protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; int num Train = get Num Instances ( ) , num Test = get Num Instances ( ) , num Classes = NUM , missing Level = NUM ; boolean [ ] result = new boolean [ NUM ] ; Instances train = null ; Instances test = null ; Classifier classifier = null ; Evaluation evaluation = null ; boolean built = BOOL ; try { train = make Test Dataset ( NUM , num Train , nominal Predictor ? get Num Nominal ( ) : NUM , numeric Predictor ? get Num Numeric ( ) : NUM , string Predictor ? get Num String ( ) : NUM , date Predictor ? get Num Date ( ) : NUM , relational Predictor ? get Num Relational ( ) : NUM , num Classes , class Type , multi Instance ) ; test = make Test Dataset ( NUM , num Test , nominal Predictor ? get Num Nominal ( ) : NUM , numeric Predictor ? get Num Numeric ( ) : NUM , string Predictor ? get Num String ( ) : NUM , date Predictor ? get Num Date ( ) : NUM , relational Predictor ? get Num Relational ( ) : NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; add Missing ( test , Math . min ( missing Level , NUM ) , predictor Missing , class Missing ) ; } classifier = Abstract Classifier . make Copies ( get Classifier ( ) , NUM ) [ NUM ] ; evaluation = new Evaluation ( train ) ; } catch ( Exception ex ) { throw new Error ( STRING + ex . get Message ( ) ) ; } try { Instances train Copy = new Instances ( train ) ; Instances test Copy = new Instances ( test ) ; classifier . build Classifier ( train Copy ) ; compare Datasets ( train , train Copy ) ; built = BOOL ; test WRT Zero R ( classifier , evaluation , train Copy , test Copy ) ; compare Datasets ( test , test Copy ) ; println ( STRING ) ; result [ NUM ] = BOOL ; } catch ( Exception ex ) { println ( STRING ) ; result [ NUM ] = BOOL ; if ( m Debug ) { println ( STRING ) ; print ( STRING ) ; if ( built ) { print ( STRING ) ; } else { print ( STRING ) ; } println ( STRING + ex . get Message ( ) + STRING ) ; println ( STRING ) ; println ( STRING + train . to String ( ) + STRING ) ; println ( STRING + test . to String ( ) + STRING ) ; } } return result ; }
public static int intersection Size ( long [ ] x , long [ ] y ) { final int lx = x . length , ly = y . length ; final int min = ( lx < ly ) ? lx : ly ; int res = NUM ; for ( int i = NUM ; i < min ; i ++ ) { res += Long . bit Count ( x [ i ] & y [ i ] ) ; } return res ; }
public void test Reverse Order 2 ( ) throws Exception { UUID id = UUID . random UUID ( ) ; Grid Cache Adapter < String , String > cache = grid . internal Cache ( ) ; Grid Cache Context < String , String > ctx = cache . context ( ) ; Grid Cache Test Entry Ex entry 1 = new Grid Cache Test Entry Ex ( ctx , STRING ) ; Grid Cache Test Entry Ex entry 2 = new Grid Cache Test Entry Ex ( ctx , STRING ) ; Grid Cache Version ver 1 = version ( NUM ) ; Grid Cache Version ver 2 = version ( NUM ) ; Grid Cache Version ver 3 = version ( NUM ) ; Grid Cache Mvcc Candidate v3 k 1 = entry 1 . add Local ( NUM , ver 3 , NUM , BOOL , BOOL ) ; Grid Cache Mvcc Candidate v3 k 2 = entry 2 . add Local ( NUM , ver 3 , NUM , BOOL , BOOL ) ; link Candidates ( ctx , v3 k 1 , v3 k 2 ) ; entry 1 . ready Local ( v3 k 1 ) ; check Local ( v3 k 1 , ver 3 , BOOL , BOOL , BOOL ) ; check Local ( v3 k 2 , ver 3 , BOOL , BOOL , BOOL ) ; Grid Cache Mvcc Candidate v2 k 1 = entry 1 . add Remote ( id , NUM , ver 2 , NUM , BOOL , BOOL ) ; Grid Cache Mvcc Candidate v2 k 2 = entry 2 . add Remote ( id , NUM , ver 2 , NUM , BOOL , BOOL ) ; check Remote ( v2 k 1 , ver 2 , BOOL , BOOL ) ; check Remote ( v2 k 2 , ver 2 , BOOL , BOOL ) ; Grid Cache Mvcc Candidate v1 k 1 = entry 1 . add Local ( NUM , ver 1 , NUM , BOOL , BOOL ) ; Grid Cache Mvcc Candidate v1 k 2 = entry 2 . add Local ( NUM , ver 1 , NUM , BOOL , BOOL ) ; link Candidates ( ctx , v1 k 1 , v1 k 2 ) ; entry 1 . ready Local ( v1 k 1 ) ; entry 2 . ready Local ( v1 k 2 ) ; check Local ( v1 k 1 , ver 1 , BOOL , BOOL , BOOL ) ; check Local ( v1 k 2 , ver 1 , BOOL , BOOL , BOOL ) ; check Local ( v3 k 2 , ver 3 , BOOL , BOOL , BOOL ) ; entry 2 . ready Local ( v3 k 2 ) ; check Local ( v3 k 2 , ver 3 , BOOL , BOOL , BOOL ) ; check Local ( v1 k 1 , ver 1 , BOOL , BOOL , BOOL ) ; check Local ( v1 k 2 , ver 1 , BOOL , BOOL , BOOL ) ; }
protected void initialize ( ) { List < Add User Fields . Attribute Spec > specs = m filter . get Attribute Specs ( ) ; m list Model = new Default List Model ( ) ; m list . set Model ( m list Model ) ; if ( specs . size ( ) > NUM ) { m up But . set Enabled ( BOOL ) ; m down But . set Enabled ( BOOL ) ; for ( Add User Fields . Attribute Spec s : specs ) { Add User Fields . Attribute Spec spec Copy = new Add User Fields . Attribute Spec ( s . to String Internal ( ) ) ; m list Model . add Element ( spec Copy ) ; } m list . repaint ( ) ; } else { m name Field . set Enabled ( BOOL ) ; m type Field . set Enabled ( BOOL ) ; m date Format Field . set Enabled ( BOOL ) ; m value Field . set Enabled ( BOOL ) ; } }
public String attributes To String ( ) { String Buffer text = new String Buffer ( ) ; int j = NUM ; for ( int i = NUM ; i < m attributes . length ; i ++ ) { if ( m attributes [ i ] ) { if ( is Gaussian ( ) ) { text . append ( STRING + i ) ; text . append ( STRING + m mean Value [ j ] ) ; text . append ( STRING + m stddev Value [ j ] + STRING ) ; } else { text . append ( STRING + i ) ; text . append ( STRING + m min Value [ j ] ) ; text . append ( STRING + m max Value [ j ] + STRING ) ; } j ++ ; } } return text . to String ( ) ; }
private static boolean is Left Outlier ( int index , Array List < Double > values ) { double current Value = values . get ( index ) ; double value To Left = values . get ( index - NUM ) ; return Math . abs ( current Value - value To Left ) > NUM ; }
@ Override public Range find Range Bounds ( XY Dataset dataset ) { if ( dataset == null ) { return null ; } double min = Double . POSITIVE INFINITY ; double max = Double . NEGATIVE INFINITY ; Table XY Dataset d = ( Table XY Dataset ) dataset ; int item Count = d . get Item Count ( ) ; for ( int i = NUM ; i < item Count ; i ++ ) { double [ ] stack Values = get Stack Values ( ( Table XY Dataset ) dataset , d . get Series Count ( ) , i ) ; min = Math . min ( min , stack Values [ NUM ] ) ; max = Math . max ( max , stack Values [ NUM ] ) ; } if ( min == Double . POSITIVE INFINITY ) { return null ; } return new Range ( min , max ) ; }
public synchronized void init Task Scheduler If Not ( ) { if ( scheduler == null ) { scheduler = Executors . new Single Thread Scheduled Executor ( Daemon Thread Factory . get Instance ( ) ) ; Capacity Aware Task Scheduler runner = new Capacity Aware Task Scheduler ( ) ; scheduler . schedule At Fixed Rate ( runner , Parallec Global Config . scheduler Init Delay , Parallec Global Config . scheduler Check Interval , Time Unit . MILLISECONDS ) ; logger . info ( STRING ) ; } }
public static boolean is String Or Similar Type ( Type type ) { if ( type instanceof Ref Type ) { Ref Type ref Type = ( Ref Type ) type ; return ref Type . equals ( Ref Type . v ( STRING ) ) || ref Type . equals ( Ref Type . v ( STRING ) ) || ref Type . equals ( Ref Type . v ( STRING ) ) || ref Type . equals ( Ref Type . v ( STRING ) ) ; } return BOOL ; }
public Entry create Root ( User user , String id , String type , String notebook Id , Long mod Time , Long create Time , Errors errors ) { if ( user == null ) { Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return null ; } if ( mod Time == null ) { Errors . add ( errors , error Messages . error Mod Time Is Null ( ) ) ; return null ; } if ( create Time == null ) { Errors . add ( errors , error Messages . error Create Time Is Null ( ) ) ; return null ; } if ( id != null && ! id Generator . is Id Well Formed ( id ) ) { Errors . add ( errors , error Messages . error Id Is Invalid ( ) ) ; return null ; } if ( notebook Id != null && ! id Generator . is Id Well Formed ( notebook Id ) ) { Errors . add ( errors , error Messages . error Notebook Id Is Invalid ( ) ) ; return null ; } if ( create Time . long Value ( ) > mod Time . long Value ( ) ) { mod Time = create Time ; } Entry root = new Entry ( ) ; root . set Db ( db ) ; if ( id == null ) { id = id Generator . get Another Id ( ) ; } root . set Id ( id ) ; root . set Create Time ( create Time ) ; root . set Mod Time ( mod Time ) ; root . set Type ( type ) ; root . set User Id ( user . get Id ( ) ) ; root . set Notebook Id ( notebook Id ) ; db . persist Entry ( root ) ; return root ; }
private void validate Jdbc Statements ( List < Jdbc Statement > jdbc Statements ) { Assert . not Null ( jdbc Statements , STRING ) ; Assert . is True ( ! jdbc Statements . is Empty ( ) , STRING ) ; Integer jdbc Max Statements = configuration Helper . get Property ( Configuration Value . JDBC MAX STATEMENTS , Integer . class ) ; if ( jdbc Max Statements != null ) { Assert . is True ( jdbc Statements . size ( ) <= jdbc Max Statements , STRING + jdbc Max Statements + STRING ) ; } for ( int i = NUM ; i < jdbc Statements . size ( ) ; i ++ ) { Jdbc Statement jdbc Statement = jdbc Statements . get ( i ) ; validate Jdbc Statement ( jdbc Statement , i ) ; } }
public static Integer [ ] values Of ( int [ ] array ) { Integer [ ] dest = new Integer [ array . length ] ; for ( int i = NUM ; i < array . length ; i ++ ) { dest [ i ] = Integer . value Of ( array [ i ] ) ; } return dest ; }
@ Override public void trace ( String msg ) { if ( logger . is Loggable ( Level . FINEST ) ) { log ( SELF , Level . FINEST , msg , null ) ; } }
protected boolean is Item Bound To Other Player ( final Player player , final RP Object object ) { if ( object instanceof Item ) { final Item item = ( Item ) object ; if ( item . is Bound ( ) && ! player . is Bound To ( item ) ) { player . send Private Text ( STRING + item . get Name ( ) + STRING + item . get Bound To ( ) + STRING ) ; return BOOL ; } } return BOOL ; }
public Base Matcher ( final Network Config config ) { if ( config == null ) { throw new Null Pointer Exception ( STRING ) ; } else { this . config = config ; } }
private int visit Nodes Rec ( Node v , Edge Map < Integer > edge Weight ) { int max Value = NUM ; for ( Edge e = v . get First Out Edge ( ) ; e != null ; e = v . get Next Out Edge ( e ) ) { if ( edge Weight . get ( e ) == null ) { edge Weight . set ( e , visit Nodes Rec ( e . get Target ( ) , edge Weight ) + NUM ) ; } max Value = Math . max ( max Value , edge Weight . get ( e ) ) ; } return max Value ; }
public void load ( Input Stream in Stream ) throws IO Exception { Properties properties = new Properties ( ) ; properties . load ( in Stream ) ; for ( Map . Entry < Object , Object > property : properties . entry Set ( ) ) { String handle Id = ( String ) property . get Key ( ) ; String value = ( String ) property . get Value ( ) ; Property Table handle Properties = new Property Table ( ) ; JSON Object json Object = ( JSON Object ) JSON Value . parse ( value ) ; if ( json Object != null ) { handle Properties . put All ( json Object ) ; } Handle handle = new Handle ( ) ; handle . set Id ( handle Id ) ; handle . set Properties ( handle Properties ) ; handles . put ( handle Id , handle ) ; } }
public static void w ( String msg , Object ... args ) { if ( ! allow W ) return ; Stack Trace Element caller = get Caller Stack Trace Element ( ) ; String tag = generate Tag ( caller ) ; if ( s Level > LEVEL WARNING ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . w ( tag , msg ) ; }
public void add Leaf ( String name , String path ) { Named Icon icon = Named Icon . get Icon By Name ( path ) ; if ( icon == null ) { log . warn ( STRING + path + STRING ) ; return ; } int h = icon . get Icon Height ( ) ; for ( int i = NUM ; i < leaves . size ( ) ; i ++ ) { Catalog Tree Leaf leaf = leaves . get ( i ) ; if ( h < leaf . get Size ( ) ) { leaves . add ( i + NUM , new Catalog Tree Leaf ( name , path , h ) ) ; return ; } } leaves . add ( new Catalog Tree Leaf ( name , path , h ) ) ; }
public void debug stack ( ) { String Buffer sb = new String Buffer ( STRING ) ; for ( int i = NUM ; i < stack . size ( ) ; i ++ ) { Symbol s = ( Symbol ) stack . element At ( i ) ; sb . append ( STRING + s . parse state + STRING + s . sym + STRING ) ; if ( ( i % NUM ) == NUM || ( i == ( stack . size ( ) - NUM ) ) ) { debug message ( sb . to String ( ) ) ; sb = new String Buffer ( STRING ) ; } } }
protected boolean prevalidate ( final String component , final Bit Set disallowed ) { if ( component == null ) { return BOOL ; } final char [ ] target = component . to Char Array ( ) ; for ( int i = NUM ; i < target . length ; i ++ ) { if ( disallowed . get ( target [ i ] ) ) { return BOOL ; } } return BOOL ; }
public void add Shutdown Hook ( Thread hook ) { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( Runtime Permission Collection . SHUTDOWN HOOKS PERMISSION ) ; } if ( hook == null ) throw new Null Pointer Exception ( STRING ) ; if ( hook . get State ( ) != Thread . State . NEW ) { throw new Illegal Argument Exception ( ) ; } if ( VM State > NUM ) { throw new Illegal State Exception ( ) ; } synchronized ( hooks List ) { if ( hooks List . contains ( hook ) ) { throw new Illegal Argument Exception ( ) ; } hooks List . add ( hook ) ; } }
protected String read Line ( ) throws IO Exception { String line = null ; if ( have Streams ( ) ) line = m in . read Line ( ) ; else line = keyboard Read Line ( ) ; set Current Line ( line ) ; return line ; }
public boolean bound Scroll Raw ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if ( Float . compare ( new Scroll , cur Scroll ) != NUM ) { set Stack Scroll Raw ( new Scroll ) ; return BOOL ; } return BOOL ; }
protected void update Numeric Scores ( double [ ] predicted , double [ ] actual , double weight ) { double diff ; double sum Err = NUM , sum Abs Err = NUM , sum Sqr Err = NUM ; double sum Prior Abs Err = NUM , sum Prior Sqr Err = NUM ; for ( int i = NUM ; i < m Num Classes ; i ++ ) { diff = predicted [ i ] - actual [ i ] ; sum Err += diff ; sum Abs Err += Math . abs ( diff ) ; sum Sqr Err += diff * diff ; diff = ( m Class Priors [ i ] / m Class Priors Sum ) - actual [ i ] ; sum Prior Abs Err += Math . abs ( diff ) ; sum Prior Sqr Err += diff * diff ; } m Sum Err += weight * sum Err / m Num Classes ; m Sum Abs Err += weight * sum Abs Err / m Num Classes ; m Sum Sqr Err += weight * sum Sqr Err / m Num Classes ; m Sum Prior Abs Err += weight * sum Prior Abs Err / m Num Classes ; m Sum Prior Sqr Err += weight * sum Prior Sqr Err / m Num Classes ; }
public void test Min Wait Interval Configuration Parameter ( ) throws Exception { System . set Property ( Stack Properties . FIRST CTRAN RETRANS AFTER , STRING ) ; System . set Property ( Stack Properties . PROPAGATE RECEIVED RETRANSMISSIONS , STRING ) ; stun Stack . add Request Listener ( server Address , request Collector ) ; stun Stack . send Request ( binding Request , server Address , client Address , response Collector ) ; request Collector . wait For Request ( ) ; Vector < ? > reqs = request Collector . get Requests For Transaction ( binding Request . get Transaction ID ( ) ) ; assert True ( STRING , reqs . size ( ) < NUM ) ; Thread . sleep ( NUM ) ; reqs = request Collector . get Requests For Transaction ( binding Request . get Transaction ID ( ) ) ; assert Equals ( STRING , NUM , reqs . size ( ) ) ; }
protected void process Start Arg ( final String key , final String value , final Map < String , Object > options , final List < String > vm Args , final Properties props ) throws Exception { props . set Property ( key , value ) ; }
public boolean dispatch ( boolean complete ) throws IO Exception , XNI Exception { try { boolean again ; do { again = BOOL ; switch ( f Scanner State ) { case SCANNER STATE CONTENT : { if ( f Entity Scanner . skip Char ( STRING ) ) { set Scanner State ( SCANNER STATE START OF MARKUP ) ; again = BOOL ; } else if ( f Entity Scanner . skip Char ( STRING ) ) { set Scanner State ( SCANNER STATE REFERENCE ) ; again = BOOL ; } else { do { int c = scan Content ( ) ; if ( c == STRING ) { f Entity Scanner . scan Char ( ) ; set Scanner State ( SCANNER STATE START OF MARKUP ) ; break ; } else if ( c == STRING ) { f Entity Scanner . scan Char ( ) ; set Scanner State ( SCANNER STATE REFERENCE ) ; break ; } else if ( c != - NUM && is Invalid Literal ( c ) ) { if ( XML Char . is High Surrogate ( c ) ) { f String Buffer . clear ( ) ; if ( scan Surrogates ( f String Buffer ) ) { if ( f Document Handler != null ) { f Document Handler . characters ( f String Buffer , null ) ; } } } else { report Fatal Error ( STRING , new Object [ ] { Integer . to String ( c , NUM ) } ) ; f Entity Scanner . scan Char ( ) ; } } } while ( complete ) ; } break ; } case SCANNER STATE START OF MARKUP : { f Markup Depth ++ ; if ( f Entity Scanner . skip Char ( STRING ) ) { if ( scan End Element ( ) == NUM ) { if ( element Depth Is Zero Hook ( ) ) { return BOOL ; } } set Scanner State ( SCANNER STATE CONTENT ) ; } else if ( is Valid Name Start Char ( f Entity Scanner . peek Char ( ) ) ) { scan Start Element ( ) ; set Scanner State ( SCANNER STATE CONTENT ) ; } else if ( f Entity Scanner . skip Char ( STRING ) ) { if ( f Entity Scanner . skip Char ( STRING ) ) { if ( ! f Entity Scanner . skip Char ( STRING ) ) { report Fatal Error ( STRING , null ) ; } set Scanner State ( SCANNER STATE COMMENT ) ; again = BOOL ; } else if ( f Entity Scanner . skip String ( STRING ) ) { set Scanner State ( SCANNER STATE CDATA ) ; again = BOOL ; } else if ( ! scan For Doctype Hook ( ) ) { report Fatal Error ( STRING , null ) ; } } else if ( f Entity Scanner . skip Char ( STRING ) ) { set Scanner State ( SCANNER STATE PI ) ; again = BOOL ; } else if ( is Valid Name Start High Surrogate ( f Entity Scanner . peek Char ( ) ) ) { scan Start Element ( ) ; set Scanner State ( SCANNER STATE CONTENT ) ; } else { report Fatal Error ( STRING , null ) ; set Scanner State ( SCANNER STATE CONTENT ) ; } break ; } case SCANNER STATE COMMENT : { scan Comment ( ) ; set Scanner State ( SCANNER STATE CONTENT ) ; break ; } case SCANNER STATE PI : { scan PI ( ) ; set Scanner State ( SCANNER STATE CONTENT ) ; break ; } case SCANNER STATE CDATA : { scan CDATA Section ( complete ) ; set Scanner State ( SCANNER STATE CONTENT ) ; break ; } case SCANNER STATE REFERENCE : { f Markup Depth ++ ; set Scanner State ( SCANNER STATE CONTENT ) ; if ( f Entity Scanner . skip Char ( STRING ) ) { scan Char Reference ( ) ; } else { scan Entity Reference ( ) ; } break ; } case SCANNER STATE TEXT DECL : { if ( f Entity Scanner . skip String ( STRING ) ) { f Markup Depth ++ ; if ( is Valid Name Char ( f Entity Scanner . peek Char ( ) ) ) { f String Buffer . clear ( ) ; f String Buffer . append ( STRING ) ; if ( f Namespaces ) { while ( is Valid NC Name ( f Entity Scanner . peek Char ( ) ) ) { f String Buffer . append ( ( char ) f Entity Scanner . scan Char ( ) ) ; } } else { while ( is Valid Name Char ( f Entity Scanner . peek Char ( ) ) ) { f String Buffer . append ( ( char ) f Entity Scanner . scan Char ( ) ) ; } } String target = f Symbol Table . add Symbol ( f String Buffer . ch , f String Buffer . offset , f String Buffer . length ) ; scan PI Data ( target , f Temp String ) ; } else { scan XML Decl Or Text Decl ( BOOL ) ; } } f Entity Manager . f Current Entity . may Read Chunks = BOOL ; set Scanner State ( SCANNER STATE CONTENT ) ; break ; } case SCANNER STATE ROOT ELEMENT : { if ( scan Root Element Hook ( ) ) { return BOOL ; } set Scanner State ( SCANNER STATE CONTENT ) ; break ; } case SCANNER STATE DOCTYPE : { report Fatal Error ( STRING , null ) ; set Scanner State ( SCANNER STATE CONTENT ) ; } } } while ( complete || again ) ; } catch ( Malformed Byte Sequence Exception e ) { f Error Reporter . report Error ( e . get Domain ( ) , e . get Key ( ) , e . get Arguments ( ) , XML Error Reporter . SEVERITY FATAL ERROR , e ) ; return BOOL ; } catch ( Char Conversion Exception e ) { f Error Reporter . report Error ( XML Message Formatter . XML DOMAIN , STRING , null , XML Error Reporter . SEVERITY FATAL ERROR , e ) ; return BOOL ; } catch ( EOF Exception e ) { end Of File Hook ( e ) ; return BOOL ; } return BOOL ; }
public void paint ( final Graphics g ) { g . draw Image ( image , NUM , NUM , this ) ; synchronized ( this ) { if ( ! paint Called ) { paint Called = BOOL ; notify All ( ) ; } } }
@ Override public boolean connection Allowed ( String event Name ) { if ( m listenees . contains Key ( event Name ) ) { return BOOL ; } if ( m listenees . contains Key ( STRING ) && ( event Name . compare To ( STRING ) == NUM || event Name . compare To ( STRING ) == NUM || event Name . compare To ( STRING ) == NUM ) ) { return BOOL ; } if ( ( m listenees . contains Key ( STRING ) || m listenees . contains Key ( STRING ) ) && ( event Name . compare To ( STRING ) == NUM || event Name . compare To ( STRING ) == NUM ) ) { return BOOL ; } if ( m listenees . contains Key ( STRING ) && ( event Name . compare To ( STRING ) == NUM || event Name . compare To ( STRING ) == NUM || event Name . compare To ( STRING ) == NUM ) ) { return BOOL ; } if ( event Name . compare To ( STRING ) == NUM && ! ( m Filter instanceof Streamable Filter ) ) { return BOOL ; } return BOOL ; }
public boolean is Prefixed ( ) { return tag . index Of ( STRING ) >= NUM ; }
protected void close ( Connection connection , Statement statement , Result Set result Set ) { try { if ( result Set != null ) { result Set . close ( ) ; } } catch ( SQL Exception ex ) { LOGGER . error ( STRING , ex ) ; } try { if ( statement != null ) { statement . close ( ) ; } } catch ( SQL Exception ex ) { LOGGER . error ( STRING , ex ) ; } try { if ( connection != null ) { connection . close ( ) ; } } catch ( SQL Exception ex ) { LOGGER . error ( STRING , ex ) ; } }
public static void register Context Menu Action ( Class < ? > associated Class , Selection Dependent Action action ) { List < Selection Dependent Action > actions = context Menu Actions . get ( associated Class ) ; if ( actions == null ) { actions = new Linked List < Selection Dependent Action > ( ) ; context Menu Actions . put ( associated Class , actions ) ; } actions . add ( action ) ; }
@ Safe Varargs protected < T extends Abstract Option Value < ? , ? > > Abstract Options ( Function < T , T > value Filter , Abstract Options base Options , T ... values ) { require Non Null ( base Options , STRING ) ; require Non Null ( value Filter , STRING ) ; require Non Null ( values , STRING ) ; value Map = new Identity Hash Map < > ( base Options . value Map ) ; put All ( value Filter , Stream . of ( values ) ) ; }
public int compare To ( Char Seq another ) { return str . compare To ( another . str ) ; }
@ Override protected void do Post ( Sling Http Servlet Request request , Sling Http Servlet Response response ) throws Servlet Exception , IO Exception { response . set Content Type ( STRING ) ; Print Writer writer = response . get Writer ( ) ; boolean not Robot = recaptcha Service . validate ( request ) ; if ( not Robot ) { final String submitter Name = request . get Parameter ( STRING ) ; final String submitter Email = request . get Parameter ( STRING ) ; final String submitter Message = request . get Parameter ( STRING ) ; if ( String Utils . is Not Empty ( submitter Name ) && String Utils . is Not Empty ( submitter Name ) && String Utils . is Not Empty ( submitter Name ) ) { final String body = String . format ( BODY , submitter Name , submitter Email , submitter Message ) ; final boolean result = email Service . send Mail ( SUBJECT , body ) ; if ( result ) { response . set Status ( Sling Http Servlet Response . SC OK ) ; send Response ( writer , Sling Http Servlet Response . SC OK , STRING ) ; } else { response . set Status ( Sling Http Servlet Response . SC INTERNAL SERVER ERROR ) ; send Response ( writer , Sling Http Servlet Response . SC INTERNAL SERVER ERROR , STRING ) ; } } else { response . set Status ( Sling Http Servlet Response . SC INTERNAL SERVER ERROR ) ; send Response ( writer , Sling Http Servlet Response . SC INTERNAL SERVER ERROR , STRING ) ; } } else { response . set Status ( Sling Http Servlet Response . SC INTERNAL SERVER ERROR ) ; send Response ( writer , Sling Http Servlet Response . SC INTERNAL SERVER ERROR , STRING ) ; } }
protected void new Commanded State ( int s ) { if ( commanded State != s ) { int old State = commanded State ; commanded State = s ; fire Property Change ( STRING , Integer . value Of ( old State ) , Integer . value Of ( commanded State ) ) ; } }
private void format And Log Arguments ( Logging Level level , Color color , String msg , Object [ ] args ) { if ( ! USE COLORS ) { format And Log Arguments ( level , msg , args ) ; return ; } if ( Photon Logger . level . id < level . id ) { return ; } Local Date Time date Time = Local Date Time . now ( ) ; Formatting Tuple ft = Message Formatter . array Format ( msg , args ) ; String formatted = format Log Line ( level , date Time , ft . get Message ( ) ) ; Throwable t = ft . get Throwable ( ) ; if ( t == null ) { Logging Service . log Line ( date Time , formatted , color ) ; } else { Logging Service . log Throwable ( date Time , t , formatted , color ) ; } }
public static String construct Job Id Redis Key ( String queue Name , String shard Name ) { return String . format ( STRING , PINLATER JOB ID KEY PREFIX , shard Name , queue Name ) ; }
public static boolean is Ascii ( String s ) { if ( s == null ) { return BOOL ; } try { if ( ! s . equals ( new String ( s . get Bytes ( ASCII CHARSET ) , ASCII CHARSET ) ) ) { return BOOL ; } } catch ( java . io . Unsupported Encoding Exception uee ) { return BOOL ; } return BOOL ; }
public void add Permitted Domain ( String domain Name ) { if ( String Utils . is Empty ( domain Name ) ) { return ; } if ( permitted Domains == null ) { permitted Domains = new Array List < > ( ) ; } permitted Domains . add ( domain Name ) ; }
public Stoppable Write Lock ( Read Write Lock lock , Cancel Criterion stopper ) { this . lock = lock . write Lock ( ) ; this . stopper = stopper ; }
private long compute Method Hash ( ) { long hash = NUM ; Byte Array Output Stream sink = new Byte Array Output Stream ( NUM ) ; try { Message Digest md = Message Digest . get Instance ( STRING ) ; Data Output Stream out = new Data Output Stream ( new Digest Output Stream ( sink , md ) ) ; String method String = name And Descriptor ( ) ; out . write UTF ( method String ) ; out . flush ( ) ; byte hash Array [ ] = md . digest ( ) ; for ( int i = NUM ; i < Math . min ( NUM , hash Array . length ) ; i ++ ) { hash += ( ( long ) ( hash Array [ i ] & NUM ) ) << ( i * NUM ) ; } } catch ( IO Exception e ) { throw new Assertion Error ( e ) ; } catch ( No Such Algorithm Exception e ) { throw new Assertion Error ( e ) ; } return hash ; }
public Gif Sequence Writer ( Image Output Stream output Stream , int image Type , int time Between Frames MS , boolean loop Continuously ) throws IIO Exception , IO Exception { gif Writer = get Writer ( ) ; image Write Param = gif Writer . get Default Write Param ( ) ; Image Type Specifier image Type Specifier = Image Type Specifier . create From Buffered Image Type ( image Type ) ; image Meta Data = gif Writer . get Default Image Metadata ( image Type Specifier , image Write Param ) ; String meta Format Name = image Meta Data . get Native Metadata Format Name ( ) ; IIO Metadata Node root = ( IIO Metadata Node ) image Meta Data . get As Tree ( meta Format Name ) ; IIO Metadata Node graphics Control Extension Node = get Node ( root , STRING ) ; graphics Control Extension Node . set Attribute ( STRING , STRING ) ; graphics Control Extension Node . set Attribute ( STRING , STRING ) ; graphics Control Extension Node . set Attribute ( STRING , STRING ) ; graphics Control Extension Node . set Attribute ( STRING , Integer . to String ( time Between Frames MS / NUM ) ) ; graphics Control Extension Node . set Attribute ( STRING , STRING ) ; IIO Metadata Node comments Node = get Node ( root , STRING ) ; comments Node . set Attribute ( STRING , STRING ) ; IIO Metadata Node app Entensions Node = get Node ( root , STRING ) ; IIO Metadata Node child = new IIO Metadata Node ( STRING ) ; child . set Attribute ( STRING , STRING ) ; child . set Attribute ( STRING , STRING ) ; int loop = loop Continuously ? NUM : NUM ; child . set User Object ( new byte [ ] { NUM , ( byte ) ( loop & NUM ) , ( byte ) ( ( loop > > NUM ) & NUM ) } ) ; app Entensions Node . append Child ( child ) ; image Meta Data . set From Tree ( meta Format Name , root ) ; gif Writer . set Output ( output Stream ) ; gif Writer . prepare Write Sequence ( null ) ; }
private void listener Dropped ( Array List drops , Array List notifies ) { Service Registrar [ ] proxys = new Service Registrar [ drops . size ( ) ] ; drops . to Array ( proxys ) ; listener Dropped ( proxys , notifies ) ; }
public static boolean parse Float Attribute ( @ Not Null String value , Typed Value out Value , boolean require Unit ) { value = value . trim ( ) ; int len = value . length ( ) ; if ( len <= NUM ) { return BOOL ; } char [ ] buf = value . to Char Array ( ) ; for ( int i = NUM ; i < len ; i ++ ) { if ( buf [ i ] > NUM ) { return BOOL ; } } if ( ( buf [ NUM ] < STRING || buf [ NUM ] > STRING ) && buf [ NUM ] != STRING && buf [ NUM ] != STRING && buf [ NUM ] != STRING ) { return BOOL ; } Matcher m = s Float Pattern . matcher ( value ) ; if ( m . matches ( ) ) { String f str = m . group ( NUM ) ; String end = m . group ( NUM ) ; float f ; try { f = Float . parse Float ( f str ) ; } catch ( Number Format Exception e ) { return BOOL ; } if ( end . length ( ) > NUM && end . char At ( NUM ) != STRING ) { if ( parse Unit ( end , out Value , s Float Out ) ) { compute Typed Value ( out Value , f , s Float Out [ NUM ] ) ; return BOOL ; } return BOOL ; } end = end . trim ( ) ; if ( end . length ( ) == NUM ) { if ( out Value != null ) { if ( ! require Unit ) { out Value . type = Typed Value . TYPE FLOAT ; out Value . data = Float . float To Int Bits ( f ) ; } else { apply Unit ( s Unit Names [ NUM ] , out Value , s Float Out ) ; compute Typed Value ( out Value , f , s Float Out [ NUM ] ) ; LOG . warn ( String . format ( DIMENSION ERROR FORMAT , value ) ) ; } return BOOL ; } } } return BOOL ; }
public void make Primary ( Client Proxy Membership ID proxy Id , boolean is Client Ready ) { Cache Client Proxy proxy = get Client Proxy ( proxy Id ) ; if ( proxy != null ) { proxy . set Primary ( BOOL ) ; if ( is Client Ready || ! proxy . is Durable ( ) ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING , proxy ) ; } proxy . start Or Resume Message Dispatcher ( BOOL ) ; } } else { throw new Internal Gem Fire Error ( STRING + proxy Id ) ; } }
public void add Nodes In Doc Order ( Node Iterator iterator , X Path Context support ) { if ( ! m mutable ) throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NODESET NOT MUTABLE , null ) ) ; Node node ; while ( null != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
@ Override public boolean test ( T value ) { long now = System . current Time Millis ( ) ; if ( now < next True Time Millis ) return BOOL ; else synchronized ( this ) { last True Time Millis = now ; next True Time Millis = now + deadtime Period Millis ; return BOOL ; } }
public void test Create Document Type 1 ( ) throws Throwable { Document doc ; DOM Implementation dom Impl ; Document Type new Doc Type ; Document owner Document ; String qualified Name = STRING ; String public Id ; String system Id ; List < String > public Ids = new Array List < String > ( ) ; public Ids . add ( STRING ) ; public Ids . add ( STRING ) ; List < String > system Ids = new Array List < String > ( ) ; system Ids . add ( STRING ) ; system Ids . add ( STRING ) ; doc = ( Document ) load ( STRING , builder ) ; dom Impl = doc . get Implementation ( ) ; for ( int index N 1005 D = NUM ; index N 1005 D < public Ids . size ( ) ; index N 1005 D ++ ) { public Id = ( String ) public Ids . get ( index N 1005 D ) ; for ( int index N 10061 = NUM ; index N 10061 < system Ids . size ( ) ; index N 10061 ++ ) { system Id = ( String ) system Ids . get ( index N 10061 ) ; new Doc Type = dom Impl . create Document Type ( qualified Name , public Id , system Id ) ; assert Not Null ( STRING , new Doc Type ) ; owner Document = new Doc Type . get Owner Document ( ) ; assert Null ( STRING , owner Document ) ; } } }
public void handle Request ( Request Context rc ) throws CLI Exception { super . handle Request ( rc ) ; ldap Login ( ) ; SSO Token admin SSO Token = get Admin SSO Token ( ) ; I Output output Writer = get Output Writer ( ) ; String realm = get String Option Value ( I Argument . REALM NAME ) ; String pattern Type = get String Option Value ( I Argument . AGENT TYPE ) ; String filter = get String Option Value ( I Argument . FILTER ) ; if ( pattern Type == null ) { pattern Type = STRING ; } if ( ( filter == null ) || ( filter . length ( ) == NUM ) ) { filter = STRING ; } String [ ] params = { realm , pattern Type , filter } ; write Log ( Log Writer . LOG ACCESS , Level . INFO , STRING , params ) ; try { AM Identity Repository amir = new AM Identity Repository ( admin SSO Token , realm ) ; Id Search Results isr = amir . search Identities ( Id Type . AGENTGROUP , filter , new Id Search Control ( ) ) ; Set results = isr . get Search Results ( ) ; if ( ( results != null ) && ! results . is Empty ( ) ) { for ( Iterator i = results . iterator ( ) ; i . has Next ( ) ; ) { AM Identity amid = ( AM Identity ) i . next ( ) ; if ( ! match Type ( amid , pattern Type ) ) { i . remove ( ) ; } } } if ( ( results != null ) && ! results . is Empty ( ) ) { for ( Iterator i = results . iterator ( ) ; i . has Next ( ) ; ) { AM Identity amid = ( AM Identity ) i . next ( ) ; Object [ ] args = { amid . get Name ( ) , amid . get Universal Id ( ) } ; output Writer . println Message ( Message Format . format ( get Resource String ( STRING ) , args ) ) ; } } else { output Writer . println Message ( get Resource String ( STRING ) ) ; } write Log ( Log Writer . LOG ACCESS , Level . INFO , STRING , params ) ; } catch ( Id Repo Exception e ) { String [ ] args = { realm , pattern Type , filter , e . get Message ( ) } ; debug Error ( STRING , e ) ; write Log ( Log Writer . LOG ERROR , Level . INFO , STRING , args ) ; throw new CLI Exception ( e , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } catch ( SSO Exception e ) { String [ ] args = { realm , pattern Type , filter , e . get Message ( ) } ; debug Error ( STRING , e ) ; write Log ( Log Writer . LOG ERROR , Level . INFO , STRING , args ) ; throw new CLI Exception ( e , Exit Codes . REQUEST CANNOT BE PROCESSED ) ; } }
public static byte [ ] serialize ( Object obj ) { try { Byte Array Output Stream out = new Byte Array Output Stream ( ) ; Object Output Stream os = new Object Output Stream ( out ) ; os . write Object ( obj ) ; return out . to Byte Array ( ) ; } catch ( Throwable e ) { throw Data Utils . new Illegal Argument Exception ( STRING , obj , e ) ; } }
public static void check Field Value From Enum ( final String value , final String field Name , Class < ? extends Enum > enum Type ) { if ( value != null ) { check Field Value From Enum ( value , field Name , Enum Set . all Of ( enum Type ) ) ; } }
@ HLE Function ( nid = NUM , version = NUM ) public int sce Net Apctl Del Handler ( int handler Id ) { if ( ! apctl Handlers . contains Key ( handler Id ) ) { log . warn ( String . format ( STRING , handler Id ) ) ; return - NUM ; } Sce Uid Manager . release Uid ( handler Id , uid Purpose ) ; apctl Handlers . remove ( handler Id ) ; return NUM ; }
private void reuse Existing Export Mask ( Map < URI , Integer > block Object Map , Storage System vplex System , Export Group export Group , URI varray Uri , List < Export Mask > export Masks To Update On Device , Map < URI , List < URI > > export Masks To Update On Device With Storage Ports , List < Initiator > inits , boolean all Ports From Mask Match For Varray , Export Mask vipr Export Mask , String op Id ) { export Masks To Update On Device . add ( vipr Export Mask ) ; export Group . add Export Mask ( vipr Export Mask . get Id ( ) ) ; db Client . update Object ( export Group ) ; Export Path Params path Params = block Scheduler . calculate Export Path Param For Volumes ( block Object Map . key Set ( ) , export Group . get Num Paths ( ) , vplex System . get Id ( ) , export Group . get Id ( ) ) ; if ( export Group . get Type ( ) != null ) { path Params . set Export Group Type ( export Group . get Type ( ) ) ; } if ( ! all Ports From Mask Match For Varray ) { Map < URI , List < URI > > assignments = block Scheduler . assign Storage Ports ( vplex System , export Group , inits , vipr Export Mask . get Zoning Map ( ) , path Params , null , network Device Controller , varray Uri , op Id ) ; if ( assignments != null && ! assignments . is Empty ( ) ) { vipr Export Mask = Export Utils . update Zoning Map ( db Client , vipr Export Mask , assignments , export Masks To Update On Device With Storage Ports ) ; } } }
public synchronized boolean remove First ( K obj ) { if ( peek First ( ) != obj ) { return BOOL ; } int len = array . length ; @ Suppress Warnings ( STRING ) K [ ] a = ( K [ ] ) new Object [ len - NUM ] ; System . arraycopy ( array , NUM , a , NUM , len - NUM ) ; array = a ; return BOOL ; }
public void write ( Image c , Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . get Width ( null ) * NUM / NUM + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= pr First ) { page . draw Image ( c , x , y , c . get Width ( null ) * NUM / NUM , c . get Height ( null ) * NUM / NUM , null ) ; } }
public static void copy ( Resource in , Output Stream os , boolean close OS ) throws IO Exception { Input Stream is = null ; try { is = to Buffered Input Stream ( in . get Input Stream ( ) ) ; } catch ( IO Exception ioe ) { IO Util . close EL ( is ) ; throw ioe ; } copy ( is , os , BOOL , close OS ) ; }
public String trim Audio ( String path , double start , double length ) throws Exception { Array List < String > cmd = new Array List < String > ( ) ; File file = new File ( path ) ; String out File = file . get Canonical Path ( ) + STRING ; cmd . add ( sox Bin ) ; cmd . add ( path ) ; cmd . add ( STRING ) ; cmd . add ( STRING ) ; cmd . add ( STRING ) ; cmd . add ( STRING ) ; cmd . add ( out File ) ; cmd . add ( STRING ) ; cmd . add ( start + STRING ) ; if ( length != - NUM ) cmd . add ( length + STRING ) ; int rc = exec Sox ( cmd , callback ) ; if ( rc != NUM ) { out File = null ; } if ( file . exists ( ) ) return out File ; else return null ; }
public boolean draw ( Canvas canvas ) { update ( ) ; final int glow Height = m Glow . get Intrinsic Height ( ) ; final float dist Scale = ( float ) m Height / m Width ; m Glow . set Alpha ( ( int ) ( Math . max ( NUM , Math . min ( m Glow Alpha , NUM ) ) * NUM ) ) ; m Glow . set Bounds ( NUM , NUM , m Width , ( int ) Math . min ( glow Height * m Glow Scale Y * dist Scale * NUM , m Height * MAX GLOW HEIGHT ) ) ; m Glow . draw ( canvas ) ; if ( m Edge != null ) { final int edge Height = m Edge . get Intrinsic Height ( ) ; m Edge . set Alpha ( ( int ) ( Math . max ( NUM , Math . min ( m Edge Alpha , NUM ) ) * NUM ) ) ; m Edge . set Bounds ( NUM , NUM , m Width , ( int ) ( edge Height * m Edge Scale Y ) ) ; m Edge . draw ( canvas ) ; } return m State != STATE IDLE ; }
protected Plugin Specification specify Plugin ( String prefix , String name ) throws Replicator Exception { String plugin Prefix = prefix + STRING + name . trim ( ) ; String raw Class Name = properties . get String ( plugin Prefix ) ; if ( raw Class Name == null ) throw new Replicator Exception ( STRING + plugin Prefix ) ; String plugin Class Name = raw Class Name . trim ( ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + plugin Prefix + STRING + plugin Class Name ) ; Tungsten Properties plugin Properties = properties . subset ( plugin Prefix + STRING , BOOL ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + plugin Properties . to String ( ) ) ; Class < ? > plugin Class ; try { plugin Class = Plugin Loader . load Class ( plugin Class Name ) ; } catch ( Plugin Exception e ) { throw new Replicator Exception ( STRING + plugin Prefix + STRING + plugin Class Name , e ) ; } return new Plugin Specification ( plugin Prefix , name , plugin Class , plugin Properties ) ; }
static String serialize Node Value ( Object value ) { String str Value ; if ( value == null ) { str Value = null ; } else if ( value instanceof Boolean ) { str Value = XMP Utils . convert From Boolean ( ( boolean ) value ) ; } else if ( value instanceof Integer ) { str Value = XMP Utils . convert From Integer ( ( int ) value ) ; } else if ( value instanceof Long ) { str Value = XMP Utils . convert From Long ( ( long ) value ) ; } else if ( value instanceof Double ) { str Value = XMP Utils . convert From Double ( ( double ) value ) ; } else if ( value instanceof XMP Date Time ) { str Value = XMP Utils . convert From Date ( ( XMP Date Time ) value ) ; } else if ( value instanceof Gregorian Calendar ) { XMP Date Time dt = XMP Date Time Factory . create From Calendar ( ( Gregorian Calendar ) value ) ; str Value = XMP Utils . convert From Date ( dt ) ; } else if ( value instanceof byte [ ] ) { str Value = XMP Utils . encode Base 64 ( ( byte [ ] ) value ) ; } else { str Value = value . to String ( ) ; } return str Value != null ? Utils . remove Control Chars ( str Value ) : null ; }
public boolean remove Sticky Event ( Object event ) { synchronized ( sticky Events ) { Class < ? extends Object > event Type = event . get Class ( ) ; Object existing Event = sticky Events . get ( event Type ) ; if ( event . equals ( existing Event ) ) { sticky Events . remove ( event Type ) ; return BOOL ; } else { return BOOL ; } } }
public int read ( char ch [ ] , int offset , int length ) throws IO Exception { if ( length > f Buffer . length ) { length = f Buffer . length ; } int count = f Input Stream . read ( f Buffer , NUM , length ) ; for ( int i = NUM ; i < count ; i ++ ) { int b0 = f Buffer [ i ] ; if ( b0 < NUM ) { throw new IO Exception ( Localizer . get Message ( STRING , Integer . to String ( b0 ) ) ) ; } ch [ offset + i ] = ( char ) b0 ; } return count ; }
protected void create y axis ( int i , String y , int size ) { float ver height = ( ( graphheight / size ) * i ) + border ; Log . e ( STRING , i + STRING + size + STRING + height + STRING + graphheight + STRING + ver height ) ; if ( i == size ) canvas . draw Line ( horstart , ver height , width - ( border ) , ver height , paint ) ; else canvas . draw Line ( horstart , ver height , border , ver height , paint ) ; paint . set Color ( Color . BLACK ) ; paint . set Text Align ( Paint . Align . RIGHT ) ; canvas . draw Text ( y + STRING , horstart - NUM , ver height - NUM , paint ) ; paint . set Text Align ( Paint . Align . LEFT ) ; }
void update ( long time , int rows ) { count ++ ; execution Time Min = Math . min ( time , execution Time Min ) ; execution Time Max = Math . max ( time , execution Time Max ) ; row Count Min = Math . min ( rows , row Count Min ) ; row Count Max = Math . max ( rows , row Count Max ) ; double delta = rows - row Count Mean ; row Count Mean += delta / count ; row Count M 2 += delta * ( rows - row Count Mean ) ; delta = time - execution Time Mean ; execution Time Mean += delta / count ; execution Time M 2 += delta * ( time - execution Time Mean ) ; execution Time Cumulative += time ; row Count Cumulative += rows ; last Update Time = System . current Time Millis ( ) ; }
static void check Access ( Management Permission p ) throws Security Exception { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( p ) ; } }
public void add ( Collection < Rule Grounding > alternatives ) { boolean found Success = BOOL ; for ( Rule Grounding g : alternatives ) { if ( ! g . is Failed ( ) ) { add ( g ) ; found Success = BOOL ; } } if ( ! found Success ) { groundings . clear ( ) ; } }
public static Pattern convert Perl Regex To Pattern ( @ Nonnull final String regex , @ Nonnull final boolean fault Tolerant ) { Check . not Null ( regex , STRING ) ; String pattern = regex . trim ( ) ; final Matcher matcher = fault Tolerant ? PERL STYLE TOLERANT . matcher ( pattern ) : PERL STYLE . matcher ( pattern ) ; if ( ! matcher . matches ( ) ) { throw new Illegal Argument Exception ( STRING + pattern + STRING ) ; } pattern = pattern . substring ( NUM ) ; final int last Index = pattern . last Index Of ( STRING ) ; pattern = pattern . substring ( NUM , last Index ) ; final int flags = Flag . convert To Bitmask ( Flag . parse ( matcher . group ( NUM ) ) ) ; return Pattern . compile ( pattern , flags ) ; }
public void test Procedure Columns ( ) throws Exception { try { Statement stmt = con . create Statement ( ) ; stmt . execute ( STRING + STRING + STRING + STRING ) ; stmt . close ( ) ; Database Meta Data dbmd = con . get Meta Data ( ) ; String [ ] column Patterns = new String [ ] { null , STRING } ; for ( int i = NUM ; i < column Patterns . length ; i ++ ) { Result Set rs = dbmd . get Procedure Columns ( null , null , STRING , column Patterns [ i ] ) ; assert True ( rs . next ( ) ) ; Assert . assert Equals ( STRING , rs . get String ( STRING ) ) ; Assert . assert Equals ( Database Meta Data . procedure Column Return , rs . get Int ( STRING ) ) ; assert True ( rs . next ( ) ) ; Assert . assert Equals ( STRING , rs . get String ( STRING ) ) ; Assert . assert Equals ( Database Meta Data . procedure Column In , rs . get Int ( STRING ) ) ; assert True ( rs . next ( ) ) ; Assert . assert Equals ( STRING , rs . get String ( STRING ) ) ; Assert . assert Equals ( Database Meta Data . procedure Column In Out , rs . get Int ( STRING ) ) ; rs . close ( ) ; } } finally { } }
public Object [ ] build Parameters ( Object [ ] first Parameters , Method method , Class < ? extends Annotation > annotation Type ) { int parameters Length = method . get Parameter Types ( ) . length ; if ( first Parameters . length > NUM && parameters Length < NUM ) { throw new Repository Method Exception ( String . format ( STRING , annotation Type ) ) ; } int parameters To Resolve = parameters Length - first Parameters . length ; Object [ ] additional Parameters = new Object [ parameters To Resolve ] ; for ( int i = first Parameters . length ; i < parameters Length ; i ++ ) { additional Parameters [ i - first Parameters . length ] = parameter Provider . provide ( method , i ) ; } return concatenate ( first Parameters , additional Parameters ) ; }
public static Method Annotation convert Method Annotation ( Class Name Rewriter class Name Rewriter , Method Annotation annotation ) { if ( class Name Rewriter != Identity Class Name Rewriter . instance ( ) ) { annotation = new Method Annotation ( class Name Rewriter . rewrite Class Name ( annotation . get Class Name ( ) ) , annotation . get Method Name ( ) , rewrite Method Signature ( class Name Rewriter , annotation . get Method Signature ( ) ) , annotation . is Static ( ) ) ; } return annotation ; }
public boolean resource Exist ( Integer id ) { if ( id == null ) { return BOOL ; } return resource Exist ( id . int Value ( ) ) ; }
public Create Window Clause add View ( String namespace , String name , List < Expression > parameters ) { views . add ( View . create ( namespace , name , parameters ) ) ; return this ; }
static public Timestamp add Minutess ( Timestamp date Time , int offset ) { if ( date Time == null ) date Time = new Timestamp ( System . current Time Millis ( ) ) ; if ( offset == NUM ) return date Time ; Gregorian Calendar cal = new Gregorian Calendar ( ) ; cal . set Time ( date Time ) ; cal . add ( Calendar . MINUTE , offset ) ; return new Timestamp ( cal . get Time In Millis ( ) ) ; }
public void row Changed ( boolean save , int key ID ) { if ( m tree == null || key ID <= NUM ) return ; String name = ( String ) m m Tab . get Value ( STRING ) ; String description = ( String ) m m Tab . get Value ( STRING ) ; Boolean Is Summary = ( Boolean ) m m Tab . get Value ( STRING ) ; boolean summary = Is Summary != null && Is Summary . boolean Value ( ) ; String image Indicator = ( String ) m m Tab . get Value ( STRING ) ; m tree . node Changed ( save , key ID , name , description , summary , image Indicator ) ; }
public Stream Impl open Read Impl ( Path Impl path ) throws IO Exception { String path Name = path . get Path ( ) ; return open Read Impl ( path Name ) ; }
@ Override protected void on Activity Result ( int request Code , int result Code , Intent data ) { super . on Activity Result ( request Code , result Code , data ) ; if ( Build Config . DEBUG ) Log . v ( STRING ) ; if ( request Code == VOICE RECOGNITION REQUEST CODE && result Code == RESULT OK ) { Array List < String > matches = data . get String Array List Extra ( Recognizer Intent . EXTRA RESULTS ) ; if ( Build Config . DEBUG ) Log . v ( STRING + matches . get ( NUM ) ) ; quick Reply ( matches . get ( NUM ) ) ; } }
public synchronized OM Graphic List prepare ( ) { if ( spatial Indexes == null || spatial Indexes . is Empty ( ) ) { logger . fine ( get Name ( ) + STRING ) ; return new OM Graphic List ( ) ; } Projection projection = get Projection ( ) ; if ( projection == null ) { logger . fine ( get Name ( ) + STRING ) ; return new OM Graphic List ( ) ; } Point 2 D ul = projection . get Upper Left ( ) ; Point 2 D lr = projection . get Lower Right ( ) ; double ul Lat = ul . get Y ( ) ; double ul Lon = ul . get X ( ) ; double lr Lat = lr . get Y ( ) ; double lr Lon = lr . get X ( ) ; OM Graphic List master List = new OM Graphic List ( ) ; OM Graphic List list = null ; if ( Proj Math . is Crossing Dateline ( ul Lon , lr Lon , projection . get Scale ( ) ) ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( get Name ( ) + STRING ) ; } double ymin = Math . min ( ul Lat , lr Lat ) ; double ymax = Math . max ( ul Lat , lr Lat ) ; Iterator < Spatial Index Handler > sii = spatial Indexes . iterator ( ) ; while ( sii . has Next ( ) ) { Spatial Index Handler sih = ( Spatial Index Handler ) sii . next ( ) ; if ( ! sih . enabled ) continue ; try { list = sih . get Graphics ( ul Lon , ymin , NUM , ymax , list , projection ) ; list = sih . get Graphics ( - NUM , ymin , lr Lon , ymax , list , projection ) ; } catch ( java . io . IO Exception ex ) { ex . print Stack Trace ( ) ; } catch ( Format Exception fe ) { fe . print Stack Trace ( ) ; } master List . add ( list ) ; } } else { double xmin = ( double ) Math . min ( ul Lon , lr Lon ) ; double xmax = ( double ) Math . max ( ul Lon , lr Lon ) ; double ymin = ( double ) Math . min ( ul Lat , lr Lat ) ; double ymax = ( double ) Math . max ( ul Lat , lr Lat ) ; Iterator < Spatial Index Handler > sii = spatial Indexes . iterator ( ) ; while ( sii . has Next ( ) ) { Spatial Index Handler sih = ( Spatial Index Handler ) sii . next ( ) ; if ( ! sih . enabled ) continue ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( get Name ( ) + STRING + sih . pretty Name + STRING ) ; } try { list = sih . get Graphics ( xmin , ymin , xmax , ymax , list , projection ) ; } catch ( java . io . IO Exception ex ) { ex . print Stack Trace ( ) ; } catch ( Format Exception fe ) { fe . print Stack Trace ( ) ; } master List . add ( list ) ; } } return master List ; }
private boolean exposed ( int modifiers ) { return NUM != ( modifiers & ( Modifier . PUBLIC | Modifier . PROTECTED ) ) ; }
public void test Divide Round Half Up Pos 1 ( ) { String a = STRING ; int a Scale = - NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int res Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . divide ( b Number , res Scale , Big Decimal . ROUND HALF UP ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }
public boolean make Entry A Child Of A Parent ( User user , Entry parent , Entry child , boolean just The Entry , boolean is Admin , Errors errors ) { if ( user == null ) { Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return BOOL ; } if ( parent == null ) { Errors . add ( errors , error Messages . error Parent Is Null ( ) ) ; return BOOL ; } if ( child == null ) { Errors . add ( errors , error Messages . error Child Is Null ( ) ) ; return BOOL ; } if ( ! can User Modify Entry ( user , parent , is Admin ) ) { Errors . add ( errors , error Messages . error The User Is Not Entitled To Modify The Parent Entry ( ) ) ; return BOOL ; } if ( ! can User Modify Entry ( user , child , is Admin ) ) { Errors . add ( errors , error Messages . error The User Is Not Entitled To Modify The Child Entry ( ) ) ; return BOOL ; } if ( ! just The Entry ) { if ( is Entry A Descendant Of Ancestor ( parent , child ) ) { Errors . add ( errors , error Messages . error Child Is An Ancestor Of The Parent ( ) ) ; return BOOL ; } } else { final Array List < Entry > childs Children In Order = get Children In Order ( child ) ; final Entry parent Of Child = get Entry By Id ( child . get Parent Id ( ) ) ; for ( final Entry childs Child Temp : childs Children In Order ) { if ( ! make Notebook Entry ( user , childs Child Temp , is Admin , errors ) ) { return BOOL ; } } if ( parent Of Child != null ) { Entry previous = child ; for ( final Entry childs Child Temp : childs Children In Order ) { if ( ! create Parent Child Relationship ( user , parent Of Child , childs Child Temp , previous , is Admin , errors ) ) { return BOOL ; } previous = childs Child Temp ; } } } if ( ! create Parent Child Relationship ( user , parent , child , null , is Admin , errors ) ) { return BOOL ; } return BOOL ; }
public void unpack Start ( String line ) { String detail = URL Decoder . decode ( line ) ; detail = detail . substring ( detail . index Of ( STRING ) ) ; String tc Start = null ; if ( detail . index Of ( STRING ) != - NUM ) tc Start = detail . substring ( NUM , detail . index Of ( STRING ) ) ; else tc Start = detail . substring ( NUM ) ; manage Timer ( detail . substring ( NUM ) ) ; started Cases . add ( tc Start ) ; last Test Case Start Time = System . current Time Millis ( ) ; last Test Case Start = tc Start ; }
private void load Binary ( Byte Buffer bb ) throws IO Exception { if ( bb . get Int ( ) != MAGIC ) { throw new Error ( STRING ) ; } if ( bb . get Int ( ) != VERSION ) { throw new Error ( STRING ) ; } continuity Weight = bb . get Int ( ) ; optimal Coupling = bb . get Int ( ) ; extend Selections = bb . get Int ( ) ; join Method = bb . get Int ( ) ; join Weight Shift = bb . get Int ( ) ; int weight Length = bb . get Int ( ) ; join Weights = new int [ weight Length ] ; for ( int i = NUM ; i < join Weights . length ; i ++ ) { join Weights [ i ] = bb . get Int ( ) ; } int units Length = bb . get Int ( ) ; units = new Database Cluster Unit [ units Length ] ; for ( int i = NUM ; i < units . length ; i ++ ) { units [ i ] = new Database Cluster Unit ( bb ) ; } int unit Types Length = bb . get Int ( ) ; unit Types = new Unit Type [ unit Types Length ] ; for ( int i = NUM ; i < unit Types . length ; i ++ ) { unit Types [ i ] = new Unit Type ( bb ) ; } sts = new Sample Set ( bb ) ; mcep = new Sample Set ( bb ) ; int num Carts = bb . get Int ( ) ; cart Map = new Hash Map ( ) ; for ( int i = NUM ; i < num Carts ; i ++ ) { String name = Utilities . get String ( bb ) ; CART cart = CART Impl . load Binary ( bb ) ; cart Map . put ( name , cart ) ; if ( default Cart == null ) { default Cart = cart ; } } }
private int measure Width ( int measure Spec ) { int result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) m Text Paint . measure Text ( m Text ) + m Padding Left + m Padding Right ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }
public void test get Put Byte Array With Offset And Length ( ) { final int capacity = NUM ; final Byte Array Buffer buf = new Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( NUM ) ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( capacity - NUM ) ) ; final int pos = NUM ; for ( int i = NUM ; i < LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - NUM ) ] ; final int off = ( expected . length / NUM == NUM ? NUM : r . next Int ( expected . length / NUM ) ) ; final int len = ( expected . length == NUM ? NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( NUM , Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( NUM , Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) NUM , buf . get Byte ( NUM ) ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( pos + capacity - NUM ) ) ; }
protected boolean is Item Bound To Other Player ( final Player player , final RP Object object ) { if ( object instanceof Item ) { final Item item = ( Item ) object ; if ( item . is Bound ( ) && ! player . is Bound To ( item ) ) { player . send Private Text ( STRING + item . get Name ( ) + STRING + item . get Bound To ( ) + STRING ) ; return BOOL ; } } return BOOL ; }
protected String url String ( ) throws Parse Exception { String Builder retval = new String Builder ( ) ; lexer . select Lexer ( STRING ) ; while ( lexer . has More Chars ( ) ) { char la = lexer . look Ahead ( NUM ) ; if ( la == STRING || la == STRING || la == STRING || la == STRING || la == STRING ) break ; lexer . consume ( NUM ) ; retval . append ( la ) ; } return retval . to String ( ) ; }
public static void slide In From Bottom Animator ( @ Non Null List < Animator > animators , @ Non Null View view , Recycler View recycler View ) { alpha Animator ( animators , view , NUM ) ; animators . add ( Object Animator . of Float ( view , STRING , recycler View . get Measured Height ( ) > > NUM , NUM ) ) ; if ( Flexible Adapter . DEBUG ) Log . v ( TAG , STRING ) ; }
void copy Value ( int [ ] val ) { int len = val . length ; if ( value . length < len ) value = new int [ len ] ; System . arraycopy ( val , NUM , value , NUM , len ) ; int Len = len ; offset = NUM ; }
@ Request Mapping ( value = STRING ) public void slo Error ( Locale locale , @ Path Variable ( value = STRING ) String tenant , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + locale . to String ( ) + STRING + tenant ) ; slo Default Tenant Binding Error ( locale , response ) ; }
public static boolean is Input Stream GZIP Compressed ( final Pushback Input Stream input Stream ) throws IO Exception { if ( input Stream == null ) return BOOL ; byte [ ] signature = new byte [ NUM ] ; int read Status = input Stream . read ( signature ) ; input Stream . unread ( signature ) ; int stream Header = ( ( int ) signature [ NUM ] & NUM ) | ( ( signature [ NUM ] << NUM ) & NUM ) ; return read Status == NUM && GZIP Input Stream . GZIP MAGIC == stream Header ; }
public Commit Time Index ( final I Raw Store store , final Checkpoint checkpoint , final Index Metadata metadata , boolean read Only ) { super ( store , checkpoint , metadata , read Only ) ; }
public boolean is Closed ( ) throws SQL Exception { return this . is Closed ; }
private static void insert Value Using If Not Empty ( final Map < String , List < String > > params Map , final String param Val , final String parameter Name ) { if ( String Utils . is Not Empty ( param Val ) ) { List < String > list = new Array List < > ( ) ; list . add ( param Val ) ; params Map . put ( parameter Name , list ) ; } }
public Dimension maximum Layout Size ( Container target ) { Dimension size ; synchronized ( this ) { check Container ( target ) ; check Requests ( ) ; size = new Dimension ( x Total . maximum , y Total . maximum ) ; } Insets insets = target . get Insets ( ) ; size . width = ( int ) Math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right , Integer . MAX VALUE ) ; size . height = ( int ) Math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom , Integer . MAX VALUE ) ; return size ; }

public void select All Files ( boolean select ) { Abs List View list View = ( Abs List View ) get List View ( ) ; for ( int position = NUM ; position < list View . get Count ( ) ; position ++ ) { File file = ( File ) m Adapter . get Item ( position ) ; if ( file . is File ( ) ) { list View . set Item Checked ( position , select ) ; } } }
@ Override public void reset ( ) throws XNI Exception { super . reset ( ) ; f Create Entity Ref Nodes = f Configuration . get Feature ( CREATE ENTITY REF NODES ) ; f Include Ignorable Whitespace = f Configuration . get Feature ( INCLUDE IGNORABLE WHITESPACE ) ; f Defer Node Expansion = f Configuration . get Feature ( DEFER NODE EXPANSION ) ; f Namespace Aware = f Configuration . get Feature ( NAMESPACES ) ; f Include Comments = f Configuration . get Feature ( INCLUDE COMMENTS FEATURE ) ; f Create CDATA Nodes = f Configuration . get Feature ( CREATE CDATA NODES FEATURE ) ; set Document Class Name ( ( String ) f Configuration . get Property ( DOCUMENT CLASS NAME ) ) ; f Document = null ; f Document Impl = null ; f Store PSVI = BOOL ; f Document Type = null ; f Document Type Index = - NUM ; f Deferred Document Impl = null ; f Current Node = null ; f String Buffer . set Length ( NUM ) ; f Root = null ; f In DTD = BOOL ; f In DTD External Subset = BOOL ; f In CDATA Section = BOOL ; f First Chunk = BOOL ; f Current CDATA Section = null ; f Current CDATA Section Index = - NUM ; f Base URI Stack . remove All Elements ( ) ; }
private void on Open Editor ( String path , Editor Part Presenter editor ) { final List < Breakpoint > file Breakpoints = breakpoints . get ( path ) ; if ( file Breakpoints != null ) { final Breakpoint Renderer breakpoint Renderer = get Breakpoint Renderer For Editor ( editor ) ; if ( breakpoint Renderer != null ) { for ( final Breakpoint breakpoint : file Breakpoints ) { re Add Breakpoint Mark ( breakpoint Renderer , breakpoint ) ; } } } if ( current Breakpoint != null && path . equals ( current Breakpoint . get Path ( ) ) ) { Breakpoint Renderer breakpoint Renderer = get Breakpoint Renderer For File ( path ) ; if ( breakpoint Renderer != null ) { breakpoint Renderer . set Line Active ( current Breakpoint . get Line Number ( ) , BOOL ) ; } } }
private List < Solution > normalize ( Population population ) { List < Solution > result = new Array List < Solution > ( ) ; double [ ] min = new double [ problem . get Number Of Objectives ( ) ] ; double [ ] max = new double [ problem . get Number Of Objectives ( ) ] ; Arrays . fill ( min , Double . POSITIVE INFINITY ) ; Arrays . fill ( max , Double . NEGATIVE INFINITY ) ; for ( Solution solution : population ) { for ( int i = NUM ; i < problem . get Number Of Objectives ( ) ; i ++ ) { min [ i ] = Math . min ( min [ i ] , solution . get Objective ( i ) ) ; max [ i ] = Math . max ( max [ i ] , solution . get Objective ( i ) ) ; } } for ( Solution solution : population ) { Solution new Solution = solution . copy ( ) ; for ( int i = NUM ; i < problem . get Number Of Objectives ( ) ; i ++ ) { new Solution . set Objective ( i , ( max [ i ] - ( new Solution . get Objective ( i ) - min [ i ] ) + offset ) / ( max [ i ] - min [ i ] ) ) ; } result . add ( new Solution ) ; } return result ; }
private static void fit To Rectangle ( final Phylo Tree View tree View , final Rectangle rect ) { final Phylo Tree tree = tree View . get Phylo Tree ( ) ; double min X = Integer . MAX VALUE ; double min Y = Integer . MAX VALUE ; double max X = Integer . MIN VALUE ; double max Y = Integer . MIN VALUE ; for ( Node v = tree . get First Node ( ) ; v != null ; v = tree . get Next Node ( v ) ) { final Point 2 D loc = tree View . get Location ( v ) ; min X = Math . min ( min X , loc . get X ( ) ) ; min Y = Math . min ( min Y , loc . get Y ( ) ) ; max X = Math . max ( max X , loc . get X ( ) ) ; max Y = Math . max ( max Y , loc . get Y ( ) ) ; } final double mX = ( ( max X - min X ) != NUM ? rect . get Width ( ) / ( max X - min X ) : NUM ) ; final double mY = ( ( max Y - min Y ) != NUM ? rect . get Height ( ) / ( max Y - min Y ) : NUM ) ; for ( Node v = tree . get First Node ( ) ; v != null ; v = tree . get Next Node ( v ) ) { final Point 2 D loc = tree View . get Location ( v ) ; tree View . set Location ( v , rect . get X ( ) + mX * ( loc . get X ( ) - min X ) , rect . get Y ( ) + mY * ( loc . get Y ( ) - min Y ) ) ; } }
boolean add REST Remote Policy Listener ( SSO Token app Token , String service Name , String notification URL , boolean re Register ) { boolean status = BOOL ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + service Name + STRING + notification URL ) ; } if ( remote Policy Listeners . contains ( service Name ) && ! re Register ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + service Name + STRING + notification URL + STRING ) ; } return status ; } if ( app Token != null ) { try { String policy Service Listener URL = null ; policy Service Listener URL = get REST Policy Service Listener URL ( app Token ) ; String root URL = get Root URL ( notification URL ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + STRING + service Name + STRING + notification URL + STRING + root URL + STRING + policy Service Listener URL ) ; } Set < String > resource Names = new Hash Set < String > ( ) ; resource Names . add ( root URL ) ; String query String = build Register Listener Query String ( app Token , service Name , resource Names ) ; query String += STRING + URL Encoder . encode ( notification URL , STRING ) ; String resource Content = post Form ( app Token , policy Service Listener URL , query String ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + STRING + resource Content ) ; } status = BOOL ; remote Policy Listeners . add ( service Name ) ; } catch ( Unsupported Encoding Exception e ) { debug . error ( STRING + STRING , e ) ; } catch ( SSO Exception se ) { debug . error ( STRING + STRING , se ) ; } catch ( Policy Exception pe ) { debug . error ( STRING + STRING , pe ) ; } } else { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING ) ; } } return status ; }
@ Override public void execute ( Metric Time Series time Series , Function Value Map function Value Map ) { if ( time Series . size ( ) <= NUM ) { function Value Map . add ( this , Double . Na N ) ; return ; } double [ ] values = time Series . get Values As Array ( ) ; double min = values [ NUM ] ; double max = values [ NUM ] ; for ( int i = NUM ; i < values . length ; i ++ ) { double current = values [ i ] ; if ( current < min ) { min = current ; } if ( current > max ) { max = current ; } } function Value Map . add ( this , Math . abs ( max - min ) ) ; }
public grammaticality Estimator ( Set File Names , int i Min Char , int i Max Char , int i Min Word , int i Max Word , int i Neighbourhood Window ) { i Min Char N Gram = i Min Char ; i Max Char N Gram = i Max Char ; i Min Word N Gram = i Min Word ; i Max Word N Gram = i Max Word ; Distro Docs = new Tree Map < Integer , Distribution Document > ( ) ; Distro Word Docs = new Tree Map < Integer , Distribution Word Document > ( ) ; String Buffer sb = new String Buffer ( ) ; Iterator i Texts = File Names . iterator ( ) ; while ( i Texts . has Next ( ) ) { String s File = ( String ) i Texts . next ( ) ; try { Buffered Reader bf = new Buffered Reader ( new File Reader ( s File ) ) ; String s Tmp ; while ( ( s Tmp = bf . read Line ( ) ) != null ) sb . append ( s Tmp ) ; bf . close ( ) ; } catch ( File Not Found Exception ex ) { ex . print Stack Trace ( System . err ) ; } catch ( IO Exception ex ) { ex . print Stack Trace ( System . err ) ; } sb . append ( ( char ) NUM ) ; } Full Text Data String = sb . to String ( ) ; for ( int i Cnt = i Min Char N Gram ; i Cnt <= i Max Char N Gram ; i Cnt ++ ) { Distro Docs . put ( i Cnt , new Distribution Document ( i Neighbourhood Window , i Cnt ) ) ; } for ( int i Cnt = i Min Word N Gram ; i Cnt <= i Max Word N Gram ; i Cnt ++ ) { Distro Word Docs . put ( i Cnt , new Distribution Word Document ( i Neighbourhood Window , i Cnt ) ) ; } }
private void parse Wild Cards ( ) { if ( f Pattern . starts With ( STRING ) ) f Has Leading Star = BOOL ; if ( f Pattern . ends With ( STRING ) ) { if ( f Length > NUM && f Pattern . char At ( f Length - NUM ) != STRING ) { f Has Trailing Star = BOOL ; } } Vector < String > temp = new Vector < String > ( ) ; int pos = NUM ; String Buffer buf = new String Buffer ( ) ; while ( pos < f Length ) { char c = f Pattern . char At ( pos ++ ) ; switch ( c ) { case STRING : if ( pos >= f Length ) { buf . append ( c ) ; } else { char next = f Pattern . char At ( pos ++ ) ; if ( next == STRING || next == STRING || next == STRING ) { buf . append ( next ) ; } else { buf . append ( c ) ; buf . append ( next ) ; } } break ; case STRING : if ( buf . length ( ) > NUM ) { temp . add Element ( buf . to String ( ) ) ; f Bound += buf . length ( ) ; buf . set Length ( NUM ) ; } break ; case STRING : buf . append ( f Single Wild Card ) ; break ; default : buf . append ( c ) ; } } if ( buf . length ( ) > NUM ) { temp . add Element ( buf . to String ( ) ) ; f Bound += buf . length ( ) ; } f Segments = new String [ temp . size ( ) ] ; temp . copy Into ( f Segments ) ; }
public static void assert Chi Square Accept ( String [ ] value Labels , double [ ] expected , long [ ] observed , double alpha ) { if ( chi Square Test ( expected , observed ) <= alpha ) { String Builder msg Buffer = new String Builder ( ) ; Decimal Format df = new Decimal Format ( STRING ) ; msg Buffer . append ( STRING ) ; msg Buffer . append ( STRING ) ; msg Buffer . append ( chi Square Test ( expected , observed ) ) ; msg Buffer . append ( STRING ) ; msg Buffer . append ( chi Square ( expected , observed ) ) ; msg Buffer . append ( STRING ) ; msg Buffer . append ( STRING ) ; for ( int i = NUM ; i < expected . length ; i ++ ) { msg Buffer . append ( value Labels [ i ] ) ; msg Buffer . append ( STRING ) ; msg Buffer . append ( df . format ( expected [ i ] ) ) ; msg Buffer . append ( STRING ) ; msg Buffer . append ( observed [ i ] ) ; msg Buffer . append ( STRING ) ; } msg Buffer . append ( STRING ) ; msg Buffer . append ( alpha ) ; msg Buffer . append ( STRING ) ; Assert . fail ( msg Buffer . to String ( ) ) ; } }
public static void assert Diagonally Dominant ( I Double Matrix mat ) { assert Square ( mat ) ; for ( int i = NUM ; i < mat . get Row Num ( ) ; ++ i ) { final double d = mat . get ( i , i ) ; if ( Double . is Na N ( d ) ) { continue ; } for ( int j = NUM ; j < mat . get Row Num ( ) ; ++ j ) { double v ; v = mat . get ( i , j ) ; if ( ! Double . is Na N ( v ) && v > d ) { final String msg = String . format ( STRING , i , j , v , i , i , d , d - v ) ; throw new Ade Core Illegal Argument Exception ( msg ) ; } v = mat . get ( j , i ) ; if ( ! Double . is Na N ( v ) && v > d ) { final String msg = String . format ( STRING , j , i , v , i , i , d ) ; throw new Ade Core Illegal Argument Exception ( msg ) ; } } } }
public void process Game Event ( Game Event event ) { if ( game Listeners == null ) { game Listeners = new Vector < Game Listener > ( ) ; } for ( Enumeration < Game Listener > e = game Listeners . elements ( ) ; e . has More Elements ( ) ; ) { event . fire Event ( e . next Element ( ) ) ; } }
public Percentiles percentiles ( Constant Range range ) { Sorted Set < Constant > sorted = values ( ) ; Sorted Set < Constant > contained = new Tree Set < Constant > ( ) ; Constant prev = null ; for ( Constant pct : sorted ) { if ( range . contains ( pct ) ) { contained . add ( pct ) ; } else if ( contained . is Empty ( ) ) prev = pct ; } if ( contained . is Empty ( ) ) return null ; double prev Percent = prev == null ? NUM : pcts . get ( prev ) ; double total Percent = pcts . get ( contained . last ( ) ) - prev Percent ; Map < Constant , Double > new Pcts = new Hash Map < Constant , Double > ( ) ; for ( Constant p : contained ) new Pcts . put ( p , ( pcts . get ( p ) - prev Percent ) / total Percent ) ; return new Percentiles ( new Pcts ) ; }
private static void close Safe ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IO Exception ignored ) { } } }
private Object execute Exponent ( Page Context pc , SQL sql , Query qr , Z Expression expression , int row ) throws Page Exception { return Integer . value Of ( Caster . to Int Value ( execute Exp ( pc , sql , qr , expression . get Operand ( NUM ) , row ) ) ^ Caster . to Int Value ( execute Exp ( pc , sql , qr , expression . get Operand ( NUM ) , row ) ) ) ; }
public static int write Byte Array ( final byte [ ] tgt , final int tgt Offset , final byte [ ] src , final int src Offset , final int src Length ) { byte [ ] vint = vint To Bytes ( src Length ) ; System . arraycopy ( vint , NUM , tgt , tgt Offset , vint . length ) ; int offset = tgt Offset + vint . length ; System . arraycopy ( src , src Offset , tgt , offset , src Length ) ; return offset + src Length ; }
public static Configuration load ( String path , Class Loader class Loader , Consumer < String > logger ) throws IO Exception { try ( Input Stream stream = Io Util . get Resource As Stream ( path , class Loader , null , null , logger ) ) { Properties props = new Properties ( ) ; if ( stream != null ) { props . load ( stream ) ; } return from ( props ) ; } }
@ Override public boolean equals ( Object o ) { if ( o instanceof Graph . Node ) { Graph < ? , ? > . Node n = ( Graph < ? , ? > . Node ) o ; return content . equals ( n . content ) && children . equals ( n . children ) && attributes . equals ( n . attributes ) ; } return BOOL ; }
public final static Name Value Pair [ ] parse Parameters ( final String value , Header Value Parser parser ) throws Parse Exception { if ( value == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( parser == null ) parser = Save Header Value Parser . DEFAULT ; Char Array Buffer buffer = new Char Array Buffer ( value . length ( ) ) ; buffer . append ( value ) ; Save Parser Cursor cursor = new Save Parser Cursor ( NUM , value . length ( ) ) ; return parser . parse Parameters ( buffer , cursor ) ; }
private static int Dist ( P Cal Location loc A , P Cal Location loc B ) { return NUM * Math . abs ( loc A . get Line ( ) - loc B . get Line ( ) ) + Math . abs ( loc A . get Column ( ) - loc B . get Column ( ) ) ; }
private void generate Code ( Velocity Engine ve , String template Dir , File file , Velocity Context context ) { Template tm = ve . get Template ( template Dir + File . separator + PIPELINE TEMPLATE ) ; String Writer sw = new String Writer ( ) ; tm . merge ( context , sw ) ; try ( Print Writer writer = new Print Writer ( file . get Absolute Path ( ) , STRING ) ) { writer . println ( sw ) ; } catch ( Unsupported Encoding Exception | File Not Found Exception e ) { logger . log ( Level . SEVERE , STRING , e ) ; } }
public Object Name ( String domain , String key , String value ) throws Malformed Object Name Exception { Map < String , String > table = Collections . singleton Map ( key , value ) ; construct ( domain , table ) ; }
public synchronized void add Remote Tcp Server ( Remote Tcp Server server ) { Queue < Remote Tcp Server > queue = remote Current Servers . get ( server . get Address ( ) ) ; if ( queue == null ) { queue = new Concurrent Linked Queue < > ( ) ; remote Current Servers . put ( server . get Address ( ) , queue ) ; } queue . add ( server ) ; }
private void prepare RP Consistency Group Data ( ) throws Exception { log . info ( STRING ) ; Tenant Org tenant Org = new Tenant Org ( ) ; URI tenant Org URI = URI Util . create Id ( Tenant Org . class ) ; tenant Org . set Id ( tenant Org URI ) ; db Client . create Object ( tenant Org ) ; Project proj = new Project ( ) ; URI project URI = URI Util . create Id ( Project . class ) ; String project Label = STRING ; proj . set Id ( project URI ) ; proj . set Label ( project Label ) ; proj . set Tenant Org ( new Named URI ( tenant Org URI , project Label ) ) ; db Client . create Object ( proj ) ; Protection Set cg 1 ps = create Protection Set Data ( STRING , project URI ) ; List < Volume > cg 1 Volumes = create Rp Volumes ( STRING , NUM , cg 1 ps ) ; cg 1 Volumes . add All ( create Rp Volumes ( STRING , NUM , cg 1 ps ) ) ; add Volumes To Protection Set ( cg 1 ps . get Id ( ) , cg 1 Volumes ) ; create Block Snapshot Data ( STRING , cg 1 Volumes ) ; Protection Set cg 2 ps = create Protection Set Data ( STRING , project URI ) ; List < Volume > cg 2 Volumes = create Rp Volumes ( STRING , NUM , cg 2 ps ) ; cg 2 Volumes . add All ( create Rp Volumes ( STRING , NUM , cg 2 ps ) ) ; add Volumes To Protection Set ( cg 2 ps . get Id ( ) , cg 2 Volumes ) ; create Block Snapshot Data ( STRING , cg 2 Volumes ) ; Protection Set cg 3 ps = create Protection Set Data ( STRING , project URI ) ; List < Volume > cg 3 Volumes = create Rp Volumes ( STRING , NUM , cg 3 ps ) ; add Volumes To Protection Set ( cg 3 ps . get Id ( ) , cg 3 Volumes ) ; create Block Snapshot Data ( STRING , cg 3 Volumes ) ; for ( URI volume URI : rp Test Volume UR Is ) { Volume volume = db Client . query Object ( Volume . class , volume URI ) ; Assert . assert Not Null ( String . format ( STRING , volume URI ) , volume ) ; } }
protected Completion Stage < Result > on Dev Server Error ( Http . Request Header request , Useful Exception exception ) { Object Node json Error = Json . new Object ( ) ; final Throwable cause = exception . cause ; final String description = exception . description ; final String id = exception . id ; final String title = exception . title ; json Error . put ( STRING , description ) ; json Error . put ( STRING , title ) ; json Error . put ( STRING , id ) ; json Error . put ( STRING , exception . get Message ( ) ) ; json Error . set ( STRING , causes To Json ( cause ) ) ; return Completable Future . completed Future ( Results . internal Server Error ( json Error ) ) ; }
private void read Object ( Object Input Stream s ) throws Class Not Found Exception , IO Exception , Headless Exception { Graphics Environment . check Headless ( ) ; acc = Access Controller . get Context ( ) ; s . default Read Object ( ) ; app Context = App Context . get App Context ( ) ; }
private void paint Foreground Pressed ( Graphics 2 D g , int width , int height ) { Shape s = decode Arrow Path ( width , height ) ; g . set Paint ( pressed Color ) ; g . fill ( s ) ; }
public Key Change ( String new Key Data , DSA Public Key change Key , boolean allows Unsigned Changes , boolean allows Public Visibility , byte [ ] msg , byte [ ] sig , long epoch , long counter ) { this . new Key Data = new Key Data ; this . new Change Key = change Key ; this . allows Unsigned Changes = allows Unsigned Changes ; this . allows Public Visibility = allows Public Visibility ; this . msg = msg == null ? null : Arrays . copy Of ( msg , msg . length ) ; this . sig = sig == null ? null : Arrays . copy Of ( sig , sig . length ) ; this . epoch = epoch ; this . counter = counter ; Logging . log ( STRING + Arrays . to String ( this . sig ) ) ; }
private void maybe Show Popup ( final Mouse Event event ) { if ( event . is Popup Trigger ( ) ) { final J Popup Menu menu = new J Popup Menu ( ) ; menu . add ( new Copy Log Action ( m text Area ) ) ; menu . show ( event . get Component ( ) , event . get X ( ) , event . get Y ( ) ) ; } }
private boolean take Task ( ) { int size = tasks . size ( ) ; for ( int i = first Pending ; i < size ; i ++ ) { Task t = tasks . get ( i ) ; if ( ! run After ( t , i ) ) { if ( i > first Pending ) { tasks . remove ( i ) ; tasks . add ( first Pending , t ) ; } first Pending ++ ; task = t ; return BOOL ; } } return BOOL ; }
protected Transferable create Transferable ( J Component c ) { if ( c instanceof J Tree ) { tree = ( J Tree ) c ; Tree Path [ ] paths = tree . get Selection Paths ( ) ; if ( paths == null || paths . length == NUM ) { return null ; } String Buffer plain Buf = new String Buffer ( ) ; String Buffer html Buf = new String Buffer ( ) ; html Buf . append ( STRING ) ; Tree Model model = tree . get Model ( ) ; Tree Path last Path = null ; Tree Path [ ] display Paths = get Display Order Paths ( paths ) ; for ( Tree Path path : display Paths ) { Object node = path . get Last Path Component ( ) ; boolean leaf = model . is Leaf ( node ) ; String label = get Display String ( path , BOOL , leaf ) ; plain Buf . append ( label + STRING ) ; html Buf . append ( STRING + label + STRING ) ; } plain Buf . delete Char At ( plain Buf . length ( ) - NUM ) ; html Buf . append ( STRING ) ; tree = null ; return new Basic Transferable ( plain Buf . to String ( ) , html Buf . to String ( ) ) ; } return null ; }
protected Class load Class ( String name , boolean resolve ) throws Class Format Error , Class Not Found Exception { name = name . intern ( ) ; synchronized ( name ) { Class c = find Loaded Class ( name ) ; if ( c == null ) c = load Class By Delegation ( name ) ; if ( c == null ) c = find Class ( name ) ; if ( c == null ) c = delegate To Parent ( name ) ; if ( resolve ) resolve Class ( c ) ; return c ; } }
Rules ( Workspace workspace ) { this . root = workspace . get Root ( ) ; this . team Hook = workspace . get Team Hook ( ) ; workspace . add Lifecycle Listener ( this ) ; }
public void remove ( @ Non Null T item ) { int remove Index ; synchronized ( lock ) { if ( items == null ) { return ; } remove Index = items . index Of ( item ) ; if ( remove Index != - NUM ) { items . remove ( remove Index ) ; } } if ( notify On Change && remove Index != - NUM ) { notify Item Removed ( remove Index ) ; } }
private void process Client Reconnect Message ( Tcp Discovery Client Reconnect Message msg ) { UUID node Id = msg . creator Node Id ( ) ; UUID loc Node Id = get Local Node Id ( ) ; boolean is Loc Node Router = loc Node Id . equals ( msg . router Node Id ( ) ) ; if ( ! msg . verified ( ) ) { Tcp Discovery Node node = ring . node ( node Id ) ; assert node == null || node . is Client ( ) ; if ( node != null ) { node . client Router Node Id ( msg . router Node Id ( ) ) ; node . alive Check ( spi . max Missed Client Hbs ) ; } if ( is Local Node Coordinator ( ) ) { msg . verify ( loc Node Id ) ; if ( node != null ) { Collection < Tcp Discovery Abstract Message > pending = msg Hist . messages ( msg . last Message Id ( ) , node ) ; if ( pending != null ) { msg . pending Messages ( pending ) ; msg . success ( BOOL ) ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + STRING + loc Node Id + STRING + node Id + STRING ) ; } else { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + STRING + loc Node Id + STRING + node Id + STRING ) ; Tcp Discovery Node Failed Message node Failed Msg = new Tcp Discovery Node Failed Message ( loc Node Id , node . id ( ) , node . internal Order ( ) ) ; process Node Failed Message ( node Failed Msg ) ; if ( node Failed Msg . verified ( ) ) msg Hist . add ( node Failed Msg ) ; } } else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + node Id + STRING ) ; if ( is Loc Node Router ) { Client Message Worker wrk = client Msg Workers . get ( node Id ) ; if ( wrk != null ) wrk . add Message ( msg ) ; else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + loc Node Id + STRING + node Id + STRING ) ; } else { if ( send Message To Remotes ( msg ) ) send Message Across Ring ( msg ) ; } } else { if ( send Message To Remotes ( msg ) ) send Message Across Ring ( msg ) ; } } else { if ( is Local Node Coordinator ( ) ) add Message ( new Tcp Discovery Discard Message ( loc Node Id , msg . id ( ) , BOOL ) ) ; if ( is Loc Node Router ) { Client Message Worker wrk = client Msg Workers . get ( node Id ) ; if ( wrk != null ) wrk . add Message ( msg ) ; else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + loc Node Id + STRING + node Id + STRING ) ; } else { if ( ring . has Remote Nodes ( ) && ! is Local Node Coordinator ( ) ) send Message Across Ring ( msg ) ; } } }
protected int parse And Add Node ( Xml Resource Parser parser , Hash Map < String , Tag Parser > tag Parser Map , Array List < Long > screen Ids ) throws Xml Pull Parser Exception , IO Exception { if ( TAG INCLUDE . equals ( parser . get Name ( ) ) ) { final int res Id = get Attribute Resource Value ( parser , ATTR WORKSPACE , NUM ) ; if ( res Id != NUM ) { return parse Layout ( res Id , screen Ids ) ; } else { return NUM ; } } m Values . clear ( ) ; parse Container And Screen ( parser , m Temp ) ; final long container = m Temp [ NUM ] ; final long screen Id = m Temp [ NUM ] ; m Values . put ( Launcher Settings . Favorites . CONTAINER , container ) ; m Values . put ( Launcher Settings . Favorites . SCREEN , screen Id ) ; m Values . put ( Launcher Settings . Favorites . CELLX , get Attribute Value ( parser , ATTR X ) ) ; m Values . put ( Launcher Settings . Favorites . CELLY , get Attribute Value ( parser , ATTR Y ) ) ; Tag Parser tag Parser = tag Parser Map . get ( parser . get Name ( ) ) ; if ( tag Parser == null ) { if ( LOGD ) Log . d ( TAG , STRING + parser . get Name ( ) ) ; return NUM ; } long new Element Id = tag Parser . parse And Add ( parser ) ; if ( new Element Id >= NUM ) { if ( ! screen Ids . contains ( screen Id ) && container == Launcher Settings . Favorites . CONTAINER DESKTOP ) { screen Ids . add ( screen Id ) ; } return NUM ; } return NUM ; }
private static Comparable < ? > parse Property Value ( String name , String value ) { if ( PROPERTY EVENT TYPE . equals ( name ) ) { return s Event Type Name To Value Map . get ( value ) ; } final int property Type = get Property Type ( name ) ; switch ( property Type ) { case PROPERTY TYPE BOOLEAN : return Boolean . value Of ( value ) ; case PROPERTY TYPE FLOAT : try { return Float . value Of ( value ) ; } catch ( Number Format Exception nfe ) { Log Utils . log ( Event Speech Rule . class , Log . WARN , STRING , name ) ; return null ; } case PROPERTY TYPE INTEGER : try { return Integer . value Of ( value ) ; } catch ( Number Format Exception nfe ) { Log Utils . log ( Event Speech Rule . class , Log . WARN , STRING , name ) ; return null ; } case PROPERTY TYPE STRING : return value ; default : throw new Illegal Argument Exception ( STRING + name ) ; } }
public void test Scalars With Typing ( ) throws Exception { Object Mapper m = new Object Mapper ( ) ; String json ; Dynamic Wrapper result ; json = m . write Value As String ( new Dynamic Wrapper ( Integer . value Of ( NUM ) ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( Integer . value Of ( NUM ) , result . value ) ; json = m . write Value As String ( new Dynamic Wrapper ( STRING ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( STRING , result . value ) ; json = m . write Value As String ( new Dynamic Wrapper ( STRING ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( STRING , result . value ) ; json = m . write Value As String ( new Dynamic Wrapper ( Boolean . TRUE ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( Boolean . TRUE , result . value ) ; json = m . write Value As String ( new Dynamic Wrapper ( Long . value Of ( NUM ) ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( Long . value Of ( NUM ) , result . value ) ; json = m . write Value As String ( new Dynamic Wrapper ( Test Enum . B ) ) ; result = m . read Value ( json , Dynamic Wrapper . class ) ; assert Equals ( Test Enum . B , result . value ) ; }
public void close ( ) { synchronized ( m Disk Cache Lock ) { if ( m Disk Lru Cache != null ) { try { if ( ! m Disk Lru Cache . is Closed ( ) ) { m Disk Lru Cache . close ( ) ; } } catch ( Throwable e ) { Log Utils . e ( e . get Message ( ) , e ) ; } m Disk Lru Cache = null ; } } }
private void profiles CB ( ) { Profile profile ; String host ; profile = ( Profile ) profiles Combo Box . get Selected Item ( ) ; if ( profile != null ) { host = profile . get Host ( ) ; server Field . set Text ( host ) ; server Port Field . set Text ( String . value Of ( profile . get Port ( ) ) ) ; username Field . set Text ( profile . get User ( ) ) ; password Field . set Text ( profile . get Password ( ) ) ; } else { server Port Field . set Text ( String . value Of ( Profile . DEFAULT SERVER PORT ) ) ; username Field . set Text ( STRING ) ; password Field . set Text ( STRING ) ; } }
public synchronized void open Write ( ) throws Replicator Exception , Interrupted Exception { if ( ! file . exists ( ) ) { throw new THL Exception ( STRING + file . get Name ( ) ) ; } try { Buffered File Data Input bfdi = new Buffered File Data Input ( file , buffer Size ) ; check File Header ( bfdi ) ; bfdi . close ( ) ; data Output = new Buffered File Data Output ( file , buffer Size ) ; } catch ( IO Exception e ) { throw new THL Exception ( STRING + file . get Name ( ) , e ) ; } mode = Access Mode . write ; if ( log Flush Task != null ) log Flush Task . add Log File ( this ) ; }
public float maximum Absolute ( ) { if ( Math . abs ( m Left ) > Math . abs ( m Right ) ) { return Math . abs ( m Left ) ; } else { return Math . abs ( m Right ) ; } }
private double determine Alpha Min ( int n , double [ ] alpha min , Hyper Bounding Box interval ) { double alpha n = extremum alpha n ( n , alpha min ) ; double lower = interval . get Min ( n ) ; double upper = interval . get Max ( n ) ; double [ ] alpha extreme = new double [ alpha min . length ] ; System . arraycopy ( alpha min , n , alpha extreme , n , alpha extreme . length - n ) ; alpha extreme [ n ] = alpha n ; Extremum Type type = extremum Type ( n , alpha extreme , interval ) ; if ( type . equals ( Extremum Type . MINIMUM ) || type . equals ( Extremum Type . CONSTANT ) ) { if ( lower <= alpha n && alpha n <= upper ) { return alpha n ; } else if ( alpha n < lower ) { return lower ; } else { if ( alpha n <= upper ) { throw new Illegal State Exception ( STRING ) ; } return upper ; } } else { if ( lower <= alpha n && alpha n <= upper ) { if ( alpha n - lower <= upper - alpha n ) { return upper ; } else { return lower ; } } else if ( alpha n < lower ) { return upper ; } else { if ( alpha n <= upper ) { throw new Illegal State Exception ( STRING ) ; } return lower ; } } }
public static String map 2 OID ( String alg Name ) { check Cache Version ( ) ; String result = alg 2 Oid Map . get ( alg Name . to Upper Case ( Locale . US ) ) ; if ( result != null ) { return result ; } Alg Name Mapper Source s = source ; if ( s != null ) { return s . map Name To Oid ( alg Name ) ; } return null ; }
@ Override public Generator < I Multi Point > construct ( String [ ] args ) { return new Uniform Generator ( Integer . value Of ( args [ NUM ] ) , Double . value Of ( args [ NUM ] ) ) ; }
private boolean process Mouse Event ( Mouse Event e ) { int id = e . get ID ( ) ; Component mouse Over = native Container . get Mouse Event Target ( e . get X ( ) , e . get Y ( ) , Container . INCLUDE SELF ) ; track Mouse Enter Exit ( mouse Over , e ) ; Component met = mouse Event Target . get ( ) ; if ( ! is Mouse Grab ( e ) && id != Mouse Event . MOUSE CLICKED ) { met = ( mouse Over != native Container ) ? mouse Over : null ; mouse Event Target = new Weak Reference < > ( met ) ; } if ( met != null ) { switch ( id ) { case Mouse Event . MOUSE ENTERED : case Mouse Event . MOUSE EXITED : break ; case Mouse Event . MOUSE PRESSED : retarget Mouse Event ( met , id , e ) ; break ; case Mouse Event . MOUSE RELEASED : retarget Mouse Event ( met , id , e ) ; break ; case Mouse Event . MOUSE CLICKED : if ( mouse Over == met ) { retarget Mouse Event ( mouse Over , id , e ) ; } break ; case Mouse Event . MOUSE MOVED : retarget Mouse Event ( met , id , e ) ; break ; case Mouse Event . MOUSE DRAGGED : if ( is Mouse Grab ( e ) ) { retarget Mouse Event ( met , id , e ) ; } break ; case Mouse Event . MOUSE WHEEL : if ( event Log . is Loggable ( Platform Logger . Level . FINEST ) && ( mouse Over != null ) ) { event Log . finest ( STRING + mouse Over . get Name ( ) + STRING + mouse Over . get Class ( ) ) ; } retarget Mouse Event ( mouse Over , id , e ) ; break ; } if ( id != Mouse Event . MOUSE WHEEL ) { e . consume ( ) ; } } return e . is Consumed ( ) ; }
public static List < I Navi Module > load Modules ( final Abstract SQL Provider provider , final List < I Navi Raw Module > raw Modules , final Debugger Template Manager debugger Manager ) throws Couldnt Load Data Exception { Preconditions . check Not Null ( raw Modules , STRING ) ; Postgre SQL Database Functions . check Arguments ( provider , debugger Manager ) ; final List < C Module > modules = new Array List < > ( ) ; final C Connection connection = provider . get Connection ( ) ; if ( ! Postgre SQL Helpers . has Table ( connection , C Table Names . MODULES TABLE ) ) { return new Array List < I Navi Module > ( modules ) ; } final String query = STRING + C Table Names . MODULES TABLE + STRING + STRING + STRING + STRING + C Table Names . FUNCTIONS TABLE + STRING + STRING + C Table Names . FUNCTIONS TABLE + STRING + STRING + STRING + C Table Names . MODULE VIEWS TABLE + STRING + C Table Names . VIEWS TABLE + STRING + STRING + C Table Names . MODULES TABLE + STRING + STRING + C Table Names . MODULES TABLE + STRING + STRING ; try ( Result Set result Set = connection . execute Query ( query , BOOL ) ) { while ( result Set . next ( ) ) { final int module Id = result Set . get Int ( STRING ) ; final String name = Postgre SQL Helpers . read String ( result Set , STRING ) ; final String md 5 = Postgre SQL Helpers . read String ( result Set , STRING ) ; final String sha 1 = Postgre SQL Helpers . read String ( result Set , STRING ) ; final String comment = Postgre SQL Helpers . read String ( result Set , STRING ) ; final Timestamp timestamp = result Set . get Timestamp ( STRING ) ; final Timestamp modification Date = result Set . get Timestamp ( STRING ) ; int function Count = result Set . get Int ( STRING ) ; final int view Count = result Set . get Int ( STRING ) ; final I Address image Base = Postgre SQL Helpers . load Address ( result Set , STRING ) ; final I Address file Base = Postgre SQL Helpers . load Address ( result Set , STRING ) ; final int debugger Id = result Set . get Int ( STRING ) ; final boolean is Stared = result Set . get Boolean ( STRING ) ; final int initialization State = result Set . get Int ( STRING ) ; final Debugger Template description = debugger Manager . find Debugger ( debugger Id ) ; final int raw Module Id = result Set . get Int ( STRING ) ; final I Navi Raw Module raw Module = Postgre SQL Database Functions . find Raw Module ( raw Module Id , raw Modules ) ; if ( ( function Count == NUM ) && ( raw Module != null ) ) { function Count = raw Module . get Function Count ( ) ; } modules . add ( new C Module ( module Id , name , comment , timestamp , modification Date , md 5 , sha 1 , function Count , view Count , file Base , image Base , description , raw Module , initialization State , is Stared , provider ) ) ; } } catch ( final SQL Exception e ) { throw new Couldnt Load Data Exception ( e ) ; } return new Array List < I Navi Module > ( modules ) ; }
public static void instance List To Arff File Multi Label ( File output File , Feature Store feature Store , boolean use Dense Instances , boolean use Weights ) throws Exception { Attribute Store attribute Store = Weka Feature Encoder . get Attribute Store ( feature Store ) ; List < Attribute > outcome Attributes = create Outcome Attributes ( new Array List < String > ( feature Store . get Unique Outcomes ( ) ) ) ; for ( Attribute attribute : outcome Attributes ) { attribute Store . add Attribute At Begin ( attribute . name ( ) , attribute ) ; } Instances weka Instances = new Instances ( RELATION NAME + STRING + outcome Attributes . size ( ) + STRING , attribute Store . get Attributes ( ) , feature Store . get Number Of Instances ( ) ) ; weka Instances . set Class Index ( outcome Attributes . size ( ) ) ; if ( ! output File . exists ( ) ) { output File . mkdirs ( ) ; output File . create New File ( ) ; } Arff Saver saver = new Arff Saver ( ) ; saver . set Retrieval ( Saver . INCREMENTAL ) ; saver . set File ( output File ) ; saver . set Compress Output ( BOOL ) ; saver . set Instances ( weka Instances ) ; for ( int i = NUM ; i < feature Store . get Number Of Instances ( ) ; i ++ ) { Instance instance = feature Store . get Instance ( i ) ; double [ ] feature Values = get Feature Values ( attribute Store , instance ) ; List < String > instance Outcome = instance . get Outcomes ( ) ; for ( Attribute label : outcome Attributes ) { String labelname = label . name ( ) ; feature Values [ attribute Store . get Attribute Offset ( labelname ) ] = instance Outcome . contains ( labelname . split ( CLASS ATTRIBUTE PREFIX ) [ NUM ] ) ? NUM : NUM ; } weka . core . Instance weka Instance ; if ( use Dense Instances ) { weka Instance = new Dense Instance ( NUM , feature Values ) ; } else { weka Instance = new Sparse Instance ( NUM , feature Values ) ; } weka Instance . set Dataset ( weka Instances ) ; Double instance Weight = feature Store . get Weight ( i ) ; if ( use Weights ) { weka Instance . set Weight ( instance Weight ) ; } saver . write Incremental ( weka Instance ) ; } saver . write Incremental ( null ) ; }
@ Override public void on Bind View Holder ( final Recycler View . View Holder holder , int positions ) { int view Type = holder . get Item View Type ( ) ; switch ( view Type ) { case NUM : convert ( ( Base View Holder ) holder , m Data . get ( holder . get Layout Position ( ) - get Header Layout Count ( ) ) ) ; break ; case LOADING VIEW : add Load More ( holder ) ; break ; case HEADER VIEW : break ; case EMPTY VIEW : break ; case FOOTER VIEW : break ; default : convert ( ( Base View Holder ) holder , m Data . get ( holder . get Layout Position ( ) - get Header Layout Count ( ) ) ) ; on Bind Def View Holder ( ( Base View Holder ) holder , m Data . get ( holder . get Layout Position ( ) - get Header Layout Count ( ) ) ) ; break ; } }
private void modify Selected Line ( ) { if ( lines List . get Selected Indices ( ) . length > NUM ) { return ; } Axis Parallel Line Configuration line = lines List . get Selected Value ( ) ; if ( line != null ) { if ( modify Line Dialog == null ) { modify Line Dialog = new Edit Parallel Line Dialog ( ) ; } modify Line Dialog . set Line ( line , BOOL ) ; modify Line Dialog . show Dialog ( ) ; } }
public void filled Rectangle ( double x , double y , double half Width , double half Height ) { if ( half Width < NUM ) throw new Illegal Argument Exception ( STRING ) ; if ( half Height < NUM ) throw new Illegal Argument Exception ( STRING ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( NUM * half Width ) ; double hs = factor Y ( NUM * half Height ) ; if ( ws <= NUM && hs <= NUM ) pixel ( x , y ) ; else offscreen . fill ( new Rectangle 2 D . Double ( xs - ws / NUM , ys - hs / NUM , ws , hs ) ) ; draw ( ) ; }
public void prepend Split Element ( Fragment a Split ) { splits . add ( NUM , a Split ) ; }
private void start Item List Item ( String Builder result , String root Id , String item Id ) { result . append ( STRING ) ; result . append ( STRING + item Id + STRING + root Id + STRING + item Id + STRING ) ; }
private long compute Number Of Partitions ( int num Tasks , long total Points In Range , int min Datapoints Per Task ) { final long max Tasks By Datapoint Restriction = total Points In Range / min Datapoints Per Task ; final long desired Num Tasks = Math . max ( num Tasks , NUM ) ; long nr Sub Ranges = Math . min ( max Tasks By Datapoint Restriction , desired Num Tasks ) ; return Math . max ( NUM , nr Sub Ranges ) ; }
@ Override public void mouse Clicked ( Mouse Event e ) { if ( mouse Clicked Listener != null && e . get Click Count ( ) == NUM && ! e . is Alt Down ( ) && ! e . is Alt Graph Down ( ) ) { mouse Clicked Listener . mouse Clicked ( ) ; } }
List < File > add Collection Files ( File new Basedir ) throws IO Exception { final Directory Scanner ds = new Directory Scanner ( ) ; ds . set Basedir ( new Basedir ) ; if ( this . includes != null && this . includes . length > NUM ) { ds . set Includes ( this . includes ) ; } else { ds . set Includes ( DEFAULT INCLUDES ) ; } ds . set Excludes ( this . excludes ) ; ds . add Default Excludes ( ) ; ds . set Case Sensitive ( BOOL ) ; ds . set Follow Symlinks ( BOOL ) ; ds . scan ( ) ; List < File > found Files = new Array List < > ( ) ; for ( String filename : ds . get Included Files ( ) ) { found Files . add ( new File ( new Basedir , filename ) ) ; } return found Files ; }
public int size ( ) { return m Selected Widgets . size ( ) ; }
public Query String Decoder ( URI uri , Charset charset , int max Params ) { if ( uri == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( charset == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( max Params <= NUM ) { throw new Illegal Argument Exception ( STRING + max Params + STRING ) ; } String raw Path = uri . get Raw Path ( ) ; if ( raw Path != null ) { has Path = BOOL ; } else { raw Path = STRING ; has Path = BOOL ; } this . uri = raw Path + ( uri . get Raw Query ( ) == null ? STRING : STRING + uri . get Raw Query ( ) ) ; this . charset = charset ; this . max Params = max Params ; }
public int to Int ( Element el , String attribute Name , int default Value ) { String value = el . get Attribute ( attribute Name ) ; if ( value == null ) return default Value ; int int Value = Caster . to Int Value ( value , Integer . MIN VALUE ) ; if ( int Value == Integer . MIN VALUE ) return default Value ; return int Value ; }
public static Property Info [ ] extract Bean Properties Info ( Type type ) { Class < ? > raw Type = get Raw Type ( type ) ; List < Property Info > result = new Array List < Property Info > ( ) ; List < Method > getter Methods = get Getter Methods ( raw Type ) ; List < Method > setter Methods = get Setter Methods ( raw Type ) ; try { for ( Method setter Method : setter Methods ) { String setter Property = get Property For Getter Or Setter Method ( setter Method ) ; for ( Method getter Method : getter Methods ) { String getter Property = get Property For Getter Or Setter Method ( getter Method ) ; if ( getter Property . equals ( setter Property ) ) { Type return Type = getter Method . get Generic Return Type ( ) ; Type property Type = get Property Type ( return Type , type , raw Type ) ; result . add ( new Property Info ( setter Property , property Type , getter Method , setter Method ) ) ; break ; } } } } catch ( Exception e ) { throw new Runtime Exception ( STRING + raw Type . get Canonical Name ( ) , e ) ; } return result . to Array ( new Property Info [ result . size ( ) ] ) ; }
private int remove Next ( ) { if ( last Usage Dates . is Empty ( ) ) { return INVALID SIZE ; } Long oldest Usage = null ; File most Long Used File = null ; Set < Entry < File , Long > > entries = last Usage Dates . entry Set ( ) ; synchronized ( last Usage Dates ) { for ( Entry < File , Long > entry : entries ) { if ( most Long Used File == null ) { most Long Used File = entry . get Key ( ) ; oldest Usage = entry . get Value ( ) ; } else { Long last Value Usage = entry . get Value ( ) ; if ( last Value Usage < oldest Usage ) { oldest Usage = last Value Usage ; most Long Used File = entry . get Key ( ) ; } } } } int file Size = NUM ; if ( most Long Used File != null ) { if ( most Long Used File . exists ( ) ) { file Size = get Size ( most Long Used File ) ; if ( most Long Used File . delete ( ) ) { last Usage Dates . remove ( most Long Used File ) ; } } else { last Usage Dates . remove ( most Long Used File ) ; } } return file Size ; }
public String search ( ) throws Exception { execute Query ( ) ; return SUCCESS ; }
public List < Endpoint Handle > bind ( String bind Address , Endpoint endpoint Address ) throws Service Result Exception { List < Endpoint Handle > result = new Array List < Endpoint Handle > ( ) ; String scheme = Uri Util . get Transport Protocol ( bind Address ) ; List < Socket Address > socket Addresses = Endpoint Util . to Socket Addresses ( bind Address ) ; if ( socket Addresses . is Empty ( ) ) return Collections . empty List ( ) ; Endpoint Server endpoint Server = application . get Or Create Endpoint Server ( scheme ) ; for ( Socket Address socket Address : socket Addresses ) { Endpoint Binding eb = new Endpoint Binding ( endpoint Server , endpoint Address , this ) ; Endpoint Handle handle = endpoint Server . bind ( socket Address , eb ) ; bound Handles . add ( handle ) ; } return result ; }
@ Suppress Warnings ( STRING ) public static void register ( String algorithm URI , String implementing Class ) throws Algorithm Already Registered Exception , Class Not Found Exception , XML Signature Exception { Java Utils . check Register Permission ( ) ; if ( log . is Loggable ( java . util . logging . Level . FINE ) ) { log . log ( java . util . logging . Level . FINE , STRING + algorithm URI + STRING + implementing Class ) ; } Class < ? extends Signature Algorithm Spi > registered Class = algorithm Hash . get ( algorithm URI ) ; if ( registered Class != null ) { Object ex Args [ ] = { algorithm URI , registered Class } ; throw new Algorithm Already Registered Exception ( STRING , ex Args ) ; } try { Class < ? extends Signature Algorithm Spi > clazz = ( Class < ? extends Signature Algorithm Spi > ) Class Loader Utils . load Class ( implementing Class , Signature Algorithm . class ) ; algorithm Hash . put ( algorithm URI , clazz ) ; } catch ( Null Pointer Exception ex ) { Object ex Args [ ] = { algorithm URI , ex . get Message ( ) } ; throw new XML Signature Exception ( STRING , ex Args , ex ) ; } }
public void load ( Path settings Path ) { m Loading Settings = BOOL ; if ( Files . exists ( settings Path ) ) { m Log . info ( STRING + settings Path . to String ( ) + STRING ) ; JAXB Context context = null ; Input Stream in = null ; try { in = new File Input Stream ( settings Path . to String ( ) ) ; try { context = JAXB Context . new Instance ( Settings . class ) ; Unmarshaller m = context . create Unmarshaller ( ) ; m Settings = ( Settings ) m . unmarshal ( in ) ; } catch ( JAXB Exception e ) { m Log . error ( STRING + STRING , e ) ; } } catch ( Exception e ) { m Log . error ( STRING + STRING + settings Path . to String ( ) + STRING , e ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IO Exception e ) { m Log . error ( STRING + STRING , e ) ; } } } } else { m Log . info ( STRING + settings Path . to String ( ) + STRING ) ; } if ( m Settings == null ) { m Settings = new Settings ( ) ; } load Tuner Configuration Model ( ) ; m Loading Settings = BOOL ; }
public boolean contains Explicit Char ( final @ Non Null Char Sequence input ) { if ( ! Text Utils . is Empty ( input ) ) { for ( int i = NUM ; i < input . length ( ) ; i ++ ) { char c = input . char At ( i ) ; if ( is Explicit Char ( c ) ) { return BOOL ; } } } return BOOL ; }
private void check End Pt Vertex Intersections ( ) { for ( Iterator i = seg Strings . iterator ( ) ; i . has Next ( ) ; ) { Segment String ss = ( Segment String ) i . next ( ) ; Coordinate [ ] pts = ss . get Coordinates ( ) ; check End Pt Vertex Intersections ( pts [ NUM ] , seg Strings ) ; check End Pt Vertex Intersections ( pts [ pts . length - NUM ] , seg Strings ) ; } }
private < T > Unary Operator < T > chain Operators ( Stream < Unary Operator < T > > operators ) { return operators . reduce ( Unary Operator . identity ( ) , null ) ; }
public void add Attribute Spec ( String spec ) { Attribute Spec new Spec = new Attribute Spec ( spec ) ; m attribute Specs . add ( new Spec ) ; }
public static String convert To Java Class Name ( String name ) { int dot Index = name . index Of ( STRING ) ; if ( dot Index >= NUM ) { name = name . substring ( NUM , dot Index ) ; } String [ ] split = name . split ( STRING ) ; String Builder out = new String Builder ( ) ; for ( String section : split ) { out . append ( String Util . capitalize ( section ) ) ; } return out . to String ( ) ; }
public final boolean delete ( String where ) { SQ Lite Database execute = get Writer ( ) ; String sql = STRING + get Table Name ( ) + STRING + where ; try { execute . exec SQL ( sql ) ; return BOOL ; } catch ( SQL Exception e ) { return BOOL ; } finally { close Writer ( execute ) ; } }
private void update Done Text ( Array List < String > result List ) { int size = NUM ; if ( result List == null || result List . size ( ) <= NUM ) { m Submit Button . set Text ( R . string . mis action done ) ; m Submit Button . set Enabled ( BOOL ) ; } else { size = result List . size ( ) ; m Submit Button . set Enabled ( BOOL ) ; } m Submit Button . set Text ( get String ( R . string . mis action button string , get String ( R . string . mis action done ) , size , m Default Count ) ) ; }
private void create Migration Rule Page ( ) { Migration Rule Editor migration Rule Editor = new Migration Rule Editor ( get Container ( ) , migration Task ) ; int index = add Page ( migration Rule Editor . get Control ( ) ) ; set Page Text ( index , STRING ) ; task Listeners . add ( migration Rule Editor ) ; }
private String next ( Pattern pattern ) throws Decode Exception { Matcher matcher = pattern . matcher ( gser Value . substring ( pos , length ) ) ; if ( matcher . find ( ) && matcher . group Count ( ) >= NUM ) { pos += matcher . end ( NUM ) ; return matcher . group ( NUM ) ; } else { final Localizable Message msg = WARN GSER PATTERN NO MATCH . get ( pattern . pattern ( ) , gser Value . substring ( pos , length ) ) ; throw Decode Exception . error ( msg ) ; } }
public void push ( final int value ) { if ( value >= - NUM && value <= NUM ) { mv . visit Insn ( Opcodes . ICONST 0 + value ) ; } else if ( value >= Byte . MIN VALUE && value <= Byte . MAX VALUE ) { mv . visit Int Insn ( Opcodes . BIPUSH , value ) ; } else if ( value >= Short . MIN VALUE && value <= Short . MAX VALUE ) { mv . visit Int Insn ( Opcodes . SIPUSH , value ) ; } else { mv . visit Ldc Insn ( value ) ; } }
public void dump ( Print Stream ps Out , int indent Amount ) { Print Writer out ; try { out = new Print Writer ( new Output Stream Writer ( ps Out , STRING ) , BOOL ) ; } catch ( Unsupported Encoding Exception e ) { out = new Print Writer ( ps Out , BOOL ) ; } indent ( out , indent Amount ) ; if ( get Name ( ) == null ) { out . print ( STRING ) ; } else { out . print ( STRING + get Name ( ) ) ; } if ( get Attribute Count ( ) > NUM ) { out . println ( STRING ) ; Enumeration names = attributes . get Attribute Names ( ) ; while ( names . has More Elements ( ) ) { Object name = names . next Element ( ) ; indent ( out , indent Amount + NUM ) ; out . println ( name + STRING + get Attribute ( name ) ) ; } indent ( out , indent Amount ) ; } out . println ( STRING ) ; if ( is Leaf ( ) ) { indent ( out , indent Amount + NUM ) ; out . print ( STRING + get Start Offset ( ) + STRING + get End Offset ( ) + STRING ) ; Content c = get Content ( ) ; try { String content Str = c . get String ( get Start Offset ( ) , get End Offset ( ) - get Start Offset ( ) ) ; if ( content Str . length ( ) > NUM ) { content Str = content Str . substring ( NUM , NUM ) + STRING ; } out . println ( STRING + content Str + STRING ) ; } catch ( Bad Location Exception e ) { } } else { int n = get Element Count ( ) ; for ( int i = NUM ; i < n ; i ++ ) { Abstract Element e = ( Abstract Element ) get Element ( i ) ; e . dump ( ps Out , indent Amount + NUM ) ; } } }
public void add ( int position , T item ) { items . add ( position , item ) ; notify Item Inserted ( position ) ; }
public List < String > split String With Default Delimiter ( String input String ) { List < String > split String = new Array List < > ( ) ; if ( input String != null ) { String Tokenizer string Tokenizer = new String Tokenizer ( input String , configuration Helper . get Property ( Configuration Value . FIELD DATA DELIMITER ) ) ; while ( string Tokenizer . has More Elements ( ) ) { split String . add ( string Tokenizer . next Token ( ) ) ; } } return split String ; }
protected final boolean read Available Non Blocking ( ) throws IO Exception { char [ ] buffer = my Buffer ; String Builder token = my Text Buffer ; token . set Length ( NUM ) ; boolean read = BOOL ; while ( my Reader . ready ( ) ) { int n = my Reader . read ( buffer ) ; if ( n <= NUM ) break ; read = BOOL ; process Line ( buffer , token , n ) ; } submit Token ( ) ; return read ; }
public Obligation Policy Database Entry add Parameter Deletes Obligation Database Entry ( X Method xmethod , Obligation obligation , Obligation Policy Database Entry Type entry Type ) { Obligation Policy Database Entry entry = new Match Method Entry ( xmethod , Obligation Policy Database Action Type . DEL , entry Type , obligation ) ; add Entry ( entry ) ; return entry ; }
private static Content Impl parse Content ( Ole Blob Impl blob ) throws IO Exception { Byte Buffer bb = Page Channel . wrap ( blob . get Bytes ( ) ) ; if ( ( bb . remaining ( ) < NUM ) || ( bb . get Short ( ) != PACKAGE SIGNATURE ) ) { return new Unknown Content Impl ( blob ) ; } int header Size = bb . get Short ( ) ; bb . get Int ( ) ; int pretty Name Len = bb . get Short ( ) ; int class Name Len = bb . get Short ( ) ; int pretty Name Off = bb . get Short ( ) ; int class Name Off = bb . get Short ( ) ; bb . get Int ( ) ; String pretty Name = read Str ( bb , pretty Name Off , pretty Name Len ) ; String class Name = read Str ( bb , class Name Off , class Name Len ) ; bb . position ( header Size ) ; int ole Ver = bb . get Int ( ) ; bb . get Int ( ) ; if ( ole Ver != OLE VERSION ) { return new Unknown Content Impl ( blob ) ; } int type Name Len = bb . get Int ( ) ; String type Name = read Str ( bb , bb . position ( ) , type Name Len ) ; bb . get Long ( ) ; int data Block Len = bb . get Int ( ) ; int data Block Pos = bb . position ( ) ; if ( SIMPLE PACKAGE TYPE . equals Ignore Case ( type Name ) ) { return create Simple Package Content ( blob , pretty Name , class Name , type Name , bb , data Block Len ) ; } if ( ( COMPOUND FACTORY != null ) && ( bb . remaining ( ) >= COMPOUND STORAGE SIGNATURE . length ) && Byte Util . matches Range ( bb , bb . position ( ) , COMPOUND STORAGE SIGNATURE ) ) { return COMPOUND FACTORY . create Compound Package Content ( blob , pretty Name , class Name , type Name , bb , data Block Len ) ; } return new Other Content Impl ( blob , pretty Name , class Name , type Name , data Block Pos , data Block Len ) ; }
@ Override public Instances define Data Format ( ) throws Exception { set Options ( get Options ( ) ) ; check Coverage ( ) ; Random random = new Random ( get Seed ( ) ) ; set Random ( random ) ; Instances dataset ; Array List < Attribute > attributes = new Array List < Attribute > ( NUM ) ; Attribute attribute ; boolean class Flag = get Class Flag ( ) ; Array List < String > class Values = null ; if ( class Flag ) { class Values = new Array List < String > ( get Clusters ( ) . length ) ; } Array List < String > bool Values = new Array List < String > ( NUM ) ; bool Values . add ( STRING ) ; bool Values . add ( STRING ) ; Array List < String > nom Values = null ; for ( int i = NUM ; i < get Num Attributes ( ) ; i ++ ) { if ( m boolean Cols . is In Range ( i ) ) { attribute = new Attribute ( STRING + i , bool Values ) ; } else if ( m nominal Cols . is In Range ( i ) ) { nom Values = new Array List < String > ( m num Values [ i ] ) ; for ( int j = NUM ; j < m num Values [ i ] ; j ++ ) { nom Values . add ( STRING + j ) ; } attribute = new Attribute ( STRING + i , nom Values ) ; } else { attribute = new Attribute ( STRING + i ) ; } attributes . add ( attribute ) ; } if ( class Flag ) { for ( int i = NUM ; i < get Clusters ( ) . length ; i ++ ) { class Values . add ( STRING + i ) ; } attribute = new Attribute ( STRING , class Values ) ; attributes . add ( attribute ) ; } dataset = new Instances ( get Relation Name To Use ( ) , attributes , NUM ) ; if ( class Flag ) { dataset . set Class Index ( m Num Attributes ) ; } Instances format = new Instances ( dataset , NUM ) ; set Dataset Format ( format ) ; for ( int i = NUM ; i < get Clusters ( ) . length ; i ++ ) { Subspace Cluster Definition cl = ( Subspace Cluster Definition ) get Clusters ( ) [ i ] ; cl . set Num Instances ( random ) ; cl . set Parent ( this ) ; } return dataset ; }
@ Override public List < Match Result > find ( String str , int max Results ) { str = str . trim ( ) ; List < Match Result > results = new Array List < Match Result > ( ) ; int start = NUM ; while ( start != - NUM ) { start = str . index Of ( string , start ) ; if ( start != - NUM ) { int end = start + string . length ( ) ; if ( ! whole || String Utils . is Delimited ( str , start , end ) ) { results . add ( new Match Result ( start , end ) ) ; } if ( results . size ( ) >= max Results ) { return results ; } start = end ; } } return results ; }
public static Map < String , String [ ] > to Multi Map ( Named List params ) { Hash Map < String , String [ ] > map = new Hash Map < > ( ) ; for ( int i = NUM ; i < params . size ( ) ; i ++ ) { String name = params . get Name ( i ) ; Object val = params . get Val ( i ) ; if ( val instanceof String [ ] ) { Multi Map Solr Params . add Param ( name , ( String [ ] ) val , map ) ; } else if ( val instanceof List ) { List l = ( List ) val ; String [ ] s = new String [ l . size ( ) ] ; for ( int j = NUM ; j < l . size ( ) ; j ++ ) { s [ j ] = l . get ( j ) == null ? null : String . value Of ( l . get ( j ) ) ; } Multi Map Solr Params . add Param ( name , s , map ) ; } else { Multi Map Solr Params . add Param ( name , val . to String ( ) , map ) ; } } return map ; }
public Statement using ( Object ... columns ) { statement . append ( STRING ) ; append Clauses ( columns ) ; statement . append ( STRING ) ; return this ; }
private void buffer Content ( ) { if ( buffer != null ) { return ; } if ( content != null ) { try { final Byte Array Output Stream tmp = new Byte Array Output Stream ( ) ; final byte [ ] data = new byte [ NUM ] ; int l = NUM ; while ( ( l = content . read ( data ) ) >= NUM ) { tmp . write ( data , NUM , l ) ; } buffer = tmp . to Byte Array ( ) ; content = null ; content Length = buffer . length ; } catch ( final IO Exception e ) { LOG . error ( e . get Message ( ) , e ) ; buffer = null ; content = null ; content Length = NUM ; } } }
public static Geo Time Serie normalize ( Geo Time Serie gts ) { if ( ( TYPE . DOUBLE != gts . get Type ( ) && TYPE . LONG != gts . get Type ( ) ) || NUM == gts . values ) { return gts . clone ( ) ; } double dmin = Double . POSITIVE INFINITY ; double dmax = Double . NEGATIVE INFINITY ; long lmin = Long . MAX VALUE ; long lmax = Long . MIN VALUE ; if ( TYPE . LONG == gts . get Type ( ) ) { for ( int i = NUM ; i < gts . values ; i ++ ) { long value = ( long ) GTS Helper . value At Index ( gts , i ) ; if ( value > lmax ) { lmax = value ; } if ( value < lmin ) { lmin = value ; } } } else { for ( int i = NUM ; i < gts . values ; i ++ ) { double value = ( double ) GTS Helper . value At Index ( gts , i ) ; if ( value > dmax ) { dmax = value ; } if ( value < dmin ) { dmin = value ; } } } boolean constant = BOOL ; if ( lmin == lmax || dmin == dmax ) { constant = BOOL ; } Geo Time Serie normalized = new Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , gts . values ) ; normalized . set Name ( gts . get Name ( ) ) ; normalized . set Labels ( gts . get Labels ( ) ) ; for ( int i = NUM ; i < gts . values ; i ++ ) { Object value ; if ( constant ) { value = NUM ; } else if ( TYPE . LONG == gts . get Type ( ) ) { value = ( ( long ) GTS Helper . value At Index ( gts , i ) - lmin ) / ( double ) ( lmax - lmin ) ; } else { value = ( ( double ) GTS Helper . value At Index ( gts , i ) - dmin ) / ( double ) ( dmax - dmin ) ; } GTS Helper . set Value ( normalized , gts . ticks [ i ] , GTS Helper . location At Index ( gts , i ) , GTS Helper . elevation At Index ( gts , i ) , value , BOOL ) ; } return normalized ; }
public Multi Match Query Builder field ( String field , float boost ) { fields . add ( field ) ; if ( fields Boosts == null ) { fields Boosts = new Object Float Hash Map < > ( ) ; } fields Boosts . put ( field , boost ) ; return this ; }
public < R > Future W < R > flat Map Cf ( final Function < ? super T , ? extends Completion Stage < ? extends R > > mapper ) { return Future W . < R > of ( future . < R > then Compose ( null ) ) ; }
protected void next Table ( ) throws Replicator Exception , SQL Exception { while ( import Tables . next ( ) ) { if ( include Import Table ( ) == BOOL ) { current Table Position = NUM ; extract Create Table Statement = this . include Structure ; prepare Import Table ( ) ; break ; } } }
public void test Neg Pos ( ) { byte a Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM } ; int a Sign = - NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private void request Streams Info 2 ( Set < String > streams , boolean special ) { Set < String > streams For Request = new Hash Set < > ( ) ; Set < Stream Info > stream Infos For Request = new Hash Set < > ( ) ; for ( String stream : streams ) { Stream Info cached = get Stream Info ( stream ) ; if ( ! cached . is Requested ( ) && ( ! special || cached . recheck Offline ( ) ) ) { streams For Request . add ( stream ) ; stream Infos For Request . add ( cached ) ; cached . set Requested ( ) ; } } if ( special ) { special Check Last Done = System . current Time Millis ( ) ; } if ( ! streams For Request . is Empty ( ) ) { if ( ! special ) { streams Info Last Requested = System . current Time Millis ( ) ; } String url = api . request Streams Info ( streams For Request ) ; pending Requests . put ( url , stream Infos For Request ) ; } }
public static Sentence new Conjunction ( Sentence ... conjuncts ) { return new Conjunction ( Arrays . as List ( conjuncts ) ) ; }
public boolean is Plural ( ) { return type String . contains ( SUFFIX PLURAL ) ; }
protected void append Char Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STRING ) ; }
public static Vector tokenize String ( String source , char separator ) { Vector tokenized = new Vector ( ) ; int len = source . length ( ) ; boolean last Separator = BOOL ; String Builder buf = new String Builder ( ) ; for ( int iter = NUM ; iter < len ; iter ++ ) { char current = source . char At ( iter ) ; if ( current == separator ) { if ( last Separator ) { buf . append ( separator ) ; last Separator = BOOL ; continue ; } last Separator = BOOL ; if ( buf . length ( ) > NUM ) { tokenized . add Element ( buf . to String ( ) ) ; buf = new String Builder ( ) ; } } else { last Separator = BOOL ; buf . append ( current ) ; } } if ( buf . length ( ) > NUM ) { tokenized . add Element ( buf . to String ( ) ) ; } return tokenized ; }
private void backup Favorites ( Backup Data Output data ) throws IO Exception { Content Resolver cr = m Context . get Content Resolver ( ) ; Cursor cursor = cr . query ( Favorites . CONTENT URI , FAVORITE PROJECTION , get User Selection Arg ( ) , null , null ) ; try { cursor . move To Position ( - NUM ) ; while ( cursor . move To Next ( ) ) { final long id = cursor . get Long ( ID INDEX ) ; final long update Time = cursor . get Long ( ID MODIFIED ) ; Key key = get Key ( Key . FAVORITE , id ) ; m Keys . add ( key ) ; final String backup Key = key To Backup Key ( key ) ; if ( ! m Existing Keys . contains ( backup Key ) || update Time >= m Last Backup Restore Time || restored Backup Version < NUM ) { write Row To Backup ( key , pack Favorite ( cursor ) , data ) ; } else { if ( DEBUG ) Log . d ( TAG , STRING + id ) ; } } } finally { cursor . close ( ) ; } }
private void update Internal ( ) throws Exception { long uptime = runtime MX Bean . get Uptime ( ) ; long cpu Time = proxy Client . get Process Cpu Time ( ) ; long gc Time = sum GC Times ( ) ; gc Count = sum GC Count ( ) ; if ( last Up Time > NUM && last CPU Time > NUM && gc Time > NUM ) { delta Uptime = uptime - last Up Time ; delta Cpu Time = ( cpu Time - last CPU Time ) / NUM ; delta Gc Time = gc Time - last Gc Time ; gc Load = calc Load ( delta Cpu Time , delta Gc Time ) ; cpu Load = calc Load ( delta Uptime , delta Cpu Time ) ; } last Up Time = uptime ; last CPU Time = cpu Time ; last Gc Time = gc Time ; total Loaded Class Count = class Loading MX Bean . get Total Loaded Class Count ( ) ; thread Count = thread MX Bean . get Thread Count ( ) ; }
public void hide Validation Messages ( ) { for ( Validation Error Message invalid Field : validation Messages ) { View view = parent View . find View With Tag ( invalid Field . get Payment Product Field Id ( ) ) ; validation Message Renderer . remove Validation Message ( ( View Group ) view . get Parent ( ) , invalid Field . get Payment Product Field Id ( ) ) ; } validation Messages . clear ( ) ; field Ids Of Error Messages Showing . clear ( ) ; }
public Key Store History ( Key Store key Store , String name , Password password , Provider explicit Provider ) { this . name = name ; this . explicit Provider = explicit Provider ; Key Store Type type = Key Store Type . resolve Jce ( key Store . get Type ( ) ) ; if ( type . is File Based ( ) ) { initial State = new Key Store State ( this , key Store , password ) ; } else { initial State = new Always Identical Key Store State ( this , key Store , password ) ; } current State = initial State ; }
public static Map < String , List < String > > to Multimap ( Headers headers , String value For Null Key ) { Map < String , List < String > > result = new Tree Map < > ( FIELD NAME COMPARATOR ) ; for ( int i = NUM , size = headers . size ( ) ; i < size ; i ++ ) { String field Name = headers . name ( i ) ; String value = headers . value ( i ) ; List < String > all Values = new Array List < > ( ) ; List < String > other Values = result . get ( field Name ) ; if ( other Values != null ) { all Values . add All ( other Values ) ; } all Values . add ( value ) ; result . put ( field Name , Collections . unmodifiable List ( all Values ) ) ; } if ( value For Null Key != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( value For Null Key ) ) ) ; } return Collections . unmodifiable Map ( result ) ; }
public void state Changed ( Change Event e ) { J Slider j = ( J Slider ) e . get Source ( ) ; Bounded Range Model r = j . get Model ( ) ; for ( int i = NUM ; i < n Values ; i ++ ) { if ( r == models [ i ] ) { set Model ( i , r . get Value ( ) ) ; break ; } } prop . fire Property Change ( STRING , null , j ) ; }
public void index ( Tuple t , String field ) { String s ; if ( ( s = t . get String ( field ) ) == null ) return ; String Tokenizer st = new String Tokenizer ( s , m delim ) ; while ( st . has More Tokens ( ) ) { String tok = st . next Token ( ) ; add String ( tok , t ) ; } }
private J Panel no Data Source Panel ( ) { J Panel panel = new J Panel ( ) ; panel . set Layout ( new Border Layout ( ) ) ; J Panel label Panel = new J Panel ( ) ; label Panel . set Layout ( new Grid Bag Layout ( ) ) ; J Label label = new J Label ( Localisation . get String ( Map Render . class , STRING ) ) ; label . set Font ( new Font ( STRING , Font . BOLD , NUM ) ) ; label Panel . add ( label ) ; label Panel . set Border ( Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; panel . add ( label Panel , Border Layout . CENTER ) ; return panel ; }
@ Override public void trigger ( Dialogue State state , Collection < String > updated Vars ) { if ( frame != null && frame . is Visible ( ) ) { chat Tab . trigger ( state , updated Vars ) ; state Monitor Tab . refresh ( state , updated Vars ) ; } refresh ( ) ; }
public static Mosaic Definition create Mosaic Definition ( final Account creator , final Mosaic Levy levy ) { return create Mosaic Definition ( creator , Utils . create Mosaic Id ( STRING , STRING ) , create Mosaic Properties ( ) , levy ) ; }
private void construct Alias Table Array ( Long 2 Double Map seeds With Weights , long [ ] index Array , int [ ] alias Table Array ) { int index = NUM ; int average Weight = NUM ; for ( Long 2 Double Map . Entry entry : seeds With Weights . long 2 Double Entry Set ( ) ) { long seed = entry . get Long Key ( ) ; double seed Weight = entry . get Double Value ( ) ; index Array [ index ] = seed ; int final Weight = ( int ) ( Math . round ( MULTIPER FOR ALIASTABLE * seed Weight * bipartite Graph . get Left Node Degree ( seed ) ) ) ; Int Array Alias Table . set Entry ( alias Table Array , index , index ) ; Int Array Alias Table . set Weight ( alias Table Array , index , final Weight ) ; average Weight += final Weight ; index ++ ; } Int Array Alias Table . set Alias Table Size ( alias Table Array , index ) ; Int Array Alias Table . set Alias Table Average Weight ( alias Table Array , average Weight / index ) ; Alias Table Util . construct Alias Table ( alias Table Array ) ; }
private static SSL Context create Easy SSL Context ( ) { SSL Context context ; try { context = SSL Context . get Instance ( STRING ) ; context . init ( null , trust Managers , new Secure Random ( ) ) ; Https URL Connection . set Default SSL Socket Factory ( context . get Socket Factory ( ) ) ; } catch ( final General Security Exception gse ) { throw new Illegal State Exception ( gse . get Message ( ) ) ; } return context ; }
public static void format Tooltips ( Container container ) { for ( int i = NUM ; i < container . get Component Count ( ) ; i ++ ) { Component component = container . get Component ( i ) ; if ( component instanceof J Component ) format Tooltip ( ( J Component ) component ) ; if ( component instanceof Container ) format Tooltips ( ( Container ) component ) ; } }
public void fill Field Values ( final Array List < Randomizer > randomizers ) { Parameter Getter < Randomizer , Prob Distribution > pdf Getter = null ; if ( ! Network Utils . is Consistent ( randomizers , pdf Getter ) ) { if ( ! ( cb Distribution . get Item Count ( ) == Prob Distribution . values ( ) . length ) ) { cb Distribution . add Item ( Prob Distribution . NULL ) ; cb Distribution . set Selected Index ( cb Distribution . get Item Count ( ) - NUM ) ; } card Panel . remove All ( ) ; card Panel . add ( new J Panel ( ) ) ; card Panel . repaint ( ) ; if ( parent != null ) { parent . pack ( ) ; parent . set Location Relative To ( null ) ; } } else { if ( cb Distribution . get Item Count ( ) == Prob Distribution . values ( ) . length ) { cb Distribution . remove Item ( Prob Distribution . NULL ) ; } Randomizer rand = ( Randomizer ) randomizers . get ( NUM ) ; Prob Dist Panel rp = card Map . get ( rand . get Pdf ( ) ) ; cb Distribution . set Selected Item ( rand . get Pdf ( ) ) ; rp . fill Field Values ( randomizers ) ; card Panel . remove All ( ) ; card Panel . add ( rp . get Panel ( ) ) ; card Panel . repaint ( ) ; if ( parent != null ) { parent . pack ( ) ; parent . set Location Relative To ( null ) ; } } }
public void await Timeout ( long await Timeout , long await Join ) throws Interrupted Exception { long end = System . nano Time ( ) + await Timeout * NUM * NUM ; for ( Thread t : threads ) { long time = System . nano Time ( ) ; if ( time < end ) { t . join ( ( ( end - time ) / NUM ) , ( int ) ( ( end - time ) % NUM ) ) ; } } check ( numthreads , NUM , NUM ) ; for ( Thread t : threads ) { t . interrupt ( ) ; } end = System . nano Time ( ) + await Join * NUM * NUM ; for ( Thread t : threads ) { long time = System . nano Time ( ) ; if ( time < end ) { t . join ( ( ( end - time ) / NUM ) , ( int ) ( ( end - time ) % NUM ) ) ; } } check ( numthreads , NUM , numthreads ) ; }
private void bcopy ( int cidx , int bidx ) { int length = m Ch Idx - cidx ; if ( ( bidx + length + NUM ) >= m Buff . length ) { char buff [ ] = new char [ m Buff . length + length ] ; System . arraycopy ( m Buff , NUM , buff , NUM , m Buff . length ) ; m Buff = buff ; } System . arraycopy ( m Chars , cidx , m Buff , bidx , length ) ; m Buff Idx += length ; }
protected Collection < Data Support > check Associated Model Collection ( Collection < Data Support > associated Model Collection , Field associated Field ) { Collection < Data Support > collection = null ; if ( is List ( associated Field . get Type ( ) ) ) { collection = new Array List < Data Support > ( ) ; } else if ( is Set ( associated Field . get Type ( ) ) ) { collection = new Hash Set < Data Support > ( ) ; } else { throw new Data Support Exception ( Data Support Exception . WRONG FIELD TYPE FOR ASSOCIATIONS ) ; } if ( associated Model Collection != null ) { collection . add All ( associated Model Collection ) ; } return collection ; }
public Node remove ( Coordinate pt ) { return ( Node ) node Map . remove ( pt ) ; }
private void check To Repaint ( ) { long time Passed = ( System . current Time Millis ( ) - last Repainted ) / NUM ; if ( time Passed > REPAINT DELAY ) { repaint ( ) ; last Repainted = System . current Time Millis ( ) ; } }
private void collect Diff Changes ( ) throws Vcs Exception { Collection < File Path > dirty Paths = dirty Paths ( BOOL ) ; if ( dirty Paths . is Empty ( ) ) { return ; } try { String output = Git Change Utils . get Diff Output ( my Project , my Vcs Root , STRING , dirty Paths ) ; Git Change Utils . parse Changes ( my Project , my Vcs Root , null , Git Change Utils . resolve Reference ( my Project , my Vcs Root , STRING ) , output , my Changes , my Unmerged Names ) ; } catch ( Vcs Exception ex ) { if ( ! Git Change Utils . is Head Missing ( ex ) ) { throw ex ; } Git Simple Handler handler = new Git Simple Handler ( my Project , my Vcs Root , Git Command . LS FILES ) ; handler . add Parameters ( STRING ) ; handler . set Silent ( BOOL ) ; handler . set Stdout Suppressed ( BOOL ) ; String output = handler . run ( ) ; if ( output . length ( ) > NUM ) { String Tokenizer tokenizer = new String Tokenizer ( output , STRING ) ; while ( tokenizer . has More Tokens ( ) ) { final String s = tokenizer . next Token ( ) ; Change ch = new Change ( null , Git Content Revision . create Revision ( my Vcs Root , s , null , my Project , BOOL , BOOL , BOOL ) , File Status . ADDED ) ; my Changes . add ( ch ) ; } } } }
public int compute ( String line ) { this . line = line ; int count = NUM ; if ( attempt First Word ) { int a = NUM ; while ( a < line . length ( ) ) { if ( line . char At ( a ) == STRING || Character . is Whitespace ( line . char At ( a ) ) ) a ++ ; else break ; } int b = a + NUM ; while ( b < line . length ( ) ) { int ch = line . char At ( b ) ; if ( Character . is Letter Or Digit ( ch ) || ch == STRING || ch == STRING ) b ++ ; else break ; } if ( b - a > NUM ) { pairs [ count ] [ NUM ] = a ; pairs [ count ++ ] [ NUM ] = b ; } } if ( id Tags . length > NUM ) { for ( String tag : id Tags ) { int b ; for ( int a = line . index Of ( tag ) ; a != - NUM ; a = line . index Of ( tag , b + NUM ) ) { a += tag . length ( ) ; b = a + NUM ; while ( b < line . length ( ) && ( Character . is Letter Or Digit ( line . char At ( b ) ) || line . char At ( b ) == STRING ) ) b ++ ; if ( b > a ) { if ( count == pairs . length ) pairs = Multi Words . grow ( pairs ) ; pairs [ count ] [ NUM ] = a ; pairs [ count ++ ] [ NUM ] = b ; } } } } return count ; }
private File calc Parent Tree ( ) { File parent Tree = tree File . get Parent File ( ) ; if ( null == parent Tree ) { return null ; } if ( tree File . is Absolute ( ) && ( null == parent Tree . get Parent File ( ) ) ) { return null ; } return parent Tree ; }
Input Stream read Channel ( int channel ) throws IO Exception { while ( ! is Closed ) { if ( input Ready [ channel ] ) { input Ready [ channel ] = BOOL ; return is ; } boolean can Read = BOOL ; synchronized ( READ LOCK ) { if ( ! is Read Locked ) { is Read Locked = BOOL ; can Read = BOOL ; } else { try { READ LOCK . wait ( NUM ) ; } catch ( Exception e ) { } } } if ( can Read ) { try { read Data ( ) ; } catch ( IO Exception e ) { close ( ) ; } } } return null ; }
public T remove ( int position ) { T removed = items . remove ( position ) ; notify Item Removed ( position ) ; return removed ; }
public double next Double ( double mean , double standard Deviation ) { if ( cache Filled && this . mean == mean && this . standard Deviation == standard Deviation ) { cache Filled = BOOL ; return cache ; } ; double x , y , r , z ; do { x = NUM * random Generator . raw ( ) - NUM ; y = NUM * random Generator . raw ( ) - NUM ; r = x * x + y * y ; } while ( r >= NUM ) ; z = Math . sqrt ( - NUM * Math . log ( r ) / r ) ; cache = mean + standard Deviation * x * z ; cache Filled = BOOL ; return mean + standard Deviation * y * z ; }
private static void split All Live Ranges ( Instruction s , java . util . Hash Map < Register , Register > new Map , IR ir , boolean root Only ) { for ( Enumeration < Operand > u = root Only ? s . get Root Uses ( ) : s . get Uses ( ) ; u . has More Elements ( ) ; ) { Operand use = u . next Element ( ) ; if ( use . is Register ( ) ) { Register Operand r Use = use . as Register ( ) ; Register Operand temp = find Or Create Temp ( r Use , new Map , ir ) ; insert Move Before ( temp , r Use . copy RO ( ) , s ) ; } } for ( Enumeration < Operand > d = s . get Defs ( ) ; d . has More Elements ( ) ; ) { Operand def = d . next Element ( ) ; if ( def . is Register ( ) ) { Register Operand r Def = def . as Register ( ) ; Register Operand temp = find Or Create Temp ( r Def , new Map , ir ) ; insert Move After ( r Def . copy RO ( ) , temp , s ) ; } } for ( Enumeration < Operand > ops = root Only ? s . get Root Operands ( ) : s . get Operands ( ) ; ops . has More Elements ( ) ; ) { Operand op = ops . next Element ( ) ; if ( op . is Register ( ) ) { Register Operand r Op = op . as Register ( ) ; Register r = r Op . get Register ( ) ; Register new R = new Map . get ( r ) ; if ( new R != null ) { r Op . set Register ( new R ) ; } } } }
public void fire Annotation Misc Changed ( Workflow Annotation anno ) { List < Workflow Annotation > list = new Linked List < > ( ) ; list . add ( anno ) ; fire Annotations Changed ( Annotation Event . MISC CHANGED , list ) ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return BOOL ; m Last Request Ms = now ; if ( delta Ms < NUM * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM ) ; } else { m Delay Ms = MIN DELAY ; } return BOOL ; }
public boolean verify Client Evidence Message ( Big Integer client M 1 ) throws Crypto Exception { if ( ( this . A == null ) || ( this . B == null ) || ( this . S == null ) ) { throw new Crypto Exception ( STRING + STRING ) ; } Big Integer computed M 1 = SRP 6 Util . calculate M 1 ( digest , N , A , B , S ) ; if ( computed M 1 . equals ( client M 1 ) ) { this . M1 = client M 1 ; return BOOL ; } return BOOL ; }
public boolean handle Keyword ( String keyword , int parameter ) { boolean ignore Group If Unknown Keyword Save = ignore Group If Unknown Keyword ; if ( skipping Characters > NUM ) { skipping Characters -- ; return BOOL ; } ignore Group If Unknown Keyword = BOOL ; if ( keyword . equals ( STRING ) ) { parser State . put ( STRING , Integer . value Of ( parameter ) ) ; return BOOL ; } if ( keyword . equals ( STRING ) ) { if ( parameter < NUM ) parameter = parameter + NUM ; handle Text ( ( char ) parameter ) ; Number skip = ( Number ) ( parser State . get ( STRING ) ) ; if ( skip != null ) { skipping Characters = skip . int Value ( ) ; } else { skipping Characters = NUM ; } return BOOL ; } if ( keyword . equals ( STRING ) ) { rtfversion = parameter ; set RTF Destination ( new Document Destination ( ) ) ; return BOOL ; } if ( keyword . starts With ( STRING ) || keyword . equals ( STRING ) ) ignore Group If Unknown Keyword Save = BOOL ; if ( rtf Destination != null ) { if ( rtf Destination . handle Keyword ( keyword , parameter ) ) return BOOL ; } if ( ignore Group If Unknown Keyword Save ) { set RTF Destination ( new Discarding Destination ( ) ) ; } return BOOL ; }
public boolean remove ( URI uri , Http Cookie ck ) { if ( ck == null ) { throw new Null Pointer Exception ( STRING ) ; } boolean modified = BOOL ; lock . lock ( ) ; try { modified = cookie Jar . remove ( ck ) ; } finally { lock . unlock ( ) ; } return modified ; }
private static boolean is Valueless Attribute ( String attrib Name ) { boolean valueless = VALUELESS ATTRIB NAMES . contains ( Strings . lower ( attrib Name ) ) ; return valueless ; }
private Parsed View Detail deflate ( View view ) { Byte Array Output Stream os = new Byte Array Output Stream ( ) ; try { m View Hierarchy . deflate ( view , os ) ; Document Builder Factory factory = Document Builder Factory . new Instance ( ) ; Document Builder document Builder = factory . new Document Builder ( ) ; Document doc = document Builder . parse ( new Byte Array Input Stream ( os . to Byte Array ( ) ) ) ; Element root = ( Element ) doc . get First Child ( ) ; return convert To Node ( root ) ; } catch ( SAX Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Parser Configuration Exception e ) { throw new Runtime Exception ( e ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( is Correct Method ( method , args ) ) { boolean handled = call Target ( args [ NUM ] ) ; set Application Event Handled ( args [ NUM ] , handled ) ; } return null ; }
public void test Case 17 ( ) { byte a Bytes [ ] = { NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public Metadata . Builder clear ( ) { Metadata Builder defaults = new Metadata . Builder ( ) ; type = defaults . type ; interface Type = defaults . interface Type ; optional Builder = defaults . optional Builder ; builder Factory = defaults . builder Factory ; generated Builder = defaults . generated Builder ; value Type = defaults . value Type ; partial Type = defaults . partial Type ; visible Nested Types . clear ( ) ; property Enum = defaults . property Enum ; properties . clear ( ) ; standard Method Underrides . clear ( ) ; builder Serializable = defaults . builder Serializable ; generated Builder Annotations . clear ( ) ; value Type Annotations . clear ( ) ; value Type Visibility = defaults . value Type Visibility ; nested Classes . clear ( ) ; unset Properties . clear ( ) ; unset Properties . add All ( defaults . unset Properties ) ; return ( Metadata . Builder ) this ; }
public float distance ( vec 3 b ) { float x = this . m [ NUM ] - b . m [ NUM ] ; float y = this . m [ NUM ] - b . m [ NUM ] ; float z = this . m [ NUM ] - b . m [ NUM ] ; float result = ( float ) Math . sqrt ( x * x + y * y + z * z ) ; return result ; }
private Properties read Properties ( final String properties File Path ) throws IO Exception { Properties properties = new Properties ( ) ; File props File = new File ( properties File Path ) ; File Input Stream fis = null ; if ( props File . exists ( ) ) { try { fis = new File Input Stream ( props File ) ; properties . load ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } } return properties ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; String Builder sb = new String Builder ( ) ; int len = s . length ( ) ; for ( int i = NUM ; i < len ; i += NUM ) { c = s . char At ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . for Digit ( ( char ) ( ( c > > > NUM ) & NUM ) , NUM ) ) ; sb . append ( Character . for Digit ( ( char ) ( c & NUM ) , NUM ) ) ; } else { sb . append ( c ) ; } } return sb . to String ( ) ; }
public static void assert Equals Ignore Newline ( String expected , String received ) { String expected Clean = remove Newline ( expected ) ; String received Clean = remove Newline ( received ) ; if ( ! expected Clean . equals ( received Clean ) ) { log . error ( STRING + expected Clean ) ; log . error ( STRING + received Clean ) ; Scope Test Helper . assert Equals ( STRING , expected , received ) ; } }
private static Scout Widget [ ] remove Guidelines ( Scout Widget [ ] list ) { Array List < Scout Widget > al = new Array List < > ( ) ; for ( Scout Widget a List : list ) { if ( a List . m Constraint Widget instanceof Guideline ) { continue ; } al . add ( a List ) ; } return al . to Array ( new Scout Widget [ al . size ( ) ] ) ; }
public static int index Of Ignore Case ( String src , char c , int start Index , int end Index ) { if ( start Index < NUM ) { start Index = NUM ; } int srclen = src . length ( ) ; if ( end Index > srclen ) { end Index = srclen ; } c = Character . to Lower Case ( c ) ; for ( int i = start Index ; i < end Index ; i ++ ) { if ( Character . to Lower Case ( src . char At ( i ) ) == c ) { return i ; } } return - NUM ; }
public static Instruction Graph create ( final Reil Graph graph ) { Preconditions . check Not Null ( graph , STRING ) ; final List < Instruction Graph Node > nodes = new Array List < Instruction Graph Node > ( ) ; final List < Instruction Graph Edge > edges = new Array List < Instruction Graph Edge > ( ) ; final Hash Map < Reil Block , Instruction Graph Node > first Node Mapping = new Hash Map < Reil Block , Instruction Graph Node > ( ) ; final Hash Map < Reil Block , Instruction Graph Node > last Node Mapping = new Hash Map < Reil Block , Instruction Graph Node > ( ) ; for ( final Reil Block block : graph ) { Instruction Graph Node last Node = null ; final Reil Instruction last Instruction = Iterables . get Last ( block . get Instructions ( ) ) ; for ( final Reil Instruction instruction : block ) { final Instruction Graph Node current Node = new Instruction Graph Node ( instruction ) ; nodes . add ( current Node ) ; if ( instruction == last Instruction ) { last Node Mapping . put ( block , current Node ) ; } if ( ! first Node Mapping . contains Key ( block ) ) { first Node Mapping . put ( block , current Node ) ; } if ( last Node != null ) { final Instruction Graph Edge edge = new Instruction Graph Edge ( last Node , current Node , Edge Type . JUMP UNCONDITIONAL ) ; edges . add ( edge ) ; Instruction Graph Node . link ( last Node , current Node , edge ) ; } last Node = current Node ; } } for ( final Reil Block block : graph ) { for ( final Reil Edge edge : block . get Outgoing Edges ( ) ) { final Instruction Graph Edge new Edge = new Instruction Graph Edge ( last Node Mapping . get ( block ) , first Node Mapping . get ( edge . get Target ( ) ) , edge . get Type ( ) ) ; edges . add ( new Edge ) ; Instruction Graph Node . link ( last Node Mapping . get ( block ) , first Node Mapping . get ( edge . get Target ( ) ) , new Edge ) ; } } return new Instruction Graph ( nodes , edges ) ; }
public void unlock ( K key ) { Reentrant Lock lock = get Lock ( key ) ; if ( ! lock . is Held By Current Thread ( ) ) { throw new Illegal State Exception ( STRING + key ) ; } lock . unlock ( ) ; }
private Linked List < Diff > diff main ( String text 1 , String text 2 , boolean checklines , long deadline ) { if ( text 1 == null || text 2 == null ) { throw new Illegal Argument Exception ( STRING ) ; } Linked List < Diff > diffs ; if ( text 1 . equals ( text 2 ) ) { diffs = new Linked List < Diff > ( ) ; if ( text 1 . length ( ) != NUM ) { diffs . add ( new Diff ( Operation . EQUAL , text 1 ) ) ; } return diffs ; } int commonlength = diff common Prefix ( text 1 , text 2 ) ; String commonprefix = text 1 . substring ( NUM , commonlength ) ; text 1 = text 1 . substring ( commonlength ) ; text 2 = text 2 . substring ( commonlength ) ; commonlength = diff common Suffix ( text 1 , text 2 ) ; String commonsuffix = text 1 . substring ( text 1 . length ( ) - commonlength ) ; text 1 = text 1 . substring ( NUM , text 1 . length ( ) - commonlength ) ; text 2 = text 2 . substring ( NUM , text 2 . length ( ) - commonlength ) ; diffs = diff compute ( text 1 , text 2 , checklines , deadline ) ; if ( commonprefix . length ( ) != NUM ) { diffs . add First ( new Diff ( Operation . EQUAL , commonprefix ) ) ; } if ( commonsuffix . length ( ) != NUM ) { diffs . add Last ( new Diff ( Operation . EQUAL , commonsuffix ) ) ; } diff cleanup Merge ( diffs ) ; return diffs ; }
public void clear Drop Item List ( ) { drops Items = new Array List < Drop Item > ( ) ; drop Item Instances . clear ( ) ; }
public static < E extends Identifiable > E find By Primary Key ( Entity Manager em , Big Integer id , Class < E > type ) { require Argument ( em != null , STRING ) ; require Argument ( id != null && id . compare To ( ZERO ) > NUM , STRING ) ; require Argument ( type != null , STRING ) ; Typed Query < E > query = em . create Named Query ( STRING , type ) ; query . set Hint ( STRING , STRING ) ; try { query . set Parameter ( STRING , id ) ; query . set Parameter ( STRING , BOOL ) ; return query . get Single Result ( ) ; } catch ( No Result Exception ex ) { return null ; } }
@ Override public int hash Code ( ) { int h = hash ; if ( h == NUM ) { final int n = arity ( ) ; for ( int i = NUM ; i < n ; i ++ ) { final B Op arg = get ( i ) ; h = NUM * h + ( arg == null ? NUM : arg . hash Code ( ) ) ; } hash = h ; } return h ; }
public static boolean verify ( byte [ ] data , byte [ ] signature , byte [ ] pub ) throws Assert Fail Exception { Preconditions . check Argument ( data . length == NUM && signature . length <= NUM && pub . length <= NUM ) ; Byte Buffer byte Buff = native ECDSA Buffer . get ( ) ; if ( byte Buff == null || byte Buff . capacity ( ) < NUM ) { byte Buff = Byte Buffer . allocate Direct ( NUM ) ; byte Buff . order ( Byte Order . native Order ( ) ) ; native ECDSA Buffer . set ( byte Buff ) ; } byte Buff . rewind ( ) ; byte Buff . put ( data ) ; byte Buff . put ( signature ) ; byte Buff . put ( pub ) ; r . lock ( ) ; try { return secp 256 k 1 ecdsa verify ( byte Buff , Secp 256 k 1 Context . get Context ( ) , signature . length , pub . length ) == NUM ; } finally { r . unlock ( ) ; } }
static public void assert Same Iteration Any Order ( final Resource [ ] expected , final Closeable Iteration < ? , ? extends Exception > actual ) throws Exception { assert Same Iteration Any Order ( STRING , expected , actual ) ; }
protected void update Search Bar Text Opacity ( float percentage ) { float overlap Percentage = NUM ; float fading Out Percentage = Math . max ( NUM - ( percentage / overlap Percentage ) , NUM ) ; float fading In Percentage = Math . max ( percentage - ( NUM - overlap Percentage ) , NUM ) / overlap Percentage ; m Search Bar Context Opacity = fading Out Percentage ; m Search Bar Term Opacity = fading In Percentage ; }
@ HLE Function ( nid = NUM , version = NUM ) public int sce Net Resolver Start Ato N ( @ Check Argument ( STRING ) int rid , int addr , T Pointer hostname Addr , int hostname Length , int timeout , int retry ) { try { byte [ ] bytes = sce Net Inet . internet Address To Bytes ( addr ) ; Inet Address inet Address = Inet Address . get By Address ( bytes ) ; String host Name = inet Address . get Host Name ( ) ; hostname Addr . set String NZ ( hostname Length , host Name ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( String . format ( STRING , host Name ) ) ; } } catch ( Unknown Host Exception e ) { log . error ( e ) ; return Sce Kernel Errors . ERROR NET RESOLVER INVALID HOST ; } return NUM ; }
public static List < String > read File ( final File arg File ) throws IO Exception { final Buffered Reader br = new Buffered Reader ( new File Reader ( arg File ) ) ; String line ; List < String > lines = new Array List < String > ( ) ; while ( ( line = br . read Line ( ) ) != null ) { lines . add ( line ) ; } br . close ( ) ; return lines ; }
private static String add IDPP Prefix ( String expression ) { if ( expression == null || expression . length ( ) == NUM ) { return expression ; } if ( expression . index Of ( STRING ) == - NUM ) { debug . error ( STRING ) ; return expression ; } String Buffer sb = new String Buffer ( NUM ) ; String Tokenizer st = new String Tokenizer ( expression , STRING ) ; while ( st . has More Tokens ( ) ) { String temp = ( String ) st . next Token ( ) ; String prefixed Str = STRING + idpp Prefix + STRING + temp ; sb . append ( prefixed Str ) ; } return sb . to String ( ) ; }
private long calc Next Time ( ) { long next Time = Long . MAX VALUE ; for ( int i = NUM ; i < groups . length ; i ++ ) { Watchdog Group group = groups [ i ] ; long g Time = group . time ; long g Wait Interval = group . wait Interval ; next Time = Math . min ( next Time , g Time + g Wait Interval ) ; } for ( int i = NUM ; i < groups . length ; i ++ ) { Watchdog Group group = groups [ i ] ; group . do Timeout = ( next Time == group . time + group . wait Interval ) ; } return next Time ; }
public static String to Bits ( final long x ) { final String Builder sb = new String Builder ( ) ; long t = x ; boolean first = BOOL ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( t < NUM ) { sb . append ( STRING ) ; first = BOOL ; } else if ( first ) { sb . append ( STRING ) ; } t = t << NUM ; } assert t == NUM ; return sb . to String ( ) ; }
public static Result from Content ( String content , String format ) throws Illegal Argument Exception { if ( content == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( format == null ) { throw new Illegal Argument Exception ( STRING ) ; } try { return from Content ( new Input Stream Reader ( new Byte Array Input Stream ( content . get Bytes ( STRING ) ) , STRING ) , format ) ; } catch ( IO Exception e ) { throw new Illegal Argument Exception ( e . get Message ( ) ) ; } }
public int wait For Condition ( Channel c , long timeout , int condition mask ) { long end time = NUM ; boolean end time set = BOOL ; synchronized ( c ) { while ( BOOL ) { int current cond = NUM ; int stdout Avail = c . stdout Writepos - c . stdout Readpos ; int stderr Avail = c . stderr Writepos - c . stderr Readpos ; if ( stdout Avail > NUM ) current cond = current cond | Channel Condition . STDOUT DATA ; if ( stderr Avail > NUM ) current cond = current cond | Channel Condition . STDERR DATA ; if ( c . EOF ) current cond = current cond | Channel Condition . EOF ; if ( c . get Exit Status ( ) != null ) current cond = current cond | Channel Condition . EXIT STATUS ; if ( c . get Exit Signal ( ) != null ) current cond = current cond | Channel Condition . EXIT SIGNAL ; if ( c . state == Channel . STATE CLOSED ) return current cond | Channel Condition . CLOSED | Channel Condition . EOF ; if ( ( current cond & condition mask ) != NUM ) return current cond ; if ( timeout > NUM ) { if ( ! end time set ) { end time = System . current Time Millis ( ) + timeout ; end time set = BOOL ; } else { timeout = end time - System . current Time Millis ( ) ; if ( timeout <= NUM ) return current cond | Channel Condition . TIMEOUT ; } } try { if ( timeout > NUM ) c . wait ( timeout ) ; else c . wait ( ) ; } catch ( Interrupted Exception e ) { } } } }
@ Override boolean should Import As Current Translation ( Long tm Text Unit Id ) { Translation Kit Exported Imported And Current TUV translation Kit Exported And Current TUV = translation Kit Exported And Current TU Vs . get ( tm Text Unit Id ) ; boolean is TK Reimport = Objects . equals ( translation Kit Exported And Current TUV . get Current Tm Text Unit Variant ( ) , translation Kit Exported And Current TUV . get Imported Tm Text Unit Variant ( ) ) ; boolean no External Translation Added = Objects . equals ( translation Kit Exported And Current TUV . get Current Tm Text Unit Variant ( ) , translation Kit Exported And Current TUV . get Exported Tm Text Unit Variant ( ) ) ; return is TK Reimport || no External Translation Added ; }
public Link Label ( String text ) { super ( text ) ; if ( Desktop . is Desktop Supported ( ) ) { set Cursor ( Cursor . get Predefined Cursor ( Cursor . HAND CURSOR ) ) ; enable Events ( Mouse Event . MOUSE EVENT MASK ) ; } }
public void add Event First ( Sim Event new Event ) { new Event . set Serial ( NUM ) ; sorted Set . add ( new Event ) ; }
public String to String Summary ( ) { String result ; String titles ; int resultset Length ; int i ; int j ; String content ; if ( m Non Sig Wins == null ) return STRING ; result = STRING ; titles = STRING ; resultset Length = NUM + Math . max ( ( int ) ( Math . log ( get Col Count ( ) ) / Math . log ( NUM ) ) , ( int ) ( Math . log ( get Row Count ( ) ) / Math . log ( NUM ) ) ) ; for ( i = NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; titles += STRING + get Summary Title ( i ) + STRING ; } result += titles + STRING ; for ( i = NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; result += STRING ; for ( j = NUM ; j < get Col Count ( ) ; j ++ ) { if ( get Col Hidden ( j ) ) continue ; if ( j == i ) content = Utils . pad Left ( STRING , resultset Length * NUM + NUM ) ; else content = Utils . pad Left ( STRING + m Non Sig Wins [ i ] [ j ] + STRING + m Wins [ i ] [ j ] + STRING , resultset Length * NUM + NUM ) ; result += STRING + content . replace All ( STRING , STRING ) + STRING ; } result += STRING + get Summary Title ( i ) + STRING + remove Filter Name ( m Col Names [ i ] ) + STRING ; } result += STRING ; return result ; }
private static File create Temp File ( String temp Subdirectory Name , String name ) throws IO Exception { String temp Dir Name = System . get Property ( STRING ) ; File temp Sub Directory = new File ( temp Dir Name + File . separator + temp Subdirectory Name ) ; if ( ! temp Sub Directory . exists ( ) ) { boolean created Directory = temp Sub Directory . mkdirs ( ) ; if ( ! created Directory ) { throw new IO Exception ( STRING + temp Sub Directory ) ; } } String temp File Name = temp Sub Directory + File . separator + name ; File temp File = new File ( temp File Name ) ; return temp File ; }
public void hrule ( double value , Paint color , String legend , Basic Stroke stroke ) { Legend Text legend Text = new Legend Text ( color , legend ) ; comments . add ( legend Text ) ; plot Elements . add ( new H Rule ( value , color , legend Text , stroke ) ) ; }
public State Interactive extent to whole connected sets ( ) { Set < Brd Item > new selected items = new Tree Set < Brd Item > ( ) ; for ( Brd Item curr item : items list ) { if ( curr item instanceof Brd Connectable ) { new selected items . add All ( curr item . get connected set ( - NUM ) ) ; } } if ( new selected items . is Empty ( ) ) return return state ; items list = new selected items ; actlog start scope ( Logfile Scope . EXTEND TO WHOLE CONNECTED SETS ) ; filter ( ) ; i brd . repaint ( ) ; return this ; }
public static List sort Items ( Collection collection , Locale locale ) { List sorted = Collections . EMPTY LIST ; if ( ( collection != null ) && ! collection . is Empty ( ) ) { sorted = new Array List ( collection ) ; Collator collator = Collator . get Instance ( locale ) ; Collections . sort ( sorted , collator ) ; } return sorted ; }
public Properties add Prefix ( Properties props ) { Properties result = new Properties ( ) ; for ( String name : props . string Property Names ( ) ) { String val = props . get Property ( name ) ; name = add Prefix ( name ) ; result . set Property ( name , val ) ; } return result ; }
public void test Replication Connection No Slaves Remain On Master ( ) throws Exception { Properties props = get Properties From Testsuite Url ( ) ; String master Host = props . get Property ( Non Registering Driver . HOST PROPERTY KEY ) + STRING + props . get Property ( Non Registering Driver . PORT PROPERTY KEY ) ; Replication Connection repl Conn = get Test Replication Connection No Slaves ( master Host ) ; Statement s = repl Conn . create Statement ( ) ; Result Set rs 1 = s . execute Query ( STRING ) ; assert True ( rs 1 . next ( ) ) ; int master Connection Id = rs 1 . get Int ( NUM ) ; rs 1 . close ( ) ; s . close ( ) ; repl Conn . add Slave Host ( master Host ) ; s = repl Conn . create Statement ( ) ; rs 1 = s . execute Query ( STRING ) ; assert True ( rs 1 . next ( ) ) ; assert Equals ( master Connection Id , rs 1 . get Int ( NUM ) ) ; assert False ( repl Conn . is Read Only ( ) ) ; rs 1 . close ( ) ; s . close ( ) ; }
@ Override public void add Relations ( Task task , Iterable < Object Id > project Ids , String field Name ) { List < Project > new Project List = new Linked List < > ( ) ; Iterable < Project > projects To Add = project Repository . find All ( project Ids , null ) ; projects To Add . for Each ( null ) ; try { if ( Property Utils . get Property ( task , field Name ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) Property Utils . get Property ( task , field Name ) ; projects . for Each ( null ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } try { Property Utils . set Property ( task , field Name , new Project List ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } task Repository . save ( task ) ; }
public static void run Update Port Associations Process ( Collection < Storage Port > ports , Collection < Storage Port > rem Ports , Db Client db Client , Coordinator Client coordinator , List < Storage Pool > pools ) { try { if ( null == pools ) { pools = new Array List < Storage Pool > ( ) ; } if ( null == ports ) { ports = new Array List < Storage Port > ( ) ; } if ( null != rem Ports ) { ports . add All ( rem Ports ) ; } Map < Network Lite , List < Storage Port > > ports By Network = group Ports By Network ( ports , db Client ) ; if ( ! ports By Network . is Empty ( ) ) { update Port Associations ( ports , ports By Network , db Client ) ; Set < URI > pool Uris = get Storage Pool Ids ( pools ) ; List < Storage Pool > modified Pools = Storage Pool Association Helper . get Storage Pools From Ports ( db Client , ports , rem Ports ) ; for ( Storage Pool pool : modified Pools ) { if ( ! pool Uris . contains ( pool . get Id ( ) ) ) { pools . add ( pool ) ; } } } String Buffer error Message = new String Buffer ( ) ; Implicit Pool Matcher . match Modified Storage Pools With All Virtual Pool ( pools , db Client , coordinator , error Message ) ; Hash Set < URI > systems To Process = Storage Pool Association Helper . get Storage Sytems From Ports ( ports , rem Ports ) ; Connectivity Util . update Rp Systems Connectivity ( systems To Process , db Client ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } }
public void sleep ( long millis ) { try { Thread . sleep ( millis ) ; } catch ( Interrupted Exception e ) { } }
static public void do Random Index Of Test ( final String label , final Abstract B Tree btree , final byte [ ] [ ] keys , final byte [ ] [ ] vals ) { final int nentries = keys . length ; if ( log . is Info Enabled ( ) ) log . info ( STRING + label + STRING + nentries ) ; final int [ ] order = get Random Order ( nentries ) ; final long begin = System . current Time Millis ( ) ; final boolean random Order = BOOL ; for ( int i = NUM ; i < nentries ; i ++ ) { final int entry Index = random Order ? order [ i ] : i ; final byte [ ] key = keys [ entry Index ] ; assert Equals ( STRING , entry Index , btree . index Of ( key ) ) ; final byte [ ] expected Val = vals [ entry Index ] ; assert Equals ( STRING , key , btree . key At ( entry Index ) ) ; assert Equals ( STRING , expected Val , btree . value At ( entry Index ) ) ; } if ( log . is Info Enabled ( ) ) { final long elapsed = System . current Time Millis ( ) - begin ; log . info ( label + STRING + nentries + STRING + elapsed + STRING ) ; } }
public double rhumb Distance ( Location location ) { if ( location == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } double lat 1 = Math . to Radians ( this . latitude ) ; double lon 1 = Math . to Radians ( this . longitude ) ; double lat 2 = Math . to Radians ( location . latitude ) ; double lon 2 = Math . to Radians ( location . longitude ) ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) { return NUM ; } double d Lat = lat 2 - lat 1 ; double d Lon = lon 2 - lon 1 ; double q ; if ( Math . abs ( d Lat ) < NEAR ZERO THRESHOLD ) { q = Math . cos ( lat 1 ) ; } else { double d Phi = Math . log ( Math . tan ( lat 2 / NUM + Math . PI / NUM ) / Math . tan ( lat 1 / NUM + Math . PI / NUM ) ) ; q = d Lat / d Phi ; } if ( Math . abs ( d Lon ) > Math . PI ) { d Lon = d Lon > NUM ? - ( NUM * Math . PI - d Lon ) : ( NUM * Math . PI + d Lon ) ; } double distance Radians = Math . sqrt ( d Lat * d Lat + q * q * d Lon * d Lon ) ; return Double . is Na N ( distance Radians ) ? NUM : distance Radians ; }
@ Override public void mouse Dragged ( Mouse Event e ) { if ( m mouse State == NUM ) { m old Mouse Pos . width = m new Mouse Pos . width ; m old Mouse Pos . height = m new Mouse Pos . height ; m new Mouse Pos . width = e . get X ( ) ; m new Mouse Pos . height = e . get Y ( ) ; m view Pos . width += m new Mouse Pos . width - m old Mouse Pos . width ; m view Pos . height += m new Mouse Pos . height - m old Mouse Pos . height ; } else if ( m mouse State == NUM ) { Graphics g = get Graphics ( ) ; if ( m Zoom Box Color == null ) { g . set Color ( Color . black ) ; } else { g . set Color ( m Zoom Box Color ) ; } if ( m Zoom Box XOR Color == null ) { g . set XOR Mode ( Color . white ) ; } else { g . set XOR Mode ( m Zoom Box XOR Color ) ; } g . draw Rect ( m old Mouse Pos . width , m old Mouse Pos . height , m new Mouse Pos . width - m old Mouse Pos . width , m new Mouse Pos . height - m old Mouse Pos . height ) ; m new Mouse Pos . width = e . get X ( ) ; m new Mouse Pos . height = e . get Y ( ) ; g . draw Rect ( m old Mouse Pos . width , m old Mouse Pos . height , m new Mouse Pos . width - m old Mouse Pos . width , m new Mouse Pos . height - m old Mouse Pos . height ) ; g . dispose ( ) ; } }
public static double create Double Setting ( final Map < String , String > raw Settings , final String setting Name , final double default Value ) { final String setting String = raw Settings . get ( setting Name ) ; if ( setting String == null ) { return default Value ; } else { try { return Double . parse Double ( setting String ) ; } catch ( final Number Format Exception exception ) { C Utility Functions . log Exception ( exception ) ; return default Value ; } } }
Can Message create Packet ( String s ) { Can Message m ; Cbus Address a = new Cbus Address ( s ) ; if ( a . check ( ) ) { m = a . make Message ( tc . get Canid ( ) ) ; } else { m = new Can Message ( tc . get Canid ( ) ) ; if ( s . char At ( NUM ) == STRING ) { m . set Extended ( BOOL ) ; int i = s . index Of ( STRING ) ; String h = s . substring ( NUM , i ) ; m . set Header ( Integer . parse Int ( h , NUM ) ) ; s = s . substring ( i + NUM , s . length ( ) ) ; } else if ( s . char At ( NUM ) == STRING ) { int i = s . index Of ( STRING ) ; String h = s . substring ( NUM , i ) ; m . set Header ( Integer . parse Int ( h , NUM ) ) ; s = s . substring ( i + NUM , s . length ( ) ) ; } byte b [ ] = String Util . bytes From Hex String ( s ) ; m . set Num Data Elements ( b . length ) ; for ( int i = NUM ; i < b . length ; i ++ ) { m . set Element ( i , b [ i ] & NUM ) ; } } return m ; }
public void remove Rtcp Listener ( Rtcp Event Listener listener ) { listeners . remove Element ( listener ) ; }
@ Override protected void ensure Number Of Columns ( int number Of Columns ) { if ( data . length >= number Of Columns ) { return ; } int [ ] new Data = new int [ number Of Columns ] ; System . arraycopy ( data , NUM , new Data , NUM , data . length ) ; data = new Data ; }
public String report Error ( XML Locator location , String domain , String key , Object [ ] arguments , short severity , Exception exception ) throws XNI Exception { Message Formatter message Formatter = get Message Formatter ( domain ) ; String message ; if ( message Formatter != null ) { message = message Formatter . format Message ( f Locale , key , arguments ) ; } else { String Buffer str = new String Buffer ( ) ; str . append ( domain ) ; str . append ( STRING ) ; str . append ( key ) ; int arg Count = arguments != null ? arguments . length : NUM ; if ( arg Count > NUM ) { str . append ( STRING ) ; for ( int i = NUM ; i < arg Count ; i ++ ) { str . append ( arguments [ i ] ) ; if ( i < arg Count - NUM ) { str . append ( STRING ) ; } } } message = str . to String ( ) ; } XML Parse Exception parse Exception = ( exception != null ) ? new XML Parse Exception ( location , message , exception ) : new XML Parse Exception ( location , message ) ; XML Error Handler error Handler = f Error Handler ; if ( error Handler == null ) { if ( f Default Error Handler == null ) { f Default Error Handler = new Default Error Handler ( ) ; } error Handler = f Default Error Handler ; } switch ( severity ) { case SEVERITY WARNING : { error Handler . warning ( domain , key , parse Exception ) ; break ; } case SEVERITY ERROR : { error Handler . error ( domain , key , parse Exception ) ; break ; } case SEVERITY FATAL ERROR : { error Handler . fatal Error ( domain , key , parse Exception ) ; if ( ! f Continue After Fatal Error ) { throw parse Exception ; } break ; } } return message ; }
public void add Debugger ( final I Debugger debugger ) { debuggers . add ( Preconditions . check Not Null ( debugger , STRING ) ) ; for ( final Debugger Provider Listener listener : m listeners ) { try { listener . debugger Added ( this , debugger ) ; } catch ( final Exception exception ) { C Utility Functions . log Exception ( exception ) ; } } }
public boolean parse Geo JSON ( File file ) { m Local File = file ; try { File Input Stream input = new File Input Stream ( m Local File ) ; Json Parser parser = new Json Parser ( ) ; Json Element json = parser . parse ( new Input Stream Reader ( input ) ) ; input . close ( ) ; return parse Geo JSON ( json . get As Json Object ( ) ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } }
public static Grid Java Process exec ( Class cls , String params , @ Nullable Ignite Logger log , @ Nullable Ignite In Closure < String > print C , @ Nullable Grid Abs Closure proc Killed C , @ Nullable Collection < String > jvm Args , @ Nullable String cp ) throws Exception { return exec ( cls . get Canonical Name ( ) , params , log , print C , proc Killed C , null , jvm Args , cp ) ; }
public static Resource parse Resource ( String n Triples Resource , Value Factory value Factory ) throws Illegal Argument Exception { if ( n Triples Resource . starts With ( STRING ) ) { return parse URI ( n Triples Resource , value Factory ) ; } else if ( n Triples Resource . starts With ( STRING ) ) { return parse B Node ( n Triples Resource , value Factory ) ; } else { throw new Illegal Argument Exception ( STRING + n Triples Resource ) ; } }
public void reset Extreme Gravity PS Rs ( ) { extreme Gravity Rolls . remove All Elements ( ) ; }
public static void sort ( byte [ ] array , int start , int end ) { Dual Pivot Quicksort . sort ( array , start , end ) ; }
synchronized void remove ( Notification Manager manager , int id ) { for ( int i = NUM ; i < cache . size ( ) ; i ++ ) { if ( cache . get ( i ) == id ) { cache . remove ( i ) ; break ; } } manager . cancel ( id ) ; }
private void stretch View Horizontally ( View view , int cross Size ) { Layout Params lp = ( Layout Params ) view . get Layout Params ( ) ; int new Width = cross Size - lp . left Margin - lp . right Margin ; new Width = Math . max ( new Width , NUM ) ; view . measure ( Measure Spec . make Measure Spec ( new Width , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( view . get Measured Height ( ) , Measure Spec . EXACTLY ) ) ; }
private void process I Pv 6 ( final String rule ) { final String [ ] s = rule . split ( STRING , - NUM ) ; final String address = s [ NUM ] ; final String ipv 6 Literal ; if ( address . char At ( NUM ) == STRING && address . char At ( address . length ( ) - NUM ) == STRING ) { ipv 6 Literal = address . substring ( NUM , address . length ( ) - NUM ) ; } else { ipv 6 Literal = address ; } boolean is Valid ; try { final Class < ? > ip Utils = Class . for Name ( STRING ) ; final Method method = ip Utils . get Method ( STRING , String . class ) ; is Valid = ( Boolean ) method . invoke ( null , ipv 6 Literal ) ; } catch ( Exception e ) { is Valid = BOOL ; } if ( ! is Valid ) { throw generic Decode Error ( ) ; } final Inet Address addr ; try { addr = Inet Address . get By Name ( address ) ; } catch ( final Unknown Host Exception ex ) { throw generic Decode Error ( ) ; } if ( addr instanceof Inet 6 Address ) { this . rule Type = Rule Type . I Pv 6 ; final Inet 6 Address addr 6 = ( Inet 6 Address ) addr ; this . rule Mask = addr 6 . get Address ( ) ; this . prefix Mask = new byte [ IN 6 ADDRSZ ] ; prefix Mask ( process Prefix ( s , IPV 6 MAXPREFIX ) ) ; } else { if ( s . length == NUM ) { throw generic Decode Error ( ) ; } this . rule Mask = addr . get Address ( ) ; this . rule Type = Rule Type . I Pv 4 ; this . prefix Mask = new byte [ IN 4 ADDRSZ ] ; prefix Mask ( process Prefix ( s , IPV 4 MAXPREFIX ) ) ; } }
public void write Double ( double value ) throws IO Exception { check Write Primitive Types ( ) ; primitive Types . write Double ( value ) ; }
public static void move End ( J Scroll Pane pane ) { J Scroll Bar bar = pane . get Vertical Scroll Bar ( ) ; bar . set Value ( bar . get Maximum ( ) ) ; }
private boolean is Null Setting ( boolean make Dest , Mapping Type mtd , Mapping Type mts , String Builder result ) { if ( make Dest && ( mtd == ALL FIELDS || mtd == ONLY VALUED FIELDS ) && mts == ONLY NULL FIELDS ) { result . append ( STRING + string Of Set Destination + STRING + new Line ) ; return BOOL ; } return BOOL ; }
protected Date compute ( double value , String locale String ) { if ( Double . is Na N ( value ) || locale String == null ) { return null ; } Locale locale = new Locale ( locale String ) ; long date Long = ( long ) value ; Date date = new Date ( date Long ) ; Calendar cal = Calendar . get Instance ( locale ) ; cal . set Time ( date ) ; return cal . get Time ( ) ; }
public void connect Pan ( Bluetooth Adapter adapter , Bluetooth Device device ) { connect Pan Or Incoming Pan Connection ( adapter , device , BOOL ) ; }
private Cuboid ( String world Name , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . world Name = world Name ; this . x1 = Math . min ( x1 , x2 ) ; this . x2 = Math . max ( x1 , x2 ) ; this . y1 = Math . min ( y1 , y2 ) ; this . y2 = Math . max ( y1 , y2 ) ; this . z1 = Math . min ( z1 , z2 ) ; this . z2 = Math . max ( z1 , z2 ) ; }
private Workflow . Method create Meta Volumes Method ( URI system URI , URI pool URI , List < URI > volume UR Is , Virtual Pool Capability Values Wrapper capabilities ) { return new Workflow . Method ( STRING , system URI , pool URI , volume UR Is , capabilities ) ; }
public static Command of ( Aggregate Id aggregate Id , Stream Timestamp command Timestamp , Versioned Name command Name , Tuple parameters , Type result Type ) { check Not Null ( aggregate Id , STRING ) ; check Not Null ( command Timestamp , STRING ) ; check Not Null ( command Name , STRING ) ; check Not Null ( parameters , STRING ) ; check Not Null ( result Type , STRING ) ; return new Command ( aggregate Id , command Timestamp , Optional . empty ( ) , command Name , parameters , result Type ) ; }
public void next Page ( Gui Manual Herblore manual ) { if ( current Page + NUM <= visible Pages . size ( ) ) { set Page ( current Page + NUM , manual ) ; } }
public final double sample Active Count Max ( ) { return active Count Max . get And Set ( active Count . get ( ) ) ; }
public void handle ( Throwable throwable , Context context , Request request , Response response ) { if ( throwable . get Cause ( ) instanceof O Auth 2 Restlet Exception ) { final O Auth 2 Restlet Exception e = ( O Auth 2 Restlet Exception ) throwable . get Cause ( ) ; handle ( e , context , request , response ) ; } else { final Server Exception server Exception = new Server Exception ( throwable ) ; final O Auth 2 Restlet Exception exception = new O Auth 2 Restlet Exception ( server Exception . get Status Code ( ) , server Exception . get Error ( ) , server Exception . get Message ( ) , null ) ; handle ( exception , context , request , response ) ; } }
public void test Missing Mission Name Handling ( ) { String xml = STRING ; xml += STRING + STRING ; xml += create End Mission Xml ( ) ; Input Stream mission Input Stream = new Byte Array Input Stream ( xml . get Bytes ( ) ) ; boolean did Mission Name Parse Fail = BOOL ; try { Mission Parser . get Mission Name ( mission Input Stream ) ; } catch ( Mission Parse Exception e ) { did Mission Name Parse Fail = BOOL ; } Assert . assert Equals ( BOOL , did Mission Name Parse Fail ) ; }
public static double abs ( Z z ) { double are , aim , rho ; are = Math . abs ( z . re ) ; aim = Math . abs ( z . im ) ; if ( are + aim == NUM ) return NUM ; if ( are >= aim ) { rho = aim / are ; return are * Math . sqrt ( NUM + rho * rho ) ; } else { rho = are / aim ; return aim * Math . sqrt ( NUM + rho * rho ) ; } }
public void start Element ( String namespace URI , String local Name , String name , Attributes atts ) throws org . xml . sax . SAX Exception { if ( m in Entity Ref ) return ; if ( m need To Call Start Document ) { start Document Internal ( ) ; m need To Call Start Document = BOOL ; m doc Is Empty = BOOL ; } else if ( m cdata Tag Open ) close CDATA ( ) ; try { if ( m need To Output Doc Type Decl ) { if ( null != get Doctype System ( ) ) { output Doc Type Decl ( name , BOOL ) ; } m need To Output Doc Type Decl = BOOL ; } if ( m elem Context . m start Tag Open ) { close Start Tag ( ) ; m elem Context . m start Tag Open = BOOL ; } if ( namespace URI != null ) ensure Prefix Is Declared ( namespace URI , name ) ; m ispreserve = BOOL ; if ( should Indent ( ) && m start New Line ) { indent ( ) ; } m start New Line = BOOL ; final java . io . Writer writer = m writer ; writer . write ( STRING ) ; writer . write ( name ) ; } catch ( IO Exception e ) { throw new SAX Exception ( e ) ; } if ( atts != null ) add Attributes ( atts ) ; m elem Context = m elem Context . push ( namespace URI , local Name , name ) ; m isprevtext = BOOL ; if ( m tracer != null ) fire Pseudo Attributes ( ) ; }
public static String relative File ( Iterable < ? extends File > paths , String file ) { File path = select Path ( paths , file ) ; File rel File = relative File ( path , new File ( file ) ) ; return rel File . get Path ( ) ; }
@ Override public Equipment Configuration Update update Config ( final Sub Equipment sub Equipment , final Properties properties ) throws Illegal Access Exception { if ( ( properties . get Property ( STRING ) ) != null ) { throw new Configuration Exception ( Configuration Exception . INVALID PARAMETER VALUE , STRING + STRING ) ; } if ( ( properties . get Property ( STRING ) ) != null ) { throw new Configuration Exception ( Configuration Exception . INVALID PARAMETER VALUE , STRING + STRING ) ; } super . update Config ( sub Equipment , properties ) ; return new Equipment Configuration Update ( ) ; }
protected void add Message Processor ( Message Processor new Message Processor ) throws IO Exception { synchronized ( message Processors ) { message Processors . add ( new Message Processor ) ; } }
public boolean is Revoked ( Certificate cert ) { if ( revoked Map . is Empty ( ) || ( ! ( cert instanceof X509 Certificate ) ) ) { return BOOL ; } X509 Certificate xcert = ( X509 Certificate ) cert ; X509 Issuer Serial issuer Serial = new X509 Issuer Serial ( xcert ) ; return revoked Map . contains Key ( issuer Serial ) ; }
private void add To Set ( Object Xml Persist persist , I File file , String set Name ) throws IO Exception , Core Exception { Collection < Relation Set Descriptor > update Set = load Relation Sets ( persist , file ) ; persist Updated Bundle ( persist , file , update Set , set Name ) ; }
public void put Len Bytes ( byte [ ] bytes ) { ensure Capacity ( NUM + bytes . length ) ; put Field Length ( bytes . length ) ; System . arraycopy ( bytes , NUM , this . byte Buffer , this . position , bytes . length ) ; this . position += bytes . length ; }
private static String list ( String [ ] arr , int from , int len ) { String Buffer sb = new String Buffer ( ) ; for ( int i = from ; i < len ; i ++ ) { sb . append ( arr [ i ] ) ; if ( i + NUM != arr . length ) sb . append ( STRING ) ; } return sb . to String ( ) ; }
public static void fill Rectange ( Graphics 2 D g2 D , J Component c , boolean round ) { Compiere Color cc = null ; boolean std CC = c . get Client Property ( Compiere Look And Feel . BACKGROUND FILL ) != null ; try { cc = ( Compiere Color ) c . get Client Property ( Compiere Look And Feel . BACKGROUND ) ; } catch ( Exception e ) { std CC = BOOL ; } if ( std CC ) cc = Compiere Color . get Default Background ( ) ; if ( cc != null ) { cc . paint ( g2 D , c ) ; } else { Paint paint = c . get Background ( ) ; g2 D . set Paint ( paint ) ; Rectangular Shape rec = null ; if ( round ) rec = new Round Rectangle 2 D . Float ( NUM , NUM , c . get Width ( ) , c . get Height ( ) , NUM , NUM ) ; else rec = new Rectangle ( NUM , NUM , c . get Width ( ) , c . get Height ( ) ) ; g2 D . fill ( rec ) ; } }
public static int create Proxy Object ( int lua State , String implem ) throws Lua Exception { Lua State L = Lua State Factory . get Existing State ( lua State ) ; synchronized ( L ) { try { if ( ! ( L . is Table ( NUM ) ) ) throw new Lua Exception ( STRING ) ; Lua Object lua Obj = L . get Lua Object ( NUM ) ; Object proxy = lua Obj . create Proxy ( implem ) ; L . push Java Object ( proxy ) ; } catch ( Exception e ) { throw new Lua Exception ( e ) ; } return NUM ; } }
private static final int check Max Lg Arr Longs ( Memory dst Mem ) { int pre Bytes = CONST PREAMBLE LONGS << NUM ; long cap = dst Mem . get Capacity ( ) ; int max Lg Arr Longs = Integer . number Of Trailing Zeros ( floor Power Of 2 ( ( int ) ( cap - pre Bytes ) ) > > > NUM ) ; if ( max Lg Arr Longs < MIN LG ARR LONGS ) { throw new Sketches Argument Exception ( STRING + cap ) ; } return max Lg Arr Longs ; }
public static boolean is Input Stream GZIP Compressed ( final Pushback Input Stream input Stream ) throws IO Exception { if ( input Stream == null ) return BOOL ; byte [ ] signature = new byte [ NUM ] ; int count = NUM ; try { while ( count < NUM ) { int read Count = input Stream . read ( signature , count , NUM - count ) ; if ( read Count < NUM ) return BOOL ; count = count + read Count ; } } finally { input Stream . unread ( signature , NUM , count ) ; } int stream Header = ( ( int ) signature [ NUM ] & NUM ) | ( ( signature [ NUM ] << NUM ) & NUM ) ; return GZIP Input Stream . GZIP MAGIC == stream Header ; }
public void shutdown ( ) { final long begin = System . current Time Millis ( ) ; log . info ( STRING ) ; log . info ( STRING + get Task Count ( scheduled Pool ) + STRING ) ; log . info ( STRING + get Task Count ( instant Pool ) + STRING ) ; log . info ( STRING + get Task Count ( long Running Pool ) + STRING ) ; scheduled Pool . shutdown ( ) ; instant Pool . shutdown ( ) ; long Running Pool . shutdown ( ) ; boolean success = BOOL ; try { success = await Termination ( NUM ) ; scheduled Pool . set Execute Existing Delayed Tasks After Shutdown Policy ( BOOL ) ; scheduled Pool . set Continue Existing Periodic Tasks After Shutdown Policy ( BOOL ) ; success |= await Termination ( NUM ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING + success + STRING + ( System . current Time Millis ( ) - begin ) + STRING ) ; log . info ( STRING + get Task Count ( scheduled Pool ) + STRING ) ; log . info ( STRING + get Task Count ( instant Pool ) + STRING ) ; log . info ( STRING + get Task Count ( long Running Pool ) + STRING ) ; }
public static synchronized Collection < String > all Local Ips ( ) { List < String > ips = new Array List < > ( NUM ) ; try { Enumeration < Network Interface > itfs = Network Interface . get Network Interfaces ( ) ; if ( itfs != null ) { for ( Network Interface itf : as Iterable ( itfs ) ) { if ( ! itf . is Loopback ( ) ) { Enumeration < Inet Address > addrs = itf . get Inet Addresses ( ) ; for ( Inet Address addr : as Iterable ( addrs ) ) { String host Addr = addr . get Host Address ( ) ; if ( ! addr . is Loopback Address ( ) && ! ips . contains ( host Addr ) ) ips . add ( host Addr ) ; } } } } } catch ( Socket Exception ignore ) { return Collections . empty List ( ) ; } Collections . sort ( ips ) ; return ips ; }
public static String file Name Clean ( String s ) { char [ ] chars = s . to Char Array ( ) ; String Buffer sb = new String Buffer ( ) ; for ( int i = NUM ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c == STRING ) ) { sb . append ( c ) ; } else { if ( c == STRING || c == STRING ) { sb . append ( STRING ) ; } else { sb . append ( STRING + ( int ) c + STRING ) ; } } } return sb . to String ( ) ; }
public synchronized Perf Rate clone And Reset ( ) { Perf Rate rc = new Perf Rate ( ) ; rc . total Count = total Count ; rc . count = count ; rc . start Time = start Time ; count = NUM ; start Time = System . current Time Millis ( ) ; return rc ; }
protected String translate To HTML ( final String text ) { final String Builder sbuf = new String Builder ( ) ; final String Character Iterator ci = new String Character Iterator ( text ) ; char ch = ci . current ( ) ; while ( ch != Character Iterator . DONE ) { if ( ch == STRING ) { ch = ci . next ( ) ; if ( ch == STRING ) { append HTML ( sbuf , ch ) ; ch = ci . next ( ) ; } else { final String link = extract Link ( ci ) ; if ( link != null ) { build Link ( sbuf , link ) ; } ch = ci . current ( ) ; } } else { append HTML ( sbuf , ch ) ; ch = ci . next ( ) ; } } return sbuf . to String ( ) ; }
private Collection < Var > migrate Columns ( SQL Table table , Result Set row , Var instance ) throws SQL Exception { String table Type = table . get Entity Type ( ) ; Map < String , Resource Type . Data Type > columns = table . get Columns ( ) ; Map < String , String > foreign = table . get Foreign Key Columns ( ) ; Result Set Meta Data metadata = row . get Meta Data ( ) ; List < Var > vars = new Array List < > ( ) ; for ( int i = NUM ; i <= metadata . get Column Count ( ) ; i ++ ) { String column Name = metadata . get Column Name ( i ) ; Object column Value = row . get Object ( column Name ) ; Resource Type . Data Type data Type = columns . get ( column Name ) ; String foreign Key = foreign . get ( column Name ) ; if ( foreign Key != null ) { vars . add All ( migrate Column Value As Relation ( instance , column Name , foreign Key , column Value ) ) ; } else { vars . add All ( migrate Column Value As Resource ( instance , column Name , cast ( data Type , column Name , row ) , table Type ) ) ; } } return vars ; }
private int cross Check Get Columns And Result Set Meta Data ( Result Set rs , boolean partial ) throws SQL Exception { Statement s = conn . create Statement ( ) ; while ( rs . next ( ) ) { String schema = rs . get String ( STRING ) ; String table = rs . get String ( STRING ) ; Result Set rst = s . execute Query ( STRING + schema + STRING + table ) ; Result Set Meta Data rsmdt = rst . get Meta Data ( ) ; for ( int col = NUM ; col <= rsmdt . get Column Count ( ) ; col ++ ) { if ( ! partial ) { if ( col != NUM ) assert True ( rs . next ( ) ) ; assert Equals ( STRING , col , rs . get Int ( STRING ) ) ; } assert Equals ( STRING , STRING , rs . get String ( STRING ) ) ; assert Equals ( STRING , schema , rs . get String ( STRING ) ) ; assert Equals ( STRING , table , rs . get String ( STRING ) ) ; cross Check Get Column Row And Result Set Meta Data ( rs , rsmdt ) ; if ( partial ) break ; } rst . close ( ) ; } int count = rs . get Row ( ) ; rs . close ( ) ; s . close ( ) ; return count ; }
@ Override public synchronized void remove Attribute ( int index ) { Attribute a = attributes . get ( index ) ; if ( a == null ) { return ; } attributes . set ( index , null ) ; unused Column List . add ( index ) ; }
default B with ( String key , double value ) { return with ( key , Double . to String ( value ) ) ; }
public void sort ( Array List < Value [ ] > rows , int offset , int limit ) { int rows Size = rows . size ( ) ; if ( rows . is Empty ( ) || offset >= rows Size || limit == NUM ) { return ; } if ( offset < NUM ) { offset = NUM ; } if ( offset + limit > rows Size ) { limit = rows Size - offset ; } if ( limit == NUM && offset == NUM ) { rows . set ( NUM , Collections . min ( rows , this ) ) ; return ; } Value [ ] [ ] arr = rows . to Array ( new Value [ rows Size ] [ ] ) ; Utils . sort Top N ( arr , offset , limit , this ) ; for ( int i = NUM , end = Math . min ( offset + limit , rows Size ) ; i < end ; i ++ ) { rows . set ( i , arr [ i ] ) ; } }
protected void re Init ( ) { if ( is Logging Enabled ( ) ) stack Logger . log Debug ( STRING ) ; message Processors = new Array List < Message Processor > ( ) ; this . io Handler = new IO Handler ( this ) ; pending Transactions = new Concurrent Hash Map < String , SIP Server Transaction > ( ) ; client Transaction Table = new Concurrent Hash Map < String , SIP Client Transaction > ( ) ; server Transaction Table = new Concurrent Hash Map < String , SIP Server Transaction > ( ) ; retransmission Alert Transactions = new Concurrent Hash Map < String , SIP Server Transaction > ( ) ; merge Table = new Concurrent Hash Map < String , SIP Server Transaction > ( ) ; this . dialog Table = new Concurrent Hash Map < String , SIP Dialog > ( ) ; this . early Dialog Table = new Concurrent Hash Map < String , SIP Dialog > ( ) ; this . terminated Server Transactions Pending Ack = new Concurrent Hash Map < String , SIP Server Transaction > ( ) ; this . forked Client Transaction Table = new Concurrent Hash Map < String , SIP Client Transaction > ( ) ; this . timer = new Timer ( ) ; this . active Client Transaction Count = new Atomic Integer ( NUM ) ; }
public static int read Fully ( Input Stream in Str , byte [ ] buf , int off , int len ) throws IO Exception { int total Read = NUM ; while ( total Read < len ) { int num Read = in Str . read ( buf , off + total Read , len - total Read ) ; if ( num Read < NUM ) { break ; } total Read += num Read ; } return total Read ; }
public static void assume False ( Boolean Supplier assumption Supplier , Supplier < String > message Supplier ) throws Test Aborted Exception { if ( assumption Supplier . get As Boolean ( ) ) { throw Test Aborted Exception ( message Supplier . get ( ) ) ; } }
public static String add To Cart Bulk Requirements ( Http Servlet Request request , Http Servlet Response response ) { Shopping Cart cart = get Cart Object ( request ) ; Delegator delegator = ( Delegator ) request . get Attribute ( STRING ) ; Local Dispatcher dispatcher = ( Local Dispatcher ) request . get Attribute ( STRING ) ; Shopping Cart Helper cart Helper = new Shopping Cart Helper ( delegator , dispatcher , cart ) ; String control Directive ; Map < String , Object > result ; Map < String , Object > param Map = Util Http . get Parameter Map ( request ) ; String catalog Id = Catalog Worker . get Current Catalog Id ( request ) ; result = cart Helper . add To Cart Bulk Requirements ( catalog Id , param Map ) ; control Directive = process Result ( result , request ) ; if ( control Directive . equals ( ERROR ) ) { return STRING ; } else { return STRING ; } }
public Object 2 Double Open Hash Map < int [ ] > support Map ( int support Threshold ) { List < Item Set > item Sets = learn ( ) ; Object 2 Double Open Hash Map < int [ ] > support Map = new Object 2 Double Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { if ( item Set . support >= support Threshold ) { support Map . put ( item Set . items , item Set . support ) ; } } return support Map ; }
private void update Peek Buffer ( int bytes Consumed ) { peek Buffer Length -= bytes Consumed ; peek Buffer Position = NUM ; System . arraycopy ( peek Buffer , bytes Consumed , peek Buffer , NUM , peek Buffer Length ) ; }
protected Workflow . Method create Add Volumes To CG Method ( URI vplex URI , URI cg URI , List < URI > vplex Volume UR Is ) { return new Workflow . Method ( ADD VOLUMES TO CG METHOD NAME , vplex URI , cg URI , vplex Volume UR Is ) ; }
private int show Has Changed Dialog ( ) { Object [ ] options = { STRING , STRING , STRING } ; return J Option Pane . show Option Dialog ( frame , STRING + STRING , STRING , J Option Pane . YES NO OPTION , J Option Pane . WARNING MESSAGE , null , options , options [ NUM ] ) ; }
public void clear Row ( int node Index , int row Index ) { for ( int col Index = NUM ; col Index < get Num Columns ( node Index ) ; col Index ++ ) { set Probability ( node Index , row Index , col Index , Double . Na N ) ; } }
public static String replace ( String in String , String old Pattern , String new Pattern ) { if ( in String == null ) { return null ; } if ( old Pattern == null || new Pattern == null ) { return in String ; } String Builder sbuf = new String Builder ( ) ; int pos = NUM ; int index = in String . index Of ( old Pattern ) ; int pat Len = old Pattern . length ( ) ; while ( index >= NUM ) { sbuf . append ( in String . substring ( pos , index ) ) ; sbuf . append ( new Pattern ) ; pos = index + pat Len ; index = in String . index Of ( old Pattern , pos ) ; } sbuf . append ( in String . substring ( pos ) ) ; return sbuf . to String ( ) ; }
public String generate Call Identifier ( String address ) { long random = rand . next Long ( ) ; int hash = ( int ) Math . abs ( random % digester Pools Size ) ; Message Digest md = digester Pool [ hash ] ; synchronized ( md ) { String date = Long . to String ( System . nano Time ( ) + System . current Time Millis ( ) + call ID Counter ++ + random ) ; byte cid [ ] = md . digest ( date . get Bytes ( ) ) ; String cid String = Utils . to Hex String ( cid ) ; return cid String + STRING + address ; } }
protected void load History ( ) { int size ; int i ; String cmd ; size = Integer . parse Int ( PROPERTIES . get Property ( STRING , STRING ) ) ; m Command History . clear ( ) ; for ( i = NUM ; i < size ; i ++ ) { cmd = PROPERTIES . get Property ( STRING + i , STRING ) ; if ( cmd . length ( ) != NUM ) { m Command History . add ( cmd ) ; } else { break ; } } m History Pos = m Command History . size ( ) ; }
public Reference Binding find Super Type Originating From ( int well Known Original ID , boolean original Is Class ) { if ( ! ( this instanceof Reference Binding ) ) return null ; Reference Binding reference = ( Reference Binding ) this ; if ( reference . id == well Known Original ID || ( original ( ) . id == well Known Original ID ) ) return reference ; Reference Binding current Type = reference ; if ( original Is Class ) { while ( ( current Type = current Type . superclass ( ) ) != null ) { if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ; } return null ; } Reference Binding [ ] interfaces To Visit = null ; int next Position = NUM ; do { Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces != Binding . NO SUPERINTERFACES ) { if ( interfaces To Visit == null ) { interfaces To Visit = its Interfaces ; next Position = interfaces To Visit . length ; } else { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length ) System . arraycopy ( interfaces To Visit , NUM , interfaces To Visit = new Reference Binding [ next Position + its Length + NUM ] , NUM , next Position ) ; next Interface : for ( int a = NUM ; a < its Length ; a ++ ) { Reference Binding next = its Interfaces [ a ] ; for ( int b = NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } } while ( ( current Type = current Type . superclass ( ) ) != null ) ; for ( int i = NUM ; i < next Position ; i ++ ) { current Type = interfaces To Visit [ i ] ; if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ; Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces != Binding . NO SUPERINTERFACES ) { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length ) System . arraycopy ( interfaces To Visit , NUM , interfaces To Visit = new Reference Binding [ next Position + its Length + NUM ] , NUM , next Position ) ; next Interface : for ( int a = NUM ; a < its Length ; a ++ ) { Reference Binding next = its Interfaces [ a ] ; for ( int b = NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } return null ; }
@ Override protected void on Draw ( Canvas canvas ) { super . on Draw ( canvas ) ; if ( m Shader == null ) return ; float radius = m Center X <= m Center Y ? m Center X - NUM : m Center Y - NUM ; canvas . rotate ( m Rotate Degrees , m Center X , m Center Y ) ; canvas . draw Circle ( m Center X , m Center Y , radius , m Paint Cover ) ; canvas . rotate ( - m Rotate Degrees , m Center X , m Center Y ) ; canvas . draw Circle ( m Center X , m Center Y , m Button Radius , m Paint Button ) ; canvas . draw Bitmap ( is Rotating ( ) ? m Bitmap Pause : m Bitmap Play , m Center X - m Bitmap Pause . get Width ( ) / NUM , m Center Y - m Bitmap Pause . get Height ( ) / NUM , m Paint Play Pause ) ; if ( m Progress Visibility ) { canvas . draw Arc ( rect F , NUM , NUM , BOOL , m Paint Progress Empty ) ; canvas . draw Arc ( rect F , NUM , calculate Past Progress Degree ( ) , BOOL , m Paint Progress Loaded ) ; String left Time = seconds To Time ( calculate Left Seconds ( ) ) ; m Paint Time . get Text Bounds ( left Time , NUM , left Time . length ( ) , m Rect Text ) ; canvas . draw Text ( left Time , ( float ) ( m Center X * Math . cos ( Math . to Radians ( NUM ) ) ) + m Width / NUM - m Rect Text . width ( ) / NUM , ( float ) ( m Center X * Math . sin ( Math . to Radians ( NUM ) ) ) + m Height / NUM + m Rect Text . height ( ) + NUM , m Paint Time ) ; String passed Time = seconds To Time ( calculate Passed Seconds ( ) ) ; m Paint Time . get Text Bounds ( passed Time , NUM , passed Time . length ( ) , m Rect Text ) ; canvas . draw Text ( passed Time , ( float ) ( m Center X * - Math . cos ( Math . to Radians ( NUM ) ) ) + m Width / NUM - m Rect Text . width ( ) / NUM , ( float ) ( m Center X * Math . sin ( Math . to Radians ( NUM ) ) ) + m Height / NUM + m Rect Text . height ( ) + NUM , m Paint Time ) ; } }
public Connection Acceptor ( TCP Transport transport ) { this . transport = transport ; }
public void request Seconds Until Password Reset Lockout ( ) { operations . add ( Password Policy State Operation Type . GET SECONDS UNTIL PASSWORD RESET LOCKOUT ) ; }
private < T extends Client Request Result > Collection < T > execute Name Request ( final Collection < String > regex List , final Class < T > clazz , final Client Request Report Listener report Listener , final String request Queue ) { LOGGER . debug ( STRING ) ; Client Request Impl < T > client Request = new Client Request Impl < T > ( clazz ) ; Iterator < String > it = regex List . iterator ( ) ; Collection < Future < Collection < T > > > results = new Array List < Future < Collection < T > > > ( ) ; int counter = NUM ; while ( it . has Next ( ) ) { while ( it . has Next ( ) && counter < max Request Size ) { client Request . add Regex ( it . next ( ) ) ; counter ++ ; } Request Values Task < T > task = new Request Values Task < T > ( client Request , report Listener , request Queue ) ; results . add ( executor . submit ( task ) ) ; client Request = new Client Request Impl < T > ( clazz ) ; counter = NUM ; } Collection < T > final Collection = new Array List < T > ( ) ; for ( Future < Collection < T > > result : results ) { try { final Collection . add All ( result . get ( ) ) ; } catch ( Interrupted Exception e ) { LOGGER . error ( STRING , e ) ; throw new Runtime Exception ( e ) ; } catch ( Execution Exception e ) { LOGGER . error ( STRING , e ) ; throw new Runtime Exception ( e ) ; } } LOGGER . debug ( STRING ) ; return final Collection ; }
public void test Neg Pos ( ) { byte a Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM } ; int a Sign = - NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private boolean backtrack For Monotone With Previous ( Featurizable < I String , String > f ) { int index Left Current Phrase = f Start ( f ) - NUM ; if ( index Left Current Phrase < NUM ) { return ( f . prior == null ) ; } else if ( f . prior == null ) { return BOOL ; } if ( f Start ( f ) < f Start ( f . prior ) ) return BOOL ; int index Right Previous Phrase = f End ( f . prior ) + NUM ; if ( index Right Previous Phrase - NUM == index Left Current Phrase ) return BOOL ; Coverage Set f Coverage = f . derivation . source Coverage ; for ( int i = index Right Previous Phrase ; i <= index Left Current Phrase ; ++ i ) { if ( ! f Coverage . get ( i ) ) return BOOL ; } if ( f Coverage . next Clear Bit ( NUM ) > index Left Current Phrase && f Coverage . next Set Bit ( f End ( f ) + NUM ) < NUM ) return BOOL ; Featurizable < I String , String > tmp f = f . prior ; tmp Coverage . clear ( ) ; boolean found Adj Phrase = BOOL ; while ( BOOL ) { if ( f End ( tmp f ) == index Left Current Phrase ) found Adj Phrase = BOOL ; int f Start = f Start ( tmp f ) ; int f End = f End ( tmp f ) ; tmp Coverage . set ( f Start , f End + NUM ) ; if ( found Adj Phrase && contiguous ( tmp Coverage ) ) break ; if ( f Start > index Left Current Phrase ) return BOOL ; tmp f = tmp f . prior ; if ( tmp f == null ) return BOOL ; } return BOOL ; }
void add Field Value ( Map < Temporal Field , Long > field Values , Chrono Field field , long value ) { Long old = field Values . get ( field ) ; if ( old != null && old . long Value ( ) != value ) { throw new Date Time Exception ( STRING + field + STRING + old + STRING + field + STRING + value ) ; } field Values . put ( field , value ) ; }
public Writer write To ( Writer out Arg ) throws IO Exception { Buffered Writer out = new Buffered Writer ( out Arg ) ; try { write Config ( STRING , this , out , NUM , BOOL ) ; } finally { out . flush ( ) ; } return out Arg ; }
public void add Surprise Member For Testing ( Distributed Member m , long birth Time ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING , m , birth Time ) ; } latest View Write Lock . lock ( ) ; try { surprise Members . put ( ( Internal Distributed Member ) m , Long . value Of ( birth Time ) ) ; } finally { latest View Write Lock . unlock ( ) ; } }
public Unicast Server Ref ( ) { }
private static int last Index Of ( Object o , Object [ ] elements , int index ) { if ( o == null ) { for ( int i = index ; i >= NUM ; i -- ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i >= NUM ; i -- ) if ( o . equals ( elements [ i ] ) ) return i ; } return - NUM ; }
private int read Local ( final Byte Buffer buffer , final long position ) throws IO Exception { final int request Len = buffer . remaining ( ) ; final long eof = m channel . size ( ) ; if ( eof < ( position + request Len ) ) { if ( position == eof ) return - NUM ; final int len = ( int ) ( eof - position ) ; buffer . limit ( len ) ; File Channel Utility . read All ( m reopener , buffer , position ) ; buffer . limit ( request Len ) ; } else { File Channel Utility . read All ( m reopener , buffer , position ) ; } return request Len - buffer . remaining ( ) ; }
@ Override public boolean is Subtype ( Annotation Mirror rhs , Annotation Mirror lhs ) { if ( Annotation Utils . are Same By Class ( lhs , Unknown Val . class ) || Annotation Utils . are Same By Class ( rhs , Bottom Val . class ) ) { return BOOL ; } else if ( Annotation Utils . are Same By Class ( rhs , Unknown Val . class ) || Annotation Utils . are Same By Class ( lhs , Bottom Val . class ) ) { return BOOL ; } else if ( Annotation Utils . are Same Ignoring Values ( lhs , rhs ) ) { List < Object > lhs Values = Annotation Utils . get Element Value Array ( lhs , STRING , Object . class , BOOL ) ; List < Object > rhs Values = Annotation Utils . get Element Value Array ( rhs , STRING , Object . class , BOOL ) ; return lhs Values . contains All ( rhs Values ) ; } else if ( Annotation Utils . are Same By Class ( lhs , Double Val . class ) && Annotation Utils . are Same By Class ( rhs , Int Val . class ) ) { List < Long > rhs Values ; rhs Values = Annotation Utils . get Element Value Array ( rhs , STRING , Long . class , BOOL ) ; List < Double > lhs Values = Annotation Utils . get Element Value Array ( lhs , STRING , Double . class , BOOL ) ; boolean same = BOOL ; for ( Long rhs Long : rhs Values ) { for ( Double lhs Dbl : lhs Values ) { if ( lhs Dbl . double Value ( ) == rhs Long . double Value ( ) ) { same = BOOL ; break ; } } if ( ! same ) { return BOOL ; } } return same ; } return BOOL ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m build Thread . is Alive ( ) && m state != IDLE ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
public void move ( Mouse Event e ) { Point 2 D pnt = get Projection Point ( e ) ; int x = ( int ) pnt . get X ( ) ; int y = ( int ) pnt . get Y ( ) ; if ( line . get Render Type ( ) == OM Graphic . RENDERTYPE OFFSET ) { gpm = new Offset Grab Point ( x , y ) ; gpm . add Grab Point ( gp 1 ) ; gpm . add Grab Point ( gp 2 ) ; } else { gpm = gpo ; gpm . set ( x , y ) ; gpm . update Offsets ( ) ; } moving Point = gpm ; }
public static boolean is In Range ( String ip , String ip Range ) { if ( ip == null || ip Range == null ) return BOOL ; String [ ] cidr String = ip Range . split ( STRING ) ; if ( cidr String . length == NUM ) return BOOL ; String network = cidr String [ NUM ] ; String cidr Mask = STRING ; if ( cidr String . length > NUM ) { cidr Mask = cidr String [ NUM ] ; } String net Mask = cidr Mask To Net Mask ( cidr Mask ) ; Inet Address masked IP = apply Mask ( ip , net Mask ) ; Inet Address masked Network = apply Mask ( network , net Mask ) ; if ( masked IP == null || masked Network == null ) return BOOL ; return masked IP . equals ( masked Network ) ; }
protected static Boolean try Lock ( String service Name , Object name , Long wait ) { D Lock Service service = D Lock Service . get Internal Service Named ( service Name ) ; boolean locked = service . lock ( name , wait . long Value ( ) , - NUM , BOOL ) ; return Boolean . value Of ( locked ) ; }
public void begin Display ( Display Event event ) throws Model Control Exception { if ( ad != null ) { try { String cookie Domain = null ; Set < String > cookie Domain Set = Auth Client Utils . get Cookie Domains For Request ( request ) ; Cookie cookie ; set Page Encoding ( request , response ) ; if ( cookie Domain Set . is Empty ( ) ) { cookie = Auth Utils . get Logout Cookie ( ac , null ) ; response . add Cookie ( cookie ) ; } else { Iterator iter = cookie Domain Set . iterator ( ) ; while ( iter . has Next ( ) ) { cookie Domain = ( String ) iter . next ( ) ; cookie = Auth Utils . get Logout Cookie ( ac , cookie Domain ) ; response . add Cookie ( cookie ) ; } } Auth Utils . clearlb Cookie ( request , response ) ; Result Val = rb . get String ( STRING ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; if ( ex Debug . message Enabled ( ) ) { ex Debug . message ( STRING + e . get Message ( ) ) ; } Result Val = rb . get String ( STRING ) + STRING + e . get Message ( ) ; } } }
private File select Export File ( final String title , File Name Extension Filter file Name Extension Filter ) { if ( Boolean . parse Boolean ( System . get Property ( STRING , Boolean . to String ( OS Type . is Mac ( ) ) ) ) ) { File Dialog export Dialog = file Dialogs . get ( title ) ; if ( export Dialog == null ) { export Dialog = new File Dialog ( this , title , File Dialog . SAVE ) ; file Dialogs . put ( title , export Dialog ) ; } export Dialog . set File ( options . file Name Stem + STRING ) ; export Dialog . set Visible ( BOOL ) ; if ( export Dialog . get File ( ) != null ) { return new File ( export Dialog . get Directory ( ) , export Dialog . get File ( ) ) ; } } else { J File Chooser export Chooser = file Choosers . get ( title ) ; if ( export Chooser == null ) { export Chooser = new J File Chooser ( Utils . get CWD ( ) ) ; export Chooser = new J File Chooser ( Utils . get CWD ( ) ) ; export Chooser . set File Filter ( file Name Extension Filter ) ; export Chooser . set Dialog Title ( title ) ; file Choosers . put ( title , export Chooser ) ; } export Chooser . set Selected File ( new File ( options . file Name Stem + STRING ) ) ; final int return Val = export Chooser . show Save Dialog ( this ) ; if ( return Val == J File Chooser . APPROVE OPTION ) { File file = export Chooser . get Selected File ( ) ; int n = J Option Pane . YES OPTION ; if ( file . exists ( ) ) { n = J Option Pane . show Confirm Dialog ( this , file . get Name ( ) , STRING , J Option Pane . YES NO OPTION ) ; } if ( n == J Option Pane . YES OPTION ) { return file ; } } } return null ; }
public GT Meta Generated Item X01 ( String a Unlocalized , Ore Prefixes a Generated Prefix , int a Icon Set Index ) { super ( a Unlocalized , ( short ) NUM , ( short ) NUM ) ; m Prefix = a Generated Prefix ; m Icon Set Index = a Icon Set Index >= NUM ? a Icon Set Index : a Generated Prefix . m Texture Index >= NUM ? a Generated Prefix . m Texture Index : NUM ; for ( int i = NUM ; i < Greg Tech API . s Generated Materials . length ; i ++ ) { Ore Prefixes t Prefix = m Prefix ; if ( t Prefix == null ) continue ; Materials t Material = Greg Tech API . s Generated Materials [ i ] ; if ( t Material == null ) continue ; if ( m Prefix . do Generate Item ( t Material ) ) { Item Stack t Stack = new Item Stack ( this , NUM , i ) ; GT Language Manager . add String Localization ( get Unlocalized Name ( t Stack ) + STRING , get Default Localization ( t Prefix , t Material , i ) ) ; GT Language Manager . add String Localization ( get Unlocalized Name ( t Stack ) + STRING , t Material . get Tool Tip ( t Prefix . m Material Amount / M ) ) ; String t Ore Name = get Ore Dict String ( t Prefix , t Material ) ; t Prefix = Ore Prefixes . get Ore Prefix ( t Ore Name ) ; if ( t Prefix != null && t Prefix . m Is Unificatable ) { GT Ore Dict Unificator . set ( t Prefix , Ore Prefixes . get Material ( t Ore Name , t Prefix ) , t Stack ) ; } else { GT Ore Dict Unificator . register Ore ( t Ore Name , t Stack ) ; } } } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static Parsed Sql parse Sql Statement ( String sql ) { if ( sql == null ) new Illegal Argument Exception ( STRING ) ; Set < String > named Parameters = new Hash Set < String > ( ) ; Parsed Sql parsed Sql = new Parsed Sql ( sql ) ; char [ ] statement = sql . to Char Array ( ) ; int named Parameter Count = NUM ; int unnamed Parameter Count = NUM ; int total Parameter Count = NUM ; int i = NUM ; while ( i < statement . length ) { int skip To Position = skip Comments And Quotes ( statement , i ) ; if ( i != skip To Position ) { if ( skip To Position >= statement . length ) { break ; } i = skip To Position ; } char c = statement [ i ] ; if ( c == STRING || c == STRING || c == STRING || c == STRING ) { int j = i + NUM ; if ( j < statement . length && statement [ j ] == STRING && c == STRING ) { i = i + NUM ; continue ; } while ( j < statement . length && ! is Parameter Separator ( statement [ j ] ) ) { j ++ ; } if ( j - i > NUM ) { String parameter = sql . substring ( i + NUM , j ) ; if ( ! named Parameters . contains ( parameter ) ) { named Parameters . add ( parameter ) ; named Parameter Count ++ ; } String removed Prefix And Suffix Parameter = remove Prefix And Suffix ( c , parameter , sql ) ; parsed Sql . add Named Parameter ( removed Prefix And Suffix Parameter , c + parameter , i , j ) ; total Parameter Count ++ ; } i = j - NUM ; } else { if ( c == STRING ) { unnamed Parameter Count ++ ; total Parameter Count ++ ; } } i ++ ; } parsed Sql . set Named Parameter Count ( named Parameter Count ) ; parsed Sql . set Unnamed Parameter Count ( unnamed Parameter Count ) ; parsed Sql . set Total Parameter Count ( total Parameter Count ) ; return parsed Sql ; }
final void put Double ( int offset , double value ) { unsafe . put Double ( offset + address , value ) ; }
public void add Request ( Action Request request , Limited Queue Info queue Info ) { String request Id = Penn Station . request Action ( request , queue Info ) ; synchronized ( this ) { m Last Request Id By Type . put ( request . type ( ) , request Id ) ; m Request Ids . add ( request Id ) ; } }
public static String gensalt ( final int log rounds , final Secure Random random ) { final String Buffer rs = new String Buffer ( ) ; final byte rnd [ ] = new byte [ BCRYPT SALT LEN ] ; random . next Bytes ( rnd ) ; rs . append ( STRING ) ; if ( log rounds < NUM ) { rs . append ( STRING ) ; } if ( log rounds > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } rs . append ( Integer . to String ( log rounds ) ) ; rs . append ( STRING ) ; rs . append ( encode base 64 ( rnd , rnd . length ) ) ; return rs . to String ( ) ; }
public static Version Number from String ( String str ) { if ( str == null ) { return null ; } String [ ] pieces = str . split ( STRING ) ; if ( pieces . length != NUM ) { return null ; } Version Number version = new Version Number ( ) ; try { for ( int i = NUM ; i < NUM ; ++ i ) { version . m Version [ i ] = Integer . parse Int ( pieces [ i ] ) ; } } catch ( Number Format Exception e ) { return null ; } return version ; }
private void run Init Function If Required ( String url , Connection connection ) throws SQL Exception { Matcher matcher = INITFUNCTION MATCHING PATTERN . matcher ( url ) ; if ( matcher . matches ( ) ) { String class Name = matcher . group ( NUM ) ; String method Name = matcher . group ( NUM ) ; try { Class < ? > init Function Clazz = Class . for Name ( class Name ) ; Method method = init Function Clazz . get Method ( method Name , Connection . class ) ; method . invoke ( null , connection ) ; } catch ( Class Not Found Exception | No Such Method Exception | Illegal Access Exception | Invocation Target Exception e ) { LOGGER . error ( STRING , class Name , method Name , e ) ; throw new SQL Exception ( STRING + class Name + STRING + method Name , e ) ; } } }
public static void check Finite ( final double x ) throws Math Illegal Argument Exception { if ( Double . is Infinite ( x ) || Double . is Na N ( x ) ) { throw new Math Illegal Argument Exception ( Localized Core Formats . NOT FINITE NUMBER , x ) ; } }
@ Override public void on Create ( Bundle icicle ) { super . on Create ( icicle ) ; set Content View ( R . layout . main ) ; File path = Environment . get Data Directory ( ) ; Stat Fs stat = new Stat Fs ( path . get Path ( ) ) ; int total Blocks = stat . get Block Count ( ) ; m Block Size = ( int ) ( stat . get Block Size ( ) ) ; Text View start Size Text View = ( Text View ) find View By Id ( R . id . totalsize ) ; start Size Text View . set Text ( Long . to String ( ( total Blocks * m Block Size ) / BYTE SIZE ) ) ; Button button = ( Button ) find View By Id ( R . id . button run ) ; button . set On Click Listener ( m Start Listener ) ; }
public static boolean is Auto Commit ( Properties ctx , int Window No ) { if ( ctx == null ) throw new Illegal Argument Exception ( STRING ) ; String s = get Context ( ctx , Window No , STRING , BOOL ) ; if ( s != null ) { if ( s . equals ( STRING ) ) return BOOL ; else return BOOL ; } return is Auto Commit ( ctx ) ; }
public static List < String > file List ( String directory Path , boolean include Full Path ) { List < String > file List = new Array List < String > ( ) ; String dir = directory Path . substring ( NUM , directory Path . last Index Of ( File . separator ) ) ; String pattern = String Utils . substring After Last ( directory Path , File . separator ) ; File directory = new File ( dir ) ; if ( directory . is Directory ( ) ) { File [ ] files = directory . list Files ( ) ; for ( int i = NUM ; i < files . length ; i ++ ) { File f = files [ i ] ; if ( f . is File ( ) ) { String file Name = f . get Name ( ) ; String full Path = dir + File . separator + file Name ; if ( file Name . matches ( convert Glob To Reg Ex ( pattern ) ) ) { if ( include Full Path ) { file List . add ( full Path ) ; } else { file List . add ( file Name ) ; } } } } } return file List ; }
public boolean init ( ) { if ( MODE == MODE HORIZONTAL ) { center Panel . set Layout ( new A Layout ( ) ) ; } if ( MODE == MODE VERTICAL ) { gbc . anchor = Grid Bag Constraints . NORTHWEST ; gbc . weightx = NUM ; gbc . weighty = NUM ; gbc . gridy = m line ++ ; gbc . gridx = NUM ; gbc . gridwidth = NUM ; gbc . insets = null Inset ; gbc . fill = Grid Bag Constraints . HORIZONTAL ; center Panel . add ( Box . create Vertical Strut ( NUM ) , gbc ) ; } log . config ( STRING ) ; M Client client = M Client . get ( Env . get Ctx ( ) ) ; String ASP Filter = STRING ; if ( client . is Use ASP ( ) ) ASP Filter = STRING + STRING + STRING + STRING + STRING + client . get AD Client ID ( ) + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + client . get AD Client ID ( ) + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + client . get AD Client ID ( ) + STRING + STRING + STRING + STRING + STRING ; String sql = null ; if ( Env . is Base Language ( Env . get Ctx ( ) , STRING ) ) sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + ASP Filter + STRING ; else sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + Env . get AD Language ( Env . get Ctx ( ) ) + STRING + STRING + ASP Filter + STRING ; int cols = NUM ; int col = NUM ; int row = NUM ; boolean has Fields = BOOL ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , m process Info . get AD Process ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { has Fields = BOOL ; if ( MODE == MODE HORIZONTAL ) { create Field ( rs , row , cols ) ; cols = cols + col ; if ( cols >= NUM ) { cols = NUM ; row ++ ; } } if ( MODE == MODE VERTICAL ) { create Field ( rs ) ; } } } catch ( SQL Exception e ) { throw new DB Exception ( e , sql ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( m m Fields . size ( ) != m m Fields 2 . size ( ) || m m Fields . size ( ) != m v Editors . size ( ) || m m Fields 2 . size ( ) != m v Editors 2 . size ( ) ) log . log ( Level . SEVERE , STRING ) ; if ( has Fields ) { if ( MODE == MODE VERTICAL ) { gbc . gridy = m line ++ ; center Panel . add ( Box . create Vertical Strut ( NUM ) , gbc ) ; gbc . gridx = NUM ; center Panel . add ( Box . create Horizontal Strut ( NUM ) , gbc ) ; } dynamic Display ( ) ; } else dispose ( ) ; return has Fields ; }
public void add Leaking Resource ( Leaking Resource resource ) { synchronized ( leaking Resources ) { leaking Resources . add ( resource ) ; } }
public void test Neg Pos ( ) { byte a Bytes [ ] = { - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM } ; int a Sign = - NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . and ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
public static String generate Random String ( int length ) { String AB = STRING ; Random rnd = new Random ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i ++ ) sb . append ( AB . char At ( rnd . next Int ( AB . length ( ) ) ) ) ; return sb . to String ( ) ; }
public static boolean does Exchange Use Reverse Rates ( String short Exchange Name ) { if ( short Exchange Name == null ) { throw new Illegal Argument Exception ( STRING ) ; } return BITCOIN CHARTS EXCHANGE NAME . equals ( short Exchange Name ) ; }
private static List < String > lines To Write ( String path , Global global , List < Attribute > attributes , Class < ? > a Class ) throws No Such Field Exception , IO Exception { String [ ] class Identifier = new String [ ] { STRING , STRING , a Class . get Simple Name ( ) } ; boolean class Found = BOOL ; verify Attributes ( a Class , attributes ) ; Hash Map < String , String > attribute Types = get Types ( a Class , attributes ) ; List < String > lines To Write = new Array List < String > ( ) ; List < String > lines = read File ( new File ( path ) ) ; if ( ! is Empty ( attributes ) ) { lines = add Import ( lines , a Class , J Map . class ) ; lines = add Target Classes Import ( lines , attributes , a Class ) ; } if ( ! is Null ( global ) ) lines = add Import ( lines , a Class , J Global Map . class ) ; if ( containts Accessors ( global , attributes ) ) { lines = add Import ( lines , a Class , J Map Accessor . class ) ; lines = add Import ( lines , a Class , J Map Accessors . class ) ; } for ( String line : lines ) { if ( contains All ( line , class Identifier ) ) { if ( global != null ) lines To Write . add ( to Annotation ( global ) ) ; class Found = BOOL ; } if ( class Found && ! is Empty ( attributes ) ) { Attribute remove = null ; for ( Attribute attribute : attributes ) { String name = attribute . get Name ( ) ; String type = attribute Types . get ( name ) ; if ( contains All ( line , name , type ) && ! line . contains ( STRING ) ) { lines To Write . add ( to Annotation ( attribute ) ) ; remove = attribute ; } } if ( remove != null ) attributes . remove ( remove ) ; } lines To Write . add ( line ) ; } return lines To Write ; }
public < T > T retrieve ( String key , final Class < T > clazz , boolean is Encrypted , String encrypt Key ) { key = safety Key ( key ) ; File file = new File ( cache Directory , key ) ; if ( is Encrypted ) { file = file Encryptor . decrypt ( encrypt Key , file ) ; } try { T data = jolyglot . from Json ( file , clazz ) ; return data ; } catch ( Exception ignore ) { return null ; } finally { if ( is Encrypted ) { file . delete ( ) ; } } }
public static void surface Sql Exception ( SQL Exception e ) { boolean chained = BOOL ; String logger Msg ; while ( e != null ) { if ( chained ) { logger Msg = String . format ( STRING , e . get SQL State ( ) , e . get Error Code ( ) , e . get Message ( ) , stack Trace To String ( e ) ) ; } else { logger Msg = String . format ( STRING , e . get SQL State ( ) , e . get Error Code ( ) , e . get Message ( ) , stack Trace To String ( e ) ) ; chained = BOOL ; } e = e . get Next Exception ( ) ; logger . error ( logger Msg ) ; } }
private void append Start Tag ( String q Name , Attributes attributes ) { char Buf . append ( STRING + q Name ) ; for ( Map . Entry < String , String > entry : new Namespace Mappings . entry Set ( ) ) { String prefix = entry . get Key ( ) ; String namespace = entry . get Value ( ) ; append Namespace Decl ( char Buf , prefix , namespace ) ; } int att Count = attributes . get Length ( ) ; for ( int i = NUM ; i < att Count ; i ++ ) { append Attribute ( char Buf , attributes . get Q Name ( i ) , attributes . get Value ( i ) ) ; } char Buf . append ( STRING ) ; int colon Idx = q Name . index Of ( STRING ) ; String prefix = ( colon Idx > NUM ) ? q Name . substring ( NUM , colon Idx ) : STRING ; if ( ! xml Literal Prefixes . contains ( prefix ) && ! unknown Prefixes In XML Literal . contains ( prefix ) ) { unknown Prefixes In XML Literal . add ( prefix ) ; } }
public void add Remove And Get Time Nanos ( long duration ) { rmv Time Nanos . add And Get ( duration ) ; get Time Nanos . add And Get ( duration ) ; if ( delegate != null ) delegate . add Remove And Get Time Nanos ( duration ) ; }
public Bloom Filter ( byte [ ] data , int hash Functions , int tweak , Update Mode update ) { filter = Arrays . clone ( data ) ; this . hash Functions = Math . min ( hash Functions , MAX HASH FUNCS ) ; this . tweak = tweak ; this . update = update ; }
@ Request Processing ( value = STRING , method = HTTP Request Method . GET ) @ Before ( advice Class = { Stopwatch Start Advice . class , Anonymous View Check . class , User Block Check . class } ) @ After ( advice Class = Stopwatch End Advice . class ) public void show Home Following Users ( final HTTP Request Context context , final Http Servlet Request request , final Http Servlet Response response , final String user Name ) throws Exception { final JSON Object user = ( JSON Object ) request . get Attribute ( User . USER ) ; request . set Attribute ( Keys . TEMAPLTE DIR NAME , Symphonys . get ( STRING ) ) ; final Abstract Free Marker Renderer renderer = new Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( STRING ) ; final Map < String , Object > data Model = renderer . get Data Model ( ) ; filler . fill Header And Footer ( request , response , data Model ) ; String page Num Str = request . get Parameter ( STRING ) ; if ( Strings . is Empty Or Null ( page Num Str ) || ! Strings . is Numeric ( page Num Str ) ) { page Num Str = STRING ; } final int page Num = Integer . value Of ( page Num Str ) ; final int page Size = Symphonys . get Int ( STRING ) ; final int window Size = Symphonys . get Int ( STRING ) ; fill Home User ( data Model , user ) ; final String following Id = user . opt String ( Keys . OBJECT ID ) ; data Model . put ( Follow . FOLLOWING ID , following Id ) ; avatar Query Service . fill User Avatar URL ( user ) ; final JSON Object following Users Result = follow Query Service . get Following Users ( following Id , page Num , page Size ) ; final List < JSON Object > following Users = ( List < JSON Object > ) following Users Result . opt ( Keys . RESULTS ) ; data Model . put ( Common . USER HOME FOLLOWING USERS , following Users ) ; final boolean is Logged In = ( Boolean ) data Model . get ( Common . IS LOGGED IN ) ; if ( is Logged In ) { final JSON Object current User = ( JSON Object ) data Model . get ( Common . CURRENT USER ) ; final String follower Id = current User . opt String ( Keys . OBJECT ID ) ; final boolean is Following = follow Query Service . is Following ( follower Id , following Id ) ; data Model . put ( Common . IS FOLLOWING , is Following ) ; for ( final JSON Object following User : following Users ) { final String home User Following User Id = following User . opt String ( Keys . OBJECT ID ) ; following User . put ( Common . IS FOLLOWING , follow Query Service . is Following ( follower Id , home User Following User Id ) ) ; } } user . put ( User Ext . USER T CREATE TIME , new Date ( user . get Long ( Keys . OBJECT ID ) ) ) ; final int following User Cnt = following Users Result . opt Int ( Pagination . PAGINATION RECORD COUNT ) ; final int page Count = ( int ) Math . ceil ( ( double ) following User Cnt / ( double ) page Size ) ; final List < Integer > page Nums = Paginator . paginate ( page Num , page Size , page Count , window Size ) ; if ( ! page Nums . is Empty ( ) ) { data Model . put ( Pagination . PAGINATION FIRST PAGE NUM , page Nums . get ( NUM ) ) ; data Model . put ( Pagination . PAGINATION LAST PAGE NUM , page Nums . get ( page Nums . size ( ) - NUM ) ) ; } data Model . put ( Pagination . PAGINATION CURRENT PAGE NUM , page Num ) ; data Model . put ( Pagination . PAGINATION PAGE COUNT , page Count ) ; data Model . put ( Pagination . PAGINATION PAGE NUMS , page Nums ) ; }
public int interp Elevation At ( float lat , float lon ) { if ( frame is valid == BOOL ) { if ( lat >= dsi . sw lat && lat <= dsi . ne lat && lon >= dsi . sw lon && lon <= dsi . ne lon ) { float lat index = ( lat - dsi . sw lat ) * NUM / uhl . lat post interval ; float lon index = ( lon - dsi . sw lon ) * NUM / uhl . lon post interval ; int lflon index = ( int ) Math . floor ( lon index ) ; int lclon index = ( int ) Math . ceil ( lon index ) ; int lclat index = ( int ) Math . ceil ( lat index ) ; if ( elevations [ lflon index ] == null ) read Data Record ( lflon index ) ; if ( elevations [ lclon index ] == null ) read Data Record ( lclon index ) ; int ul = elevations [ lflon index ] [ lclat index ] ; int ur = elevations [ lclon index ] [ lclat index ] ; int ll = elevations [ lflon index ] [ lclat index ] ; int lr = elevations [ lclon index ] [ lclat index ] ; float answer = resolve Four Points ( ul , ur , lr , ll , lat index , lon index ) ; return Math . round ( answer ) ; } } return - NUM ; }
@ Override Observed Object create Observed Object ( Object Name object ) { final Gauge Monitor Observed Object gmo = new Gauge Monitor Observed Object ( object ) ; gmo . set Status ( RISING OR FALLING ) ; gmo . set Previous Scan Gauge ( null ) ; return gmo ; }
public Set < State > init And Start ( State Machine state Machine ) { Context context = new RAM Context ( System . current Time Millis ( ) , null , state Machine ) ; final List < String > triggered Events = events DAO . find Triggered Events Names By SM Id ( state Machine . get Id ( ) ) ; Set < State > initial States = context . get Initial States ( new Hash Set < > ( triggered Events ) ) ; execute States ( state Machine . get Id ( ) , initial States ) ; return initial States ; }
private boolean is obstacle clearance ( Brd Item curr item ) { boolean is obstacle = curr item . is obstacle ( this ) ; if ( ! is obstacle ) return BOOL ; if ( ! ( this instanceof Brd Tracep && curr item instanceof Brd Tracep ) ) return BOOL ; Brd Tracep this trace = ( Brd Tracep ) this ; boolean contact found = BOOL ; Pla Point contact point = this trace . corner first ( ) ; Collection < Brd Item > curr contacts = this trace . get normal contacts ( contact point , BOOL ) ; if ( curr contacts . contains ( curr item ) ) contact found = BOOL ; if ( ! contact found ) { contact point = this trace . corner last ( ) ; curr contacts = this trace . get normal contacts ( contact point , BOOL ) ; if ( curr contacts . contains ( curr item ) ) contact found = BOOL ; } if ( ! contact found ) return BOOL ; for ( Brd Item curr contact : curr contacts ) { if ( ! ( curr contact instanceof Brd Abit Pin ) ) continue ; if ( curr contact . shares net ( this ) && curr contact . shares net ( curr item ) ) return BOOL ; } return BOOL ; }
private Object try Eval As Method ( Class < ? > clazz , Object target , List < Object > args ) { Method method = find Method ( clazz , args ) ; if ( method == null ) { return null ; } try { return Values . ensure Not Null ( location ( ) , method . invoke ( target , Values . convert Args ( location ( ) , method . get Parameter Types ( ) , args ) ) ) ; } catch ( Illegal Access Exception | Illegal Argument Exception e ) { throw new Eval Exception ( location ( ) , STRING , name ( ) , e . get Message ( ) ) ; } catch ( Invocation Target Exception e ) { throw new Eval Exception ( Issue . create ( location ( ) , STRING , name ( ) , e . get Cause ( ) ) ) ; } }
private static String pad String ( String s , Align alignment , int min Length ) { if ( alignment == Align . Left ) { return pad Right ( s , min Length ) ; } else if ( alignment == Align . Right ) { return pad Left ( s , min Length ) ; } else { throw new Index Out Of Bounds Exception ( STRING ) ; } }
protected synchronized void on Send Accepted ( Record Buffer < R > buffer ) { logger . trace ( STRING , name ( ) , buffer ) ; throttler . on Send Accepted ( ) ; active Send Tasks . increment And Get ( ) ; }
public void add Add Delete Buttons ( ) { J Button delete Button = new J Button ( STRING ) ; delete Button . set Action ( Raster Plot Actions . get Remove Source Action ( this ) ) ; J Button add Button = new J Button ( STRING ) ; add Button . set Action ( Raster Plot Actions . get Add Source Action ( this ) ) ; button Panel . add ( delete Button ) ; button Panel . add ( add Button ) ; }
List < Key > subrecord Keys ( long low Time , long high Time ) { List < Key > keys = new Array List < Key > ( ) ; long low Bucket Number = bucket Number ( low Time ) ; long high Bucket Number = bucket Number ( high Time ) ; for ( long index = low Bucket Number ; index <= high Bucket Number ; index += this . bucket Size ) { keys . add ( form Subrecord Key ( index ) ) ; } return keys ; }
public String warehouse ( Properties ctx , int Window No , Grid Tab m Tab , Grid Field m Field , Object value ) { if ( is Callout Active ( ) ) return STRING ; Integer M Warehouse ID = ( Integer ) value ; if ( M Warehouse ID == null || M Warehouse ID . int Value ( ) == NUM ) return STRING ; String sql = STRING + STRING + STRING + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , M Warehouse ID . int Value ( ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { Integer ii = new Integer ( rs . get Int ( NUM ) ) ; int AD Org ID = Env . get Context As Int ( ctx , Window No , STRING ) ; if ( AD Org ID != ii . int Value ( ) ) m Tab . set Value ( STRING , ii ) ; ii = new Integer ( rs . get Int ( NUM ) ) ; if ( rs . was Null ( ) ) Env . set Context ( ctx , Window No , NUM , STRING , null ) ; else { log . config ( STRING + ii ) ; Env . set Context ( ctx , Window No , STRING , ii . int Value ( ) ) ; } } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; return e . get Localized Message ( ) ; } finally { DB . close ( rs , pstmt ) ; } return STRING ; }
public Byte Interleaved Raster ( Sample Model sample Model , Data Buffer data Buffer , Point origin ) { this ( sample Model , data Buffer , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
@ Override public boolean swipe ( Selector obj , String dir , float percent , int steps ) throws Ui Object Not Found Exception { if ( obj . to Ui Object 2 ( ) == null ) { return swipe ( device . find Object ( obj . to Ui Selector ( ) ) , dir , steps ) ; } return swipe ( obj . to Ui Object 2 ( ) , dir , percent , steps ) ; }
public static double parse ( String s ) { try { return Double . parse Double ( s ) ; } catch ( Number Format Exception e ) { } s = s . replace All ( STRING , STRING ) ; s = s . replace All ( STRING , STRING ) ; s = s . replace All ( STRING , STRING ) ; s = s . replace All ( STRING , STRING ) ; try { return Double . parse Double ( s ) ; } catch ( Number Format Exception e ) { } Pattern p2 = Pattern . compile ( STRING ) ; Matcher m2 = p2 . matcher ( s ) ; if ( m2 . matches ( ) ) { try { return ( Double . parse Double ( m2 . group ( NUM ) ) + Double . parse Double ( m2 . group ( NUM ) ) ) / NUM ; } catch ( Number Format Exception e ) { } } Pattern p1 = Pattern . compile ( STRING ) ; Matcher m1 = p1 . matcher ( s ) ; if ( m1 . matches ( ) ) { try { return Double . parse Double ( m1 . group ( NUM ) ) ; } catch ( Number Format Exception e ) { } } return Double . Na N ; }
public void add Listener ( final I Debugger Chooser Panel Listener listener ) { m listeners . add Listener ( listener ) ; }
boolean filter Changed ( Table Line Filter < Search Result Data Line > filter , int depth ) { FILTER . set Filter ( depth , filter ) ; int [ ] rows = TABLE . get Selected Rows ( ) ; Search Result Data Line [ ] lines = new Search Result Data Line [ rows . length ] ; List < Search Result Data Line > in View = new Linked List < > ( ) ; for ( int i = NUM ; i < rows . length ; i ++ ) { int row = rows [ i ] ; Search Result Data Line line = DATA MODEL . get ( row ) ; lines [ i ] = line ; if ( TABLE . is Row Visible ( row ) ) in View . add ( line ) ; } DATA MODEL . filters Changed ( ) ; for ( int i = NUM ; i < rows . length ; i ++ ) { Search Result Data Line line = lines [ i ] ; int row = DATA MODEL . get Row ( line ) ; if ( row != - NUM ) { TABLE . add Row Selection Interval ( row , row ) ; if ( in View != null && in View . contains ( line ) ) { TABLE . ensure Row Visible ( row ) ; in View = null ; } } } Search Mediator . set Tab Display Count ( this ) ; return BOOL ; }
@ Target Api ( Build . VERSION CODES . ICE CREAM SANDWICH MR 1 ) private boolean needs Fallback Locale ( ) { if ( ! PACKAGE GOOGLE TTS . equals ( m Tts Engine ) || ( m Default Locale != null ) ) { return BOOL ; } if ( m Tts == null ) { return BOOL ; } final Set < String > features = m Tts . get Features ( m System Locale ) ; return ! ( ( ( features != null ) && features . contains ( Engine . KEY FEATURE EMBEDDED SYNTHESIS ) ) || ! is Not Available Status ( m Tts . is Language Available ( m System Locale ) ) ) ; }
public static F Size calc Text Size ( Paint paint , String demo Text ) { Rect r = new Rect ( ) ; paint . get Text Bounds ( demo Text , NUM , demo Text . length ( ) , r ) ; return new F Size ( r . width ( ) , r . height ( ) ) ; }
@ Visible For Testing protected Map < String , String > calculate Modified Server Defaults ( Map < String , String > new Defaults , Map < String , String > existing Defaults , Set < String > attr To Modify ) { Map < String , String > modified Values = new Hash Map < String , String > ( ) ; for ( String attr Name : attr To Modify ) { String new Attr = new Defaults . get ( attr Name ) ; String existing Attr = existing Defaults . get ( attr Name ) ; if ( new Attr != null && existing Attr != null && ! new Attr . equals ( existing Attr ) ) { modified Values . put ( attr Name , new Attr ) ; } } return modified Values ; }
public static void write ( float lt , float ln , int offset x1 , int offset y1 , Image image , int image width , int image height , Link Properties properties , Data Output Stream dos ) throws IO Exception , Interrupted Exception { int [ ] pixels = new int [ image width * image height ] ; Pixel Grabber pixelgrabber = new Pixel Grabber ( image , NUM , NUM , image width , image height , pixels , NUM , image width ) ; pixelgrabber . grab Pixels ( ) ; Link Raster . write ( lt , ln , offset x1 , offset y1 , image width , image height , pixels , properties , dos ) ; }
@ Suppress Warnings ( STRING ) public void test Failover Topology ( ) throws Exception { try { Ignite ignite 1 = start Grid ( NUM ) ; start Grid ( NUM ) ; ignite 1 . compute ( ) . local Deploy Task ( Job Fail Task . class , Job Fail Task . class . get Class Loader ( ) ) ; try { compute ( ignite 1 . cluster ( ) . for Remotes ( ) ) . execute ( Job Fail Task . class , null ) ; } catch ( Ignite Exception e ) { info ( STRING + e ) ; } assert ! failed . get ( ) ; } finally { stop Grid ( NUM ) ; stop Grid ( NUM ) ; } }
public void store ( String filename To Save , String comments ) throws File Not Found Exception , File Already Exists Exception { if ( String Utils . is Empty ( filename To Save ) ) { throw new File Not Found Exception ( ) ; } if ( filename To Save . equals ( filename ) ) { throw new File Already Exists Exception ( filename To Save ) ; } File Writer file Writer = null ; Buffered Writer buffered Writer = null ; try { file Writer = new File Writer ( filename To Save , BOOL ) ; buffered Writer = new Buffered Writer ( file Writer ) ; prop . store ( buffered Writer , comments ) ; } catch ( IO Exception e ) { logger . error ( STRING , e ) ; } finally { IO Utils . close Quite ( file Writer ) ; IO Utils . close Quite ( buffered Writer ) ; } }
public void register Connected ( long platform Ident ) { Agent Status Data agent Status Data = agent Status Data Map . get ( platform Ident ) ; if ( null == agent Status Data ) { agent Status Data = new Agent Status Data ( Agent Connection . CONNECTED ) ; Agent Status Data existing = agent Status Data Map . put If Absent ( platform Ident , agent Status Data ) ; if ( null != existing ) { agent Status Data = existing ; } } long current Time Millis = System . current Time Millis ( ) ; agent Status Data . set Last Keep Alive Timestamp ( current Time Millis ) ; agent Status Data . set Connection Timestamp ( current Time Millis ) ; agent Status Data . set Agent Connection ( Agent Connection . CONNECTED ) ; }
public static void add Servers To Site ( SSO Token sso Token , String site Name , Collection server Instance Names ) throws SMS Exception , SSO Exception , Configuration Exception { String site Id = get Site Id ( sso Token , site Name ) ; if ( site Id != null ) { for ( Iterator i = server Instance Names . iterator ( ) ; i . has Next ( ) ; ) { String svr = ( String ) i . next ( ) ; Server Configuration . add To Site ( sso Token , svr , site Name ) ; } } }
public static void clear ( int Window No , Container c , String Parse String ) { log . info ( STRING + Parse String ) ; Properties ctx = Env . get Ctx ( ) ; String parse = Env . parse Context ( ctx , Window No , Parse String , BOOL ) ; if ( parse . length ( ) == NUM ) parse = STRING + Parse String ; Window parent = Env . get Parent ( c ) ; if ( parent == null ) parent = Env . get Window ( Window No ) ; if ( show Dialog && parent != null ) { if ( parent instanceof J Frame ) new A Dialog Dialog ( ( J Frame ) parent , Env . get Header ( ctx , Window No ) , STRING + parse , J Option Pane . INFORMATION MESSAGE ) ; else new A Dialog Dialog ( ( J Dialog ) parent , Env . get Header ( ctx , Window No ) , STRING + parse , J Option Pane . INFORMATION MESSAGE ) ; } else J Option Pane . show Message Dialog ( parent , STRING + parse + STRING , Env . get Header ( ctx , Window No ) , J Option Pane . INFORMATION MESSAGE ) ; }
private String preprocess SLD ( Styled Layer Descriptor sld ) { if ( sld == null ) { return null ; } SLD Writer Interface sld Writer = SLD Writer Factory . create Writer ( null ) ; Duplicating Style Visitor duplicator = new Duplicating Style Visitor ( ) ; sld . accept ( duplicator ) ; Styled Layer Descriptor sld Copy = ( Styled Layer Descriptor ) duplicator . get Copy ( ) ; for ( Styled Layer styled Layer : sld Copy . layers ( ) ) { if ( styled Layer instanceof User Layer ) { User Layer Impl user Layer = ( User Layer Impl ) styled Layer ; user Layer . set Inline Feature Datastore ( null ) ; user Layer . set Inline Feature Type ( null ) ; } } String sld Contents = sld Writer . encode SLD ( null , sld Copy ) ; return sld Contents ; }
public void run Finalization ( ) { return ; }
private void display All String Defined In String Xml ( ) { Simple Icon Font Text View text View = ( Simple Icon Font Text View ) find View By Id ( R . id . text view 2 ) ; List < String > list = new Array List < > ( ) ; list . add ( get String ( R . string . cubeicon gems logo ) ) ; list . add ( get String ( R . string . cubeicon android ) ) ; list . add ( get String ( R . string . cubeicon heart ) ) ; String text = Text Utils . join ( STRING , list ) ; text View . set Text ( text ) ; }
protected void do Write ( Http Servlet Request request , Http Servlet Response response , String tunnel UUID ) throws Guacamole Exception { Guacamole Tunnel tunnel = get Tunnel ( tunnel UUID ) ; response . set Content Type ( STRING ) ; response . set Header ( STRING , STRING ) ; response . set Content Length ( NUM ) ; try { Guacamole Writer writer = tunnel . acquire Writer ( ) ; Reader input = new Input Stream Reader ( request . get Input Stream ( ) , STRING ) ; try { int length ; char [ ] buffer = new char [ NUM ] ; while ( tunnel . is Open ( ) && ( length = input . read ( buffer , NUM , buffer . length ) ) != - NUM ) writer . write ( buffer , NUM , length ) ; } finally { input . close ( ) ; } } catch ( Guacamole Connection Closed Exception e ) { logger . debug ( STRING , e ) ; } catch ( IO Exception e ) { deregister Tunnel ( tunnel ) ; tunnel . close ( ) ; throw new Guacamole Server Exception ( STRING + e . get Message ( ) , e ) ; } finally { tunnel . release Writer ( ) ; } }
protected Foreign Key Constraint build Foreign Key Constraint ( List < String > fk Field Names , List < String > pk Field Names , Table Definition target Table , Database Platform platform ) { assert fk Field Names . size ( ) > NUM && fk Field Names . size ( ) == pk Field Names . size ( ) ; Foreign Key Constraint fk Constraint = new Foreign Key Constraint ( ) ; for ( int i = NUM ; i < fk Field Names . size ( ) ; i ++ ) { fk Constraint . get Source Fields ( ) . add ( fk Field Names . get ( i ) ) ; fk Constraint . get Target Fields ( ) . add ( pk Field Names . get ( i ) ) ; } fk Constraint . set Target Table ( target Table . get Full Name ( ) ) ; String fk Field Name = fk Field Names . get ( NUM ) ; String name = build Foreign Key Constraint Name ( this . get Name ( ) , fk Field Name , platform . get Max Foreign Key Name Size ( ) , platform ) ; fk Constraint . set Name ( name ) ; return fk Constraint ; }
public void add Notification ( @ Not Null Notification notification ) { Notification Message message = new Notification Message ( resources , notification , this ) ; notification Message . put ( notification , message ) ; messages . add ( message ) ; show Message ( ) ; }
private static void merge ( Map < String , Object > merged , Map < String , Object > attributes ) { for ( Hash Map . Entry < String , Object > new Entry : attributes . entry Set ( ) ) { String key = new Entry . get Key ( ) ; if ( key . equals ( Chronix Query Params . SOLR VERSION FIELD ) ) { continue ; } if ( ! merged . contains Key ( key ) ) { merged . put ( key , new Linked Hash Set ( ) ) ; } Linked Hash Set values = ( Linked Hash Set ) merged . get ( key ) ; Object value = new Entry . get Value ( ) ; if ( value instanceof Collection && ! values . contains ( value ) ) { values . add All ( ( Collection ) value ) ; } else if ( ! values . contains ( value ) ) { values . add ( value ) ; } } }
public void deselect All ( final boolean should Fire Events ) { check Widget ( ) ; items . add All ( selection ) ; final List < DL Item > deselected Items = new Array List < DL Item > ( ) ; for ( final DL Item item : selection ) { item . set Last Action ( LAST ACTION . DESELECTION ) ; deselected Items . add ( item ) ; if ( should Fire Events ) { fire Selection Event ( item ) ; } } fire Selection Change Event ( deselected Items ) ; selection . clear ( ) ; redraw Tables ( ) ; }
public void rotate Way ( final Way way , final float angle , final int direction , final float pivot X , final float pivot Y , int w , int h , Bounding Box v ) { if ( way . get Nodes ( ) == null ) { Log . d ( STRING , STRING + way . get Osm Id ( ) + STRING ) ; return ; } dirty = BOOL ; try { Hash Set < Node > nodes = new Hash Set < Node > ( way . get Nodes ( ) ) ; for ( Node nd : nodes ) { undo . save ( nd ) ; api Storage . insert Element Safe ( nd ) ; float node X = Geo Math . lon E 7 To X ( w , v , nd . get Lon ( ) ) ; float node Y = Geo Math . lat E 7 To Y ( h , w , v , nd . get Lat ( ) ) ; float new X = pivot X + ( node X - pivot X ) * ( float ) Math . cos ( angle ) - direction * ( node Y - pivot Y ) * ( float ) Math . sin ( angle ) ; float new Y = pivot Y + direction * ( node X - pivot X ) * ( float ) Math . sin ( angle ) + ( node Y - pivot Y ) * ( float ) Math . cos ( angle ) ; int lat = Geo Math . y To Lat E 7 ( h , w , v , new Y ) ; int lon = Geo Math . x To Lon E 7 ( w , v , new X ) ; nd . set Lat ( lat ) ; nd . set Lon ( lon ) ; nd . update State ( Osm Element . STATE MODIFIED ) ; } record Imagery ( ) ; } catch ( Storage Exception e ) { e . print Stack Trace ( ) ; } }
private void init Listeners ( ) { add Mouse Listener ( m listener ) ; add Mouse Motion Listener ( m listener ) ; add Mouse Wheel Listener ( m listener ) ; add Focus Listener ( m listener ) ; add Component Listener ( m listener ) ; add Key Listener ( m listener ) ; m caret . add Caret Listener ( m listener ) ; }
@ Override public boolean equals ( Object obj ) { return ( obj instanceof String Compare ) ; }
private static Map < String , Set < Integer > > read Config File ( File config File ) throws IO Exception { Map < String , Set < Integer > > entries = new Hash Map < > ( ) ; for ( String line : File Utils . read Lines ( config File ) ) { String [ ] fields = line . split ( FIELDSEPARATOR CONFIGFILE ) ; if ( fields . length < NUM ) { throw new Illegal State Exception ( String . format ( STRING , config File , line ) ) ; } if ( entries . contains Key ( fields [ NUM ] ) ) { throw new Illegal State Exception ( String . format ( STRING , config File , fields [ NUM ] ) ) ; } Set < Integer > topic Counts = new Hash Set < > ( fields . length - NUM ) ; for ( int i = NUM ; i < fields . length ; i ++ ) { try { topic Counts . add ( Integer . parse Int ( fields [ i ] ) ) ; } catch ( Number Format Exception e ) { throw new Illegal State Exception ( String . format ( STRING , config File , fields [ i ] ) ) ; } } entries . put ( fields [ NUM ] , topic Counts ) ; } return entries ; }
public void test atomic Append Full Block ( ) throws IO Exception { final String id = STRING ; final int version = NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK SIZE ] ; r . next Bytes ( expected ) ; final long block 0 = repo . append Block ( id , version , expected , NUM , expected . length ) ; assert Equals ( STRING , NUM , block 0 ) ; assert Equals ( STRING , NUM , repo . get Block Count ( id , version ) ) ; assert Equals ( STRING , expected , repo . read Block ( id , version , block 0 ) ) ; assert Equals ( STRING , expected , read ( repo . input Stream ( id , version ) ) ) ; }
private void check Idle ( Iterable < Selection Key > keys ) { long now = U . current Time Millis ( ) ; for ( Selection Key key : keys ) { Grid Selector Nio Session Impl ses = ( Grid Selector Nio Session Impl ) key . attachment ( ) ; try { long write Timeout 0 = write Timeout ; boolean op Write = key . is Valid ( ) && ( key . interest Ops ( ) & Selection Key . OP WRITE ) != NUM ; if ( op Write && now - ses . last Send Time ( ) > write Timeout 0 ) { filter Chain . on Session Write Timeout ( ses ) ; ses . bytes Sent ( NUM ) ; continue ; } long idle Timeout 0 = idle Timeout ; if ( ! op Write && now - ses . last Receive Time ( ) > idle Timeout 0 && now - ses . last Send Schedule Time ( ) > idle Timeout 0 ) { filter Chain . on Session Idle Timeout ( ses ) ; ses . reset Send Schedule Time ( ) ; ses . bytes Received ( NUM ) ; } } catch ( Ignite Checked Exception e ) { close ( ses , e ) ; } } }
public static List < Response > execute Connection And Wait ( Http URL Connection connection , Request Batch requests ) { List < Response > responses = Response . from Http Connection ( connection , requests ) ; Utility . disconnect Quietly ( connection ) ; int num Requests = requests . size ( ) ; if ( num Requests != responses . size ( ) ) { throw new Facebook Exception ( String . format ( STRING , responses . size ( ) , num Requests ) ) ; } run Callbacks ( requests , responses ) ; Hash Set < Session > sessions = new Hash Set < Session > ( ) ; for ( Request request : requests ) { if ( request . session != null ) { sessions . add ( request . session ) ; } } for ( Session session : sessions ) { session . extend Access Token If Needed ( ) ; } return responses ; }
public static Redeem Data of ( EC Key key , Script program ) { check Argument ( program . is Sent To Address ( ) || program . is Sent To Raw Pub Key ( ) ) ; return key != null ? new Redeem Data ( Collections . singleton List ( key ) , program ) : null ; }
public void edit Sensors ( ) { Collection < Sensor > sensors = selection Model . get Selection ( ) ; if ( ! sensors . is Empty ( ) ) { Edit Sensors Dialog d = new Edit Sensors Dialog ( sensors ) ; d . set Bounds ( NUM , NUM , NUM , NUM ) ; d . set Visible ( BOOL ) ; } }
private static boolean use Specific Trust Store ( ) { return ( ( System Configuration Util . get Property ( SOAP KEYSTORE FILE PROP ) != null ) && ( System Configuration Util . get Property ( SOAP KEYSTORE PASS FILE PROP ) != null ) && ( System Configuration Util . get Property ( SOAP KEYSTORE TYPE PROP ) != null ) && ( System Configuration Util . get Property ( SOAP PRIVATE KEY PASS FILE PROP ) != null ) ) ; }
private void log Missing Resource ( Faces Context ctx , String resource Name , String library Name , Throwable t ) { Level level ; if ( ! ctx . is Project Stage ( Project Stage . Production ) ) { level = Level . WARNING ; } else { level = ( ( t != null ) ? Level . WARNING : Level . FINE ) ; } if ( library Name != null ) { if ( LOGGER . is Loggable ( level ) ) { LOGGER . log ( level , STRING , new Object [ ] { resource Name , library Name } ) ; if ( t != null ) { LOGGER . log ( level , STRING , t ) ; } } } else { if ( LOGGER . is Loggable ( level ) ) { LOGGER . log ( level , STRING , new Object [ ] { resource Name } ) ; if ( t != null ) { LOGGER . log ( level , STRING , t ) ; } } } }
protected static int to Digit ( final char ch , final int index ) throws Illegal Argument Exception { final int digit = Character . digit ( ch , NUM ) ; if ( digit == - NUM ) { throw new Illegal Argument Exception ( STRING + ch + STRING + index ) ; } return digit ; }
public JSON Object to JSON ( ) throws JSON Exception { JSON Object json = new JSON Object ( ) ; if ( entries . size ( ) > NUM ) { JSON Object history = new JSON Object ( ) ; for ( Entry e : entries ) { history . put ( e . push Id , e . timestamp ) ; } json . put ( STRING , history ) ; } json . put Opt ( STRING , last Time ) ; return json ; }
public static void save ( Key Store key Store , File key Store File , Password password ) throws Crypto Exception , IO Exception { Key Store Type key Store Type = Key Store Type . resolve Jce ( key Store . get Type ( ) ) ; if ( ! key Store Type . is File Based ( ) ) { throw new Crypto Exception ( Message Format . format ( res . get String ( STRING ) , key Store Type . jce ( ) ) ) ; } File Output Stream fos = null ; fos = new File Output Stream ( key Store File ) ; try { key Store . store ( fos , password . to Char Array ( ) ) ; } catch ( IO Exception ex ) { throw new Crypto Exception ( res . get String ( STRING ) , ex ) ; } catch ( Key Store Exception ex ) { throw new Crypto Exception ( res . get String ( STRING ) , ex ) ; } catch ( Certificate Exception ex ) { throw new Crypto Exception ( res . get String ( STRING ) , ex ) ; } catch ( No Such Algorithm Exception ex ) { throw new Crypto Exception ( res . get String ( STRING ) , ex ) ; } finally { IO Utils . close Quietly ( fos ) ; } }
public static boolean is Auto Scan Enabled ( Context context ) { final Shared Preferences prefs = Preference Manager . get Default Shared Preferences ( context ) ; return prefs . get Boolean ( context . get String ( R . string . pref key auto scan enabled ) , Boolean . parse Boolean ( context . get String ( R . string . pref auto scan default value ) ) ) ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) { return BOOL ; } if ( ! ( o instanceof Long Bit Set ) ) { return BOOL ; } Long Bit Set other = ( Long Bit Set ) o ; if ( num Bits != other . num Bits ) { return BOOL ; } return Arrays . equals ( bits , other . bits ) ; }
public Principal Entry ( String principal Class , String principal Name ) { if ( principal Class == null || principal Name == null ) throw new Null Pointer Exception ( Resources Mgr . get String ( STRING ) ) ; this . principal Class = principal Class ; this . principal Name = principal Name ; }
public static boolean is Drm Mime Type ( Context context , String mimetype ) { boolean result = BOOL ; if ( context != null ) { try { Drm Manager Client drm Client = new Drm Manager Client ( context ) ; if ( drm Client != null && mimetype != null && mimetype . length ( ) > NUM ) { result = drm Client . can Handle ( STRING , mimetype ) ; } } catch ( Illegal Argument Exception e ) { Log . w ( TAG , STRING ) ; } catch ( Illegal State Exception e ) { Log . w ( TAG , STRING ) ; } } return result ; }
private int read Internal ( ) throws IO Exception { int c ; if ( peekc == NO CHAR ) { c = reader . read ( ) ; } else { c = peekc ; peekc = NO CHAR ; if ( c == STRING ) { return c ; } } if ( c != STRING ) { return c ; } c = reader . read ( ) ; if ( c != STRING ) { peekc = c ; return STRING ; } do { c = reader . read ( ) ; } while ( c == STRING ) ; int nchars = NUM ; if ( c >= NUM ) { code [ nchars ++ ] = ( char ) c ; while ( nchars < NUM ) { int n = reader . read ( code , nchars , NUM - nchars ) ; if ( n < NUM ) { break ; } nchars += n ; } } String s = new String ( code , NUM , nchars ) ; if ( nchars == NUM ) { try { int i = Integer . parse Int ( s , NUM ) ; if ( i >= NUM ) { return ( char ) i ; } } catch ( Number Format Exception e ) { } } throw new IO Exception ( STRING + s ) ; }
protected static void compute Cartesian ( List < Event Bean [ ] > stream One , int [ ] sub Stream Nums One , List < Event Bean [ ] > stream Two , int [ ] sub Stream Nums Two , List < Event Bean [ ] > result List ) { if ( ( stream Two == null ) || ( stream Two . is Empty ( ) ) ) { if ( ( stream One == null ) || ( stream One . is Empty ( ) ) ) { return ; } result List . add All ( stream One ) ; return ; } if ( ( stream One == null ) || ( stream One . is Empty ( ) ) ) { result List . add All ( stream Two ) ; return ; } int stream One Size = stream One . size ( ) ; int stream Two Size = stream Two . size ( ) ; if ( stream One Size == NUM ) { copy To Each ( sub Stream Nums One , stream One . get ( NUM ) , stream Two ) ; result List . add All ( stream Two ) ; return ; } if ( stream Two Size == NUM ) { copy To Each ( sub Stream Nums Two , stream Two . get ( NUM ) , stream One ) ; result List . add All ( stream One ) ; return ; } if ( stream Two Size > stream One Size ) { List < Event Bean [ ] > hold Rows = stream One ; int hold Size = stream One Size ; stream One = stream Two ; stream One Size = stream Two Size ; stream Two = hold Rows ; stream Two Size = hold Size ; sub Stream Nums Two = sub Stream Nums One ; } int cartesian Total Rows = stream One Size * stream Two Size ; int num Columns = stream One . get ( NUM ) . length ; Event Bean [ ] [ ] results = new Event Bean [ cartesian Total Rows ] [ ] ; int stream One Count = NUM ; for ( Event Bean [ ] row : stream One ) { results [ stream One Count ] = row ; for ( int i = NUM ; i < stream Two Size ; i ++ ) { Event Bean [ ] dup Row = new Event Bean [ num Columns ] ; System . arraycopy ( row , NUM , dup Row , NUM , num Columns ) ; int index = stream One Size * i + stream One Count ; results [ index ] = dup Row ; } stream One Count ++ ; } int stream Two Count = NUM ; for ( Event Bean [ ] row : stream Two ) { for ( int i = NUM ; i < stream One Size ; i ++ ) { int index = stream Two Count * stream One Size + i ; copy ( sub Stream Nums Two , row , results [ index ] ) ; } stream Two Count ++ ; } result List . add All ( Arrays . as List ( results ) ) ; }
private static Kdb Group deserialize Group ( Kdb Group last Group , Data Input data Input ) throws IO Exception { int field Type ; Kdb Group group = new Kdb Group ( ) ; while ( ( field Type = data Input . read Unsigned Short ( ) ) != NUM ) { switch ( field Type ) { case NUM : read Ext Data ( data Input ) ; break ; case NUM : UUID uuid = new UUID ( NUM , read Int ( data Input ) ) ; group . set Uuid ( uuid ) ; break ; case NUM : group . set Name ( read String ( data Input ) ) ; break ; case NUM : group . set Creation Time ( read Date ( data Input ) ) ; break ; case NUM : group . set Last Modification Time ( read Date ( data Input ) ) ; break ; case NUM : group . set Last Access Time ( read Date ( data Input ) ) ; break ; case NUM : group . set Expiry Time ( read Date ( data Input ) ) ; break ; case NUM : group . set Icon ( new Kdb Icon ( read Int ( data Input ) ) ) ; break ; case NUM : int level = read Short ( data Input ) ; group . set Parent ( compute Parent Group ( last Group , level ) ) ; break ; case NUM : group . set Flags ( read Int ( data Input ) ) ; break ; default : throw new Illegal State Exception ( STRING ) ; } } data Input . read Int ( ) ; return group ; }
private Diff Part decode Replace ( final int block Size S , final int block Size E , final int block Size L ) throws Unsupported Encoding Exception , Decoding Exception { if ( block Size S < NUM || block Size E < NUM || block Size L < NUM ) { throw new Decoding Exception ( STRING + block Size S + STRING + block Size E + STRING + block Size L ) ; } int s = r . read ( block Size S ) ; int e = r . read ( block Size E ) ; int l = r . read ( block Size L ) ; Byte Array Output Stream output = new Byte Array Output Stream ( ) ; for ( int i = NUM ; i < l ; i ++ ) { output . write ( r . read Byte ( ) ) ; } Diff Part part = new Diff Part ( Diff Action . REPLACE ) ; part . set Start ( s ) ; part . set Length ( e ) ; part . set Text ( output . to String ( WIKIPEDIA ENCODING ) ) ; return part ; }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; } else { return BOOL ; } } return BOOL ; }
public void flush ( ) throws IO Exception { ensure Open ( ) ; if ( ! inf . finished ( ) ) { try { while ( ! inf . finished ( ) && ! inf . needs Input ( ) ) { int n ; n = inf . inflate ( buf , NUM , buf . length ) ; if ( n < NUM ) { break ; } out . write ( buf , NUM , n ) ; } super . flush ( ) ; } catch ( Data Format Exception ex ) { String msg = ex . get Message ( ) ; if ( msg == null ) { msg = STRING ; } throw new Zip Exception ( msg ) ; } } }
@ Override public String to String ( ) { if ( m Handler != null ) return m File . get Absolute Path ( ) + STRING + Utils . to Command Line ( m Handler ) ; else return m File . get Absolute Path ( ) + STRING ; }
public final void go To Last Page ( ) { view Pager . set Current Item ( pages . size ( ) - NUM ) ; }
public List < Class < ? > > parameter List ( ) { return Collections . unmodifiable List ( Arrays . as List ( ptypes . clone ( ) ) ) ; }
private static void add Rules ( List < String > batch List , List < Rule > rules To Add ) { String add Statement = STRING + RULES TABLE + STRING + STRING + STRING + STRING + STRING ; for ( Rule rule : rules To Add ) { batch List . add ( String . format ( add Statement , rule . get Name ( ) , rule . get Description ( ) , rule . get Membership Rule ( ) ) ) ; } }
private synchronized void perform ( ) { if ( done ) return ; while ( my Elements . has Next ( ) ) { Object element = my Elements . next ( ) ; if ( ! is Visited ( element ) ) { visit ( element , NUM ) ; } } }
public void publish ( AWS Iot Message message ) throws AWS Iot Exception { try { publish Message ( message ) ; } catch ( Aws Iot Retryable Exception e ) { if ( client . get Max Offline Queue Size ( ) > NUM && publish Queue . size ( ) < client . get Max Offline Queue Size ( ) ) { publish Queue . add ( message ) ; } else { LOGGER . info ( STRING + message . get Topic ( ) ) ; throw new AWS Iot Exception ( e ) ; } } }
public static < T > Completable Future < T > exceptional Future ( Throwable t ) { Completable Future < T > future = new Completable Future < > ( ) ; future . complete Exceptionally ( t ) ; return future ; }
protected void update Numeric Scores ( double [ ] predicted , double [ ] actual , double weight ) { double diff ; double sum Err = NUM , sum Abs Err = NUM , sum Sqr Err = NUM ; double sum Prior Abs Err = NUM , sum Prior Sqr Err = NUM ; for ( int i = NUM ; i < m Num Classes ; i ++ ) { diff = predicted [ i ] - actual [ i ] ; sum Err += diff ; sum Abs Err += Math . abs ( diff ) ; sum Sqr Err += diff * diff ; diff = ( m Class Priors [ i ] / m Class Priors Sum ) - actual [ i ] ; sum Prior Abs Err += Math . abs ( diff ) ; sum Prior Sqr Err += diff * diff ; } m Sum Err += weight * sum Err / m Num Classes ; m Sum Abs Err += weight * sum Abs Err / m Num Classes ; m Sum Sqr Err += weight * sum Sqr Err / m Num Classes ; m Sum Prior Abs Err += weight * sum Prior Abs Err / m Num Classes ; m Sum Prior Sqr Err += weight * sum Prior Sqr Err / m Num Classes ; }
public boolean check Modifiers ( Mouse Event e ) { return ( e . get Modifiers ( ) & modifiers ) != NUM ; }
void output Variables ( List < Var Holder > vars ) { boolean first = BOOL ; for ( Var Holder vh : vars ) { if ( vh . name != null ) { if ( first ) { gen . out ( STRING , vh . name ) ; first = BOOL ; } else { gen . out ( STRING , vh . name ) ; } } else if ( vh . destr != null && vh . vars != null ) { for ( Tree . Variable v : vh . vars ) { final String vname = names . name ( v . get Declaration Model ( ) ) ; if ( first ) { gen . out ( STRING , vname ) ; first = BOOL ; } else { gen . out ( STRING , vname ) ; } } } } if ( ! first ) { gen . end Line ( BOOL ) ; } }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N , Buffered Writer out ) throws IO Exception { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = NUM ; k <= top N ; k ++ ) { String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public static List < ? extends Block Object > fetch ( Db Client db Client , List < URI > block UR Is ) { List < ? extends Block Object > block Objects = null ; if ( URI Util . is Type ( block UR Is . get ( NUM ) , Volume . class ) ) { block Objects = db Client . query Object ( Volume . class , block UR Is ) ; } else if ( URI Util . is Type ( block UR Is . get ( NUM ) , Block Snapshot . class ) ) { block Objects = db Client . query Object ( Block Snapshot . class , block UR Is ) ; } else if ( URI Util . is Type ( block UR Is . get ( NUM ) , Block Mirror . class ) ) { block Objects = db Client . query Object ( Block Mirror . class , block UR Is ) ; } return block Objects ; }
private List < File Descriptor > prepare File Descriptors ( List < File Share > filesystems , Virtual Pool Capability Values Wrapper cos Capabilities , String suggested Id ) { final List < File Descriptor > file Descriptors = new Array List < File Descriptor > ( ) ; for ( File Share filesystem : filesystems ) { File Descriptor desc = new File Descriptor ( File Descriptor . Type . FILE DATA , filesystem . get Storage Device ( ) , filesystem . get Id ( ) , filesystem . get Pool ( ) , filesystem . get Capacity ( ) , cos Capabilities , null , suggested Id ) ; file Descriptors . add ( desc ) ; } return file Descriptors ; }
private String strip Tags ( String string ) { return string . replace All ( STRING , STRING ) ; }
public static double regularized Inc Beta ( double x , double alpha , double beta ) { if ( alpha <= NUM || beta <= NUM || Double . is Na N ( alpha ) || Double . is Na N ( beta ) || Double . is Na N ( x ) ) { return Double . Na N ; } if ( x <= NUM ) { return NUM ; } if ( x >= NUM ) { return NUM ; } if ( alpha > SWITCH && beta > SWITCH ) { return regularized Inc Beta Quadrature ( alpha , beta , x ) ; } double bt = Math . exp ( - log Beta ( alpha , beta ) + alpha * Math . log ( x ) + beta * Math . log 1 p ( - x ) ) ; if ( x < ( alpha + NUM ) / ( alpha + beta + NUM ) ) { return bt * regularized Inc Beta CF ( alpha , beta , x ) / alpha ; } else { return NUM - bt * regularized Inc Beta CF ( beta , alpha , NUM - x ) / beta ; } }
@ Override public DSS Document sign Document ( final byte [ ] signature Value ) throws DSS Exception { if ( ! built ) { build ( ) ; } final Encryption Algorithm encryption Algorithm = params . get Encryption Algorithm ( ) ; final byte [ ] signature Value Bytes = DSS Signature Utils . convert To Xml D Sig ( encryption Algorithm , signature Value ) ; final String signature Value Base 64 Encoded = Base 64 . encode Base 64 String ( signature Value Bytes ) ; final Text signature Value Node = document Dom . create Text Node ( signature Value Base 64 Encoded ) ; signature Value Dom . append Child ( signature Value Node ) ; byte [ ] document Bytes = DSSXML Utils . transform Dom To Byte Array ( document Dom ) ; final In Memory Document in Memory Document = new In Memory Document ( document Bytes ) ; in Memory Document . set Mime Type ( Mime Type . XML ) ; return in Memory Document ; }
private static Grid Uri Deployment File Processor Result process No Descriptor File ( File file , String uri , Ignite Logger log ) throws Ignite Spi Exception { Class Loader cls Ldr = Grid Uri Deployment Class Loader Factory . create ( U . grid Class Loader ( ) , file , log ) ; Set < Class < ? extends Compute Task < ? , ? > > > clss = Grid Uri Deployment Discovery . get Classes ( cls Ldr , file ) ; Grid Uri Deployment File Processor Result res = new Grid Uri Deployment File Processor Result ( ) ; res . set File ( file ) ; res . set Class Loader ( cls Ldr ) ; if ( clss != null ) { List < Class < ? extends Compute Task < ? , ? > > > valid Tasks = new Array List < > ( clss . size ( ) ) ; for ( Class < ? extends Compute Task < ? , ? > > cls : clss ) { if ( is Allowed Task Class ( cls ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + cls . get Name ( ) ) ; valid Tasks . add ( cls ) ; } } if ( ! valid Tasks . is Empty ( ) ) res . set Task Classes ( valid Tasks ) ; else if ( log . is Debug Enabled ( ) ) log . debug ( STRING + file . get Absolute Path ( ) + STRING + U . hide Password ( uri ) + STRING ) ; } return res ; }
public void test Get Servlet Run As Role ( ) throws Exception { String xml = WEBAPP TEST HEADER + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; String role Name = Web Xml Utils . get Servlet Run As Role Name ( web Xml , STRING ) ; assert Equals ( STRING , role Name ) ; }
public Date Time Formatter Builder append Text ( Temporal Field field , Text Style text Style ) { Objects . require Non Null ( field , STRING ) ; Objects . require Non Null ( text Style , STRING ) ; append Internal ( new Text Printer Parser ( field , text Style , Date Time Text Provider . get Instance ( ) ) ) ; return this ; }
public static void print ( Object message ) { if ( ! is Disabled ( ) ) { print ( String . value Of ( message ) ) ; } }
public static String remove Invalid XML Chars ( String text ) { if ( text == null || text . is Empty ( ) ) { return text ; } return text . replace All ( INVALID XML CHARACTERS , STRING ) ; }
void acc expand ( ) { int len = digits . length ; int old Ones [ ] = digits ; digits = new int [ len + NUM ] ; System . arraycopy ( old Ones , NUM , digits , NUM , len ) ; }
@ Suppress Warnings ( STRING ) private < T > T allow Static Access To Member ( T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; is Static = Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof List ) { List < Method Node > list = ( List < Method Node > ) member ; if ( list . size ( ) == NUM ) { return ( T ) Collections . singleton List ( allow Static Access To Member ( list . get ( NUM ) , static Only ) ) ; } return ( T ) Collections . empty List ( ) ; } else { Method Node mn = ( Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
public static String date To String ( Date date ) { Simple Date Format formatter = new Simple Date Format ( ISO DATE FORMAT ) ; formatter . set Time Zone ( Time Zone . get Time Zone ( STRING ) ) ; return formatter . format ( date ) ; }
public KMZ Writer ( final String out Filename ) { log . set Level ( Level . INFO ) ; String filename = out Filename ; if ( filename . ends With ( STRING ) || filename . ends With ( STRING ) ) { filename = filename . substring ( NUM , filename . length ( ) - NUM ) ; } try { this . zip Out = new Zip Output Stream ( new File Output Stream ( filename + STRING ) ) ; this . out = new Buffered Writer ( new Output Stream Writer ( this . zip Out , STRING ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } Kml Type doc KML = kml Object Factory . create Kml Type ( ) ; Network Link Type nl = kml Object Factory . create Network Link Type ( ) ; Link Type link = kml Object Factory . create Link Type ( ) ; link . set Href ( STRING ) ; nl . set Link ( link ) ; doc KML . set Abstract Feature Group ( kml Object Factory . create Network Link ( nl ) ) ; write Kml ( STRING , doc KML ) ; }
private String move To Folder ( final String file , final String folder ) { final File source = new File ( file ) ; final File destination = new File ( folder + File . separator + source . get Name ( ) ) ; Log . i ( TAG , file + STRING + destination . get Absolute Path ( ) ) ; try { File Utils . move File ( source , destination ) ; } catch ( final IO Exception e ) { Log . e ( TAG , STRING ) ; } return destination . get Absolute Path ( ) ; }
public Model Importer Visual Panel 3 ( Model Importer Wizard Panel 3 panel ) { init Components ( ) ; this . panel = panel ; off Panel = new Off Scene Panel ( NUM , NUM ) ; j Panel 1 . add ( off Panel ) ; }
private static String as Http Date ( long date ) { Simple Date Format date Format = new Simple Date Format ( STRING , Locale . US ) ; return date Format . format ( new Date ( date ) ) ; }
public Aem Sidekick click Mode Icon ( Mode Icon icon Name ) { final String xpath = String . format ( ICON BOTTOM XPATH , icon Name . get Icon Name ( ) ) ; final Web Element icon Bottom = driver . find Element ( By . xpath ( xpath ) ) ; icon Bottom . click ( ) ; return this ; }
private void ping Client ( String to Token , String sender Token ) { Client sender Client ; if ( to Token . equals ( SENDER ID + STRING + Gcm Server . GCM HOST ) ) { sender Client = client Map . get ( to Token ) ; to Token = sender Token ; } else { sender Client = client Map . get ( sender Token ) ; } Json Object j Ping = new Json Object ( ) ; Json Object j Data = new Json Object ( ) ; j Data . add Property ( ACTION KEY , PING CLIENT ) ; j Data . add Property ( SENDER KEY , sender Client . registration Token ) ; Json Object j Notification = new Json Object ( ) ; j Notification . add Property ( STRING , sender Client . name + STRING ) ; j Notification . add Property ( STRING , PING TITLE ) ; j Notification . add Property ( STRING , PING ICON ) ; j Notification . add Property ( STRING , STRING ) ; j Notification . add Property ( STRING , CLICK ACTION ) ; j Ping . add ( DATA KEY , j Data ) ; j Ping . add ( STRING , j Notification ) ; friendly Gcm Server . send ( to Token , j Ping ) ; }
@ Override public synchronized void parse ( Input Stream in , String base URI ) throws IO Exception , RDF Parse Exception , RDF Handler Exception { if ( in == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( base URI == null ) { throw new Illegal Argument Exception ( STRING ) ; } Input Source input Source = new Input Source ( new BOM Input Stream ( in , BOOL ) ) ; input Source . set System Id ( base URI ) ; parse ( input Source ) ; }
public static Date parse Date ( String date Value , Collection date Formats , Date start Date ) throws Date Parse Exception { if ( date Value == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( date Formats == null ) { date Formats = DEFAULT PATTERNS ; } if ( start Date == null ) { start Date = DEFAULT TWO DIGIT YEAR START ; } if ( date Value . length ( ) > NUM && date Value . starts With ( STRING ) && date Value . ends With ( STRING ) ) { date Value = date Value . substring ( NUM , date Value . length ( ) - NUM ) ; } Simple Date Format date Parser = null ; final Iterator format Iter = date Formats . iterator ( ) ; while ( format Iter . has Next ( ) ) { final String format = ( String ) format Iter . next ( ) ; if ( date Parser == null ) { date Parser = new Simple Date Format ( format , Locale . US ) ; date Parser . set Time Zone ( Time Zone . get Time Zone ( STRING ) ) ; date Parser . set 2 Digit Year Start ( start Date ) ; } else { date Parser . apply Pattern ( format ) ; } try { return date Parser . parse ( date Value ) ; } catch ( final Parse Exception pe ) { } } throw new Date Parse Exception ( STRING + date Value ) ; }
public Json Object remove ( String name ) { if ( name == null ) { throw new Null Pointer Exception ( STRING ) ; } int index = index Of ( name ) ; if ( index != - NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
private static List < Block Node > clean Successors ( Block Node block ) { List < Block Node > suc List = block . get Successors ( ) ; if ( suc List . is Empty ( ) ) { return suc List ; } List < Block Node > to Remove = new Linked List < Block Node > ( ) ; for ( Block Node b : suc List ) { if ( Block Utils . is Block Must Be Cleared ( b ) ) { to Remove . add ( b ) ; } } if ( block . contains ( A Flag . LOOP END ) ) { List < Loop Info > loops = block . get All ( A Type . LOOP ) ; for ( Loop Info loop : loops ) { to Remove . add ( loop . get Start ( ) ) ; } } Ignore Edge Attr ignore Edge Attr = block . get ( A Type . IGNORE EDGE ) ; if ( ignore Edge Attr != null ) { to Remove . add All ( ignore Edge Attr . get Blocks ( ) ) ; } if ( to Remove . is Empty ( ) ) { return suc List ; } List < Block Node > result = new Array List < Block Node > ( suc List ) ; result . remove All ( to Remove ) ; return result ; }
private Load Offset Field Type infer Record Address Type ( String record String ) { if ( record String . char At ( NUM ) != LEADING CHAR RECORD MARK ) { log . error ( STRING + line Num + STRING ) ; return Load Offset Field Type . ADDRESSFIELDSIZEUNKNOWN ; } String r = record String . substring ( CHARS IN RECORD MARK ) ; int len = r . length ( ) ; if ( ( ( len + NUM ) / NUM ) != ( len / NUM ) ) { log . error ( STRING + line Num + STRING + STRING ) ; return Load Offset Field Type . ADDRESSFIELDSIZEUNKNOWN ; } int datalen = Integer . parse Int ( r . substring ( NUM , NUM ) , NUM ) ; int checksum In Record = Integer . parse Int ( r . substring ( len - NUM , len ) , NUM ) ; int calculated Checksum = calculate 8 Bit Checksum ( record String . substring ( CHARS IN RECORD MARK , record String . length ( ) - CHARS IN CHECKSUM ) ) ; if ( calculated Checksum != checksum In Record ) { log . error ( STRING + line Num + STRING + Integer . to Hex String ( calculated Checksum ) + STRING + Integer . to Hex String ( checksum In Record ) + STRING ) ; return Load Offset Field Type . ADDRESSFIELDSIZEUNKNOWN ; } int computed Len If 16 Bit = NUM + NUM + NUM + ( datalen * NUM ) + NUM ; int computed Len If 24 Bit = computed Len If 16 Bit + NUM ; if ( computed Len If 16 Bit == len ) { if ( is Supported Record Type ( Integer . parse Int ( r . substring ( NUM , NUM ) , NUM ) ) ) { return Load Offset Field Type . ADDRESSFIELDSIZE 16 BITS ; } else { log . error ( STRING + line Num + STRING + STRING ) ; return Load Offset Field Type . ADDRESSFIELDSIZEUNKNOWN ; } } if ( computed Len If 24 Bit == len ) { if ( is Supported Record Type ( Integer . parse Int ( r . substring ( NUM , NUM ) , NUM ) ) ) { return Load Offset Field Type . ADDRESSFIELDSIZE 24 BITS ; } else { log . error ( STRING + line Num + STRING ) ; return Load Offset Field Type . ADDRESSFIELDSIZEUNKNOWN ; } } return Load Offset Field Type . ADDRESSFIELDSIZEUNKNOWN ; }
private void print Err Line ( int pos , Print Writer writer ) { String line = ( source == null ? null : source . get Line ( pos ) ) ; if ( line == null ) return ; int col = source . get Column Number ( pos , BOOL ) ; print Raw Lines ( writer , line ) ; for ( int i = NUM ; i < col - NUM ; i ++ ) { writer . print ( ( line . char At ( i ) == STRING ) ? STRING : STRING ) ; } writer . println ( STRING ) ; writer . flush ( ) ; }
private J Check Box Menu Item create Check Item ( Container c , String txt , boolean selected , String setting ) { Settings s = new Settings ( gui . Main Window . GUI NS ) ; J Check Box Menu Item i = new J Check Box Menu Item ( txt ) ; if ( setting == null ) { i . set Selected ( selected ) ; } else { i . set Selected ( s . get Boolean ( setting , selected ) ) ; } i . add Action Listener ( this ) ; c . add ( i ) ; return i ; }
public String multi Line ( int col ) { String val = STRING + wf ; if ( sf == null ) { return val ; } return val + STRING + N Spaces ( col ) + STRING + sf ; }
public void world To Spherical ( Vector 3 vec ) { if ( pj Unprojected == null ) { String proj Str = STRING + proj Info . get Semi Major Axis ( ) + STRING + proj Info . get Semi Minor Axis ( ) + STRING ; pj Unprojected = Proj 4 . new Instance ( proj Str ) ; } if ( pj Projected == null ) { pj Projected = Proj 4 . new Instance ( proj 4 String ) ; } try { vec . to Array ( coord ) ; pj Projected . transform ( pj Unprojected , coord ) ; vec . set X ( Math . to Degrees ( coord [ NUM ] ) ) ; vec . set Y ( Math . to Degrees ( coord [ NUM ] ) ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public static byte [ ] encode String With Hyphen ( final String str ) { return Dna Utils . encode String ( str . replace ( STRING , STRING ) ) ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { if ( img == null ) { return BOOL ; } m Drawing Area . add Infinite ( ) ; m Print Metrics . draw Image ( this , img ) ; return m Graphics . draw Image ( img , xform , obs ) ; }
static public Interest Rate implied Rate ( final double c , final double time , final Day Counter result DC , final Compounding comp , final Frequency freq ) { final double t = time ; final double f = freq . to Integer ( ) ; QL . require ( c > NUM , STRING ) ; QL . require ( t > NUM , STRING ) ; double rate ; switch ( comp ) { case Simple : rate = ( c - NUM ) / t ; break ; case Compounded : rate = ( Math . pow ( c , ( NUM / ( f * t ) ) ) - NUM ) * f ; break ; case Continuous : rate = Math . log ( c ) / t ; break ; case Simple Then Compounded : if ( t <= ( NUM / f ) ) { rate = ( c - NUM ) / t ; } else { rate = ( Math . pow ( c , ( NUM / ( f * t ) ) ) - NUM ) * f ; } break ; default : throw new Library Exception ( STRING ) ; } return new Interest Rate ( rate , result DC , comp , freq ) ; }
protected void load Schemas ( File [ ] files ) { for ( File file : files ) { File Reader file Reader = null ; Buffered Reader reader = null ; try { file Reader = new File Reader ( file ) ; reader = new Buffered Reader ( file Reader ) ; load Schema From Reader ( reader ) ; } catch ( IO Exception exception ) { log . warn ( STRING , exception ) ; } finally { try { if ( reader != null ) { reader . close ( ) ; } if ( file Reader != null ) { file Reader . close ( ) ; } } catch ( IO Exception exception ) { log . warn ( STRING , exception ) ; } } } }
@ Override public void add Property Change Listener ( String property Name , Property Change Listener listener ) { property Change Support . add Property Change Listener ( property Name , listener ) ; }
public File create New Folder ( File containing Dir ) throws IO Exception { if ( containing Dir == null ) { throw new IO Exception ( STRING ) ; } File new Folder ; new Folder = create File Object ( containing Dir , new Folder String ) ; int i = NUM ; while ( new Folder . exists ( ) && i < NUM ) { new Folder = create File Object ( containing Dir , Message Format . format ( new Folder Next String , new Integer ( i ) ) ) ; i ++ ; } if ( new Folder . exists ( ) ) { throw new IO Exception ( STRING + new Folder . get Absolute Path ( ) ) ; } else { new Folder . mkdirs ( ) ; } return new Folder ; }
public Resources Poet add String Array ( String name , @ Not Null List < String > values ) { Element element = document . create Element ( STRING ) ; element . set Attribute ( STRING , name ) ; for ( String value : values ) { Element value Element = document . create Element ( STRING ) ; value Element . append Child ( document . create Text Node ( value ) ) ; element . append Child ( value Element ) ; } resource Element . append Child ( element ) ; return this ; }
public void add Syntax Actions ( Keymap map , String prefix ) { Pattern splitter = CONFIG . get Value Separator ( prefix ) ; Configuration actions Conf = CONFIG . sub Config ( prefix , STRING ) ; for ( String action Name : actions Conf . string Property Names ( ) ) { String [ ] values = splitter . split ( actions Conf . get Property ( action Name ) ) ; String action Class = values [ NUM ] ; Syntax Action action = editor Actions . get ( action Class ) ; if ( action == null ) { action = create Action ( action Class ) ; action . config ( CONFIG , prefix , action Name ) ; } String key Stroke String = values [ NUM ] ; Key Stroke ks = Key Stroke . get Key Stroke ( key Stroke String ) ; if ( ks == null ) { throw new Illegal Argument Exception ( STRING + key Stroke String ) ; } Text Action ta = action . get Action ( action Name ) ; if ( ta == null ) { throw new Illegal Argument Exception ( STRING + action Name ) ; } map . add Action For Key Stroke ( ks , ta ) ; } }
void fill Delta Entries ( Set < Page Leaf Entry > entries , Row row , int tail ) { int row Offset = row Head ; byte [ ] buffer = buffer ; while ( row Offset < tail ) { int code = buffer [ row Offset ] & CODE MASK ; int len = get Length ( code , row ) ; if ( code == INSERT || code == REMOVE ) { Page Leaf Entry entry = new Page Leaf Entry ( this , row , row Offset , len , code ) ; entries . add ( entry ) ; } row Offset += len ; } }
private static boolean are Equal ( int from Index , Char Sequence left , Char Sequence right ) { if ( left == right ) return BOOL ; if ( ( left == null ) || ( right == null ) ) return BOOL ; int n = left . length ( ) ; if ( right . length ( ) != n ) return BOOL ; for ( int i = n ; i > from Index ; ) { if ( left . char At ( -- i ) != right . char At ( i ) ) return BOOL ; } return BOOL ; }
private void log Descriptors ( List < Volume Descriptor > descriptors ) { String Buffer buf = new String Buffer ( ) ; buf . append ( String . format ( NEW LINE ) ) ; buf . append ( String . format ( STRING ) ) ; for ( Volume Descriptor desc : descriptors ) { Volume volume = db Client . query Object ( Volume . class , desc . get Volume URI ( ) ) ; buf . append ( String . format ( STRING , volume . get Label ( ) , desc . get Type ( ) , desc . to String ( ) ) ) ; } buf . append ( String . format ( NEW LINE ) ) ; log . info ( buf . to String ( ) ) ; }
private List < Inactive Image Descriptor > filter Inactive Images ( final State current , final List < Inactive Image Descriptor > inactive Images , final Map < String , Image Service . State > reference Images ) { List < Inactive Image Descriptor > images To Delete = new Linked List < > ( ) ; for ( Inactive Image Descriptor image : inactive Images ) { Image Service . State reference Image = reference Images . get ( image . get Image id ( ) ) ; Service Utils . log Info ( this , Utils . to Json ( BOOL , BOOL , reference Image ) ) ; if ( image . get Timestamp ( ) > current . image Create Watermark Time || image . get Timestamp ( ) > current . image Delete Watermark Time ) { continue ; } if ( null != reference Image ) { if ( reference Image . state == Image State . PENDING DELETE ) { images To Delete . add ( image ) ; continue ; } if ( reference Image . replication Type == Image Replication Type . EAGER || current . is Image Datastore ) { continue ; } } images To Delete . add ( image ) ; } return images To Delete ; }
public Sequence Resource ( String mimetype , Resource ... resources ) { this ( mimetype , Arrays . as List ( resources ) ) ; }
public static Arguments parse Args ( final String args ) { Map < String , String > parsed = new Hash Map < > ( ) ; for ( String arg Pair : args . split ( STRING ) ) { String [ ] tokens = arg Pair . split ( STRING ) ; if ( tokens . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } parsed . put ( tokens [ NUM ] , tokens [ NUM ] ) ; } for ( String required Arg : REQUIRED ) { if ( ! parsed . contains Key ( required Arg ) ) { throw new Illegal Argument Exception ( String . format ( STRING , required Arg ) ) ; } } return new Arguments ( parsed ) ; }
public static byte [ ] iv Cipher Concat ( byte [ ] iv , byte [ ] cipher Text ) { byte [ ] combined = new byte [ iv . length + cipher Text . length ] ; System . arraycopy ( iv , NUM , combined , NUM , iv . length ) ; System . arraycopy ( cipher Text , NUM , combined , iv . length , cipher Text . length ) ; return combined ; }
private double lin To Mel Freq ( double input Freq ) { return ( NUM * ( Math . log ( NUM + input Freq / NUM ) / Math . log ( NUM ) ) ) ; }
private int add Labels Internal ( GL 10 gl , Paint text Paint , boolean draw To Canvas , Label Data [ ] labels ) { int u = NUM ; int v = NUM ; int line Height = NUM ; for ( Label Data label : labels ) { int ascent = NUM ; int descent = NUM ; int measured Text Width = NUM ; int height = NUM ; int width = NUM ; int font Size = label . get Font Size ( ) ; do { text Paint . set Color ( NUM | label . get Color ( ) ) ; text Paint . set Text Size ( font Size * m Res . get Display Metrics ( ) . density ) ; ascent = ( int ) Math . ceil ( - text Paint . ascent ( ) ) ; descent = ( int ) Math . ceil ( text Paint . descent ( ) ) ; measured Text Width = ( int ) Math . ceil ( text Paint . measure Text ( label . get Text ( ) ) ) ; height = ascent + descent ; width = measured Text Width ; font Size -- ; } while ( font Size > NUM && width > m Res . get Display Metrics ( ) . width Pixels ) ; int next U ; if ( u + width > m Strike Width ) { u = NUM ; next U = width ; v += line Height ; line Height = NUM ; } else { next U = u + width ; } line Height = Math . max ( line Height , height ) ; if ( v + line Height > m Strike Height && draw To Canvas ) { throw new Illegal Argument Exception ( STRING ) ; } int v Base = v + ascent ; if ( draw To Canvas ) { m Canvas . draw Text ( label . get Text ( ) , u , v Base , text Paint ) ; label . set Texture Data ( width , height , u , v + height , width , - height , m Texel Width , m Texel Height ) ; } u = next U ; } return v + line Height ; }
public static byte [ ] random Bytes ( int length ) { byte [ ] bytes = new byte [ length ] ; SEEDED RANDOM . next Bytes ( bytes ) ; return bytes ; }
@ Override public String to String ( ) { String Buffer Bf String = new String Buffer ( ) ; Bf String . append ( STRING ) ; if ( m starting == null ) { Bf String . append ( STRING ) ; } else { Bf String . append ( start Set To String ( ) + STRING ) ; } Bf String . append ( STRING ) ; if ( m search Direction == SELECTION BACKWARD ) { Bf String . append ( STRING ) ; } else { if ( m search Direction == SELECTION FORWARD ) { Bf String . append ( STRING ) ; } else { Bf String . append ( STRING ) ; } } Bf String . append ( STRING + m max Stale + STRING ) ; Bf String . append ( STRING + m total Evals + STRING ) ; Bf String . append ( STRING + Utils . double To String ( Math . abs ( m best Merit ) , NUM , NUM ) + STRING ) ; return Bf String . to String ( ) ; }
public synchronized void return Buf ( byte [ ] buf ) { if ( buf == null || buf . length > m Size Limit ) { return ; } m Buffers By Last Use . add ( buf ) ; int pos = Collections . binary Search ( m Buffers By Size , buf , BUF COMPARATOR ) ; if ( pos < NUM ) { pos = - pos - NUM ; } m Buffers By Size . add ( pos , buf ) ; m Current Size += buf . length ; trim ( ) ; }
public Session store ( ) { long expired = Global . get Long ( STRING , X . AWEEK ) ; if ( expired > NUM ) { expired = System . current Time Millis ( ) + expired ; } else { expired = - NUM ; } return store ( expired ) ; }
private void deselect ( int position , Iterator < Integer > entries ) { Item item = get Item ( position ) ; if ( item != null ) { item . with Set Selected ( BOOL ) ; } if ( entries == null ) { if ( m Position Based State Management ) { if ( m Selections . contains ( position ) ) { m Selections . remove ( position ) ; } } } else { entries . remove ( ) ; } notify Item Changed ( position ) ; if ( m Selection Listener != null ) m Selection Listener . on Selection Changed ( item , BOOL ) ; }
public Big Decimal invoke ( M Depreciation Workfile assetwk , M Asset Acct asset Acct , int A Current Period , Big Decimal Accum Dep ) { String depreciation Type = get Depreciation Type ( ) ; Big Decimal ret Value = null ; if ( C Log Mgt . is Level Finest ( ) ) { log . fine ( STRING + depreciation Type + STRING + assetwk + STRING + asset Acct + STRING + A Current Period + STRING + Accum Dep ) ; } if ( ! can Invoke ( assetwk , asset Acct , A Current Period , Accum Dep ) ) { return Big Decimal . ZERO ; } if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply SL ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH VAR ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH AD 1 ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH AD 2 ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH ZERO ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else { throw new Asset Not Supported Exception ( COLUMNNAME Depreciation Type , depreciation Type ) ; } if ( ret Value == null ) { ret Value = Big Decimal . ZERO ; } ret Value = ret Value . set Scale ( get Precision ( ) , Rounding Mode . HALF UP ) ; if ( C Log Mgt . is Level Finest ( ) ) log . fine ( STRING + ret Value ) ; return ret Value ; }
public Tree Map < Float , List < List < Integer > > > pack First Fit Shuffled ( ) { Random Data Generator rnd = new Random Data Generator ( ) ; int [ ] permutation = rnd . next Permutation ( items . size ( ) , items . size ( ) ) ; List < Integer > shuffled Items = new Array List < Integer > ( items . size ( ) ) ; List < Float > shuffled Weights = new Array List < Float > ( items . size ( ) ) ; for ( int ix : permutation ) { shuffled Items . add ( items . get ( ix ) ) ; shuffled Weights . add ( item Weights . get ( ix ) ) ; } return pack First Fit ( shuffled Items , shuffled Weights ) ; }
public void add Notify ( ) { super . add Notify ( ) ; text Area . add Caret Listener ( listener ) ; text Area . add Property Change Listener ( R Syntax Text Area . PARSER NOTICES PROPERTY , listener ) ; text Area . add Property Change Listener ( R Syntax Text Area . MARK OCCURRENCES PROPERTY , listener ) ; text Area . add Property Change Listener ( R Syntax Text Area . MARKED OCCURRENCES CHANGED PROPERTY , listener ) ; refresh Markers ( ) ; }
@ Override public Iterator < Cube > iterator ( ) { return cubes . iterator ( ) ; }
private boolean ends With Space ( String str ) { return str . length ( ) != NUM && str . char At ( str . length ( ) - NUM ) == STRING ; }
private boolean key Match ( String key , Lazy Node token ) { if ( token . type == Lazy Node . EFIELD ) { String field = token . get String Value ( cbuf ) ; return field . equals ( key ) ; } else { int length = key . length ( ) ; if ( token . end Index - token . start Index != length ) { return BOOL ; } for ( int i = NUM ; i < length ; i ++ ) { char c = key . char At ( i ) ; if ( c != cbuf [ token . start Index + i ] ) { return BOOL ; } } return BOOL ; } }
public boolean mouse Pressed ( Mouse Event e ) { if ( show plot && graph != null ) { int x = e . get X ( ) ; int y = e . get Y ( ) ; if ( ( x >= plot X ) && ( x <= plot X + plot Width ) && ( y >= plot Y ) && ( y <= plot Y + plot Width ) ) { grabbed plot graphics = BOOL ; prev X = x ; prev Y = y ; } } return BOOL ; }
public void load ( General Names general Names ) { General Name [ ] general Names Array = general Names . get Names ( ) ; data = new Array List < General Name > ( Arrays . as List ( general Names Array ) ) ; Collections . sort ( data , new General Name Comparator ( ) ) ; fire Table Data Changed ( ) ; }
public static boolean is In Disabled List ( String classname ) { return DISABLED . contains ( classname ) ; }
public static void append To File ( final File file , final String contents ) throws IO Exception { try ( File Output Stream fos = new File Output Stream ( file , BOOL ) ) { fos . write ( contents . get Bytes ( ) ) ; } }
public void put ( String key , Array List < String > value ) { Iterator < Pair < String , Array List < String > > > it = store . iterator ( ) ; while ( it . has Next ( ) ) { Pair < String , Array List < String > > pair = it . next ( ) ; if ( key . equals ( pair . first ) ) { pair . second = value ; return ; } } store . add ( new Pair < > ( key , value ) ) ; }
private void add Fillet ( Coordinate p , Coordinate p0 , Coordinate p1 , int direction , double radius ) { double dx 0 = p0 . x - p . x ; double dy 0 = p0 . y - p . y ; double start Angle = Math . atan 2 ( dy 0 , dx 0 ) ; double dx 1 = p1 . x - p . x ; double dy 1 = p1 . y - p . y ; double end Angle = Math . atan 2 ( dy 1 , dx 1 ) ; if ( direction == CG Algorithms . CLOCKWISE ) { if ( start Angle <= end Angle ) start Angle += NUM * Math . PI ; } else { if ( start Angle >= end Angle ) start Angle -= NUM * Math . PI ; } seg List . add Pt ( p0 ) ; add Fillet ( p , start Angle , end Angle , direction , radius ) ; seg List . add Pt ( p1 ) ; }
public static void dump Cursor ( I Cursor cursor , int max Column Width , String Builder builder ) { if ( cursor == null ) { builder . append ( STRING ) ; return ; } String [ ] column Names = cursor . get Column Names ( ) ; for ( String col : column Names ) { add Column To Row Builder ( builder , col , max Column Width ) ; } builder . append ( STRING ) ; for ( int i = NUM ; i < ( max Column Width + NUM ) * column Names . length ; i ++ ) { builder . append ( STRING ) ; } builder . append ( STRING ) ; int position = cursor . get Position ( ) ; for ( cursor . move To First ( ) ; ! cursor . is After Last ( ) ; cursor . move To Next ( ) ) { dump Current Row ( cursor , max Column Width , builder ) ; builder . append ( STRING ) ; } cursor . move To Position ( position ) ; }
@ Override public boolean is Enabled ( ) { if ( ( attribute Selection Panel != null ) && ! is Value Only ( ) ) { return attribute Selection Panel . is Enabled ( ) ; } else { if ( text Field != null ) { return text Field . is Enabled ( ) ; } } return BOOL ; }
private void draw Drag Border ( final Execution Unit process , final Graphics 2 D g2 ) { double width = model . get Process Width ( process ) ; double height = model . get Process Height ( process ) ; Shape drag Frame = new Round Rectangle 2 D . Double ( DRAG BORDER PADDING , DRAG BORDER PADDING , width - NUM * DRAG BORDER PADDING , height - NUM * DRAG BORDER PADDING , DRAG BORDER CORNER , DRAG BORDER CORNER ) ; g2 . set Color ( BORDER DRAG COLOR ) ; g2 . set Stroke ( BORDER DRAG STROKE ) ; g2 . draw ( drag Frame ) ; }
protected static Modbus Response read Request ( int function Code , int register , int count ) { Modbus TCP Transport transport = null ; Modbus TCP Transaction trans ; try { Socket socket = new Socket ( LOCALHOST , PORT ) ; transport = new Modbus TCP Transport ( socket ) ; Modbus Request req = null ; switch ( function Code ) { case Modbus . READ COILS : req = new Read Coils Request ( register , count ) ; break ; case Modbus . READ INPUT DISCRETES : req = new Read Input Discretes Request ( register , count ) ; break ; case Modbus . READ INPUT REGISTERS : req = new Read Input Registers Request ( register , count ) ; break ; case Modbus . READ HOLDING REGISTERS : req = new Read Multiple Registers Request ( register , count ) ; break ; default : fail ( String . format ( STRING , function Code ) ) ; } req . set Unit ID ( UNIT ID ) ; trans = ( Modbus TCP Transaction ) transport . create Transaction ( ) ; trans . set Request ( req ) ; trans . set Reconnecting ( BOOL ) ; trans . execute ( ) ; return trans . get Response ( ) ; } catch ( Exception e ) { logger . debug ( e . get Message ( ) ) ; } finally { if ( transport != null ) { try { transport . close ( ) ; } catch ( IO Exception e ) { logger . error ( e . get Message ( ) ) ; } } } return null ; }
public void start ( ) { runner = new Thread ( this , get Shell Name ( ) ) ; runner . start ( ) ; }
public final boolean does FFDC Directory Exist ( String [ ] args ) throws Ade Exception { final String dir Name = get FFDCDB Workspace Directory ( args ) ; if ( dir Name != null ) { final File ffdc Dir = new File ( dir Name ) ; if ( ffdc Dir != null && ffdc Dir . exists ( ) ) { return BOOL ; } } return BOOL ; }
public static String read Fixed Size UTF 16 Str ( Input Stream stream , int str Len ) throws IO Exception { byte [ ] str Bytes = new byte [ str Len ] ; int read = stream . read ( str Bytes ) ; if ( read == str Bytes . length ) { if ( str Bytes . length >= NUM ) { if ( str Bytes [ str Bytes . length - NUM ] == NUM && str Bytes [ str Bytes . length - NUM ] == NUM ) { byte [ ] copy = new byte [ str Bytes . length - NUM ] ; System . arraycopy ( str Bytes , NUM , copy , NUM , str Bytes . length - NUM ) ; str Bytes = copy ; } } return new String ( str Bytes , STRING ) ; } throw new Illegal State Exception ( STRING ) ; }
public static Summary Tree Node create Node ( Android Version version , Set < Updater Tree Node > children ) { Set < Updater Tree Node > included Children = Sets . new Hash Set ( ) ; Updater Tree Node primary Child = null ; for ( Updater Tree Node child : children ) { if ( child . include In Summary ( ) ) { included Children . add ( child ) ; } if ( child . is Primary ( ) ) { primary Child = child ; } } if ( ! included Children . is Empty ( ) ) { return new Summary Tree Node ( version , children , included Children , primary Child ) ; } return null ; }
public List < M Type > build ( ) { is Clean = BOOL ; if ( ! is Messages List Mutable && builders == null ) { return messages ; } boolean all Messages In Sync = BOOL ; if ( ! is Messages List Mutable ) { for ( int i = NUM ; i < messages . size ( ) ; i ++ ) { Message message = messages . get ( i ) ; Single Field Builder < M Type , B Type , I Type > builder = builders . get ( i ) ; if ( builder != null ) { if ( builder . build ( ) != message ) { all Messages In Sync = BOOL ; break ; } } } if ( all Messages In Sync ) { return messages ; } } ensure Mutable Message List ( ) ; for ( int i = NUM ; i < messages . size ( ) ; i ++ ) { messages . set ( i , get Message ( i , BOOL ) ) ; } messages = Collections . unmodifiable List ( messages ) ; is Messages List Mutable = BOOL ; return messages ; }
public Generic Table Handler ( Json Value table Config , String db Schema Name , Json Value queries Config , Json Value commands Config , int max Batch Size , SQL Exception Handler sql Exception Handler ) { cfg = Generic Table Config . parse ( table Config ) ; this . main Table Name = cfg . main Table Name ; this . prop Table Name = cfg . properties Table Name ; this . db Schema Name = db Schema Name ; if ( max Batch Size < NUM ) { this . max Batch Size = NUM ; } else { this . max Batch Size = max Batch Size ; } if ( sql Exception Handler == null ) { this . sql Exception Handler = new Default SQL Exception Handler ( ) ; } else { this . sql Exception Handler = sql Exception Handler ; } queries = new Table Queries ( this , main Table Name , prop Table Name , db Schema Name , get Searchable Length ( ) , new Generic Query Result Mapper ( ) ) ; query Map = Collections . unmodifiable Map ( initialize Query Map ( ) ) ; queries . set Configured Queries ( queries Config , commands Config , query Map ) ; enable Batching = ( this . max Batch Size > NUM ) ; if ( enable Batching ) { logger . info ( STRING , this . max Batch Size ) ; } else { logger . info ( STRING ) ; } }
@ Override public Object visit Order By Expression ( Order By Expression order expression , String expression string , List < Object > orders ) { String Builder sb = new String Builder ( ) ; sb . append ( orders . get ( NUM ) ) ; for ( int i = NUM ; i < orders . size ( ) ; i ++ ) { sb . append ( STRING ) ; sb . append ( orders . get ( i ) ) ; } return sb . to String ( ) ; }
public void write External ( Object Output out ) throws IO Exception { out . write Int ( Vocabulary . size ( ) ) ; for ( int i = NUM ; i < Vocabulary . size ( ) ; i ++ ) { out . write UTF ( Vocabulary . word ( i ) ) ; } out . write Double ( num Tokens ) ; out . write Int ( count Funcs . length ) ; for ( long [ ] count Func : count Funcs ) { out . write Long ( count Func [ NUM ] ) ; out . write Long ( count Func [ NUM ] ) ; } out . write Int ( types Funcs . length ) ; for ( long [ ] types Func : types Funcs ) { out . write Long ( types Func [ NUM ] ) ; out . write Long ( types Func [ NUM ] ) ; } out . write Double ( quantization Base ) ; bf . write External ( out ) ; }
public static double logpdf ( double x , double mu , double sigma , double xi ) { x = ( x - mu ) / sigma ; if ( x < NUM || ( xi < NUM && x > - NUM / xi ) ) { return Double . NEGATIVE INFINITY ; } if ( xi == NUM ) { return Double . POSITIVE INFINITY ; } return ( ( xi == - NUM ) ? NUM : Math . log ( NUM + xi * x ) * ( - NUM / xi - NUM ) ) - Math . log ( sigma ) ; }
public Sdp Exception ( String message , Throwable root Cause ) { super ( root Cause . get Message ( ) + Separators . SEMICOLON + message ) ; }
protected final void fire Property Change ( String property Name , Object old Value , Object new Value ) { Property Change Support a Change Support = this . change Support ; if ( a Change Support == null ) { return ; } a Change Support . fire Property Change ( property Name , old Value , new Value ) ; }
private Response Packet execute Delete ( Query Template Packet template , I Space Proxy space , Transaction txn ) throws Remote Exception , Transaction Exception , Unusable Entry Exception , Interrupted Exception { Response Packet packet = new Response Packet ( ) ; template . set Operation ID ( get Operation ID ( ) ) ; template . set Explain Plan ( get Explain Plan ( ) ) ; if ( is Return Result ( ) ) { int max = get Rownum Limit ( ) ; Array List < I Entry Packet > entries = template . take ( space , get Routing ( ) , get Projection Template ( ) , txn , get Timeout ( ) , get Read Modifier ( ) , get If Exists ( ) , max , get Min Entries To Wait For ( ) , get Query Result Type ( ) ) ; packet . set Result Set ( entries ) ; packet . set Int Result ( entries . size ( ) ) ; } else { template . set Routing ( get Routing ( ) ) ; int cleared = executor . clear ( template , space , txn , get Read Modifier ( ) ) ; packet . set Int Result ( cleared ) ; } return packet ; }
private Elements Or Attributes to Elements Or Attributes ( String value , Elements Or Attributes default Value ) { if ( value == null ) return default Value ; Elements Or Attributes eoa = Elements Or Attributes . NEITHER ; if ( value . index Of ( STRING ) >= NUM ) eoa = eoa . add Elements ( ) ; if ( value . index Of ( STRING ) >= NUM ) eoa = eoa . add Attributes ( ) ; return eoa ; }
public static String canonicalize Url ( String url , String refer ) { URL base ; try { try { base = new URL ( refer ) ; } catch ( Malformed URL Exception e ) { URL abs = new URL ( refer ) ; return abs . to External Form ( ) ; } if ( url . starts With ( STRING ) ) url = base . get Path ( ) + url ; URL abs = new URL ( base , url ) ; return encode Illegal Character In Url ( abs . to External Form ( ) ) ; } catch ( Malformed URL Exception e ) { return STRING ; } }
public void start ( ) throws IO Exception { this . is Running = BOOL ; Thread thread = new Thread ( this ) ; thread . set Daemon ( BOOL ) ; thread . set Name ( STRING ) ; thread . set Priority ( Thread . MAX PRIORITY ) ; thread . start ( ) ; }
@ Override public void add Layout Complete Event Listener ( Layout Complete Event Listener l ) { if ( layout Complete Listeners == null ) { layout Complete Listeners = new Array List < Layout Complete Event Listener > ( ) ; } layout Complete Listeners . add ( l ) ; }
public Byte Matrix encode ( String contents ) throws Writer Exception { if ( contents == null || contents . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } code = Encoder . encode ( contents , Error Correction Level . L ) ; return render Result ( code , QR CODE ELEMENT MULTIPLE ) ; }
public Request cookie ( String key , String value ) { Objects . require Non Null ( key ) ; Objects . require Non Null ( value ) ; cookies . put ( key , value ) ; return this ; }
protected void install Defaults ( ) { list . set Layout ( null ) ; Look And Feel . install Border ( list , STRING ) ; Look And Feel . install Colors And Font ( list , STRING , STRING , STRING ) ; Look And Feel . install Property ( list , STRING , Boolean . TRUE ) ; if ( list . get Cell Renderer ( ) == null ) { list . set Cell Renderer ( ( List Cell Renderer ) ( UI Manager . get ( STRING ) ) ) ; } Color sbg = list . get Selection Background ( ) ; if ( sbg == null || sbg instanceof UI Resource ) { list . set Selection Background ( UI Manager . get Color ( STRING ) ) ; } Color sfg = list . get Selection Foreground ( ) ; if ( sfg == null || sfg instanceof UI Resource ) { list . set Selection Foreground ( UI Manager . get Color ( STRING ) ) ; } Long l = ( Long ) UI Manager . get ( STRING ) ; time Factor = ( l != null ) ? l . long Value ( ) : NUM ; update Is File List ( ) ; }
public static void generate Extension Manager ( File root Folder ) throws IO Exception { File out File = new File ( root Folder , REGISTRY PATH ) ; String Builder builder = new String Builder ( ) ; builder . append ( STRING + STRING ) ; generate Imports ( builder ) ; generate Class ( builder ) ; File Utils . write String To File ( out File , builder . to String ( ) ) ; }
public static < V > Future < V > submit ( Callable < V > task ) { if ( task == null ) { throw new Null Pointer Exception ( ) ; } Future Task < V > future = new Future Task < V > ( task ) ; execute ( future ) ; return future ; }
static void check Internal Name ( final String name , final String msg ) { if ( name == null || name . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING + msg + STRING ) ; } if ( name . char At ( NUM ) == STRING ) { check Desc ( name , BOOL ) ; } else { check Internal Name ( name , NUM , - NUM , msg ) ; } }
private boolean is Authorized ( Application User application User , String namespace , Namespace Permission Enum ... permissions ) { if ( application User != null && application User . get Namespace Authorizations ( ) != null ) { for ( Namespace Authorization current User Authorization : application User . get Namespace Authorizations ( ) ) { List < Namespace Permission Enum > current User Namespace Permissions = current User Authorization . get Namespace Permissions ( ) ; if ( current User Namespace Permissions == null ) { current User Namespace Permissions = Collections . empty List ( ) ; } if ( String Utils . equals Ignore Case ( current User Authorization . get Namespace ( ) , namespace ) && current User Namespace Permissions . contains All ( Arrays . as List ( permissions ) ) ) { return BOOL ; } } } return BOOL ; }
protected Collection < String > format Arguments ( JC Diagnostic d , Locale l ) { List Buffer < String > buf = new List Buffer < String > ( ) ; for ( Object o : d . get Args ( ) ) { buf . append ( format Argument ( d , o , l ) ) ; } return buf . to List ( ) ; }
public void calculate Derived ( ) { x Stats . calculate Derived ( ) ; y Stats . calculate Derived ( ) ; differences Stats . calculate Derived ( ) ; correlation = Double . Na N ; if ( ! Double . is Na N ( x Stats . std Dev ) && ! Double . is Na N ( y Stats . std Dev ) && ! Utils . eq ( x Stats . std Dev , NUM ) ) { double slope = ( xy Sum - x Stats . sum * y Stats . sum / count ) / ( x Stats . sum Sq - x Stats . sum * x Stats . mean ) ; if ( ! Utils . eq ( y Stats . std Dev , NUM ) ) { correlation = slope * x Stats . std Dev / y Stats . std Dev ; } else { correlation = NUM ; } } if ( Utils . gr ( differences Stats . std Dev , NUM ) ) { double tval = differences Stats . mean / Math . sqrt ( ( NUM / count + m test Train Ratio ) * differences Stats . std Dev * differences Stats . std Dev ) ; if ( count > NUM ) { differences Probability = Statistics . F Probability ( tval * tval , NUM , ( int ) count - NUM ) ; } else differences Probability = NUM ; } else { if ( differences Stats . sum Sq == NUM ) { differences Probability = NUM ; } else { differences Probability = NUM ; } } differences Significance = NUM ; if ( differences Probability <= sig Level ) { if ( x Stats . mean > y Stats . mean ) { differences Significance = NUM ; } else { differences Significance = - NUM ; } } }
private Un Managed Consistency Group create Un Managed CG ( String un Managed CG Native Guid , Xtrem IO Consistency Group consistency Group , URI storage System URI , Db Client db Client ) { Un Managed Consistency Group un Managed CG = new Un Managed Consistency Group ( ) ; un Managed CG . set Id ( URI Util . create Id ( Un Managed Consistency Group . class ) ) ; un Managed CG . set Label ( consistency Group . get Name ( ) ) ; un Managed CG . set Name ( consistency Group . get Name ( ) ) ; un Managed CG . set Native Guid ( un Managed CG Native Guid ) ; un Managed CG . set Storage System Uri ( storage System URI ) ; un Managed CG . set Number Of Vols ( consistency Group . get Num Of Vols ( ) ) ; db Client . create Object ( un Managed CG ) ; return un Managed CG ; }
public Amqp Message receive ( long timeout , Time Unit unit ) throws Exception { check Closed ( ) ; return prefetch . poll ( timeout , unit ) ; }
private boolean zz Refill ( ) throws java . io . IO Exception { if ( zz Start Read > NUM ) { System . arraycopy ( zz Buffer , zz Start Read , zz Buffer , NUM , zz End Read - zz Start Read ) ; zz End Read -= zz Start Read ; zz Current Pos -= zz Start Read ; zz Marked Pos -= zz Start Read ; zz Pushback Pos -= zz Start Read ; zz Start Read = NUM ; } if ( zz Current Pos >= zz Buffer . length ) { char new Buffer [ ] = new char [ zz Current Pos * NUM ] ; System . arraycopy ( zz Buffer , NUM , new Buffer , NUM , zz Buffer . length ) ; zz Buffer = new Buffer ; } int num Read = zz Reader . read ( zz Buffer , zz End Read , zz Buffer . length - zz End Read ) ; if ( num Read < NUM ) { return BOOL ; } else { zz End Read += num Read ; return BOOL ; } }
void save Entities ( Data Output Stream out ) throws IO Exception { int num = NUM ; for ( Enumeration < Entity > e = entity Hash . elements ( ) ; e . has More Elements ( ) ; ) { Entity ent = e . next Element ( ) ; if ( ent . is General ( ) ) { num ++ ; } } out . write Short ( ( short ) num ) ; for ( Enumeration < Entity > e = entity Hash . elements ( ) ; e . has More Elements ( ) ; ) { Entity ent = e . next Element ( ) ; if ( ent . is General ( ) ) { out . write Short ( get Name Id ( ent . get Name ( ) ) ) ; out . write Byte ( ent . get Type ( ) & ~ GENERAL ) ; out . write UTF ( ent . get String ( ) ) ; } } }
public Server Configuration kill Bookie ( int index ) throws Exception { if ( index >= bs . size ( ) ) { throw new IO Exception ( STRING ) ; } Bookie Server server = bs . get ( index ) ; server . shutdown ( ) ; stop Auto Recovery Service ( server ) ; bs . remove ( server ) ; return bs Confs . remove ( index ) ; }
public void add Selections ( Set < Entity > items ) { for ( Entity item : items ) { set Selection ( item , BOOL ) ; } }
private static final Map < Id < Link > , Id < Zone > > parse L 2 Z Mapping ( String infile ) { Map < Id < Link > , Id < Zone > > l2 z Mapping = new Hash Map < > ( ) ; try { File Reader fr = new File Reader ( infile ) ; Buffered Reader br = new Buffered Reader ( fr ) ; String curr line ; while ( ( curr line = br . read Line ( ) ) != null ) { String [ ] entries = curr line . split ( STRING , - NUM ) ; Id < Link > lid = Id . create ( entries [ NUM ] , Link . class ) ; Id < Zone > zid = Id . create ( entries [ NUM ] , Zone . class ) ; l2 z Mapping . put ( lid , zid ) ; } } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } return l2 z Mapping ; }
public boolean delete Load Name ( String load ) { if ( ! load List . contains ( load ) ) { return BOOL ; } load List . remove ( load ) ; log . debug ( STRING , get Name ( ) , load ) ; set Dirty And Fire Property Change ( LOADS CHANGED PROPERTY , load List . size ( ) + NUM , load List . size ( ) ) ; return BOOL ; }
private void validate Removal Of Public Network Interface ( String instance Id , int desired Network Interface State Count ) throws Throwable { if ( this . is Aws Client Mock ) { return ; } Compute State stopped Compute State = get Compute By AWS Id ( this . host , instance Id ) ; assert Not Null ( stopped Compute State ) ; for ( String network Link : stopped Compute State . network Interface Links ) { assert False ( network Link . contains ( PUBLIC INTERFACE ) ) ; } validate Network Interface Count ( desired Network Interface State Count ) ; }
private void process Tag ( final String Builder builder ) { boolean started = BOOL ; while ( template Reader . has Next Character ( ) ) { final char tag Character = template Reader . next Character ( ) ; if ( ! started && Strings . is Whitespace ( tag Character ) ) { continue ; } started = BOOL ; if ( tag Character == syntax . get Argument Opening ( ) ) { process Argument ( ) ; } else if ( tag Character == syntax . get Tag Opening ( ) && is Next Character Comment Opening ( ) ) { process Comment ( ) ; } else if ( tag Character == syntax . get Tag Closing ( ) ) { process Tag Entity ( builder ) ; return ; } else { builder . append ( tag Character ) ; } } throw Error ( STRING + builder . to String ( ) ) ; }
public Array List parse Arguments ( ) { String working = STRING + arguments + STRING ; int index = NUM ; result = new Array List ( ) ; while ( index < working . length ( ) ) { int next = find Next Arg ( index , working ) ; if ( next < NUM ) break ; int pos = extract Arg Name ( next , working ) ; Arg Range range = extract Arg Value ( pos + NUM , working ) ; if ( range != null ) { String arg Name = working . substring ( next , pos ) ; String arg Value = working . substring ( range . start Index , range . end Index ) ; result . add ( arg Name + STRING + arg Value ) ; index = range . end Index + NUM ; } else { String arg Name = working . substring ( next , pos ) ; result . add ( arg Name ) ; index = pos + NUM ; } } return result ; }
public void add Privilege ( SSO Token token , String org Name , Delegation Privilege privilege ) throws SSO Exception , Delegation Exception { if ( privilege != null ) { try { if ( has Delegation Permissions For Realm ( token , org Name ) ) { token = ( SSO Token ) Access Controller . do Privileged ( Admin Token Action . get Instance ( ) ) ; } Policy Manager pm = new Policy Manager ( token , POLICY REPOSITORY REALM ) ; Policy p = privilege To Policy ( pm , privilege , org Name ) ; if ( p != null ) { Set existing Policies = pm . get Policy Names ( ) ; if ( existing Policies . contains ( p . get Name ( ) ) ) { Set < String > subject Names = p . get Subject Names ( ) ; if ( ( subject Names == null ) || subject Names . is Empty ( ) ) { pm . remove Policy ( p . get Name ( ) ) ; } else { pm . replace Policy ( p ) ; } } else { Set < String > subject Names = p . get Subject Names ( ) ; if ( ( subject Names != null ) && ! subject Names . is Empty ( ) ) { pm . add Policy ( p ) ; } } } else { throw new Delegation Exception ( Res Bundle Utils . rb Name , STRING , null , null ) ; } } catch ( Exception e ) { throw new Delegation Exception ( e ) ; } } }
public void test Doubles Round Trip ( ) { byte [ ] encoded = new byte [ Double . BYTES ] ; for ( int i = NUM ; i < NUM ; i ++ ) { double value = Double . long Bits To Double ( Test Util . next Long ( random ( ) , Long . MIN VALUE , Long . MAX VALUE ) ) ; Numeric Utils . long To Sortable Bytes ( Numeric Utils . double To Sortable Long ( value ) , encoded , NUM ) ; double actual = Numeric Utils . sortable Long To Double ( Numeric Utils . sortable Bytes To Long ( encoded , NUM ) ) ; assert Equals ( Double . double To Long Bits ( value ) , Double . double To Long Bits ( actual ) ) ; } }
private void recompute Seperation ( double [ ] [ ] means , double [ ] [ ] cdist , int [ ] [ ] cnum , Long Statistic diststat ) { final int k = means . length ; for ( int i = NUM ; i < k ; i ++ ) { Double Vector mi = Double Vector . wrap ( means [ i ] ) ; for ( int j = NUM ; j < i ; j ++ ) { cdist [ i ] [ j ] = cdist [ j ] [ i ] = distance Function . distance ( mi , Double Vector . wrap ( means [ j ] ) ) ; } } double [ ] buf = new double [ k - NUM ] ; for ( int i = NUM ; i < k ; i ++ ) { System . arraycopy ( cdist [ i ] , NUM , buf , NUM , i ) ; System . arraycopy ( cdist [ i ] , i + NUM , buf , i , k - i - NUM ) ; for ( int j = NUM ; j < buf . length ; j ++ ) { cnum [ i ] [ j ] = j < i ? j : ( j + NUM ) ; } Double Integer Array Quick Sort . sort ( buf , cnum [ i ] , k - NUM ) ; } if ( diststat != null ) { diststat . increment ( ( k * ( k - NUM ) ) > > NUM ) ; } }
public Bitmap read Image ( String image Path , int max Width , int max Height ) { File image File = new File ( image Path ) ; if ( image File . exists ( ) ) { Buffered Input Stream input Stream = null ; try { input Stream = new Buffered Input Stream ( new File Input Stream ( image File ) ) ; Bitmap Factory . Options options = new Bitmap Factory . Options ( ) ; options . in Just Decode Bounds = BOOL ; Bitmap Factory . decode Stream ( input Stream , null , options ) ; input Stream . close ( ) ; int i = NUM ; while ( BOOL ) { if ( ( options . out Width > > i <= max Width ) && ( options . out Height > > i <= max Height ) ) { input Stream = new Buffered Input Stream ( new File Input Stream ( new File ( image Path ) ) ) ; options . in Sample Size = ( int ) Math . pow ( NUM , i ) ; options . in Just Decode Bounds = BOOL ; Bitmap bitmap = Bitmap Factory . decode Stream ( input Stream , null , options ) ; input Stream . close ( ) ; return bitmap ; } i += NUM ; } } catch ( IO Exception e ) { Logger . e ( e , STRING + image Path + STRING ) ; } finally { IO Utils . close Quietly ( input Stream ) ; } } return null ; }
@ Override public void write Empty Element ( String local Name ) throws XML Stream Exception { write Empty Element ( null , local Name , null ) ; }
public void add Listener ( final I Running Query Listener l ) { if ( l == null ) throw new Illegal Argument Exception ( ) ; listeners . add ( l ) ; }
private static Set < Emoticon > parse Emotes ( String json , String channel Restriction ) { Set < Emoticon > emotes = new Hash Set < > ( ) ; if ( json == null ) { return emotes ; } JSON Parser parser = new JSON Parser ( ) ; try { JSON Object root = ( JSON Object ) parser . parse ( json ) ; String url Template = ( String ) root . get ( STRING ) ; if ( url Template == null || url Template . is Empty ( ) ) { LOGGER . warning ( STRING ) ; return emotes ; } JSON Array emotes Array = ( JSON Array ) root . get ( STRING ) ; for ( Object o : emotes Array ) { if ( o instanceof JSON Object ) { Emoticon emote = parse Emote ( ( JSON Object ) o , url Template , channel Restriction ) ; if ( emote != null ) { emotes . add ( emote ) ; } } } } catch ( Parse Exception | Class Cast Exception ex ) { LOGGER . warning ( STRING + ex ) ; } return emotes ; }
public Str Builder replace All ( final String search Str , final String replace Str ) { final int search Len = ( search Str == null ? NUM : search Str . length ( ) ) ; if ( search Len > NUM ) { final int replace Len = ( replace Str == null ? NUM : replace Str . length ( ) ) ; int index = index Of ( search Str , NUM ) ; while ( index >= NUM ) { replace Impl ( index , index + search Len , search Len , replace Str , replace Len ) ; index = index Of ( search Str , index + replace Len ) ; } } return this ; }
public abstract Byte Buffer put ( int index , byte b ) ;
public Scale Selector ( ) { slider = new J Slider ( NUM , NUM , NUM ) ; value = new J Label ( STRING ) ; size = new J Label ( STRING ) ; preview = new Image Panel ( ) ; value . set Preferred Size ( new Dimension ( NUM , NUM ) ) ; size . set Horizontal Alignment ( J Label . CENTER ) ; slider . set Major Tick Spacing ( NUM ) ; slider . set Snap To Ticks ( BOOL ) ; slider . add Change Listener ( this ) ; set Layout ( new Border Layout ( ) ) ; Box b1 = new Box ( Box Layout . X AXIS ) ; b1 . add ( Box . create Horizontal Strut ( NUM ) ) ; b1 . add ( Box . create Horizontal Glue ( ) ) ; b1 . add ( preview ) ; b1 . add ( Box . create Horizontal Glue ( ) ) ; b1 . add ( Box . create Horizontal Strut ( NUM ) ) ; add ( b1 , Border Layout . CENTER ) ; Box b2 = new Box ( Box Layout . X AXIS ) ; b2 . add ( slider ) ; b2 . add ( Box . create Horizontal Strut ( NUM ) ) ; b2 . add ( value ) ; Box b3 = new Box ( Box Layout . X AXIS ) ; b3 . add ( Box . create Horizontal Strut ( NUM ) ) ; b3 . add ( Box . create Horizontal Glue ( ) ) ; b3 . add ( size ) ; b3 . add ( Box . create Horizontal Glue ( ) ) ; b3 . add ( Box . create Horizontal Strut ( NUM ) ) ; Box b4 = new Box ( Box Layout . Y AXIS ) ; b4 . add ( b2 ) ; b4 . add ( b3 ) ; add ( b4 , Border Layout . SOUTH ) ; }
protected static String normalize Url Ending ( String link ) { if ( link . index Of ( STRING ) > - NUM ) link = link . substring ( NUM , link . index Of ( STRING ) ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; return link ; }
public C Address Space Configuration ( final C Address Space address Space , final Address Space Configuration Backend provider , final int address Space Id , final String name , final String description , final Date creation Date , final Date modification Date , final Debugger Template debugger Template ) { m address Space = address Space ; m provider = provider ; m id = address Space Id ; m name = name ; m description = description ; m creation Date = new Date ( creation Date . get Time ( ) ) ; m modification Date = new Date ( modification Date . get Time ( ) ) ; m debugger Template = debugger Template ; }
public static < T > Parallel Flux < T > from ( Publisher < ? extends T > source , int parallelism , int prefetch , Supplier < Queue < T > > queue Supplier ) { if ( parallelism <= NUM ) { throw new Illegal Argument Exception ( STRING + parallelism ) ; } if ( prefetch <= NUM ) { throw new Illegal Argument Exception ( STRING + prefetch ) ; } Objects . require Non Null ( queue Supplier , STRING ) ; Objects . require Non Null ( source , STRING ) ; return on Assembly ( new Parallel Unordered Source < > ( source , parallelism , prefetch , queue Supplier ) ) ; }
private void on Ball In Pipe ( ) { m Sound Pool . play ( m Sound Ball In Machine , NUM , NUM , NUM , NUM , NUM ) ; m Game Balls Left -- ; m Number Collected ++ ; change Indicator ( ) ; m Match Score += NUM * Math . max ( NUM , ( m Current Level Num - m Count Level Ball Respawns ) ) ; m View Score . set Text ( String . value Of ( m Match Score ) ) ; if ( m Game Balls Left == NUM && m View Play Again Background . get Visibility ( ) != View . VISIBLE ) { m Current Level Num ++ ; m Level Number Text . set Level Number ( m Current Level Num ) ; m Level Number Text . start Animation ( m Animation Level Scale Up ) ; m End Level Circle . start Animation ( m Animation Scale Level Down ) ; } }
public final double sample Sigma ( int n ) { synchronized ( lock ) { long count = count . get ( ) ; long last Count = last Std Count ; last Std Count = count ; double sum = sum . get ( ) ; double last Sum = last Std Sum ; last Std Sum = sum ; double sum Square = sum Square ; sum Square = NUM ; if ( count == last Count ) return NUM ; double avg = ( sum - last Sum ) / ( count - last Count ) ; double part = ( count - last Count ) * sum Square - sum * sum ; if ( part < NUM ) part = NUM ; double std = Math . sqrt ( part ) / ( count - last Count ) ; return scale * ( avg + n * std ) ; } }
public void remove ( final Channel channel ) { synchronized ( channels ) { for ( final Iterator chan Iter = channels . iterator ( ) ; chan Iter . has Next ( ) ; ) { if ( chan Iter . next ( ) == channel ) { chan Iter . remove ( ) ; break ; } } } }
public Pla Segment Float shrink segment ( double p offset ) { double dx = point b . v x - point a . v x ; double dy = point b . v y - point a . v y ; if ( dx == NUM && dy == NUM ) return this ; double length = Math . sqrt ( dx * dx + dy * dy ) ; double offset = Math . min ( p offset , length / NUM ) ; Pla Point Float new a = new Pla Point Float ( point a . v x + ( dx * offset ) / length , point a . v y + ( dy * offset ) / length ) ; double new length = length - offset ; Pla Point Float new b = new Pla Point Float ( point a . v x + ( dx * new length ) / length , point a . v y + ( dy * new length ) / length ) ; return new Pla Segment Float ( new a , new b ) ; }
void read Checkpoint Delta ( Table Kelp table , Page Service Impl page Actor , Read Stream is , int length ) throws IO Exception { Row row = table . row ( ) ; int remove Length = row . remove Length ( ) ; int row Length = row . length ( ) ; Block Leaf block = blocks [ NUM ] ; long end Position = is . position ( ) + length ; int row Head = block . row Head ( ) ; int blob Tail = block . get Blob Tail ( ) ; long pos ; while ( ( pos = is . position ( ) ) < end Position ) { int code = is . read ( ) ; is . unread ( ) ; code = code & CODE MASK ; if ( code == REMOVE ) { row Head -= remove Length ; if ( row Head < blob Tail ) { block = extend Blocks ( ) ; row Head = BLOCK SIZE - remove Length ; blob Tail = NUM ; } is . read All ( block . get Buffer ( ) , row Head , remove Length ) ; } else if ( code == INSERT ) { row Head -= row Length ; while ( ( blob Tail = row . read Checkpoint ( is , block . get Buffer ( ) , row Head , blob Tail ) ) < NUM ) { is . position ( pos ) ; block = extend Blocks ( ) ; row Head = BLOCK SIZE - row Length ; blob Tail = NUM ; } } else { throw new Illegal State Exception ( L . l ( STRING , this , pos , code ) ) ; } block . row Head ( row Head ) ; block . set Blob Tail ( blob Tail ) ; } clear Dirty ( ) ; validate ( table ) ; }
@ Suppress Warnings ( { STRING } ) private void init Client ( ) throws Ignite Spi Exception { if ( init Guard . compare And Set ( BOOL , BOOL ) ) try { if ( cred == null ) throw new Ignite Spi Exception ( STRING ) ; if ( cfg == null ) U . warn ( log , STRING ) ; if ( F . is Empty ( bucket Name ) ) throw new Ignite Spi Exception ( STRING ) ; s3 = cfg != null ? new Amazon S 3 Client ( cred , cfg ) : new Amazon S 3 Client ( cred ) ; if ( ! s3 . does Bucket Exist ( bucket Name ) ) { try { s3 . create Bucket ( bucket Name ) ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + bucket Name ) ; while ( ! s3 . does Bucket Exist ( bucket Name ) ) try { U . sleep ( NUM ) ; } catch ( Ignite Interrupted Checked Exception e ) { throw new Ignite Spi Exception ( STRING , e ) ; } } catch ( Amazon Client Exception e ) { if ( ! s3 . does Bucket Exist ( bucket Name ) ) { s3 = null ; throw new Ignite Spi Exception ( STRING + bucket Name , e ) ; } } } } finally { init Latch . count Down ( ) ; } else { try { U . await ( init Latch ) ; } catch ( Ignite Interrupted Checked Exception e ) { throw new Ignite Spi Exception ( STRING , e ) ; } if ( s3 == null ) throw new Ignite Spi Exception ( STRING ) ; } }
protected Literal parse Literal ( String literal ) throws Illegal Argument Exception { if ( literal . starts With ( STRING ) ) { int end Label Idx = find End Of Label ( literal ) ; if ( end Label Idx != - NUM ) { int start Lang Idx = literal . index Of ( STRING , end Label Idx ) ; int start Dt Idx = literal . index Of ( STRING , end Label Idx ) ; if ( start Lang Idx != - NUM && start Dt Idx != - NUM ) { throw new Illegal Argument Exception ( STRING ) ; } String label = literal . substring ( NUM , end Label Idx ) ; label = decode String ( label ) ; if ( start Lang Idx != - NUM ) { String language = literal . substring ( start Lang Idx + NUM ) ; return value Factory . create Literal ( label , language ) ; } else if ( start Dt Idx != - NUM ) { String datatype = literal . substring ( start Dt Idx + NUM ) ; datatype = datatype . substring ( NUM , datatype . length ( ) - NUM ) ; IRI dt URI = value Factory . create IRI ( datatype ) ; return value Factory . create Literal ( label , dt URI ) ; } else { return value Factory . create Literal ( label ) ; } } } throw new Illegal Argument Exception ( STRING + literal ) ; }
public static double distance Point Line ( Coordinate p , Coordinate A , Coordinate B ) { if ( A . x == B . x && A . y == B . y ) return p . distance ( A ) ; double len 2 = ( B . x - A . x ) * ( B . x - A . x ) + ( B . y - A . y ) * ( B . y - A . y ) ; double r = ( ( p . x - A . x ) * ( B . x - A . x ) + ( p . y - A . y ) * ( B . y - A . y ) ) / len 2 ; if ( r <= NUM ) return p . distance ( A ) ; if ( r >= NUM ) return p . distance ( B ) ; double s = ( ( A . y - p . y ) * ( B . x - A . x ) - ( A . x - p . x ) * ( B . y - A . y ) ) / len 2 ; return Math . abs ( s ) * Math . sqrt ( len 2 ) ; }
public static int check Signature And Tinker ID ( Context context , File patch File , Share Security Check security Check ) { if ( ! security Check . verify Patch Meta Signature ( patch File ) ) { return Share Constants . ERROR PACKAGE CHECK SIGNATURE FAIL ; } String old Tinker Id = get Manifest Tinker ID ( context ) ; if ( old Tinker Id == null ) { return Share Constants . ERROR PACKAGE CHECK APK TINKER ID NOT FOUND ; } Hash Map < String , String > properties = security Check . get Package Properties If Present ( ) ; if ( properties == null ) { return Share Constants . ERROR PACKAGE CHECK PACKAGE META NOT FOUND ; } String patch Tinker Id = properties . get ( Share Constants . TINKER ID ) ; if ( patch Tinker Id == null ) { return Share Constants . ERROR PACKAGE CHECK PATCH TINKER ID NOT FOUND ; } if ( ! old Tinker Id . equals ( patch Tinker Id ) ) { return Share Constants . ERROR PACKAGE CHECK TINKER ID NOT EQUAL ; } return Share Constants . ERROR PACKAGE CHECK OK ; }
public static String read String Fixed Size ( final Data Input in , int size ) throws IO Exception { byte [ ] b = new byte [ size ] ; in . read Fully ( b ) ; int n = b . length ; while ( n > NUM && b [ n - NUM ] == NUM ) -- n ; return to String ( b , NUM , n ) ; }
private void create Gui ( ) { final J Panel top Panel = new J Panel ( new Border Layout ( ) ) ; final J Panel inner Top Panel = new J Panel ( new Border Layout ( ) ) ; top Panel . add ( inner Top Panel ) ; inner Top Panel . add ( m std Edit Panel ) ; inner Top Panel . add ( m debugger Panel , Border Layout . SOUTH ) ; final J Panel button Panel = new J Panel ( new Grid Layout ( NUM , NUM ) ) ; button Panel . set Border ( new Empty Border ( NUM , NUM , NUM , NUM ) ) ; button Panel . add ( new J Panel ( ) ) ; button Panel . add ( m save Button ) ; top Panel . add ( button Panel , Border Layout . SOUTH ) ; final J Panel inner Sp = new J Panel ( new Border Layout ( ) ) ; m middle Panel . set Preferred Size ( new Dimension ( m middle Panel . get Preferred Size ( ) . width , NUM ) ) ; inner Sp . add ( m middle Panel , Border Layout . NORTH ) ; inner Sp . add ( m bottom Panel , Border Layout . CENTER ) ; final J Split Pane outer Sp = new J Split Pane ( J Split Pane . VERTICAL SPLIT , BOOL , top Panel , inner Sp ) ; outer Sp . set One Touch Expandable ( BOOL ) ; outer Sp . set Divider Location ( outer Sp . get Minimum Divider Location ( ) ) ; outer Sp . set Resize Weight ( NUM ) ; final J Panel inner Panel = new J Panel ( new Border Layout ( ) ) ; inner Panel . add ( outer Sp ) ; add ( inner Panel ) ; }
public static boolean is Document Mode Eligible ( Context context ) { return Build . VERSION . SDK INT >= Build . VERSION CODES . LOLLIPOP && ! Device Form Factor . is Tablet ( context ) ; }
private double gamma Ratio ( int n , int k ) { double top = ( n - k + NUM ) / NUM ; double bottom = ( n - k ) / NUM ; double lngamma = Prob Utils . lngamma ( top ) - Prob Utils . lngamma ( bottom ) ; return Math . exp ( lngamma ) ; }
private static List < String > wrap ( String text , int width ) { List < String > lines = Collections . singleton List ( text ) ; if ( text . length ( ) > width ) { String [ ] chunks = text . split ( STRING ) ; lines = new Array List < > ( ) ; String Builder line = new String Builder ( ) ; for ( String chunk : chunks ) { if ( line . length ( ) + chunk . length ( ) > width ) { lines . add ( line . to String ( ) ) ; line . set Length ( NUM ) ; } if ( line . length ( ) != NUM ) { line . append ( STRING ) ; } String [ ] embedded Lines = chunk . split ( STRING , - NUM ) ; if ( embedded Lines . length == NUM ) { line . append ( chunk ) ; } else { for ( int i = NUM ; i < embedded Lines . length ; i ++ ) { line . append ( embedded Lines [ i ] ) ; if ( i < embedded Lines . length - NUM ) { lines . add ( line . to String ( ) ) ; line . set Length ( NUM ) ; } } } } if ( line . length ( ) != NUM ) { lines . add ( line . to String ( ) ) ; } } return lines ; }
@ Override public String to String ( ) { String result ; if ( valid ) { result = STRING + output File . get Absolute Path ( ) + STRING ; if ( sign Mode ) { result += STRING + key Store Path + STRING + STRING + alias + STRING ; } else { result += STRING + key File Path + STRING ; } } else { return invalid Message ; } result += STRING + reason + STRING + STRING + location + STRING ; if ( can Encrypt ( ) ) { result += STRING + STRING ; } if ( can Flatten ( ) ) { result += STRING + STRING ; } if ( certify Mode != Itext Functions . NOT CERTIFIED ) { result += STRING + STRING ; } return result ; }
public void add Action Listener ( Action Listener a ) { m Colour Change Listeners . add ( a ) ; }
public double calculate Log Likelihood ( ) { double log L = NUM ; for ( Statistic statistic : data List ) { for ( int j = NUM ; j < statistic . get Dimension ( ) ; j ++ ) { log L -= NUM * Math . log ( statistic . get Statistic Value ( j ) ) ; } } return log L ; }
public static boolean has Dead States To Accept ( Automaton a ) { Bit Set reachable From Initial = get Live States From Initial ( a ) ; Bit Set reachable From Accept = get Live States To Accept ( a ) ; reachable From Accept . and Not ( reachable From Initial ) ; return reachable From Accept . is Empty ( ) == BOOL ; }
public Decimal add ( Decimal decimal ) { assert Defined ( ) ; if ( null == m value ) { if ( null == decimal . get Big Decimal Value ( ) ) { return new Decimal ( SCALE ) ; } else { return new Decimal ( decimal . get Big Decimal Value ( ) , SCALE ) ; } } Big Decimal value = m value . add ( decimal . get Big Decimal Value ( ) ) ; return new Decimal ( value , SCALE ) ; }
@ Override public boolean equals ( Object object ) { if ( object == null ) { return BOOL ; } if ( object == this ) { return BOOL ; } if ( super . equals ( object ) && object instanceof Ship Needle ) { return BOOL ; } return BOOL ; }
protected String parse ( Reader reader ) throws IO Exception { if ( ! reader . mark Supported ( ) ) { reader = new Buffered Reader ( reader ) ; } String Writer sw = new String Writer ( ) ; start Script ( sw ) ; int c ; while ( ( c = reader . read ( ) ) != - NUM ) { if ( c == STRING ) { reader . mark ( NUM ) ; c = reader . read ( ) ; if ( c != STRING ) { sw . write ( STRING ) ; reader . reset ( ) ; } else { reader . mark ( NUM ) ; c = reader . read ( ) ; if ( c == STRING ) { groovy Expression ( reader , sw ) ; } else { reader . reset ( ) ; groovy Section ( reader , sw ) ; } } continue ; } if ( c == STRING ) { reader . mark ( NUM ) ; c = reader . read ( ) ; if ( c != STRING ) { sw . write ( STRING ) ; reader . reset ( ) ; } else { reader . mark ( NUM ) ; sw . write ( STRING ) ; process G Sstring ( reader , sw ) ; } continue ; } if ( c == STRING ) { sw . write ( STRING ) ; } if ( c == STRING || c == STRING ) { if ( c == STRING ) { reader . mark ( NUM ) ; c = reader . read ( ) ; if ( c != STRING ) { reader . reset ( ) ; } } sw . write ( STRING ) ; continue ; } sw . write ( c ) ; } end Script ( sw ) ; return sw . to String ( ) ; }
public static boolean controller Has Request Uri Direct ( Http Servlet Request request , String uri ) { if ( request == null ) { return BOOL ; } Request Handler rh = Request Handler . get Request Handler ( request . get Servlet Context ( ) ) ; return rh . controller Has Request Uri Direct ( uri ) ; }
public static List < Byte Buffer > base 64 String To Byte Buffer ( String ... base 64 Encoded Keys ) { List < Byte Buffer > byte Buffers = new Array List < > ( base 64 Encoded Keys . length ) ; for ( String base 64 Encoded Key : base 64 Encoded Keys ) { byte Buffers . add ( base 64 String To Byte Buffer ( base 64 Encoded Key ) ) ; } return byte Buffers ; }
boolean compute Angle Offset ( ) { if ( m Finished ) { return BOOL ; } long system Clock = Animation Utils . current Animation Time Millis ( ) ; long time Passed = system Clock - m Start Millis ; if ( time Passed < m Duration Millis ) { switch ( m Mode ) { case SCROLL MODE : float sc = ( float ) time Passed / m Duration Millis ; m Curr Angle Deg = m Start Angle Deg + Math . round ( m Delta Angle Deg * sc ) ; break ; case FLING MODE : float time Passed Seconds = time Passed / NUM ; float distance = m Coeff Velocity * m Velocity * time Passed Seconds - ( DECELERATION * time Passed Seconds * time Passed Seconds / NUM ) ; m Curr Angle Deg = m Start Angle Deg + Math . round ( distance ) ; break ; } return BOOL ; } else { m Finished = BOOL ; return BOOL ; } }
private final int load digits ( String Builder sb , int c ) throws IO Exception { if ( ! Ion Token Consts X . is Digit ( c ) ) { return c ; } sb . append ( ( char ) c ) ; return read Numeric ( sb , Radix . DECIMAL , Numeric State . DIGIT ) ; }
private Document sign Element ( Document doc , String id , X509 Certificate cert , Private Key key , String sign Algorithm , String digest Algorithm ) throws Marshal Exception , XML Signature Exception { try { XML Signature Factory xml Signature Factory = XML Signature Factory . get Instance ( STRING , new org . jcp . xml . dsig . internal . dom . XMLD Sig RI ( ) ) ; List < Transform > transforms = new Array List < Transform > ( ) ; Transform enveloped = xml Signature Factory . new Transform ( Transforms . TRANSFORM ENVELOPED SIGNATURE , ( XML Structure ) null ) ; transforms . add ( enveloped ) ; Transform c14 n = xml Signature Factory . new Transform ( Transforms . TRANSFORM C14 N EXCL OMIT COMMENTS , ( XML Structure ) null ) ; transforms . add ( c14 n ) ; Reference ref ; try { ref = xml Signature Factory . new Reference ( STRING + id , xml Signature Factory . new Digest Method ( digest Algorithm , null ) , transforms , null , null ) ; } catch ( No Such Algorithm Exception e ) { ref = xml Signature Factory . new Reference ( STRING + id , xml Signature Factory . new Digest Method ( Digest Method . SHA 256 , null ) , transforms , null , null ) ; } Signed Info signed Info ; try { signed Info = xml Signature Factory . new Signed Info ( xml Signature Factory . new Canonicalization Method ( Canonicalization Method . EXCLUSIVE , ( C14 N Method Parameter Spec ) null ) , xml Signature Factory . new Signature Method ( sign Algorithm , null ) , Collections . singleton List ( ref ) ) ; } catch ( No Such Algorithm Exception e ) { signed Info = xml Signature Factory . new Signed Info ( xml Signature Factory . new Canonicalization Method ( Canonicalization Method . EXCLUSIVE , ( C14 N Method Parameter Spec ) null ) , xml Signature Factory . new Signature Method ( XML Signature . ALGO ID SIGNATURE RSA SHA 256 , null ) , Collections . singleton List ( ref ) ) ; } Key Info Factory key Info Factory = xml Signature Factory . get Key Info Factory ( ) ; List < X509 Certificate > x509 Content = new Array List < > ( ) ; x509 Content . add ( cert ) ; X509 Data x509 Data = key Info Factory . new X 509 Data ( x509 Content ) ; Key Info key Info = key Info Factory . new Key Info ( Collections . singleton List ( x509 Data ) ) ; Element element To Sign = doc . get Element By Id ( id ) ; Node List issuer List = element To Sign . get Elements By Tag Name NS ( STRING , STRING ) ; Element element Before Signature ; if ( issuer List . get Length ( ) > NUM ) { element Before Signature = ( Element ) issuer List . item ( NUM ) ; } else { element Before Signature = element To Sign ; } Element next Element After Issuer = ( Element ) element Before Signature . get Next Sibling ( ) ; DOM Sign Context dom Sign Context = new DOM Sign Context ( key , element To Sign ) ; dom Sign Context . set Default Namespace Prefix ( STRING ) ; dom Sign Context . set Next Sibling ( next Element After Issuer ) ; javax . xml . crypto . dsig . XML Signature signature = xml Signature Factory . new XML Signature ( signed Info , key Info ) ; signature . sign ( dom Sign Context ) ; return doc ; } catch ( Invalid Algorithm Parameter Exception e ) { e . print Stack Trace ( ) ; } catch ( No Such Algorithm Exception e1 ) { e1 . print Stack Trace ( ) ; } return null ; }
@ Suppress Warnings ( { STRING , STRING } ) private static Pipeline Op distinct Term Scan Join ( final Pipeline Op left , final List < NV > anns , Predicate pred , final Dataset Node dataset , final Long cutoff Limit Is Ignored , final Var Node distinct Term Scan Var , final Properties query Hints , final AST 2 B Op Context ctx ) { final I Variable distinct Var = distinct Term Scan Var . get Value Expression ( ) ; anns . add ( new NV ( Distinct Term Scan Op . Annotations . DISTINCT VAR , distinct Var ) ) ; final Constant < IV > mock Const = new Constant < IV > ( Term Id . mock IV ( VTE . URI ) ) ; final I Predicate mock Pred = pred . as Bound ( distinct Var , mock Const ) ; final SPO Key Order key Order = SPO Key Order . get Key Order ( mock Pred , ctx . is Quads ( ) ? NUM : NUM ) ; pred = ( Predicate ) pred . set Property ( I Predicate . Annotations . KEY ORDER , key Order ) ; anns . add ( new NV ( Pipeline Join . Annotations . PREDICATE , pred ) ) ; return apply Query Hints ( new Distinct Term Scan Op ( left Or Empty ( left ) , NV . as Map ( anns . to Array ( new NV [ anns . size ( ) ] ) ) ) , query Hints , ctx ) ; }
private String parse Name ( ) throws Jasper Exception { char ch = ( char ) reader . peek Char ( ) ; if ( Character . is Letter ( ch ) || ch == STRING || ch == STRING ) { String Builder buf = new String Builder ( ) ; buf . append ( ch ) ; reader . next Char ( ) ; ch = ( char ) reader . peek Char ( ) ; while ( Character . is Letter ( ch ) || Character . is Digit ( ch ) || ch == STRING || ch == STRING || ch == STRING || ch == STRING ) { buf . append ( ch ) ; reader . next Char ( ) ; ch = ( char ) reader . peek Char ( ) ; } return buf . to String ( ) ; } return null ; }
public static final String to Bit String ( double d [ ] ) { String Builder sb = new String Builder ( d . length ) ; for ( double b : d ) { sb . append ( ( int ) Math . round ( b ) ) ; } return sb . to String ( ) ; }
public static Byte Buffer convert To Signed 16 Bit Samples ( float [ ] samples ) { Byte Buffer converted = Byte Buffer . allocate ( samples . length * NUM ) ; converted . order ( Byte Order . LITTLE ENDIAN ) ; for ( float sample : samples ) { converted . put Short ( ( short ) ( sample * Short . MAX VALUE ) ) ; } return converted ; }
private void update IP Address ( String ip Address , Storage Port port ) { if ( null != ip Address && ! ip Address . equals Ignore Case ( port . get Port Network Id ( ) ) ) { port . set Ip Address ( ip Address ) ; } }
protected void expand All Paths ( Tree Path path , Tree Model tree Model ) { expand Path ( path ) ; final Object node = path . get Last Path Component ( ) ; final int n = tree Model . get Child Count ( node ) ; for ( int index = NUM ; index < n ; index ++ ) { final Object child = tree Model . get Child ( node , index ) ; expand All Paths ( path . path By Adding Child ( child ) ) ; } }
private String lock Random Namespace ( final boolean read Only ) { final int k = r . next Int ( ( int ) namespace Exist Counter . get ( ) ) ; int i = - NUM ; while ( BOOL ) { for ( Map . Entry < String , Read Write Lock > e : namespaces . entry Set ( ) ) { if ( namespace Exist Counter . get ( ) == NUM ) { throw new Runtime Exception ( STRING + read Only ) ; } i ++ ; if ( i < k ) { continue ; } final String namespace = e . get Key ( ) ; final Read Write Lock lock = e . get Value ( ) ; final Lock taken Lock ; { if ( read Only ) taken Lock = lock . read Lock ( ) ; else taken Lock = lock . write Lock ( ) ; taken Lock . lock ( ) ; } if ( namespaces . get ( namespace ) != lock ) { taken Lock . unlock ( ) ; continue ; } return namespace ; } } }
public void test Timed Invoke Any 3 ( ) throws Throwable { Count Down Latch latch = new Count Down Latch ( NUM ) ; Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new Array List < Callable < String > > ( ) ; l . add ( latch Awaiting String Task ( latch ) ) ; l . add ( null ) ; try { e . invoke Any ( l , MEDIUM DELAY MS , MILLISECONDS ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } latch . count Down ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }

void update Pressed ( Action Event e , boolean new Signal Group , boolean close ) { if ( cur Signal Group == null ) { if ( ! check New Names OK ( ) ) { return ; } } if ( ! check Valid Signal Mast ( ) ) { return ; } String u Name = user Name . get Text ( ) ; Signal Group g = check Names OK ( ) ; if ( g == null ) { return ; } cur Signal Group = g ; g . set User Name ( u Name ) ; initialize Included List ( ) ; set Signal Information ( g ) ; set Mast Appearance Information ( g ) ; g . set Signal Mast ( ( Signal Mast ) main Signal . get Selected Bean ( ) , main Signal . get Selected Display Name ( ) ) ; Signal Group Dirty = BOOL ; if ( close ) { finish Update ( ) ; } }
private Hash Map add Attr ( Svc Reg reg , Entry Class eclass , int fldidx , Object value ) { Hash Map [ ] attr Maps = ( Hash Map [ ] ) service By Attr . get ( eclass ) ; if ( attr Maps == null ) { attr Maps = new Hash Map [ eclass . get Num Fields ( ) ] ; service By Attr . put ( eclass , attr Maps ) ; } Hash Map map = attr Maps [ fldidx ] ; if ( map == null ) { map = new Hash Map ( NUM ) ; attr Maps [ fldidx ] = map ; } Array List regs = ( Array List ) map . get ( value ) ; if ( regs == null ) { regs = new Array List ( NUM ) ; map . put ( value , regs ) ; } else if ( regs . contains ( reg ) ) return map ; regs . add ( reg ) ; return map ; }
public Query String Decoder Util ( String uri ) { this ( uri , Charset . default Charset ( ) ) ; }
public static void show Error ( final Component parent , final String msg ) { J Option Pane . show Message Dialog ( is Iconified ( parent ) ? null : parent , msg , System . get Property ( DEFAULT WINDOW TITLE PROPERTY ) , J Option Pane . ERROR MESSAGE ) ; }
@ Override public void on Destroy ( ) { synchronized ( m Thread ) { m Ready = BOOL ; m Quiting = BOOL ; m Thread . notify ( ) ; } super . on Destroy ( ) ; }
private static Windows File Attributes from File Attribute Data ( long address , int reparse Tag ) { int file Attrs = unsafe . get Int ( address + OFFSETOF FILE ATTRIBUTE DATA ATTRIBUTES ) ; long creation Time = unsafe . get Long ( address + OFFSETOF FILE ATTRIBUTE DATA CREATETIME ) ; long last Access Time = unsafe . get Long ( address + OFFSETOF FILE ATTRIBUTE DATA LASTACCESSTIME ) ; long last Write Time = unsafe . get Long ( address + OFFSETOF FILE ATTRIBUTE DATA LASTWRITETIME ) ; long size = ( ( long ) ( unsafe . get Int ( address + OFFSETOF FILE ATTRIBUTE DATA SIZEHIGH ) ) << NUM ) + ( unsafe . get Int ( address + OFFSETOF FILE ATTRIBUTE DATA SIZELOW ) & NUM ) ; return new Windows File Attributes ( file Attrs , creation Time , last Access Time , last Write Time , size , reparse Tag , NUM , NUM , NUM ) ; }
public static final void write Map Xml ( Map val , Xml Serializer out , Write Map Callback callback ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { return ; } Set s = val . entry Set ( ) ; Iterator i = s . iterator ( ) ; while ( i . has Next ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; write Value Xml ( e . get Value ( ) , ( String ) e . get Key ( ) , out , callback ) ; } }
public final void fire Event ( Event event ) { event Handlers . fire Event ( event ) ; }
protected Completable Future < Query Response > query Local ( Query Entry entry ) { Completable Future < Query Response > future = new Completable Future < > ( ) ; sequence Query ( entry , future ) ; return future ; }
public static String create Resource Name ( String resource , Locale locale , boolean remove Extension ) { String resource Name = resource ; if ( remove Extension ) { if ( resource Name . ends With ( STRING ) ) { resource Name = resource Name . replace ( STRING , STRING ) ; } else if ( resource Name . ends With ( STRING ) ) { resource Name = resource Name . replace ( STRING , STRING ) ; } } if ( locale != null ) { if ( Util Validate . is Not Empty ( locale . to String ( ) ) ) { resource Name = resource Name + STRING + locale ; } } return resource Name ; }
public int write Annotation Set ( Annotation Set annotation Set ) { int off = data . position ( ) ; write Int ( annotation Set . annotation Offsets . length ) ; for ( int annotation Offset : annotation Set . annotation Offsets ) { write Int ( annotation Offset ) ; } return off ; }
private long to Long ( Inet Address inet Address ) { byte [ ] address = inet Address . get Address ( ) ; long result = NUM ; for ( int i = NUM ; i < address . length ; i ++ ) { result <<= NUM ; result |= address [ i ] & BYTE MASK ; } return result ; }
public boolean revision Contains Template Names ( int rev Id , List < String > template Names ) throws Wiki Api Exception { List < String > tpl List = get Template Names From Revision ( rev Id ) ; for ( String tpl : tpl List ) { for ( String template Name : template Names ) { if ( tpl . equals Ignore Case ( template Name ) ) { return BOOL ; } } } return BOOL ; }
public List < Generic Entry > retrieve All Mailbox Dump Requests ( Date from Date ) throws Apps For Your Domain Exception , Malformed URL Exception , IO Exception , Service Exception { String url = BASE URL + STRING + domain ; if ( from Date != null ) { url += STRING + DATE FORMAT . format ( from Date ) ; } return get All Pages ( new URL ( url ) , Generic Feed . class ) ; }
protected void draw Oval ( int x , int y , int w , int h , Color fill Color , Paint fill Paint , Color pen Color , boolean shadow ) { if ( fill Color != null || fill Paint != null ) { if ( shadow ) { g . set Color ( mx Constants . SHADOW COLOR ) ; g . fill Oval ( x + mx Constants . SHADOW OFFSETX , y + mx Constants . SHADOW OFFSETY , w , h ) ; } if ( fill Paint != null ) { g . set Paint ( fill Paint ) ; } else { g . set Color ( fill Color ) ; } g . fill Oval ( x , y , w , h ) ; } if ( pen Color != null ) { g . set Color ( pen Color ) ; g . draw Oval ( x , y , w , h ) ; } }
public static Result sudo ( long timeout , Pattern mask Filter , String ... args ) { String user Name = System . get Property ( STRING ) ; if ( user Name . equals ( STRING ) ) { return exec ( timeout , mask Filter , args ) ; } List < String > tmp List = new Array List ( Arrays . as List ( args ) ) ; tmp List . add ( NUM , STRING ) ; String [ ] new Array = tmp List . to Array ( new String [ tmp List . size ( ) ] ) ; return exec ( timeout , mask Filter , new Array ) ; }
public void dispatch To Events ( int node Handle , org . xml . sax . Content Handler ch ) throws org . xml . sax . SAX Exception { Tree Walker tree Walker = m walker ; Content Handler prev CH = tree Walker . get Content Handler ( ) ; if ( null != prev CH ) { tree Walker = new Tree Walker ( null ) ; } tree Walker . set Content Handler ( ch ) ; try { Node node = get Node ( node Handle ) ; tree Walker . traverse Fragment ( node ) ; } finally { tree Walker . set Content Handler ( null ) ; } }
public static Decompounded Word create From String ( String a Split ) { Decompounded Word s = new Decompounded Word ( ) ; String [ ] elems = a Split . split ( STRING ) ; for ( String string : elems ) { s . append Split Element ( Fragment . create From String ( string ) ) ; } return s ; }
public String app source path ( String app class ) { String filename = app class . replace ( STRING , STRING ) ; filename = filename . replace First ( STRING , STRING ) ; if ( filename . index Of ( STRING ) > NUM ) { filename = filename . substring ( NUM , filename . index Of ( STRING ) ) ; } return STRING + filename + STRING ; }
public void add Title Prefix ( String prfx ) { if ( ! title Prefix . contains ( prfx ) ) { title Prefix . add ( prfx ) ; fire Property Change ( TITLE PREFIX , null , title Prefix ) ; } }
public void send ( Set recipients , boolean multicast ) throws Interrupted Exception , Reply Exception { if ( Thread . interrupted ( ) ) { throw new Interrupted Exception ( ) ; } this . op = operation Type . DRAIN POOL ; Set recips = new Hash Set ( recipients ) ; Distributed Member me = origin Dm . get Distribution Manager Id ( ) ; if ( recips . contains ( me ) ) { recips . remove ( me ) ; } rp = new Reply Processor 21 ( origin Dm , recips ) ; processor Id = rp . get Processor Id ( ) ; set Recipients ( recips ) ; set Multicast ( multicast ) ; origin Dm . put Outgoing ( this ) ; rp . wait For Replies ( ) ; }
public static boolean are Regexp Modifiers Valid ( String flags ) { final int GROUP = NUM ; final int CASE INSENSITIVE = NUM ; final int MULTILINE = NUM ; int seen = NUM ; for ( int i = NUM , n = flags . length ( ) ; i < n ; ++ i ) { char flag = flags . char At ( i ) ; int flag Mask ; switch ( flag ) { case STRING : flag Mask = GROUP ; break ; case STRING : flag Mask = CASE INSENSITIVE ; break ; case STRING : flag Mask = MULTILINE ; break ; default : return BOOL ; } if ( ( seen & flag Mask ) != NUM ) { return BOOL ; } seen = seen | flag Mask ; } return BOOL ; }
public int find Engine By Road Number ( String road Number ) { if ( sys List != null ) { if ( ! road Number . equals ( road Number ) ) { return get Index ( NUM , road Number ) ; } int index = get Index ( index , road Number ) ; if ( index > NUM ) { return index ; } return get Index ( NUM , road Number ) ; } return - NUM ; }
@ Dotted Class Name @ Suppress FB Warnings ( STRING ) public static String to Dotted Class Name ( @ Slashed Class Name ( when = When . UNKNOWN ) String class Name ) { if ( class Name . index Of ( STRING ) >= NUM ) { return Descriptor Factory . canonicalize String ( class Name . replace ( STRING , STRING ) ) ; } return class Name ; }
public List < E > next ( ) { if ( num Left . equals ( total ) ) { num Left = num Left . subtract ( Big Integer . ONE ) ; return items ; } int temp ; int j = a . length - NUM ; while ( a [ j ] > a [ j + NUM ] ) { j -- ; } int k = a . length - NUM ; while ( a [ j ] > a [ k ] ) { k -- ; } temp = a [ k ] ; a [ k ] = a [ j ] ; a [ j ] = temp ; int r = a . length - NUM ; int s = j + NUM ; while ( r > s ) { temp = a [ s ] ; a [ s ] = a [ r ] ; a [ r ] = temp ; r -- ; s ++ ; } num Left = num Left . subtract ( Big Integer . ONE ) ; List < E > ans = new Array List < E > ( a . length ) ; for ( int index : a ) { ans . add ( items . get ( index ) ) ; } return ans ; }
public void register ( Location location ) { Integer old Size = Integer . value Of ( location Hash Table . size ( ) ) ; location Hash Table . put ( location . get Id ( ) , location ) ; int id = Integer . parse Int ( location . get Id ( ) ) ; if ( id > id ) { id = id ; } set Dirty And Fire Property Change ( LISTLENGTH CHANGED PROPERTY , old Size , Integer . value Of ( location Hash Table . size ( ) ) ) ; }
@ Override public void close ( ) throws IO Exception { if ( closed . compare And Set ( BOOL , BOOL ) ) { close ( BOOL ) ; } }
public synchronized void store Resource Config ( String cluster Name , Resource Type resource Type , Tungsten Properties resource Props ) throws Configuration Exception { if ( get Cluster Home ( ) == null ) { throw new Configuration Exception ( STRING + get Module Properties File Name ( Configuration Constants . TR PROPERTIES , get Cluster Home ( ) ) ) ; } String resource Dir = get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ; File resources = new File ( resource Dir ) ; if ( ! resources . is Directory ( ) ) { if ( resources . mkdirs ( ) ) { logger . info ( String . format ( STRING , resource Dir ) ) ; } else { String msg = String . format ( STRING , get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ) ; logger . error ( msg ) ; throw new Configuration Exception ( msg ) ; } } String out File Name = resources . get Absolute Path ( ) + File . separator + resource Props . get String ( STRING ) + STRING ; store ( resource Props , out File Name ) ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( m listenees . contains Key ( event Name ) ) { return BOOL ; } if ( m listenees . contains Key ( STRING ) && ( event Name . compare To ( STRING ) == NUM || event Name . compare To ( STRING ) == NUM || event Name . compare To ( STRING ) == NUM ) ) { return BOOL ; } if ( ( m listenees . contains Key ( STRING ) || m listenees . contains Key ( STRING ) ) && ( event Name . compare To ( STRING ) == NUM || event Name . compare To ( STRING ) == NUM ) ) { return BOOL ; } if ( m listenees . contains Key ( STRING ) && ( event Name . compare To ( STRING ) == NUM || event Name . compare To ( STRING ) == NUM || event Name . compare To ( STRING ) == NUM ) ) { return BOOL ; } if ( event Name . compare To ( STRING ) == NUM && ! ( m Filter instanceof Streamable Filter ) ) { return BOOL ; } return BOOL ; }
public static Vector 2 abs ( Vector 2 o ) { return new Vector 2 ( Math . abs ( o . x ) , Math . abs ( o . z ) ) ; }
public static Object invoke Static ( String clazz , String method Name , Class [ ] types , Object [ ] values , Object default Value ) { try { return invoke Static ( Class . for Name ( clazz ) , method Name , types , values ) ; } catch ( Class Not Found Exception e ) { return default Value ; } catch ( No Such Method Exception e ) { return default Value ; } }
void load Constants ( Prototype f ) throws IO Exception { int n = load Int ( ) ; Lua Value [ ] values = n > NUM ? new Lua Value [ n ] : NOVALUES ; for ( int i = NUM ; i < n ; i ++ ) { switch ( is . read Byte ( ) ) { case LUA TNIL : values [ i ] = Lua Value . NIL ; break ; case LUA TBOOLEAN : values [ i ] = ( NUM != is . read Unsigned Byte ( ) ? Lua Value . TRUE : Lua Value . FALSE ) ; break ; case LUA TINT : values [ i ] = Lua Integer . value Of ( load Int ( ) ) ; break ; case LUA TNUMBER : values [ i ] = load Number ( ) ; break ; case LUA TSTRING : values [ i ] = load String ( ) ; break ; default : throw new Illegal State Exception ( STRING ) ; } } f . k = values ; n = load Int ( ) ; Prototype [ ] protos = n > NUM ? new Prototype [ n ] : NOPROTOS ; for ( int i = NUM ; i < n ; i ++ ) protos [ i ] = load Function ( f . source ) ; f . p = protos ; }
public void init GUI ( ) { remove All ( ) ; try { URL url = Prop Utils . get Resource Or File Or URL ( this , forward Icon URL ) ; forward Icon = new Image Icon ( url ) ; url = Prop Utils . get Resource Or File Or URL ( this , forward Step Icon URL ) ; forward Step Icon = new Image Icon ( url ) ; url = Prop Utils . get Resource Or File Or URL ( this , backward Icon URL ) ; backward Icon = new Image Icon ( url ) ; url = Prop Utils . get Resource Or File Or URL ( this , backward Step Icon URL ) ; backward Step Icon = new Image Icon ( url ) ; url = Prop Utils . get Resource Or File Or URL ( this , pause Icon URL ) ; pause Icon = new Image Icon ( url ) ; } catch ( Malformed URL Exception murle ) { Debug . error ( STRING ) ; } catch ( Null Pointer Exception npe ) { Debug . error ( STRING ) ; npe . print Stack Trace ( ) ; } J Tool Bar jtb = new J Tool Bar ( ) ; jtb . set Floatable ( BOOL ) ; backward Button = new J Button ( backward Icon ) ; backward Button . set Tool Tip Text ( STRING ) ; backward Button . set Action Command ( Timer Status . TIMER BACKWARD ) ; backward Button . add Action Listener ( this ) ; jtb . add ( backward Button ) ; J Button button = new J Button ( backward Step Icon ) ; button . set Tool Tip Text ( STRING ) ; button . set Action Command ( Timer Status . TIMER STEP BACKWARD ) ; button . add Action Listener ( this ) ; jtb . add ( button ) ; button = new J Button ( forward Step Icon ) ; button . set Tool Tip Text ( STRING ) ; button . set Action Command ( Timer Status . TIMER STEP FORWARD ) ; button . add Action Listener ( this ) ; jtb . add ( button ) ; forward Button = new J Button ( forward Icon ) ; forward Button . set Tool Tip Text ( STRING ) ; forward Button . set Action Command ( Timer Status . TIMER FORWARD ) ; forward Button . add Action Listener ( this ) ; jtb . add ( forward Button ) ; add ( jtb ) ; }
public void add Mapping ( Matcher < Request > request Matcher , Response Source response Source ) { mappings . add First ( new Matcher Response Source Pair ( request Matcher , response Source ) ) ; }
private void init Primary Backup Maps ( ) { Map < UUID , Set < Integer > > tmp Prm = new Hash Map < > ( ) ; Map < UUID , Set < Integer > > tmp Bkp = new Hash Map < > ( ) ; for ( int parts Cnt = assignment . size ( ) , p = NUM ; p < parts Cnt ; p ++ ) { Map < UUID , Set < Integer > > tmp = tmp Prm ; Map < UUID , Set < Integer > > map = primary ; for ( Cluster Node node : assignment . get ( p ) ) { UUID id = node . id ( ) ; Set < Integer > set = tmp . get ( id ) ; if ( set == null ) { tmp . put ( id , set = new Hash Set < > ( ) ) ; map . put ( id , Collections . unmodifiable Set ( set ) ) ; } set . add ( p ) ; tmp = tmp Bkp ; map = backup ; } } }
@ Suppress Warnings ( STRING ) public static String [ ] split ( String original , String separator ) { nodes . remove All Elements ( ) ; int index = original . index Of ( separator ) ; while ( index >= NUM ) { nodes . add Element ( original . substring ( NUM , index ) ) ; original = original . substring ( index + separator . length ( ) ) ; index = original . index Of ( separator ) ; } nodes . add Element ( original ) ; String [ ] result = new String [ nodes . size ( ) ] ; if ( nodes . size ( ) > NUM ) { for ( int loop = NUM ; loop < nodes . size ( ) ; loop ++ ) { result [ loop ] = ( String ) nodes . element At ( loop ) ; } } return result ; }
public void move To End ( Instruction inst ) { Iterator < GCIR Map Element > iter = list . iterator ( ) ; while ( iter . has Next ( ) ) { GCIR Map Element new Ptr = iter . next ( ) ; if ( new Ptr . get Instruction ( ) == inst ) { iter . remove ( ) ; list . add ( new Ptr ) ; return ; } } throw new Optimizing Compiler Exception ( STRING + inst + STRING ) ; }
private void reinitialize ( Class < Presenter Type > ops Type , Required View Ops view ) throws java . lang . Instantiation Exception , Illegal Access Exception { m Presenter Instance = m State Maintainer . get ( ops Type . get Simple Name ( ) ) ; if ( m Presenter Instance == null ) { initialize ( ops Type , view ) ; } else { m Presenter Instance . on Configuration Changed ( view ) ; } }
public static String join ( String separator , List < String > strings ) { String Builder sb = new String Builder ( ) ; for ( Iterator < String > iter = strings . iterator ( ) ; iter . has Next ( ) ; ) { String s = iter . next ( ) ; sb . append ( s ) ; if ( iter . has Next ( ) ) sb . append ( separator ) ; } return sb . to String ( ) ; }
private static boolean is Format Playable ( Format format , String [ ] allowed Container Mime Types , boolean filter Hd Formats , int max Decodable Frame Size ) { if ( allowed Container Mime Types != null && ! Util . contains ( allowed Container Mime Types , format . mime Type ) ) { return BOOL ; } if ( filter Hd Formats && ( format . width >= NUM || format . height >= NUM ) ) { return BOOL ; } if ( format . width > NUM && format . height > NUM ) { if ( format . width * format . height > max Decodable Frame Size ) { return BOOL ; } } return BOOL ; }
private void schedule Settings Save ( ) { if ( ! m Loading Settings ) { if ( m Settings Save Pending . compare And Set ( BOOL , BOOL ) ) { m Thread Pool Manager . schedule Once ( new Settings Save Task ( ) , NUM , Time Unit . SECONDS ) ; } } }
public boolean is To Write ( ) { Iterator < Variable Value > i = variables . iterator ( ) ; while ( i . has Next ( ) ) { Variable Value v = i . next ( ) ; if ( v . is To Write ( ) ) { return BOOL ; } } return BOOL ; }
public void action Performed ( Action Event e ) { Action Map map = tab Pane . get Action Map ( ) ; if ( map != null ) { String action Key ; if ( e . get Source ( ) == scroll Forward Button ) { action Key = STRING ; } else { action Key = STRING ; } Action action = map . get ( action Key ) ; if ( action != null && action . is Enabled ( ) ) { action . action Performed ( new Action Event ( tab Pane , Action Event . ACTION PERFORMED , null , e . get When ( ) , e . get Modifiers ( ) ) ) ; } } }
@ Override public String to String No Weight ( int after Decimal Point ) { String Buffer text = new String Buffer ( ) ; for ( int i = NUM ; i < m Att Values . length ; i ++ ) { if ( i > NUM ) { text . append ( STRING ) ; } text . append ( to String ( i , after Decimal Point ) ) ; } return text . to String ( ) ; }
public static Integer to Ref ( int i ) { return Integer . value Of ( i ) ; }
public synchronized void remove Index Family ( I Path path ) { Array List to Remove = null ; Object [ ] container Paths = this . index Locations . key Table ; for ( int i = NUM , length = container Paths . length ; i < length ; i ++ ) { I Path container Path = ( I Path ) container Paths [ i ] ; if ( container Path == null ) continue ; if ( path . is Prefix Of ( container Path ) ) { if ( to Remove == null ) to Remove = new Array List ( ) ; to Remove . add ( container Path ) ; } } if ( to Remove != null ) for ( int i = NUM , length = to Remove . size ( ) ; i < length ; i ++ ) remove Index ( ( I Path ) to Remove . get ( i ) ) ; }
@ Override public void put All ( Map < ? extends K , ? extends V > m ) { try Presize ( m . size ( ) ) ; for ( Map . Entry < ? extends K , ? extends V > e : m . entry Set ( ) ) put Val ( e . get Key ( ) , e . get Value ( ) , BOOL ) ; }
public String build Query ( String [ ] projection In , String selection , String group By , String having , String sort Order , String limit ) { String [ ] projection = compute Projection ( projection In ) ; String Builder where = new String Builder ( ) ; boolean has Base Where Clause = m Where Clause != null && m Where Clause . length ( ) > NUM ; if ( has Base Where Clause ) { where . append ( m Where Clause . to String ( ) ) ; where . append ( STRING ) ; } if ( selection != null && selection . length ( ) > NUM ) { if ( has Base Where Clause ) { where . append ( STRING ) ; } where . append ( STRING ) ; where . append ( selection ) ; where . append ( STRING ) ; } return build Query String ( m Distinct , m Tables , projection , where . to String ( ) , group By , having , sort Order , limit ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int length ) throws IO Exception { int to Send = length ; int sent ; long start = System . current Time Millis ( ) ; while ( to Send > NUM ) { synchronized ( pseudo Tcp ) { sent = pseudo Tcp . send ( buffer , offset + length - to Send , to Send ) ; } if ( sent > NUM ) { to Send -= sent ; } else { try { logger . log ( Level . FINER , STRING ) ; synchronized ( write notify ) { if ( write Timeout > NUM ) { long elapsed = System . current Time Millis ( ) - start ; long left = write Timeout - elapsed ; if ( left <= NUM ) { IO Exception exc = new IO Exception ( STRING ) ; pseudo Tcp . closedown ( exc ) ; throw exc ; } write notify . wait ( left ) ; } else { write notify . wait ( ) ; } } logger . log ( Level . FINER , STRING + pseudo Tcp . get Available Send Buffer ( ) ) ; if ( exception != null ) { throw exception ; } } catch ( Interrupted Exception ex ) { if ( exception != null ) { throw new IO Exception ( STRING , exception ) ; } else { throw new IO Exception ( STRING , ex ) ; } } } } }
public static void copy Stream ( Input Stream input Stream , Output Stream output Stream , boolean close Out ) throws IO Exception { try { copy Bytes To Stream ( input Stream , output Stream , - NUM ) ; } finally { try { input Stream . close ( ) ; } finally { if ( close Out ) { output Stream . close ( ) ; } } } }
List < Isilon Event > filter Events ( List < Isilon Event > events ) { long most Recent Timestamp = latest Time Threshold ; List < Isilon Event > filtered Events = new Array List < Isilon Event > ( ) ; for ( Isilon Event event : events ) { long latest Time = event . get Latest Time ( ) ; if ( latest Time > latest Time Threshold ) { filtered Events . add ( event ) ; if ( latest Time > most Recent Timestamp ) { most Recent Timestamp = latest Time ; } } } most Recent Timestamp In Polling Cycle = most Recent Timestamp ; return filtered Events ; }
public static Point inverse Transform Point ( Affine Transform af , Point pt ) { Point 2 D src = new Point 2 D . Float ( pt . x , pt . y ) ; try { Point 2 D dest = af . inverse Transform ( src , null ) ; return new Point ( ( int ) Math . floor ( dest . get X ( ) ) , ( int ) Math . floor ( dest . get Y ( ) ) ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return new Point ( NUM , NUM ) ; } }
private void fill Resource ( ) { Key Name Pair pp = ( Key Name Pair ) field Resource Type . get Selected Item ( ) ; if ( pp == null ) return ; int S Resource Type ID = pp . get Key ( ) ; Key Name Pair default Value = null ; m loading = BOOL ; field Resource . remove All Items ( ) ; String sql = STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , S Resource Type ID ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { pp = new Key Name Pair ( rs . get Int ( NUM ) , rs . get String ( NUM ) ) ; if ( m m Assignment . get S Resource ID ( ) == pp . get Key ( ) ) default Value = pp ; field Resource . add Item ( pp ) ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( default Value != null ) field Resource . set Selected Item ( default Value ) ; m loading = BOOL ; }
@ Override public List < Work Order > search WO For MB ( final Map < String , Object > criteria Map ) { logger . info ( STRING ) ; final List < Work Order > filtered List = new Array List < Work Order > ( ) ; criteria Map . put ( ACTION FLAG , STRING ) ; for ( final Work Order workorder : search WO ( criteria Map ) ) if ( ! is Approval Limit Reached For WO ( workorder . get Id ( ) ) ) filtered List . add ( workorder ) ; return filtered List ; }
public Day ( Date time , Time Zone zone , Locale locale ) { Param Checks . null Not Permitted ( time , STRING ) ; Param Checks . null Not Permitted ( zone , STRING ) ; Param Checks . null Not Permitted ( locale , STRING ) ; Calendar calendar = Calendar . get Instance ( zone , locale ) ; calendar . set Time ( time ) ; int d = calendar . get ( Calendar . DAY OF MONTH ) ; int m = calendar . get ( Calendar . MONTH ) + NUM ; int y = calendar . get ( Calendar . YEAR ) ; this . serial Date = Serial Date . create Instance ( d , m , y ) ; peg ( calendar ) ; }
void drop Resource ( final R resource ) { final Thread tx = Thread . current Thread ( ) ; synchronized ( resource Queues ) { final Resource Queue < R , Thread > resource Queue = resource Queues . get ( resource ) ; if ( resource Queue == null ) { throw new Illegal Argument Exception ( STRING + resource ) ; } resource Queue . clear ( tx ) ; resource Queues . remove ( resource ) ; } }
public void sign ( Private Key key , String algorithm , String provider ) throws Certificate Exception , No Such Algorithm Exception , Invalid Key Exception , No Such Provider Exception , Signature Exception { try { if ( read Only ) throw new Certificate Encoding Exception ( STRING ) ; Signature sig Engine = null ; if ( ( provider == null ) || ( provider . length ( ) == NUM ) ) sig Engine = Signature . get Instance ( algorithm ) ; else sig Engine = Signature . get Instance ( algorithm , provider ) ; sig Engine . init Sign ( key ) ; alg Id = Algorithm Id . get ( sig Engine . get Algorithm ( ) ) ; Der Output Stream out = new Der Output Stream ( ) ; Der Output Stream tmp = new Der Output Stream ( ) ; info . encode ( tmp ) ; byte [ ] raw Cert = tmp . to Byte Array ( ) ; alg Id . encode ( tmp ) ; sig Engine . update ( raw Cert , NUM , raw Cert . length ) ; signature = sig Engine . sign ( ) ; tmp . put Bit String ( signature ) ; out . write ( Der Value . tag Sequence , tmp ) ; signed Cert = out . to Byte Array ( ) ; read Only = BOOL ; } catch ( IO Exception e ) { throw new Certificate Encoding Exception ( e . to String ( ) ) ; } }
public void schedule At Fixed Rate ( Timer Task task , Date when , long period ) { if ( period <= NUM || when . get Time ( ) < NUM ) { throw new Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) - System . current Time Millis ( ) ; schedule Impl ( task , delay , period , BOOL ) ; }
protected void stop Output Test ( ) { if ( test Running && out Test ) { out Timer . stop ( ) ; status Text 1 . set Text ( STRING + Integer . to String ( num Iterations ) + STRING ) ; status Text 1 . set Visible ( BOOL ) ; status Text 2 . set Text ( STRING ) ; status Text 2 . set Visible ( BOOL ) ; } }
public void insert Row ( int row Index , Row Spec row Spec ) { if ( row Index < NUM || row Index > get Row Count ( ) ) { throw new Index Out Of Bounds Exception ( STRING + row Index + STRING + get Row Count ( ) + STRING ) ; } row Specs . add ( row Index - NUM , row Spec ) ; shift Components Vertically ( row Index , BOOL ) ; adjust Group Indices ( row Group Indices , row Index , BOOL ) ; }
private void nuke Symbols ( ) { count = NUM ; Arrays . fill ( main Hash , NUM ) ; Arrays . fill ( main Names , null ) ; Arrays . fill ( coll List , null ) ; coll Count = NUM ; coll End = NUM ; }
public static Name from ( String ... pieces ) { List < Name Piece > name Pieces = new Array List < > ( ) ; for ( String piece : pieces ) { validate Lower Underscore ( piece ) ; name Pieces . add ( new Name Piece ( piece , Case Format . LOWER UNDERSCORE ) ) ; } return new Name ( name Pieces ) ; }
public static Date parse XS Date Time ( String date Time Str , Time Zone default TZ , Calendar Fields To Date Converter cal To Date Converter ) throws Date Parse Exception { Matcher m = PATTERN XS DATE TIME . matcher ( date Time Str ) ; if ( ! m . matches ( ) ) { throw new Date Parse Exception ( STRING + PATTERN XS DATE TIME ) ; } return parse Date Time parse Matcher ( m , default TZ , BOOL , cal To Date Converter ) ; }
public static String column Encode ( String string ) { if ( string != null ) { string = string . replace All ( STRING , STRING ) ; string = string . replace All ( STRING , STRING ) ; string = string . replace All ( ILLEGAL FILENAME CHARS REGEX , EMPTY ) ; string = string . length ( ) > NUM ? string . substring ( NUM , NUM ) : string ; string = string . to Lower Case ( ) ; } return string ; }
static boolean is Str White Space Char ( int c ) { switch ( c ) { case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : return BOOL ; default : return Character . get Type ( c ) == Character . SPACE SEPARATOR ; } }
public static void remove Log Filter ( Log Filter filter ) { if ( filter == null || filters == null || filters . is Empty ( ) ) { return ; } if ( filters . contains ( filter ) ) { filters . remove ( filter ) ; } }
protected void remove Datasets ( int [ ] indices ) { int i ; if ( indices == null ) { m Model Datasets . remove All Elements ( ) ; } else { for ( i = indices . length - NUM ; i >= NUM ; i -- ) m Model Datasets . remove ( indices [ i ] ) ; } set Modified ( BOOL ) ; }
public void fill Combo Box ( boolean restore ) { if ( restore && m temp Data != null ) { Object obj = m selected Object ; p data . clear ( ) ; p data = new Array List < Object > ( m temp Data . length ) ; for ( int i = NUM ; i < m temp Data . length ; i ++ ) p data . add ( m temp Data [ i ] ) ; m temp Data = null ; if ( obj == null && p data . size ( ) > NUM ) obj = p data . get ( NUM ) ; set Selected Item ( obj ) ; fire Contents Changed ( this , NUM , p data . size ( ) ) ; return ; } if ( p data != null ) fill Combo Box ( is Mandatory ( ) , BOOL , BOOL , BOOL ) ; }
public void remove Assigned Virtual Arrays ( Set < String > virtual Array UR Is ) { if ( ( virtual Array UR Is != null ) && ( ! virtual Array UR Is . is Empty ( ) ) && ( assigned Virtual Arrays != null ) ) { Hash Set < String > remove Virtual Arrays = new Hash Set < String > ( ) ; remove Virtual Arrays . add All ( virtual Array UR Is ) ; assigned Virtual Arrays . remove All ( remove Virtual Arrays ) ; update Virtual Array Tags ( ) ; } }
@ Override public Env Var add New Env Var ( String name , Class < ? > type , String value ) { Env Var env Var = null ; if ( ! exist ( name ) ) { env Var = new Env Var ( name , type , BOOL ) ; env Var . set Value ( value ) ; env Var List . add ( env Var ) ; } return env Var ; }
public void remove From Dragging Connections ( Block root Block ) { if ( m Pending Drag == null ) { return ; } m Temp Connections . clear ( ) ; root Block . get All Connections Recursive ( m Temp Connections ) ; for ( int i = NUM ; i < m Temp Connections . size ( ) ; i ++ ) { Connection conn = m Temp Connections . get ( i ) ; m Dragged Connections . remove ( conn ) ; conn . set Drag Mode ( BOOL ) ; } }
public static < T > List < T > as List ( T ... values ) { if ( values == null ) { return new Array List < T > ( NUM ) ; } else { return new Array List < T > ( Arrays . as List ( values ) ) ; } }
public Collection < Graph Node > compute Successor Nodes ( ) { Collection < Graph Node > result = Lists . new Array List ( ) ; for ( Graph Edge edge : get Forward Edges ( ) ) { result . add ( edge . get Tail ( ) ) ; } for ( Graph Edge edge : get Reverse Edges ( ) ) { result . add ( edge . get Head ( ) ) ; } return result ; }
public void add Custom Catalog ( ) { custom Catalogs . add ( new Custom Catalog Entry ( Constants . CUSTOMCATALOG DEFAULT TITLE , Constants . CUSTOMCATALOG DEFAULT SEARCH , BOOL ) ) ; fire Table Changed Event ( new Table Model Event ( this ) ) ; }
public Pooled Executor With DM Stats ( Blocking Queue < Runnable > q , int pool Size , Thread Factory tf ) { this ( q , pool Size , null , tf ) ; }
private void create Pre Streaming Tags ( int timestamp , boolean clear ) { log . debug ( STRING ) ; if ( clear ) { first Tags . clear ( ) ; } I Tag tag = null ; Io Buffer body = null ; if ( has Video ) { body = Io Buffer . allocate ( NUM ) ; body . set Auto Expand ( BOOL ) ; body . put ( PREFIX VIDEO CONFIG FRAME ) ; if ( video Decoder Bytes != null ) { body . put ( video Decoder Bytes ) ; } tag = new Tag ( Io Constants . TYPE VIDEO , timestamp , body . position ( ) , null , NUM ) ; body . flip ( ) ; tag . set Body ( body ) ; first Tags . add ( tag ) ; } if ( has Audio ) { body = Io Buffer . allocate ( NUM ) ; body . set Auto Expand ( BOOL ) ; body . put ( new byte [ ] { ( byte ) NUM , ( byte ) NUM } ) ; if ( audio Decoder Bytes != null ) { body . put ( audio Decoder Bytes ) ; } else { body . put ( AUDIO CONFIG FRAME AAC LC ) ; } body . put ( ( byte ) NUM ) ; tag = new Tag ( Io Constants . TYPE AUDIO , timestamp , body . position ( ) , null , tag . get Body Size ( ) ) ; body . flip ( ) ; tag . set Body ( body ) ; first Tags . add ( tag ) ; } }
public boolean swap Children ( @ Non Null Display Base child 1 , @ Non Null Display Base child 2 ) { int child Index 1 = m Display List . index Of ( child 1 ) ; int child Index 2 = m Display List . index Of ( child 2 ) ; if ( child Index 1 == - NUM || child Index 2 == - NUM ) { return BOOL ; } remove Child At ( child Index 1 ) ; add Child At ( child Index 1 , child 2 ) ; remove Child At ( child Index 2 ) ; add Child At ( child Index 2 , child 1 ) ; return BOOL ; }
public void column Selection Changed ( List Selection Event e ) { if ( e . get Value Is Adjusting ( ) ) { return ; } List Selection Model selection Model = ( List Selection Model ) e . get Source ( ) ; Data Set data Set = get Data Set ( ) ; data Set . clear Selection ( ) ; if ( ! get Row Selection Allowed ( ) ) { for ( int i = NUM ; i < data Set . get Num Columns ( ) ; i ++ ) { if ( selection Model . is Selected Index ( i + NUM ) ) { data Set . set Selected ( data Set . get Variable ( i ) , BOOL ) ; } } } }
public void add Muted Mac ( final String mac , final Date mute Till ) { if ( is Mac Muted ( mac ) ) { remove Muted Mac ( mac ) ; } Timestamp mute Till Ts = null ; if ( mute Till != null ) { mute Till Ts = new Timestamp ( mute Till . get Time ( ) ) ; } s logger . fine ( STRING + mac ) ; final Connection con = Database . get Connection ( ) ; try { final Prepared Statement ps = con . prepare Statement ( STRING ) ; ps . set String ( NUM , mac ) ; ps . set Timestamp ( NUM , mute Till Ts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final SQL Exception sqle ) { if ( sqle . get Error Code ( ) == NUM ) { s logger . info ( STRING + mac + STRING + sqle . get Message ( ) ) ; return ; } s logger . log ( Level . SEVERE , STRING + mac , sqle ) ; throw new Illegal State Exception ( sqle . get Message ( ) ) ; } finally { Db Util . close Connection ( con ) ; } }
public void consume All ( long timeout , Time Unit unit ) throws Timeout Exception { final long stop Time = System . current Time Millis ( ) + unit . to Millis ( timeout ) ; while ( System . current Time Millis ( ) < stop Time ) { Event next Event = queue . poll ( ) ; if ( next Event != null ) { Testing . print ( STRING + next Event ) ; consumed Events . accept ( next Event ) ; } } }
private void show Flags Dialog ( ) { int [ ] old Indices = flags List . get Selected Indices ( ) ; String [ ] buttons = { STRING , STRING } ; int result = J Option Pane . show Option Dialog ( tool Window Content , flags List , STRING , J Option Pane . YES NO CANCEL OPTION , J Option Pane . PLAIN MESSAGE , null , buttons , buttons [ NUM ] ) ; if ( result != NUM ) { flags List . set Selected Indices ( old Indices ) ; } else { if ( flags List . get Selected Indices ( ) . length > NUM && flags List . is Selected Index ( NUM ) ) { flags List . remove Selection Interval ( NUM , NUM ) ; } update Flags Text Field ( ) ; } }
public static int rand Exponential ( final int mean ) { return ( int ) ( - mean * Math . log ( rand . next Double ( ) ) ) ; }
public O Vector ( int c ) { vector = new Object [ Math . max ( default Capacity , c ) ] ; }
public void process Invite ( Request Event request Event , Server Transaction server Transaction ) { final Request request = request Event . get Request ( ) ; final Sip Provider sip Provider = ( Sip Provider ) request Event . get Source ( ) ; Server Transaction st = server Transaction ; try { if ( st == null ) { st = sip Provider . get New Server Transaction ( request ) ; } sip Provider . get New Dialog ( st ) ; final String to Tag = STRING + System . nano Time ( ) ; Response response = message Factory . create Response ( Response . RINGING , request ) ; To Header to Header = ( To Header ) response . get Header ( To Header . NAME ) ; to Header . set Tag ( to Tag ) ; st . send Response ( response ) ; response = message Factory . create Response ( Response . OK , request ) ; final Address address = address Factory . create Address ( STRING + my Address + STRING + my Port + STRING ) ; final Contact Header contact Header = header Factory . create Contact Header ( address ) ; response . add Header ( contact Header ) ; to Header = ( To Header ) response . get Header ( To Header . NAME ) ; to Header . set Tag ( to Tag ) ; st . send Response ( response ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } }
public Grid Tcp Rest Nio Listener ( Ignite Logger log , Grid Tcp Rest Protocol proto , Grid Rest Protocol Handler hnd , Grid Kernal Context ctx ) { memcached Lsnr = new Grid Tcp Memcached Nio Listener ( log , hnd , ctx ) ; this . log = log ; this . proto = proto ; this . hnd = hnd ; }
protected boolean read Send Delay ( ) { try { send Delay = Integer . parse Int ( send Delay Field . get Text ( ) ) ; } catch ( Exception e ) { status Text 1 . set Text ( rb . get String ( STRING ) ) ; status Text 1 . set Visible ( BOOL ) ; send Delay = NUM ; error In Status 1 = BOOL ; reset Notes 2 ( ) ; return ( BOOL ) ; } if ( send Delay < NUM ) { status Text 1 . set Text ( rb . get String ( STRING ) ) ; status Text 1 . set Visible ( BOOL ) ; send Delay = NUM ; error In Status 1 = BOOL ; reset Notes 2 ( ) ; return ( BOOL ) ; } if ( send Delay > NUM ) { status Text 1 . set Text ( rb . get String ( STRING ) ) ; status Text 1 . set Visible ( BOOL ) ; send Delay = NUM ; error In Status 1 = BOOL ; reset Notes 2 ( ) ; return ( BOOL ) ; } return BOOL ; }
static int measure Indentation Units ( I Document document , int line Of Invocation Offset , int line Offset , I Java Project project ) throws Bad Location Exception { Map < ? , ? > options = project . get Options ( BOOL ) ; String line Text = document . get ( line Offset , document . get Line Length ( line Of Invocation Offset ) ) ; int indentation Units = Indent Manipulation . measure Indent Units ( line Text , Indent Manipulation . get Tab Width ( options ) , Indent Manipulation . get Indent Width ( options ) ) ; return indentation Units ; }
private static Integer parse Int ( final String value ) { try { return Integer . parse Int ( value ) ; } catch ( Number Format Exception e ) { return null ; } }
private boolean process Mouse Event ( Mouse Event e ) { int id = e . get ID ( ) ; Component mouse Over = native Container . get Mouse Event Target ( e . get X ( ) , e . get Y ( ) , Container . INCLUDE SELF ) ; track Mouse Enter Exit ( mouse Over , e ) ; Component met = mouse Event Target . get ( ) ; if ( ! is Mouse Grab ( e ) && id != Mouse Event . MOUSE CLICKED ) { met = ( mouse Over != native Container ) ? mouse Over : null ; mouse Event Target = new Weak Reference < > ( met ) ; } if ( met != null ) { switch ( id ) { case Mouse Event . MOUSE ENTERED : case Mouse Event . MOUSE EXITED : break ; case Mouse Event . MOUSE PRESSED : retarget Mouse Event ( met , id , e ) ; break ; case Mouse Event . MOUSE RELEASED : retarget Mouse Event ( met , id , e ) ; break ; case Mouse Event . MOUSE CLICKED : if ( mouse Over == met ) { retarget Mouse Event ( mouse Over , id , e ) ; } break ; case Mouse Event . MOUSE MOVED : retarget Mouse Event ( met , id , e ) ; break ; case Mouse Event . MOUSE DRAGGED : if ( is Mouse Grab ( e ) ) { retarget Mouse Event ( met , id , e ) ; } break ; case Mouse Event . MOUSE WHEEL : if ( event Log . is Loggable ( Platform Logger . Level . FINEST ) && ( mouse Over != null ) ) { event Log . finest ( STRING + mouse Over . get Name ( ) + STRING + mouse Over . get Class ( ) ) ; } retarget Mouse Event ( mouse Over , id , e ) ; break ; } if ( id != Mouse Event . MOUSE WHEEL ) { e . consume ( ) ; } } return e . is Consumed ( ) ; }
@ Nullable private boolean should Align Field In Columns ( @ Not Null AST Node child ) { if ( ! my Settings . ALIGN GROUP FIELD DECLARATIONS ) { return BOOL ; } I Element Type child Type = child . get Element Type ( ) ; AST Node previous Node = Formatter Util . get Previous Non Whitespace Sibling ( child ) ; if ( child Type == Java Token Type . IDENTIFIER && ( previous Node == null || previous Node . get Element Type ( ) == Java Token Type . COMMA ) ) { return BOOL ; } return BOOL ; }
@ Override public boolean on Touch Event ( Motion Event event ) { if ( get Interaction Mode ( ) == DRAW MODE ) return on Touch Draw Mode ( event ) ; else if ( get Interaction Mode ( ) == SELECT MODE ) return on Touch Select Mode ( event ) ; else if ( get Interaction Mode ( ) == ROTATE MODE ) return on Touch Rotate Mode ( event ) ; else return on Touch Locked Mode ( event ) ; }
public synchronized void add Batch Clusterer Listener ( Batch Clusterer Listener cl ) { m batch Clusterer Listeners . add Element ( cl ) ; }
public Held Locks Token refresh ( long expiration Date Ms ) { return new Held Locks Token ( token Id , client , creation Date Ms , expiration Date Ms , lock Map , lock Timeout , version Id ) ; }
void add Known Object ( Parse Object object ) { synchronized ( mutex ) { known Objects . add ( object ) ; } }
static Bytes Store < ? , Byte Buffer > wrap ( @ Not Null Byte Buffer bb ) { return bb . is Direct ( ) ? Native Bytes Store . wrap ( bb ) : Heap Bytes Store . wrap ( bb ) ; }
public Json Value to Json ( ) { Json Value base Value = super . to Json ( ) ; base Value . add ( SERVICE QNAME , service Q Name != null ? service Q Name . to String ( ) : null ) ; base Value . add ( PORT QNAME , port Q Name != null ? port Q Name . to String ( ) : null ) ; base Value . add ( WSDL LOCATION , wsdl Location ) ; base Value . add ( CUSTOM WSDL LOCATION , custom Wsdl Location ) ; base Value . add ( CUSTOM PORT QNAME , custom Port Q Name != null ? custom Port Q Name . to String ( ) : null ) ; base Value . add ( CUSTOM SERVICE QNAME , custom Service Q Name != null ? custom Service Q Name . to String ( ) : null ) ; base Value . add ( AM DEPLOYMENT URL , am Deployment Url ) ; return base Value ; }
public void before Insert ( int index , Object element ) { if ( index > size || index < NUM ) throw new Index Out Of Bounds Exception ( STRING + index + STRING + size ) ; ensure Capacity ( size + NUM ) ; System . arraycopy ( elements , index , elements , index + NUM , size - index ) ; elements [ index ] = element ; size ++ ; }
public void clear ( ) { Grid Unsafe . copy Memory ( spine Empty , INT ARR OFF , spine , INT ARR OFF , spine Empty . length << NUM ) ; Grid Unsafe . copy Memory ( next Empty , INT ARR OFF , next , INT ARR OFF , next Empty . length << NUM ) ; Arrays . fill ( objs , null ) ; size = NUM ; }
public Sided Plane ( final Vector p , final Vector A , final Vector B ) { super ( A , B ) ; sig Num = Math . signum ( evaluate ( p ) ) ; if ( sig Num == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
protected void remove Service Listener ( SMS Entry Update Listener update Listener ) { service Objects . remove ( update Listener ) ; if ( service Objects . is Empty ( ) ) { subscription . cancel ( ) ; } }
public static void register Reportable Object ( Reportable obj ) { report Objects . add ( obj ) ; }
public static void assert End Of Output Expected To Contain ( String end Marker , String expected String , File log ) { String r = read Logfile ( log ) ; int idx = r . index Of ( end Marker ) ; if ( idx == - NUM ) fail ( STRING + end Marker + STRING + expected String + STRING ) ; String x = r . substring ( idx ) ; assert Expected Output Contains ( expected String , x ) ; }
public boolean add ( String classname ) { String pkgname ; Hash Set < String > names ; classname = clean Up ( classname ) ; pkgname = extract Package ( classname ) ; if ( ! m Cache . contains Key ( pkgname ) ) { m Cache . put ( pkgname , new Hash Set < String > ( ) ) ; } names = m Cache . get ( pkgname ) ; return names . add ( classname ) ; }
public void test Completed Stage ( ) { Atomic Integer x = new Atomic Integer ( NUM ) ; Atomic Reference < Throwable > r = new Atomic Reference < Throwable > ( ) ; Completion Stage < Integer > f = Completable Future . completed Stage ( NUM ) ; f . when Complete ( null ) ; assert Equals ( x . get ( ) , NUM ) ; assert Null ( r . get ( ) ) ; }
@ Override public void print Component ( Graphics gr ) { Graphics 2 D g = ( Graphics 2 D ) gr ; g . set Rendering Hint ( Rendering Hints . KEY ALPHA INTERPOLATION , Rendering Hints . VALUE ALPHA INTERPOLATION QUALITY ) ; g . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g . set Rendering Hint ( Rendering Hints . KEY STROKE CONTROL , Rendering Hints . VALUE STROKE NORMALIZE ) ; g . set Rendering Hint ( Rendering Hints . KEY FRACTIONALMETRICS , Rendering Hints . VALUE FRACTIONALMETRICS ON ) ; g . set Rendering Hint ( Rendering Hints . KEY INTERPOLATION , Rendering Hints . VALUE INTERPOLATION BICUBIC ) ; g . set Rendering Hint ( Rendering Hints . KEY RENDERING , Rendering Hints . VALUE RENDER QUALITY ) ; g . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; draw Drawing ( g ) ; }
public void class Loader Destroy ( Dynamic Class Loader loader ) { Object resource = resource Ref . get ( ) ; if ( resource == null ) return ; Method destroy = Close Listener . get Destroy Method ( resource . get Class ( ) ) ; if ( destroy == null ) return ; try { destroy . invoke ( resource , ( Object [ ] ) null ) ; } catch ( Throwable e ) { log . log ( Level . WARNING , e . to String ( ) , e ) ; } }
public boolean delete Attachment Point ( long sw , short port ) { Attachment Point ap = new Attachment Point ( sw , port , NUM ) ; if ( this . old A Ps != null ) { Array List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; ap List . add All ( this . old A Ps ) ; int index = ap List . index Of ( ap ) ; if ( index > NUM ) { ap List . remove ( index ) ; this . old A Ps = ap List ; } } if ( this . attachment Points != null ) { Array List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; ap List . add All ( this . attachment Points ) ; int index = ap List . index Of ( ap ) ; if ( index > NUM ) { ap List . remove ( index ) ; this . attachment Points = ap List ; return BOOL ; } } return BOOL ; }
public boolean is Simple Type Or Simple Object ( final Field field ) { Class < ? > type = field . get Type ( ) ; boolean simple Type = ( type . is Assignable From ( Short . class ) || type . is Assignable From ( Short . TYPE ) || type . is Assignable From ( Integer . class ) || type . is Assignable From ( Integer . TYPE ) || type . is Assignable From ( Float . class ) || type . is Assignable From ( Float . TYPE ) || type . is Assignable From ( Double . class ) || type . is Assignable From ( Double . TYPE ) || type . is Assignable From ( Long . class ) || type . is Assignable From ( Long . TYPE ) || type . is Assignable From ( Byte . class ) || type . is Assignable From ( Byte . TYPE ) || type . is Assignable From ( Character . class ) || type . is Assignable From ( Character . TYPE ) || type . is Assignable From ( Boolean . class ) || type . is Assignable From ( Boolean . TYPE ) || type . is Assignable From ( String . class ) ) || type . is Enum ( ) ; return simple Type ; }
public synchronized long total Recover Bytes ( ) { long total = NUM ; for ( File file : file Details . values ( ) ) { if ( file . reused ( ) == BOOL ) { total += file . length ( ) ; } } return total ; }
@ Override @ Timed public Assignment assign User ( Assignment assignment , Experiment experiment , Date date ) { Assignment new assignment = null ; if ( assign User To Old ) { new assignment = assign User To Old ( assignment , date ) ; } if ( assign User To New ) { new assignment = assign User To Look Up ( assignment , date ) ; } boolean count Up = BOOL ; assignments Count Executor . execute ( new Assignment Count Envelope ( assignments Repository , experiment Repository , db Repository , experiment , assignment , count Up , event Log , date , assign User To Export , assign Bucket Count ) ) ; index User To Experiment ( assignment ) ; index User To Bucket ( assignment ) ; index Experiments To User ( assignment ) ; return new assignment ; }
private void validate Cloumns ( Map < String , Object > column Name To Type Map ) { if ( column Name To Type Map == null ) { throw new Illegal Argument Exception ( STRING ) ; } for ( Map . Entry < String , Object > entry : column Name To Type Map . entry Set ( ) ) { Object obj Value = entry . get Value ( ) ; if ( obj Value == null ) { throw new Illegal Argument Exception ( STRING + entry . get Key ( ) + STRING ) ; } if ( obj Value instanceof Class < ? > ) { continue ; } if ( obj Value instanceof String ) { try { entry . set Value ( Class . for Name ( ( String ) obj Value ) ) ; } catch ( Class Not Found Exception e ) { throw new Illegal Argument Exception ( STRING , e ) ; } } } }
public void thread Dump ( ) { if ( can Dump Locks ) { if ( tmbean . is Object Monitor Usage Supported ( ) && tmbean . is Synchronizer Usage Supported ( ) ) { dump Thread Info With Locks ( ) ; } } else { dump Thread Info ( ) ; } }
private void check Stop ( ) { if ( m Can Process Audio && m Output . is Running ( ) && m Output . available ( ) >= m Buffer Stop Threshold ) { m Output . drain ( ) ; m Output . stop ( ) ; } }
private boolean matches Entity Type Filter ( Metadata Reader reader , Metadata Reader Factory reader Factory ) throws IO Exception { for ( Type Filter filter : ENTITY TYPE FILTERS ) { if ( filter . match ( reader , reader Factory ) ) { return BOOL ; } } return BOOL ; }
private I Status run Safely ( I Progress Monitor monitor ) throws Exception { monitor . begin Task ( null , NUM ) ; monitor . sub Task ( NLS . bind ( Messages . Connecting Source , get Source URL ( ) ) ) ; URL url = new URL ( source URL ) ; URL Connection connection = url . open Connection ( ) ; set URL Connection ( connection ) ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; setup Connection ( connection ) ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; connection . connect ( ) ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; I Status consumed = validate Connection ( connection ) ; if ( consumed != null ) return consumed ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; int length = connection . get Content Length ( ) ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; Input Stream source Stream = connection . get Input Stream ( ) ; try { if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; monitor . sub Task ( NLS . bind ( Messages . Initializing Target , get Target Path ( ) ) ) ; Output Stream target Stream = target . open Output Stream ( ) ; if ( monitor . is Canceled ( ) ) return cancel Status ( ) ; try { source Stream = new Monitored Input Stream ( source Stream , monitor ) ; target Stream = new Monitored Output Stream ( target Stream , monitor ) ; monitor . sub Task ( Messages . Transfering Data ) ; transfer ( source Stream , target Stream , new Sub Progress Monitor ( monitor , NUM ) , length ) ; set URL Connection ( null ) ; monitor . done ( ) ; return new Status ( I Status . OK , plugin Id , NLS . bind ( Messages . Download Finished , get Source URL ( ) , get Target Path ( ) ) ) ; } finally { try { target Stream . close ( ) ; } catch ( IO Exception ignore ) { } } } finally { try { source Stream . close ( ) ; } catch ( IO Exception ignore ) { } } }
public boolean has Invoices ( ) { boolean ret Value = BOOL ; String sql = STRING ; Prepared Statement pstmt = null ; try { pstmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; pstmt . set Int ( NUM , get ID ( ) ) ; Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { if ( rs . get Int ( NUM ) > NUM ) ret Value = BOOL ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { s log . log ( Level . SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { pstmt = null ; } return ret Value ; }
public static String check Path Ending ( String path ) { path . replace ( STRING , STRING ) ; if ( path . ends With ( STRING ) ) return path ; else return path + STRING ; }
public void about ( ) { Web Medium Config config = null ; if ( launch Type == Launch Type . Bot ) { config = new Instance Config ( ) ; } else if ( launch Type == Launch Type . Forum ) { config = new Forum Config ( ) ; } else if ( launch Type == Launch Type . Channel ) { config = new Channel Config ( ) ; } config . id = launch Instance Id ; config . name = launch Instance Name ; Http Action action = new Http Fetch Action ( this , config , BOOL ) ; action . execute ( ) ; }
private void update NFSAC Ls In DB ( Nfs ACL Update Params param , File Share fs , File Device Input Output args ) { try { List < Nfs ACE > ace Add = param . get Aces To Add ( ) ; if ( ace Add != null && ! ace Add . is Empty ( ) ) { for ( Nfs ACE ace : ace Add ) { NFS Share ACL db Nfs Acl = new NFS Share ACL ( ) ; db Nfs Acl . set Id ( URI Util . create Id ( NFS Share ACL . class ) ) ; copy To Persist Nfs ACL ( ace , db Nfs Acl , fs , args ) ; log . info ( STRING , db Nfs Acl ) ; db Client . create Object ( db Nfs Acl ) ; } } List < Nfs ACE > ace Modify = param . get Aces To Modify ( ) ; if ( ace Modify != null && ! ace Modify . is Empty ( ) ) { for ( Nfs ACE ace : ace Modify ) { NFS Share ACL db Nfs Acl = new NFS Share ACL ( ) ; copy To Persist Nfs ACL ( ace , db Nfs Acl , fs , args ) ; NFS Share ACL db Nfs Acl Temp = get Existing Nfs Acl From DB ( db Nfs Acl , args . get File Operation ( ) ) ; if ( db Nfs Acl Temp != null ) { db Nfs Acl . set Id ( db Nfs Acl Temp . get Id ( ) ) ; log . info ( STRING , db Nfs Acl ) ; db Client . update Object ( db Nfs Acl ) ; } } } List < Nfs ACE > ace Delete = param . get Aces To Delete ( ) ; if ( ace Delete != null && ! ace Delete . is Empty ( ) ) { for ( Nfs ACE ace : ace Delete ) { NFS Share ACL db Nfs Acl = new NFS Share ACL ( ) ; copy To Persist Nfs ACL ( ace , db Nfs Acl , fs , args ) ; NFS Share ACL db Nfs Acl Temp = get Existing Nfs Acl From DB ( db Nfs Acl , args . get File Operation ( ) ) ; if ( db Nfs Acl Temp != null ) { db Nfs Acl . set Id ( db Nfs Acl Temp . get Id ( ) ) ; db Nfs Acl . set Inactive ( BOOL ) ; log . info ( STRING , db Nfs Acl ) ; db Client . update Object ( db Nfs Acl ) ; } } } } catch ( Exception e ) { log . error ( STRING , e ) ; } }
private static void expand Path ( final Evidence Builder fs Log , final String path , final int depth , boolean save First ) { if ( Cfg . DEBUG ) { Check . requires ( depth > NUM , STRING ) ; } if ( Cfg . DEBUG ) { Check . requires ( path != null , STRING ) ; } if ( Cfg . DEBUG ) { Check . requires ( path == STRING || ! path . ends With ( STRING ) , STRING ) ; } if ( Cfg . DEBUG ) { Check . requires ( ! path . ends With ( STRING ) , STRING ) ; } if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + path + STRING + depth ) ; } final File dir = new File ( path ) ; if ( dir . is Directory ( ) ) { if ( save First ) { Protocol . save Filesystem Log ( fs Log , path ) ; } final String [ ] files = dir . list ( ) ; if ( files == null ) { return ; } for ( final String file : files ) { String d Path = path + STRING + file ; if ( d Path . starts With ( STRING ) ) { d Path = d Path . substring ( NUM ) ; } if ( d Path . index Of ( String Utils . chomp ( Path . hidden ( ) , STRING ) ) >= NUM ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + STRING + d Path ) ; } continue ; } if ( ! black List Dir . contains ( d Path ) ) { final boolean is Dir = Protocol . save Filesystem Log ( fs Log , d Path ) ; if ( is Dir && depth > NUM ) { expand Path ( fs Log , d Path , depth - NUM , BOOL ) ; } } else { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING , d Path ) ; } } } } }
private boolean on Queue Buffer Success ( Record Buffer < R > buffer , long elapsed ) { queued Records += buffer . size Records ( ) ; queued Bytes += buffer . size Bytes With Overhead ( ) ; total Queue Wait Time Millis . add And Get ( elapsed ) ; not Empty . signal ( ) ; return BOOL ; }
private void add To Expression ( String value ) { if ( value == null ) { return ; } String selected Text = current Expression . get Selected Text ( ) ; if ( selected Text != null && selected Text . length ( ) > NUM ) { if ( value . ends With ( STRING ) ) { int selection Start = current Expression . get Selection Start ( ) ; int selection End = current Expression . get Selection End ( ) ; String text = current Expression . get Text ( ) ; String first Part = text . substring ( NUM , selection Start ) ; String last Part = text . substring ( selection End ) ; current Expression . set Text ( first Part + value + last Part ) ; int length For Caret Position = value . length ( ) ; if ( value . ends With ( STRING ) ) { length For Caret Position -- ; } current Expression . set Caret Position ( selection Start + length For Caret Position ) ; add To Expression ( selected Text ) ; current Expression . set Caret Position ( current Expression . get Caret Position ( ) + NUM ) ; validate Expression ( ) ; request Expression Focus ( ) ; } else { int selection Start = current Expression . get Selection Start ( ) ; int selection End = current Expression . get Selection End ( ) ; String text = current Expression . get Text ( ) ; String first Part = text . substring ( NUM , selection Start ) ; String last Part = text . substring ( selection End ) ; current Expression . set Text ( first Part + value + last Part ) ; int length For Caret Position = value . length ( ) ; if ( value . ends With ( STRING ) ) { length For Caret Position -- ; } current Expression . set Caret Position ( selection Start + length For Caret Position ) ; validate Expression ( ) ; request Expression Focus ( ) ; } } else { int caret Position = current Expression . get Caret Position ( ) ; String text = current Expression . get Text ( ) ; if ( text != null && text . length ( ) > NUM ) { String first Part = text . substring ( NUM , caret Position ) ; String last Part = text . substring ( caret Position ) ; current Expression . set Text ( first Part + value + last Part ) ; int length For Caret Position = value . length ( ) ; if ( value . ends With ( STRING ) ) { length For Caret Position -- ; } current Expression . set Caret Position ( caret Position + length For Caret Position ) ; } else { current Expression . set Text ( value ) ; int length For Caret Position = value . length ( ) ; if ( value . ends With ( STRING ) ) { length For Caret Position -- ; } current Expression . set Caret Position ( caret Position + length For Caret Position ) ; current Expression . set Caret Position ( length For Caret Position ) ; } validate Expression ( ) ; request Expression Focus ( ) ; } }
byte [ ] unzip ( final byte [ ] data ) throws IO Exception { final Input Stream input = new Byte Array Input Stream ( data ) ; final byte [ ] buffer = new byte [ NUM ] ; final Zip Input Stream zip = new Zip Input Stream ( input ) ; final Byte Array Output Stream out = new Byte Array Output Stream ( data . length ) ; int count = NUM ; if ( zip . get Next Entry ( ) != null ) { while ( ( count = zip . read ( buffer ) ) != - NUM ) { out . write ( buffer , NUM , count ) ; } } out . flush ( ) ; zip . close ( ) ; out . close ( ) ; return out . to Byte Array ( ) ; }
private final Styled String append Parameter Signature ( Styled String buffer , char [ ] [ ] parameter Types , char [ ] [ ] parameter Names ) { if ( parameter Types != null ) { for ( int i = NUM ; i < parameter Types . length ; i ++ ) { if ( i > NUM ) { buffer . append ( STRING ) ; buffer . append ( STRING ) ; } buffer . append ( parameter Types [ i ] ) ; if ( parameter Names != null && parameter Names [ i ] != null ) { buffer . append ( STRING ) ; buffer . append ( parameter Names [ i ] ) ; } } } return buffer ; }
public void start Heartbeat ( Database database , String name ) throws SQL Exception { Array List < Column > where Clause = new Array List < Column > ( ) ; Array List < Column > values = new Array List < Column > ( ) ; Timestamp now = new Timestamp ( System . current Time Millis ( ) ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + name + STRING + now ) ; hb Id . set Value ( KEY ) ; where Clause . add ( hb Id ) ; hb Source Tstamp . set Value ( now ) ; hb Salt . set Value ( salt Value . get And Increment ( ) ) ; hb Name . set Value ( name ) ; values . add ( hb Source Tstamp ) ; values . add ( hb Salt ) ; values . add ( hb Name ) ; database . update ( hb Table , where Clause , values ) ; }
public Cipher Parameters encrypt ( byte [ ] out , int out Off , int key Len ) throws Illegal Argument Exception { if ( key . is Private ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } Big Integer n = key . get Modulus ( ) ; Big Integer e = key . get Exponent ( ) ; Big Integer r = Big Integers . create Random In Range ( ZERO , n . subtract ( ONE ) , rnd ) ; Big Integer c = r . mod Pow ( e , n ) ; byte [ ] C = Big Integers . as Unsigned Byte Array ( ( n . bit Length ( ) + NUM ) / NUM , c ) ; System . arraycopy ( C , NUM , out , out Off , C . length ) ; return generate Key ( n , r , key Len ) ; }
public Public Key load Public Key ( int id ) throws Exception { if ( default Keys ) { return get Public Key From String ( RSA Key Loader . DEFAULT UKEY ) ; } File Reader f = new File Reader ( path + STRING + id ) ; Buffered Reader r = new Buffered Reader ( f ) ; String tmp = STRING ; String key = STRING ; while ( ( tmp = r . read Line ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ; Public Key ret = get Public Key From String ( key ) ; return ret ; }
public void add Categories Listener ( Snapshot Categories Listener listener ) { listeners . add ( listener ) ; }
private Chrono Local Date of Week Based Year ( Chronology chrono , int yowby , int wowby , int dow ) { Chrono Local Date date = chrono . date ( yowby , NUM , NUM ) ; int ldow = localized Day Of Week ( date ) ; int offset = start Of Week Offset ( NUM , ldow ) ; int year Len = date . length Of Year ( ) ; int new Year Week = compute Week ( offset , year Len + week Def . get Minimal Days In First Week ( ) ) ; wowby = Math . min ( wowby , new Year Week - NUM ) ; int days = - offset + ( dow - NUM ) + ( wowby - NUM ) * NUM ; return date . plus ( days , DAYS ) ; }
public static int [ ] string To Int Array ( String str ) { if ( str == null ) { return ( null ) ; } String [ ] array = str . split ( STRING ) ; if ( array . length == NUM ) { array = new String [ ] { str . trim ( ) } ; } int [ ] n Array = new int [ array . length ] ; for ( int i = NUM ; i < n Array . length ; ++ i ) { n Array [ i ] = Integer . parse Int ( array [ i ] ) ; } return ( n Array ) ; }
private boolean is Lockout Enabled ( ) { if ( max Authn Login Attemts Count == NUM || max Authn Login Attemts Life Time In Mins == NUM ) { return BOOL ; } return BOOL ; }
static Class Loader create Loader ( ) { List < URL > urls = new Array List < > ( ) ; for ( String name : new String [ ] { STRING , STRING } ) { String value = System . get Property ( name ) ; if ( value != null ) { add UR Ls From Path ( urls , value ) ; } } for ( int i = NUM ; add Patch Paths ( urls , i ) ; i ++ ) { } return new URL Class Loader ( urls . to Array ( new URL [ urls . size ( ) ] ) ) ; }
public void inline Image ( Rendered Image image , Color bkg , String encode ) throws IO Exception { Image Bytes bytes = new Image Bytes ( image , bkg , Image Constants . JPG , Image Constants . COLOR MODEL RGB ) ; println ( STRING ) ; image Info ( STRING , image . get Width ( ) ) ; image Info ( STRING , image . get Height ( ) ) ; image Info ( STRING , pdf . name ( STRING ) ) ; image Info ( STRING , NUM ) ; image Info ( STRING , get Filter Name ( bytes . get Format ( ) ) ) ; print ( STRING ) ; write ( bytes . get Bytes ( ) ) ; println ( STRING ) ; }
public List < Object > ids By DFS Finish Time ( boolean increasing ) { if ( ! initialized ) { throw new Illegal Argument Exception ( ) ; } int len = vertex List . size ( ) ; Object [ ] r = new Object [ len ] ; for ( Iterator < Vertex > all V = vertex List . iterator ( ) ; all V . has Next ( ) ; ) { Vertex vertex = all V . next ( ) ; int f = vertex . finish Time ; if ( increasing ) { r [ f - NUM ] = vertex . id ; } else { r [ len - f ] = vertex . id ; } } return Arrays . as List ( r ) ; }
private void configure Auth ( Client Builder client Builder ) { if ( conf . client . auth Type == Authentication Type . OAUTH ) { auth Token = Jersey Client Util . configure O Auth 1 ( conf . client . oauth , client Builder ) ; } else if ( conf . client . auth Type != Authentication Type . NONE ) { Jersey Client Util . configure Password Auth ( conf . client . auth Type , conf . client . basic Auth , client Builder ) ; } }
private static int index Of ( int from Index , Char Sequence csq ) { if ( csq == null ) return NUM ; int length = csq . length ( ) ; int j = from Index ; int i = ( j < length ) ? Character . to Upper Case ( csq . char At ( j ++ ) ) : NUM ; i <<= NUM ; i |= ( j < length ) ? Character . to Upper Case ( csq . char At ( j ++ ) ) : NUM ; return i ; }
protected Size Requirements calculate Minor Axis Requirements ( int axis , Size Requirements r ) { if ( r == null ) { r = new Size Requirements ( ) ; } float pref = layout Pool . get Preferred Span ( axis ) ; float min = layout Pool . get Minimum Span ( axis ) ; r . minimum = ( int ) min ; r . preferred = Math . max ( r . minimum , ( int ) pref ) ; r . maximum = Integer . MAX VALUE ; r . alignment = NUM ; return r ; }
public static String row To String ( JSON Array ja ) { String Buffer sb = new String Buffer ( ) ; for ( int i = NUM ; i < ja . length ( ) ; i += NUM ) { if ( i > NUM ) { sb . append ( STRING ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . to String ( ) ; if ( string . length ( ) > NUM && ( string . index Of ( STRING ) >= NUM || string . index Of ( STRING ) >= NUM || string . index Of ( STRING ) >= NUM || string . index Of ( NUM ) >= NUM || string . char At ( NUM ) == STRING ) ) { sb . append ( STRING ) ; int length = string . length ( ) ; for ( int j = NUM ; j < length ; j += NUM ) { char c = string . char At ( j ) ; if ( c >= STRING && c != STRING ) { sb . append ( c ) ; } } sb . append ( STRING ) ; } else { sb . append ( string ) ; } } } sb . append ( STRING ) ; return sb . to String ( ) ; }
public Geometry Function find ( String name , int arg Count ) { for ( Iterator i = functions . iterator ( ) ; i . has Next ( ) ; ) { Geometry Function func = ( Geometry Function ) i . next ( ) ; String func Name = func . get Name ( ) ; if ( func Name . equals Ignore Case ( name ) && func . get Parameter Types ( ) . length == arg Count ) return func ; } return null ; }
private Cluster < Dendrogram Model > make Cluster ( DBID Ref lead , double depth , DBI Ds members ) { final String name ; if ( members . size ( ) == NUM ) { name = STRING + DBID Util . to String ( lead ) + STRING + depth ; } else if ( ! Double . is Na N ( depth ) && Double . is Infinite ( depth ) || ( members . size ( ) == NUM && members . contains ( lead ) ) ) { name = STRING + DBID Util . to String ( lead ) ; } else if ( ! Double . is Na N ( depth ) ) { name = STRING + DBID Util . to String ( lead ) + STRING + depth ; } else { name = STRING + DBID Util . to String ( lead ) ; } Cluster < Dendrogram Model > cluster = new Cluster < > ( name , members , new Dendrogram Model ( depth ) ) ; return cluster ; }
public static void columns For ( Result Set result Set , Consumer < Column > consumer ) throws SQL Exception { Result Set Meta Data metadata = result Set . get Meta Data ( ) ; Column Editor column = Column . editor ( ) ; for ( int position = NUM ; position <= metadata . get Column Count ( ) ; ++ position ) { String column Label = metadata . get Column Label ( position ) ; column . name ( column Label != null ? column Label : metadata . get Column Name ( position ) ) ; column . type ( metadata . get Column Type Name ( position ) ) ; column . jdbc Type ( metadata . get Column Type ( position ) ) ; column . length ( metadata . get Precision ( position ) ) ; column . scale ( metadata . get Scale ( position ) ) ; column . optional ( is Nullable ( metadata . is Nullable ( position ) ) ) ; column . auto Incremented ( metadata . is Auto Increment ( position ) ) ; column . generated ( BOOL ) ; consumer . accept ( column . create ( ) ) ; } }
protected Array List < Array List < DBI Ds > > build Ranges ( Relation < V > relation ) { final int dim = Relation Util . dimensionality ( relation ) ; final int size = relation . size ( ) ; final Array List < Array List < DBI Ds > > ranges = new Array List < > ( ) ; Array Modifiable DBI Ds ids = DBID Util . new Array ( relation . get DBI Ds ( ) ) ; Sort DBI Ds By Single Dimension sorter = new Sort DBI Ds By Single Dimension ( relation ) ; final double part = size * NUM / phi ; for ( int d = NUM ; d < dim ; d ++ ) { sorter . set Dimension ( d ) ; ids . sort ( sorter ) ; Array List < DBI Ds > dimranges = new Array List < > ( phi + NUM ) ; int start = NUM ; DBID Array Iter iter = ids . iter ( ) ; for ( int r = NUM ; r <= phi ; r ++ ) { int end = ( r < phi ) ? ( int ) ( part * r ) : size ; Array Modifiable DBI Ds currange = DBID Util . new Array ( end - start ) ; for ( iter . seek ( start ) ; iter . get Offset ( ) < end ; iter . advance ( ) ) { currange . add ( iter ) ; } start = end ; dimranges . add ( currange ) ; } ranges . add ( dimranges ) ; } return ranges ; }

public static Persistent Search Request Control new Control ( final boolean is Critical , final boolean changes Only , final boolean return E Cs , final Collection < Persistent Search Change Type > change Types ) { Reject . if Null ( change Types ) ; final Set < Persistent Search Change Type > copy Of Change Types = Enum Set . none Of ( Persistent Search Change Type . class ) ; copy Of Change Types . add All ( change Types ) ; return new Persistent Search Request Control ( is Critical , changes Only , return E Cs , Collections . unmodifiable Set ( copy Of Change Types ) ) ; }
private < T > Binding Inject < T > find Bean ( Key < T > key ) { for ( Inject Provider provider : provider List ) { Binding Inject < T > bean = ( Binding Inject ) provider . lookup ( key . raw Class ( ) ) ; if ( bean != null ) { return bean ; } } return null ; }
protected void smart Indent After New Line ( I Document document , Document Command command ) { int doc Length = document . get Length ( ) ; if ( command . offset == - NUM || doc Length == NUM ) { return ; } try { int p = ( command . offset == doc Length ? command . offset - NUM : command . offset ) ; int line = document . get Line Of Offset ( p ) ; String Buffer buf = new String Buffer ( command . text ) ; if ( command . offset < doc Length && document . get Char ( command . offset ) == STRING ) { int ind Line = find Matching Open Bracket ( document , line , command . offset , NUM ) ; if ( ind Line == - NUM ) { ind Line = line ; } buf . append ( get Indent Of Line ( document , ind Line ) ) ; } else { int start = document . get Line Offset ( line ) ; int whiteend = find End Of White Space ( document , start , command . offset ) ; buf . append ( document . get ( start , whiteend - start ) ) ; if ( get Bracket Count ( document , start , command . offset , BOOL ) > NUM ) { buf . append ( get Indent Token ( ) ) ; } } command . text = buf . to String ( ) ; } catch ( Bad Location Exception e ) { GWT Plugin Log . log Error ( e ) ; } }
private String input Accrued National Number ( ) { int length Of National Number = national Number . length ( ) ; if ( length Of National Number > NUM ) { String temp National Number = STRING ; for ( int i = NUM ; i < length Of National Number ; i ++ ) { temp National Number = input Digit Helper ( national Number . char At ( i ) ) ; } return able To Format ? append National Number ( temp National Number ) : accrued Input . to String ( ) ; } else { return prefix Before National Number . to String ( ) ; } }
private void fill Picks ( ) throws Exception { Language language = Language . get Login Language ( ) ; M Lookup order L = M Lookup Factory . get ( Env . get Ctx ( ) , m Window No , M Column . get Column ID ( MDD Order . Table Name , MDD Order . COLUMNNAME DD Order ID ) , Display Type . Search , language , MDD Order . COLUMNNAME DD Order ID , NUM , BOOL , STRING ) ; f Order = new V Lookup ( MDD Order . COLUMNNAME DD Order ID , BOOL , BOOL , BOOL , order L ) ; l Order . set Text ( Msg . translate ( Env . get Ctx ( ) , MDD Order . COLUMNNAME DD Order ID ) ) ; f Order . add Vetoable Change Listener ( this ) ; Timestamp today = new Timestamp ( System . current Time Millis ( ) ) ; m Movement Date = today ; f Movement Date . set Value ( today ) ; f Movement Date . add Vetoable Change Listener ( this ) ; }
@ Override protected Field Config Base create Copy ( Field Config Base field Config Base ) { Field Config Boolean copy = null ; if ( field Config Base != null ) { copy = new Field Config Boolean ( field Config Base . get Common Data ( ) ) ; } return copy ; }
private Image cache Annotation Image ( final Workflow Annotation anno , final int cache Id ) { Rectangle 2 D loc = anno . get Location ( ) ; Dimension size = new Dimension ( ( int ) loc . get Width ( ) , ( int ) loc . get Height ( ) ) ; pane . set Size ( size ) ; pane . set Text ( Annotation Draw Utils . create Styled Comment String ( anno ) ) ; pane . set Caret Position ( NUM ) ; Buffered Image img = new Buffered Image ( ( int ) loc . get Width ( ) , ( int ) loc . get Height ( ) , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g Img = img . create Graphics ( ) ; g Img . set Rendering Hints ( Process Drawer . HI QUALITY HINTS ) ; g Img . set Composite ( Alpha Composite . Src Over ) ; pane . paint ( g Img ) ; display Cache . put ( anno . get Id ( ) , new Weak Reference < Image > ( img ) ) ; cached ID . put ( anno . get Id ( ) , cache Id ) ; return img ; }
public void add ( Dimensional Node dn ) { if ( in Progress ) { throw new Concurrent Modification Exception ( STRING ) ; } nodes . add ( dn ) ; }
public static Configuration load ( Input Stream stream ) throws IO Exception { try { Properties properties = new Properties ( ) ; properties . load ( stream ) ; return from ( properties ) ; } finally { stream . close ( ) ; } }
public synchronized Combo Box < V > add Item ( V item ) { if ( item == null ) { throw new Illegal Argument Exception ( STRING ) ; } items . add ( item ) ; if ( selected Index == - NUM && items . size ( ) == NUM ) { set Selected Index ( NUM ) ; } invalidate ( ) ; return this ; }
private static Element add Bean ( Document doc , Node parent , Class < ? > cls ) { Element elem = doc . create Element ( STRING ) ; elem . set Attribute ( STRING , cls . get Name ( ) ) ; parent . append Child ( elem ) ; return elem ; }
public void write Boolean ( boolean value ) throws IO Exception { check Write Primitive Types ( ) ; primitive Types . write Boolean ( value ) ; }
public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM ) ; new Vector . add Element ( STRING ) ; new Vector . add Element ( STRING ) ; return new Vector . elements ( ) ; }
@ Override public Instances define Data Format ( ) throws Exception { Array List < Attribute > atts ; Array List < String > att Values ; int i ; int n ; m Random = new Random ( get Seed ( ) ) ; set Num Examples Act ( get Num Examples ( ) ) ; atts = new Array List < Attribute > ( ) ; for ( n = NUM ; n <= NUM ; n ++ ) { att Values = new Array List < String > ( ) ; for ( i = NUM ; i < NUM ; i ++ ) { att Values . add ( STRING + i ) ; } atts . add ( new Attribute ( STRING + n , att Values ) ) ; } att Values = new Array List < String > ( ) ; for ( i = NUM ; i < NUM ; i ++ ) { att Values . add ( STRING + i ) ; } atts . add ( new Attribute ( STRING , att Values ) ) ; m Dataset Format = new Instances ( get Relation Name To Use ( ) , atts , NUM ) ; return m Dataset Format ; }
public static double ln Gamma ( double x ) { double p , q , w , z ; double A [ ] = { NUM , - NUM , NUM , - NUM , NUM } ; double B [ ] = { - NUM , - NUM , - NUM , - NUM , - NUM , - NUM } ; double C [ ] = { - NUM , - NUM , - NUM , - NUM , - NUM , - NUM } ; if ( x < - NUM ) { q = - x ; w = ln Gamma ( q ) ; p = Math . floor ( q ) ; if ( p == q ) throw new Arithmetic Exception ( STRING ) ; z = q - p ; if ( z > NUM ) { p += NUM ; z = p - q ; } z = q * Math . sin ( Math . PI * z ) ; if ( z == NUM ) throw new Arithmetic Exception ( STRING ) ; z = LOGPI - Math . log ( z ) - w ; return z ; } if ( x < NUM ) { z = NUM ; while ( x >= NUM ) { x -= NUM ; z *= x ; } while ( x < NUM ) { if ( x == NUM ) throw new Arithmetic Exception ( STRING ) ; z /= x ; x += NUM ; } if ( z < NUM ) z = - z ; if ( x == NUM ) return Math . log ( z ) ; x -= NUM ; p = x * polevl ( x , B , NUM ) / p1 evl ( x , C , NUM ) ; return ( Math . log ( z ) + p ) ; } if ( x > NUM ) throw new Arithmetic Exception ( STRING ) ; q = ( x - NUM ) * Math . log ( x ) - x + NUM ; if ( x > NUM ) return ( q ) ; p = NUM / ( x * x ) ; if ( x >= NUM ) q += ( ( NUM * p - NUM ) * p + NUM ) / x ; else q += polevl ( p , A , NUM ) / x ; return q ; }
private void adjust For Right Fading Edge ( View child In Selected Row , int left Selection Pixel , int right Selection Pixel ) { if ( child In Selected Row . get Right ( ) > right Selection Pixel ) { int space To Left = child In Selected Row . get Left ( ) - left Selection Pixel ; int space To Right = child In Selected Row . get Right ( ) - right Selection Pixel ; int offset = Math . min ( space To Left , space To Right ) ; offset Children Left And Right ( - offset ) ; } }
@ Override public String run ( String [ ] args ) { if ( args . length == NUM ) { String help = STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; return help ; } try { if ( args . length > NUM ) { String cmd = args [ NUM ] ; if ( cmd == STRING ) { if ( args . length > NUM ) { int id = Integer . parse Int ( args [ NUM ] ) ; return str List Network ( id , BOOL ) ; } else { return str List Networks ( BOOL ) ; } } else if ( cmd == STRING ) { if ( args . length > NUM ) { int id 1 = Integer . parse Int ( args [ NUM ] ) ; int id 2 = Integer . parse Int ( args [ NUM ] ) ; int id 3 = Integer . parse Int ( args [ NUM ] ) ; return str Link 3 ( id 1 , id 2 , id 3 ) ; } else if ( args . length > NUM ) { int id 1 = Integer . parse Int ( args [ NUM ] ) ; int id 2 = Integer . parse Int ( args [ NUM ] ) ; return str Link 2 ( id 1 , id 2 ) ; } } else if ( cmd == STRING ) { if ( args . length > NUM ) { int id = Integer . parse Int ( args [ NUM ] ) ; return str Unlink ID ( id ) ; } else { return str Unlink All ( ) ; } } return STRING ; } } catch ( Number Format Exception nfe ) { } catch ( Null Pointer Exception npe ) { } catch ( Index Out Of Bounds Exception ioobe ) { } return STRING ; }
public Reconciliation Context ( Reconciliation Service . Recon Action recon Action , Object Mapping mapping , Context calling Context , Json Value recon Params , Json Value overriding Config , Reconciliation Service service ) throws Bad Request Exception { this . recon Action = recon Action ; this . mapping = mapping ; this . recon Id = calling Context . get Id ( ) ; this . recon Stat = new Reconciliation Statistic ( this ) ; this . recon Params = recon Params ; this . overriding Config = overriding Config ; this . service = service ; recon Type Handler = create Recon Type Handler ( recon Action ) ; int no Of Threads = mapping . get Task Threads ( ) ; if ( no Of Threads > NUM ) { executor = Executors . new Fixed Thread Pool ( no Of Threads ) ; } else { executor = null ; } }
private < V > J Component create Property Editor ( Class < V > type , Parameter Getter < Neuron Update Rule , V > getter , Parameter Setter < Neuron Update Rule , V > setter ) { if ( type == Double . class || type == Float . class ) { J Formatted Text Field field = new J Formatted Text Field ( ) ; editor List . add ( new Editor ( type , field , getter , setter ) ) ; return field ; } else if ( type == Boolean . class ) { Yes No Null drop Down = new Yes No Null ( ) ; editor List . add ( new Editor ( type , drop Down , getter , setter ) ) ; return drop Down ; } else if ( type == Integer . class ) { Choices With Null drop Down = new Choices With Null ( ) ; editor List . add ( new Editor ( type , drop Down , getter , setter ) ) ; return drop Down ; } return null ; }
private static void store As Type With Signatures Import ( String str Type To Import , @ Nullable Function obj Scope , Php Index obj Index , Hash Set < String > obj Types Set ) { if ( str Type To Import . contains ( STRING ) ) { for ( String str One Type : str Type To Import . split ( STRING ) ) { store As Type With Signatures Import ( Types . get Type ( str One Type ) , obj Scope , obj Index , obj Types Set ) ; } return ; } if ( String Util . is Empty ( str Type To Import ) || str Type To Import . equals ( STRING ) ) { return ; } if ( str Type To Import . contains ( STRING ) ) { Type From Signature Resolving Util . resolve Signature ( str Type To Import , obj Scope , obj Index , obj Types Set ) ; return ; } obj Types Set . add ( Types . get Type ( str Type To Import ) ) ; }
@ Parameters Are Nonnull By Default public static List < Size > filter Black Listed Sizes ( List < Size > sizes , String blacklist String ) { String [ ] blacklist String Array = blacklist String . split ( STRING ) ; if ( blacklist String Array . length == NUM ) { return sizes ; } Set < String > blacklisted Sizes = new Hash Set ( Lists . new Array List ( blacklist String Array ) ) ; List < Size > new Size List = new Array List < > ( ) ; for ( Size size : sizes ) { if ( ! is Black Listed ( size , blacklisted Sizes ) ) { new Size List . add ( size ) ; } } return new Size List ; }
public static void copy ( final J Text Area area ) { final String selected Text = area . get Selected Text ( ) ; if ( selected Text == null ) { Clipboard Helpers . copy To Clipboard ( area . get Text ( ) ) ; } else { Clipboard Helpers . copy To Clipboard ( selected Text ) ; } }
@ Override public void on Transfer Progress ( long progress Rate , long total Transferred So Far , long total To Transfer , String file Path ) { int percent = ( int ) ( NUM * ( ( double ) total Transferred So Far ) / ( ( double ) total To Transfer ) ) ; if ( percent != m Last Percent ) { m Notification Builder . set Progress ( NUM , percent , total To Transfer < NUM ) ; String file Name = file Path . substring ( file Path . last Index Of ( File Utils . PATH SEPARATOR ) + NUM ) ; String text = String . format ( get String ( R . string . downloader download in progress content ) , percent , file Name ) ; m Notification Builder . set Content Text ( text ) ; m Notification Manager . notify ( R . string . downloader download in progress ticker , m Notification Builder . build ( ) ) ; } m Last Percent = percent ; }
final private String class Def 2 Object Desc ( Attributes attrs ) throws Naming Exception { String Buffer object Desc = new String Buffer ( STRING ) ; Attribute attr = null ; int count = NUM ; attr = attrs . get ( NUMERICOID ID ) ; if ( attr != null ) { object Desc . append ( write Numeric OID ( attr ) ) ; count ++ ; } else { throw new Configuration Exception ( STRING + STRING ) ; } attr = attrs . get ( NAME ID ) ; if ( attr != null ) { object Desc . append ( write Q Descrs ( attr ) ) ; count ++ ; } attr = attrs . get ( DESC ID ) ; if ( attr != null ) { object Desc . append ( write QD String ( attr ) ) ; count ++ ; } attr = attrs . get ( OBSOLETE ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get ( SUP ID ) ; if ( attr != null ) { object Desc . append ( write OI Ds ( attr ) ) ; count ++ ; } attr = attrs . get ( ABSTRACT ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get ( STRUCTURAL ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get ( AUXILARY ID ) ; if ( attr != null ) { object Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get ( MUST ID ) ; if ( attr != null ) { object Desc . append ( write OI Ds ( attr ) ) ; count ++ ; } attr = attrs . get ( MAY ID ) ; if ( attr != null ) { object Desc . append ( write OI Ds ( attr ) ) ; count ++ ; } if ( count < attrs . size ( ) ) { String attr Id = null ; for ( Naming Enumeration < ? extends Attribute > ae = attrs . get All ( ) ; ae . has More Elements ( ) ; ) { attr = ae . next ( ) ; attr Id = attr . get ID ( ) ; if ( attr Id . equals ( NUMERICOID ID ) || attr Id . equals ( NAME ID ) || attr Id . equals ( SUP ID ) || attr Id . equals ( MAY ID ) || attr Id . equals ( MUST ID ) || attr Id . equals ( STRUCTURAL ID ) || attr Id . equals ( DESC ID ) || attr Id . equals ( AUXILARY ID ) || attr Id . equals ( ABSTRACT ID ) || attr Id . equals ( OBSOLETE ID ) ) { continue ; } else { object Desc . append ( write QD Strings ( attr ) ) ; } } } object Desc . append ( STRING ) ; return object Desc . to String ( ) ; }
private < T extends Client Request Result > Collection < T > execute Name Request ( final Collection < String > regex List , final Class < T > clazz , final Client Request Report Listener report Listener , final String request Queue ) { LOGGER . debug ( STRING ) ; Client Request Impl < T > client Request = new Client Request Impl < T > ( clazz ) ; Iterator < String > it = regex List . iterator ( ) ; Collection < Future < Collection < T > > > results = new Array List < Future < Collection < T > > > ( ) ; int counter = NUM ; while ( it . has Next ( ) ) { while ( it . has Next ( ) && counter < max Request Size ) { client Request . add Regex ( it . next ( ) ) ; counter ++ ; } Request Values Task < T > task = new Request Values Task < T > ( client Request , report Listener , request Queue ) ; results . add ( executor . submit ( task ) ) ; client Request = new Client Request Impl < T > ( clazz ) ; counter = NUM ; } Collection < T > final Collection = new Array List < T > ( ) ; for ( Future < Collection < T > > result : results ) { try { final Collection . add All ( result . get ( ) ) ; } catch ( Interrupted Exception e ) { LOGGER . error ( STRING , e ) ; throw new Runtime Exception ( e ) ; } catch ( Execution Exception e ) { LOGGER . error ( STRING , e ) ; throw new Runtime Exception ( e ) ; } } LOGGER . debug ( STRING ) ; return final Collection ; }
public void load All Images ( Component comp , Media Tracker tracker ) { for ( Iterator < Hex Entry > i = bases . iterator ( ) ; i . has Next ( ) ; ) { Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , NUM ) ; } for ( Iterator < Hex Entry > i = supers . iterator ( ) ; i . has Next ( ) ; ) { Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , NUM ) ; } for ( Iterator < Hex Entry > i = ortho . iterator ( ) ; i . has Next ( ) ; ) { Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , NUM ) ; } }
public static Date parse Date ( String date Str ) { try { return m Simple Date Format . parse ( date Str ) ; } catch ( Parse Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( STRING ) ; } }
public static String serialize ( Object data ) { String ret = null ; if ( data != null ) { if ( data . get Class ( ) == String . class ) { ret = ( String ) data ; } else if ( data instanceof byte [ ] ) { ret = new String ( ( byte [ ] ) data ) ; } else { try { ret = mapper . write Value As String ( data ) ; } catch ( Json Processing Exception e ) { if ( log . is Loggable ( Level . FINEST ) ) { log . log ( Level . FINEST , STRING , e ) ; } } } } if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( STRING + data + STRING + ret ) ; } return ret ; }
@ Override public int hash Code ( ) { int result = NUM ; Iterator < ? > it = iterator ( ) ; while ( it . has Next ( ) ) { Object next = it . next ( ) ; result += next == null ? NUM : next . hash Code ( ) ; } return result ; }
private static List find Labeled Edge Rings ( Collection dir Edges ) { List edge Ring Starts = new Array List ( ) ; long curr Label = NUM ; for ( Iterator i = dir Edges . iterator ( ) ; i . has Next ( ) ; ) { Polygonize Directed Edge de = ( Polygonize Directed Edge ) i . next ( ) ; if ( de . is Marked ( ) ) continue ; if ( de . get Label ( ) >= NUM ) continue ; edge Ring Starts . add ( de ) ; List edges = Edge Ring . find Dir Edges In Ring ( de ) ; label ( edges , curr Label ) ; curr Label ++ ; } return edge Ring Starts ; }
public void delete Entity Config ( String realm , String entity Id ) throws SAML 2 Meta Exception { if ( entity Id == null ) { return ; } if ( realm == null ) { realm = STRING ; } String [ ] objs = { entity Id , realm } ; try { Map old Attrs = config Inst . get Configuration ( realm , entity Id ) ; Set old Values = ( Set ) old Attrs . get ( ATTR ENTITY CONFIG ) ; if ( old Values == null || old Values . is Empty ( ) ) { Log Util . error ( Level . INFO , Log Util . NO ENTITY DESCRIPTOR DELETE ENTITY CONFIG , objs , null ) ; throw new SAML 2 Meta Exception ( STRING , objs ) ; } remove From Circle Of Trust ( realm , entity Id ) ; Set attr = new Hash Set ( ) ; attr . add ( ATTR ENTITY CONFIG ) ; config Inst . delete Configuration ( realm , entity Id , attr ) ; Log Util . access ( Level . INFO , Log Util . ENTITY CONFIG DELETED , objs , null ) ; SAML 2 Meta Cache . put Entity Config ( realm , entity Id , null ) ; } catch ( Configuration Exception e ) { debug . error ( STRING , e ) ; String [ ] data = { e . get Message ( ) , entity Id , realm } ; Log Util . error ( Level . INFO , Log Util . CONFIG ERROR DELETE ENTITY CONFIG , data , null ) ; throw new SAML 2 Meta Exception ( e ) ; } }
public static synchronized Data Source Window Manager shared Instance ( ) { if ( shared Instance == null ) shared Instance = new Data Source Window Manager ( ) ; return shared Instance ; }
public static String format ( String s ) { List < String > color repl = new Array List < > ( ) ; Matcher m = color Pattern . matcher ( s ) ; while ( m . find ( ) ) color repl . add ( m . group ( NUM ) ) ; String [ ] split = s . split ( color Pattern . pattern ( ) ) ; String total = STRING ; for ( int i = NUM ; i < split . length ; i ++ ) { if ( i >= color repl . size ( ) ) total += split [ i ] ; else { total += colorize ( split [ i ] , Colors . get ( color repl . get ( i ) ) ) ; } } return total ; }
public static final String stack Strace As String ( final Throwable exception ) { final String Writer string Writer = new String Writer ( ) ; exception . print Stack Trace ( new Print Writer ( string Writer ) ) ; return string Writer . to String ( ) ; }
public String resolve Path ( String path Info ) { if ( ( path Info == null ) || ( path Info . index Of ( STRING ) != - NUM ) ) { return null ; } int lib Start = path Info . index Of ( STRING ) + NUM ; int lib End = path Info . index Of ( STRING , lib Start ) ; if ( lib End == - NUM ) { lib End = path Info . length ( ) ; } String libname = path Info . substring ( lib Start , lib End ) ; String subpath = path Info . substring ( lib End ) ; String lib home = get Path ( libname ) ; if ( lib home == null ) { return null ; } return lib home + STRING + subpath ; }
public void compress ( ) { Io Buffer tmp = Io Buffer . allocate ( NUM ) ; tmp . set Auto Expand ( BOOL ) ; Deflater Output Stream deflater = new Deflater Output Stream ( tmp . as Output Stream ( ) , new Deflater ( Deflater . BEST COMPRESSION ) ) ; byte [ ] tmp Data = new byte [ data . limit ( ) ] ; data . position ( NUM ) ; data . get ( tmp Data ) ; try { deflater . write ( tmp Data ) ; deflater . finish ( ) ; } catch ( IO Exception e ) { tmp . free ( ) ; throw new Runtime Exception ( STRING , e ) ; } finally { if ( deflater != null ) { try { deflater . close ( ) ; } catch ( IO Exception e1 ) { } } } data . free ( ) ; data = tmp ; data . flip ( ) ; prepare IO ( ) ; }
public void poll ( final Snmp Udp Statistics Handler snmp Udp Statistics Handler ) { this . statistics Handler = snmp Udp Statistics Handler ; try { file Loader . load ( ) ; final Byte Buffer buffer = file Loader . get Buffer ( ) ; line Parser . reset ( ) ; line Parser . handle Token ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statistics Handler = null ; } }
@ Override public int compare To ( Byte Buffer other Buffer ) { int compare Remaining = ( remaining ( ) < other Buffer . remaining ( ) ) ? remaining ( ) : other Buffer . remaining ( ) ; int this Pos = position ; int other Pos = other Buffer . position ; byte this Byte , other Byte ; while ( compare Remaining > NUM ) { this Byte = get ( this Pos ) ; other Byte = other Buffer . get ( other Pos ) ; if ( this Byte != other Byte ) { return this Byte < other Byte ? - NUM : NUM ; } this Pos ++ ; other Pos ++ ; compare Remaining -- ; } return remaining ( ) - other Buffer . remaining ( ) ; }
public Urbansim Cell Based Accessibility CSV Writer V 2 ( String matsim Output Directory ) { log . info ( STRING ) ; try { accessibility Data Writer = IO Utils . get Buffered Writer ( matsim Output Directory + STRING + ACCESSIBILITY INDICATORS ) ; } catch ( Exception ee ) { ee . print Stack Trace ( ) ; throw new Runtime Exception ( STRING ) ; } if ( accessibility Data Writer == null ) { throw new Runtime Exception ( STRING ) ; } try { accessibility Data Writer . write ( Labels . ZONE ID + STRING + Labels . X COORDINATE + STRING + Labels . Y COORDINATE + STRING + Labels . ACCESSIBILITY BY FREESPEED + STRING + Labels . ACCESSIBILITY BY CAR + STRING + Labels . ACCESSIBILITY BY BIKE + STRING + Labels . ACCESSIBILITY BY WALK + STRING + Labels . ACCESSIBILITY BY PT ) ; accessibility Data Writer . new Line ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( STRING ) ; } log . info ( STRING ) ; }
@ Override public void agg ( Object new Val ) { if ( new Val instanceof byte [ ] ) { Byte Buffer buffer = Byte Buffer . wrap ( ( byte [ ] ) new Val ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { byte [ ] value Byte = new byte [ buffer . get Int ( ) ] ; buffer . get ( value Byte ) ; Big Decimal value Big Decimal = Data Type Util . byte To Big Decimal ( value Byte ) ; agg Val = agg Val . add ( value Big Decimal ) ; count += buffer . get Double ( ) ; first Time = BOOL ; } return ; } if ( first Time ) { agg Val = ( Big Decimal ) new Val ; first Time = BOOL ; } else { agg Val = agg Val . add ( ( Big Decimal ) new Val ) ; } count ++ ; }
void refresh From Data Store ( ) throws Policy Exception { Node xml Root Node = null ; try { xml Root Node = resource Manager . get XML Root Node ( resource Type . get Name ( ) ) ; } catch ( Exception e ) { DEBUG . error ( STRING , e ) ; throw new Policy Exception ( Res Bundle Utils . rb Name , STRING , null , e ) ; } if ( xml Root Node != null ) { Set top Index Entry Node Set = XML Utils . get Child Nodes ( xml Root Node , Policy Manager . POLICY INDEX REFERENCE NODE ) ; Iterator top Index Entry Nodes = top Index Entry Node Set . iterator ( ) ; while ( top Index Entry Nodes . has Next ( ) ) { Node top Index Entry Node = ( Node ) top Index Entry Nodes . next ( ) ; String resource Name = XML Utils . get Node Attribute Value ( top Index Entry Node , Policy Manager . POLICY INDEX REFERENCE NODE NAME ATTR ) ; Set policy Names = get Policy Names ( top Index Entry Node ) ; Resource Index Entry rie = new Resource Index Entry ( resource Name , policy Names ) ; top Level Entries . add ( rie ) ; Set index Entry Node Set = XML Utils . get Child Nodes ( top Index Entry Node , Policy Manager . POLICY INDEX REFERENCE NODE ) ; Iterator index Entry Nodes = index Entry Node Set . iterator ( ) ; while ( index Entry Nodes . has Next ( ) ) { Node index Entry Node = ( Node ) index Entry Nodes . next ( ) ; process Index Entry Node ( rie , index Entry Node ) ; } } } }
public static Data Type create Object ( String class Name , String value ) { try { Class < ? > the Class = Class . for Name ( class Name ) ; Class < ? > [ ] constructor Parameters = new Class [ NUM ] ; constructor Parameters [ NUM ] = Class . for Name ( STRING ) ; Constructor < ? > class Constructor = the Class . get Constructor ( constructor Parameters ) ; return ( Data Type ) class Constructor . new Instance ( value ) ; } catch ( Exception ex ) { Log . e ( STRING , STRING + class Name + STRING + value ) ; } return null ; }
private static final String decode Field Name ( final String p Xml Field Name ) { String Buffer str = new String Buffer ( ) ; int field Name Length = p Xml Field Name . length ( ) ; char current Char ; for ( int i = NUM ; i < field Name Length ; i ++ ) { current Char = p Xml Field Name . char At ( i ) ; if ( current Char == STRING ) { str . append ( Character . to Upper Case ( p Xml Field Name . char At ( ++ i ) ) ) ; } else { str . append ( current Char ) ; } } return str . to String ( ) ; }
public boolean authenticate User ( String username , String password , String uri ) throws Data Access Exception { if ( null == username || null == password ) { return BOOL ; } User Info user = get User Info ( username ) ; if ( user == null ) { return BOOL ; } String hashed Salted Password = Utilities . get Salted Password ( username , uri , password ) ; return hashed Salted Password . equals ( user . get Hashed Password ( ) ) ; }
public Builder add Content Item ( Content Item content Item ) { if ( content Items == null ) { content Items = new Array List < Content Item > ( ) ; content Type = Http Media Type . APPLICATION JSON ; } content Items . add ( content Item ) ; return this ; }
public static String [ ] split Classname ( String classname ) { classname = canonicalize Class Name ( classname ) ; int i = classname . last Index Of ( STRING ) ; String classn , packn ; if ( i == - NUM ) { classn = classname ; packn = STRING ; } else { packn = classname . substring ( NUM , i ) ; classn = classname . substring ( i + NUM ) ; } return new String [ ] { packn , classn } ; }
@ Deprecated public static void wait For Criterion ( final Wait Criterion wait Criterion , final long timeout Millis , final long polling Interval , final boolean throw On Timeout ) { long wait This Time = jitter Interval ( polling Interval ) ; final long tilt = System . current Time Millis ( ) + timeout Millis ; for ( ; ; ) { if ( wait Criterion . done ( ) ) { return ; } if ( wait Criterion instanceof Stoppable Wait Criterion ) { Stoppable Wait Criterion ev 2 = ( Stoppable Wait Criterion ) wait Criterion ; if ( ev 2 . stop Waiting ( ) ) { if ( throw On Timeout ) { fail ( STRING + wait Criterion . description ( ) ) ; } return ; } } long time Left = tilt - System . current Time Millis ( ) ; if ( time Left <= NUM ) { if ( ! throw On Timeout ) { return ; } fail ( STRING + timeout Millis + STRING + wait Criterion . description ( ) ) ; } if ( wait This Time > time Left ) { wait This Time = time Left ; } Thread . yield ( ) ; try { Thread . sleep ( wait This Time ) ; } catch ( Interrupted Exception e ) { fail ( STRING ) ; } } }
private void reflect Member Variables In Right Button ( ) { final boolean last Page Reached = ( view Pager . get Current Item ( ) + NUM ) == pages . size ( ) ; final boolean button Should Be Invisible = last Page Reached || right Button Disabled ; final boolean button Is Currently Invisible = right Button . get Visibility ( ) == View . INVISIBLE ; final boolean should Update Button = button Should Be Invisible != button Is Currently Invisible ; if ( should Update Button ) { final Animator button Animator = button Should Be Invisible ? button Animator Factory . new Right Button Disappear Animator ( right Button ) : button Animator Factory . new Right Button Appear Animator ( right Button ) ; if ( button Should Be Invisible ) { disable Button ( button Animator , right Button ) ; } else { enable Button ( button Animator , right Button ) ; } } }
private void run Analysis ( Path node Db , Path inverted , Path output , int iteration , int num Iterations , float rank One ) throws IO Exception { Job Conf analyzer = new Nutch Job ( get Conf ( ) ) ; analyzer . set ( STRING , String . value Of ( iteration + NUM ) ) ; analyzer . set Job Name ( STRING + ( iteration + NUM ) + STRING + num Iterations ) ; File Input Format . add Input Path ( analyzer , node Db ) ; File Input Format . add Input Path ( analyzer , inverted ) ; File Output Format . set Output Path ( analyzer , output ) ; analyzer . set ( STRING , String . value Of ( rank One ) ) ; analyzer . set Map Output Key Class ( Text . class ) ; analyzer . set Map Output Value Class ( Object Writable . class ) ; analyzer . set Input Format ( Sequence File Input Format . class ) ; analyzer . set Mapper Class ( Analyzer . class ) ; analyzer . set Reducer Class ( Analyzer . class ) ; analyzer . set Output Key Class ( Text . class ) ; analyzer . set Output Value Class ( Node . class ) ; analyzer . set Output Format ( Map File Output Format . class ) ; analyzer . set Boolean ( STRING , BOOL ) ; LOG . info ( STRING ) ; try { Job Client . run Job ( analyzer ) ; } catch ( IO Exception e ) { LOG . error ( String Utils . stringify Exception ( e ) ) ; throw e ; } LOG . info ( STRING ) ; }
public static double [ ] lpc 2 lsf ( double [ ] one Minus A , int type ) { int order = one Minus A . length - NUM ; double [ ] g1 = new double [ NUM ] ; double [ ] g2 = new double [ NUM ] ; double [ ] g1 r = new double [ NUM ] ; double [ ] g2 r = new double [ NUM ] ; boolean even ; int g1 order , g2 order ; int orderd 2 ; int i , j ; int swap ; double Factor ; even = ( order & NUM ) == NUM ; if ( even ) g1 order = g2 order = order / NUM ; else { g1 order = ( order + NUM ) / NUM ; g2 order = g1 order - NUM ; throw new Illegal Argument Exception ( STRING ) ; } orderd 2 = ( order + NUM ) / NUM ; g1 [ orderd 2 ] = one Minus A [ NUM ] ; for ( i = NUM ; i <= orderd 2 ; i ++ ) g1 [ g1 order - i ] = one Minus A [ i ] + one Minus A [ order + NUM - i ] ; g2 [ orderd 2 ] = one Minus A [ NUM ] ; for ( i = NUM ; i <= orderd 2 ; i ++ ) g2 [ orderd 2 - i ] = one Minus A [ i ] - one Minus A [ order + NUM - i ] ; if ( even ) { for ( i = NUM ; i <= orderd 2 ; i ++ ) g1 [ orderd 2 - i ] -= g1 [ orderd 2 - i + NUM ] ; for ( i = NUM ; i <= orderd 2 ; i ++ ) g2 [ orderd 2 - i ] += g2 [ orderd 2 - i + NUM ] ; } else { for ( i = NUM ; i <= orderd 2 ; i ++ ) g2 [ orderd 2 - i ] += g2 [ orderd 2 - i + NUM ] ; } if ( type == NUM ) { cheby 1 ( g1 , g1 order ) ; cheby 1 ( g2 , g2 order ) ; Factor = NUM ; } else if ( type == NUM ) { cheby 2 ( g1 , g1 order ) ; cheby 2 ( g2 , g2 order ) ; Factor = NUM ; } else if ( type == NUM ) { cheby 3 ( g1 , g1 order ) ; cheby 3 ( g2 , g2 order ) ; Factor = NUM ; } else if ( type == NUM ) { kw ( g1 , g1 order ) ; kw ( g2 , g2 order ) ; Factor = NUM ; } else { throw new Illegal Argument Exception ( STRING ) ; } cacm 283 ( g1 , g1 order , g1 r ) ; cacm 283 ( g2 , g2 order , g2 r ) ; double [ ] lsp = new double [ order ] ; for ( i = NUM , j = NUM ; ; ) { lsp [ j ++ ] = Math . acos ( Factor * g1 r [ i ] ) / Math Utils . TWOPI ; if ( j >= order ) break ; lsp [ j ++ ] = Math . acos ( Factor * g2 r [ i ] ) / Math Utils . TWOPI ; if ( j >= order ) break ; i ++ ; } return lsp ; }
protected void generate Adapter ( ) { String holder Class Name = Utils . get View Holder Class Name ( ) ; String Builder holder Builder = new String Builder ( ) ; String Builder generator = new String Builder ( ) ; generator . append ( STRING + holder Class Name + STRING ) ; String root View Name = STRING ; holder Builder . append ( STRING + STRING + root View Name + STRING ) ; generator . append ( STRING + root View Name + STRING + root View Name + STRING ) ; for ( Element element : m Elements ) { if ( ! element . used ) { continue ; } holder Builder . append ( STRING + element . name + STRING + element . get Field Name ( ) + STRING ) ; generator . append ( STRING + element . get Field Name ( ) + STRING + element . name + STRING + root View Name + STRING + element . get Full ID ( ) + STRING ) ; } generator . append ( STRING ) ; holder Builder . append ( generator . to String ( ) ) ; Psi Class view Holder = m Factory . create Class From Text ( holder Builder . to String ( ) , m Class ) ; view Holder . set Name ( holder Class Name ) ; m Class . add ( view Holder ) ; m Class . add Before ( m Factory . create Keyword ( STRING , m Class ) , m Class . find Inner Class By Name ( holder Class Name , BOOL ) ) ; m Class . add Before ( m Factory . create Keyword ( STRING , m Class ) , m Class . find Inner Class By Name ( holder Class Name , BOOL ) ) ; }
public static boolean is Strike Through ( Attribute Set a ) { Boolean strike = ( Boolean ) a . get Attribute ( Strike Through ) ; if ( strike != null ) { return strike . boolean Value ( ) ; } return BOOL ; }
public static Executor create Task Distributor ( ) { return Executors . new Cached Thread Pool ( create Thread Factory ( Thread . NORM PRIORITY , STRING ) ) ; }
private float compute Overscroll Percent ( ) { if ( m Over Scroll Offset >= NUM ) { return m Over Scroll Offset / m Max Over Scroll ; } else { return m Over Scroll Offset / m Max Under Scroll ; } }
private void retrieve Tracks ( Search Query query , Array List < Track > tracks ) { String query Like Selection = STRING + query . text Query + STRING ; String [ ] track Selection Args = new String [ ] { query Like Selection , query Like Selection , query Like Selection } ; Cursor cursor = null ; try { cursor = provider Utils . get Track Cursor ( TRACK SELECTION QUERY , track Selection Args , TRACK SELECTION ORDER ) ; if ( cursor != null ) { tracks . ensure Capacity ( cursor . get Count ( ) ) ; while ( cursor . move To Next ( ) ) { tracks . add ( provider Utils . create Track ( cursor ) ) ; } } } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
void load ( int position , boolean use Circular Transformation ) { if ( is Downloading ( position ) ) { return ; } Nox Item nox Item = nox Items . get ( position ) ; if ( ( nox Item . has Url ( ) && ! is Bitmap Ready ( position ) ) || nox Item . has Resource Id ( ) && ! is Drawable Ready ( position ) ) { loading [ position ] = BOOL ; load Nox Item ( position , nox Item , use Circular Transformation ) ; } }
public void insert ( String name , long cnt ) { if ( values == null ) { values = new Array List < > ( NUM ) ; } values . add ( NUM , new Count ( this , name , cnt ) ) ; }
protected void close Dialog Ok ( ) { wta . set K ( Integer . parse Int ( k Value . get Text ( ) ) ) ; super . close Dialog Ok ( ) ; }
public void add Element ( Ast Node element ) { assert Not Null ( element ) ; if ( elements == null ) elements = new Array List < Ast Node > ( ) ; elements . add ( element ) ; element . set Parent ( this ) ; }
public Create Event ( JSON Object json ) throws JSON Exception { super ( TYPE CREATE , json ) ; if ( m Block Id == null ) { throw new JSON Exception ( JSON BLOCK ID + STRING ) ; } m Xml = json . get String ( JSON XML ) ; JSON Array json Ids = json . get JSON Array ( STRING ) ; int count = json Ids . length ( ) ; List < String > ids = new Array List < > ( count ) ; for ( int i = NUM ; i < count ; ++ i ) { ids . add ( json Ids . get String ( i ) ) ; } m Ids = Collections . unmodifiable List ( ids ) ; }
public static boolean is Full Copy Resynchronizable ( Volume volume , Db Client db Client ) { boolean result = BOOL ; String replica State = volume . get Replica State ( ) ; if ( is Volume Full Copy ( volume , db Client ) && replica State != null && ! replica State . is Empty ( ) ) { Replication State state = Replication State . get Enum Value ( replica State ) ; if ( state != null && state == Replication State . SYNCHRONIZED ) { result = BOOL ; } } return result ; }
private static int end Of Tag Match ( String string , int from Index , String tag ) { int pos = string . index Of ( tag , from Index ) ; if ( pos != - NUM ) { while ( pos < string . length ( ) && Character . is Whitespace ( string . char At ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } if ( tag . contains ( STRING ) ) { tag = tag . replace All ( STRING , STRING ) ; pos = string . index Of ( tag ) ; if ( pos != - NUM ) { while ( pos < string . length ( ) && Character . is Whitespace ( string . char At ( pos ) ) ) pos ++ ; return pos + tag . length ( ) ; } } return - NUM ; }
public byte [ ] to Bytes ( ) { Byte Buffer geometry Byte Buffer = data . to Byte Buffer ( ) ; geometry Byte Buffer . rewind ( ) ; int size = NUM + geometry Byte Buffer . capacity ( ) ; Byte Buffer buf = Byte Buffer . allocate ( size ) ; buf . order ( Byte Order . LITTLE ENDIAN ) ; buf . rewind ( ) ; buf . put Int ( Byte Swapper . swap ( record Number ) ) ; buf . put Int ( Byte Swapper . swap ( content Length ) ) ; buf . put Int ( get Int From Shape Type ( shape Type ) ) ; byte [ ] bytes = geometry Byte Buffer . array ( ) ; for ( int i = NUM ; i < bytes . length ; i ++ ) { buf . put ( bytes [ i ] ) ; } return buf . array ( ) ; }
public static boolean needs Recalculation ( long query Start Time , long last Modified Time ) { return ENABLE UPDATE IN PROGRESS INDEX CALCULATION && query Start Time <= SAFE QUERY TIME . get ( ) - query Start Time + last Modified Time ; }
final public boolean check DS Closing ( Distribution Manager dm ) { Internal Distributed System ds = dm . get System ( ) ; return ( ds == null || ds . is Disconnecting ( ) ) ; }
private boolean check External Storage And Notify ( String filename , String full Dir Path , String external Storage Status ) { if ( full Dir Path == null ) { Log . e ( TAG , STRING ) ; alert Download Failure ( filename ) ; return BOOL ; } if ( ! external Storage Status . equals ( Environment . MEDIA MOUNTED ) ) { if ( external Storage Status . equals ( Environment . MEDIA SHARED ) ) { Log . e ( TAG , STRING ) ; } else { Log . e ( TAG , STRING ) ; } alert Download Failure ( filename ) ; return BOOL ; } return BOOL ; }
public static String quantityplnoun ( final int quantity , final String noun , final String one ) { final String word = plnoun ( quantity , noun ) ; if ( quantity == NUM ) { if ( one . equals ( STRING ) ) { return a noun ( word ) ; } else if ( one . equals ( STRING ) ) { return A noun ( word ) ; } else if ( one . equals ( STRING ) ) { return word ; } else { return one + STRING + word ; } } else { return Integer . to String ( quantity ) + STRING + plural ( noun ) ; } }
public org . w3 c . dom . Element sign XML ( org . w3 c . dom . Document doc , java . lang . String cert Alias , java . lang . String algorithm , java . lang . String id ) throws XML Signature Exception { return sign XML ( doc , cert Alias , algorithm , DEF ID ATTRIBUTE , id , BOOL , null ) ; }
public void read Turns ( final int [ ] columns Indices , final Buffered Reader reader ) throws IO Exception { String line = reader . read Line ( ) ; while ( line != null && line . length ( ) > NUM ) { line = reader . read Line ( ) ; } }
public Component Config Builder add Item In Fieldset ( String fieldset Label , String item Type , String item Label , String value ) { String type = String . format ( STRING , item Type ) ; String label = String . format ( STRING , fieldset Label , item Label ) ; config . add ( new Configuration Entry ( current Tab , type , label , value ) ) ; return this ; }
public Object [ ] build Parameters ( Object [ ] first Parameters , Method method , Class < ? extends Annotation > annotation Type ) { int parameters Length = method . get Parameter Types ( ) . length ; if ( first Parameters . length > NUM && parameters Length < NUM ) { throw new Repository Method Exception ( String . format ( STRING , annotation Type ) ) ; } int parameters To Resolve = parameters Length - first Parameters . length ; Object [ ] additional Parameters = new Object [ parameters To Resolve ] ; for ( int i = first Parameters . length ; i < parameters Length ; i ++ ) { additional Parameters [ i - first Parameters . length ] = parameter Provider . provide ( method , i ) ; } return concatenate ( first Parameters , additional Parameters ) ; }
public boolean is Session Token ( String site , String token ) { if ( ! site . contains ( STRING ) ) { site = site + ( STRING ) ; } Http Session Tokens Set site Tokens = session Tokens . get ( site ) ; if ( site Tokens == null ) return BOOL ; return site Tokens . is Session Token ( token ) ; }
private void add New Distribution ( ) { edit Distribution = Boolean . FALSE ; final String name = Hawkbit Common Util . trim And Null If Empty ( dist Name Text Field . get Value ( ) ) ; final String version = Hawkbit Common Util . trim And Null If Empty ( dist Version Text Field . get Value ( ) ) ; final String dist Set Type Name = Hawkbit Common Util . trim And Null If Empty ( ( String ) distset Type Name Combo Box . get Value ( ) ) ; final String desc = Hawkbit Common Util . trim And Null If Empty ( desc Text Area . get Value ( ) ) ; final boolean is Mig Step Req = req Mig Step Checkbox . get Value ( ) ; Distribution Set new Dist = entity Factory . generate Distribution Set ( ) ; set Distribution Values ( new Dist , name , version , dist Set Type Name , desc , is Mig Step Req ) ; new Dist = distribution Set Management . create Distribution Set ( new Dist ) ; notification Message . display Success ( i18 n . get ( STRING , new Object [ ] { new Dist . get Name ( ) , new Dist . get Version ( ) } ) ) ; final Set < Distribution Set Id Name > s = new Hash Set < > ( ) ; s . add ( new Distribution Set Id Name ( new Dist . get Id ( ) , new Dist . get Name ( ) , new Dist . get Version ( ) ) ) ; final Distribution Set Table distribution Set Table = Spring Context Helper . get Bean ( Distribution Set Table . class ) ; distribution Set Table . set Value ( s ) ; }
public Location rhumb Location ( double azimuth Degrees , double distance Radians , Location result ) { if ( result == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } if ( distance Radians == NUM ) { result . latitude = this . latitude ; result . longitude = this . longitude ; return result ; } double lat Radians = Math . to Radians ( this . latitude ) ; double lon Radians = Math . to Radians ( this . longitude ) ; double azimuth Radians = Math . to Radians ( azimuth Degrees ) ; double end Lat Radians = lat Radians + distance Radians * Math . cos ( azimuth Radians ) ; double end Lon Radians ; double d Lat = end Lat Radians - lat Radians ; double q ; if ( Math . abs ( d Lat ) < NEAR ZERO THRESHOLD ) { q = Math . cos ( lat Radians ) ; } else { double d Phi = Math . log ( Math . tan ( end Lat Radians / NUM + Math . PI / NUM ) / Math . tan ( lat Radians / NUM + Math . PI / NUM ) ) ; q = d Lat / d Phi ; } double d Lon = distance Radians * Math . sin ( azimuth Radians ) / q ; if ( Math . abs ( end Lat Radians ) > Math . PI / NUM ) { end Lat Radians = end Lat Radians > NUM ? Math . PI - end Lat Radians : - Math . PI - end Lat Radians ; } end Lon Radians = ( lon Radians + d Lon + Math . PI ) % ( NUM * Math . PI ) - Math . PI ; if ( Double . is Na N ( end Lat Radians ) || Double . is Na N ( end Lon Radians ) ) { result . latitude = this . latitude ; result . longitude = this . longitude ; } else { result . latitude = normalize Latitude ( Math . to Degrees ( end Lat Radians ) ) ; result . longitude = normalize Longitude ( Math . to Degrees ( end Lon Radians ) ) ; } return result ; }
public boolean start Using Data Socket ( ) { try { data Socket = local Data Socket . on Transfer ( ) ; if ( data Socket == null ) { Log . i ( TAG , STRING ) ; return BOOL ; } data Output Stream = data Socket . get Output Stream ( ) ; return BOOL ; } catch ( IO Exception e ) { Log . i ( TAG , STRING ) ; data Socket = null ; return BOOL ; } }
protected void push Write Context ( Context c ) { write Context Stack . push ( write Context ) ; write Context = c ; }
private void finish Kb Mode ( ) { m In Kb Mode = BOOL ; if ( ! m Typed Times . is Empty ( ) ) { int values [ ] = get Entered Time ( null ) ; m Radial Time Picker View . set Current Hour ( values [ NUM ] ) ; m Radial Time Picker View . set Current Minute ( values [ NUM ] ) ; if ( ! m Is 24 Hour View ) { m Radial Time Picker View . set Am Or Pm ( values [ NUM ] ) ; } m Typed Times . clear ( ) ; } update Display ( BOOL ) ; m Radial Time Picker View . set Input Enabled ( BOOL ) ; }
public CART load ( String file Name ) throws IO Exception , Mary Configuration Exception { File Input Stream fis = new File Input Stream ( file Name ) ; try { return load From Stream ( fis ) ; } finally { fis . close ( ) ; } }
public static double log Gamma ( final double x ) { if ( Double . is Na N ( x ) || ( x <= NUM ) ) { return Double . Na N ; } double g = NUM / NUM ; double tmp = x + g + NUM ; tmp = ( x + NUM ) * Math . log ( tmp ) - tmp ; double ser = LANCZOS [ NUM ] ; for ( int i = LANCZOS . length - NUM ; i > NUM ; -- i ) { ser += LANCZOS [ i ] / ( x + i ) ; } return tmp + Math . log ( Math Util . SQRTTWOPI * ser / x ) ; }
void move ( boolean move Up ) { final I Selection selection = f Table Viewer . get Selection ( ) ; if ( selection instanceof I Structured Selection ) { final I Structured Selection ss = ( I Structured Selection ) selection ; final String selected = ( String ) ss . get First Element ( ) ; int index = f Location List . index Of ( selected ) ; if ( move Up && index - NUM >= NUM ) { f Location List . remove ( index ) ; f Location List . add ( index - NUM , selected ) ; f Table Viewer . refresh ( ) ; update Enablement Move Buttons ( ss ) ; } else if ( ! move Up && index + NUM < f Location List . size ( ) ) { f Location List . remove ( index ) ; f Location List . add ( index + NUM , selected ) ; f Table Viewer . refresh ( ) ; update Enablement Move Buttons ( ss ) ; } } }
static String create Jsni Block ( I Java Project project , String body , int indentation Units ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( Code Formatter Util . create Indent String ( indentation Units + NUM , project ) ) ; if ( body != null ) { sb . append ( body ) ; } sb . append ( STRING ) ; sb . append ( Code Formatter Util . create Indent String ( indentation Units , project ) ) ; sb . append ( STRING ) ; return sb . to String ( ) ; }
private boolean is Job Scheduling Needed ( URI id , String type , boolean in Progress , boolean is Error , boolean scheduler , long last Time , long next Time ) { long system Time = System . current Time Millis ( ) ; long tolerance = Long . parse Long ( config Info . get ( TOLERANCE ) ) * NUM ; logger . info ( STRING , next Time , last Time ) ; long refresh Interval = get Refresh Interval ( type ) ; if ( ! in Progress ) { if ( scheduler ) { if ( system Time < next Time - tolerance ) { logger . info ( STRING , id + STRING + type , new Date ( next Time ) ) ; logger . info ( STRING , new Date ( system Time ) , tolerance ) ; return BOOL ; } } if ( ! scheduler && is Error && last Time > NUM ) { logger . info ( STRING , type , id ) ; return BOOL ; } if ( system Time - last Time < refresh Interval * NUM ) { logger . info ( STRING , id , type ) ; return BOOL ; } } else if ( ! scheduler && ( system Time - last Time > refresh Interval * NUM ) && last Time > NUM ) { logger . info ( STRING , type , id ) ; } else if ( scheduler && ( system Time - last Time > refresh Interval * NUM ) && next Time > NUM && System . current Time Millis ( ) - next Time >= Job Intervals . get Max Idle Interval ( ) * NUM ) { logger . info ( STRING , type , id ) ; } else { logger . info ( STRING , type , id ) ; return BOOL ; } return BOOL ; }

public boolean is Output Column Name Allowed ( String column Name ) { if ( column Name == null || column Name . length ( ) == NUM ) return BOOL ; get Output Column Names ( BOOL ) ; for ( int i = NUM ; i < m outputcolumnnames . length ; i ++ ) { if ( column Name . equals ( m outputcolumnnames [ i ] ) ) return BOOL ; } return BOOL ; }
public void test Field Types ( ) throws Exception { Prepared Statement ps = connection . prepare Statement ( STRING ) ; for ( int i = NUM ; i < TEST ROW COUNT ; i ++ ) { ps . set Int ( NUM , i ) ; ps . set Bytes ( NUM , test Data [ i ] ) ; ps . execute Update ( ) ; } ps . close ( ) ; Statement stmt = connection . create Statement ( ) ; Result Set rs = stmt . execute Query ( STRING ) ; try { int counter = NUM ; while ( rs . next ( ) ) { int id = rs . get Int ( STRING ) ; byte [ ] data = rs . get Bytes ( STRING ) ; assert True ( STRING + id + STRING , Arrays . equals ( test Data [ id ] , data ) ) ; counter ++ ; } assert True ( STRING + TEST ROW COUNT + STRING + counter , TEST ROW COUNT == counter ) ; } finally { rs . close ( ) ; stmt . close ( ) ; } }
private synchronized void rebuild Journal ( ) throws IO Exception { if ( journal Writer != null ) { journal Writer . close ( ) ; } Writer writer = new Buffered Writer ( new Output Stream Writer ( new File Output Stream ( journal File Tmp ) , IO Util . US ASCII ) ) ; try { writer . write ( MAGIC ) ; writer . write ( STRING ) ; writer . write ( VERSION 1 ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( app Version ) ) ; writer . write ( STRING ) ; writer . write ( Integer . to String ( value Count ) ) ; writer . write ( STRING ) ; writer . write ( STRING ) ; for ( Entry entry : lru Entries . values ( ) ) { if ( entry . current Editor != null ) { writer . write ( DIRTY + STRING + entry . key + STRING ) ; } else { writer . write ( CLEAN + STRING + entry . key + entry . get Lengths ( ) + STRING ) ; } } } finally { writer . close ( ) ; } if ( journal File . exists ( ) ) { rename To ( journal File , journal File Backup , BOOL ) ; } rename To ( journal File Tmp , journal File , BOOL ) ; journal File Backup . delete ( ) ; journal Writer = new Buffered Writer ( new Output Stream Writer ( new File Output Stream ( journal File , BOOL ) , IO Util . US ASCII ) ) ; }
public void load Plugins ( File file ) throws IO Exception , Class Not Found Exception { Object plugin Object , active List Object ; File Input Stream fis ; Object Input Stream ois ; fis = new File Input Stream ( file ) ; ois = new Object Input Stream ( fis ) ; plugin Object = ois . read Object ( ) ; active List Object = ois . read Object ( ) ; ois . close ( ) ; if ( ! ( plugin Object instanceof Plugin Container ) ) { LOG . error ( STRING ) ; return ; } Plugin Container collection = ( Plugin Container ) plugin Object ; for ( Abstract Plugin saved Plugin : collection ) { Abstract Plugin current Plugin = all Plugins . get By Name ( saved Plugin . get Name ( ) ) ; if ( current Plugin != null ) { current Plugin . restore Configuration ( saved Plugin ) ; } else { LOG . warn ( STRING + saved Plugin . get Name ( ) + STRING ) ; } } if ( ! ( active List Object instanceof List ) ) { LOG . error ( STRING ) ; return ; } @ Suppress Warnings ( STRING ) List active List = ( List ) active List Object ; for ( Object active : active List ) { if ( active instanceof String ) { set Active ( get By Name ( ( String ) active ) , BOOL ) ; } } }
public void wait For State ( final String collection , long wait , Time Unit unit , Collection State Predicate predicate ) throws Interrupted Exception , Timeout Exception { final Count Down Latch latch = new Count Down Latch ( NUM ) ; Collection State Watcher watcher = null ; register Collection State Watcher ( collection , watcher ) ; try { if ( ! latch . await ( wait , unit ) ) throw new Timeout Exception ( ) ; } finally { remove Collection State Watcher ( collection , watcher ) ; } }
private void blackman Harris 4 s ( int size ) { int start = ( window Function . length - size ) / NUM ; int stop = ( window Function . length + size ) / NUM ; double scale = NUM / ( double ) size / NUM ; for ( int i = NUM ; start < stop ; start ++ , i ++ ) window Function [ i ] = scale * ( NUM - NUM * Math . cos ( two PI * i / size ) + NUM * Math . cos ( NUM * two PI * i / size ) - NUM * Math . cos ( NUM * two PI * i / size ) ) ; }
public int hash Code ( ) { if ( hash Code == - NUM ) { hash Code = ASCII Case Insensitive Comparator . lower Case Hash Code ( name ) ; } return hash Code ; }
public Boolean is Expired ( ) { if ( is Never Expiry ) { return BOOL ; } if ( write Time <= NUM ) { return BOOL ; } if ( expiration Time <= NUM ) { return BOOL ; } long interval Time = System . current Time Millis ( ) - write Time ; String format = STRING ; String current Time Str = get String By Format ( System . current Time Millis ( ) , format ) ; String write Time Str = get String By Format ( write Time , format ) ; C Log . d ( STRING , ( Object ) current Time Str , write Time Str , interval Time / NUM ) ; if ( interval Time < expiration Time ) { return BOOL ; } else { return BOOL ; } }
protected Conversation Parser ( final Sentence Implementation sentence ) { String text = sentence . get Original Text ( ) ; if ( text == null ) { text = STRING ; } else if ( text . starts With ( STRING ) ) { text = STRING ; } final String text Without Punctation = detect Sentence Type ( text , sentence ) ; tokenizer = new String Tokenizer ( text Without Punctation ) ; }
public void tear Down ( Proxy Test Case test Case ) throws Exception { if ( BOOL && data Dir . exists ( ) && data Dir . is Directory ( ) ) { recursive Delete ( data Dir ) ; } }
protected boolean check Special Position ( Element current Rule Part , String special Position Type ) { Named Node Map att Nodes = current Rule Part . get Attributes ( ) ; for ( int z = NUM ; z < att Nodes . get Length ( ) ; z ++ ) { Node el = att Nodes . item ( z ) ; String current Att = el . get Node Name ( ) ; String current Val = el . get Node Value ( ) ; if ( current Att . equals ( STRING ) ) { if ( ! current Val . starts With ( STRING ) ) { if ( ! special Position Type . equals ( current Val ) ) return BOOL ; } else { current Val = current Val . substring ( NUM , current Val . length ( ) ) ; if ( special Position Type . equals ( current Val ) ) return BOOL ; } } } return BOOL ; }
private static void register Service Class ( final Class < ? > type , final Map < String , Class Loader > classloader Map , final Class Loader class Loader , final Set < Class > classes ) { final String class Name = type . get Name ( ) ; final Class Loader registered Class Loader = classloader Map . get ( class Name ) ; if ( registered Class Loader == null ) { classloader Map . put ( class Name , class Loader ) ; classes . add ( type ) ; } else { boolean loaded From Ancestor = BOOL ; Class Loader ancestor Class Loader = class Loader . get Parent ( ) ; while ( ancestor Class Loader != null ) { if ( ancestor Class Loader == registered Class Loader ) { loaded From Ancestor = BOOL ; break ; } ancestor Class Loader = ancestor Class Loader . get Parent ( ) ; } if ( ! loaded From Ancestor ) { logger . warn ( STRING + class Name + STRING + class Loader + STRING + registered Class Loader + STRING ) ; } } }
public Set create Sub Group Containers ( Set group Container Names ) throws AM Exception , SSO Exception { Iterator iter = group Container Names . iterator ( ) ; Set group Containers = new Hash Set ( ) ; while ( iter . has Next ( ) ) { String group Container DN = AM Naming Attr Manager . get Naming Attr ( GROUP CONTAINER ) + STRING + ( ( String ) iter . next ( ) ) + STRING + entry DN ; AM Group Container Impl group Container Impl = new AM Group Container Impl ( token , group Container DN ) ; group Container Impl . create ( ) ; group Containers . add ( group Container Impl ) ; } return group Containers ; }
public void schedule ( Timer Task task , Date when , long period ) { if ( period <= NUM || when . get Time ( ) < NUM ) { throw new Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) - System . current Time Millis ( ) ; schedule Impl ( task , delay < NUM ? NUM : delay , period , BOOL ) ; }
void compile Class ( Source java Source , Source java Class , String source Path , boolean is Make ) throws Class Not Found Exception { try { Java Compiler Util compiler = Java Compiler Util . create ( get Class Loader ( ) ) ; compiler . set Class Dir ( class Dir ) ; compiler . set Source Dir ( source Dir ) ; if ( encoding != null ) compiler . set Encoding ( encoding ) ; compiler . set Args ( args ) ; compiler . set Compile Parent ( ! is Make ) ; compiler . set Source Extension ( source Ext ) ; if ( compiler != null ) compiler . set Compiler ( compiler ) ; String prefix = source Dir . get Path ( ) ; String full = java Source . get Path ( ) ; String source ; if ( full . starts With ( prefix ) ) { source = full . substring ( prefix . length ( ) ) ; if ( source . starts With ( STRING ) ) source = source . substring ( NUM ) ; } else source = java Source . get Path ( ) ; compiler . compile If Modified ( source , null ) ; } catch ( Exception e ) { log . log ( Level . FINEST , e . to String ( ) , e ) ; throw new Compile Class Not Found ( e ) ; } }
public static boolean runs On Dev Env ( ) { return Runtime Mode . DEVELOPMENT == Latkes . get Runtime Mode ( ) ; }
private static String to String ( Serializable o ) throws IO Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( baos ) ; oos . write Object ( o ) ; oos . close ( ) ; return new String ( Base 64 . encode ( baos . to Byte Array ( ) , Base 64 . DEFAULT ) ) ; }
public static boolean is Java Identifier ( final String str ) { if ( str == null || str . length ( ) < NUM ) { return BOOL ; } if ( ! Character . is Java Identifier Start ( str . char At ( NUM ) ) ) { return BOOL ; } for ( int i = NUM ; i < str . length ( ) ; i ++ ) { if ( ! Character . is Java Identifier Part ( str . char At ( i ) ) ) { return BOOL ; } } return BOOL ; }
static boolean less Than Unsigned ( long x1 , long x2 ) { return ( x1 + Long . MIN VALUE ) < ( x2 + Long . MIN VALUE ) ; }
public void update Track Point ( Point p ) { int new Loc X = Math . min ( p . x , this . anchor . x ) ; int new Loc Y = Math . min ( p . y , this . anchor . y ) ; int delta X = Math . abs ( p . x - this . anchor . x ) ; int delta Y = Math . abs ( p . y - this . anchor . y ) ; set Location ( new Loc X , new Loc Y ) ; set Size ( delta X , delta Y ) ; }
public String read Config Name ( Solr Zk Client zk Client , String collection ) throws Keeper Exception , Interrupted Exception { if ( collection == null ) { throw new Illegal Argument Exception ( STRING ) ; } String config Name = null ; byte [ ] alias Data = zk Client . get Data ( Zk State Reader . ALIASES , null , null , BOOL ) ; Aliases aliases = Cluster State . load ( alias Data ) ; String alias = aliases . get Collection Alias ( collection ) ; if ( alias != null ) { List < String > alias List = Str Utils . split Smart ( alias , STRING , BOOL ) ; if ( alias List . size ( ) > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } collection = alias List . get ( NUM ) ; } String path = Zk State Reader . COLLECTIONS ZKNODE + STRING + collection ; if ( LOG . is Info Enabled ( ) ) { LOG . info ( STRING + path ) ; } byte [ ] data = zk Client . get Data ( path , null , null , BOOL ) ; if ( data != null ) { Zk Node Props props = Zk Node Props . load ( data ) ; config Name = props . get Str ( Zk Controller . CONFIGNAME PROP ) ; } if ( config Name != null && ! zk Client . exists ( Zk Config Manager . CONFIGS ZKNODE + STRING + config Name , BOOL ) ) { LOG . error ( STRING + config Name ) ; throw new Illegal Argument Exception ( STRING + config Name ) ; } return config Name ; }
public Chat Builder add Email ( String email ) { emails . add ( email ) ; return this ; }
public static Hash Provider best ( Hash Parameters params , Enum Set < Hash Support > required ) { Hash Provider result = null ; Enum Set < Hash Support > result Support = null ; for ( final Hash Provider provider : ALL PROVIDERS ) { final Enum Set < Hash Support > support = provider . query Support ( params ) ; if ( support . contains All ( required ) && ( result == null || Hash Support . compare ( support , result Support ) < NUM ) ) { result = provider ; result Support = support ; } } if ( result == null ) throw new Unsupported Operation Exception ( ) ; return result ; }
public byte [ ] read Raw Bytes ( final int size ) throws IO Exception { if ( size < NUM ) { throw Invalid Protocol Buffer Exception . negative Size ( ) ; } if ( total Bytes Retired + buffer Pos + size > current Limit ) { skip Raw Bytes ( current Limit - total Bytes Retired - buffer Pos ) ; throw Invalid Protocol Buffer Exception . truncated Message ( ) ; } if ( size <= buffer Size - buffer Pos ) { final byte [ ] bytes = new byte [ size ] ; System . arraycopy ( buffer , buffer Pos , bytes , NUM , size ) ; buffer Pos += size ; return bytes ; } else if ( size < BUFFER SIZE ) { final byte [ ] bytes = new byte [ size ] ; int pos = buffer Size - buffer Pos ; System . arraycopy ( buffer , buffer Pos , bytes , NUM , pos ) ; buffer Pos = buffer Size ; refill Buffer ( BOOL ) ; while ( size - pos > buffer Size ) { System . arraycopy ( buffer , NUM , bytes , pos , buffer Size ) ; pos += buffer Size ; buffer Pos = buffer Size ; refill Buffer ( BOOL ) ; } System . arraycopy ( buffer , NUM , bytes , pos , size - pos ) ; buffer Pos = size - pos ; return bytes ; } else { final int original Buffer Pos = buffer Pos ; final int original Buffer Size = buffer Size ; total Bytes Retired += buffer Size ; buffer Pos = NUM ; buffer Size = NUM ; int size Left = size - ( original Buffer Size - original Buffer Pos ) ; final List < byte [ ] > chunks = new Array List < byte [ ] > ( ) ; while ( size Left > NUM ) { final byte [ ] chunk = new byte [ Math . min ( size Left , BUFFER SIZE ) ] ; int pos = NUM ; while ( pos < chunk . length ) { final int n = ( input == null ) ? - NUM : input . read ( chunk , pos , chunk . length - pos ) ; if ( n == - NUM ) { throw Invalid Protocol Buffer Exception . truncated Message ( ) ; } total Bytes Retired += n ; pos += n ; } size Left -= chunk . length ; chunks . add ( chunk ) ; } final byte [ ] bytes = new byte [ size ] ; int pos = original Buffer Size - original Buffer Pos ; System . arraycopy ( buffer , original Buffer Pos , bytes , NUM , pos ) ; for ( final byte [ ] chunk : chunks ) { System . arraycopy ( chunk , NUM , bytes , pos , chunk . length ) ; pos += chunk . length ; } return bytes ; } }
static boolean pair Diff ( int ar [ ] , int x ) { Arrays . sort ( ar ) ; int len = ar . length ; for ( int i = NUM , j = NUM ; i < len && j < len ; ) { if ( i != j && ar [ j ] - ar [ i ] == x ) { return BOOL ; } else if ( ar [ j ] - ar [ i ] < x ) { j ++ ; } else { i ++ ; } } return BOOL ; }
public synchronized void import From File ( ) { Path file = Paths . get ( import File Name ) ; try ( Buffered Reader reader = Files . new Buffered Reader ( file , CHARSET ) ) { LOGGER . info ( STRING + file . to Absolute Path ( ) ) ; String line ; while ( ( line = reader . read Line ( ) ) != null ) { String result = command ( line ) ; LOGGER . info ( String . format ( STRING , result , line ) ) ; } } catch ( IO Exception ex ) { LOGGER . warning ( STRING + ex ) ; } }
public double local Score ( int i , int ... parents ) { Conditional Gaussian Likelihood . Ret ret = likelihood . get Likelihood Ratio ( i , parents ) ; int N = data Set . get Num Rows ( ) ; double lik = ret . get Lik ( ) ; int k = ret . get Dof ( ) ; double prior = get Structure Prior ( parents ) ; return NUM * lik - k * Math . log ( N ) + prior ; }
public boolean add ( final T item ) { final Adapter Transaction add Transaction = new Add Transaction < > ( this , item ) ; final boolean success = add Transaction . perform ( ) ; m Transactions . offer ( add Transaction ) ; return success ; }
private List < Type > parse Type List ( List < Map < String , Object > > types , List < Type Parameter > type Params ) { List < Type > ts = new Array List < Type > ( types . size ( ) ) ; for ( Map < String , Object > st : types ) { ts . add ( get Type From Json ( st , null , type Params ) ) ; } return ts ; }
public static void assert Throws ( Class < ? > throwable , Checked Runnable runnable , Consumer < Throwable > exception Consumer ) { boolean fail = BOOL ; try { runnable . run ( ) ; fail = BOOL ; } catch ( Throwable t ) { if ( ! throwable . is Instance ( t ) ) throw new Assertion Error ( STRING , t ) ; exception Consumer . accept ( t ) ; } if ( fail ) Assert . fail ( STRING ) ; }
public void build ( String code ) { try { result . put ( resources . get String ( R . string . intent extra status ) , resources . get String ( R . string . shared pref default status ) ) ; result . put ( resources . get String ( R . string . intent extra code ) , code ) ; operation List Result . put ( result ) ; } catch ( JSON Exception e ) { Log . e ( TAG , STRING + e . to String ( ) ) ; } }
public Cost Estimate cost Index Scan ( Index index , long nrows ) { return new Cost Estimate ( nrows , model . index Scan ( schema . index Row Type ( index ) , ( int ) nrows ) ) ; }
public long nswap ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public static void create Realm Privileges ( SSO Token token , String realm Name ) throws SSO Exception , Delegation Exception { String realm Id = DN Mapper . org Name To DN ( realm Name ) ; Delegation Manager dm = new Delegation Manager ( token , realm Name ) ; Set privs = dm . get Configured Privilege Names ( ) ; if ( ( privs == null ) || privs . is Empty ( ) ) { return ; } if ( debug . message Enabled ( ) ) { debug . message ( STRING ) ; } Iterator it = privs . iterator ( ) ; while ( it . has Next ( ) ) { Service Config perm = null ; String priv Name = ( String ) it . next ( ) ; if ( get Revision Number ( ) == AM 70 DELEGATION REVISION ) { perm = Delegation Utils . get Permission Config ( null , priv Name , BOOL ) ; } else { perm = Delegation Utils . get Privilege Config ( null , priv Name , BOOL ) ; } Map attrs = perm . get Attributes ( ) ; if ( ( attrs == null ) || attrs . is Empty ( ) ) { throw new Delegation Exception ( Res Bundle Utils . rb Name , STRING , null , null ) ; } Set subjects = null ; Set config Subjects = ( Set ) attrs . get ( SUBJECTS IN LEGACY MODE ) ; if ( ( config Subjects != null ) && ( ! config Subjects . is Empty ( ) ) ) { Iterator s Iter = config Subjects . iterator ( ) ; subjects = new Hash Set ( ) ; while ( s Iter . has Next ( ) ) { String sv = ( String ) s Iter . next ( ) ; subjects . add ( swap Realm Tag ( realm Id , sv ) ) ; } } Delegation Privilege priv = new Delegation Privilege ( priv Name , subjects , realm Name ) ; dm . add Privilege ( priv ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + priv Name + STRING + realm Name ) ; } } }
@ Override public boolean equals ( Object o ) { if ( o == this ) return BOOL ; if ( ! ( o instanceof Record ) ) return BOOL ; Record other = ( Record ) o ; return ( name == null ? other . name == null : name . equals ( other . name ) ) && ( type == null ? other . type == null : type . equals ( other . type ) ) && ( location == null ? other . location == null : location . equals ( other . location ) ) && ( metadata == null ? other . metadata == null : metadata . equals ( other . metadata ) ) && ( registration == null ? other . registration == null : registration . equals ( other . registration ) ) && ( status == null ? other . status == null : status . equals ( other . status ) ) ; }
@ Override public boolean is Armed ( ) { boolean b = should Act Like Button ( ) || ( pressed When Popup Visible && combo Box . is Popup Visible ( ) ) ; return b ? is Pressed ( ) : super . is Armed ( ) ; }
public Encoder Test Suite Builder invalid ( int min , int max ) { invalid . set ( min , max + NUM ) ; valid . clear ( min , max + NUM ) ; encoded . clear ( min , max + NUM ) ; return this ; }
private void roll Back Vpool On Vplex Backend Volume ( Volume volume , List < Volume > volumes To Update , Db Client db Client , URI old Vpool URI ) { Volume backend Src = V Plex Util . get VPLEX Backend Volume ( volume , BOOL , db Client , BOOL ) ; if ( backend Src != null ) { log . info ( STRING , backend Src . get Id ( ) , backend Src . get Label ( ) ) ; backend Src . set Virtual Pool ( old Vpool URI ) ; log . info ( STRING , old Vpool URI ) ; volumes To Update . add ( backend Src ) ; Volume backend Ha = V Plex Util . get VPLEX Backend Volume ( volume , BOOL , db Client , BOOL ) ; if ( backend Ha != null ) { log . info ( STRING , backend Ha . get Id ( ) , backend Ha . get Label ( ) ) ; Virtual Pool old Vpool Obj = db Client . query Object ( Virtual Pool . class , old Vpool URI ) ; Virtual Pool old HA Vpool = Virtual Pool . get HAV Pool ( old Vpool Obj , db Client ) ; if ( old HA Vpool == null ) { old HA Vpool = old Vpool Obj ; } backend Ha . set Virtual Pool ( old HA Vpool . get Id ( ) ) ; log . info ( STRING , old HA Vpool . get Id ( ) ) ; volumes To Update . add ( backend Ha ) ; } } }
public static String clear Last Viewed Categories ( Http Servlet Request request , Http Servlet Response response ) { Http Session session = request . get Session ( ) ; if ( session != null ) { session . set Attribute ( STRING , Fast List . new Instance ( ) ) ; } return STRING ; }
public boolean equals ( Object obj ) { if ( this == obj ) return BOOL ; if ( obj instanceof EC Field F 2 m ) { return ( ( m == ( ( EC Field F 2 m ) obj ) . m ) && ( Arrays . equals ( ks , ( ( EC Field F 2 m ) obj ) . ks ) ) ) ; } return BOOL ; }
public Request Authenticator ( Secure Random rand , String secret ) throws No Such Algorithm Exception { final byte [ ] authenticator = new byte [ NUM ] ; rand . next Bytes ( authenticator ) ; final Message Digest md 5 = Message Digest . get Instance ( STRING ) ; md 5 . update ( authenticator ) ; md 5 . update ( secret . get Bytes ( Standard Charsets . UTF 8 ) ) ; octets = md 5 . digest ( ) ; }
private void parse Config ( ) throws Parser Configuration Exception , SAX Exception , IO Exception { Document Builder Factory factory = Document Builder Factory . new Instance ( ) ; factory . set Ignoring Comments ( BOOL ) ; Document Builder builder = factory . new Document Builder ( ) ; Document dom Tree = null ; if ( file Name . starts With ( STRING ) || file Name . starts With ( STRING ) ) { if ( ! Local File Utils . validate External Filename ( file Name , BOOL ) ) throw new IO Exception ( STRING ) ; File System DFS = File System . get ( Configuration Manager . get Cached Job Conf ( ) ) ; Path config File Path = new Path ( file Name ) ; dom Tree = builder . parse ( DFS . open ( config File Path ) ) ; } else { if ( ! Local File Utils . validate External Filename ( file Name , BOOL ) ) throw new IO Exception ( STRING ) ; dom Tree = builder . parse ( file Name ) ; } xml Root = dom Tree . get Document Element ( ) ; }
public Str Builder insert ( int index , Object obj ) { if ( obj == null ) { return insert ( index , null Text ) ; } return insert ( index , obj . to String ( ) ) ; }
@ Override public void handle Mouse Pressed ( Chart Canvas canvas , Mouse Event e ) { this . mouse Pressed Point = new Point 2 D . Double ( e . get X ( ) , e . get Y ( ) ) ; }
public static void concat ( Iterable < File > to Merge , File dst ) throws IO Exception { try ( File Channel dst Channel = File Channel . open ( dst . to Path ( ) , Standard Open Option . CREATE , Standard Open Option . TRUNCATE EXISTING , Standard Open Option . WRITE ) ) { for ( File file : to Merge ) { try ( Random Access File raf = new Random Access File ( file , STRING ) ) { File Channel channel = raf . get Channel ( ) ; dst Channel . write ( channel . map ( File Channel . Map Mode . READ ONLY , NUM , raf . length ( ) ) ) ; } } } }
private void populate Volume Recommendations ( Virtual Pool Capability Values Wrapper capabilities , Virtual Pool source Volume V Pool , Volume source Volume , String task Id , Task List task List , Integer volume Count , int volume Counter , String volume Label , List < Volume > prepared Volumes , List < Recommendation > volume Recommendations ) { List < Recommendation > current Recommendation = new Array List < Recommendation > ( ) ; Virtual Pool mirror V Pool = source Volume V Pool ; if ( ! is Null Or Empty ( source Volume V Pool . get Mirror Virtual Pool ( ) ) ) { URI mirror Pool Uri = URI . create ( source Volume V Pool . get Mirror Virtual Pool ( ) ) ; if ( ! URI Util . is Null ( mirror Pool Uri ) ) { mirror V Pool = db Client . query Object ( Virtual Pool . class , mirror Pool Uri ) ; } } for ( int i = NUM ; i < capabilities . get Resource Count ( ) ; i ++ ) { Volume Recommendation volume Recommendation = new Volume Recommendation ( Volume Recommendation . Volume Type . BLOCK VOLUME , source Volume . get Capacity ( ) , source Volume V Pool , source Volume . get Virtual Array ( ) ) ; volume Recommendation . set Id ( source Volume . get Id ( ) ) ; volume Recommendation . add Storage Pool ( source Volume . get Pool ( ) ) ; current Recommendation . add ( volume Recommendation ) ; } Virtual Array v Array = db Client . query Object ( Virtual Array . class , source Volume . get Virtual Array ( ) ) ; scheduler . get Recommendations For Mirrors ( v Array , mirror V Pool , capabilities , current Recommendation ) ; scheduler . prepare Recommended Volumes ( null , task Id , task List , null , null , source Volume V Pool , volume Count , current Recommendation , null , volume Counter , volume Label , prepared Volumes , capabilities , BOOL ) ; volume Recommendations . add All ( current Recommendation ) ; }
public static Lat Lon great Circle End Position ( Lat Lon p , double great Circle Azimuth Radians , double path Length Radians ) { if ( p == null ) { throw new Illegal Argument Exception ( STRING ) ; } return great Circle End Position ( p , Angle . from Radians ( great Circle Azimuth Radians ) , Angle . from Radians ( path Length Radians ) ) ; }
public Dimension maximum Layout Size ( Container target ) { Dimension size ; synchronized ( this ) { check Container ( target ) ; check Requests ( ) ; size = new Dimension ( x Total . maximum , y Total . maximum ) ; } Insets insets = target . get Insets ( ) ; size . width = ( int ) Math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right , Integer . MAX VALUE ) ; size . height = ( int ) Math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom , Integer . MAX VALUE ) ; return size ; }
String pull In Source ( Input Stream in , Charset encoding ) { String script = STRING ; Buffered Reader f = null ; try { String Builder sb = new String Builder ( ) ; Reader reader = null ; if ( encoding == null ) reader = new Input Stream Reader ( in ) ; else reader = new Input Stream Reader ( in , encoding ) ; f = new Buffered Reader ( reader ) ; String line ; while ( ( line = f . read Line ( ) ) != null ) { sb . append ( line ) ; sb . append ( STRING ) ; } script = sb . to String ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return script ; }
public synchronized void remove ( Lease lease ) throws Unknown Lease Exception { Entry e = find Entry ( lease ) ; if ( ! remove Lease In Renew ( e ) ) leases . remove ( e ) ; calc Actual Renews ( ) ; logger . log ( Level . FINE , STRING , lease ) ; }
private float normalize Time ( int index ) { if ( ! m Is Exiting ) return ( float ) m Current Duration [ index ] / m Duration ; else return NUM - ( float ) m Current Duration [ index ] / m Duration ; }
protected final void write S ( String text , int size ) { if ( text == null ) { buf . put ( new byte [ size ] ) ; } else { final int len = text . length ( ) ; for ( int i = NUM ; i < len ; i ++ ) { buf . put Char ( text . char At ( i ) ) ; } buf . put ( new byte [ size - ( len * NUM ) ] ) ; } }
@ Override public void on Draw Frame ( final GL 10 unused ) { GLES 20 . gl Clear ( GLES 20 . GL COLOR BUFFER BIT ) ; if ( requesr Update Tex ) { requesr Update Tex = BOOL ; mS Texture . update Tex Image ( ) ; mS Texture . get Transform Matrix ( m St Matrix ) ; update ( h Tex , m St Matrix ) ; } GLES 20 . gl Bind Framebuffer ( GLES 20 . GL FRAMEBUFFER , NUM ) ; GLES 20 . gl Clear ( GLES 20 . GL COLOR BUFFER BIT ) ; GLES 20 . gl Enable ( GLES 20 . GL BLEND ) ; final Camera GL View parent = m Weak Parent . get ( ) ; render ( parent . m Render Viewport . x , parent . m Render Viewport . y , parent . m Render Viewport . width , parent . m Render Viewport . height ) ; GLES 20 . gl Disable ( GLES 20 . GL BLEND ) ; flip = ! flip ; if ( flip ) { synchronized ( this ) { if ( m Video Encoder != null ) { m Video Encoder . frame Available Soon ( m St Matrix , m Mvp Matrix ) ; } } } }
protected int consume Available Records ( Consumer < Source Record > record Consumer ) { List < Source Record > records = new Linked List < > ( ) ; consumed Lines . drain To ( records ) ; if ( record Consumer != null ) { records . for Each ( record Consumer ) ; } return records . size ( ) ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) { return BOOL ; } if ( o == null ) { return BOOL ; } if ( ! ( o instanceof Column ) ) { return BOOL ; } Column column = ( Column ) o ; return Objects . equals ( name , column . name ) ; }
protected Map < String , Double > load Bing Liu ( ) throws File Not Found Exception { Map < String , Double > lexi Map = new Hash Map < String , Double > ( ) ; File file = new File ( STRING ) ; Scanner scanner = new Scanner ( file ) ; while ( scanner . has Next Line ( ) ) { lexi Map . put ( scanner . next Line ( ) , NUM ) ; } scanner . close ( ) ; File file 2 = new File ( STRING ) ; Scanner scanner 2 = new Scanner ( file 2 ) ; while ( scanner 2 . has Next Line ( ) ) { lexi Map . put ( scanner 2 . next Line ( ) , - NUM ) ; } scanner 2 . close ( ) ; return lexi Map ; }
public final boolean is Valid ( ) { return ! Float . is Na N ( x ) && ! Float . is Infinite ( x ) && ! Float . is Na N ( y ) && ! Float . is Infinite ( y ) ; }
public boolean is Plural ( ) { return type String . contains ( SUFFIX PLURAL ) ; }
private void stop ( ) { if ( this . throttle == null ) { return ; } internal Adjust = BOOL ; throttle . set Speed Setting ( - NUM ) ; speed Slider . set Value ( NUM ) ; if ( speed Spinner != null ) { speed Spinner Model . set Value ( Integer . value Of ( NUM ) ) ; } if ( speed Slider Continuous != null ) { speed Slider Continuous . set Value ( Integer . value Of ( NUM ) ) ; } internal Adjust = BOOL ; }
public static Dag markov Blanket Dag ( Node target , Graph dag ) { if ( dag . get Node ( target . get Name ( ) ) == null ) { throw new Null Pointer Exception ( STRING + target ) ; } Graph blanket = new Edge List Graph ( ) ; blanket . add Node ( target ) ; List < Node > parents = dag . get Parents ( target ) ; for ( Object parent 1 : parents ) { Node parent = ( Node ) parent 1 ; blanket . add Node ( parent ) ; blanket . add Directed Edge ( parent , target ) ; } List < Node > children = dag . get Children ( target ) ; List < Node > parents Of Children = new Linked List < > ( ) ; for ( Object a Children : children ) { Node child = ( Node ) a Children ; if ( ! blanket . contains Node ( child ) ) { blanket . add Node ( child ) ; } blanket . add Directed Edge ( target , child ) ; List < Node > parents Of Child = dag . get Parents ( child ) ; parents Of Child . remove ( target ) ; for ( Object a Parents Of Child : parents Of Child ) { Node parent Of Child = ( Node ) a Parents Of Child ; if ( ! parents Of Children . contains ( parent Of Child ) ) { parents Of Children . add ( parent Of Child ) ; } if ( ! blanket . contains Node ( parent Of Child ) ) { blanket . add Node ( parent Of Child ) ; } blanket . add Directed Edge ( parent Of Child , child ) ; } } parents Of Children . remove All ( parents ) ; for ( Object parent 2 : parents ) { Node parent = ( Node ) parent 2 ; for ( Object a Parents Of Children : parents Of Children ) { Node parent Of Child = ( Node ) a Parents Of Children ; Edge edge 1 = dag . get Edge ( parent , parent Of Child ) ; Edge edge 2 = blanket . get Edge ( parent , parent Of Child ) ; if ( edge 1 != null && edge 2 == null ) { Edge new Edge = new Edge ( parent , parent Of Child , edge 1 . get Proximal Endpoint ( parent ) , edge 1 . get Proximal Endpoint ( parent Of Child ) ) ; blanket . add Edge ( new Edge ) ; } } } for ( Object a Children 1 : children ) { Node child = ( Node ) a Children 1 ; for ( Object a Parents Of Children : parents Of Children ) { Node parent Of Child = ( Node ) a Parents Of Children ; Edge edge 1 = dag . get Edge ( child , parent Of Child ) ; Edge edge 2 = blanket . get Edge ( child , parent Of Child ) ; if ( edge 1 != null && edge 2 == null ) { Edge new Edge = new Edge ( child , parent Of Child , edge 1 . get Proximal Endpoint ( child ) , edge 1 . get Proximal Endpoint ( parent Of Child ) ) ; blanket . add Edge ( new Edge ) ; } } } return new Dag ( blanket ) ; }
private Class Vertex resolve Class Vertex ( Class Descriptor class Descriptor ) throws Class Not Found Exception { Class Vertex type Vertex = optionally Resolve Class Vertex ( class Descriptor ) ; if ( ! type Vertex . is Resolved ( ) ) { Class Descriptor . throw Class Not Found Exception ( class Descriptor ) ; } assert type Vertex . is Resolved ( ) ; return type Vertex ; }
public void dup 2 X 1 ( ) { mv . visit Insn ( Opcodes . DUP 2 X1 ) ; }
public boolean is Offline Page Model Loaded ( ) { return m Is Native Offline Page Model Loaded ; }
@ Suppress Warnings ( STRING ) public static List < String > parse Get Bucket Replication Location ( Input Stream response Body ) throws Response Parse Exception { try { Element root = get Xml Root Element ( response Body ) ; List < String > location List = new Array List < String > ( ) ; List < Element > loc Elements = root . get Children ( STRING ) ; for ( Element loc Elem : loc Elements ) { location List . add ( loc Elem . get Text ( ) ) ; } return location List ; } catch ( Exception e ) { throw new Response Parse Exception ( e . get Message ( ) , e ) ; } }
public Run Panel ( ) { m Start But . add Action Listener ( this ) ; m Stop But . add Action Listener ( this ) ; m Start But . set Enabled ( BOOL ) ; m Stop But . set Enabled ( BOOL ) ; m Start But . set Mnemonic ( STRING ) ; m Stop But . set Mnemonic ( STRING ) ; m Log . status Message ( NOT RUNNING ) ; J Panel controls = new J Panel ( ) ; Grid Bag Layout gb = new Grid Bag Layout ( ) ; Grid Bag Constraints constraints = new Grid Bag Constraints ( ) ; controls . set Border ( Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; controls . set Layout ( gb ) ; constraints . gridx = NUM ; constraints . gridy = NUM ; constraints . weightx = NUM ; constraints . fill = Grid Bag Constraints . HORIZONTAL ; constraints . gridwidth = NUM ; constraints . gridheight = NUM ; constraints . insets = new Insets ( NUM , NUM , NUM , NUM ) ; controls . add ( m Start But , constraints ) ; constraints . gridx = NUM ; constraints . gridy = NUM ; constraints . weightx = NUM ; constraints . gridwidth = NUM ; constraints . gridheight = NUM ; controls . add ( m Stop But , constraints ) ; set Layout ( new Border Layout ( ) ) ; add ( controls , Border Layout . NORTH ) ; add ( m Log , Border Layout . CENTER ) ; }
default < V > Throwing Bi Function < T1 , T2 , V , E > and Then ( final Throwing Function < ? super R , ? extends V , E > after ) { Objects . require Non Null ( after ) ; return null ; }
private List < Symbol Type Config > read Value List Config ( Class < ? > localisation Class , Class < ? > panel Id , XML Field Config Enum Value List value List ) { List < Symbol Type Config > config List = new Array List < Symbol Type Config > ( ) ; for ( XML Field Config Enum Value value Obj : value List . get Value ( ) ) { Symbol Type Config config = parse Symbol Type Config ( localisation Class , panel Id , value Obj ) ; config List . add ( config ) ; } return config List ; }
private static void parse Attribute Or Text Content ( String string Value , Field field , Type value Type , List < Type > context , Object destination , Generic Xml generic Xml , Map < String , Object > destination Map , String name ) { if ( field != null || generic Xml != null || destination Map != null ) { value Type = field == null ? value Type : field . get Generic Type ( ) ; Object value = parse Value ( value Type , context , string Value ) ; set Value ( value , field , destination , generic Xml , destination Map , name ) ; } }
void delete Tokens ( int start Index , int end Index ) throws Exception { Array List updated Raw Tokens = new Array List ( ) ; updated Raw Tokens . add All ( get Raw Tokens ( ) ) ; Iterator it = updated Raw Tokens . iterator ( ) ; boolean delete = BOOL ; int delete Count = NUM ; Token last Token = null ; while ( it . has Next ( ) ) { Token next Token = ( Token ) it . next ( ) ; if ( ! delete ) { if ( next Token . get Token Index ( ) == start Index ) { if ( last Token != null && last Token instanceof White Space Token ) { last Token . mark Deleted ( ) ; } next Token . mark Deleted ( ) ; delete Count ++ ; if ( start Index != end Index ) { delete = BOOL ; } } } else { delete Count ++ ; next Token . mark Deleted ( ) ; if ( next Token . get Token Index ( ) == end Index ) { delete = BOOL ; break ; } } last Token = next Token ; } if ( delete == BOOL ) { throw new Exception ( STRING + end Index ) ; } if ( start Index != end Index && delete Count < NUM ) { throw new Exception ( STRING + start Index + STRING + end Index ) ; } if ( start Index == end Index && delete Count != NUM ) { throw new Exception ( STRING + start Index + STRING + delete Count ) ; } set Raw Tokens ( updated Raw Tokens ) ; }
public static boolean equals ( final Object [ ] a , final Object [ ] b ) { if ( a == b ) { return BOOL ; } else if ( a . length != b . length ) { return BOOL ; } for ( int i = NUM ; i < a . length ; i ++ ) { final Object x = a [ i ] ; final Object y = b [ i ] ; if ( x == null ) { if ( y != null ) { return BOOL ; } } else { if ( ! x . equals ( y ) ) { return BOOL ; } } } return BOOL ; }
public static void unzip ( Input Stream in , Path dest Dir ) throws IO Exception { in = new Buffered Input Stream ( in ) ; try ( Zip Input Stream zip Input = new Zip Input Stream ( in ) ) { Zip Entry entry ; byte [ ] buffer = new byte [ NUM ] ; while ( ( entry = zip Input . get Next Entry ( ) ) != null ) { Path target File = dest Dir . resolve ( entry . get Name ( ) ) ; Files . create Directories ( target File . get Parent ( ) ) ; if ( ! entry . is Directory ( ) ) { Output Stream out = Files . new Output Stream ( target File ) ; int len ; while ( ( len = zip Input . read ( buffer ) ) >= NUM ) { out . write ( buffer , NUM , len ) ; } out . close ( ) ; } zip Input . close Entry ( ) ; } } }
public Building Target ( Coords coords , I Board board , int n Type ) { init ( coords , board , n Type ) ; }
@ Rpc Method public void detach Disks ( String vm Id , List < String > disk Ids , Async Method Callback < Host . Async Client . detach disks call > handler ) throws Rpc Exception { ensure Client ( ) ; Vm Disks Detach Request vm Disks Detach Request = new Vm Disks Detach Request ( vm Id , disk Ids ) ; client Proxy . set Timeout ( DETACH DISKS TIMEOUT MS ) ; logger . info ( STRING , vm Id , disk Ids , get Host Ip ( ) , vm Disks Detach Request ) ; try { client Proxy . detach disks ( vm Disks Detach Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public void reply ( Z21 Reply msg ) { if ( msg . is X Press Net Tunnel Message ( ) ) { X Net Reply reply = msg . get X Net Reply ( ) ; log . debug ( STRING , msg , reply ) ; for ( int i = NUM ; i < reply . get Num Data Elements ( ) ; i ++ ) { try { outpipe . write Byte ( reply . get Element ( i ) ) ; } catch ( java . io . IO Exception ioe ) { log . error ( STRING ) ; } } } }
public void show List ( List < Item Chooser Row > list ) { m Progress Bar . set Visibility ( View . GONE ) ; m Status . set Text ( m Labels . m Status ) ; if ( list . is Empty ( ) ) { boolean show Empty Message = m Item Adapter . is Empty ( ) ; m Not Found Message . set Visibility ( show Empty Message ? View . VISIBLE : View . GONE ) ; m List View . set Visibility ( show Empty Message ? View . GONE : View . VISIBLE ) ; } else { m List View . set Visibility ( View . VISIBLE ) ; m Item Adapter . add All ( list ) ; } }
private void persist All Systems And Providers ( final List < Storage System > systems To Persist , final List < Storage Provider > provider To Persist ) { try { db Client . persist Object ( systems To Persist ) ; db Client . persist Object ( provider To Persist ) ; } catch ( Database Exception ex ) { logger . error ( STRING , ex ) ; } }
public void redo ( ) { if ( ! redo Stack . is Empty ( ) ) { Undoable Action redo Event = redo Stack . pop ( ) ; redo Event . redo ( ) ; undo Stack . push ( redo Event ) ; } }
public void add All ( int [ ] data ) { int data Len = data . length ; if ( data Len == NUM ) { return ; } int newcap = size + ( int ) ( data Len * NUM ) + NUM ; ensure Capacity ( newcap ) ; System . arraycopy ( data , NUM , array , size , data Len ) ; size += data Len ; }
public void store Device Throttled ( Device d ) { long interval Ns = sync Store Write Interval Ms * NUM * NUM ; if ( ! is Master ) return ; if ( d == null ) return ; long now = System . nano Time ( ) ; Long last = last Write Times . get ( d . get Device Key ( ) ) ; if ( last == null || now - last > interval Ns ) { write Updated Device To Storage ( d ) ; last Write Times . put ( d . get Device Key ( ) , now ) ; } else { cnt Device Store Throttled . update Counter With Flush ( ) ; } }
public String Builder encode Body ( String Builder buffer ) { return buffer . append ( organization ) ; }
protected void tear Down ( ) throws Exception { super . tear Down ( ) ; if ( oos != null ) { try { oos . close ( ) ; } catch ( Exception e ) { } } if ( oos ioe != null ) { try { oos ioe . close ( ) ; } catch ( Exception e ) { } } if ( f != null && f . exists ( ) ) { if ( ! f . delete ( ) ) { fail ( STRING ) ; } } }
private int detect Type ( String file Name ) throws IO Exception , FTP Illegal Reply Exception , FTP Exception { int start = file Name . last Index Of ( STRING ) + NUM ; int stop = file Name . length ( ) ; if ( start > NUM && start < stop - NUM ) { String ext = file Name . substring ( start , stop ) ; ext = ext . to Lower Case ( ) ; if ( textual Extension Recognizer . is Textual Ext ( ext ) ) { return TYPE TEXTUAL ; } else { return TYPE BINARY ; } } else { return TYPE BINARY ; } }
protected void going Inactive ( O Block block ) { if ( run Mode == MODE NONE ) { return ; } if ( ! Threading Util . is Layout Thread ( ) ) log . error ( STRING , new Exception ( STRING ) ) ; int idx = get Index Of Block ( block , idx Last Order ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + block . get Display Name ( ) + STRING + idx + STRING + idx Current Order + STRING + get Display Name ( ) ) ; } if ( idx < idx Current Order ) { release Block ( block , idx ) ; } else if ( idx == idx Current Order ) { if ( idx Current Order + NUM < orders . size ( ) ) { O Block next Block = get Block At ( idx Current Order + NUM ) ; if ( ( next Block . get State ( ) & O Block . DARK ) != NUM ) { if ( engineer != null ) { going Active ( next Block ) ; release Block ( block , idx ) ; } else { if ( run Mode == MODE LEARN ) { idx Current Order ++ ; fire Property Change ( STRING , block , next Block ) ; } else if ( run Mode == MODE RUN ) { control Run Train ( ABORT ) ; } } } else { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + block . get Display Name ( ) + STRING + get Display Name ( ) ) ; } fire Property Change ( STRING , block , null ) ; if ( engineer != null ) { engineer . set Halt ( BOOL ) ; } else { control Run Train ( ABORT ) ; } return ; } } else { abort Warrant ( STRING + get Display Name ( ) + STRING + block . get Display Name ( ) + STRING ) ; } } else if ( idx == idx Current Order + NUM ) { restart ( ) ; move Into Next Block ( END ) ; } else { block . allocate ( this ) ; } }
public void add Custom Sash Form Listener ( I Custom Sash Form Listener listener ) { if ( custom Sash Form Listeners == null ) custom Sash Form Listeners = new Array List ( ) ; custom Sash Form Listeners . add ( listener ) ; }
@ Override public void close ( ) throws IO Exception { if ( ! m Seen Eof ) { m Thread . interrupt ( ) ; try { m Thread . join ( ) ; } catch ( final Interrupted Exception e ) { throw new IO Exception ( STRING ) ; } finally { super . close ( ) ; } } check Exception ( ) ; }
public static UUID parse String As UUID ( String in ) throws Index Parse Field Exception { try { return UUID . from String ( in ) ; } catch ( Illegal Argument Exception e ) { throw new Index Parse Field Exception ( in , e ) ; } }
public void write All ( java . sql . Result Set rs , boolean include Column Names , boolean trim ) throws SQL Exception , IO Exception { if ( include Column Names ) { write Column Names ( rs ) ; } while ( rs . next ( ) ) { write Next ( result Service . get Column Values ( rs , trim ) ) ; } }
public Zone Rules Builder add Rule To Window ( int start Year , int end Year , int month , int day Of Month Indicator , int day Of Week , Local Time time , boolean time End Of Day , Time Definition time Definition , int saving Amount Secs ) { Objects . require Non Null ( time , STRING ) ; Objects . require Non Null ( time Definition , STRING ) ; if ( day Of Month Indicator < - NUM || day Of Month Indicator > NUM || day Of Month Indicator == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } if ( time End Of Day && time . equals ( Local Time . MIDNIGHT ) == BOOL ) { throw new Illegal Argument Exception ( STRING ) ; } if ( window List . is Empty ( ) ) { throw new Illegal State Exception ( STRING ) ; } TZ Window window = window List . get ( window List . size ( ) - NUM ) ; window . add Rule ( start Year , end Year , month , day Of Month Indicator , day Of Week , time , time End Of Day , time Definition , saving Amount Secs ) ; return this ; }
private String concat ( List < I Line Segment > list ) { String Builder res = new String Builder ( ) ; Node < I Line Segment > n = list . head ( ) ; while ( n != null ) { res . append ( n . value ( ) ) ; n = n . next ( ) ; if ( n != null ) { res . append ( STRING ) ; } } return res . to String ( ) ; }
public Native Font ( String plat Name , boolean bitmap Delegate ) throws Font Format Exception { super ( plat Name , null ) ; is Bitmap Delegate = bitmap Delegate ; if ( Graphics Environment . is Headless ( ) ) { throw new Font Format Exception ( STRING ) ; } font Rank = Font 2 D . NATIVE RANK ; init Names ( ) ; if ( get Num Glyphs ( ) == NUM ) { throw new Font Format Exception ( STRING + plat Name ) ; } }
public Set < State > post Event ( Event Data event Data , Long state Machine Instance Id , String correlation Id ) { State Machine state Machine = null ; if ( state Machine Instance Id != null ) { state Machine = retrieve State Machine ( state Machine Instance Id ) ; } else if ( correlation Id != null ) { state Machine = retrieve State Machine By Correlation Id ( correlation Id ) ; state Machine Instance Id = ( state Machine == null ) ? null : state Machine . get Id ( ) ; } if ( state Machine == null ) throw new Unknown State Machine ( STRING + state Machine Instance Id + STRING + correlation Id + STRING ) ; Event event = events DAO . find By SM Id And Name ( state Machine Instance Id , event Data . get Name ( ) ) ; if ( event == null ) throw new Illegal Event Exception ( STRING + state Machine Instance Id + STRING + event Data . get Name ( ) + STRING ) ; event . set Status ( Event . Event Status . triggered ) ; event . set Event Data ( event Data . get Data ( ) ) ; event . set Event Source ( event Data . get Event Source ( ) ) ; events DAO . update Event ( event ) ; Context context = new RAM Context ( System . current Time Millis ( ) , null , state Machine ) ; final Set < State > dependant States = context . get Dependant States ( event Data . get Name ( ) ) ; logger . debug ( STRING , dependant States , event Data . get Name ( ) ) ; Set < State > executable States = get Executable States ( dependant States , state Machine Instance Id ) ; logger . debug ( STRING , executable States , event Data . get Name ( ) ) ; execute States ( state Machine Instance Id , executable States ) ; return executable States ; }
protected void write Blob ( int test Id , byte [ ] test Bytes , Fb Database db , Blob Parameter Buffer blob Parameter Buffer ) throws SQL Exception { final Simple Statement Listener listener = new Simple Statement Listener ( ) ; final Fb Transaction transaction = get Transaction ( db ) ; try { final Fb Statement statement = db . create Statement ( transaction ) ; statement . add Statement Listener ( listener ) ; final Fb Blob blob = db . create Blob For Output ( transaction , blob Parameter Buffer ) ; blob . open ( ) ; int bytes Written = NUM ; while ( bytes Written < test Bytes . length ) { byte [ ] buffer = new byte [ Math . min ( blob . get Maximum Segment Size ( ) , test Bytes . length - bytes Written ) ] ; System . arraycopy ( test Bytes , bytes Written , buffer , NUM , buffer . length ) ; blob . put Segment ( buffer ) ; bytes Written += buffer . length ; } blob . close ( ) ; statement . prepare ( INSERT BLOB TABLE ) ; final Datatype Coder datatype Coder = db . get Datatype Coder ( ) ; Field Value param 1 = new Field Value ( datatype Coder . encode Int ( test Id ) ) ; Field Value param 2 = new Field Value ( datatype Coder . encode Long ( blob . get Blob Id ( ) ) ) ; statement . execute ( Row Value . of ( param 1 , param 2 ) ) ; statement . close ( ) ; } finally { transaction . commit ( ) ; } }
public static double sqrt Quick ( final double value ) { if ( USE JDK MATH ) { return Math . sqrt ( value ) ; } final long bits = Double . double To Raw Long Bits ( value ) ; return Double . long Bits To Double ( bits + NUM > > > NUM ) ; }
public void add Near Key ( Key Cache Object key , Grid Cache Shared Context ctx ) throws Ignite Checked Exception { if ( near Keys == null ) near Keys = new Array List < > ( ) ; near Keys . add ( key ) ; }
public static void do With Fields ( Class < ? > clazz , Field Callback fc , Field Filter ff ) { Class < ? > target Class = clazz ; do { Field [ ] fields = target Class . get Declared Fields ( ) ; for ( Field field : fields ) { if ( ff != null && ! ff . matches ( field ) ) { continue ; } try { fc . do With ( field ) ; } catch ( Illegal Access Exception ex ) { throw new Illegal State Exception ( STRING + field . get Name ( ) + STRING + ex ) ; } } target Class = target Class . get Superclass ( ) ; } while ( target Class != null && target Class != Object . class ) ; }
public static void show Reil Graph ( final C Graph Window parent , final I View Container view Container , final I Navi Module module , final I Navi View view ) { final Reil Creation Thread thread = new Reil Creation Thread ( module , view ) ; C Progress Dialog . show Endless ( parent , STRING + STRING , thread ) ; final Exception exception = thread . get Exception ( ) ; if ( exception != null ) { if ( exception instanceof Couldnt Save Data Exception ) { C Utility Functions . log Exception ( exception ) ; } else { C Utility Functions . log Exception ( exception ) ; final String inner Message = STRING ; final String inner Description = C Utility Functions . create Description ( String . format ( STRING , view . get Name ( ) ) , new String [ ] { STRING } , new String [ ] { STRING + STRING } ) ; Navi Error Dialog . show ( parent , inner Message , inner Description ) ; } return ; } C View Opener . show View ( parent , view Container , thread . get Reil View ( ) , parent ) ; }
public static void rename ( String from , String to ) { Process p = null ; Thread std = null ; try { Runtime run Time = Runtime . get Runtime ( ) ; log . debug ( STRING ) ; if ( File . separator Char == STRING ) { p = run Time . exec ( STRING + from + STRING + to + STRING ) ; } else { p = run Time . exec ( STRING + from + STRING + to ) ; } std = std Out ( p ) ; while ( std . is Alive ( ) ) { try { Thread . sleep ( NUM ) ; } catch ( Exception e ) { } } log . debug ( STRING ) ; } catch ( Exception e ) { log . error ( STRING , e ) ; } finally { if ( null != p ) { log . debug ( STRING ) ; p . destroy ( ) ; p = null ; std = null ; } } }
public static String find Edit Table ( String tables ) { if ( ! Text Utils . is Empty ( tables ) ) { int spacepos = tables . index Of ( STRING ) ; int commapos = tables . index Of ( STRING ) ; if ( spacepos > NUM && ( spacepos < commapos || commapos < NUM ) ) { return tables . substring ( NUM , spacepos ) ; } else if ( commapos > NUM && ( commapos < spacepos || spacepos < NUM ) ) { return tables . substring ( NUM , commapos ) ; } return tables ; } else { throw new Illegal State Exception ( STRING ) ; } }
public void write Operations Engine File ( ) { make Backup File ( default Operations Filename ( ) ) ; try { if ( ! check File ( default Operations Filename ( ) ) ) { java . io . File file = new java . io . File ( default Operations Filename ( ) ) ; java . io . File parent Dir = file . get Parent File ( ) ; if ( ! parent Dir . exists ( ) ) { if ( ! parent Dir . mkdir ( ) ) { log . error ( STRING ) ; } } if ( file . create New File ( ) ) { log . debug ( STRING ) ; } } write File ( default Operations Filename ( ) ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; } }
public Follower Info ( Follower . Type type , String stream , List < Follower > followers , int total ) { this . type = type ; this . followers = followers ; this . total = total ; this . time = System . current Time Millis ( ) ; this . stream = stream ; this . request Error = BOOL ; this . request Error Description = null ; }
public Location great Circle Location ( double azimuth Degrees , double distance Radians , Location result ) { if ( result == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } if ( distance Radians == NUM ) { result . latitude = this . latitude ; result . longitude = this . longitude ; return result ; } double lat Radians = Math . to Radians ( this . latitude ) ; double lon Radians = Math . to Radians ( this . longitude ) ; double azimuth Radians = Math . to Radians ( azimuth Degrees ) ; double cos Lat = Math . cos ( lat Radians ) ; double sin Lat = Math . sin ( lat Radians ) ; double cos Azimuth = Math . cos ( azimuth Radians ) ; double sin Azimuth = Math . sin ( azimuth Radians ) ; double sin Distance = Math . sin ( distance Radians ) ; double cos Distance = Math . cos ( distance Radians ) ; double end Lat Radians = Math . asin ( sin Lat * cos Distance + cos Lat * sin Distance * cos Azimuth ) ; double end Lon Radians = lon Radians + Math . atan 2 ( sin Distance * sin Azimuth , cos Lat * cos Distance - sin Lat * sin Distance * cos Azimuth ) ; if ( Double . is Na N ( end Lat Radians ) || Double . is Na N ( end Lon Radians ) ) { result . latitude = this . latitude ; result . longitude = this . longitude ; } else { result . latitude = normalize Latitude ( Math . to Degrees ( end Lat Radians ) ) ; result . longitude = normalize Longitude ( Math . to Degrees ( end Lon Radians ) ) ; } return result ; }
protected final void fire Vetoable Change ( Property Change Event evt ) throws Property Veto Exception { vcs . fire Vetoable Change ( evt ) ; }
public static void sort Methods ( Method Binding [ ] sorted Methods , int left , int right ) { Arrays . sort ( sorted Methods , left , right , METHOD COMPARATOR ) ; }
private void draw Background ( final Graphics g ) { g . set Color ( m bg Color Offset ) ; g . fill Rect ( - m first Column * m char Width , NUM , m offset View Width , get Height ( ) ) ; g . set Color ( m bg Color Hex ) ; g . fill Rect ( ( - m first Column * m char Width ) + m offset View Width , NUM , m hex View Width , get Height ( ) ) ; g . set Color ( m bg Color Ascii ) ; g . fill Rect ( ( - m first Column * m char Width ) + m hex View Width + m offset View Width , NUM , ( ( m first Column * m char Width ) + get Width ( ) ) - ( m hex View Width + m offset View Width ) - m scrollbar . get Width ( ) , get Height ( ) - m horizontal Scrollbar . get Height ( ) ) ; g . set Color ( Color . BLACK ) ; g . draw Line ( ( - m first Column * m char Width ) + m offset View Width , NUM , ( - m first Column * m char Width ) + m offset View Width , get Height ( ) ) ; g . draw Line ( ( - m first Column * m char Width ) + m offset View Width + m hex View Width , NUM , ( - m first Column * m char Width ) + m offset View Width + m hex View Width , get Height ( ) ) ; }
public void add Included Attributes ( final String element Name , final List attr Names ) { List attr Names List = null ; if ( ( attr Names List = ( List ) included Element Attrs Map . get ( element Name ) ) == null ) { attr Names List = new Array List ( ) ; } attr Names List . add All ( attr Names ) ; included Element Attrs Map . put ( element Name , attr Names List ) ; }
private static Get Vm Network Response check Get Vm Network Response ( Get Vm Network Response get Vm Network Response ) throws Rpc Exception { logger . info ( STRING , get Vm Network Response ) ; switch ( get Vm Network Response . get Result ( ) ) { case OK : break ; case SYSTEM ERROR : throw new System Error Exception ( get Vm Network Response . get Error ( ) ) ; case VM NOT FOUND : throw new Vm Not Found Exception ( get Vm Network Response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STRING , get Vm Network Response . get Result ( ) ) ) ; } return get Vm Network Response ; }
default Literal to Literal ( final Object value ) { final Value Factory vf = Defaults . VF ; if ( value instanceof Float ) { return vf . create Literal ( ( Float ) value ) ; } else if ( value instanceof Double ) { return vf . create Literal ( ( Double ) value ) ; } else if ( value instanceof Integer ) { return vf . create Literal ( ( Integer ) value ) ; } else if ( value instanceof Long ) { return vf . create Literal ( ( Long ) value ) ; } else if ( value instanceof Boolean ) { return vf . create Literal ( ( Boolean ) value ) ; } else if ( value instanceof Short ) { return vf . create Literal ( ( Short ) value ) ; } else if ( value instanceof Byte ) { return vf . create Literal ( ( Byte ) value ) ; } else if ( value instanceof String ) { return vf . create Literal ( ( String ) value ) ; } else { throw new Illegal Argument Exception ( String . format ( STRING , value ) ) ; } }
public Authorization Code ( Json Value token ) throws Invalid Grant Exception { super ( token ) ; if ( ! OAUTH CODE TYPE . equals ( get Token Name ( ) ) ) { throw new Invalid Grant Exception ( STRING + get Token Id ( ) ) ; } }
private int parse Style In Workspace ( Geo Server REST Reader reader , Map < String , List < Style Wrapper > > style Map , int count , String workspace Name ) { List < Style Wrapper > style List ; if ( workspace Name != null ) { REST Style List geo Server Workspace Style List = reader . get Styles ( workspace Name ) ; style List = new Array List < Style Wrapper > ( ) ; for ( String style : geo Server Workspace Style List . get Names ( ) ) { Style Wrapper new Style Wrapper = new Style Wrapper ( workspace Name , style ) ; style List . add ( new Style Wrapper ) ; if ( parent Obj != null ) { parent Obj . read Styles Progress ( connection , count , count ) ; } count ++ ; } style Map . put ( workspace Name , style List ) ; } return count ; }
public static String extract Host Id ( String host Id ) { Assert Util . assert Not Null ( host Id , STRING ) ; int idx = host Id . index Of ( HOST ID TENANT SEPARATOR ) ; String id = host Id ; if ( idx != - NUM ) { id = host Id . substring ( idx + HOST ID TENANT SEPARATOR . length ( ) ) ; } return id ; }
public static < T > Future W < T > of Error ( final Throwable error ) { final Completable Future < T > cf = new Completable Future < > ( ) ; cf . complete Exceptionally ( error ) ; return Future W . < T > of ( cf ) ; }
private void update Action Status ( final Message message ) { final Action Update Status action Update Status = convert Message ( message , Action Update Status . class ) ; final Action action = check Action Exist ( message , action Update Status ) ; final Action Status action Status = create Action Status ( message , action Update Status , action ) ; update Last Poll Time ( action . get Target ( ) ) ; switch ( action Update Status . get Action Status ( ) ) { case DOWNLOAD : action Status . set Status ( Status . DOWNLOAD ) ; break ; case RETRIEVED : action Status . set Status ( Status . RETRIEVED ) ; break ; case RUNNING : action Status . set Status ( Status . RUNNING ) ; break ; case CANCELED : action Status . set Status ( Status . CANCELED ) ; break ; case FINISHED : action Status . set Status ( Status . FINISHED ) ; break ; case ERROR : action Status . set Status ( Status . ERROR ) ; break ; case WARNING : action Status . set Status ( Status . WARNING ) ; break ; case CANCEL REJECTED : handle Cancel Rejected ( message , action , action Status ) ; break ; default : log And Throw Message Error ( message , STRING ) ; } final Action add Update Action Status = get Update Action Status ( action Status ) ; if ( ! add Update Action Status . is Active ( ) ) { look If Update Available ( action . get Target ( ) ) ; } }
protected Object convert Builtin Sound ( Input Stream i ) throws IO Exception { Byte Array Output Stream b = new Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ NUM ] ; int size = i . read ( buffer ) ; while ( size > - NUM ) { b . write ( buffer , NUM , size ) ; size = i . read ( buffer ) ; } b . close ( ) ; i . close ( ) ; return b . to Byte Array ( ) ; }
public void toggle Pause ( ) { mplayer . toggle Pause ( ) ; notify State ( get State ( ) ) ; }
public static String to UTF 8 ( String s Str ) { byte [ ] ba Bytes = s Str . get Bytes ( ) ; try { return new String ( ba Bytes , STRING ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return new String ( ba Bytes ) ; } }
public void test Encoding Decoding Fullness ( ) { for ( Grid Client Cache Flag f : Grid Client Cache Flag . values ( ) ) { if ( f == KEEP BINARIES ) continue ; int bits = Grid Client Connection . encode Cache Flags ( Collections . singleton ( f ) ) ; assert True ( bits != NUM ) ; boolean out = Grid Cache Command Handler . parse Cache Flags ( bits ) ; assert Equals ( out , BOOL ) ; } }
private void create Data Links ( CWL Workflow workflow ) throws CWL Exception { for ( CWL Output Port port : workflow . get Outputs ( ) ) { port . set Id ( Draft 2 To CWL Converter . convert Port ID ( port . get Id ( ) ) ) ; List < String > sources = transform Source ( port . get Source ( ) ) ; for ( int position = NUM ; position < sources . size ( ) ; position ++ ) { String destination = port . get Id ( ) ; Link Merge link Merge = port . get Link Merge ( ) != null ? Link Merge . value Of ( port . get Link Merge ( ) ) : Link Merge . merge nested ; String source = sources . get ( position ) ; source = Draft 2 To CWL Converter . convert Source ( source ) ; source = CWL Schema Helper . normalize Id ( source ) ; CWL Data Link data Link = new CWL Data Link ( source , destination , link Merge , position + NUM ) ; workflow . add Data Link ( data Link ) ; } } for ( CWL Step step : workflow . get Steps ( ) ) { step . set Id ( Draft 2 To CWL Converter . convert Step ID ( step . get Id ( ) ) ) ; List < CWL Data Link > data Links = new Array List < > ( ) ; for ( Map < String , Object > input : step . get Inputs ( ) ) { List < String > sources = transform Source ( CWL Binding Helper . get Source ( input ) ) ; for ( int position = NUM ; position < sources . size ( ) ; position ++ ) { String destination = CWL Binding Helper . get Id ( input ) ; destination = Draft 2 To CWL Converter . convert Destination Id ( destination ) ; destination = step . get Id ( ) + SLASH SEPARATOR + destination ; Link Merge link Merge = CWL Binding Helper . get Link Merge ( input ) != null ? Link Merge . value Of ( CWL Binding Helper . get Link Merge ( input ) ) : Link Merge . merge nested ; String source = sources . get ( position ) ; source = Draft 2 To CWL Converter . convert Source ( source ) ; source = CWL Schema Helper . normalize Id ( source ) ; CWL Data Link data Link = new CWL Data Link ( source , destination , link Merge , position + NUM ) ; data Links . add ( data Link ) ; } } workflow . add Data Links ( data Links ) ; } }
public void add Value ( double value , double weight ) { m Weighted Sum += value * weight ; m Weighted Sum Squared += value * value * weight ; m Sum Of Weights += weight ; }
public Date parse ( String text , String format , Locale locale ) throws Parser Exception { Simple Date Format date Format = get Date Format ( format , locale ) ; try { return date Format . parse ( text . trim ( ) ) ; } catch ( Parse Exception e ) { throw new Parser Exception ( STRING + date Format . to Pattern ( ) + STRING + text , e ) ; } }
public void change Item Icon At Position ( int item Index , int new Icon ) { if ( item Index < NUM || item Index > space Items . size ( ) ) { throw Array Index Out Of Bounds Exception ( item Index ) ; } else { Space Item space Item = space Items . get ( item Index ) ; Relative Layout text And Icon Container = ( Relative Layout ) space Item List . get ( item Index ) ; Image View space Item Icon = ( Image View ) text And Icon Container . find View By Id ( R . id . space icon ) ; space Item Icon . set Image Resource ( new Icon ) ; space Item . set Item Icon ( new Icon ) ; changed Item And Icon Hash Map . put ( item Index , space Item ) ; } }
private void insert COM Marker Segment ( COM Marker Segment new Guy ) { int last COM = find Marker Segment Position ( COM Marker Segment . class , BOOL ) ; boolean has JFIF = ( find Marker Segment ( JFIF Marker Segment . class , BOOL ) != null ) ; int first Adobe = find Marker Segment Position ( Adobe Marker Segment . class , BOOL ) ; if ( last COM != - NUM ) { marker Sequence . add ( last COM + NUM , new Guy ) ; } else if ( has JFIF ) { marker Sequence . add ( NUM , new Guy ) ; } else if ( first Adobe != - NUM ) { marker Sequence . add ( first Adobe + NUM , new Guy ) ; } else { marker Sequence . add ( NUM , new Guy ) ; } }
public void organization Config Changed ( String service Name , String version , String org Name , String group Name , String service Component , int type ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + service Name + STRING + org Name + STRING + group Name + STRING + service Component + STRING + type ) ; } if ( ( type == Service Listener . REMOVED ) && ( service Component . length ( ) == NUM ) ) { remove Id Repo ( org Name ) ; } else if ( ( service Component . length ( ) != NUM ) && ! service Component . equals ( STRING ) && ! service Component . equals ( STRING ) ) { String id Repo Name = null ; String Tokenizer st = new String Tokenizer ( service Component , STRING ) ; if ( st . has More Tokens ( ) ) { id Repo Name = st . next Token ( ) ; } try { if ( type == Service Listener . ADDED ) { add Id Repo ( org Name , id Repo Name ) ; } else if ( type == Service Listener . MODIFIED ) { if ( ! Id Services Impl . is Shutdown Called ( ) ) { remove Id Repo ( org Name , id Repo Name , BOOL ) ; } else { remove Id Repo ( org Name , id Repo Name , BOOL ) ; } } else if ( type == Service Listener . REMOVED ) { remove Id Repo ( org Name , id Repo Name , BOOL ) ; } } catch ( Exception e ) { debug . error ( STRING + STRING + service Name + STRING + org Name + STRING + group Name + STRING + service Component + STRING + type , e ) ; } } }
public static void launch Sms Intent ( final Activity activity , String number , String text ) { Log . i ( LOG TAG , STRING + number ) ; Uri sms Uri = Uri . parse ( STRING + number ) ; Intent sms Intent = new Intent ( Intent . ACTION SENDTO , sms Uri ) ; sms Intent . put Extra ( STRING , text ) ; Package Manager smspackage Manager = activity . get Package Manager ( ) ; List < Resolve Info > smsresolve Infos = smspackage Manager . query Intent Activities ( sms Intent , NUM ) ; if ( smsresolve Infos . size ( ) > NUM ) { activity . start Activity ( sms Intent ) ; } }
public int [ ] intersect ( int [ ] nums 1 , int [ ] nums 2 ) { Map < Integer , Integer > count = new Hash Map < > ( ) ; for ( int n : nums 1 ) { count . put ( n , count . contains Key ( n ) ? count . get ( n ) + NUM : NUM ) ; } List < Integer > intersections = new Array List < > ( Math . min ( nums 1 . length , nums 2 . length ) ) ; for ( int n : nums 2 ) { if ( count . contains Key ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - NUM ) ; if ( count . get ( n ) == NUM ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = NUM ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
static void write UTF ( Output Stream out , String str ) throws IO Exception { for ( int i = NUM , len = str . length ( ) ; i < len ; i ++ ) { int c = str . char At ( i ) ; if ( ( c >= NUM ) && ( c <= NUM ) ) { out . write ( c ) ; } else { if ( c > NUM ) { out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; } else { out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; out . write ( NUM | ( ( c > > NUM ) & NUM ) ) ; } } } }
public static void main ( String [ ] args ) { java . net . URL input 100 = Class Loader . get System Resource ( filename data 100 + STRING ) ; java . net . URL input 200 = Class Loader . get System Resource ( filename data 200 + STRING ) ; log . info ( STRING ) ; sg 100 = Spatial Grid . read From File ( input 100 . get File ( ) ) ; sg 200 = Spatial Grid . read From File ( input 200 . get File ( ) ) ; try { out = new File Writer ( output File ) ; out . write ( STRING ) ; out . write ( STRING ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING + filename data 200 + STRING ) ; test One Method ( Interpolation . BILINEAR , Double . Na N ) ; test One Method ( Interpolation . BICUBIC , Double . Na N ) ; for ( int e = NUM ; e <= NUM ; e ++ ) { test One Method ( Interpolation . INVERSE DISTANCE WEIGHTING , e ) ; } try { out . write ( STRING ) ; out . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING ) ; }
public void add Footer View ( View v , Object data , boolean is Selectable ) { Fixed View Info info = new Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Footer View Infos . add ( info ) ; if ( m Data Set Observer != null ) { m Data Set Observer . on Changed ( ) ; } }
public void store ( String filename To Save , String comments ) throws File Not Found Exception , File Already Exists Exception { if ( String Utils . is Empty ( filename To Save ) ) { throw new File Not Found Exception ( ) ; } if ( filename To Save . equals ( filename ) ) { throw new File Already Exists Exception ( filename To Save ) ; } File Writer file Writer = null ; Buffered Writer buffered Writer = null ; try { file Writer = new File Writer ( filename To Save , BOOL ) ; buffered Writer = new Buffered Writer ( file Writer ) ; prop . store ( buffered Writer , comments ) ; } catch ( IO Exception e ) { logger . error ( STRING , e ) ; } finally { IO Utils . close Quite ( file Writer ) ; IO Utils . close Quite ( buffered Writer ) ; } }
public static boolean can Player Afford Trading Fee ( Player player , int price ) { Big Decimal fee = calculate Fee ( player , price ) ; List < Item > all Equipped = player . get All Equipped ( STRING ) ; int owned Money = NUM ; for ( Item item : all Equipped ) { Money m = ( Money ) item ; owned Money += m . get Quantity ( ) ; } return fee . int Value ( ) <= owned Money ; }
private static void load Trace Events ( final C Connection connection , final Trace List trace List , final List < ? extends I Navi Module > modules ) throws SQL Exception { final List < List < Trace Register > > values = load Trace Event Values ( connection , trace List ) ; final String query = STRING + C Table Names . TRACE EVENT TABLE + STRING + trace List . get Id ( ) + STRING ; final Result Set result Set = connection . execute Query ( query , BOOL ) ; int counter = NUM ; try { while ( result Set . next ( ) ) { final long tid = result Set . get Long ( STRING ) ; final int module Id = result Set . get Int ( STRING ) ; final I Navi Module module = result Set . was Null ( ) ? null : find Module ( modules , module Id ) ; final Breakpoint Address address = new Breakpoint Address ( module , new Unrelocated Address ( Postgre SQL Helpers . load Address ( result Set , STRING ) ) ) ; final int event = result Set . get Int ( STRING ) ; trace List . add Event ( new Trace Event ( tid , address , Trace Event Type . parse Int ( event ) , values . is Empty ( ) ? new Array List < Trace Register > ( ) : values . get ( counter ) ) ) ; counter ++ ; } } finally { result Set . close ( ) ; } }
protected void execute Tasks ( final Access Path Task [ ] tasks ) throws Exception { if ( executor == null ) { for ( Access Path Task task : tasks ) { task . call ( ) ; } return ; } final List < Future Task < Void > > future Tasks = new Linked List < Future Task < Void > > ( ) ; for ( Access Path Task task : tasks ) { final Future Task < Void > ft = new Future Task < Void > ( task ) ; future Tasks . add ( ft ) ; } try { for ( Future Task < Void > ft : future Tasks ) { if ( halt ) throw new Runtime Exception ( first Cause . get ( ) ) ; executor . execute ( ft ) ; } for ( Future Task < Void > ft : future Tasks ) { if ( ! halt ) ft . get ( ) ; } } finally { for ( Future Task < Void > ft : future Tasks ) { ft . cancel ( BOOL ) ; } } }
@ Suppress Warnings ( STRING ) private static void load Extensions ( final Class Loader class Loader ) { for ( final Map . Entry < Class , Set < Class > > entry : definition Map . entry Set ( ) ) { final Service Loader < ? > service Loader = Service Loader . load ( entry . get Key ( ) , class Loader ) ; for ( final Object o : service Loader ) { register Service Class ( o . get Class ( ) , extension Classloader Lookup , class Loader , entry . get Value ( ) ) ; } } }
public static Set < String > check Inheritance Dependencies ( List < String > target Swcs , Set < String > source Swcs , Compiler Swc Context swc Context ) { if ( source Swcs . is Empty ( ) ) { return Collections . empty Set ( ) ; } Set < String > inheritance Dependencies = new Hash Set < String > ( NUM * source Swcs . size ( ) ) ; Set < String > inheritance Dependency Type = new Hash Set < String > ( ) ; inheritance Dependency Type . add ( Swc Dependency Set . INHERITANCE ) ; for ( String source Swc : source Swcs ) { Swc swc = swc Context . get Swc ( source Swc ) ; inheritance Dependencies . add All ( get Swc Dependencies ( swc , inheritance Dependency Type ) ) ; } if ( inheritance Dependencies . is Empty ( ) ) return Collections . empty Set ( ) ; Set < String > found Swcs = new Hash Set < String > ( ) ; for ( List Iterator < String > iter = target Swcs . list Iterator ( target Swcs . size ( ) ) ; iter . has Previous ( ) ; ) { String target Swc = iter . previous ( ) ; Set < String > script Name Set = get Swc Scripts ( swc Context . get Swc ( target Swc ) ) ; for ( String dependency : inheritance Dependencies ) { if ( script Name Set . contains ( dependency ) ) { found Swcs . add ( target Swc ) ; if ( iter . has Previous ( ) ) { inheritance Dependencies . add All ( get Swc Dependencies ( swc Context . get Swc ( target Swc ) , inheritance Dependency Type ) ) ; } break ; } } } return found Swcs ; }
public void test Find Spring Attributes Open Ldap ( ) { Ldap Proxy proxy = get Ldap Open Ldap ( ) ; List result = null ; try { result = proxy . find ( get Ldap Search VO ( STRING , Ldap Constants . NO SEARCH LIMIT , null , null , new String [ ] { STRING } , Ldap Scope Constants . SCOPE SUBTREE ) ) ; } catch ( Exception e ) { } assert Not Null ( result ) ; assert Equals ( NUM , result . size ( ) ) ; }
public Map read ( SSO Token token , String dn ) throws SMS Exception , SSO Exception { if ( dn == null || dn . length ( ) == NUM ) { debug . error ( STRING + dn ) ; throw new SMS Exception ( STRING , STRING ) ; } if ( ! LDAP Utils . is DN ( dn ) ) { debug . warning ( STRING + dn ) ; String [ ] args = { dn } ; throw new SMS Exception ( IUMS Constants . UMS BUNDLE NAME , STRING , args ) ; } if ( SMS Notification Manager . is Cache Enabled ( ) && entries Not Present . contains ( dn ) ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + dn + STRING ) ; } return ( null ) ; } Search Request request = Requests . new Search Request ( DN . value Of ( dn ) , Search Scope . BASE OBJECT , Search Filter . object Class Present ( ) , sms Attributes . to Array ( new String [ sms Attributes . size ( ) ] ) ) ; Internal Search Operation iso = ic Conn . process Search ( request ) ; Result Code result Code = iso . get Result Code ( ) ; if ( result Code == Result Code . SUCCESS ) { Linked List search Result = iso . get Search Entries ( ) ; if ( ! search Result . is Empty ( ) ) { Search Result Entry entry = ( Search Result Entry ) search Result . get ( NUM ) ; List attributes = entry . get Attributes ( ) ; return Embedded Search Result Iterator . convert LDAP Attribute Set To Map ( attributes ) ; } else { return null ; } } else if ( result Code == Result Code . NO SUCH OBJECT ) { object Changed ( dn , DELETE ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + dn ) ; } return null ; } else { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING + dn + STRING + result Code ) ; } throw new SMS Exception ( STRING , STRING ) ; } }
private static < T extends Abstract Block Base < T > > void compute Code Emitting Order ( List < T > order , Priority Queue < T > worklist , Bit Set visited Blocks ) { while ( ! worklist . is Empty ( ) ) { T next Important Path = worklist . poll ( ) ; add Path To Code Emitting Order ( next Important Path , order , worklist , visited Blocks ) ; } }
public void add Role ( Role Entity role ) { roles . add ( role ) ; }
private J Panel build Row ( final String string , final J Check Box check Box ) { final J Panel panel = new J Panel ( new Border Layout ( ) ) ; panel . add ( new J Label ( string ) , Border Layout . WEST ) ; panel . add ( check Box , Border Layout . EAST ) ; check Box . add Item Listener ( m check Box Listener ) ; return panel ; }
public Q Date ( Time Zone zone ) { time Zone = zone ; if ( zone == gmt Time Zone ) { std Name = gmt Std Name ; dst Name = gmt Dst Name ; } else if ( zone == local Time Zone ) { std Name = local Std Name ; dst Name = local Dst Name ; } else { std Name = time Zone . get Display Name ( BOOL , Time Zone . SHORT ) ; dst Name = time Zone . get Display Name ( BOOL , Time Zone . SHORT ) ; } calendar = new Gregorian Calendar ( time Zone ) ; set Local Time ( Current Time . current Time ( ) ) ; }
public static boolean check Url ( String url As String ) { if ( url As String == null ) { logger . error ( STRING ) ; return BOOL ; } URL url ; try { url = new URL ( url As String ) ; } catch ( Malformed URL Exception e ) { logger . error ( url As String + STRING ) ; return BOOL ; } int response Code ; String response Message = STRING ; Object content = STRING ; Http URL Connection huc ; try { huc = ( Http URL Connection ) url . open Connection ( ) ; huc . set Request Method ( STRING ) ; response Code = huc . get Response Code ( ) ; content = huc . get Content ( ) ; response Message = huc . get Response Message ( ) ; } catch ( Protocol Exception e ) { logger . error ( STRING + e . get Message ( ) , e ) ; return BOOL ; } catch ( IO Exception e ) { logger . error ( STRING + e . get Message ( ) , e ) ; return BOOL ; } if ( response Code == NUM || ( response Code > NUM && response Code < NUM ) ) { logger . info ( STRING + url As String + STRING ) ; return BOOL ; } else { logger . error ( url As String + STRING + response Code + STRING + content + STRING + response Message ) ; return BOOL ; } }
protected void finalize ( List < Snapshot Files > snapshots , int file List Generation , Map < String , Blob Meta Data > blobs ) { Blob Store Index Shard Snapshots new Snapshots = new Blob Store Index Shard Snapshots ( snapshots ) ; List < String > blobs To Delete = new Array List < > ( ) ; for ( String blob Name : blobs . key Set ( ) ) { if ( index Shard Snapshots Format . is Temp Blob Name ( blob Name ) || blob Name . starts With ( SNAPSHOT INDEX PREFIX ) ) { blobs To Delete . add ( blob Name ) ; } } try { blob Container . delete Blobs ( blobs To Delete ) ; } catch ( IO Exception e ) { throw new Index Shard Snapshot Failed Exception ( shard Id , STRING + e . get Message ( ) , e ) ; } blobs To Delete = new Array List < > ( ) ; for ( String blob Name : blobs . key Set ( ) ) { if ( blob Name . starts With ( DATA BLOB PREFIX ) ) { if ( new Snapshots . find Name File ( File Info . canonical Name ( blob Name ) ) == null ) { blobs To Delete . add ( blob Name ) ; } } } try { blob Container . delete Blobs ( blobs To Delete ) ; } catch ( IO Exception e ) { logger . debug ( STRING , e , snapshot Id , shard Id , blobs To Delete ) ; } if ( snapshots . size ( ) > NUM ) { try { index Shard Snapshots Format . write Atomic ( new Snapshots , blob Container , Integer . to String ( file List Generation ) ) ; } catch ( IO Exception e ) { throw new Index Shard Snapshot Failed Exception ( shard Id , STRING , e ) ; } } }
public void read From ( Channel Buffer data ) { this . wildcards = data . read Int ( ) ; this . input Port = data . read Short ( ) ; this . data Layer Source = new byte [ NUM ] ; data . read Bytes ( this . data Layer Source ) ; this . data Layer Destination = new byte [ NUM ] ; data . read Bytes ( this . data Layer Destination ) ; this . data Layer Virtual Lan = data . read Short ( ) ; this . data Layer Virtual Lan Priority Code Point = data . read Byte ( ) ; data . read Byte ( ) ; this . data Layer Type = data . read Short ( ) ; this . network Type Of Service = data . read Byte ( ) ; this . network Protocol = data . read Byte ( ) ; data . read Byte ( ) ; data . read Byte ( ) ; this . network Source = data . read Int ( ) ; this . network Destination = data . read Int ( ) ; this . transport Source = data . read Short ( ) ; this . transport Destination = data . read Short ( ) ; }
@ Override public boolean is Armed ( ) { boolean b = should Act Like Button ( ) || ( pressed When Popup Visible && combo Box . is Popup Visible ( ) ) ; return b ? is Pressed ( ) : super . is Armed ( ) ; }
public static Attrib Key for Attribute ( Namespaces in Scope , El Key el , String qname ) { Namespaces ns ; String local Name ; int colon = qname . index Of ( STRING ) ; if ( colon < NUM ) { ns = el . ns ; local Name = qname ; } else { ns = in Scope . for Attr Name ( el . ns , qname ) ; if ( ns == null ) { return null ; } ns = in Scope . for Uri ( ns . uri ) ; local Name = qname . substring ( colon + NUM ) ; } return new Attrib Key ( el , ns , local Name ) ; }
Sparse Array ( Class < L > linear Array Type , int [ ] linear Indices , int [ ] row Indices , int [ ] col Indices , L real , L imag , int num Rows , int num Cols ) { num Rows = num Rows ; num Cols = num Cols ; base Component Type = linear Array Type . get Component Type ( ) ; output Array Type = ( Class < L [ ] > ) Array Utils . get Array Class ( base Component Type , NUM ) ; linear Indices = linear Indices ; row Indices = row Indices ; col Indices = col Indices ; real Values = linear Array Type . cast ( real ) ; imag Values = linear Array Type . cast ( imag ) ; }
protected void update Radio Links ( ) { m Set Test But . set Enabled ( m Test Split But . is Selected ( ) ) ; if ( ( m Set Test Frame != null ) && ( ! m Test Split But . is Selected ( ) ) ) { m Set Test Frame . set Visible ( BOOL ) ; } m CV Text . set Enabled ( m CV But . is Selected ( ) ) ; m CV Lab . set Enabled ( m CV But . is Selected ( ) ) ; m Percent Text . set Enabled ( m Percent But . is Selected ( ) ) ; m Percent Lab . set Enabled ( m Percent But . is Selected ( ) ) ; }
@ Override public String run ( String [ ] args ) { if ( args . length == NUM ) { String help = STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; return help ; } try { if ( args . length > NUM ) { String cmd = args [ NUM ] ; if ( cmd == STRING ) { if ( args . length > NUM ) { int id = Integer . parse Int ( args [ NUM ] ) ; return str List Network ( id , BOOL ) ; } else { return str List Networks ( BOOL ) ; } } else if ( cmd == STRING ) { if ( args . length > NUM ) { int id 1 = Integer . parse Int ( args [ NUM ] ) ; int id 2 = Integer . parse Int ( args [ NUM ] ) ; int id 3 = Integer . parse Int ( args [ NUM ] ) ; return str Link 3 ( id 1 , id 2 , id 3 ) ; } else if ( args . length > NUM ) { int id 1 = Integer . parse Int ( args [ NUM ] ) ; int id 2 = Integer . parse Int ( args [ NUM ] ) ; return str Link 2 ( id 1 , id 2 ) ; } } else if ( cmd == STRING ) { if ( args . length > NUM ) { int id = Integer . parse Int ( args [ NUM ] ) ; return str Unlink ID ( id ) ; } else { return str Unlink All ( ) ; } } return STRING ; } } catch ( Number Format Exception nfe ) { } catch ( Null Pointer Exception npe ) { } catch ( Index Out Of Bounds Exception ioobe ) { } return STRING ; }
static void reset Cache Recreation Count ( ) { cache Recreation Count . set ( NUM ) ; }
public void test Number To String Pattern ( ) { Locale default Locale = Locale . get Default ( ) ; Locale . set Default ( Locale . US ) ; Number Converter converter = make Converter ( ) ; converter . set Pattern ( STRING ) ; assert Equals ( STRING + numbers [ NUM ] , STRING , converter . convert ( String . class , numbers [ NUM ] ) ) ; assert Equals ( STRING + numbers [ NUM ] , STRING , converter . convert ( String . class , numbers [ NUM ] ) ) ; converter . set Locale ( Locale . GERMAN ) ; assert Equals ( STRING + numbers [ NUM ] , STRING , converter . convert ( String . class , numbers [ NUM ] ) ) ; assert Equals ( STRING + numbers [ NUM ] , STRING , converter . convert ( String . class , numbers [ NUM ] ) ) ; Locale . set Default ( default Locale ) ; }
public Set < String > schema Sub Entries ( SSO Token token , String obj Name , String filter , String sid Filter , int num Of Entries , boolean sort Results , boolean ascending Order ) throws SMS Exception , SSO Exception { if ( obj Name == null || obj Name . length ( ) == NUM || filter == null || filter . length ( ) == NUM || sid Filter == null || sid Filter . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING + STRING ) ; } Set < String > subentries = null ; try { subentries = get Sub Entries ( obj Name , filter , sid Filter , num Of Entries , sort Results , ascending Order ) ; } catch ( Service Not Found Exception e ) { subentries = new Case Insensitive Hash Set < > ( ) ; } if ( m Debug . message Enabled ( ) ) { m Debug . message ( STRING + STRING + filter + STRING + obj Name + STRING + subentries . size ( ) + STRING ) ; } return ( subentries ) ; }
protected double angle Between ( Point 2 D v1 , Point 2 D v2 ) { double x1 = v1 . get X ( ) ; double y1 = v1 . get Y ( ) ; double x2 = v2 . get X ( ) ; double y2 = v2 . get Y ( ) ; double cross = x1 * y2 - x2 * y1 ; int cw = NUM ; if ( cross > NUM ) { cw = - NUM ; } double angle = cw * Math . acos ( ( x1 * x2 + y1 * y2 ) / ( Math . sqrt ( x1 * x1 + y1 * y1 ) * Math . sqrt ( x2 * x2 + y2 * y2 ) ) ) ; if ( Double . is Na N ( angle ) ) { angle = NUM ; } return angle ; }
@ Override public Object annotation Button ( final Form Object form ) { final int subtype = form . get Parameter Constant ( Pdf Dictionary . Subtype ) ; if ( subtype == Pdf Dictionary . Popup ) { return create Annotation Popup ( form ) ; } if ( ! form . is Appearance Used ( ) ) { switch ( subtype ) { case Pdf Dictionary . Text : return create Annotation Text ( form ) ; case Pdf Dictionary . Free Text : return create Annotation Free Text ( form ) ; case Pdf Dictionary . Highlight : return create Anntoation Highlight ( form ) ; case Pdf Dictionary . Underline : return create Annotation Underline ( form ) ; case Pdf Dictionary . Ink : return create Annotation Ink ( form ) ; case Pdf Dictionary . Strick Out : return create Annotation Strike Out ( form ) ; } } return setup Annotation Button ( form ) ; }
protected static List < String > is Valid Git Version ( final String git Response ) { Trace . write Line ( STRING ) ; Trace . write Line ( STRING + git Response ) ; final String Git Not Found = STRING ; final List < String > result = new Array List < String > ( ) ; if ( git Response != null ) { Version version = null ; try { version = Version . parse Version ( git Response ) ; } catch ( final Illegal Argument Exception ignored ) { Trace . write Line ( STRING + ignored . get Message ( ) ) ; result . add ( Git Not Found ) ; } if ( version != null ) { if ( version . get Major ( ) < NUM || ( version . get Major ( ) == NUM && version . get Minor ( ) < NUM ) ) { result . add ( STRING + version . get Major ( ) + STRING + version . get Minor ( ) + STRING ) ; } } } else { result . add ( Git Not Found ) ; } return result ; }
public static Vector 2 max ( Vector 2 o1 , Vector 2 o2 ) { return new Vector 2 ( Math . max ( o1 . x , o2 . x ) , Math . max ( o1 . z , o2 . z ) ) ; }
private void convert Procedure Call ( final String Builder target , final String procedure Call ) throws SQL Exception { FB Escaped Call Parser temp Parser = new FB Escaped Call Parser ( mode ) ; FB Procedure Call call = temp Parser . parse Call ( procedure Call ) ; call . check Parameters ( ) ; target . append ( call . get SQL ( BOOL ) ) ; }
private void serialize Test Summary ( K Xml Serializer serializer ) throws IO Exception { serializer . start Tag ( ns , SUMMARY TAG ) ; serializer . attribute ( ns , HAS CRASH ATTR , get Has Crash ( ) ) ; serializer . attribute ( ns , CRASH FILE ATTR , get Crash File ( ) ) ; serializer . attribute ( ns , DURATION ATTR , get Duration ( ) ) ; serializer . attribute ( Cts Xml Result Reporter . ns , RESULT ATTR , get Result ( ) ) ; serializer . end Tag ( ns , SUMMARY TAG ) ; }
private void migrate Block Mirrors ( ) { log . info ( STRING ) ; Db Client db Client = get Db Client ( ) ; List < URI > block Mirror UR Is = db Client . query By Type ( Block Mirror . class , BOOL ) ; Iterator < Block Mirror > block Mirrors = db Client . query Iterative Objects ( Block Mirror . class , block Mirror UR Is , BOOL ) ; List < Block Object > block Objects = new Array List < Block Object > ( ) ; while ( block Mirrors . has Next ( ) ) { block Objects . add ( block Mirrors . next ( ) ) ; } migrate Block Objects ( block Objects ) ; }
protected < H extends Mem Holder < ? extends Common Allocator < ? > , ? , ? > > H create ( Mem Create < H > creator , Performance Level startlevel , long size ) { H ret = null ; boolean eligible = BOOL ; for ( Performance Level lvl : m info . key Set ( ) ) { if ( ! eligible && startlevel == lvl ) { eligible = BOOL ; } if ( eligible ) { int distance = NUM ; List < Common Allocator < ? > > bmas = m info . get ( lvl ) ; for ( Common Allocator < ? > bma : bmas ) { ret = creator . create ( bma , size ) ; if ( null == ret ) { distance ++ ; } else { if ( null != m bwlvlchange && m prevbwlevel != lvl ) { m bwlvlchange . changed ( m prevbwlevel , lvl ) ; m prevbwlevel = lvl ; } if ( null != m allocator Change && m prevallocator != bma ) { m allocator Change . changed ( lvl , m prevallocator , bma ) ; m prevallocator = bma ; } break ; } } Collections . rotate ( bmas , distance ) ; } if ( null != ret ) { break ; } } return ret ; }
private Element create IDPSSO Descriptor ( boolean export Private Data ) throws Exception { Element idpsso D = doc . create Element ( SAML Names . IDPSSODESCRIPTOR ) ; idpsso D . set Attribute ( SAML Names . PSE , SAML Names . REQUIREDPROTOCAL ) ; idpsso D . set Attribute ( SAML Names . WANTSIGNED , SAML Names . FALSE ) ; if ( export Private Data ) { set Extension Attributes ( idpsso D ) ; Element ext Ele = create Extension Ele ( ) ; if ( ext Ele != null ) { idpsso D . append Child ( ext Ele ) ; } } Element key D = create Key Descriptor ( export Private Data ) ; if ( key D != null ) { idpsso D . append Child ( key D ) ; } Element slo Ele = create Single Log Out For Castle As IDP ( SAML Names . HTTP REDIRECT BINDING ) ; idpsso D . append Child ( slo Ele ) ; slo Ele = create Single Log Out For Castle As IDP ( SAML Names . SOAP BINDING ) ; idpsso D . append Child ( slo Ele ) ; create Name ID Formats ( idpsso D , BOOL ) ; String sso Location Str = convert To IPV 6 Short Form ( idm Client . get Entity ID ( tenant Name ) ) ; if ( sso Location Str == null ) { sso Location Str = tenant Name ; } sso Location Str = sso Location Str . replace All ( STRING , STRING ) ; Element ssos = create End Point ( SAML Names . SSOS , SAML Names . HTTP REDIRECT BINDING , sso Location Str , null ) ; idpsso D . append Child ( ssos ) ; create Attributes Ele ( idpsso D ) ; return idpsso D ; }
public void clear ( ) { info Queue . clear ( ) ; allocator . release ( data Queue . to Array ( new Allocation [ data Queue . size ( ) ] ) ) ; data Queue . clear ( ) ; total Bytes Dropped = NUM ; total Bytes Written = NUM ; last Allocation = null ; last Allocation Offset = allocation Length ; }
private void trace ( ) { gl Use Program ( ray Tracing Program ) ; if ( mouse Down ) { curr Rotation About Y = rotation About Y + ( mouse X - mouse Down X ) * NUM ; } else { curr Rotation About Y = rotation About Y ; } camera Position . set ( ( float ) sin ( - curr Rotation About Y ) * NUM , NUM , ( float ) cos ( - curr Rotation About Y ) * NUM ) ; view Matrix . set Look At ( camera Position , camera Look At , camera Up ) ; if ( reset Framebuffer ) { proj Matrix . set Perspective ( ( float ) Math . to Radians ( NUM ) , ( float ) width / height , NUM , NUM ) ; resize Framebuffer Texture ( ) ; reset Framebuffer = BOOL ; } proj Matrix . invert Perspective View ( view Matrix , inv View Proj Matrix ) ; update Camera Settings Ubo ( ) ; long this Time = System . nano Time ( ) ; float elapsed Seconds = ( this Time - first Time ) / NUM ; gl Uniform 1 f ( time Uniform , elapsed Seconds ) ; float blend Factor = frame Number / ( frame Number + NUM ) ; gl Uniform 1 f ( blend Factor Uniform , blend Factor ) ; gl Uniform 1 i ( bounce Count Uniform , bounce Count ) ; gl Uniform 1 f ( width Uniform , width ) ; gl Uniform 1 f ( height Uniform , height ) ; gl Bind Buffer Base ( GL UNIFORM BUFFER , this . camera Settings Ubo Binding , this . camera Settings Ubo ) ; gl Bind Framebuffer ( GL FRAMEBUFFER , fbo ) ; gl Bind Vertex Array ( vao ) ; gl Bind Texture ( GL TEXTURE 2D , tex ) ; gl Bind Sampler ( NUM , this . sampler ) ; gl Draw Arrays ( GL TRIANGLES , NUM , NUM ) ; gl Bind Sampler ( NUM , NUM ) ; gl Bind Texture ( GL TEXTURE 2D , NUM ) ; gl Bind Vertex Array ( NUM ) ; gl Bind Framebuffer ( GL FRAMEBUFFER , NUM ) ; gl Use Program ( NUM ) ; gl Bind Buffer Base ( GL UNIFORM BUFFER , this . camera Settings Ubo Binding , NUM ) ; frame Number ++ ; }
public static Result Set simple Result Set ( ) { Simple Result Set rs = new Simple Result Set ( ) ; rs . add Column ( STRING , Types . INTEGER , NUM , NUM ) ; rs . add Column ( STRING , Types . VARCHAR , NUM , NUM ) ; rs . add Row ( NUM , STRING ) ; return rs ; }
public static void reconcile Export Groups HL Us ( Db Client db Client , Export Group export Group ) { List < String > eg Volumes Without HL Us = find Volumes Without HL Us ( export Group ) ; if ( ! eg Volumes Without HL Us . is Empty ( ) ) { for ( Export Mask this Mask : Export Mask Utils . get Export Masks ( db Client , export Group ) ) { Iterator < String > volume Iter = eg Volumes Without HL Us . iterator ( ) ; while ( volume Iter . has Next ( ) ) { URI volume URI = URI . create ( volume Iter . next ( ) ) ; if ( this Mask . has Volume ( volume URI ) ) { String hlu = this Mask . return Volume HLU ( volume URI ) ; if ( hlu != Export Group . LUN UNASSIGNED DECIMAL STR ) { log . info ( String . format ( STRING , export Group . get Label ( ) , export Group . get Id ( ) , volume URI , hlu ) ) ; export Group . add Volume ( volume URI , Integer . value Of ( hlu ) ) ; volume Iter . remove ( ) ; } } } } } }
public String create Temp File ( String prefix , String suffix , File directory ) throws Illegal Argument Exception , IO Exception { if ( prefix . length ( ) < NUM ) throw new Illegal Argument Exception ( STRING ) ; if ( suffix == null ) suffix = STRING ; String folder = null ; if ( directory == null ) { folder = get Tmp Folder Path ( ) ; } else { folder = directory . get Absolute Path ( ) ; } int counter = tmp File Counter . get And Increment ( ) ; String file Name = prefix + counter + suffix ; String path = folder + File . separator + file Name ; boolean created = create File ( path ) ; if ( ! created ) { throw new IO Exception ( ) ; } return path ; }
private static boolean contains Anno Of Type ( List < Attribute . Compound > annos , Type type ) { for ( Attribute . Compound anno : annos ) { if ( anno . type . tsym == type . tsym ) return BOOL ; } return BOOL ; }
private Byte Buffer ensure Buffer ( int size , Byte Buffer buffer , Writable Byte Channel output ) throws IO Exception { if ( buffer . remaining ( ) >= size ) { return buffer ; } flush Buffer ( buffer , output ) ; if ( buffer . remaining ( ) >= size ) { return buffer ; } return Byte Buffer . allocate Direct ( Math . max ( buffer . capacity ( ) << NUM , buffer . capacity ( ) + size ) ) ; }
protected void add Text Indicator ( final String text , final Notification Type type ) { text Indicators . add ( new Text Indicator ( text , type ) ) ; fire Change ( PROP TEXT INDICATORS ) ; }
@ Override @ Nullable public Object find Template Source ( @ Not Null String name ) throws IO Exception { File file = resolve Name ( name ) ; Template Source template Source = Template Source . open ( file ) ; push Template Folder ( file . get Parent File ( ) ) ; return template Source ; }
@ Override public void mouse Exited ( Mouse Event e ) { if ( this . own Tool Tip Delays Active ) { Tool Tip Manager ttm = Tool Tip Manager . shared Instance ( ) ; ttm . set Initial Delay ( this . original Tool Tip Initial Delay ) ; ttm . set Reshow Delay ( this . original Tool Tip Reshow Delay ) ; ttm . set Dismiss Delay ( this . original Tool Tip Dismiss Delay ) ; this . own Tool Tip Delays Active = BOOL ; } }
@ Safe Varargs public static final < T > List < T > list ( T ... items ) { Array List < T > list = new Array List < T > ( items . length ) ; for ( T item : items ) { list . add ( item ) ; } return list ; }
public void save ( Output Stream os ) throws IO Exception { Data Output Stream dos = null ; try { dos = new Data Output Stream ( os ) ; dos . write Long ( FILE MAGIC NUMBER ) ; dos . write Int ( FILE VERSION ) ; save Extensions ( critical Extensions , dos ) ; save Extensions ( non Critical Extensions , dos ) ; } finally { IO Utils . close Quietly ( dos ) ; } }
public long nswap ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
private static byte [ ] generate Seed ( ) { try { Byte Array Output Stream seed Buffer = new Byte Array Output Stream ( ) ; Data Output Stream seed Buffer Out = new Data Output Stream ( seed Buffer ) ; seed Buffer Out . write Long ( System . current Time Millis ( ) ) ; seed Buffer Out . write Long ( System . nano Time ( ) ) ; seed Buffer Out . write Int ( Process . my Pid ( ) ) ; seed Buffer Out . write Int ( Process . my Uid ( ) ) ; seed Buffer Out . write ( BUILD FINGERPRINT AND DEVICE SERIAL ) ; seed Buffer Out . close ( ) ; return seed Buffer . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Security Exception ( STRING , e ) ; } }
private String render Tuple Expr ( Tuple Expr the Expr ) throws Exception { Sparql Tuple Expr Renderer a Renderer = new Sparql Tuple Expr Renderer ( ) ; a Renderer . m Indent = m Indent ; a Renderer . m Contexts = new Hash Map < Tuple Expr , Var > ( m Contexts ) ; return a Renderer . render ( the Expr ) ; }
public void start Sampling ( ) { if ( m Sampling Counter . get And Increment ( ) == NUM ) { m Handler . start Sampling Thread ( ) ; m Last Time Reading = System Clock . elapsed Realtime ( ) ; } }
public D Sign Csr ( J Frame parent , Spkac spkac Csr , File csr File , Private Key sign Private Key , Key Pair Type sign Key Pair Type , X509 Certificate verification Certificate , Provider provider ) throws Crypto Exception { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; this . spkac Csr = spkac Csr ; this . csr File = csr File ; this . sign Private Key = sign Private Key ; this . sign Key Pair Type = sign Key Pair Type ; this . verification Certificate = verification Certificate ; this . provider = provider ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }
public Host Scsi Disk find Scsi Disk ( Host System host , Cluster Compute Resource cluster , Block Object Rest Rep volume ) { if ( String Utils . is Blank ( volume . get Wwn ( ) ) ) { String volume Id = Resource Utils . string Id ( volume ) ; String volume Name = Resource Utils . name ( volume ) ; Execution Utils . fail ( STRING , new Object [ ] { volume Id } , new Object [ ] { volume Name } ) ; } Host Scsi Disk disk = execute ( new Find Host Scsi Disk For Lun ( host , volume ) ) ; if ( cluster != null ) { Host System [ ] hosts = cluster . get Hosts ( ) ; if ( hosts == null ) { throw new Illegal State Exception ( STRING + cluster . get Name ( ) + STRING ) ; } Map < Host System , Host Scsi Disk > disks = Maps . new Hash Map ( ) ; disks . put ( host , disk ) ; for ( Host System other Host : hosts ) { if ( String Utils . equals ( host . get Name ( ) , other Host . get Name ( ) ) ) { continue ; } Host Scsi Disk other Disk = execute ( new Find Host Scsi Disk For Lun ( other Host , volume ) ) ; disks . put ( other Host , other Disk ) ; } } return disk ; }
static public String format Date ( Date d ) { if ( time Formatter == null ) { try { return Long . to String ( d . get Time ( ) ) ; } catch ( Exception ignore ) { return STRING ; } } try { synchronized ( time Formatter ) { return time Formatter . format ( d ) ; } } catch ( Exception e1 ) { try { return d . to String ( ) ; } catch ( Exception e2 ) { try { return Long . to String ( d . get Time ( ) ) ; } catch ( Exception e3 ) { return STRING ; } } } }
public static String left ( String s , int width , char fill Char ) { if ( s . length ( ) >= width ) { return s ; } String Buffer sb = new String Buffer ( width ) ; sb . append ( s ) ; for ( int i = width - s . length ( ) ; -- i >= NUM ; ) { sb . append ( fill Char ) ; } return sb . to String ( ) ; }
public synchronized boolean add All ( int index , Collection < ? extends E > c ) { mod Count ++ ; if ( index < NUM || index > element Count ) throw new Array Index Out Of Bounds Exception ( index ) ; Object [ ] a = c . to Array ( ) ; int num New = a . length ; ensure Capacity Helper ( element Count + num New ) ; int num Moved = element Count - index ; if ( num Moved > NUM ) System . arraycopy ( element Data , index , element Data , index + num New , num Moved ) ; System . arraycopy ( a , NUM , element Data , index , num New ) ; element Count += num New ; return num New != NUM ; }
public void update ( CST State state ) { new Checkpoint ( state . get Serialized State ( ) , state . get State Hash ( ) , state . get Checkpoint CID ( ) ) ; set Last Checkpoint CID ( state . get Checkpoint CID ( ) ) ; }
public static List < Name Value Pair > to Name Value Pair ( Object parent , Map < String , String > map ) { List < Name Value Pair > list = new Array List < Name Value Pair > ( ) ; for ( String key : map . key Set ( ) ) { Name Value Pair nvp = new Name Value Pair ( parent , key , map . get ( key ) ) ; list . add ( nvp ) ; } return list ; }
public void remove Message Observer ( final Message Observer observer ) { if ( observer == null ) { throw new Null Pointer Exception ( ) ; } else if ( message Observers != null ) { message Observers . remove ( observer ) ; } }
public int calculate Partition ( char initial Char , int num Partitions ) { final int partition Size = ( int ) ( Math . ceil ( NUM / ( double ) num Partitions ) ) ; int initial Char = ( int ) initial Char ; if ( initial Char < STRING ) return NUM ; if ( initial Char > STRING ) return num Partitions - NUM ; return ( initial Char - NUM ) / partition Size ; }
private static void byte 2 hex ( byte b , String Buffer buf ) { char [ ] hex Chars = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; int high = ( ( b & NUM ) > > NUM ) ; int low = ( b & NUM ) ; buf . append ( hex Chars [ high ] ) ; buf . append ( hex Chars [ low ] ) ; }
public E remove ( int index ) { range Check ( index ) ; mod Count ++ ; E old Value = element Data ( index ) ; int num Moved = size - index - NUM ; if ( num Moved > NUM ) System . arraycopy ( element Data , index + NUM , element Data , index , num Moved ) ; element Data [ -- size ] = null ; return old Value ; }
public static Double Vector rchisq ( int n , double ncp , Random random ) { Double Vector v = new Double Vector ( n ) ; double mean = Math . sqrt ( ncp ) ; double x ; for ( int i = NUM ; i < n ; i ++ ) { x = random . next Gaussian ( ) + mean ; v . set ( i , x * x ) ; } return v ; }
public final Pdf Object read Reference Table ( final Pdf Object linear Obj , final Pdf File Reader current Pdf File , final Object Reader object Reader ) throws Pdf Exception { int pointer = - NUM ; final int eof = ( int ) this . eof ; boolean islinearized Compressed = BOOL ; if ( linear Obj == null ) { pointer = read First Start Ref ( ) ; } else { final byte [ ] data = pdf datafile . get Pdf Buffer ( ) ; final int count = data . length ; int ptr = NUM ; for ( int i = NUM ; i < count ; i ++ ) { if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { ptr = i + NUM ; } if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { pointer = i ; i = count ; } else if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { islinearized Compressed = BOOL ; pointer = ptr ; while ( data [ pointer ] == NUM || data [ pointer ] == NUM || data [ pointer ] == NUM ) { pointer ++ ; } i = count ; } } } offset . add Xref ( pointer ) ; Pdf Object root Obj = null ; if ( pointer >= eof || pointer == NUM ) { Log Writer . write Log ( STRING ) ; offset . set Ref Table Invalid ( BOOL ) ; try { root Obj = new Page Object ( Broken Ref Table . find Offsets ( pdf datafile , offset ) ) ; } catch ( Error err ) { throw new Pdf Exception ( err . get Message ( ) + STRING ) ; } current Pdf File . read Object ( root Obj ) ; return root Obj ; } else if ( islinearized Compressed || is Compressed Stream ( pointer , eof ) ) { return read Compressed Stream ( root Obj , pointer , current Pdf File , object Reader , linear Obj ) ; } else { return read Legacy Reference Table ( root Obj , pointer , eof , current Pdf File ) ; } }
void warning Occurred ( int code ) { cb Lock . lock ( ) ; try { if ( ( code < NUM ) || ( code > MAX WARNING ) ) { throw new Internal Error ( STRING ) ; } process Warning Occurred ( current Image , STRING , Integer . to String ( code ) ) ; } finally { cb Lock . unlock ( ) ; } }
public boolean is Known Package ( String package Name ) { return KNOWN PACKAGES . contains ( Perl Package Util . get Canonical Package Name ( package Name ) ) ; }
private void remove Download Id From Shared Prefs ( int download Id ) { Set < String > download Ids = get Stored Download Info ( DOWNLOAD NOTIFICATION IDS ) ; String id = Integer . to String ( download Id ) ; if ( download Ids . contains ( id ) ) { download Ids . remove ( id ) ; store Download Info ( DOWNLOAD NOTIFICATION IDS , download Ids ) ; } }
public void clear 2 Lead Search Light ( int bit ) { if ( node Type != SMINI ) { log . error ( STRING ) ; return ; } if ( ( bit < NUM ) || ( bit > NUM ) ) { log . error ( STRING + Integer . to String ( bit ) ) ; return ; } if ( ( loc Search Light Bits [ bit ] != NUM ) || ( loc Search Light Bits [ bit + NUM ] != NUM ) ) { log . error ( STRING + Integer . to String ( bit ) ) ; return ; } loc Search Light Bits [ bit ] = NUM ; loc Search Light Bits [ bit + NUM ] = NUM ; num 2 L Search Lights -- ; }
public void calc Major Tick ( ) { fraction = UNIT ; double u = major Tick ; double r = max Tick - min Tick ; major Tick Count = ( int ) ( r / u ) ; while ( major Tick Count < pref Major Tick Count ) { u = major Tick / NUM ; if ( ! is Discrete || u == Math . floor ( u ) ) { major Tick Count = ( int ) ( r / u ) ; fraction = HALFS ; if ( major Tick Count >= pref Major Tick Count ) break ; } u = major Tick / NUM ; if ( ! is Discrete || u == Math . floor ( u ) ) { major Tick Count = ( int ) ( r / u ) ; fraction = QUARTERS ; if ( major Tick Count >= pref Major Tick Count ) break ; } u = major Tick / NUM ; if ( ! is Discrete || u == Math . floor ( u ) ) { major Tick Count = ( int ) ( r / u ) ; fraction = FIFTHS ; if ( major Tick Count >= pref Major Tick Count ) break ; } if ( is Discrete && ( major Tick / NUM ) != Math . floor ( major Tick / NUM ) ) { u = major Tick ; major Tick Count = ( int ) ( r / u ) ; break ; } major Tick /= NUM ; u = major Tick ; major Tick Count = ( int ) ( r / u ) ; fraction = UNIT ; } major Tick = u ; if ( is Discrete && major Tick < NUM ) { major Tick = NUM ; major Tick Count = ( int ) ( r / major Tick ) ; fraction = UNIT ; } major Tick Count ++ ; while ( ( min Tick + major Tick - epsilon ) < min Data ) { min Tick += major Tick ; major Tick Count -- ; } while ( ( max Tick - major Tick + epsilon ) > max Data ) { max Tick -= major Tick ; major Tick Count -- ; } }
public Sample Attribute Table merge Samples ( Collection < String > samples , String new Name ) { Sample Attribute Table sample Attribute Table = new Sample Attribute Table ( ) ; Map < String , Object > attribute 2 value = new Hash Map < > ( ) ; for ( String attribute : get Attribute Set ( ) ) { boolean value Mismatch = BOOL ; Object previous Value = null ; for ( String sample : samples ) { Object value = table . get ( sample , attribute ) ; if ( value != null ) { if ( previous Value == null ) previous Value = value ; else if ( ! value . equals ( previous Value ) ) { value Mismatch = BOOL ; break ; } } } if ( ! value Mismatch && previous Value != null ) { attribute 2 value . put ( attribute , previous Value ) ; } } sample Attribute Table . add Sample ( new Name , attribute 2 value , BOOL , BOOL ) ; return sample Attribute Table ; }
protected boolean track Message ( Function Streaming Reply Message m ) { this . msgs Processed ++ ; if ( m . is Last Message ( ) ) { this . num Msgs = m . get Message Number ( ) + NUM ; } return this . msgs Processed == this . num Msgs ; }
public void dispose ( ) { Object [ ] in Nodes Array = in Nodes . to Array ( ) ; for ( int i = NUM ; i < in Nodes Array . length ; i ++ ) { Digraph Node node = ( Digraph Node ) in Nodes Array [ i ] ; node . remove Edge ( this ) ; } Object [ ] out Nodes Array = out Nodes . to Array ( ) ; for ( int i = NUM ; i < out Nodes Array . length ; i ++ ) { Digraph Node node = ( Digraph Node ) out Nodes Array [ i ] ; remove Edge ( node ) ; } }
private String file To String ( File file ) throws IO Exception { Input Stream in = new Buffered Input Stream ( new File Input Stream ( file ) , NUM ) ; Reader reader ; in . mark ( NUM ) ; int byte 1 = in . read ( ) ; int byte 2 = in . read ( ) ; if ( byte 1 == NUM && byte 2 == NUM ) { reader = new Input Stream Reader ( in , STRING ) ; } else if ( byte 1 == NUM && byte 2 == NUM ) { reader = new Input Stream Reader ( in , STRING ) ; } else { int byte 3 = in . read ( ) ; if ( byte 1 == NUM && byte 2 == NUM && byte 3 == NUM ) { reader = new Input Stream Reader ( in , STRING ) ; } else { in . reset ( ) ; reader = new Input Stream Reader ( in ) ; } } String Writer out = new String Writer ( ) ; char [ ] buffer = new char [ NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM ) { out . write ( buffer , NUM , count ) ; } in . close ( ) ; return out . to String ( ) ; }
public Shape straight Line Shape ( ) { General Path path = null ; if ( llpts != null && llpts . length >= NUM && llpts . length % NUM == NUM ) { double y1 = llpts [ NUM ] ; double x1 = llpts [ NUM ] ; path = new General Path ( General Path . WIND EVEN ODD , llpts . length / NUM ) ; if ( return Degrees ) { path . move To ( Proj Math . rad To Deg ( x1 ) , Proj Math . rad To Deg ( y1 ) ) ; } else { path . move To ( x1 , y1 ) ; } for ( int i = NUM ; i < llpts . length - NUM ; i += NUM ) { x1 = llpts [ i + NUM ] ; y1 = llpts [ i ] ; if ( return Degrees ) { path . line To ( Proj Math . rad To Deg ( x1 ) , Proj Math . rad To Deg ( y1 ) ) ; } else { path . line To ( x1 , y1 ) ; } } } return path ; }
public DTLS Session ( Inet Socket Address peer Address , boolean is Client ) { this ( peer Address , is Client , NUM ) ; }
protected static Vector convert To Vector ( final Object [ ] [ ] an Array ) { if ( an Array == null ) { return null ; } final Vector v = new Vector ( an Array . length ) ; for ( final Object [ ] element : an Array ) { v . add Element ( convert To Vector ( element ) ) ; } return v ; }
synchronized protected void timeout ( ) { Sprog Version v ; switch ( state ) { case CRSENT : log . debug ( STRING ) ; state = Query State . IDLE ; v = new Sprog Version ( new Sprog Type ( Sprog Type . TIMEOUT ) ) ; notify Version ( v ) ; break ; case QUERYSENT : log . debug ( STRING ) ; state = Query State . IDLE ; v = new Sprog Version ( new Sprog Type ( Sprog Type . NOT A SPROG ) ) ; notify Version ( v ) ; break ; case DONE : case IDLE : log . error ( STRING + state ) ; break ; } }
protected void accept Drag ( int drag Operation ) { Drop Target Context Peer peer = get Drop Target Context Peer ( ) ; if ( peer != null ) { peer . accept Drag ( drag Operation ) ; } }
public static String add Capabilities ( String title , Capabilities c ) { String result ; String caps ; result = title + STRING ; caps = list Capabilities ( c . get Class Capabilities ( ) ) ; if ( caps . length ( ) != NUM ) { result += STRING ; result += caps ; result += STRING ; } caps = list Capabilities ( c . get Attribute Capabilities ( ) ) ; if ( caps . length ( ) != NUM ) { result += STRING ; result += caps ; result += STRING ; } caps = list Capabilities ( c . get Other Capabilities ( ) ) ; if ( caps . length ( ) != NUM ) { result += STRING ; result += caps ; result += STRING ; } result += STRING ; result += STRING + c . get Minimum Number Instances ( ) + STRING ; result += STRING ; return result ; }

public long file Size ( String path ) throws Illegal State Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception { synchronized ( lock ) { if ( ! connected ) { throw new Illegal State Exception ( STRING ) ; } if ( ! authenticated ) { throw new Illegal State Exception ( STRING ) ; } communication . send FTP Command ( STRING ) ; FTP Reply r = communication . read FTP Reply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new FTP Exception ( r ) ; } communication . send FTP Command ( STRING + path ) ; r = communication . read FTP Reply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new FTP Exception ( r ) ; } String [ ] messages = r . get Messages ( ) ; if ( messages . length != NUM ) { throw new FTP Illegal Reply Exception ( ) ; } else { try { return Long . parse Long ( messages [ NUM ] ) ; } catch ( Throwable t ) { throw new FTP Illegal Reply Exception ( ) ; } } } }
public boolean import Pkcs 12 ( ) { return jrb Pkcs 12 . is Selected ( ) ; }
public Phase One Result process ( Tree Path body Path , Processing Environment env , Underlying AST underlying AST , Label exceptional Exit Label , Tree Builder tree Builder , Annotation Provider annotation Provider ) { this . env = env ; this . try Stack = new Try Stack ( exceptional Exit Label ) ; this . tree Builder = tree Builder ; this . annotation Provider = annotation Provider ; elements = env . get Element Utils ( ) ; types = env . get Type Utils ( ) ; tree Lookup Map = new Identity Hash Map < > ( ) ; converted Tree Lookup Map = new Identity Hash Map < > ( ) ; node List = new Array List < > ( ) ; bindings = new Hash Map < > ( ) ; leaders = new Hash Set < > ( ) ; break Labels = new Hash Map < > ( ) ; continue Labels = new Hash Map < > ( ) ; return Nodes = new Array List < > ( ) ; scan ( body Path , null ) ; node List . add ( new Unconditional Jump ( regular Exit Label ) ) ; return new Phase One Result ( underlying AST , tree Lookup Map , converted Tree Lookup Map , node List , bindings , leaders , return Nodes ) ; }
public boolean is Fusion ( ) { if ( ( engine Type == COMBUSTION ENGINE ) || ( engine Type == FISSION ) || ( engine Type == FUEL CELL ) || ( engine Type == NONE ) || ( engine Type == BATTERY ) || ( engine Type == SOLAR ) || ( engine Type == STEAM ) || ( engine Type == MAGLEV ) ) { return BOOL ; } return BOOL ; }
private double [ ] calculate B ( ) { int length = m Extremal Indices . size ( ) ; double [ ] b = new double [ length ] ; for ( int k = NUM ; k < length ; k ++ ) { b [ k ] = NUM ; double xk = m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( k ) ] ; for ( int i = NUM ; i < length ; i ++ ) { if ( i != k ) { double xi = m Grid . get Cosine Frequency Grid ( ) [ m Extremal Indices . get ( i ) ] ; double denominator = xk - xi ; if ( Math . abs ( denominator ) < NUM ) { denominator = NUM ; } b [ k ] *= NUM / denominator ; } } } return b ; }
public static final void decode ( Input Stream is , Output Stream os ) throws Base 64 Decoding Exception , IO Exception { byte b1 = NUM , b2 = NUM , b3 = NUM , b4 = NUM ; int index = NUM ; byte [ ] data = new byte [ NUM ] ; int read ; while ( ( read = is . read ( ) ) > NUM ) { byte readed = ( byte ) read ; if ( is White Space ( readed ) ) { continue ; } if ( is Pad ( readed ) ) { data [ index ++ ] = readed ; if ( index == NUM ) { data [ index ++ ] = ( byte ) is . read ( ) ; } break ; } if ( ( data [ index ++ ] = readed ) == - NUM ) { throw new Base 64 Decoding Exception ( STRING ) ; } if ( index != NUM ) { continue ; } index = NUM ; b1 = base 64 Alphabet [ data [ NUM ] ] ; b2 = base 64 Alphabet [ data [ NUM ] ] ; b3 = base 64 Alphabet [ data [ NUM ] ] ; b4 = base 64 Alphabet [ data [ NUM ] ] ; os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ) ; os . write ( ( byte ) ( b3 << NUM | b4 ) ) ; } byte d1 = data [ NUM ] , d2 = data [ NUM ] , d3 = data [ NUM ] , d4 = data [ NUM ] ; b1 = base 64 Alphabet [ d1 ] ; b2 = base 64 Alphabet [ d2 ] ; b3 = base 64 Alphabet [ d3 ] ; b4 = base 64 Alphabet [ d4 ] ; if ( ( b3 == - NUM ) || ( b4 == - NUM ) ) { if ( is Pad ( d3 ) && is Pad ( d4 ) ) { if ( ( b2 & NUM ) != NUM ) { throw new Base 64 Decoding Exception ( STRING ) ; } os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; } else if ( ! is Pad ( d3 ) && is Pad ( d4 ) ) { b3 = base 64 Alphabet [ d3 ] ; if ( ( b3 & NUM ) != NUM ) { throw new Base 64 Decoding Exception ( STRING ) ; } os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ) ; } else { throw new Base 64 Decoding Exception ( STRING ) ; } } else { os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ) ; os . write ( ( byte ) ( b3 << NUM | b4 ) ) ; } }
private Properties load Properties From External File ( String file Path , Properties fallback ) { Properties properties = new Properties ( fallback ) ; try { File Input Stream property File Stream = new File Input Stream ( file Path ) ; properties . load ( property File Stream ) ; return properties ; } catch ( Null Pointer Exception e ) { return fallback ; } catch ( File Not Found Exception e ) { return fallback ; } catch ( IO Exception e ) { return fallback ; } }
public static String replace ( final Object source , final Properties value Properties ) { if ( value Properties == null ) { return source . to String ( ) ; } final Map < String , String > value Map = new Hash Map < String , String > ( ) ; final Enumeration < ? > prop Names = value Properties . property Names ( ) ; while ( prop Names . has More Elements ( ) ) { final String prop Name = ( String ) prop Names . next Element ( ) ; final String prop Value = value Properties . get Property ( prop Name ) ; value Map . put ( prop Name , prop Value ) ; } return Str Substitutor . replace ( source , value Map ) ; }
@ Suppress Warnings ( STRING ) public < U > Lazy Future Stream < U > from ( final Iterator < U > iterator ) { return from Stream ( Stream Support . stream ( Spliterators . spliterator Unknown Size ( iterator , Spliterator . ORDERED ) , BOOL ) ) ; }
private void align On Baseline ( Grid Bag Constraints cons , Rectangle r , int cell Y , int cell Height ) { if ( cons . ascent >= NUM ) { if ( cons . baseline Resize Behavior == Component . Baseline Resize Behavior . CONSTANT DESCENT ) { int max Y = cell Y + cell Height - layout Info . max Descent [ cons . temp Y + cons . temp Height - NUM ] + cons . descent - cons . insets . bottom ; if ( ! cons . is Vertically Resizable ( ) ) { r . y = max Y - cons . min Height ; r . height = cons . min Height ; } else { r . height = max Y - cell Y - cons . insets . top ; } } else { int baseline ; int ascent = cons . ascent ; if ( layout Info . has Constant Descent ( cons . temp Y ) ) { baseline = cell Height - layout Info . max Descent [ cons . temp Y ] ; } else { baseline = layout Info . max Ascent [ cons . temp Y ] ; } if ( cons . baseline Resize Behavior == Component . Baseline Resize Behavior . OTHER ) { boolean fits = BOOL ; ascent = component Adjusting . get Baseline ( r . width , r . height ) ; if ( ascent >= NUM ) { ascent += cons . insets . top ; } if ( ascent >= NUM && ascent <= baseline ) { if ( baseline + ( r . height - ascent - cons . insets . top ) <= cell Height - cons . insets . bottom ) { fits = BOOL ; } else if ( cons . is Vertically Resizable ( ) ) { int ascent 2 = component Adjusting . get Baseline ( r . width , cell Height - cons . insets . bottom - baseline + ascent ) ; if ( ascent 2 >= NUM ) { ascent 2 += cons . insets . top ; } if ( ascent 2 >= NUM && ascent 2 <= ascent ) { r . height = cell Height - cons . insets . bottom - baseline + ascent ; ascent = ascent 2 ; fits = BOOL ; } } } if ( ! fits ) { ascent = cons . ascent ; r . width = cons . min Width ; r . height = cons . min Height ; } } r . y = cell Y + baseline - ascent + cons . insets . top ; if ( cons . is Vertically Resizable ( ) ) { switch ( cons . baseline Resize Behavior ) { case CONSTANT ASCENT : r . height = Math . max ( cons . min Height , cell Y + cell Height - r . y - cons . insets . bottom ) ; break ; case CENTER OFFSET : { int upper = r . y - cell Y - cons . insets . top ; int lower = cell Y + cell Height - r . y - cons . min Height - cons . insets . bottom ; int delta = Math . min ( upper , lower ) ; delta += delta ; if ( delta > NUM && ( cons . min Height + cons . center Padding + delta ) / NUM + cons . center Offset != baseline ) { delta -- ; } r . height = cons . min Height + delta ; r . y = cell Y + baseline - ( r . height + cons . center Padding ) / NUM - cons . center Offset ; } break ; case OTHER : break ; default : break ; } } } } else { center Vertically ( cons , r , cell Height ) ; } }
public void read External ( Object Input in ) throws IO Exception , Class Not Found Exception { byte [ ] hdr = new byte [ RES HEADER SIZE ] ; in . read Fully ( hdr ) ; res Type = U . bytes To Int ( hdr , NUM ) ; boolean has Err = hdr [ NUM ] != NUM ; if ( has Err ) { err = in . read UTF ( ) ; err Code = in . read Int ( ) ; if ( res Type == RES TYPE ERR STREAM ID ) res = in . read Long ( ) ; return ; } switch ( res Type ) { case RES TYPE BOOLEAN : res = in . read Boolean ( ) ; break ; case RES TYPE LONG : res = in . read Long ( ) ; break ; case RES TYPE IGFS PATH : { boolean has Val = in . read Boolean ( ) ; if ( has Val ) res = Igfs Utils . read Path ( in ) ; break ; } case RES TYPE IGFS PATH SUMMARY : { boolean has Val = in . read Boolean ( ) ; if ( has Val ) { Igfs Path Summary sum = new Igfs Path Summary ( ) ; sum . read External ( in ) ; res = sum ; } break ; } case RES TYPE IGFS FILE : { boolean has Val = in . read Boolean ( ) ; if ( has Val ) { Igfs File Impl file = new Igfs File Impl ( ) ; file . read External ( in ) ; res = file ; } break ; } case RES TYPE IGFS STREAM DESCRIPTOR : { boolean has Val = in . read Boolean ( ) ; if ( has Val ) { Igfs Input Stream Descriptor desc = new Igfs Input Stream Descriptor ( ) ; desc . read External ( in ) ; res = desc ; } break ; } case RES TYPE HANDSHAKE : { boolean has Val = in . read Boolean ( ) ; if ( has Val ) { Igfs Handshake Response msg = new Igfs Handshake Response ( ) ; msg . read External ( in ) ; res = msg ; } break ; } case RES TYPE STATUS : { boolean has Val = in . read Boolean ( ) ; if ( has Val ) { Igfs Status msg = new Igfs Status ( ) ; msg . read External ( in ) ; res = msg ; } break ; } case RES TYPE COL IGFS FILE : { Collection < Igfs File > files = null ; int size = in . read Int ( ) ; if ( size >= NUM ) { files = new Array List < > ( size ) ; for ( int i = NUM ; i < size ; i ++ ) { Igfs File Impl file = new Igfs File Impl ( ) ; file . read External ( in ) ; files . add ( file ) ; } } res = files ; break ; } case RES TYPE COL IGFS PATH : { Collection < Igfs Path > paths = null ; int size = in . read Int ( ) ; if ( size >= NUM ) { paths = new Array List < > ( size ) ; for ( int i = NUM ; i < size ; i ++ ) paths . add ( Igfs Utils . read Path ( in ) ) ; } res = paths ; break ; } case RES TYPE COL IGFS BLOCK LOCATION : { Collection < Igfs Block Location > locations = null ; int size = in . read Int ( ) ; if ( size >= NUM ) { locations = new Array List < > ( size ) ; for ( int i = NUM ; i < size ; i ++ ) { Igfs Block Location Impl location = new Igfs Block Location Impl ( ) ; location . read External ( in ) ; locations . add ( location ) ; } } res = locations ; break ; } case RES TYPE BYTE ARRAY : assert BOOL : STRING ; } }
public Interval XY Item Label Generator ( ) { this ( DEFAULT ITEM LABEL FORMAT , Number Format . get Number Instance ( ) , Number Format . get Number Instance ( ) ) ; }
public double adjusted Log 10 ( double val ) { boolean neg Flag = ( val < NUM ) ; if ( neg Flag ) { val = - val ; } if ( val < NUM ) { val += ( NUM - val ) / NUM ; } double res = Math . log ( val ) / LOG 10 VALUE ; return neg Flag ? ( - res ) : res ; }
public boolean is Last Invoice ( ) { String cm = get Costing Method ( ) ; return cm != null && cm . equals ( COSTINGMETHOD Last Invoice ) && COSTELEMENTTYPE Material . equals ( get Cost Element Type ( ) ) ; }
public static String build Cluster Cg Name ( String cluster Name , String cg Name ) { return String . format ( STRING + SPLITTER + STRING , cluster Name , cg Name ) ; }
private void fetch Users Service Cards From Server ( String user Id ) { Retro Callback retro Callback ; retro Callback = new Retro Callback ( this ) ; retro Callback . set Request Id ( Api Response Codes . GET USERS SERVICES ) ; retro Callback List . add ( retro Callback ) ; m Yelo Api . get Users Service Cards ( user Id , retro Callback ) ; }
public D View Public Key ( J Frame parent , String title , Public Key public Key ) throws Crypto Exception { super ( parent , title , Dialog . Modality Type . DOCUMENT MODAL ) ; this . public Key = public Key ; init Components ( ) ; }
public List < Colour Change > sample Conditional Migration Events ( int parent Colour , double parent Height , int child Colour , double child Height , double [ ] m ) { List < Colour Change > colour Changes = new Array List < Colour Change > ( ) ; int current Colour ; double current Height ; do { colour Changes . clear ( ) ; current Colour = parent Colour ; current Height = parent Height ; do { double total Rate = m [ NUM - current Colour ] ; double U = Math Utils . next Double ( ) ; if ( ( parent Colour != child Colour ) && ( colour Changes . size ( ) == NUM ) ) { double min U = Math . exp ( - total Rate * ( parent Height - child Height ) ) ; U = min U + U * ( NUM - min U ) ; } double time = - Math . log ( U ) / total Rate ; current Height -= time ; if ( current Height > child Height ) { current Colour = NUM - current Colour ; colour Changes . add ( new Colour Change ( current Height , current Colour ) ) ; } } while ( current Height > child Height ) ; } while ( current Colour != child Colour ) ; reverse Colour Change List ( colour Changes , parent Colour ) ; return colour Changes ; }
@ Override public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof Value Literal Node ) ) { return BOOL ; } Value Literal Node other = ( Value Literal Node ) obj ; Object val = get Value ( ) ; Object other Val = other . get Value ( ) ; return ( ( val == null || other Val == null ) && val == other Val ) || val . equals ( other Val ) ; }
public void write ( final byte b [ ] , final int off , final int len ) throws IO Exception { if ( ! m open ) { throw new Illegal State Exception ( STRING ) ; } if ( ( m cursor + len ) > WORM STREAM BUFFER SIZE ) { for ( int i = NUM ; i < len ; i ++ ) { write ( b [ off + i ] ) ; } } else { System . arraycopy ( b , off , m buffer , m cursor , len ) ; m cursor += len ; } }
public void remove Operator From Selection ( Operator selected Operator ) { List < Operator > new List = new Array List < > ( get Selected Operators ( ) ) ; new List . remove ( selected Operator ) ; this . selected Operators = Collections . unmodifiable List ( new List ) ; }
public synchronized void remove Property Change Listener ( Property Change Listener listener ) { listener List . remove ( listener ) ; }
public static void open Share Dialog ( Context context , String title , @ Suppress Warnings ( STRING ) String uri , String share Text , String share Subject ) { Intent share = new Intent ( Intent . ACTION SEND ) ; share . set Type ( STRING ) ; share . put Extra ( Intent . EXTRA TEXT , share Text ) ; share . put Extra ( Intent . EXTRA SUBJECT , share Subject ) ; if ( ! Text Utils . is Empty ( uri ) ) { share . set Type ( STRING ) ; share . put Extra ( Intent . EXTRA STREAM , Uri . parse ( uri ) ) ; } context . start Activity ( Intent . create Chooser ( share , title ) ) ; }
@ Caller Sensitive public static < U > Atomic Integer Field Updater < U > new Updater ( Class < U > tclass , String field Name ) { return new Atomic Integer Field Updater Impl < U > ( tclass , field Name , Reflection . get Caller Class ( ) ) ; }
private void tql 2 ( ) { for ( int i = NUM ; i < n ; i ++ ) { e [ i - NUM ] = e [ i ] ; } e [ n - NUM ] = NUM ; double f = NUM ; double tst 1 = NUM ; double eps = Math . pow ( NUM , - NUM ) ; for ( int l = NUM ; l < n ; l ++ ) { tst 1 = Math . max ( tst 1 , Math . abs ( d [ l ] ) + Math . abs ( e [ l ] ) ) ; int m = l ; while ( m < n ) { if ( Math . abs ( e [ m ] ) <= eps * tst 1 ) { break ; } m ++ ; } if ( m > l ) { int iter = NUM ; do { iter = iter + NUM ; double g = d [ l ] ; double p = ( d [ l + NUM ] - g ) / ( NUM * e [ l ] ) ; double r = Algebra . hypot ( p , NUM ) ; if ( p < NUM ) { r = - r ; } d [ l ] = e [ l ] / ( p + r ) ; d [ l + NUM ] = e [ l ] * ( p + r ) ; double dl 1 = d [ l + NUM ] ; double h = g - d [ l ] ; for ( int i = l + NUM ; i < n ; i ++ ) { d [ i ] -= h ; } f = f + h ; p = d [ m ] ; double c = NUM ; double c2 = c ; double c3 = c ; double el 1 = e [ l + NUM ] ; double s = NUM ; double s2 = NUM ; for ( int i = m - NUM ; i >= l ; i -- ) { c3 = c2 ; c2 = c ; s2 = s ; g = c * e [ i ] ; h = c * p ; r = Algebra . hypot ( p , e [ i ] ) ; e [ i + NUM ] = s * r ; s = e [ i ] / r ; c = p / r ; p = c * d [ i ] - s * g ; d [ i + NUM ] = h + s * ( c * g + s * d [ i ] ) ; for ( int k = NUM ; k < n ; k ++ ) { h = V [ k ] [ i + NUM ] ; V [ k ] [ i + NUM ] = s * V [ k ] [ i ] + c * h ; V [ k ] [ i ] = c * V [ k ] [ i ] - s * h ; } } p = - s * s2 * c3 * el 1 * e [ l ] / dl 1 ; e [ l ] = s * p ; d [ l ] = c * p ; } while ( Math . abs ( e [ l ] ) > eps * tst 1 ) ; } d [ l ] = d [ l ] + f ; e [ l ] = NUM ; } for ( int i = NUM ; i < n - NUM ; i ++ ) { int k = i ; double p = d [ i ] ; for ( int j = i + NUM ; j < n ; j ++ ) { if ( d [ j ] < p ) { k = j ; p = d [ j ] ; } } if ( k != i ) { d [ k ] = d [ i ] ; d [ i ] = p ; for ( int j = NUM ; j < n ; j ++ ) { p = V [ j ] [ i ] ; V [ j ] [ i ] = V [ j ] [ k ] ; V [ j ] [ k ] = p ; } } } }
private static Pair < String , String > pre Indexed LSR ( final long offset , final I Translation Environment environment , final List < Reil Instruction > instructions , final String register Node Value 1 , final String register Node Value 2 , final String immediate Node Value ) { final String address = environment . get Next Variable String ( ) ; final String tmp Var 1 = environment . get Next Variable String ( ) ; final String tmp Var 2 = environment . get Next Variable String ( ) ; final String index = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value 2 , dw , STRING + immediate Node Value , qw , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , qw , tmp Var 1 , dw , d Word Bit Mask , dw , index ) ) ; instructions . add ( Reil Helpers . create Add ( base Offset ++ , dw , register Node Value 1 , dw , index , dw , tmp Var 2 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , dw , tmp Var 2 , dw , d Word Bit Mask , dw , address ) ) ; instructions . add ( Reil Helpers . create Str ( base Offset ++ , dw , address , dw , register Node Value 1 ) ) ; return new Pair < String , String > ( address , register Node Value 1 ) ; }
public Mixed Data Box ( List < Node > variables , int num Rows ) { this . variables = variables ; this . num Rows = num Rows ; this . continuous Data = new double [ variables . size ( ) ] [ ] ; this . discrete Data = new int [ variables . size ( ) ] [ ] ; for ( int j = NUM ; j < variables . size ( ) ; j ++ ) { if ( variables . get ( j ) instanceof Continuous Variable ) { continuous Data [ j ] = new double [ num Rows ] ; Arrays . fill ( continuous Data [ j ] , Double . Na N ) ; } else if ( variables . get ( j ) instanceof Discrete Variable ) { discrete Data [ j ] = new int [ num Rows ] ; Arrays . fill ( discrete Data [ j ] , - NUM ) ; } } }
public final int last common layer ( Brd Item p other ) { int max first layer = Math . max ( first layer ( ) , p other . first layer ( ) ) ; int min last layer = Math . min ( last layer ( ) , p other . last layer ( ) ) ; if ( max first layer > min last layer ) return - NUM ; return min last layer ; }
public Item Stack add Item ( Item Stack drive , Item Stack item ) { if ( get Max Kilobits ( drive ) == - NUM ) { if ( get Partitioning Mode ( drive ) == Partitioning Mode . NONE || find Data Index For Prototype ( drive , create Prototype ( item ) ) != - NUM ) { item . stack Size = NUM ; return null ; } else { return item ; } } int bits Free = get Kilobits Free For ( drive , item ) ; int amount Taken = Math . min ( item . stack Size , bits Free ) ; int current = get Amount Stored ( drive , item ) ; if ( amount Taken > NUM ) { set Amount Stored ( drive , item , current + amount Taken ) ; item . stack Size -= amount Taken ; mark Dirty ( drive ) ; } if ( item . stack Size <= NUM ) { return null ; } else { return item ; } }
public synchronized void remove Index Family ( I Path path ) { Array List to Remove = null ; Object [ ] container Paths = this . index Locations . key Table ; for ( int i = NUM , length = container Paths . length ; i < length ; i ++ ) { I Path container Path = ( I Path ) container Paths [ i ] ; if ( container Path == null ) continue ; if ( path . is Prefix Of ( container Path ) ) { if ( to Remove == null ) to Remove = new Array List ( ) ; to Remove . add ( container Path ) ; } } if ( to Remove != null ) for ( int i = NUM , length = to Remove . size ( ) ; i < length ; i ++ ) remove Index ( ( I Path ) to Remove . get ( i ) ) ; }
public void add Item ( Artist artist ) { if ( artist == null ) throw new Null Pointer Exception ( STRING ) ; artists . add ( artist ) ; notify Item Inserted ( get Item Count ( ) - NUM ) ; }
public boolean refresh Location ( ) { if ( parent Com != null && content Com != null ) { Point location = Swing Utilities . convert Point ( parent Com , get Location ( ) , this ) ; set Bounds ( location . x + delta X , ( location . y + delta Y ) - get Preferred Size ( ) . height , get Preferred Size ( ) . width , get Preferred Size ( ) . height ) ; validate ( ) ; return BOOL ; } else throw new Illegal Argument Exception ( STRING ) ; }
private static void save Confirmed Stack Traces ( Weak Reference < Context > weak Context ) { Context context = null ; if ( weak Context != null ) { context = weak Context . get ( ) ; if ( context != null ) { try { String [ ] filenames = search For Report ( ) ; Shared Preferences preferences = context . get Shared Preferences ( ARTISAN SDK , Context . MODE PRIVATE ) ; Editor editor = preferences . edit ( ) ; editor . put String ( STRING , join Array ( filenames , STRING ) ) ; editor . apply ( ) ; } catch ( Exception e ) { } } } }
public void encode ( Output Stream out ) throws IO Exception { Der Output Stream tmp = new Der Output Stream ( ) ; if ( this . extension Value == null ) { this . extension Id = PKIX Extensions . Invalidity Date Id ; this . critical = BOOL ; encode This ( ) ; } super . encode ( tmp ) ; out . write ( tmp . to Byte Array ( ) ) ; }
public Driver Task create Volumes ( List < Storage Volume > volumes , Storage Capabilities storage Capabilities ) { Driver Task task = new Dell SC Driver Task ( STRING ) ; String Builder err Buffer = new String Builder ( ) ; int volumes Created = NUM ; for ( Storage Volume volume : volumes ) { LOG . debug ( STRING , volume . get Display Name ( ) , volume . get Storage System Id ( ) ) ; String ssn = volume . get Storage System Id ( ) ; try { Storage Center API api = connection Manager . get Connection ( ssn ) ; Sc Volume sc Vol = api . create Volume ( ssn , volume . get Display Name ( ) , volume . get Storage Pool Id ( ) , Size Util . byte To Meg ( volume . get Requested Capacity ( ) ) , volume . get Consistency Group ( ) ) ; volume . set Provisioned Capacity ( Size Util . size Str To Bytes ( sc Vol . configured Size ) ) ; volume . set Allocated Capacity ( NUM ) ; volume . set Wwn ( sc Vol . device Id ) ; volume . set Native Id ( sc Vol . instance Id ) ; volume . set Device Label ( sc Vol . name ) ; volume . set Access Status ( Access Status . READ WRITE ) ; volumes Created ++ ; LOG . info ( STRING , sc Vol . name ) ; } catch ( Storage Center API Exception | Dell SC Driver Exception dex ) { String error = String . format ( STRING , volume . get Display Name ( ) , dex ) ; LOG . error ( error ) ; err Buffer . append ( String . format ( STRING , error ) ) ; } } task . set Message ( err Buffer . to String ( ) ) ; if ( volumes Created == volumes . size ( ) ) { task . set Status ( Task Status . READY ) ; } else if ( volumes Created == NUM ) { task . set Status ( Task Status . FAILED ) ; } else { task . set Status ( Task Status . PARTIALLY FAILED ) ; } return task ; }
public void create Vm Async ( final String project Id , final Vm Create Spec vm Create Spec , final Future Callback < Task > response Callback ) throws IO Exception { final String path = String . format ( STRING , get Base Path ( ) , project Id ) ; create Object Async ( path , serialize Object As Json ( vm Create Spec ) , response Callback ) ; }
public static Result Code value Of ( final int int Value ) { Result Code result = ELEMENTS . get ( int Value ) ; if ( result == null ) { result = new Result Code ( int Value , Localizable Message . raw ( STRING + int Value + STRING ) , BOOL , Enum . UNKNOWN ) ; } return result ; }
public static void write Unsafe ( Packet Output Stream out , Input Stream is , boolean no Backslash Escapes ) throws IO Exception { out . write Unsafe ( QUOTE ) ; byte [ ] buffer = new byte [ NUM ] ; int len ; while ( ( len = is . read ( buffer ) ) >= NUM ) { write Bytes Escaped Unsafe ( out , buffer , len , no Backslash Escapes ) ; } out . write Unsafe ( QUOTE ) ; }
public boolean skip To ( long position ) throws IO Exception { if ( position == position ( ) ) { return BOOL ; } Log Reader skip Reader = dlm . get Input Stream ( position ) ; Log Record With Input Stream log Record = null ; try { log Record = next Log Record ( skip Reader ) ; } catch ( IO Exception ex ) { skip Reader . close ( ) ; throw ex ; } if ( null == log Record ) { return BOOL ; } current Position = log Record . get Offset ( ) ; current Log Record = log Record ; Log Reader old Reader = reader ; reader = skip Reader ; old Reader . close ( ) ; byte [ ] skip Buffer = new byte [ SKIP BUFFER SIZE ] ; while ( current Position < position ) { long bytes To Read = Math . min ( position - current Position , SKIP BUFFER SIZE ) ; long bytes Read = read ( skip Buffer , NUM , ( int ) bytes To Read ) ; if ( bytes Read < bytes To Read ) { return BOOL ; } } return BOOL ; }
public byte [ ] encode To Bitcoin ( ) { if ( schnorr != null ) { try { Byte Array Output Stream bos = new Byte Array Output Stream ( NUM ) ; bos . write ( schnorr ) ; bos . write ( sighash Flags ) ; return bos . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } } try { Byte Array Output Stream bos = der Byte Stream ( ) ; bos . write ( sighash Flags ) ; return bos . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
private static String check Property ( String key , String default Value ) { String result = null ; if ( key . equals ( P WARNING ) || key . equals ( P WARNING de ) ) result = default Value ; else if ( ! is Client ( ) ) result = s prop . get Property ( key , Secure Interface . CLEARVALUE START + default Value + Secure Interface . CLEARVALUE END ) ; else result = s prop . get Property ( key , Secure Engine . encrypt ( default Value ) ) ; s prop . set Property ( key , result ) ; return result ; }
public static int object Equals ( Object obj 1 , Object obj 2 ) { return obj 1 . equals ( obj 2 ) ? TRUE : FALSE ; }
public static void si Wait ( Object o , long time ) { try { if ( time == - NUM ) o . wait ( ) ; else o . wait ( time ) ; } catch ( Interrupted Exception e ) { throw new SI Exception ( ) ; } abort Or Pause If Necessary ( ) ; }
private void log O Data Perf ( String query , long delta time ) { LOGGER . debug ( STRING + get Id ( ) + STRING + query + STRING + delta time + STRING ) ; }
public void save ( String key , Object data , boolean is Encrypted , String encrypt Key ) { key = safety Key ( key ) ; String wrapper JSON Serialized ; if ( data instanceof Record ) { Type type = jolyglot . new Parameterized Type ( data . get Class ( ) , Object . class ) ; wrapper JSON Serialized = jolyglot . to Json ( data , type ) ; } else { wrapper JSON Serialized = jolyglot . to Json ( data ) ; } File Writer file Writer = null ; try { File file = new File ( cache Directory , key ) ; file Writer = new File Writer ( file , BOOL ) ; file Writer . write ( wrapper JSON Serialized ) ; file Writer . flush ( ) ; file Writer . close ( ) ; file Writer = null ; if ( is Encrypted ) { file Encryptor . encrypt ( encrypt Key , new File ( cache Directory , key ) ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } finally { try { if ( file Writer != null ) { file Writer . flush ( ) ; file Writer . close ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } }
public static void send SLO Requests To Other Participants ( String tenant , Logout State logout State ) throws IO Exception { log . info ( STRING ) ; Locale locale = logout State . get Locale ( ) ; Http Servlet Response response = logout State . get Response ( ) ; Validate . not Null ( response ) ; Collection < String > saml Request Urls = logout State . generate Request Urls For Tenant ( tenant , logout State . get Message Source ( ) , locale ) ; if ( saml Request Urls == null ) return ; for ( String request Url : saml Request Urls ) { log . info ( STRING + request Url ) ; if ( request Url != null ) { Throwable exception = null ; try { send SLO Request To Other Participant ( request Url ) ; } catch ( URI Syntax Exception e ) { exception = e ; } catch ( IO Exception e ) { exception = e ; } catch ( Key Management Exception e ) { exception = e ; } catch ( No Such Algorithm Exception e ) { exception = e ; } catch ( Key Store Exception e ) { exception = e ; } if ( exception != null ) { log . error ( STRING + request Url , exception ) ; } } else { Saml Service Impl . send Logout Error ( locale , response , logout State , logout State . get Message Source ( ) ) ; } } }
public static void assert Label ( String name , String text ) { if ( verbose ) { log ( STRING + name + STRING + text + STRING ) ; } Label l = ( Label ) find By Name ( name ) ; assert Bool ( l != null , STRING + text ) ; assert Bool ( text == l . get Text ( ) || text . equals ( l . get Text ( ) ) , name + STRING + text ) ; }
public static boolean is Equivalent ( Array List < Path Parser . Path Data Node > original , Array List < Path Parser . Path Data Node > alternative ) { int inner Start = NUM ; for ( Path Parser . Path Data Node o : original ) { boolean found = BOOL ; for ( int i = inner Start ; i < alternative . size ( ) && ! found ; i ++ ) { Path Parser . Path Data Node n = alternative . get ( i ) ; if ( ( o . m Type == n . m Type && Arrays . equals ( o . m Params , n . m Params ) ) || ( ( o . m Type == STRING || o . m Type == STRING ) && n . m Type == STRING ) ) { found = BOOL ; inner Start = i + NUM ; } } if ( ! found ) return BOOL ; } return BOOL ; }
private Stream Tokenizer make Arff Tokenizer ( Buffered Reader br ) { Stream Tokenizer tokenizer = new Stream Tokenizer ( br ) ; { tokenizer . reset Syntax ( ) ; tokenizer . whitespace Chars ( NUM , STRING ) ; tokenizer . ordinary Chars ( STRING , STRING ) ; tokenizer . ordinary Char ( STRING ) ; tokenizer . ordinary Char ( STRING ) ; tokenizer . word Chars ( STRING + NUM , STRING ) ; tokenizer . whitespace Chars ( STRING , STRING ) ; tokenizer . comment Char ( STRING ) ; tokenizer . quote Char ( STRING ) ; tokenizer . quote Char ( STRING ) ; tokenizer . ordinary Char ( STRING ) ; tokenizer . ordinary Char ( STRING ) ; tokenizer . eol Is Significant ( BOOL ) ; } return tokenizer ; }
protected void close All Activities ( ) throws Exception { try { for ( int i = NUM ; i < NUM ; i ++ ) { press Back ( ) ; Thread . sleep ( NUM ) ; } } catch ( No Activity Resumed Exception | Interrupted Exception e ) { } }
protected void view Record Field ( DDF Field po Field ) { DDF Field Definition po Field Defn = po Field . get Field Defn ( ) ; Debug . output ( STRING + po Field Defn . get Name ( ) + STRING + po Field Defn . get Description ( ) ) ; byte [ ] pach Field Data = po Field . get Data ( ) ; int n Bytes Remaining = po Field . get Data Size ( ) ; for ( int i Repeat = NUM ; i Repeat < po Field . get Repeat Count ( ) ; i Repeat ++ ) { if ( i Repeat > NUM ) { Debug . output ( STRING + i Repeat + STRING ) ; } for ( int iSF = NUM ; iSF < po Field Defn . get Subfield Count ( ) ; iSF ++ ) { DDF Subfield Definition po SF Defn = po Field Defn . get Subfield Defn ( iSF ) ; int n Bytes Consumed = view Subfield ( po SF Defn , pach Field Data , n Bytes Remaining ) ; n Bytes Remaining -= n Bytes Consumed ; byte [ ] temp Data = new byte [ pach Field Data . length - n Bytes Consumed ] ; System . arraycopy ( pach Field Data , n Bytes Consumed , temp Data , NUM , temp Data . length ) ; pach Field Data = temp Data ; } } }
@ Override public boolean lock ( ) { try { if ( ! File Factory . is File Exist ( location , File Factory . get File Type ( tmp Path ) ) ) { File Factory . mkdirs ( location , File Factory . get File Type ( tmp Path ) ) ; } lock File Path = location + Carbon Common Constants . FILE SEPARATOR + lock File ; if ( ! File Factory . is File Exist ( lock File Path , File Factory . get File Type ( location ) ) ) { File Factory . create New Lock File ( lock File Path , File Factory . get File Type ( location ) ) ; } file Output Stream = new File Output Stream ( lock File Path ) ; channel = file Output Stream . get Channel ( ) ; try { file Lock = channel . try Lock ( ) ; } catch ( Overlapping File Lock Exception e ) { return BOOL ; } if ( null != file Lock ) { return BOOL ; } else { return BOOL ; } } catch ( IO Exception e ) { return BOOL ; } }
public void load Functions From Script ( final String script Name ) { final Script script = get Script ( script Name , Date Utils . today ( ) ) ; final Script Engine engine = script Engine Provider . get Script Engine ( script . get Type ( ) ) ; execute Script ( script , engine , engine . get Context ( ) ) ; }
public void enable ( Rich Formatter Feature feature ) { features . add ( feature ) ; }
public void add Event Listener ( Z Wave Event Listener event Listener ) { synchronized ( zwave Event Listeners ) { if ( zwave Event Listeners . contains ( event Listener ) ) { logger . debug ( STRING , event Listener ) ; return ; } zwave Event Listeners . add ( event Listener ) ; } }
public static void calibrate Nanos Conversion ( ) { long original Millis = System . current Time Millis ( ) ; long updated Millis = original Millis ; while ( original Millis == updated Millis ) { updated Millis = System . current Time Millis ( ) ; } reference Nanos = System . nano Time ( ) ; reference Millis = updated Millis ; seconds Offset = millis To Seconds ( reference Millis ) - ( double ) reference Nanos / ( double ) NANOS IN SECOND ; }
@ Safe Varargs public final void inject Elements ( Timestamped Value < Input T > ... values ) throws Exception { inject Elements ( Arrays . as List ( values ) ) ; }
public static String quote ( String name ) { return JVM Module Util . quote ( name ) ; }
private void add Single Unique ( String Builder sb , Field Type field Type , List < String > additional Args , List < String > statements After ) { String Builder alter Sb = new String Builder ( ) ; alter Sb . append ( STRING ) ; append Escaped Entity Name ( alter Sb , field Type . get Column Name ( ) ) ; alter Sb . append ( STRING ) ; additional Args . add ( alter Sb . to String ( ) ) ; }
public static boolean is Valid Import String ( String s ) { if ( s . equals ( STRING ) ) return BOOL ; boolean valid = BOOL ; String t = s ; int index = t . index Of ( STRING ) ; if ( index != - NUM ) { if ( index == t . length ( ) - NUM ) { if ( index - NUM >= NUM ) { valid = t . char At ( index - NUM ) == STRING ; t = t . substring ( NUM , t . length ( ) - NUM ) ; } } else return BOOL ; } if ( valid ) { String [ ] java Ids = t . split ( STRING , t . length ( ) + NUM ) ; for ( String java Id : java Ids ) valid &= Source Version . is Identifier ( java Id ) ; } return valid ; }
@ HLE Function ( nid = NUM , version = NUM ) public int sce Rtc Get Tick ( Sce Psp Date Time time , T Pointer 64 ticks Addr ) { Calendar cal = new Gregorian Calendar ( time . year , time . month - NUM , time . day , time . hour , time . minute , time . second ) ; cal . set ( Calendar . MILLISECOND , time . microsecond / NUM ) ; cal . set Time Zone ( Sce Psp Date Time . GMT ) ; long ticks = rtc Magic Offset + ( cal . get Time In Millis ( ) * NUM ) + ( time . microsecond % NUM ) ; ticks Addr . set Value ( ticks ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( String . format ( STRING , ticks ) ) ; } return NUM ; }
private void populate Nav Drawer ( ) { m Nav Drawer Items . clear ( ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM HOME ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM WEBVIEW ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM TSTB ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM VOICE COMMANDS ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM PALETTE ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM SEPARATOR SPECIAL ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM ABOUT ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM BUG REPORT ) ; m Nav Drawer Items . add ( NAVDRAWER ITEM REQUEST ) ; create Nav Drawer Items ( ) ; }
private byte [ ] decrypt ( byte [ ] data , NTRU Encryption Private Key Parameters priv Key ) throws Invalid Cipher Text Exception { Polynomial priv t = priv Key . t ; Integer Polynomial priv fp = priv Key . fp ; Integer Polynomial pub = priv Key . h ; int N = params . N ; int q = params . q ; int db = params . db ; int max Msg Len Bytes = params . max Msg Len Bytes ; int dm 0 = params . dm 0 ; int pk Len = params . pk Len ; int min Calls Mask = params . min Calls Mask ; boolean hash Seed = params . hash Seed ; byte [ ] oid = params . oid ; if ( max Msg Len Bytes > NUM ) { throw new Data Length Exception ( STRING ) ; } int b Len = db / NUM ; Integer Polynomial e = Integer Polynomial . from Binary ( data , N , q ) ; Integer Polynomial ci = decrypt ( e , priv t , priv fp ) ; if ( ci . count ( - NUM ) < dm 0 ) { throw new Invalid Cipher Text Exception ( STRING ) ; } if ( ci . count ( NUM ) < dm 0 ) { throw new Invalid Cipher Text Exception ( STRING ) ; } if ( ci . count ( NUM ) < dm 0 ) { throw new Invalid Cipher Text Exception ( STRING ) ; } Integer Polynomial cR = ( Integer Polynomial ) e . clone ( ) ; cR . sub ( ci ) ; cR . mod Positive ( q ) ; Integer Polynomial cR 4 = ( Integer Polynomial ) cR . clone ( ) ; cR 4 . mod Positive ( NUM ) ; byte [ ] co R 4 = cR 4 . to Binary ( NUM ) ; Integer Polynomial mask = MGF ( co R 4 , N , min Calls Mask , hash Seed ) ; Integer Polynomial cM Trin = ci ; cM Trin . sub ( mask ) ; cM Trin . mod 3 ( ) ; byte [ ] cM = cM Trin . to Binary 3 Sves ( ) ; byte [ ] cb = new byte [ b Len ] ; System . arraycopy ( cM , NUM , cb , NUM , b Len ) ; int cl = cM [ b Len ] & NUM ; if ( cl > max Msg Len Bytes ) { throw new Invalid Cipher Text Exception ( STRING + cl + STRING + max Msg Len Bytes ) ; } byte [ ] cm = new byte [ cl ] ; System . arraycopy ( cM , b Len + NUM , cm , NUM , cl ) ; byte [ ] p0 = new byte [ cM . length - ( b Len + NUM + cl ) ] ; System . arraycopy ( cM , b Len + NUM + cl , p0 , NUM , p0 . length ) ; if ( ! Arrays . constant Time Are Equal ( p0 , new byte [ p0 . length ] ) ) { throw new Invalid Cipher Text Exception ( STRING ) ; } byte [ ] bh = pub . to Binary ( q ) ; byte [ ] h Trunc = copy Of ( bh , pk Len / NUM ) ; byte [ ] s Data = build S Data ( oid , cm , cl , cb , h Trunc ) ; Polynomial cr = generate Blinding Poly ( s Data , cm ) ; Integer Polynomial cR Prime = cr . mult ( pub ) ; cR Prime . mod Positive ( q ) ; if ( ! cR Prime . equals ( cR ) ) { throw new Invalid Cipher Text Exception ( STRING ) ; } return cm ; }
private void initialize Path ( String p uri Spec , int p n Start Index ) throws Malformed URI Exception { if ( p uri Spec == null ) { throw new Malformed URI Exception ( STRING ) ; } int index = p n Start Index ; int start = p n Start Index ; int end = p uri Spec . length ( ) ; char test Char = STRING ; if ( start < end ) { if ( get Scheme ( ) == null || p uri Spec . char At ( start ) == STRING ) { while ( index < end ) { test Char = p uri Spec . char At ( index ) ; if ( test Char == STRING ) { if ( index + NUM >= end || ! is Hex ( p uri Spec . char At ( index + NUM ) ) || ! is Hex ( p uri Spec . char At ( index + NUM ) ) ) { throw new Malformed URI Exception ( STRING ) ; } index += NUM ; } else if ( ! is Path Character ( test Char ) ) { if ( test Char == STRING || test Char == STRING ) { break ; } throw new Malformed URI Exception ( STRING + test Char ) ; } ++ index ; } } else { while ( index < end ) { test Char = p uri Spec . char At ( index ) ; if ( test Char == STRING || test Char == STRING ) { break ; } if ( test Char == STRING ) { if ( index + NUM >= end || ! is Hex ( p uri Spec . char At ( index + NUM ) ) || ! is Hex ( p uri Spec . char At ( index + NUM ) ) ) { throw new Malformed URI Exception ( STRING ) ; } index += NUM ; } else if ( ! is URI Character ( test Char ) ) { throw new Malformed URI Exception ( STRING + test Char ) ; } ++ index ; } } } m path = p uri Spec . substring ( start , index ) ; if ( test Char == STRING ) { index ++ ; start = index ; while ( index < end ) { test Char = p uri Spec . char At ( index ) ; if ( test Char == STRING ) { break ; } if ( test Char == STRING ) { if ( index + NUM >= end || ! is Hex ( p uri Spec . char At ( index + NUM ) ) || ! is Hex ( p uri Spec . char At ( index + NUM ) ) ) { throw new Malformed URI Exception ( STRING ) ; } index += NUM ; } else if ( ! is URI Character ( test Char ) ) { throw new Malformed URI Exception ( STRING + test Char ) ; } index ++ ; } m query String = p uri Spec . substring ( start , index ) ; } if ( test Char == STRING ) { index ++ ; start = index ; while ( index < end ) { test Char = p uri Spec . char At ( index ) ; if ( test Char == STRING ) { if ( index + NUM >= end || ! is Hex ( p uri Spec . char At ( index + NUM ) ) || ! is Hex ( p uri Spec . char At ( index + NUM ) ) ) { throw new Malformed URI Exception ( STRING ) ; } index += NUM ; } else if ( ! is URI Character ( test Char ) ) { throw new Malformed URI Exception ( STRING + test Char ) ; } index ++ ; } m fragment = p uri Spec . substring ( start , index ) ; } }
public static byte [ ] values ( Byte [ ] array ) { byte [ ] dest = new byte [ array . length ] ; for ( int i = NUM ; i < array . length ; i ++ ) { Byte v = array [ i ] ; if ( v != null ) { dest [ i ] = v . byte Value ( ) ; } } return dest ; }
public void audit Config ( Operation Type Enum audit Type , String operational Status , String description , Object ... descparams ) { audit Mgr . record Audit Log ( null , null , EVENT SERVICE TYPE , audit Type , System . current Time Millis ( ) , operational Status , description , descparams ) ; }
public static double mean ( double [ ] data , int start Index , int end Index ) { double mean = NUM ; int total = NUM ; start Index = Math . max ( start Index , NUM ) ; start Index = Math . min ( start Index , data . length - NUM ) ; end Index = Math . max ( end Index , NUM ) ; end Index = Math . min ( end Index , data . length - NUM ) ; if ( start Index > end Index ) start Index = end Index ; for ( int i = start Index ; i <= end Index ; i ++ ) { if ( Double . is Na N ( data [ i ] ) ) throw new Illegal Argument Exception ( STRING ) ; mean += data [ i ] ; total ++ ; } mean /= total ; return mean ; }
public Run Stats delegate Get Bucket For Fourthousand Year Dates ( int buckets ) throws Exception { long start Time = System . current Time Millis ( ) ; Primary Index Bucket Generator Impl ibg = new Primary Index Bucket Generator Impl ( Field Data Type . DATE TIME , buckets ) ; Primary Index Bucket Locator Impl locator = new Primary Index Bucket Locator Impl ( null , ibg . generate Buckets ( ) , null , null , null , null , null , null , null ) ; logger . debug ( STRING ) ; Simple Date Format simple Dt Format = new Simple Date Format ( STRING ) ; String start Date = STRING ; Hash Map < Long , List < Object > > hm = new Hash Map < > ( ) ; Summary Statistics stats = new Summary Statistics ( ) ; Date date = null ; for ( int i = NUM ; i < NUM ; i ++ ) { date = simple Dt Format . parse ( start Date ) ; final Date TIME = new Date ( ( long ) ( Math . random ( ) * NUM ) ) ; date . set Time ( date . get Time ( ) + TIME . get Time ( ) ) ; Long bucket Id = locator . get Bucket ( start Date , Field Data Type . DATE TIME ) ; calculate ( hm , stats , bucket Id , start Date ) ; date . set Time ( date . get Time ( ) + NUM - TIME . get Time ( ) ) ; start Date = simple Dt Format . format ( date . get Time ( ) ) ; } long run Time = System . current Time Millis ( ) - start Time ; Run Stats run Stats = new Run Stats ( STRING , Field Data Type . DATE TIME , run Time , stats , hm ) ; logger . debug ( run Stats . to String ( ) ) ; return run Stats ; }
public Fixed Content Type Resolver ( Media Type media Types ) { this . media Types = Collections . singleton List ( media Types ) ; }
public void paint Text ( Synth Context ss , Graphics g , String text , int x , int y , int mnemonic Index ) { if ( text != null ) { Graphics 2 D g2 d = ( Graphics 2 D ) g . create ( ) ; g2 d . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; J Component c = ss . get Component ( ) ; Font Metrics fm = Swing Utilities 2 . get Font Metrics ( c , g2 d ) ; y += fm . get Ascent ( ) ; Swing Utilities 2 . draw String ( c , g2 d , text , x , y ) ; if ( mnemonic Index >= NUM && mnemonic Index < text . length ( ) ) { int underline X = x + Swing Utilities 2 . string Width ( c , fm , text . substring ( NUM , mnemonic Index ) ) ; int underline Y = y ; int underline Width = fm . char Width ( text . char At ( mnemonic Index ) ) ; int underline Height = NUM ; g2 d . fill Rect ( underline X , underline Y + fm . get Descent ( ) - NUM , underline Width , underline Height ) ; } } }
public void add All ( int [ ] data ) { int data Len = data . length ; if ( data Len == NUM ) { return ; } int newcap = size + ( int ) ( data Len * NUM ) + NUM ; ensure Capacity ( newcap ) ; System . arraycopy ( data , NUM , array , size , data Len ) ; size += data Len ; }
static byte [ ] read ( final I Memory Manager mmgr , final long addr ) { final int nbytes = get Allocation Size ( addr ) ; final byte [ ] a = new byte [ nbytes ] ; final Byte Buffer mybb = Byte Buffer . wrap ( a ) ; final Byte Buffer [ ] bufs = mmgr . get ( addr ) ; for ( Byte Buffer b : bufs ) { mybb . put ( b ) ; } return a ; }
private List < Class Symbol > enter Class Files ( Map < String , Java File Object > class Files ) { Class Reader reader = Class Reader . instance ( context ) ; Names names = Names . instance ( context ) ; List < Class Symbol > list = List . nil ( ) ; for ( Map . Entry < String , Java File Object > entry : class Files . entry Set ( ) ) { Name name = names . from String ( entry . get Key ( ) ) ; Java File Object file = entry . get Value ( ) ; if ( file . get Kind ( ) != Java File Object . Kind . CLASS ) throw new Assertion Error ( file ) ; Class Symbol cs ; if ( is Pkg Info ( file , Java File Object . Kind . CLASS ) ) { Name package Name = Convert . package Part ( name ) ; Package Symbol p = reader . enter Package ( package Name ) ; if ( p . package info == null ) p . package info = reader . enter Class ( Convert . short Name ( name ) , p ) ; cs = p . package info ; if ( cs . classfile == null ) cs . classfile = file ; } else cs = reader . enter Class ( name , file ) ; list = list . prepend ( cs ) ; } return list . reverse ( ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( ! ( obj instanceof Y Interval Renderer ) ) { return BOOL ; } Y Interval Renderer that = ( Y Interval Renderer ) obj ; if ( ! Object Utilities . equal ( this . additional Item Label Generator , that . additional Item Label Generator ) ) { return BOOL ; } return super . equals ( obj ) ; }
public static Node remove Children ( Node node ) { if ( node . get Node Type ( ) == Node . ELEMENT NODE ) { Node List children = node . get Child Nodes ( ) ; for ( int i = NUM ; i < children . get Length ( ) ; i ++ ) { Node child = children . item ( i ) ; Node temp = node . remove Child ( child ) ; i -- ; } } return node ; }
public synchronized Combo Box < V > remote Item ( int index ) { items . remove ( index ) ; if ( index < selected Index ) { set Selected Index ( selected Index - NUM ) ; } else if ( index == selected Index ) { set Selected Index ( - NUM ) ; } invalidate ( ) ; return this ; }
public static boolean is Primitive Type ( String type Signature ) { return SIG PRIMITIVE TYPES . contains ( type Signature ) ; }
public void check Permission ( Object object , Namespace Permission Enum [ ] permissions ) { List < Access Denied Exception > access Denied Exceptions = new Array List < > ( ) ; check Permission ( object , permissions , access Denied Exceptions ) ; if ( ! access Denied Exceptions . is Empty ( ) ) { throw get Access Denied Exception ( access Denied Exceptions ) ; } }
private static Intent create Call Activity Intent ( Context context , URL Span [ ] url Spans ) { Telephony Manager tm = ( Telephony Manager ) context . get System Service ( Context . TELEPHONY SERVICE ) ; if ( tm . get Phone Type ( ) == Telephony Manager . PHONE TYPE NONE ) { return null ; } for ( int span i = NUM ; span i < url Spans . length ; span i ++ ) { URL Span url Span = url Spans [ span i ] ; String url String = url Span . get URL ( ) ; if ( url String . starts With ( TEL PREFIX ) ) { Intent call Intent = new Intent ( Intent . ACTION DIAL , Uri . parse ( url String ) ) ; call Intent . add Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; return call Intent ; } } return null ; }
private void add Files Parameter ( Daemon Parameters parameters , String parameter Name , String file Prefix , Map < String , String > files ) { String Builder properties JSON = new String Builder ( ) ; properties JSON . append ( STRING ) ; int file Id = NUM ; for ( Map . Entry < String , String > entry : files . entry Set ( ) ) { String relative Path = entry . get Key ( ) ; String absolute Path = entry . get Value ( ) ; if ( file Id != NUM ) { properties JSON . append ( STRING ) ; } properties JSON . append ( STRING + relative Path + STRING ) ; parameters . set File ( file Prefix + file Id , absolute Path ) ; file Id ++ ; } properties JSON . append ( STRING ) ; parameters . set Parameter ( parameter Name , properties JSON . to String ( ) ) ; }
private String pre Process Signature ( String signature ) { int index ; if ( ( index = signature . index Of ( STRING ) ) > NUM ) { signature = signature . substring ( NUM , index ) ; } while ( ( index = signature . index Of ( STRING ) ) > NUM ) { signature = signature . substring ( NUM , index ) + signature . substring ( index + NUM , signature . length ( ) ) ; } return signature ; }
public static void clear Image ( Buffered Image image , Color bg Color ) { Graphics 2 D g2 d = ( Graphics 2 D ) image . get Graphics ( ) ; g2 d . set Color ( bg Color ) ; g2 d . fill Rect ( NUM , NUM , image . get Width ( ) , image . get Height ( ) ) ; g2 d . dispose ( ) ; }
public static List < Long > to Long List ( @ Nullable long [ ] arr ) { if ( arr == null || arr . length == NUM ) return Collections . empty List ( ) ; List < Long > ret = new Array List < > ( arr . length ) ; for ( long l : arr ) ret . add ( l ) ; return ret ; }
public static void update UI ( Window win ) { if ( win == null ) return ; Window c = win ; do { Swing Utilities . update Component Tree UI ( c ) ; c . invalidate ( ) ; c . pack ( ) ; c . validate ( ) ; c . repaint ( ) ; c = c . get Owner ( ) ; } while ( c != null ) ; }
private static Array List < Constraint Widget Container > gather Containers ( Constraint Widget Container container ) { Array List < Constraint Widget Container > containers = new Array List < > ( ) ; for ( Constraint Widget widget : container . get Children ( ) ) { if ( widget instanceof Constraint Widget Container ) { containers . add ( ( Constraint Widget Container ) widget ) ; } } return containers ; }
public final void print Quoted Symbol ( Char Sequence text ) throws IO Exception { if ( text == null ) { append Ascii ( STRING ) ; } else if ( text . length ( ) == NUM ) { throw new Empty Symbol Exception ( ) ; } else { append Ascii ( STRING ) ; print Code Points ( text , SYMBOL ESCAPE CODES ) ; append Ascii ( STRING ) ; } }
@ Override public String to String ( ) { Map < Value , Double > sorted Table = Inference Utils . get N Best ( table , Math . max ( table . size ( ) , NUM ) ) ; String str = STRING ; for ( Entry < Value , Double > entry : sorted Table . entry Set ( ) ) { String prob = String Utils . get Short Form ( entry . get Value ( ) ) ; str += STRING + variable + STRING + entry . get Key ( ) + STRING + prob + STRING ; } return ( str . length ( ) > NUM ) ? str . substring ( NUM , str . length ( ) - NUM ) : str ; }
private void update Border ( ) { m table Border . set Title ( get Border Text ( ) ) ; update UI ( ) ; }
public List < Resource > scan ( ) { List < Resource > found Resources = new Linked List < > ( ) ; List < Class < ? extends Object > > classes ; try { if ( jar Url == null ) { if ( this . clazz != null ) { classes = get Classes In Package ( this . package Name , this . clazz ) ; } else { classes = get Classes In Package ( this . package Name ) ; } } else { classes = get Classes In Jar File ( jar Url ) ; } } catch ( IO Exception e ) { return found Resources ; } for ( Class clazz : classes ) { found Resources . add All ( get Resources From Class Recursive ( clazz ) ) ; } return found Resources ; }
@ Override public void reset References ( ) { refs . clear ( ) ; }
public Core Attributes Model Impl ( Http Servlet Request req , String service Name , Map map ) throws AM Console Exception { super ( req , service Name , map ) ; current Realm = ( String ) map . get ( AM Admin Constants . CURRENT REALM ) ; if ( current Realm == null ) { debug . warning ( STRING ) ; current Realm = STRING ; } }
protected Date Time Data parse ( String str ) throws Schema Date Time Exception { Date Time Data date = new Date Time Data ( str , this ) ; int len = str . length ( ) ; date . year = YEAR ; if ( str . char At ( NUM ) != STRING || str . char At ( NUM ) != STRING ) { throw new Schema Date Time Exception ( STRING + str ) ; } date . month = parse Int ( str , NUM , NUM ) ; int start = NUM ; if ( str . char At ( start ++ ) != STRING ) { throw new Schema Date Time Exception ( STRING + str ) ; } date . day = parse Int ( str , start , start + NUM ) ; if ( MONTHDAY SIZE < len ) { if ( ! is Next Char UTC Sign ( str , MONTHDAY SIZE , len ) ) { throw new Schema Date Time Exception ( STRING + str ) ; } else { get Time Zone ( str , date , MONTHDAY SIZE , len ) ; } } validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != NUM && date . utc != STRING ) { normalize ( date ) ; } date . position = NUM ; return date ; }
private boolean send Message ( ) { if ( msg Queue . is Empty ( ) == BOOL ) { return BOOL ; } if ( free To Send == BOOL ) { Serial Message msg = msg Queue . peek ( ) ; if ( msg != null ) { free To Send = BOOL ; logger . debug ( STRING , node . get Node Id ( ) , msg Queue . size ( ) ) ; if ( msg . get Message Class ( ) == Serial Message Class . Send Data ) { controller . send Data ( msg ) ; } else { controller . enqueue ( msg ) ; } } } return BOOL ; }
private Array Modifiable DBI Ds merge I Ds ( List < ? extends Double DBID List > query Results , DBI Ds ... ids ) { Modifiable DBI Ds result = DBID Util . new Hash Set ( ) ; for ( DBI Ds dbids : ids ) { result . add DBI Ds ( dbids ) ; } for ( Double DBID List query Result : query Results ) { result . add DBI Ds ( query Result ) ; } return DBID Util . new Array ( result ) ; }
@ Override public final void write Int ( int v ) throws IO Exception { work [ NUM ] = ( byte ) v ; work [ NUM ] = ( byte ) ( v > > NUM ) ; work [ NUM ] = ( byte ) ( v > > NUM ) ; work [ NUM ] = ( byte ) ( v > > NUM ) ; dis . write ( work , NUM , NUM ) ; }
final public void println ( int v ) { Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( newline , NUM , newline . length ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
@ Override public Service Builder Amp service ( Key < ? > key , Class < ? > api ) { Objects . require Non Null ( api ) ; return new Service Builder Impl ( this , api , key ) ; }
public Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= NUM || h <= NUM ) { throw new Raster Format Exception ( STRING + ( ( w <= NUM ) ? STRING : STRING ) ) ; } Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new Byte Component Raster ( sm , new Point ( NUM , NUM ) ) ; }
public void delete Auth Configuration ( String realm , Set names ) throws AM Console Exception { String Builder error List = new String Builder ( ) ; String message = null ; for ( Iterator i = names . iterator ( ) ; i . has Next ( ) ; ) { String config = ( String ) i . next ( ) ; message = null ; try { AM Auth Config Utils . remove Named Config ( config , realm , get User SSO Token ( ) ) ; } catch ( AM Configuration Exception e ) { debug . warning ( STRING , e ) ; message = e . get Message ( ) ; error List . append ( config ) ; } catch ( SMS Exception e ) { debug . warning ( STRING , e ) ; message = e . get Message ( ) ; error List . append ( config ) ; } catch ( SSO Exception e ) { debug . warning ( STRING , e ) ; message = e . get Message ( ) ; error List . append ( config ) ; } if ( message != null ) { if ( error List . length ( ) > NUM ) { error List . append ( STRING ) ; } } } if ( error List . length ( ) > NUM ) { String [ ] tmp = { error List . to String ( ) , message } ; throw new AM Console Exception ( Message Format . format ( get Localized String ( STRING ) , ( Object [ ] ) tmp ) ) ; } }
private void process Tracker State Change ( Tracker tracker , O Block block , int state ) { List < O Block > old Range = tracker . get Range ( ) ; switch ( tracker . move ( block , state ) ) { case Tracker . NO BLOCK : adjust Block Listeners ( old Range , tracker . get Range ( ) , tracker ) ; String msg = Bundle . get Message ( STRING , tracker . get Train Name ( ) , block . get Display Name ( ) ) + STRING + Bundle . get Message ( STRING ) ; J Option Pane . show Message Dialog ( this , msg , Bundle . get Message ( STRING ) , J Option Pane . WARNING MESSAGE ) ; stop Train ( tracker ) ; set Status ( msg ) ; break ; case Tracker . ENTER BLOCK : block . entry Time = System . current Time Millis ( ) ; adjust Block Listeners ( old Range , tracker . get Range ( ) , tracker ) ; set Status ( Bundle . get Message ( STRING , tracker . get Train Name ( ) , block . get Display Name ( ) ) ) ; break ; case Tracker . LEAVE BLOCK : adjust Block Listeners ( old Range , tracker . get Range ( ) , tracker ) ; long et = ( System . current Time Millis ( ) - block . entry Time ) / NUM ; set Status ( Bundle . get Message ( STRING , tracker . get Train Name ( ) , block . get Display Name ( ) , et / NUM , et % NUM ) ) ; break ; case Tracker . ERROR BLOCK : break ; } }
public Lazy Value < Form > create Back Lazy Value ( final Form f ) { Vector form Navigation Stack = base Form Navigation Stack ; Hashtable p = null ; Command cmd = null ; if ( form Navigation Stack . size ( ) > NUM ) { p = ( Hashtable ) form Navigation Stack . element At ( form Navigation Stack . size ( ) - NUM ) ; String back Title = get Back Command Text ( ( String ) p . get ( FORM STATE KEY TITLE ) ) ; String command Action = ( String ) p . get ( FORM STATE KEY NAME ) ; cmd = create Command Impl ( back Title , null , BACK COMMAND ID , command Action , BOOL , STRING ) ; cmd . put Client Property ( COMMAND ARGUMENTS , STRING ) ; cmd . put Client Property ( COMMAND ACTION , command Action ) ; } return new Lazy Value C ( f , p , cmd , this ) ; }
public boolean load Properties ( Properties props , URL url ) { try { Input Stream props In = url . open Stream ( ) ; props . load ( props In ) ; return BOOL ; } catch ( java . io . IO Exception e ) { Debug . error ( STRING + url ) ; return BOOL ; } }
public Builder put ( Properties properties ) { for ( Map . Entry entry : properties . entry Set ( ) ) { map . put ( ( String ) entry . get Key ( ) , ( String ) entry . get Value ( ) ) ; } return this ; }
protected void process Selectors ( List < Node > results , List < Css Selector > selectors ) { List < Node > selected Nodes = select ( root Node , selectors ) ; for ( Node selected Node : selected Nodes ) { if ( ! results . contains ( selected Node ) ) { results . add ( selected Node ) ; } } }
public static int int From Properties ( Properties p , String prop Name , int default Value ) { int ret = default Value ; String int String = p . get Property ( prop Name ) ; if ( int String != null ) { try { ret = Integer . parse Int ( int String . trim ( ) ) ; } catch ( Number Format Exception e ) { ret = default Value ; } } return ret ; }

private static Locale strip ( Locale locale ) { String language = locale . get Language ( ) ; String country = locale . get Country ( ) ; String variant = locale . get Variant ( ) ; if ( ! variant . is Empty ( ) ) { variant = STRING ; } else if ( ! country . is Empty ( ) ) { country = STRING ; } else if ( ! language . is Empty ( ) ) { language = STRING ; } else { return null ; } return new Locale ( language , country , variant ) ; }
static List < Map < String , Object > > query ( Result Set rs ) throws SQL Exception { List < Map < String , Object > > list = new Array List < Map < String , Object > > ( ) ; Result Set Meta Data meta = rs . get Meta Data ( ) ; int column Count = meta . get Column Count ( ) ; while ( rs . next ( ) ) { Hash Map < String , Object > map = new Hash Map < String , Object > ( ) ; for ( int i = NUM ; i < column Count ; i ++ ) { map . put ( meta . get Column Label ( i + NUM ) , rs . get Object ( i + NUM ) ) ; } list . add ( map ) ; } return list ; }
public boolean equals ( Object obj ) { if ( obj instanceof M Assignment Slot ) { M Assignment Slot cmp = ( M Assignment Slot ) obj ; if ( m start Time . equals ( cmp . get Start Time ( ) ) && m end Time . equals ( cmp . get End Time ( ) ) && m status == cmp . get Status ( ) && m name . equals ( cmp . get Name ( ) ) && m description . equals ( cmp . get Description ( ) ) ) return BOOL ; } return BOOL ; }
private static void write Setting ( final C Connection connection , final int container Id , final String key , final String value , final String table ) throws Couldnt Save Data Exception { String id column = STRING ; if ( table . equals Ignore Case ( C Table Names . MODULE SETTINGS TABLE ) ) { id column = STRING ; } else { id column = STRING ; } final String delete Query = STRING + table + STRING + id column + STRING + container Id + STRING + key + STRING ; final String insert Query = STRING + table + STRING + container Id + STRING + key + STRING + value + STRING ; try { Postgre SQL Helpers . begin Transaction ( connection ) ; connection . execute Update ( delete Query , BOOL ) ; connection . execute Update ( insert Query , BOOL ) ; Postgre SQL Helpers . end Transaction ( connection ) ; } catch ( final SQL Exception exception ) { throw new Couldnt Save Data Exception ( STRING + table ) ; } }
public C Process List Panel ( final Process List process List ) { super ( new Border Layout ( ) ) ; m process List = process List ; final C Process List Model model = new C Process List Model ( process List ) ; m sorter = new Table Row Sorter < C Process List Model > ( model ) ; m table = new J Table ( model ) ; m table . set Selection Mode ( List Selection Model . SINGLE SELECTION ) ; m table . set Row Sorter ( m sorter ) ; final J Scroll Pane scroll Pane = new J Scroll Pane ( m table ) ; scroll Pane . set Border ( new Titled Border ( STRING ) ) ; add ( scroll Pane ) ; set Preferred Size ( new Dimension ( NUM , NUM ) ) ; }
public boolean is Super User ( String uuid ) { boolean is Super User = BOOL ; try { AM Identity admin User Id = null ; String admin User = System Properties . get ( Constants . AUTHENTICATION SUPER USER ) ; if ( admin User != null ) { admin User Id = new AM Identity ( dsame Admin Token Provider . get Admin Token ( ) , admin User , Id Type . USER , STRING , null ) ; } AM Identity user = Id Utils . get Identity ( dsame Admin Token Provider . get Admin Token ( ) , uuid ) ; is Super User = admin User Id . equals ( user ) ; } catch ( SSO Exception ssoe ) { session Debug . error ( STRING ) ; } catch ( Id Repo Exception idme ) { session Debug . error ( STRING ) ; } if ( session Debug . message Enabled ( ) ) { session Debug . message ( STRING + is Super User ) ; } return is Super User ; }
protected static String normalize Url Ending ( String link ) { if ( link . index Of ( STRING ) > - NUM ) link = link . substring ( NUM , link . index Of ( STRING ) ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; return link ; }
private void add Manifest Package ( String name , Attributes attr ) { if ( ! name . ends With ( STRING ) && ! name . equals ( STRING ) ) return ; String spec Title = attr . get Value ( STRING ) ; String spec Version = attr . get Value ( STRING ) ; String spec Vendor = attr . get Value ( STRING ) ; String impl Title = attr . get Value ( STRING ) ; String impl Version = attr . get Value ( STRING ) ; String impl Vendor = attr . get Value ( STRING ) ; if ( spec Title == null && spec Version == null && spec Vendor != null && impl Title == null && impl Version == null && impl Vendor != null ) return ; Class Package pkg = new Class Package ( name ) ; pkg . set Specification Title ( spec Title ) ; pkg . set Specification Version ( spec Version ) ; pkg . set Specification Vendor ( spec Vendor ) ; pkg . set Implementation Title ( impl Title ) ; pkg . set Implementation Version ( impl Version ) ; pkg . set Implementation Vendor ( impl Vendor ) ; packages . add ( pkg ) ; }
public Reference Binding find Super Type Originating From ( int well Known Original ID , boolean original Is Class ) { if ( ! ( this instanceof Reference Binding ) ) return null ; Reference Binding reference = ( Reference Binding ) this ; if ( reference . id == well Known Original ID || ( original ( ) . id == well Known Original ID ) ) return reference ; Reference Binding current Type = reference ; if ( original Is Class ) { while ( ( current Type = current Type . superclass ( ) ) != null ) { if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ; } return null ; } Reference Binding [ ] interfaces To Visit = null ; int next Position = NUM ; do { Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces != Binding . NO SUPERINTERFACES ) { if ( interfaces To Visit == null ) { interfaces To Visit = its Interfaces ; next Position = interfaces To Visit . length ; } else { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length ) System . arraycopy ( interfaces To Visit , NUM , interfaces To Visit = new Reference Binding [ next Position + its Length + NUM ] , NUM , next Position ) ; next Interface : for ( int a = NUM ; a < its Length ; a ++ ) { Reference Binding next = its Interfaces [ a ] ; for ( int b = NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } } while ( ( current Type = current Type . superclass ( ) ) != null ) ; for ( int i = NUM ; i < next Position ; i ++ ) { current Type = interfaces To Visit [ i ] ; if ( current Type . id == well Known Original ID ) return current Type ; if ( current Type . original ( ) . id == well Known Original ID ) return current Type ; Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces != Binding . NO SUPERINTERFACES ) { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length ) System . arraycopy ( interfaces To Visit , NUM , interfaces To Visit = new Reference Binding [ next Position + its Length + NUM ] , NUM , next Position ) ; next Interface : for ( int a = NUM ; a < its Length ; a ++ ) { Reference Binding next = its Interfaces [ a ] ; for ( int b = NUM ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } return null ; }
public void add Column ( Column previous Column , Column column ) { if ( column != null ) { if ( previous Column == null ) { columns . add ( NUM , column ) ; } else { columns . add ( columns . index Of ( previous Column ) , column ) ; } } }
public void update Contents ( ) { clear ( ) ; String display Category = get Display Category ( ) ; Display [ ] displays = m Display Manager . get Displays ( display Category ) ; add All ( displays ) ; Log . d ( TAG , STRING + displays . length + STRING ) ; for ( Display display : displays ) { Log . d ( TAG , STRING + display ) ; } }
static public float angle Between ( P Vector v1 , P Vector v2 ) { if ( v1 . x == NUM && v1 . y == NUM ) return NUM ; if ( v2 . x == NUM && v2 . y == NUM ) return NUM ; double dot = v1 . x * v2 . x + v1 . y * v2 . y + v1 . z * v2 . z ; double v1 mag = Math . sqrt ( v1 . x * v1 . x + v1 . y * v1 . y + v1 . z * v1 . z ) ; double v2 mag = Math . sqrt ( v2 . x * v2 . x + v2 . y * v2 . y + v2 . z * v2 . z ) ; double amt = dot / ( v1 mag * v2 mag ) ; if ( amt <= - NUM ) { return P Constants . PI ; } else if ( amt >= NUM ) { return NUM ; } return ( float ) Math . acos ( amt ) ; }
public void remove Listener ( final I Running Query Listener l ) { if ( l == null ) throw new Illegal Argument Exception ( ) ; listeners . remove ( l ) ; }
public void process Invite ( Request Event request Event , Server Transaction server Transaction ) { Sip Provider sip Provider = ( Sip Provider ) request Event . get Source ( ) ; Request request = request Event . get Request ( ) ; this . saw Invite = BOOL ; try { Response ok Response = message Factory . create Response ( Response . OK , request ) ; Address address = address Factory . create Address ( STRING + my Address + STRING + my Port + STRING ) ; Contact Header contact Header = header Factory . create Contact Header ( address ) ; To Header to Header = ( To Header ) ok Response . get Header ( To Header . NAME ) ; to Header . set Tag ( STRING ) ; ok Response . add Header ( contact Header ) ; sip Provider . send Response ( ok Response ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; System . exit ( NUM ) ; } }
@ Nullable public Grid Cache Mvcc Candidate add Entry ( Grid Dht Cache Entry entry ) throws Grid Cache Entry Removed Exception , Grid Distributed Lock Cancelled Exception { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + entry ) ; if ( entry == null ) return null ; if ( timed Out ) return null ; Grid Cache Mvcc Candidate c = entry . add Dht Local ( near Node Id , near Lock Ver , top Ver , thread Id , lock Ver , null , null , timeout , BOOL , in Tx ( ) , implicit Single ( ) ) ; if ( c == null && timeout < NUM ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + entry ) ; on Failed ( BOOL ) ; return null ; } synchronized ( sync ) { entries . add ( c == null || c . reentry ( ) ? null : entry ) ; if ( c != null && ! c . reentry ( ) ) pending Locks . add ( entry . key ( ) ) ; } if ( timed Out ) { entry . remove Lock ( lock Ver ) ; return null ; } return c ; }
@ Override public Axis Space reserve Space ( Graphics 2 D g2 , Plot plot , Rectangle 2 D plot Area , Rectangle Edge edge , Axis Space space ) { if ( space == null ) { space = new Axis Space ( ) ; } if ( ! is Visible ( ) ) { return space ; } double tick Label Height = NUM ; double tick Label Width = NUM ; if ( is Tick Labels Visible ( ) ) { g2 . set Font ( get Tick Label Font ( ) ) ; Axis State state = new Axis State ( ) ; refresh Ticks ( g2 , state , plot Area , edge ) ; if ( edge == Rectangle Edge . TOP ) { tick Label Height = state . get Max ( ) ; } else if ( edge == Rectangle Edge . BOTTOM ) { tick Label Height = state . get Max ( ) ; } else if ( edge == Rectangle Edge . LEFT ) { tick Label Width = state . get Max ( ) ; } else if ( edge == Rectangle Edge . RIGHT ) { tick Label Width = state . get Max ( ) ; } } Rectangle 2 D label Enclosure = get Label Enclosure ( g2 , edge ) ; double label Height , label Width ; if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { label Height = label Enclosure . get Height ( ) ; space . add ( label Height + tick Label Height + this . category Label Position Offset , edge ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { label Width = label Enclosure . get Width ( ) ; space . add ( label Width + tick Label Width + this . category Label Position Offset , edge ) ; } return space ; }
protected void assert Same Join Order ( final int [ ] expected , final Test Helper helper ) throws Exception { assert Same Join Order ( Collections . singleton List ( expected ) , helper ) ; }
private boolean delete File ( String filepath ) { try { if ( filepath != null ) { File file = new File ( filepath ) ; if ( file . exists ( ) ) { if ( file . delete ( ) ) { logger . debug ( STRING + file . get Path ( ) ) ; return BOOL ; } else { logger . warn ( STRING + file . get Path ( ) ) ; } } else { logger . warn ( STRING + file . get Path ( ) ) ; return BOOL ; } } } catch ( Exception e ) { logger . error ( e ) ; } return BOOL ; }
public void delete Group Member ( Gitlab Group group , Gitlab User user ) throws IO Exception { delete Group Member ( group . get Id ( ) , user . get Id ( ) ) ; }
private synchronized void init Resource Bundle ( String resource Bundle Name ) { String current = this . resource Bundle Name ; if ( current != null ) { if ( current . equals ( resource Bundle Name ) ) { return ; } else { throw new Illegal Argument Exception ( STRING + resource Bundle Name + STRING + current + STRING ) ; } } if ( resource Bundle Name != null ) { this . resource Bundle = load Resource Bundle ( resource Bundle Name ) ; this . resource Bundle Name = resource Bundle Name ; } }
@ Override public void increment ( double coord , double val ) { int bin = get Bin Nr ( coord ) ; if ( bin < NUM ) { if ( size - bin > data . length ) { double [ ] tmpdata = new double [ grow Size ( data . length , size - bin ) ] ; System . arraycopy ( data , NUM , tmpdata , - bin , size ) ; data = tmpdata ; } else { System . arraycopy ( data , NUM , data , - bin , size ) ; Arrays . fill ( data , NUM , - bin , ( double ) NUM ) ; } data [ NUM ] = val ; assert ( data . length >= size - bin ) ; offset -= bin ; size -= bin ; } else if ( bin >= data . length ) { double [ ] tmpdata = new double [ grow Size ( data . length , bin + NUM ) ] ; System . arraycopy ( data , NUM , tmpdata , NUM , size ) ; tmpdata [ bin ] = val ; data = tmpdata ; size = bin + NUM ; max = Double . MAX VALUE ; } else { if ( bin >= size ) { size = bin + NUM ; } data [ bin ] += val ; } }
private static void verify Markdown Contains Fields In Tables ( File doc , Map < String , Set < String > > fields By Table ) throws IO Exception { final List < String > lines = Files . read All Lines ( doc . to Path ( ) , Charset . default Charset ( ) ) ; final Map < String , Set < String > > fields Left By Table = Maps . new Hash Map ( ) ; for ( Map . Entry < String , Set < String > > entry : fields By Table . entry Set ( ) ) { fields Left By Table . put ( entry . get Key ( ) , Sets . new Hash Set ( entry . get Value ( ) ) ) ; } String in Table = null ; for ( String line : lines ) { if ( fields Left By Table . is Empty ( ) ) { return ; } final String current Header = get Table Header ( line ) ; if ( in Table == null || current Header != null ) { in Table = current Header ; } if ( in Table != null && fields Left By Table . contains Key ( in Table ) ) { String [ ] parts = line . split ( STRING ) ; if ( parts . length > NUM ) { final String field Name = parts [ NUM ] ; final Set < String > fields Left = fields Left By Table . get ( in Table ) ; Iterator < String > field It = fields Left . iterator ( ) ; while ( field It . has Next ( ) ) { String field Left = field It . next ( ) ; if ( field Name . contains ( field Left ) ) field It . remove ( ) ; } if ( fields Left . is Empty ( ) ) { fields Left By Table . remove ( in Table ) ; } } } } if ( ! fields Left By Table . is Empty ( ) ) { fail ( String . format ( STRING , doc , fields Left By Table ) ) ; } }
public static double mad ( final double [ ] data ) { double mad = NUM ; if ( data . length > NUM ) { double median = median ( data ) ; double [ ] deviation Sum = new double [ data . length ] ; for ( int i = NUM ; i < data . length ; i ++ ) { deviation Sum [ i ] = Math . abs ( median - data [ i ] ) ; } mad = median ( deviation Sum ) ; } return mad ; }
private static < T > Load Result < T > validate Loaded Plugins ( final Load Result < T > result ) { final Hash Set < Long > guids = new Hash Set < > ( ) ; final Array List < Pair < com . google . security . zynamics . binnavi . api 2 . plugins . I Plugin < T > , Plugin Status > > validated Plugins = new Array List < > ( ) ; for ( final Pair < com . google . security . zynamics . binnavi . api 2 . plugins . I Plugin < T > , Plugin Status > plugin Pair : result . get Loaded Plugins ( ) ) { final com . google . security . zynamics . binnavi . api 2 . plugins . I Plugin < T > plugin = plugin Pair . first ( ) ; final String name = plugin . get Name ( ) ; final long guid = plugin . get Guid ( ) ; if ( ( name == null ) && ( guid == NUM ) ) { validated Plugins . add ( new Pair < com . google . security . zynamics . binnavi . api 2 . plugins . I Plugin < T > , Plugin Status > ( plugin , Plugin Status . Invalid Name Guid ) ) ; } else if ( name == null ) { validated Plugins . add ( new Pair < com . google . security . zynamics . binnavi . api 2 . plugins . I Plugin < T > , Plugin Status > ( plugin , Plugin Status . Invalid Name ) ) ; } else if ( guid == NUM ) { validated Plugins . add ( new Pair < com . google . security . zynamics . binnavi . api 2 . plugins . I Plugin < T > , Plugin Status > ( plugin , Plugin Status . Invalid Guid ) ) ; } else if ( guids . contains ( guid ) ) { validated Plugins . add ( new Pair < com . google . security . zynamics . binnavi . api 2 . plugins . I Plugin < T > , Plugin Status > ( plugin , Plugin Status . Duplicate Guid ) ) ; } else { validated Plugins . add ( new Pair < com . google . security . zynamics . binnavi . api 2 . plugins . I Plugin < T > , Plugin Status > ( plugin , Plugin Status . Valid ) ) ; } guids . add ( guid ) ; } return new Load Result < T > ( validated Plugins , result . get Failed Plugins ( ) ) ; }
public synchronized void stop ( ) { m Run = BOOL ; if ( m Process != null ) { m Process . destroy ( ) ; m Process = null ; } try { m Thread . join ( ) ; } catch ( Interrupted Exception e ) { } m Thread = null ; m Callback = null ; }
public static Graph Request new Upload Video Request ( Access Token access Token , File file , Callback callback ) throws File Not Found Exception { Parcel File Descriptor descriptor = Parcel File Descriptor . open ( file , Parcel File Descriptor . MODE READ ONLY ) ; Bundle parameters = new Bundle ( NUM ) ; parameters . put Parcelable ( file . get Name ( ) , descriptor ) ; return new Graph Request ( access Token , MY VIDEOS , parameters , Http Method . POST , callback ) ; }
public Requestor ( String [ ] groups , int port , boolean delay Flag ) throws IO Exception { super ( STRING ) ; set Daemon ( BOOL ) ; sock = new Multicast Socket ( Constants . get Discovery Port ( ) ) ; sock . set Time To Live ( multicast Request Constraints . get Multicast Time To Live ( Constants . get Ttl ( ) ) ) ; response Port = port ; this . groups = groups == null ? new String [ NUM ] : groups ; this . delay Flag = delay Flag ; }
private double calculate Node Times ( Tree Model tree , Node Ref node ) { Node Ref parent = tree . get Parent ( node ) ; double time 0 = NUM ; if ( ! tree . is External ( node ) ) { Node Ref child 1 = tree . get Child ( node , NUM ) ; double t1 = calculate Node Times ( tree , child 1 ) ; Node Ref child 2 = tree . get Child ( node , NUM ) ; double t2 = calculate Node Times ( tree , child 2 ) ; time 0 = ( t1 + t2 ) / NUM ; } if ( parent == null ) return NUM ; double branch Time = tree . get Node Height ( parent ) - tree . get Node Height ( node ) ; double time 1 = time 0 + branch Time ; node Times [ node . get Number ( ) ] = time 0 ; return time 1 ; }
protected Example Set Meta Data modify Inner Output Example Set ( Example Set Meta Data meta Data ) { return meta Data ; }
public < T , E extends T > void copy Properties Of Inherited Class ( final T src , final E dest ) { if ( src == null ) throw new Illegal Argument Exception ( STRING ) ; if ( dest == null ) throw new Illegal Argument Exception ( STRING ) ; final Class < ? extends Object > src Clz = src . get Class ( ) ; final Class < ? extends Object > dest Clz = dest . get Class ( ) ; if ( src Clz . is Array ( ) ) { if ( ! dest Clz . is Array ( ) ) throw new Illegal Argument Exception ( STRING + dest Clz ) ; final int length = Array . get Length ( src ) ; for ( int i = NUM ; i < length ; i ++ ) { final Object v = Array . get ( src , i ) ; Array . set ( dest , i , v ) ; } return ; } final List < Field > fields = all Fields ( src Clz ) ; final List < Field > dest Fields = all Fields ( dest . get Class ( ) ) ; for ( final Field field : fields ) { if ( ! Modifier . is Static ( field . get Modifiers ( ) ) ) { try { final Object field Object = field . get ( src ) ; field . set Accessible ( BOOL ) ; if ( dest Fields . contains ( field ) ) { field . set ( dest , field Object ) ; } } catch ( final Illegal Argument Exception e ) { throw new Runtime Exception ( e ) ; } catch ( final Illegal Access Exception e ) { throw new Runtime Exception ( e ) ; } } } }
public Gossip Service ( String cluster , String ip Address , int port , String id , List < Gossip Member > gossip Members , Gossip Settings settings , Gossip Listener listener ) throws Interrupted Exception , Unknown Host Exception { gossip Manager = new Random Gossip Manager ( cluster , ip Address , port , id , settings , gossip Members , listener ) ; }
public boolean is Font Substituted ( ) { return is Font Substituted ; }
public void add To Be Ignored ( final String url String ) { if ( to Ignored == null ) { to Ignored = new Array List < String > ( ) ; } if ( String Utils . is Not Blank ( url String ) ) { final String normalized File Name = Resource Loader . get Normalized File Name ( url String ) ; to Ignored . add ( normalized File Name ) ; } }
public static String Builder make Where String From Fields ( String Builder sb , List < Model Field > model Fields , Map < String , Object > fields , String operator , List < Entity Condition Param > entity Condition Params ) { if ( model Fields . size ( ) < NUM ) { return sb ; } Iterator < Model Field > iter = model Fields . iterator ( ) ; while ( iter . has Next ( ) ) { Object item = iter . next ( ) ; Object name = null ; Model Field model Field = null ; if ( item instanceof Model Field ) { model Field = ( Model Field ) item ; sb . append ( model Field . get Col Value ( ) ) ; name = model Field . get Name ( ) ; } else { sb . append ( item ) ; name = item ; } Object field Value = fields . get ( name ) ; if ( field Value != null && field Value != Generic Entity . NULL FIELD ) { sb . append ( STRING ) ; add Value ( sb , model Field , field Value , entity Condition Params ) ; } else { sb . append ( STRING ) ; } if ( iter . has Next ( ) ) { sb . append ( STRING ) ; sb . append ( operator ) ; sb . append ( STRING ) ; } } return sb ; }
private Git Note Writer ( String review Hash , final Repository repo , String ref , Person Ident author ) { this . ref = ref ; this . repo = repo ; this . author = author ; rev Walk = new Rev Walk ( repo ) ; inserter = repo . new Object Inserter ( ) ; reader = repo . new Object Reader ( ) ; try { Object Id review Ref Obj Id = repo . resolve ( review Hash ) ; this . review Commit = rev Walk . parse Commit ( review Ref Obj Id ) ; } catch ( Exception e ) { logger . log ( Level . SEVERE , STRING + review Hash , e ) ; throw new Runtime Exception ( e ) ; } }
private void write Root Block ( final boolean is Root Block 0 , final I Root Block View root Block ) throws IO Exception { if ( root Block == null ) throw new Illegal Argument Exception ( ) ; final long position = is Root Block 0 ? OFFSET ROOT BLOCK 0 : OFFSET ROOT BLOCK 1 ; File Channel Utility . write All ( reopener , root Block . as Read Only Buffer ( ) , position ) ; if ( ha Log . is Debug Enabled ( ) ) ha Log . debug ( STRING + root Block ) ; }
@ Request Mapping ( value = STRING , method = Request Method . POST ) public String add Or Remove Favourite ( Http Servlet Request request , String fqdn ) { table Entity Service . add Or Remove Favourite ( fqdn ) ; return STRING + request . get Header ( STRING ) ; }
public void test Of EEEEE ( ) { Enum Set < Enum With Inner Class > enum Set = Enum Set . of ( Enum With Inner Class . a , Enum With Inner Class . b , Enum With Inner Class . c , Enum With Inner Class . d , Enum With Inner Class . e ) ; assert Equals ( STRING , NUM , enum Set . size ( ) ) ; assert True ( STRING , enum Set . contains ( Enum With Inner Class . a ) ) ; assert True ( STRING , enum Set . contains ( Enum With Inner Class . e ) ) ; try { Enum Set . of ( ( Enum With Inner Class ) null , null , null , null , null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception npe ) { } Enum Set < Huge Enum With Inner Class > huge Enum Set = Enum Set . of ( Huge Enum With Inner Class . a , Huge Enum With Inner Class . b , Huge Enum With Inner Class . c , Huge Enum With Inner Class . d , Huge Enum With Inner Class . e ) ; assert Equals ( NUM , huge Enum Set . size ( ) ) ; assert True ( huge Enum Set . contains ( Huge Enum With Inner Class . a ) ) ; assert True ( huge Enum Set . contains ( Huge Enum With Inner Class . e ) ) ; try { Enum Set . of ( ( Huge Enum With Inner Class ) null , null , null , null , null ) ; fail ( STRING ) ; } catch ( Null Pointer Exception npe ) { } }
private boolean ensure Target Is Valid ( ) { String target Dir = get Target Directory ( ) ; if ( ! ensure Target Directory Is Valid ( target Dir ) ) { return BOOL ; } String file Name = get Target File Name ( ) ; if ( ! ensure Target File Is Valid ( new File ( target Dir , file Name ) ) ) { return BOOL ; } return BOOL ; }
public final boolean skip Any ( Char Set char Set , Char Sequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && char Set . contains ( csq . char At ( i ) ) ; i ++ ) { } if ( i == index ) return BOOL ; index = i ; return BOOL ; }
private void generate Gaussian Examples ( Instances format , int num Instances , Random random , Subspace Cluster Definition cl , String c Name ) { boolean make Integer = cl . is Integer ( ) ; Instance example = null ; int num Atts = m Num Attributes ; if ( get Class Flag ( ) ) { num Atts ++ ; } example = new Dense Instance ( num Atts ) ; example . set Dataset ( format ) ; boolean [ ] attributes = cl . get Attributes ( ) ; double [ ] mean Value = cl . get Mean Value ( ) ; double [ ] stddev Value = cl . get Stddev Value ( ) ; for ( int j = NUM ; j < num Instances ; j ++ ) { int num = - NUM ; for ( int i = NUM ; i < m Num Attributes ; i ++ ) { if ( attributes [ i ] ) { num ++ ; double value = mean Value [ num ] + ( random . next Gaussian ( ) * stddev Value [ num ] ) ; if ( make Integer ) { value = Math . round ( value ) ; } example . set Value ( i , value ) ; } else { example . set Missing ( i ) ; } } if ( get Class Flag ( ) ) { example . set Class Value ( c Name ) ; } format . add ( example ) ; } }
public synchronized boolean retain All ( Collection c ) { Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( len != NUM ) { int newlen = NUM ; Object [ ] temp = new Object [ len ] ; for ( int i = NUM ; i < len ; ++ i ) { Object element = elements [ i ] ; if ( c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { set Array ( copy Of Range ( temp , NUM , newlen , Object [ ] . class ) ) ; return BOOL ; } } return BOOL ; }
public Info create Info ( String value ) { Information Field info Impl = new Information Field ( ) ; try { info Impl . set Value ( value ) ; } catch ( Sdp Exception s ) { s . print Stack Trace ( ) ; } return info Impl ; }
private String convert Line Separators ( String string ) { return string . replace All ( System . line Separator ( ) , STRING ) ; }
private void reload Cache With New Value ( final Long new Value ) { final long new Value As Primitive = new Value == null ? get Cache Update Period ( ) : new Value ; LOG . debug ( STRING , cache Update Period Listeners . size ( ) ) ; for ( final Property Change Listener listener : cache Update Period Listeners ) { final Property Change Event event = new Property Change Event ( this , STRING , get Cache Update Period ( ) , new Value As Primitive ) ; listener . property Change ( event ) ; } }
public static void write Chars To Writer ( char [ ] chars , Writer writer ) throws IO Exception { Buffered Writer bw = new Buffered Writer ( writer ) ; try { bw . write ( chars ) ; } finally { bw . close ( ) ; } }
public final void dec Ref ( ) throws IO Exception { if ( ref Count . get ( ) <= NUM ) { throw new Already Closed Exception ( STRING ) ; } final int rc = ref Count . decrement And Get ( ) ; if ( rc == NUM ) { closed = BOOL ; Throwable throwable = null ; try { do Close ( ) ; } catch ( Throwable th ) { throwable = th ; } finally { try { report Close To Parent Readers ( ) ; } finally { notify Reader Closed Listeners ( throwable ) ; } } } else if ( rc < NUM ) { throw new Illegal State Exception ( STRING + rc + STRING ) ; } }
public static boolean is Self Issued ( X509 Certificate cert ) { X500 Principal subject = cert . get Subject X 500 Principal ( ) ; X500 Principal issuer = cert . get Issuer X 500 Principal ( ) ; return subject . equals ( issuer ) ; }
@ Override public Bigdata Statement next ( ) throws Query Evaluation Exception { final Bigdata Statement stmt = src . next ( ) ; { final Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
public Compiere Color ( String type ) { if ( type == null ) throw new java . lang . Illegal Argument Exception ( EXCEPTION TEXT ) ; if ( type . equals ( TYPE FLAT ) || type . equals ( TYPE GRADIENT ) || type . equals ( TYPE TEXTURE ) || type . equals ( TYPE LINES ) ) { m type = type ; } else throw new java . lang . Illegal Argument Exception ( STRING ) ; }
public void change Lock Code ( String code , String data ) { Component Name demo Device Admin = new Component Name ( context , Agent Device Admin Receiver . class ) ; device Policy Manager . set Password Minimum Length ( demo Device Admin , DEFAULT PASSWORD MIN LENGTH ) ; String password = null ; try { JSON Object lock Data = new JSON Object ( data ) ; if ( ! lock Data . is Null ( resources . get String ( R . string . intent extra password ) ) ) { password = ( String ) lock Data . get ( resources . get String ( R . string . intent extra password ) ) ; } result Builder . build ( code ) ; if ( password != null && ! password . is Empty ( ) ) { device Policy Manager . reset Password ( password , Device Policy Manager . RESET PASSWORD REQUIRE ENTRY ) ; device Policy Manager . lock Now ( ) ; } } catch ( JSON Exception e ) { Log . e ( TAG , STRING + e ) ; } }
public List < Integer > postorder Traversal A ( Tree Node root ) { List < Integer > res = new Array List < Integer > ( ) ; if ( root == null ) return res ; Stack < Tree Node > s = new Stack < Tree Node > ( ) ; s . push ( root ) ; while ( ! s . is Empty ( ) ) { Tree Node cur Node = s . pop ( ) ; res . add ( cur Node . val ) ; if ( cur Node . left != null ) s . push ( cur Node . left ) ; if ( cur Node . right != null ) s . push ( cur Node . right ) ; } Collections . reverse ( res ) ; return res ; }
private static void exit ( @ Nullable String err Msg , boolean show Usage , int exit Code ) { if ( err Msg != null ) X . error ( err Msg ) ; String runner = System . get Property ( IGNITE PROG NAME , STRING ) ; int space = runner . index Of ( STRING ) ; runner = runner . substring ( NUM , space == - NUM ? runner . length ( ) : space ) ; if ( show Usage ) { boolean ignite = runner . contains ( STRING ) ; X . error ( STRING , STRING + runner + ( ignite ? STRING : STRING ) , STRING , STRING , STRING , STRING , STRING ) ; if ( ignite ) { X . error ( STRING , STRING , STRING , STRING , STRING , STRING , STRING ) ; } } System . exit ( exit Code ) ; }
@ Override public int compare To ( New Split Emitted Term term 2 ) { int result ; if ( ( result = term . compare To ( term 2 . get Term ( ) ) ) != NUM ) return result ; if ( ( result = splitno - term 2 . get Splitno ( ) ) != NUM ) return result ; return flushno - term 2 . get Flushno ( ) ; }
public Section ( Location location , Location location 2 ) { this . min X = Math . min ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . min Y = Math . min ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . min Z = Math . min ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . max X = Math . max ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . max Y = Math . max ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . max Z = Math . max ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . world = location . get World ( ) ; }
private void generate Inner Class Handles ( I Type type , I Binary Type type Info , Array List children Handles ) { I Binary Nested Type [ ] inner Types = type Info . get Member Types ( ) ; if ( inner Types != null ) { I Package Fragment pkg = ( I Package Fragment ) type . get Ancestor ( I Java Element . PACKAGE FRAGMENT ) ; for ( int i = NUM , type Count = inner Types . length ; i < type Count ; i ++ ) { I Binary Nested Type binary Type = inner Types [ i ] ; I Class File parent Class File = pkg . get Class File ( new String ( Class File . unqualified Name ( binary Type . get Name ( ) ) ) + SUFFIX STRING class ) ; I Type inner Type = new Binary Type ( ( Java Element ) parent Class File , ( ( Java Element ) parent Class File ) . manager , Class File . simple Name ( binary Type . get Name ( ) ) ) ; children Handles . add ( inner Type ) ; } } }
private void handle Channel ( String [ ] args , Buffered Reader reader ) throws IO Exception { Tuple < String , String > initial Payload = new Tuple < > ( args [ NUM ] , args [ NUM ] ) ; if ( args . length == NUM ) { request Channel Fail . add ( initial Payload ) ; } String line = reader . read Line ( ) ; List < String > commands = new Array List < > ( ) ; while ( ! line . equals ( STRING ) ) { commands . add ( line ) ; line = reader . read Line ( ) ; } request Channel Commands . put ( initial Payload , commands ) ; }
@ Bean public Spring Process Engine Configuration activiti Process Engine Configuration ( Async Executor activiti Async Executor ) { Spring Process Engine Configuration configuration = new Spring Process Engine Configuration ( ) ; configuration . set Data Source ( herd Data Source ) ; configuration . set Transaction Manager ( herd Transaction Manager ) ; configuration . set Database Schema Update ( get Activiti Db Schema Update Param Bean Name ( ) ) ; configuration . set Async Executor Activate ( BOOL ) ; configuration . set Async Executor Enabled ( BOOL ) ; configuration . set Async Executor ( activiti Async Executor ) ; configuration . set Beans ( new Hash Map < > ( ) ) ; configuration . set Delegate Interceptor ( herd Delegate Interceptor ) ; configuration . set Command Invoker ( herd Command Invoker ) ; init Scripting Engines ( configuration ) ; configuration . set Mail Server Default From ( configuration Helper . get Property ( Configuration Value . ACTIVITI DEFAULT MAIL FROM ) ) ; List < Process Engine Configurator > herd Configurators = new Array List < > ( ) ; herd Configurators . add ( herd Process Engine Configurator ) ; configuration . set Configurators ( herd Configurators ) ; return configuration ; }
static < T extends Multi Threaded Test . Test Thread > void run Test Threads ( List < T > threads ) { long start Time = System . nano Time ( ) + NUM ; for ( T thread : threads ) { if ( thread . start Time == NUM ) { thread . start Time = start Time ; } thread . start ( ) ; } for ( T thread : threads ) { try { thread . join ( ) ; } catch ( Interrupted Exception e ) { throw new Runtime Exception ( e ) ; } if ( thread . cause != null ) { throw new Runtime Exception ( thread . cause ) ; } } }
public void adapt ( ) { double [ ] zmin = new double [ number Of Objectives ] ; double [ ] zmax = new double [ number Of Objectives ] ; Arrays . fill ( zmin , Double . POSITIVE INFINITY ) ; Arrays . fill ( zmax , Double . NEGATIVE INFINITY ) ; for ( Solution solution : this ) { for ( int i = NUM ; i < number Of Objectives ; i ++ ) { zmin [ i ] = Math . min ( zmin [ i ] , solution . get Objective ( i ) ) ; zmax [ i ] = Math . max ( zmax [ i ] , solution . get Objective ( i ) ) ; } } weights . clear ( ) ; for ( double [ ] weight : original Weights ) { double [ ] new Weight = weight . clone ( ) ; for ( int i = NUM ; i < number Of Objectives ; i ++ ) { new Weight [ i ] *= Math . max ( NUM , zmax [ i ] - zmin [ i ] ) ; } weights . add ( Vector . normalize ( new Weight ) ) ; } min Angles = new double [ weights . size ( ) ] ; for ( int i = NUM ; i < weights . size ( ) ; i ++ ) { min Angles [ i ] = smallest Angle Between Weights ( i ) ; } }
public void add Column ( Column previous Column , Column column ) { if ( column != null ) { if ( previous Column == null ) { columns . add ( NUM , column ) ; } else { columns . add ( columns . index Of ( previous Column ) , column ) ; } } }
private String new Sentence ( Random r , int max Sentence Length ) { String Builder sb = new String Builder ( ) ; int num Elements = Test Util . next Int ( r , NUM , max Sentence Length ) ; for ( int i = NUM ; i < num Elements ; i ++ ) { if ( sb . length ( ) > NUM ) { sb . append ( STRING ) ; sb . append ( ( char ) Test Util . next Int ( r , STRING , STRING ) ) ; } else { sb . append ( ( char ) Test Util . next Int ( r , STRING , STRING ) ) ; } } sb . append ( STRING ) ; return sb . to String ( ) ; }
@ Target Api ( Build . VERSION CODES . JELLY BEAN ) private void dequeue Output Buffer ( Media Codec codec , Byte Buffer [ ] output Buffers , int index , Media Codec . Buffer Info info ) { if ( Build . VERSION . SDK INT >= Build . VERSION CODES . JELLY BEAN ) { Byte Buffer buffer = output Buffers [ index ] ; Log . i ( STRING + info . size + STRING + buffer . remaining ( ) ) ; if ( info . size <= buffer . remaining ( ) ) { final byte [ ] buffer Copied = new byte [ info . size ] ; buffer . get ( buffer Copied ) ; codec . release Output Buffer ( index , BOOL ) ; add Encoded ( buffer Copied ) ; if ( Log . DEBUG ) { Audio Utils . show Some Bytes ( STRING , buffer Copied ) ; } } else { Log . e ( STRING ) ; codec . release Output Buffer ( index , BOOL ) ; } } }
@ Override public void add Scanned Result ( Result scanned Result ) throws Query Execution Exception { synchronized ( this . lock Object ) { scanned Result List . add ( scanned Result ) ; if ( ( scanned Result List . size ( ) > max Number Of Scanned Result List ) ) { List < Result > local Result = scanned Result List ; scanned Result List = new Array List < Result > ( Carbon Common Constants . DEFAULT COLLECTION SIZE ) ; exec Service . submit ( new Merger Thread ( local Result ) ) ; } } }
@ Override public int hash Code ( ) { int hash Code = cached Hash Code ; if ( hash Code == NUM ) { hash Code = NUM ; hash Code = NUM * hash Code + Arrays . hash Code ( eras ) ; hash Code = NUM * hash Code + Arrays . hash Code ( months ) ; hash Code = NUM * hash Code + Arrays . hash Code ( short Months ) ; hash Code = NUM * hash Code + Arrays . hash Code ( weekdays ) ; hash Code = NUM * hash Code + Arrays . hash Code ( short Weekdays ) ; hash Code = NUM * hash Code + Arrays . hash Code ( ampms ) ; hash Code = NUM * hash Code + Arrays . deep Hash Code ( get Zone Strings Wrapper ( ) ) ; hash Code = NUM * hash Code + Objects . hash Code ( local Pattern Chars ) ; cached Hash Code = hash Code ; } return hash Code ; }
private boolean is Inter Org ( M Acct Schema as ) { M Acct Schema Element elementorg = as . get Acct Schema Element ( M Acct Schema Element . ELEMENTTYPE Organization ) ; if ( elementorg == null || ! elementorg . is Balanced ( ) ) { return BOOL ; } if ( m io Line != null && m o Line != null && m io Line . get AD Org ID ( ) != m o Line . get AD Org ID ( ) ) return BOOL ; return BOOL ; }
public Process Drawer ( final Process Renderer Model model , final boolean draw Highlight ) { if ( model == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . model = model ; this . draw Highlight = draw Highlight ; decorators = new Hash Map < > ( ) ; for ( Render Phase phase : Render Phase . draw Order ( ) ) { decorators . put ( phase , new Copy On Write Array List < Process Draw Decorator > ( ) ) ; } operator Decorators = new Copy On Write Array List < Operator Draw Decorator > ( ) ; }
public boolean has User Groups To Alert ( ) { return user Groups To Alert != null && ! user Groups To Alert . is Empty ( ) ; }
private static String replace Chars ( String str ) { String Buffer buf = new String Buffer ( str ) ; int length = buf . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char current Char = buf . char At ( i ) ; if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; buf . insert ( i + NUM , STRING ) ; length = length + NUM ; i = i + NUM ; } else if ( current Char == STRING ) { buf . set Char At ( i , STRING ) ; } } return buf . to String ( ) ; }
public static int put Short ( byte [ ] bytes , int offset , short val ) { if ( little Endian ) { val = Short . reverse Bytes ( val ) ; } the Unsafe . put Short ( bytes , offset + BYTE ARRAY BASE OFFSET , val ) ; return offset + Bytes . SIZEOF SHORT ; }
protected void draw Value Label ( Drawing Context context , Shape point , Row row , int point Index , int col ) { Comparable < ? > value = row . get ( col ) ; Format format = get Value Format ( ) ; if ( ( format == null ) && row . is Column Numeric ( col ) ) { format = Number Format . get Instance ( ) ; } String text = ( format != null ) ? format . format ( value ) : value . to String ( ) ; Color Mapper colors = get Value Color ( ) ; Paint paint = colors . get ( point Index ) ; Font font = get Value Font ( ) ; double font Size = font . get Size 2 D ( ) ; Location location = get Value Location ( ) ; double align X = get Value Alignment X ( ) ; double align Y = get Value Alignment Y ( ) ; double rotation = get Value Rotation ( ) ; double distance = get Value Distance ( ) ; if ( Math Utils . is Calculatable ( distance ) ) { distance *= font Size ; } else { distance = NUM ; } Label label = new Label ( text ) ; label . set Alignment X ( align X ) ; label . set Alignment Y ( align Y ) ; label . set Rotation ( rotation ) ; label . set Color ( paint ) ; label . set Font ( font ) ; Rectangle 2 D bounds Point = point . get Bounds 2 D ( ) ; Drawable Container label Container = new Drawable Container ( new Outer Edge Layout ( distance ) ) ; label Container . add ( label , location ) ; label Container . set Bounds ( bounds Point ) ; label Container . draw ( context ) ; }
public static String wrap In Tag ( String line , String tag , String css Class ) { String Builder tag Builder = new String Builder ( ) ; tag Builder . append ( STRING ) ; tag Builder . append ( tag ) ; if ( css Class != null ) { tag Builder . append ( STRING ) ; tag Builder . append ( css Class ) ; tag Builder . append ( STRING ) ; } tag Builder . append ( STRING ) ; String start Tag = tag Builder . to String ( ) ; tag Builder . delete ( NUM , tag Builder . length ( ) ) ; tag Builder . append ( STRING ) ; tag Builder . append ( tag ) ; tag Builder . append ( STRING ) ; String end Tag = tag Builder . to String ( ) ; return start Tag + line + end Tag ; }
@ Nullable private Ipc Shared Memory Server Endpoint reset Shmem Server ( ) throws Ignite Checked Exception { if ( bound Tcp Shmem Port >= NUM ) throw new Ignite Checked Exception ( STRING + bound Tcp Shmem Port ) ; if ( shmem Port == - NUM || U . is Windows ( ) ) return null ; Ignite Checked Exception last Ex = null ; for ( int port = shmem Port ; port < shmem Port + loc Port Range ; port ++ ) { try { Ipc Shared Memory Server Endpoint srv = new Ipc Shared Memory Server Endpoint ( log . get Logger ( Ipc Shared Memory Server Endpoint . class ) , loc Proc Desc . process Id ( ) , grid Name ) ; srv . set Port ( port ) ; srv . omit Out Of Resources Warning ( BOOL ) ; srv . start ( ) ; bound Tcp Shmem Port = port ; if ( log . is Info Enabled ( ) ) log . info ( STRING + bound Tcp Shmem Port + STRING + loc Host + STRING ) ; return srv ; } catch ( Ignite Checked Exception e ) { last Ex = e ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + port + STRING + loc Host + STRING ) ; } } throw new Ignite Checked Exception ( STRING + loc Port + STRING + loc Port Range + STRING + loc Host + STRING , last Ex ) ; }
private void convert Outer Join ( final String Builder target , final Char Sequence outer Join ) throws FBSQL Parse Exception { target . append ( outer Join ) ; }
private static final Set < File > encode ( String src ) { if ( src == null || src . length ( ) == NUM ) return new Hash Set < File > ( ) ; String Tokenizer tokenizer = new String Tokenizer ( src , STRING ) ; int size = tokenizer . count Tokens ( ) ; Set < File > set = new Hash Set < File > ( ) ; for ( int i = NUM ; i < size ; i ++ ) set . add ( new File ( tokenizer . next Token ( ) ) ) ; return set ; }
public E poll ( long timeout , Time Unit unit ) throws Interrupted Exception { long nanos = unit . to Nanos ( timeout ) ; final Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; try { for ( ; ; ) { E first = q . peek ( ) ; if ( first == null ) { if ( nanos <= NUM ) return null ; else nanos = available . await Nanos ( nanos ) ; } else { long delay = first . get Delay ( NANOSECONDS ) ; if ( delay <= NUM ) return q . poll ( ) ; if ( nanos <= NUM ) return null ; first = null ; if ( nanos < delay || leader != null ) nanos = available . await Nanos ( nanos ) ; else { Thread this Thread = Thread . current Thread ( ) ; leader = this Thread ; try { long time Left = available . await Nanos ( delay ) ; nanos -= delay - time Left ; } finally { if ( leader == this Thread ) leader = null ; } } } } } finally { if ( leader == null && q . peek ( ) != null ) available . signal ( ) ; lock . unlock ( ) ; } }
public Stream < Interaction Word > process ( List < Pattern Reference > patterns ) { final Set < Word > terms = gather Terms ( patterns ) ; monitor . info ( STRING , terms . size ( ) ) ; calculate Term Frequencies ( patterns , terms ) ; monitor . info ( STRING ) ; sort ( patterns ) ; monitor . info ( STRING ) ; final List < Clustered Patterns > clusters = cluster ( patterns ) ; monitor . info ( STRING , clusters . size ( ) ) ; filter Clusters ( clusters ) ; monitor . info ( STRING , clusters . size ( ) ) ; monitor . info ( STRING ) ; return extract Interaction Words ( clusters ) ; }
private int find Last Group Index ( int group Id ) { int i = NUM , size = m Items . size ( ) ; boolean traversing Group = BOOL ; while ( BOOL ) { if ( i < size ) { final Sublime Base Menu Item item = m Items . get ( i ) ; if ( item . get Group Id ( ) == group Id ) { traversing Group = BOOL ; } else if ( traversing Group ) { return i - NUM ; } i ++ ; } else { return traversing Group ? size - NUM : size ; } } }
public static void write Short Integer ( Output Stream the Os , int the Value ) throws IO Exception { the Os . write ( ( byte ) ( the Value | ( byte ) NUM ) ) ; }
public void add Header ( String name , String value ) { if ( custom Headers == null ) { custom Headers = new Hash Map < > ( NUM ) ; } List < String > header = custom Headers . get ( name ) ; if ( header == null ) { header = new Array List < > ( ) ; custom Headers . put ( name , header ) ; } header . add ( value ) ; }
public static void check Access And Aliases For Keystore ( String store Location , String store Password , boolean should Not Be Empty ) throws Configuration Exception { final String error Message = Message Format . format ( STRING , store Location ) ; try { List < String > aliases In Keystore = Security Helper . get Aliasesfor Keystore ( store Location , store Password ) ; if ( aliases In Keystore . is Empty ( ) && should Not Be Empty ) { throw new Configuration Exception ( Message Format . format ( STRING , store Location ) ) ; } } catch ( Key Store Exception e ) { throw new Configuration Exception ( Message Format . format ( error Message , e ) ) ; } catch ( No Such Algorithm Exception e ) { throw new Configuration Exception ( Message Format . format ( error Message , e ) ) ; } catch ( Certificate Exception e ) { throw new Configuration Exception ( Message Format . format ( error Message , e ) ) ; } catch ( IO Exception e ) { throw new Configuration Exception ( Message Format . format ( error Message , e ) ) ; } }
public Set Breakpoint Command ( final int packet Id , final Set < Relocated Address > addresses , final Breakpoint Type type ) { super ( get Command For Type ( type ) , packet Id ) ; Preconditions . check Not Null ( addresses , STRING ) ; Preconditions . check Not Null ( type , STRING ) ; add Argument ( new Debug Message Integer Argument ( addresses . size ( ) ) ) ; for ( final Relocated Address address : addresses ) { add Argument ( new Debug Message Address Argument ( address . get Address ( ) ) ) ; } }
public static void sort ( char [ ] a ) { do Sort ( a , NUM , a . length - NUM ) ; }
public void add Terms ( String query String , String field Name , float min Similarity , int prefix Length ) { int max Edits = ( int ) min Similarity ; if ( max Edits != min Similarity || max Edits < NUM || max Edits > Levenshtein Automata . MAXIMUM SUPPORTED DISTANCE ) { throw new Illegal Argument Exception ( STRING + Levenshtein Automata . MAXIMUM SUPPORTED DISTANCE + STRING + min Similarity ) ; } field Vals . add ( new Field Vals ( field Name , max Edits , prefix Length , query String ) ) ; }
public Optional < T > first ( ) { Iterator < T > iterator = iterator ( ) ; return iterator . has Next ( ) ? Optional . of ( iterator . next ( ) ) : Optional . < T > empty ( ) ; }
public static void sleep ( long millis ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } }
static boolean is Package Access ( final int modifiers ) { return ( modifiers & Member Utils . ACCESS TEST ) == NUM ; }
private int find Window Position ( String window ) { int loc = window Order . index Of ( window ) ; if ( loc != - NUM ) { int i = NUM ; for ( Component c : panel . get Components ( ) ) { if ( c instanceof Managed Window ) { String name = c . get Name ( ) ; if ( loc < window Order . index Of ( name ) ) { return i ; } } i ++ ; } } else { window Order . add ( window ) ; fire Window Order Changed ( ) ; } return panel . get Component Count ( ) ; }
public Create Bucket Result create Redundant Bucket ( int bucket Id , boolean is Rebalance , Internal Distributed Member move Source ) { return grab Bucket ( bucket Id , move Source , BOOL , BOOL , is Rebalance , null , BOOL ) ; }
private String preprocess SLD ( Styled Layer Descriptor sld ) { if ( sld == null ) { return null ; } SLD Writer Interface sld Writer = SLD Writer Factory . create Writer ( null ) ; Duplicating Style Visitor duplicator = new Duplicating Style Visitor ( ) ; sld . accept ( duplicator ) ; Styled Layer Descriptor sld Copy = ( Styled Layer Descriptor ) duplicator . get Copy ( ) ; for ( Styled Layer styled Layer : sld Copy . layers ( ) ) { if ( styled Layer instanceof User Layer ) { User Layer Impl user Layer = ( User Layer Impl ) styled Layer ; user Layer . set Inline Feature Datastore ( null ) ; user Layer . set Inline Feature Type ( null ) ; } } String sld Contents = sld Writer . encode SLD ( null , sld Copy ) ; return sld Contents ; }
Map < String , Type Name > convert Properties To Types ( Map < String , Executable Element > properties ) { Map < String , Type Name > types = new Linked Hash Map < String , Type Name > ( ) ; for ( Map . Entry < String , Executable Element > entry : properties . entry Set ( ) ) { Executable Element el = entry . get Value ( ) ; types . put ( entry . get Key ( ) , Type Name . get ( el . get Return Type ( ) ) ) ; } return types ; }
public static void change Font ( J Component comp , double scale Factor , int style ) { Font font = comp . get Font ( ) ; font = scale ( font , scale Factor ) ; comp . set Font ( font . derive Font ( style ) ) ; }
public static Image Icon create Icon From Color ( final Color color , final Color border Color , final int width , final int height , final Shape shape ) { Buffered Image img = new Buffered Image ( width , height , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g2 = img . create Graphics ( ) ; g2 . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g2 . set Color ( color ) ; g2 . fill ( shape ) ; g2 . set Color ( border Color ) ; g2 . draw ( shape ) ; g2 . dispose ( ) ; return new Image Icon ( img ) ; }
private void save Trusted Host ( String fingerprint ) throws IO Exception { this . fingerprint = fingerprint ; logger . warn ( STRING , fingerprint , server Id ) ; create Known Cert File If Not Exists ( ) ; assert Known Host File Writable ( ) ; Buffered Writer writer = new Buffered Writer ( new File Writer ( known Hosts , BOOL ) ) ; writer . write ( server Id + STRING + this . fingerprint ) ; writer . new Line ( ) ; writer . close ( ) ; }
public void remove On Central Position Changed Listener ( On Central Position Changed Listener listener ) { m On Central Position Changed Listeners . remove ( listener ) ; }
public static Object invoke Static ( Class clazz , String method Name , Class [ ] types , Object [ ] values ) throws No Such Method Exception { try { Method method = clazz . get Method ( method Name , types ) ; Object result = method . invoke ( null , values ) ; return result ; } catch ( Illegal Access Exception e ) { throw new No Such Method Exception ( method Name + STRING ) ; } catch ( Invocation Target Exception e ) { throw new Internal Error ( e . get Message ( ) ) ; } }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return NOTE ID ; case NUM : return PARAGRAPH ID ; case NUM : return RESOURCE NAME ; default : return null ; } }
@ Override protected final boolean write Data ( Byte Buffer data ) { synchronized ( guard ) { Ls Server Packet packet = send Msg Queue . poll First ( ) ; if ( packet == null ) { return BOOL ; } packet . write ( this , data ) ; return BOOL ; } }
@ Override @ Suppress Warnings ( STRING ) public Object execute Command ( final int command ID , final Object [ ] args ) { if ( ! is Setup ) { throw new Runtime Exception ( STRING ) ; } return current Commands . execute Command ( command ID , args ) ; }
@ Override public void on Upgrade ( SQ Lite Database db , int old Version , int new Version ) { if ( old Version != new Version ) { if ( new Version == NUM && old Version == NUM ) { WX Log Utils . d ( TAG STORAGE , STRING + old Version + STRING + new Version ) ; boolean update Result = BOOL ; try { long start = System . current Time Millis ( ) ; db . begin Transaction ( ) ; String SQL ADD COLUMN TIMESTAMP = STRING + TABLE STORAGE + STRING + COLUMN TIMESTAMP + STRING ; WX Log Utils . d ( TAG STORAGE , STRING + SQL ADD COLUMN TIMESTAMP ) ; db . exec SQL ( SQL ADD COLUMN TIMESTAMP ) ; String SQL ADD COLUMN PERSISTENT = STRING + TABLE STORAGE + STRING + COLUMN PERSISTENT + STRING ; WX Log Utils . d ( TAG STORAGE , STRING + SQL ADD COLUMN PERSISTENT ) ; db . exec SQL ( SQL ADD COLUMN PERSISTENT ) ; String SQL UPDATE TABLE = STRING + TABLE STORAGE + STRING + COLUMN TIMESTAMP + STRING + s Date Formatter . format ( new Date ( ) ) + STRING + COLUMN PERSISTENT + STRING ; WX Log Utils . d ( TAG STORAGE , STRING + SQL UPDATE TABLE ) ; db . exec SQL ( SQL UPDATE TABLE ) ; db . set Transaction Successful ( ) ; long time = System . current Time Millis ( ) - start ; WX Log Utils . d ( TAG STORAGE , STRING + time + STRING ) ; } catch ( Exception e ) { WX Log Utils . d ( TAG STORAGE , STRING + old Version + STRING + new Version + STRING + e . get Message ( ) ) ; update Result = BOOL ; } finally { db . end Transaction ( ) ; } if ( ! update Result ) { WX Log Utils . d ( TAG STORAGE , STRING ) ; delete DB ( ) ; on Create ( db ) ; } } else { delete DB ( ) ; on Create ( db ) ; } } }
public void clear ( Faces Context faces Context , Map < String , Object > view Map ) { if ( LOGGER . is Loggable ( Level . FINEST ) ) { LOGGER . log ( Level . FINEST , STRING , view Map ) ; } if ( context Manager != null ) { context Manager . clear ( faces Context , view Map ) ; } destroy Beans ( faces Context , view Map ) ; }
public Set < URI > check For Active User Mapping Using Group ( String domain , String label ) { Set < URI > tenants Using User Group = null ; Map < URI , List < User Mapping > > mappings = get All User Mappings For Domain ( domain ) ; if ( Collection Utils . is Empty ( mappings ) ) { log . debug ( STRING , domain ) ; return tenants Using User Group ; } tenants Using User Group = new Hash Set < URI > ( ) ; for ( Map . Entry < URI , List < Base Permissions Helper . User Mapping > > entry : mappings . entry Set ( ) ) { if ( Collection Utils . is Empty ( entry . get Value ( ) ) ) { continue ; } for ( User Mapping user Mapping : entry . get Value ( ) ) { if ( user Mapping == null || Collection Utils . is Empty ( user Mapping . get Groups ( ) ) ) { continue ; } for ( String group : user Mapping . get Groups ( ) ) { if ( String Utils . is Not Blank ( group ) && group . equals Ignore Case ( label ) ) { tenants Using User Group . add ( entry . get Key ( ) ) ; } } } } return tenants Using User Group ; }
public Process ( final URL url ) throws IO Exception , XML Exception { init Context ( ) ; Reader in = new Input Stream Reader ( Web Service Tools . open Stream From URL ( url ) , get Encoding ( null ) ) ; read Process ( in ) ; in . close ( ) ; }
@ Override public boolean accepts URL ( String url ) { if ( url != null ) { if ( url . starts With ( Constants . START URL ) ) { return BOOL ; } else if ( url . equals ( DEFAULT URL ) ) { return DEFAULT CONNECTION . get ( ) != null ; } } return BOOL ; }
private String prep Operand ( String label ) { String Builder sb = new String Builder ( STRING ) ; sb . append ( label ) ; sb . append ( Lop . DATATYPE PREFIX ) ; sb . append ( get Data Type ( ) ) ; sb . append ( Lop . VALUETYPE PREFIX ) ; sb . append ( get Value Type ( ) ) ; return sb . to String ( ) ; }
protected final Field unpack Field ( Buffer packet , boolean extract Default Values ) throws SQL Exception { if ( this . use 41 Extensions ) { if ( this . has 41 New New Prot ) { int catalog Name Start = packet . get Position ( ) + NUM ; int catalog Name Length = packet . fast Skip Len String ( ) ; catalog Name Start = adjust Start For Field Length ( catalog Name Start , catalog Name Length ) ; } int database Name Start = packet . get Position ( ) + NUM ; int database Name Length = packet . fast Skip Len String ( ) ; database Name Start = adjust Start For Field Length ( database Name Start , database Name Length ) ; int table Name Start = packet . get Position ( ) + NUM ; int table Name Length = packet . fast Skip Len String ( ) ; table Name Start = adjust Start For Field Length ( table Name Start , table Name Length ) ; int original Table Name Start = packet . get Position ( ) + NUM ; int original Table Name Length = packet . fast Skip Len String ( ) ; original Table Name Start = adjust Start For Field Length ( original Table Name Start , original Table Name Length ) ; int name Start = packet . get Position ( ) + NUM ; int name Length = packet . fast Skip Len String ( ) ; name Start = adjust Start For Field Length ( name Start , name Length ) ; int original Column Name Start = packet . get Position ( ) + NUM ; int original Column Name Length = packet . fast Skip Len String ( ) ; original Column Name Start = adjust Start For Field Length ( original Column Name Start , original Column Name Length ) ; packet . read Byte ( ) ; short char Set Number = ( short ) packet . read Int ( ) ; long col Length = NUM ; if ( this . has 41 New New Prot ) { col Length = packet . read Long ( ) ; } else { col Length = packet . read Long Int ( ) ; } int col Type = packet . read Byte ( ) & NUM ; short col Flag = NUM ; if ( this . has Long Column Info ) { col Flag = ( short ) packet . read Int ( ) ; } else { col Flag = ( short ) ( packet . read Byte ( ) & NUM ) ; } int col Decimals = packet . read Byte ( ) & NUM ; int default Value Start = - NUM ; int default Value Length = - NUM ; if ( extract Default Values ) { default Value Start = packet . get Position ( ) + NUM ; default Value Length = packet . fast Skip Len String ( ) ; } Field field = new Field ( this . connection , packet . get Byte Buffer ( ) , database Name Start , database Name Length , table Name Start , table Name Length , original Table Name Start , original Table Name Length , name Start , name Length , original Column Name Start , original Column Name Length , col Length , col Type , col Flag , col Decimals , default Value Start , default Value Length , char Set Number ) ; return field ; } int table Name Start = packet . get Position ( ) + NUM ; int table Name Length = packet . fast Skip Len String ( ) ; table Name Start = adjust Start For Field Length ( table Name Start , table Name Length ) ; int name Start = packet . get Position ( ) + NUM ; int name Length = packet . fast Skip Len String ( ) ; name Start = adjust Start For Field Length ( name Start , name Length ) ; int col Length = packet . readn Bytes ( ) ; int col Type = packet . readn Bytes ( ) ; packet . read Byte ( ) ; short col Flag = NUM ; if ( this . has Long Column Info ) { col Flag = ( short ) ( packet . read Int ( ) ) ; } else { col Flag = ( short ) ( packet . read Byte ( ) & NUM ) ; } int col Decimals = ( packet . read Byte ( ) & NUM ) ; if ( this . col Decimal Needs Bump ) { col Decimals ++ ; } Field field = new Field ( this . connection , packet . get Byte Buffer ( ) , name Start , name Length , table Name Start , table Name Length , col Length , col Type , col Flag , col Decimals ) ; return field ; }
static int derive ARGB ( Color color 1 , Color color 2 , float mid Point ) { int r = color 1 . get Red ( ) + Math . round ( ( color 2 . get Red ( ) - color 1 . get Red ( ) ) * mid Point ) ; int g = color 1 . get Green ( ) + Math . round ( ( color 2 . get Green ( ) - color 1 . get Green ( ) ) * mid Point ) ; int b = color 1 . get Blue ( ) + Math . round ( ( color 2 . get Blue ( ) - color 1 . get Blue ( ) ) * mid Point ) ; int a = color 1 . get Alpha ( ) + Math . round ( ( color 2 . get Alpha ( ) - color 1 . get Alpha ( ) ) * mid Point ) ; return ( ( a & NUM ) << NUM ) | ( ( r & NUM ) << NUM ) | ( ( g & NUM ) << NUM ) | ( b & NUM ) ; }
public static void activate System Style ( ) { try { UI Manager . set Look And Feel ( UI Manager . get System Look And Feel Class Name ( ) ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } J Frame . set Default Look And Feel Decorated ( BOOL ) ; }
public static Buffered Image to Buffered Image ( Image img ) { if ( img instanceof Buffered Image ) { return ( Buffered Image ) img ; } Buffered Image bimage = new Buffered Image ( img . get Width ( null ) , img . get Height ( null ) , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D b Gr = bimage . create Graphics ( ) ; b Gr . draw Image ( img , NUM , NUM , null ) ; b Gr . dispose ( ) ; return bimage ; }
private static Char Set do Parse String ( String s ) { Char Set result = new Char Set ( ) ; int p = NUM ; boolean have Dash = BOOL ; boolean have Tilde = BOOL ; boolean w Is Real = BOOL ; int w = NUM ; while ( p < s . length ( ) ) { int c = s . code Point At ( p ) ; if ( c == STRING ) { if ( w Is Real ) { result . internal Union ( new Char Set ( w ) ) ; } int bracket Level = NUM ; int q = p + NUM ; while ( bracket Level != NUM ) { if ( q >= s . length ( ) ) { throw new Illegal Argument Exception ( STRING + p + STRING + s ) ; } int ch = s . code Point At ( q ) ; switch ( ch ) { case STRING : ch = s . code Point At ( ++ q ) ; break ; case STRING : ++ bracket Level ; break ; case STRING : -- bracket Level ; break ; } q += Character . char Count ( ch ) ; } -- q ; if ( ! have Tilde ) { result . internal Union ( Char Set . parse String ( s . substring ( p + NUM , q ) ) ) ; } else { result . internal Difference ( Char Set . parse String ( s . substring ( p + NUM , q ) ) ) ; } have Tilde = BOOL ; have Dash = BOOL ; w Is Real = BOOL ; p = q + NUM ; } else if ( c == STRING ) { if ( w Is Real ) { result . internal Union ( new Char Set ( w ) ) ; } int q = s . index Of ( STRING , p + NUM ) ; if ( q == - NUM ) { throw new Illegal Argument Exception ( STRING + p + STRING + s ) ; } if ( ! have Tilde ) { result . internal Union ( char Set For Category ( s . substring ( p + NUM , q ) ) ) ; } else { result . internal Difference ( char Set For Category ( s . substring ( p + NUM , q ) ) ) ; } have Tilde = BOOL ; have Dash = BOOL ; w Is Real = BOOL ; p = q + NUM ; } else if ( c == STRING ) { if ( w Is Real ) { have Dash = BOOL ; } ++ p ; } else if ( c == STRING ) { if ( w Is Real ) { result . internal Union ( new Char Set ( w ) ) ; w Is Real = BOOL ; } have Tilde = BOOL ; ++ p ; if ( result . empty ( ) ) { result . internal Complement ( ) ; } } else if ( c >= STRING && c < STRING && ! Character . is Letter ( ( char ) c ) && ! Character . is Digit ( ( char ) c ) && c != STRING ) { throw new Illegal Argument Exception ( STRING + p + STRING + s ) ; } else { if ( c == STRING ) { ++ p ; } if ( have Dash ) { if ( s . code Point At ( p ) < w ) { throw new Illegal Argument Exception ( STRING + Integer . to Hex String ( s . code Point At ( p ) ) + STRING + Integer . to Hex String ( w ) + STRING + STRING ) ; } int ch = s . code Point At ( p ) ; if ( ! have Tilde ) { result . internal Union ( new Char Set ( w , ch ) ) ; } else { result . internal Difference ( new Char Set ( w , ch ) ) ; } p += Character . char Count ( ch ) ; have Dash = BOOL ; have Tilde = BOOL ; w Is Real = BOOL ; } else if ( have Tilde ) { w = s . code Point At ( p ) ; result . internal Difference ( new Char Set ( w ) ) ; p += Character . char Count ( w ) ; have Tilde = BOOL ; w Is Real = BOOL ; } else if ( w Is Real ) { result . internal Union ( new Char Set ( w ) ) ; w = s . code Point At ( p ) ; p += Character . char Count ( w ) ; w Is Real = BOOL ; } else { w = s . code Point At ( p ) ; p += Character . char Count ( w ) ; w Is Real = BOOL ; } } } if ( w Is Real ) { result . internal Union ( new Char Set ( w ) ) ; } return result ; }
public void add Sensor Selection Listener ( final Sensor Selection Listener listener ) { listener List . add ( Sensor Selection Listener . class , listener ) ; }
public void write ( char c ) throws IO Exception { if ( output == null ) throw new IO Exception ( STRING ) ; output . append ( c ) ; }
public void unregister ( Grid Cache Ttl Manager mgr ) { synchronized ( mux ) { mgrs . remove ( mgr ) ; if ( mgrs . is Empty ( ) ) stop Cleanup Worker ( ) ; } }
public synchronized void initialize Secure Log Helper ( String logger File Name , AM Password Logger Password , String ver File Name , AM Password verifier Password ) throws Exception { log File Name = logger File Name ; verifier File Name = ver File Name ; logger Pass = Logger Password ; AM Password temp Verifier Pass = verifier Password ; logger Initialized = is Initialized ( logger File Name , logger Pass ) ; if ( ! logger Initialized ) { initialize Key Store Manager ( Logger Password ) ; Key Generator keygen = Key Generator . get Instance ( STRING ) ; Secret Key k0 = keygen . generate Key ( ) ; current Logger Key = k0 . get Encoded ( ) ; write To Secret Store ( current Logger Key , logger File Name , logger Pass , initial Key ) ; logger Initialized = BOOL ; write To Secret Store ( current Logger Key , logger File Name , logger Pass , current Key ) ; write To Secret Store ( current Logger Key , verifier File Name , temp Verifier Pass , initial Key ) ; } else { if ( Debug . message Enabled ( ) ) { Debug . message ( log File Name + STRING + STRING ) ; } current Logger Key = read From Secret Store ( logger File Name , current Key , logger Pass ) ; } }
@ Override protected Image platform Image Bytes To Image ( byte [ ] bytes , long format ) throws IO Exception { String mime Type = null ; if ( format == CF PNG ) { mime Type = STRING ; } else if ( format == CF JFIF ) { mime Type = STRING ; } if ( mime Type != null ) { return standard Image Bytes To Image ( bytes , mime Type ) ; } int [ ] image Data = platform Image Bytes To Image Data ( bytes , format ) ; if ( image Data == null ) { throw new IO Exception ( STRING ) ; } int len = image Data . length - NUM ; int width = image Data [ len ] ; int height = image Data [ len + NUM ] ; Data Buffer Int buffer = new Data Buffer Int ( image Data , len ) ; Writable Raster raster = Raster . create Packed Raster ( buffer , width , height , width , bandmasks , null ) ; return new Buffered Image ( direct Color Model , raster , BOOL , null ) ; }
public static String clean Stacking Markers ( String filename ) { if ( ! String Utils . is Empty ( filename ) ) { Matcher m = stacking Pattern 1 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( NUM ) + m . group ( NUM ) ; } m = stacking Pattern 2 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( NUM ) + m . group ( NUM ) ; } m = stacking Pattern 3 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( NUM ) + m . group ( NUM ) ; } m = stacking Pattern 4 . matcher ( filename ) ; if ( m . matches ( ) ) { return m . group ( NUM ) + m . group ( NUM ) ; } } return filename ; }
private void send Discarded ( Service Registrar reg , String [ ] cur Groups ) { Service ID srvc ID = reg . get Service ID ( ) ; if ( cur Groups == null ) { Unicast Response resp = ( Unicast Response ) registrars . get ( srvc ID ) ; if ( resp == null ) return ; cur Groups = resp . get Groups ( ) ; } if ( registrars . remove ( srvc ID ) != null ) { reg Info . remove ( srvc ID ) ; if ( ! listeners . is Empty ( ) ) { add Notify ( ( Array List ) listeners . clone ( ) , map Reg To Groups ( reg , cur Groups ) , DISCARDED ) ; } } }
@ Suppress Warnings ( STRING ) public boolean wait For Completion ( Application Id app Id , App Status Callback callback , long timeout Millis ) throws Yarn Exception , IO Exception { long start Millis = System . current Time Millis ( ) ; while ( BOOL ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { LOG . debug ( STRING ) ; } Application Report report = client RM . get Application Report ( app Id ) ; if ( callback . exit Loop ( report ) == BOOL ) { return BOOL ; } Yarn Application State state = report . get Yarn Application State ( ) ; Final Application Status ds Status = report . get Final Application Status ( ) ; if ( Yarn Application State . FINISHED == state ) { if ( Final Application Status . SUCCEEDED == ds Status ) { LOG . info ( STRING ) ; return BOOL ; } else { LOG . info ( STRING + STRING + state . to String ( ) + STRING + ds Status . to String ( ) + STRING ) ; return BOOL ; } } else if ( Yarn Application State . KILLED == state || Yarn Application State . FAILED == state ) { LOG . info ( STRING + STRING + state . to String ( ) + STRING + ds Status . to String ( ) + STRING ) ; return BOOL ; } if ( System . current Time Millis ( ) - start Millis > timeout Millis ) { LOG . info ( STRING ) ; client RM . kill Application ( app Id ) ; return BOOL ; } } }
private String new Sentence ( Random r , int max Sentence Length ) { String Builder sb = new String Builder ( ) ; int num Elements = Test Util . next Int ( r , NUM , max Sentence Length ) ; for ( int i = NUM ; i < num Elements ; i ++ ) { if ( sb . length ( ) > NUM ) { sb . append ( STRING ) ; sb . append ( ( char ) Test Util . next Int ( r , STRING , STRING ) ) ; } else { sb . append ( ( char ) Test Util . next Int ( r , STRING , STRING ) ) ; } } sb . append ( STRING ) ; return sb . to String ( ) ; }
private void read Fig Tree Block ( Map < String , Object > settings ) throws Import Exception , IO Exception { String command = helper . read Token ( STRING ) ; while ( ! command . equals Ignore Case ( STRING ) ) { if ( command . equals Ignore Case ( STRING ) ) { while ( helper . get Last Delimiter ( ) != STRING ) { String key = helper . read Token ( STRING ) ; if ( helper . get Last Delimiter ( ) != STRING ) { throw new Import Exception ( STRING + key + STRING + command + STRING ) ; } String value = helper . read Token ( STRING ) ; settings . put ( key , parse Value ( value ) ) ; } } else { throw new Import Exception ( STRING + command + STRING ) ; } command = helper . read Token ( STRING ) ; } find End Block ( ) ; }
@ Override public int hash Code ( ) { int hash ; if ( normalized . length ( ) > NUM ) { hash = normalized . hash Code ( ) ; } else { hash = original . hash Code ( ) ; } if ( matcher != null ) { hash ^= matcher . hash Code ( ) ; } return hash ; }
@ Override public void end DTD ( Augmentations augs ) throws XNI Exception { f In DTD = BOOL ; try { if ( f Lexical Handler != null ) { f Lexical Handler . end DTD ( ) ; } } catch ( SAX Exception e ) { throw new XNI Exception ( e ) ; } if ( f Declared Attrs != null ) { f Declared Attrs . clear ( ) ; } }
public boolean copy ( String where Clause , boolean drop First ) { log . info ( where Clause ) ; if ( get Connection ( BOOL , BOOL ) == null ) return BOOL ; boolean success = BOOL ; int count = NUM ; Array List < String > list = new Array List < String > ( ) ; String sql = STRING ; if ( where Clause != null && where Clause . length ( ) > NUM ) sql += STRING + where Clause ; sql += STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; Connection conn = pstmt . get Connection ( ) ; Database Meta Data md = null ; if ( conn != null ) md = conn . get Meta Data ( ) ; else { throw new DB Exception ( STRING ) ; } rs = pstmt . execute Query ( ) ; while ( rs . next ( ) && success ) { M Table table = new M Table ( m ctx , rs , null ) ; if ( table . is View ( ) ) continue ; if ( drop First ) { execute Commands ( new String [ ] { STRING + table . get Table Name ( ) } , m conn , BOOL , BOOL ) ; } if ( create Table ( table , md ) ) { list . add ( table . get Table Name ( ) ) ; count ++ ; } else success = BOOL ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; success = BOOL ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( ! success ) return BOOL ; enable Constraints ( list ) ; database Build ( ) ; log . info ( STRING + count ) ; try { if ( m conn != null ) m conn . close ( ) ; } catch ( SQL Exception e2 ) { log . log ( Level . SEVERE , STRING , e2 ) ; } m conn = null ; return success ; }
static Method find Method ( Class < ? > cls , String method Name , int arg Count ) { return find Method ( cls , method Name , arg Count , null ) ; }
public static boolean has Mime Type ( String mime Type ) { if ( mime Type == null || mime Type . is Empty ( ) ) { return BOOL ; } return mime Type To Extension Map . contains Key ( mime Type ) ; }
private String replace Meta Chars ( String input ) { String result = input . replace All ( STRING , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; result = result . replace All ( Pattern . quote ( STRING ) , STRING ) ; return result ; }
static String base 64 encode ( byte [ ] bytes ) { String Builder builder = new String Builder ( ( ( bytes . length + NUM ) / NUM ) * NUM ) ; for ( int i = NUM ; i < bytes . length ; i += NUM ) { byte b0 = bytes [ i ] ; byte b1 = i < bytes . length - NUM ? bytes [ i + NUM ] : NUM ; byte b2 = i < bytes . length - NUM ? bytes [ i + NUM ] : NUM ; builder . append ( BASE 64 CHARS [ ( b0 & NUM ) > > NUM ] ) ; builder . append ( BASE 64 CHARS [ ( ( b0 & NUM ) << NUM ) | ( ( b1 & NUM ) > > NUM ) ] ) ; builder . append ( i < bytes . length - NUM ? BASE 64 CHARS [ ( ( b1 & NUM ) << NUM ) | ( ( b2 & NUM ) > > NUM ) ] : STRING ) ; builder . append ( i < bytes . length - NUM ? BASE 64 CHARS [ b2 & NUM ] : STRING ) ; } return builder . to String ( ) ; }
final public void print ( float v ) { Writer out = this . out ; if ( out == null ) return ; try { String s = String . value Of ( v ) ; out . write ( s , NUM , s . length ( ) ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
@ Override public String to String ( ) { String Buffer result ; if ( m Model == null ) { result = new String Buffer ( STRING ) ; } else { result = new String Buffer ( ) ; result . append ( STRING ) ; result . append ( STRING ) ; result . append ( STRING + get Model File ( ) + STRING ) ; result . append ( m Model . to String ( ) ) ; } return result . to String ( ) ; }
public static boolean check Chroot Path ( String zk Host , boolean create ) throws Keeper Exception , Interrupted Exception { if ( ! Solr Zk Client . contains Chroot ( zk Host ) ) { return BOOL ; } log . trace ( STRING ) ; String chroot Path = zk Host . substring ( zk Host . index Of ( STRING ) , zk Host . length ( ) ) ; Solr Zk Client tmp Client = new Solr Zk Client ( zk Host . substring ( NUM , zk Host . index Of ( STRING ) ) , NUM , NUM , null , null , null ) ; boolean exists = tmp Client . exists ( chroot Path , BOOL ) ; if ( ! exists && create ) { tmp Client . make Path ( chroot Path , BOOL , BOOL ) ; exists = BOOL ; } tmp Client . close ( ) ; return exists ; }
public List < Source Record > ddl Records For Database ( String db Name ) { return ddl Records By Db Name . get ( db Name ) ; }
@ Override public int hash Code ( ) { int result = NUM ; result = Hash Utilities . hash Code ( result , this . anchor ) ; result = Hash Utilities . hash Code ( result , this . coordinate Type ) ; result = Hash Utilities . hash Code ( result , this . x ) ; result = Hash Utilities . hash Code ( result , this . y ) ; result = Hash Utilities . hash Code ( result , this . max Width ) ; result = Hash Utilities . hash Code ( result , this . max Height ) ; result = Hash Utilities . hash Code ( result , this . title ) ; return result ; }
public static Print Data parse XML ( Properties ctx , File input ) { log . config ( input . to String ( ) ) ; Print Data pd = null ; try { Print Data Handler handler = new Print Data Handler ( ctx ) ; SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; SAX Parser parser = factory . new SAX Parser ( ) ; parser . parse ( input , handler ) ; pd = handler . get Print Data ( ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; } return pd ; }
void notify Failure ( Throwable exception ) { synchronized ( wait Object ) { is Complete = BOOL ; if ( exception instanceof Mqtt Exception ) { pending Exception = ( Mqtt Exception ) exception ; } else { pending Exception = new Mqtt Exception ( exception ) ; } wait Object . notify All ( ) ; if ( exception instanceof Mqtt Exception ) { last Exception = ( Mqtt Exception ) exception ; } if ( listener != null ) { listener . on Failure ( this , exception ) ; } } }
@ Override public boolean contains ( String identifier ) { return blacklist . contains ( identifier ) ; }
static private String SHORT Max ( ) { short temp Value = Short . MAX VALUE ; return String . value Of ( temp Value ) ; }
public static String make Compliant Name ( String value ) { value = value . replace ( STRING , STRING ) ; value = value . replace ( STRING , STRING ) ; value = value . replace ( STRING , STRING ) ; value = value . replace ( STRING , STRING ) ; value = value . replace ( STRING , STRING ) ; if ( value . length ( ) < NUM ) { value = STRING ; } return value ; }
public Storage Unit Entity create Database Entities For Business Object Data Ddl Testing ( String partition Value ) { if ( partition Value != null ) { String s3 Key Prefix = Abstract Service Test . get Expected S 3 Key Prefix ( Abstract Service Test . NAMESPACE , Abstract Service Test . DATA PROVIDER NAME , Abstract Service Test . BDEF NAME , Abstract Service Test . FORMAT USAGE CODE , File Type Entity . TXT FILE TYPE , Abstract Service Test . FORMAT VERSION , Abstract Service Test . FIRST PARTITION COLUMN NAME , partition Value , null , null , Abstract Service Test . DATA VERSION ) ; return create Database Entities For Business Object Data Ddl Testing ( partition Value , s3 Key Prefix ) ; } else { return create Database Entities For Business Object Data Ddl Testing ( null , null ) ; } }
private void do Shader ( PDF Object shader Obj ) throws IO Exception { }
public static Map append Element To Map ( String key , Set values , Map to Map ) { if ( ( key != null ) && ( values != null ) && ( ! values . is Empty ( ) ) && ( to Map != null ) ) { Set previous Values = ( Set ) to Map . get ( key ) ; if ( ( previous Values != null ) && ( ! previous Values . is Empty ( ) ) ) { previous Values . add All ( values ) ; } else { to Map . put ( key , values ) ; } } return to Map ; }
public static File create Temporary Agent Jar ( final String agent Class , final String boot Class Path , final boolean can Redefine Classes , final boolean can Retransform Classes , final boolean can Set Native Method Prefix ) throws IO Exception { final File jar File = File . create Temp File ( STRING + agent Class , STRING ) ; jar File . delete On Exit ( ) ; create Agent Jar ( new File Output Stream ( jar File ) , agent Class , boot Class Path , can Redefine Classes , can Retransform Classes , can Set Native Method Prefix ) ; return jar File ; }
public synchronized void store ( String file Name ) throws IO Exception { Byte Array Output Stream out = new Byte Array Output Stream ( ) ; store ( out , null ) ; Byte Array Input Stream in = new Byte Array Input Stream ( out . to Byte Array ( ) ) ; Input Stream Reader reader = new Input Stream Reader ( in , STRING ) ; Line Number Reader r = new Line Number Reader ( reader ) ; Writer w ; try { w = new Output Stream Writer ( File Utils . new Output Stream ( file Name , BOOL ) ) ; } catch ( Exception e ) { throw new IO Exception ( e . to String ( ) , e ) ; } Print Writer writer = new Print Writer ( new Buffered Writer ( w ) ) ; while ( BOOL ) { String line = r . read Line ( ) ; if ( line == null ) { break ; } if ( ! line . starts With ( STRING ) ) { writer . print ( line + STRING ) ; } } writer . close ( ) ; }
public Packet Output Stream write Time Length ( final Calendar calendar , final boolean fractional Seconds ) { if ( fractional Seconds ) { assure Buffer Capacity ( NUM ) ; buffer . put ( ( byte ) NUM ) ; buffer . put ( ( byte ) NUM ) ; buffer . put Int ( NUM ) ; buffer . put ( ( byte ) calendar . get ( Calendar . HOUR OF DAY ) ) ; buffer . put ( ( byte ) calendar . get ( Calendar . MINUTE ) ) ; buffer . put ( ( byte ) calendar . get ( Calendar . SECOND ) ) ; buffer . put Int ( calendar . get ( Calendar . MILLISECOND ) * NUM ) ; } else { assure Buffer Capacity ( NUM ) ; buffer . put ( ( byte ) NUM ) ; buffer . put ( ( byte ) NUM ) ; buffer . put Int ( NUM ) ; buffer . put ( ( byte ) calendar . get ( Calendar . HOUR OF DAY ) ) ; buffer . put ( ( byte ) calendar . get ( Calendar . MINUTE ) ) ; buffer . put ( ( byte ) calendar . get ( Calendar . SECOND ) ) ; } return this ; }
public static String ensure Min Text Length ( final String text , final int needed Len , final char ch , final int mode ) { final int number = needed Len - text . length ( ) ; if ( number <= NUM ) { return text ; } final String Builder result = new String Builder ( needed Len ) ; switch ( mode ) { case NUM : { for ( int i = NUM ; i < number ; i ++ ) { result . append ( ch ) ; } result . append ( text ) ; } break ; case NUM : { result . append ( text ) ; for ( int i = NUM ; i < number ; i ++ ) { result . append ( ch ) ; } } break ; default : { int left Field = number / NUM ; int right Field = number - left Field ; while ( left Field -- > NUM ) { result . append ( ch ) ; } result . append ( text ) ; while ( right Field -- > NUM ) { result . append ( ch ) ; } } } return result . to String ( ) ; }
public static Print Writer open Print Writer To File ( File file , boolean verbose ) throws Ade Usage Exception { try { if ( verbose ) { logger . info ( STRING + file . get Path ( ) ) ; } return new Print Writer ( file , FILE ENCODING ) ; } catch ( File Not Found Exception e ) { throw new Ade Usage Exception ( STRING + file . get Path ( ) , e ) ; } catch ( Unsupported Encoding Exception e ) { throw new Ade Usage Exception ( STRING + FILE ENCODING , e ) ; } }
public Shape create Cancel Icon ( int x , int y , int w , int h ) { final double x Mid = x + w / NUM ; final double y Mid = y + h / NUM ; path . reset ( ) ; path . move To ( x Mid , y ) ; path . quad To ( x , y , x , y Mid ) ; path . quad To ( x , y + h , x Mid , y + h ) ; path . quad To ( x + w , y + h , x + w , y Mid ) ; path . quad To ( x + w , y , x Mid , y ) ; path . close Path ( ) ; final double x Offset L = w / NUM - NUM ; final double x Offset S = w / NUM - NUM ; final double y Offset L = h / NUM - NUM ; final double y Offset S = h / NUM - NUM ; final double offset C = NUM ; path . move To ( x Mid , y Mid - offset C ) ; path . line To ( x Mid + x Offset S , y Mid - y Offset L ) ; path . line To ( y Mid + x Offset L , y Mid - y Offset S ) ; path . line To ( x Mid + offset C , y Mid ) ; path . line To ( x Mid + x Offset L , y Mid + y Offset S ) ; path . line To ( x Mid + x Offset S , y Mid + y Offset L ) ; path . line To ( x Mid , y Mid + offset C ) ; path . line To ( x Mid - x Offset S , y Mid + y Offset L ) ; path . line To ( x Mid - x Offset L , y Mid + y Offset S ) ; path . line To ( x Mid - offset C , y Mid ) ; path . line To ( x Mid - x Offset L , y Mid - y Offset S ) ; path . line To ( x Mid - x Offset S , y Mid - y Offset L ) ; path . close Path ( ) ; return path ; }
public static Socket create Socket ( Inet Address address , int port , boolean ssl ) throws IO Exception { long start = System . current Time Millis ( ) ; for ( int i = NUM ; ; i ++ ) { try { if ( ssl ) { return Cipher Factory . create Socket ( address , port ) ; } Socket socket = new Socket ( ) ; socket . connect ( new Inet Socket Address ( address , port ) , Sys Properties . SOCKET CONNECT TIMEOUT ) ; return socket ; } catch ( IO Exception e ) { if ( System . current Time Millis ( ) - start >= Sys Properties . SOCKET CONNECT TIMEOUT ) { throw e ; } if ( i >= Sys Properties . SOCKET CONNECT RETRY ) { throw e ; } try { long sleep = Math . min ( NUM , i * i ) ; Thread . sleep ( sleep ) ; } catch ( Interrupted Exception e2 ) { } } } }
protected void copy Selected Bean ( ) { if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; if ( selected Bean == null || selected Bean Location == null ) { clear Selection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING + selected Bean Location ) ; return ; } try { ser Bean = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; return ; } cut Bean = null ; if ( Debug . debugging ( STRING ) ) Debug . output ( STRING ) ; }
private void add System Menu Items ( J Popup Menu menu ) { J Menu Item mi = ( J Menu Item ) menu . add ( restore Action ) ; mi . set Mnemonic ( STRING ) ; mi = ( J Menu Item ) menu . add ( move Action ) ; mi . set Mnemonic ( STRING ) ; mi = ( J Menu Item ) menu . add ( size Action ) ; mi . set Mnemonic ( STRING ) ; mi = ( J Menu Item ) menu . add ( iconify Action ) ; mi . set Mnemonic ( STRING ) ; mi = ( J Menu Item ) menu . add ( maximize Action ) ; mi . set Mnemonic ( STRING ) ; menu . add ( new J Separator ( ) ) ; mi = ( J Menu Item ) menu . add ( close Action ) ; mi . set Mnemonic ( STRING ) ; }
public Path Controller ( J List l , J Label label , Default List Model model , J Button add , J File Chooser chooser , J Button remove , J Button up , J Button down , List Data Listener lstnr ) { this . l = l ; this . label = label ; this . model = model ; this . add = add ; this . remove = remove ; this . up = up ; this . down = down ; this . chooser = chooser ; this . lstnr = lstnr ; l . set Model ( model ) ; if ( model != null ) { model . add List Data Listener ( this ) ; } add . set Action Command ( STRING ) ; remove . set Action Command ( STRING ) ; up . set Action Command ( STRING ) ; down . set Action Command ( STRING ) ; add . add Action Listener ( this ) ; remove . add Action Listener ( this ) ; up . add Action Listener ( this ) ; down . add Action Listener ( this ) ; l . add List Selection Listener ( this ) ; remove . set Enabled ( BOOL ) ; up . set Enabled ( BOOL ) ; down . set Enabled ( BOOL ) ; }
private File [ ] list Files ( File file ) { File [ ] children = null ; if ( file . is Directory ( ) ) { children = file Filter == null ? file . list Files ( ) : file . list Files ( file Filter ) ; } if ( children == null ) { children = File Utils . EMPTY FILE ARRAY ; } if ( comparator != null && children . length > NUM ) { Arrays . sort ( children , comparator ) ; } return children ; }
public static String player Id To Name ( UUID uuid ) { long least Sig Bits = uuid . get Least Significant Bits ( ) ; long most Sig Bits = uuid . get Most Significant Bits ( ) ; byte [ ] bytes = to Array ( most Sig Bits , least Sig Bits ) ; bytes = remove Zeroes At End ( bytes ) ; return new String ( bytes , Standard Charsets . UTF 8 ) ; }
private Http Handler secure Handler ( final Http Handler to Wrap , Security Realm security Realm ) { Http Handler handler = to Wrap ; handler = new Authentication Call Handler ( handler ) ; handler = new Authentication Constraint Handler ( handler ) ; Realm Identity Manager idm = new Realm Identity Manager ( security Realm ) ; Set < Auth Mechanism > mechanisms = security Realm . get Supported Authentication Mechanisms ( ) ; List < Authentication Mechanism > undertow Mechanisms = new Array List < Authentication Mechanism > ( mechanisms . size ( ) ) ; undertow Mechanisms . add ( wrap ( new Cached Authenticated Session Mechanism ( ) , null ) ) ; for ( Auth Mechanism current : mechanisms ) { switch ( current ) { case DIGEST : List < Digest Algorithm > digest Algorithms = Collections . singleton List ( Digest Algorithm . MD 5 ) ; List < Digest Qop > digest Qops = Collections . singleton List ( Digest Qop . AUTH ) ; undertow Mechanisms . add ( wrap ( new Digest Authentication Mechanism ( digest Algorithms , digest Qops , security Realm . get Name ( ) , STRING , new Simple Nonce Manager ( ) ) , current ) ) ; break ; case PLAIN : undertow Mechanisms . add ( wrap ( new Basic Authentication Mechanism ( security Realm . get Name ( ) ) , current ) ) ; break ; case LOCAL : break ; } } handler = new Authentication Mechanisms Handler ( handler , undertow Mechanisms ) ; handler = new Security Initial Handler ( Authentication Mode . PRO ACTIVE , idm , handler ) ; handler = new Predicate Handler ( null , handler , to Wrap ) ; return handler ; }
public String to String ( ) { String Builder sb = new String Builder ( ) ; sb . append ( DML Program . construct Function Key ( this . namespace , this . fname ) ) ; sb . append ( STRING ) ; sb . append ( this . inst ID ) ; sb . append ( STRING ) ; sb . append ( this . line Number ) ; sb . append ( STRING ) ; return sb . to String ( ) ; }
protected void request Result ( Request Type type , String url , String result , int response Code , String error , String encoding ) { int length = - NUM ; if ( result != null ) { length = result . length ( ) ; } String encoding Text = encoding == null ? STRING : STRING + encoding ; LOGGER . info ( STRING + response Code + STRING + length + encoding Text + STRING + url + ( error != null ? STRING + error + STRING : STRING ) ) ; String stream = remove Request ( url ) ; if ( type == Request Type . STREAM ) { stream Info Manager . request Result ( url , result , response Code , stream ) ; } else if ( type == Request Type . STREAMS ) { stream Info Manager . request Result Streams ( url , result , response Code ) ; } else if ( type == Request Type . EMOTICONS ) { emoticon Manager . emoticons Received ( result , stream ) ; } else if ( type == Request Type . CHAT ICONS ) { if ( result == null ) { LOGGER . warning ( STRING + result ) ; return ; } List < Usericon > icons = parse Chat Icons ( result , stream ) ; if ( icons == null ) { LOGGER . warning ( STRING + result ) ; return ; } else { result Listener . received Usericons ( icons ) ; requested Chat Icons . add ( stream ) ; } } else if ( type == Request Type . GLOBAL BADGES ) { result Listener . received Usericons ( badge Manager . handle Global Badges Result ( result ) ) ; } else if ( type == Request Type . ROOM BADGES ) { result Listener . received Usericons ( badge Manager . handle Room Badges Result ( result , stream ) ) ; } else if ( type == Request Type . CHANNEL || type == Request Type . CHANNEL PUT ) { handle Channel Info Result ( type , url , result , response Code , stream ) ; } else if ( type == Request Type . GAME SEARCH ) { if ( result == null ) { LOGGER . warning ( STRING ) ; return ; } Set < String > games = parse Game Search ( result ) ; if ( games == null ) { LOGGER . warning ( STRING ) ; return ; } result Listener . game Search Result ( games ) ; } else if ( type == Request Type . FOLLOWERS ) { follower Manager . received ( response Code , stream , result ) ; } else if ( type == Request Type . SUBSCRIBERS ) { subscriber Manager . received ( response Code , stream , result ) ; } else if ( type == Request Type . USERINFO ) { String display Name = parse Name From User Info ( result ) ; result Listener . received Display Name ( String Util . to Lower Case ( stream ) , display Name ) ; } else if ( type == Request Type . CHAT SERVER ) { result Listener . received Server ( stream , parse Server ( result ) ) ; } else if ( type == Request Type . CHAT INFO ) { result Listener . received Chat Info ( Chat Info . decode ( stream , result ) ) ; } }
public static int execute Update ( Connection connection , String raw Sql Query , Object ... parameters ) throws SQL Exception { Prepared Statement stmt = null ; try { stmt = connection . prepare Statement ( raw Sql Query ) ; for ( int index = NUM ; index < parameters . length ; index ++ ) { Jdbc Utils . bind Parameter ( stmt , index + NUM , parameters [ index ] ) ; } return stmt . execute Update ( ) ; } finally { Jdbc Utils . close Statement ( stmt ) ; } }
public Future < Sync Reply > send Request ( int xid , Sync Message request ) throws Remote Store Exception { ensure Connected ( ) ; Remote Sync Future future = new Remote Sync Future ( xid , connection Generation ) ; future Map . put ( Integer . value Of ( xid ) , future ) ; if ( future Map . size ( ) > MAX PENDING REQUESTS ) { synchronized ( future Notify ) { while ( future Map . size ( ) > MAX PENDING REQUESTS ) { try { future Notify . wait ( ) ; } catch ( Interrupted Exception e ) { throw new Remote Store Exception ( STRING , e ) ; } } } } channel . write ( request ) ; return future ; }
public static boolean is Empty ( String str ) { return str == null || str . length ( ) == NUM ; }
public void disable Dependency ( Capability c ) { if ( do Not Check Capabilities ( ) ) { return ; } if ( c == Capability . NOMINAL ATTRIBUTES ) { disable Dependency ( Capability . BINARY ATTRIBUTES ) ; } else if ( c == Capability . BINARY ATTRIBUTES ) { disable Dependency ( Capability . UNARY ATTRIBUTES ) ; } else if ( c == Capability . UNARY ATTRIBUTES ) { disable Dependency ( Capability . EMPTY NOMINAL ATTRIBUTES ) ; } else if ( c == Capability . NOMINAL CLASS ) { disable Dependency ( Capability . BINARY CLASS ) ; } else if ( c == Capability . BINARY CLASS ) { disable Dependency ( Capability . UNARY CLASS ) ; } else if ( c == Capability . UNARY CLASS ) { disable Dependency ( Capability . EMPTY NOMINAL CLASS ) ; } m Dependencies . remove ( c ) ; }
private static void apply Data Internal 0 ( int id , Array < Variable Info > m Tmp Variables , Property Bind Info info , View Helper m View Helper , I Data Resolver m Data Resolver , boolean check Strictly , Sparse Array < Listener Impl Context > m Listener Map , Event Parse Caretaker caretaker ) { if ( ! check Strictly || contains All ( m Tmp Variables , info . refer Variables ) ) { if ( ! check Strictly ) { if ( s Debug ) { String msg = STRING + id + STRING + info . property Name + STRING ; Logger . d ( TAG , msg ) ; } } Variable Info var Info ; for ( int j = NUM , len = m Tmp Variables . size ; j < len ; j ++ ) { var Info = m Tmp Variables . get ( j ) ; m Data Resolver . put Object ( var Info . variable Name , var Info . data ) ; } apply Data Really ( id , NUM , info , m View Helper , m Data Resolver , m Listener Map , caretaker ) ; } else { String msg = STRING + id + STRING + info . property Name + STRING ; throw new Data Bind Exception ( msg ) ; } }
public Resources Poet add Drawable ( String name , String value ) { Element bool = document . create Element ( STRING ) ; bool . set Attribute ( STRING , name ) ; bool . append Child ( document . create Text Node ( value ) ) ; resource Element . append Child ( bool ) ; return this ; }
public Rectangle 2 D auto Position ( Operator op , int index , boolean set Position ) { int max Per Row = ( int ) Math . max ( NUM , Math . floor ( model . get Process Width ( op . get Execution Unit ( ) ) / ( Process Drawer . GRID AUTOARRANGE WIDTH + NUM ) ) ) ; int col = index % max Per Row ; int row = index / max Per Row ; Rectangle 2 D old = model . get Operator Rect ( op ) ; double x = col * Process Drawer . GRID AUTOARRANGE WIDTH + Process Drawer . GRID X OFFSET ; double y = Process Drawer . GRID AUTOARRANGE HEIGHT * row + Process Drawer . GRID Y OFFSET ; double width = Math . floor ( old != null ? old . get Width ( ) : Process Drawer . OPERATOR WIDTH ) ; double height = Math . floor ( old != null ? old . get Height ( ) : Process Drawer . OPERATOR MIN HEIGHT ) ; Rectangle 2 D rect ; if ( model . is Snap To Grid ( ) ) { Point snapped Point = Process Draw Utils . snap ( new Point 2 D . Double ( x , y ) ) ; rect = new Rectangle 2 D . Double ( snapped Point . get X ( ) , snapped Point . get Y ( ) , width , height ) ; } else { rect = new Rectangle 2 D . Double ( x , y , width , height ) ; } if ( set Position ) { model . set Operator Rect ( op , rect ) ; model . fire Operator Moved ( op ) ; } return rect ; }
private void check To Repaint ( ) { long time Passed = ( System . current Time Millis ( ) - last Repainted ) / NUM ; if ( time Passed > REPAINT DELAY ) { repaint ( ) ; last Repainted = System . current Time Millis ( ) ; } }
protected void handle Or Defer View Event ( Net View view Arg ) { if ( this . is Joining ) { synchronized ( startup Lock ) { startup Messages . add ( new Startup Event ( view Arg ) ) ; return ; } } latest View Write Lock . lock ( ) ; try { synchronized ( startup Lock ) { if ( ! processing Events ) { startup Messages . add ( new Startup Event ( view Arg ) ) ; return ; } } long new Id = view Arg . get View Id ( ) ; Local View Message v = new Local View Message ( address , new Id , view Arg , GMS Membership Manager . this ) ; listener . message Received ( v ) ; } finally { latest View Write Lock . unlock ( ) ; } }
public boolean zone Export Masks Delete ( List < Network Zoning Param > zoning Params , Collection < URI > volume UR Is , String step Id ) { Network Zoning Param zoning Param = zoning Params . get ( NUM ) ; log . info ( String . format ( STRING , zoning Param . get Export Group Display ( ) ) ) ; return do Zone Export Masks Delete ( zoning Params , volume UR Is , step Id ) ; }
private void update Pseudo References ( int epoch ) { if ( nbest List Writer != null ) { nbest List Writer . close ( ) ; Evaluation Metric < I String , String > metric = new BLEU Metric < I String , String > ( references ) ; Multi Translation Metric Max < I String , String > search Algorithm = new Hill Climbing Multi Translation Metric Max < I String , String > ( metric ) ; N Best List Container < I String , String > nbest Lists = null ; try { nbest Lists = new Flat N Best List ( nbest Filename , references . size ( ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; logger . error ( STRING , nbest Filename ) ; throw new Runtime Exception ( STRING + nbest Filename ) ; } List < Scored Featurized Translation < I String , String > > max Featurized Translations = search Algorithm . maximize ( nbest Lists ) ; assert max Featurized Translations . size ( ) == tune Source . size ( ) : STRING ; int num Translations = max Featurized Translations . size ( ) ; for ( int i = NUM ; i < num Translations ; ++ i ) { Sequence < I String > translation = max Featurized Translations . get ( i ) . translation ; if ( pseudo References . get ( i ) . size ( ) >= num Pseudo References ) pseudo References . get ( i ) . remove ( NUM ) ; pseudo References . get ( i ) . add ( translation ) ; } logger . info ( STRING , pseudo References . get ( NUM ) . size ( ) ) ; File file = new File ( nbest Filename ) ; file . delete ( ) ; reference Weights = new double [ num References + pseudo References . get ( NUM ) . size ( ) ] ; Arrays . fill ( reference Weights , NUM ) ; } if ( epoch >= pseudo Reference Burn In ) { nbest Filename = String . format ( STRING , temp Directory , epoch ) ; logger . info ( STRING , nbest Filename ) ; nbest List Writer = IO Tools . get Writer From File ( nbest Filename ) ; } }
@ Suppress Warnings ( STRING ) @ Override public void paint Icon ( Component c , Graphics g , int x , int y ) { Sea Glass Painter painter = ( Sea Glass Painter ) UI Manager . get ( prefix + STRING + key ) ; if ( painter != null ) { J Component jc = ( c instanceof J Component ) ? ( J Component ) c : null ; Graphics 2 D gfx = ( Graphics 2 D ) g ; gfx . translate ( x , y ) ; painter . paint ( gfx , jc , width , height ) ; gfx . translate ( - x , - y ) ; } }
public int list Max Channel ( Database conn ) throws SQL Exception { Result Set rs = null ; Statement statement = null ; int max Channel = - NUM ; try { statement = conn . create Statement ( ) ; rs = statement . execute Query ( select Max ) ; while ( rs . next ( ) ) { max Channel = rs . get Int ( NUM ) ; } } finally { close ( rs ) ; close ( statement ) ; } return max Channel ; }
public static File locate File ( String name , String basedir ) { File f = new File ( name ) ; if ( f . exists ( ) ) { return f ; } if ( basedir != null ) { f = new File ( basedir , name ) ; if ( f . exists ( ) ) { return f ; } } { String name 2 = name . trim ( ) ; if ( ! name . equals ( name 2 ) ) { f = locate File ( name 2 , basedir ) ; if ( f != null ) { return f ; } } } { String name 2 = name . replace ( STRING , File . separator Char ) ; if ( ! name . equals ( name 2 ) ) { f = locate File ( name 2 , basedir ) ; if ( f != null ) { return f ; } } name 2 = name . replace ( STRING , File . separator Char ) ; if ( ! name . equals ( name 2 ) ) { f = locate File ( name 2 , basedir ) ; if ( f != null ) { return f ; } } } if ( name . length ( ) > NUM && name . char At ( NUM ) == STRING && name . char At ( name . length ( ) - NUM ) == STRING ) { f = locate File ( name . substring ( NUM , name . length ( ) - NUM ) , basedir ) ; if ( f != null ) { return f ; } } return null ; }
@ Override public void on Update Scrollbar ( int dy ) { List < Alphabetical Apps List . Adapter Item > items = m Apps . get Adapter Items ( ) ; if ( items . is Empty ( ) || m Num Apps Per Row == NUM ) { m Scrollbar . set Thumb Offset ( - NUM , - NUM ) ; return ; } int row Count = m Apps . get Num App Rows ( ) ; get Cur Scroll State ( m Scroll Pos State , - NUM ) ; if ( m Scroll Pos State . row Index < NUM ) { m Scrollbar . set Thumb Offset ( - NUM , - NUM ) ; return ; } int available Scroll Bar Height = get Available Scroll Bar Height ( ) ; int available Scroll Height = get Available Scroll Height ( m Apps . get Num App Rows ( ) ) ; if ( available Scroll Height <= NUM ) { m Scrollbar . set Thumb Offset ( - NUM , - NUM ) ; return ; } int scroll Y = get Scroll Top ( m Scroll Pos State ) ; int scroll Bar Y = m Background Padding . top + ( int ) ( ( ( float ) scroll Y / available Scroll Height ) * available Scroll Bar Height ) ; if ( m Scrollbar . is Thumb Detached ( ) ) { int scroll Bar X ; if ( Utilities . is Rtl ( get Resources ( ) ) ) { scroll Bar X = m Background Padding . left ; } else { scroll Bar X = get Width ( ) - m Background Padding . right - m Scrollbar . get Thumb Width ( ) ; } if ( m Scrollbar . is Dragging Thumb ( ) ) { m Scrollbar . set Thumb Offset ( scroll Bar X , ( int ) m Scrollbar . get Last Touch Y ( ) ) ; } else { int thumb Scroll Y = m Scrollbar . get Thumb Offset ( ) . y ; int diff Scroll Y = scroll Bar Y - thumb Scroll Y ; if ( diff Scroll Y * dy > NUM ) { if ( dy < NUM ) { int offset = ( int ) ( ( dy * thumb Scroll Y ) / ( float ) scroll Bar Y ) ; thumb Scroll Y += Math . max ( offset , diff Scroll Y ) ; } else { int offset = ( int ) ( ( dy * ( available Scroll Bar Height - thumb Scroll Y ) ) / ( float ) ( available Scroll Bar Height - scroll Bar Y ) ) ; thumb Scroll Y += Math . min ( offset , diff Scroll Y ) ; } thumb Scroll Y = Math . max ( NUM , Math . min ( available Scroll Bar Height , thumb Scroll Y ) ) ; m Scrollbar . set Thumb Offset ( scroll Bar X , thumb Scroll Y ) ; if ( scroll Bar Y == thumb Scroll Y ) { m Scrollbar . reattach Thumb To Scroll ( ) ; } } else { m Scrollbar . set Thumb Offset ( scroll Bar X , thumb Scroll Y ) ; } } } else { synchronize Scroll Bar Thumb Offset To View Scroll ( m Scroll Pos State , row Count ) ; } }
private byte [ ] unzip ( byte [ ] body ) { Zip Entry ze ; byte buf [ ] = new byte [ NUM ] ; try ( Byte Array Output Stream bao = new Byte Array Output Stream ( ) ; Byte Array Input Stream bytein = new Byte Array Input Stream ( body ) ; Zip Input Stream zis = new Zip Input Stream ( bytein ) ) { while ( ( ze = zis . get Next Entry ( ) ) != null ) { int l = NUM ; while ( ( l = zis . read ( buf ) ) > NUM ) { bao . write ( buf , NUM , l ) ; } } return bao . to Byte Array ( ) ; } catch ( IO Exception e ) { } return null ; }
public static void update Artwork ( Movie Set movie Set ) { find Artwork In Artwork Folder ( movie Set ) ; for ( Movie movie : new Array List < > ( movie Set . get Movies ( ) ) ) { find Artwork In Movie Folder ( movie Set , movie ) ; } }
public Multivariate Table ( Categorical Table head Table ) { this . head Vars = new Hash Set < String > ( Arrays . as List ( head Table . get Variable ( ) ) ) ; this . table = new Hash Map < Assignment , Double > ( ) ; String variable = head Table . get Variable ( ) ; for ( Value a : head Table . get Values ( ) ) { double prob = head Table . get Prob ( a ) ; table . put ( new Assignment ( variable , a ) , prob ) ; } }
public void write Jar From Content ( final String class Name , final String content , final Output Stream out Stream ) throws IO Exception { Jar Output Stream jar Output Stream = new Jar Output Stream ( out Stream ) ; String formatted Name = class Name ; if ( ! formatted Name . ends With ( STRING ) ) { formatted Name = formatted Name . concat ( STRING ) ; } if ( class Name . contains ( STRING ) ) { Jar Entry entry = new Jar Entry ( class Name . substring ( NUM , class Name . last Index Of ( STRING ) ) ) ; entry . set Time ( System . current Time Millis ( ) ) ; jar Output Stream . put Next Entry ( entry ) ; } Jar Entry entry = new Jar Entry ( formatted Name ) ; entry . set Time ( System . current Time Millis ( ) ) ; jar Output Stream . put Next Entry ( entry ) ; jar Output Stream . write ( compile Class ( class Name , content ) ) ; jar Output Stream . close Entry ( ) ; jar Output Stream . close ( ) ; }
private View fill Right ( int pos , int next Left ) { View selected View = null ; int end = ( get Right ( ) - get Left ( ) ) ; while ( next Left < end && pos < m Item Count ) { boolean selected = pos == m Selected Position ; View child = make And Add View ( pos , next Left , BOOL , m List Padding . top , selected ) ; next Left = child . get Right ( ) + m Divider Width ; if ( selected ) { selected View = child ; } pos ++ ; } set Visible Range Hint ( m First Position , m First Position + get Child Count ( ) - NUM ) ; return selected View ; }
V remove ( Object key , int hash , Object value ) { lock ( ) ; try { int c = count - NUM ; I Hash Entry < K , V > [ ] tab = table ; int index = hash & ( tab . length - NUM ) ; I Hash Entry < K , V > first = tab [ index ] ; I Hash Entry < K , V > e = first ; while ( e != null && ( h . hash ( e ) != hash || ! key . equals ( h . key ( e ) ) ) ) e = h . next ( e ) ; V old Value = null ; if ( e != null ) { V v = h . value ( e ) ; if ( value == null || value . equals ( v ) ) { old Value = v ; ++ mod Count ; I Hash Entry < K , V > new First = h . next ( e ) ; for ( I Hash Entry < K , V > p = first ; p != e ; p = h . next ( p ) ) new First = h . clone Entry ( p , new First ) ; tab [ index ] = new First ; count = c ; } } return old Value ; } finally { unlock ( ) ; } }
public void message Item Details ( String str Class , String item , String description , String [ ] msg Option , int [ ] msg Number , int default Option ) { Hash Map < Integer , String > options = new Hash Map < Integer , String > ( msg Option . length ) ; for ( int i = NUM ; i < msg Option . length ; i ++ ) { options . put ( msg Number [ i ] , msg Option [ i ] ) ; } message Item Details ( str Class , description , item , options , default Option ) ; }
public void add Map Listener ( Map Listener listener ) { if ( listeners == null ) { listeners = new Array List < Map Listener > ( ) ; } listeners . add ( listener ) ; }
protected double compute PLO Fs ( Relation < O > relation , KNN Query < O > knn , Writable Double Data Store pdists , Writable Double Data Store plofs ) { Finite Progress progress PLO Fs = LOG . is Verbose ( ) ? new Finite Progress ( STRING , relation . size ( ) , LOG ) : null ; double nplof = NUM ; for ( DBID Iter iditer = relation . iter DBI Ds ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { final KNN List neighbors = knn . get KNN For DBID ( iditer , kcomp + NUM ) ; int ks = NUM ; double sum = NUM ; for ( DBID Iter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) && ks < kcomp ; neighbor . advance ( ) ) { if ( DBID Util . equal ( neighbor , iditer ) ) { continue ; } sum += pdists . double Value ( neighbor ) ; ks ++ ; } double plof = Math Util . max ( pdists . double Value ( iditer ) * ks / sum , NUM ) ; if ( Double . is Na N ( plof ) || Double . is Infinite ( plof ) ) { plof = NUM ; } plofs . put Double ( iditer , plof ) ; nplof += ( plof - NUM ) * ( plof - NUM ) ; LOG . increment Processed ( progress PLO Fs ) ; } LOG . ensure Completed ( progress PLO Fs ) ; nplof = lambda * Math . sqrt ( nplof / relation . size ( ) ) ; if ( LOG . is Debugging Fine ( ) ) { LOG . debug Fine ( STRING + nplof ) ; } return nplof > NUM ? nplof : NUM ; }
public static Process execute ( Process Builder pb , Line Consumer consumer ) throws IO Exception { pb . redirect Error Stream ( BOOL ) ; Process process = pb . start ( ) ; process ( process , consumer ) ; return process ; }
public static int start Agent ( SSO Server Mon Config mon Config ) { mon Html Port = mon Config . html Port ; mon Snmp Port = mon Config . snmp Port ; mon Rmi Port = mon Config . rmi Port ; monitoring Enabled = mon Config . monitoring Enabled ; mon Html Port Enabled = mon Config . mon Html Port Enabled ; mon Snmp Port Enabled = mon Config . mon Snmp Port Enabled ; mon Rmi Port Enabled = mon Config . mon Rmi Port Enabled ; mon Auth File Path = mon Config . mon Auth File Path ; policy Window = mon Config . policy Window ; session Window = mon Config . session Window ; String class Method = STRING ; String server Port = agent Svr Info . server Port ; if ( ( mon Auth File Path != null ) && ( mon Auth File Path . ends With ( STRING ) ) ) { File mon Auth File = new File ( mon Auth File Path ) ; File new Mon Auth File = new File ( mon Auth File . get Parent File ( ) + STRING + STRING ) ; if ( mon Auth File . rename To ( new Mon Auth File ) ) { mon Auth File Path = new Mon Auth File . get Absolute Path ( ) ; } } if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + STRING + mon Html Port + STRING + STRING + mon Auth File Path + STRING + STRING + mon Snmp Port + STRING + STRING + mon Rmi Port + STRING + STRING + monitoring Enabled + STRING + STRING + mon Html Port Enabled + STRING + STRING + mon Snmp Port Enabled + STRING + STRING + mon Rmi Port Enabled + STRING + STRING + policy Window + STRING + STRING + session Window + STRING + STRING + server Port + STRING ) ; } if ( ! monitoring Enabled ) { debug . warning ( class Method + STRING ) ; return MON CONFIG DISABLED ; } try { int sport = Integer . parse Int ( server Port ) ; if ( mon Rmi Port == sport ) { debug . error ( class Method + STRING + sport + STRING ) ; return MON RMICONNECTOR PROBLEM ; } if ( mon Html Port == sport ) { mon Html Port Enabled = BOOL ; if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + sport + STRING ) ; } } if ( mon Snmp Port == sport ) { mon Snmp Port Enabled = BOOL ; if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + sport + STRING ) ; } } } catch ( Number Format Exception nfe ) { debug . error ( class Method + STRING + server Port + STRING + nfe . get Message ( ) ) ; } if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + STRING + monitoring Enabled + STRING + STRING + mon Html Port + STRING + mon Html Port Enabled + STRING + STRING + mon Snmp Port + STRING + mon Snmp Port Enabled + STRING + STRING + mon Rmi Port + STRING + mon Rmi Port Enabled + STRING + STRING + session Window + STRING + STRING + policy Window + STRING ) ; } List < M Bean Server > servers = null ; try { servers = M Bean Server Factory . find M Bean Server ( null ) ; } catch ( Security Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } } if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + ( ( servers != null ) && ! servers . is Empty ( ) ) ) ; } if ( ( servers != null ) && ! servers . is Empty ( ) ) { server = servers . get ( NUM ) ; } else { try { server = M Bean Server Factory . create M Bean Server ( ) ; } catch ( Security Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } return MON MBEANSRVR PROBLEM ; } catch ( JM Runtime Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } return MON MBEANSRVR PROBLEM ; } catch ( Class Cast Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } return MON MBEANSRVR PROBLEM ; } } if ( server == null ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING ) ; } return MON MBEANSRVR PROBLEM ; } String domain = server . get Default Domain ( ) ; try { sun Mib Obj Name = new Object Name ( STRING ) ; forgerock Cts Mib Obj Name = new Object Name ( STRING ) ; forgerock Policy Mib Obj Name = new Object Name ( STRING ) ; forgerock Session Mib Obj Name = new Object Name ( STRING ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + STRING + sun Mib Obj Name + STRING ) ; debug . message ( class Method + STRING + STRING + forgerock Cts Mib Obj Name + STRING ) ; } } catch ( Malformed Object Name Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } return MON CREATEMIB PROBLEM ; } try { sun Mib = new SUN OPENSSO SERVER MIB Impl ( ) ; forgerock Cts Mib = new FORGEROCK OPENAM CTS MIB Impl ( ) ; forgerock Policy Mib = new FORGEROCK OPENAM POLICY MIB Impl ( ) ; forgerock Session Mib = new FORGEROCK OPENAM SESSION MIB Impl ( ) ; } catch ( Runtime Exception ex ) { debug . error ( class Method + STRING , ex ) ; return MON CREATEMIB PROBLEM ; } catch ( Exception ex ) { debug . error ( class Method + STRING , ex ) ; return MON CREATEMIB PROBLEM ; } try { server . register M Bean ( sun Mib , sun Mib Obj Name ) ; server . register M Bean ( forgerock Cts Mib , forgerock Cts Mib Obj Name ) ; server . register M Bean ( forgerock Policy Mib , forgerock Policy Mib Obj Name ) ; server . register M Bean ( forgerock Session Mib , forgerock Session Mib Obj Name ) ; } catch ( Runtime Operations Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } return MON CREATEMIB PROBLEM ; } catch ( Instance Already Exists Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } } catch ( M Bean Registration Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } return MON CREATEMIB PROBLEM ; } catch ( Not Compliant M Bean Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } return MON CREATEMIB PROBLEM ; } boolean mon HTML Started = BOOL ; boolean mon SNMP Started = BOOL ; boolean mon RMI Started = BOOL ; if ( mon Html Port Enabled ) { try { html Obj Name = new Object Name ( domain + STRING + mon Html Port ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + html Obj Name + STRING + STRING + mon Html Port ) ; } Map < String , String > users = Monitoring Util . get Mon Auth List ( mon Auth File Path ) ; if ( users != null ) { Auth Info auth Info [ ] = new Auth Info [ users . size ( ) ] ; int i = NUM ; for ( Map . Entry < String , String > entry : users . entry Set ( ) ) { auth Info [ i ] = new Auth Info ( entry . get Key ( ) , entry . get Value ( ) ) ; i ++ ; } html Adaptor = new Html Adaptor Server ( mon Html Port , auth Info ) ; } else { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + STRING ) ; } html Adaptor = null ; } if ( html Adaptor == null ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + mon Html Port + STRING + STRING ) ; } } else { server . register M Bean ( html Adaptor , html Obj Name ) ; html Adaptor . start ( ) ; mon HTML Started = BOOL ; } } catch ( Malformed Object Name Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } } catch ( Null Pointer Exception ex ) { debug . error ( class Method + STRING , ex ) ; if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } } catch ( Instance Already Exists Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } } catch ( M Bean Registration Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } } catch ( Not Compliant M Bean Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } } } else { debug . warning ( class Method + STRING ) ; } if ( mon Snmp Port Enabled ) { try { snmp Obj Name = new Object Name ( domain + STRING + mon Snmp Port ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + snmp Obj Name + STRING + STRING + mon Snmp Port ) ; } snmp Adaptor = new Snmp Adaptor Server ( mon Snmp Port ) ; if ( snmp Adaptor == null ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING ) ; } } else { server . register M Bean ( snmp Adaptor , snmp Obj Name ) ; snmp Adaptor . start ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING + STRING ) ; } snmp Adaptor . set Trap Port ( new Integer ( mon Snmp Port + NUM ) ) ; snmp Adaptor . snmp V 1 Trap ( NUM , NUM , null ) ; if ( debug . message Enabled ( ) ) { debug . message ( class Method + STRING ) ; } sun Mib . set Snmp Adaptor ( snmp Adaptor ) ; forgerock Cts Mib . set Snmp Adaptor ( snmp Adaptor ) ; forgerock Policy Mib . set Snmp Adaptor ( snmp Adaptor ) ; forgerock Session Mib . set Snmp Adaptor ( snmp Adaptor ) ; mon SNMP Started = BOOL ; } } catch ( Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + ex . get Message ( ) ) ; } if ( ex instanceof IO Exception || ex instanceof Snmp Status Exception ) { mon SNMP Started = BOOL ; } } } else { debug . warning ( class Method + STRING ) ; } if ( mon Rmi Port Enabled ) { try { registry = Locate Registry . create Registry ( mon Rmi Port ) ; JMX Service URL url = new JMX Service URL ( STRING + mon Rmi Port + STRING ) ; cs = JMX Connector Server Factory . new JMX Connector Server ( url , null , server ) ; cs . start ( ) ; mon RMI Started = BOOL ; } catch ( Malformed URL Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + STRING + ex . get Message ( ) ) ; } } catch ( Null Pointer Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + STRING + ex . get Message ( ) ) ; } } catch ( IO Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + STRING + ex . get Message ( ) ) ; } } catch ( Illegal State Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( class Method + STRING + STRING + ex . get Message ( ) ) ; } } catch ( Exception ex ) { debug . error ( class Method + STRING + mon Rmi Port + STRING , ex ) ; } } else { debug . warning ( class Method + STRING ) ; } if ( ! mon RMI Started && ! mon SNMP Started && ! mon HTML Started ) { debug . warning ( class Method + STRING ) ; return MON RMICONNECTOR PROBLEM ; } else { agent Started = BOOL ; start Monitoring Agent ( agent Svr Info ) ; return NUM ; } }
private void merge Released ( List < Segment > segments , List < Offset Predicate > predicates , Segment compact Segment ) { for ( int i = NUM ; i < segments . size ( ) ; i ++ ) { merge Released Entries ( segments . get ( i ) , predicates . get ( i ) , compact Segment ) ; } }
public MM Roll ( MM Random rng , int count , int start , int keep ) { super ( count , start ) ; this . total = rng . random Int ( this . faces ) + this . min ; all . add Element ( this . total ) ; this . keep = keep ; }
public static void print Help ( Print Stream out ) { check Not Null ( out ) ; out . println ( STRING ) ; Set < Class < ? extends Pipeline Options > > sorted Options = new Tree Set < > ( Class Name Comparator . INSTANCE ) ; sorted Options . add All ( REGISTERED OPTIONS ) ; for ( Class < ? extends Pipeline Options > kls : sorted Options ) { out . format ( STRING , kls . get Name ( ) ) ; } out . format ( STRING + STRING + STRING ) ; }
public static void close Quietly ( Auto Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( Runtime Exception rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
public void send ( Coordinator Stream Message message ) { log . debug ( STRING , message ) ; try { String source = message . get Source ( ) ; byte [ ] key = key Serde . to Bytes ( Arrays . as List ( message . get Key Array ( ) ) ) ; byte [ ] value = null ; if ( ! message . is Delete ( ) ) { value = message Serde . to Bytes ( message . get Message Map ( ) ) ; } Outgoing Message Envelope envelope = new Outgoing Message Envelope ( system Stream , Integer . value Of ( NUM ) , key , value ) ; system Producer . send ( source , envelope ) ; } catch ( Exception e ) { throw new Samza Exception ( e ) ; } }
public static int rand Range ( int min , int max ) { int mod = max - min ; double val = Math . ceil ( Math . random ( ) * NUM ) % mod ; return ( int ) val + min ; }
public void test simple Close On End ( ) { Striterator iter = new Striterator ( m data . iterator ( ) ) ; assert True ( iter . is Open ( ) ) ; while ( iter . has Next ( ) ) { iter . next ( ) ; assert True ( iter . is Open ( ) ) ; } assert True ( ! iter . is Open ( ) ) ; }
public void push Draw List Head ( Psp Ge List list ) { synchronized ( draw List Queue ) { int array Size = draw List Queue . size ( ) ; if ( array Size > NUM ) { Psp Ge List [ ] array = draw List Queue . to Array ( new Psp Ge List [ array Size ] ) ; Concurrent Linked Queue < Psp Ge List > new Queue = new Concurrent Linked Queue < Psp Ge List > ( ) ; Psp Ge List [ ] new Array = new Psp Ge List [ array Size + NUM ] ; new Array [ NUM ] = list ; for ( int i = NUM ; i < array Size ; i ++ ) { new Array [ i + NUM ] = array [ i ] ; new Queue . add ( new Array [ i ] ) ; } draw List Queue = new Queue ; } else { draw List Queue . add ( list ) ; } } }
protected void add Tasks For Volumes And C Gs ( Db Client db Client , List < Volume > add Vols , List < Volume > remove Vols , Set < URI > remove Volume C Gs , String task Id , Task List task List ) { if ( add Vols != null && ! add Vols . is Empty ( ) ) { for ( Volume vol : add Vols ) { add Volume Task ( db Client , vol , task List , task Id , Resource Operation Type Enum . UPDATE VOLUME GROUP ) ; } } if ( remove Vols != null && ! remove Vols . is Empty ( ) ) { for ( Volume vol : remove Vols ) { add Volume Task ( db Client , vol , task List , task Id , Resource Operation Type Enum . UPDATE VOLUME GROUP ) ; } } if ( remove Volume C Gs != null && ! remove Volume C Gs . is Empty ( ) ) { for ( URI cg : remove Volume C Gs ) { add Consistency Group Task ( db Client , cg , task List , task Id , Resource Operation Type Enum . UPDATE VOLUME GROUP ) ; } } }
protected List < Chunk > parse Chunk Spec ( String delimited Chunk Definitions , String delimited Token Text , List < Mutable Token > untyped Tokens ) { List < Chunk > chunks = new Array List < > ( ) ; String [ ] chunk Definitions = delimited Chunk Definitions . split ( STRING ) ; for ( int i = NUM ; i < chunk Definitions . length ; i ++ ) { chunks . add ( parse Chunk ( chunk Definitions [ i ] , delimited Token Text , untyped Tokens ) ) ; } return chunks ; }
public void add Listener ( final I Navi Graph Listener listener ) { super . add Listener ( listener ) ; m listeners . add Listener ( listener ) ; m synchronizer . add Listener ( listener ) ; }
public void close ( ) { if ( null != input Stream Reader ) { Carbon Util . close Streams ( input Stream Reader ) ; } }
public double longing ( F f , int N ) { return Math . pow ( NUM - p ( f ) , N ) ; }
@ Override public void draw Series ( Canvas canvas , Paint paint , List < Float > points , XY Series Renderer series Renderer , float y Axis Value , int series Index , int start Index ) { int series Nr = m Dataset . get Series Count ( ) ; int length = points . size ( ) ; paint . set Color ( series Renderer . get Color ( ) ) ; paint . set Style ( Style . FILL ) ; float half Diff X = get Half Diff X ( points , length , series Nr ) ; for ( int i = NUM ; i < length ; i += NUM ) { float x = points . get ( i ) ; float y = points . get ( i + NUM ) ; draw Bar ( canvas , x , y Axis Value , x , y , half Diff X , series Nr , series Index , paint ) ; } paint . set Color ( series Renderer . get Color ( ) ) ; }
public void write ( byte [ ] b , int off , int len , long pos ) throws IO Exception { if ( b == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ( off < NUM ) || ( len < NUM ) || ( pos < NUM ) || ( off + len > b . length ) || ( off + len < NUM ) ) { throw new Index Out Of Bounds Exception ( ) ; } long last Pos = pos + len - NUM ; if ( last Pos >= length ) { pad ( last Pos ) ; length = last Pos + NUM ; } int offset = ( int ) ( pos % BUFFER LENGTH ) ; while ( len > NUM ) { byte [ ] buf = get Cache Block ( pos / BUFFER LENGTH ) ; int nbytes = Math . min ( len , BUFFER LENGTH - offset ) ; System . arraycopy ( b , off , buf , offset , nbytes ) ; pos += nbytes ; off += nbytes ; len -= nbytes ; offset = NUM ; } }
private static void expand Number At ( String number String , int start Index , Word Relation word Relation , Item token Item ) { expand Number ( number String . substring ( start Index , number String . length ( ) ) , word Relation , token Item ) ; }
public final void open Fallback Output Stream ( ) throws Data Fallback Exception { if ( output == null ) { if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING + data File . get Name ( ) + STRING ) ; try { output = new Buffered Writer ( new File Writer ( data File , BOOL ) ) ; } catch ( IO Exception e ) { throw new Data Fallback Exception ( e . get Message ( ) ) ; } } }
private boolean can Force Perform ( String permission Name ) { List < Permission Rule > access = access ( permission Name ) ; List < Permission Rule > overridden = relevant . get Overridden ( permission Name ) ; Set < Project Ref > allows = new Hash Set < > ( ) ; Set < Project Ref > blocks = new Hash Set < > ( ) ; for ( Permission Rule rule : access ) { if ( rule . is Block ( ) ) { blocks . add ( relevant . get Rule Props ( rule ) ) ; } else if ( rule . get Force ( ) ) { allows . add ( relevant . get Rule Props ( rule ) ) ; } } for ( Permission Rule rule : overridden ) { if ( rule . get Force ( ) ) { blocks . remove ( relevant . get Rule Props ( rule ) ) ; } } blocks . remove All ( allows ) ; return blocks . is Empty ( ) && ! allows . is Empty ( ) ; }
public void stop ( ) { synchronized ( this ) { m Stopped = BOOL ; if ( m Listener Thread == null ) { return ; } } m Listener Thread . interrupt ( ) ; try { if ( m Server Socket != null ) { m Server Socket . close ( ) ; } } catch ( IO Exception e ) { } }
void handle External Entity ( String context , String public Id , String system Id ) throws SAX Exception , IO Exception { Entity Resolver entity Resolver = xml Reader . entity Resolver ; if ( entity Resolver == null ) { return ; } if ( this . system Id != null ) { try { URI system Uri = new URI ( system Id ) ; if ( ! system Uri . is Absolute ( ) && ! system Uri . is Opaque ( ) ) { URI base Uri = new URI ( this . system Id ) ; system Uri = base Uri . resolve ( system Uri ) ; system Id = system Uri . to String ( ) ; } } catch ( Exception e ) { System . log I ( STRING + system Id + STRING + STRING + this . system Id + STRING + locator , e ) ; } } Input Source input Source = entity Resolver . resolve Entity ( public Id , system Id ) ; if ( input Source == null ) { return ; } String encoding = pick Encoding ( input Source ) ; long pointer = create Entity Parser ( this . pointer , context ) ; try { Entity Parser entity Parser = new Entity Parser ( encoding , xml Reader , pointer , input Source . get Public Id ( ) , input Source . get System Id ( ) ) ; parse External Entity ( entity Parser , input Source ) ; } finally { release Parser ( pointer ) ; } }
public static final boolean is Ignorable IO Exception ( Exception e ) { if ( e instanceof Closed Channel Exception ) { return BOOL ; } String msg = e . get Message ( ) ; if ( msg == null ) { msg = e . to String ( ) ; } msg = msg . to Lower Case ( ) ; return ( msg . index Of ( STRING ) >= NUM ) || ( msg . index Of ( STRING ) >= NUM ) || ( msg . index Of ( STRING ) >= NUM ) ; }
public boolean equals Ignore Case ( String string ) { if ( string == this ) { return BOOL ; } if ( string == null || count != string . count ) { return BOOL ; } int o1 = offset , o2 = string . offset ; int end = offset + count ; char c1 , c2 ; char [ ] target = string . value ; while ( o1 < end ) { if ( ( c1 = value [ o1 ++ ] ) != ( c2 = target [ o2 ++ ] ) && Character . to Upper Case ( c1 ) != Character . to Upper Case ( c2 ) && Character . to Lower Case ( c1 ) != Character . to Lower Case ( c2 ) ) { return BOOL ; } } return BOOL ; }
public static void write Uuid ( Byte Buf buf , UUID uuid ) { buf . write Long ( uuid . get Most Significant Bits ( ) ) ; buf . write Long ( uuid . get Least Significant Bits ( ) ) ; }
public static List < Vm > create Vm List ( int broker Id , int vms Number ) { List < Vm > vms = new Array List < Vm > ( ) ; for ( int i = NUM ; i < vms Number ; i ++ ) { int vm Type = i / ( int ) Math . ceil ( ( double ) vms Number / Constants . VM TYPES ) ; vms . add ( new Power Vm ( i , broker Id , Constants . VM MIPS [ vm Type ] , Constants . VM PES [ vm Type ] , Constants . VM RAM [ vm Type ] , Constants . VM BW , Constants . VM SIZE , NUM , STRING , new Cloudlet Scheduler Dynamic Workload ( Constants . VM MIPS [ vm Type ] , Constants . VM PES [ vm Type ] ) , Constants . SCHEDULING INTERVAL ) ) ; } return vms ; }
private void apply To ( Class Visitor v , Method m ) { if ( Log . is Logging On ( ) ) { Log . log Line ( String . format ( STRING , m . to Generic String ( ) ) ) ; } v . visit ( m ) ; }
public void test Compare To Neg Neg 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = - NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; assert Equals ( - NUM , a Number . compare To ( b Number ) ) ; }
private void add Observed File ( String local Path , Account account ) { File file = new File ( local Path ) ; String parent Path = file . get Parent ( ) ; Folder Observer observer = m Folder Observers Map . get ( parent Path ) ; if ( observer == null ) { observer = new Folder Observer ( parent Path , account , get Application Context ( ) ) ; m Folder Observers Map . put ( parent Path , observer ) ; Log OC . d ( TAG , STRING + parent Path + STRING ) ; } observer . start Watching ( file . get Name ( ) ) ; Log OC . d ( TAG , STRING + local Path + STRING ) ; }
public static Workflow . Method unlink Block Snapshot Session Target Method ( URI system URI , URI snap Session URI , URI snapshot URI , Boolean delete Target ) { return new Workflow . Method ( UNLINK SNAPSHOT SESSION TARGET METHOD , system URI , snap Session URI , snapshot URI , delete Target ) ; }
public List delete Cut Edges ( ) { compute Next CW Edges ( ) ; find Labeled Edge Rings ( dir Edges ) ; List cut Lines = new Array List ( ) ; for ( Iterator i = dir Edges . iterator ( ) ; i . has Next ( ) ; ) { Polygonize Directed Edge de = ( Polygonize Directed Edge ) i . next ( ) ; if ( de . is Marked ( ) ) continue ; Polygonize Directed Edge sym = ( Polygonize Directed Edge ) de . get Sym ( ) ; if ( de . get Label ( ) == sym . get Label ( ) ) { de . set Marked ( BOOL ) ; sym . set Marked ( BOOL ) ; Polygonize Edge e = ( Polygonize Edge ) de . get Edge ( ) ; cut Lines . add ( e . get Line ( ) ) ; } } return cut Lines ; }
public static byte [ ] to Byte Array ( String spaced Hex ) { int idx = NUM ; final int len = spaced Hex . length ( ) ; final String Builder sb = new String Builder ( ) ; final Byte Array Output Stream bytes = new Byte Array Output Stream ( ) ; while ( idx < len ) { final char chr = spaced Hex . char At ( idx ++ ) ; if ( chr != STRING ) { sb . set Length ( NUM ) ; sb . append ( chr ) ; sb . append ( spaced Hex . char At ( idx ++ ) ) ; final int i = Integer . parse Int ( sb . to String ( ) , NUM ) ; final byte b = ( ( byte ) i ) ; bytes . write ( b ) ; } } return bytes . to Byte Array ( ) ; }
public Array Set ( Collection < ? extends E > collection ) { items = new Array List < E > ( collection . size ( ) ) ; for ( E item : collection ) if ( ! items . contains ( item ) ) items . add ( item ) ; }
public String documentation Wiki Url ( ) { return properties . get Property ( STRING ) ; }
public Backup Inspector ( File backup Dir ) throws IO Exception { this . backup Dir = backup Dir ; if ( ! backup Dir . exists ( ) ) { throw new IO Exception ( STRING + backup Dir . get Absolute Path ( ) + STRING ) ; } File restore File = get Restore File ( backup Dir ) ; if ( ! restore File . exists ( ) ) { throw new IO Exception ( STRING + restore File . get Name ( ) + STRING ) ; } Buffered Reader reader = null ; try { reader = new Buffered Reader ( new File Reader ( restore File ) ) ; parse Restore File ( reader ) ; } finally { if ( null != reader ) { reader . close ( ) ; } } }
public void remove Selection Listener ( final Selection Listener listener ) { check Widget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR NULL ARGUMENT ) ; } selection Listeners . remove ( listener ) ; }
public < T extends Node > T jjt Get Child ( Class < T > type ) { for ( Node n : children ) { if ( type . is Instance ( n ) ) { return ( T ) n ; } } return null ; }
public void handle Button 1 Request ( Request Invocation Event event ) throws Model Control Exception { submit Cycle = BOOL ; RM Realm Model model = ( RM Realm Model ) get Model ( ) ; String realm = ( String ) get Page Session Attribute ( AM Admin Constants . CURRENT REALM ) ; AM Property Sheet ps = ( AM Property Sheet ) get Child ( REALM PROPERTIES ) ; try { Map orig = model . get Attribute Values ( realm ) ; Map values = ps . get Attribute Values ( orig , BOOL , BOOL , model ) ; model . set Attribute Values ( realm , values ) ; set Inline Alert Message ( CC Alert . TYPE INFO , STRING , STRING ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } forward To ( ) ; }
private static Double compute Angle ( final Geo Point point , final double sin Latitude , final double cos Latitude , final double sin Longitude , final double cos Longitude ) { final double x1 = point . x * cos Longitude + point . y * sin Longitude ; final double y1 = - point . x * sin Longitude + point . y * cos Longitude ; final double z1 = point . z ; final double y2 = y1 ; final double z2 = - x1 * sin Latitude + z1 * cos Latitude ; if ( Math . sqrt ( y2 * y2 + z2 * z2 ) < Vector . MINIMUM RESOLUTION ) { return null ; } return Math . atan 2 ( z2 , y2 ) ; }
private Node delete ( Node x , Key key ) { int cmp = key . compare To ( x . key ) ; if ( cmp < NUM ) { x . left = delete ( x . left , key ) ; } else if ( cmp > NUM ) { x . right = delete ( x . right , key ) ; } else { if ( x . left == null ) { return x . right ; } else if ( x . right == null ) { return x . left ; } else { Node y = x ; x = min ( y . right ) ; x . right = delete Min ( y . right ) ; x . left = y . left ; } } x . size = NUM + size ( x . left ) + size ( x . right ) ; x . height = NUM + Math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }
@ Override protected void on Size Changed ( int w , int h , int oldw , int oldh ) { super . on Size Changed ( w , h , oldw , oldh ) ; m Center X = w / NUM ; m Center Y = h / NUM ; m Radius = Math . min ( m Center X , m Center Y ) ; m Progress Rect F . top = m Center Y - m Radius ; m Progress Rect F . bottom = m Center Y + m Radius ; m Progress Rect F . left = m Center X - m Radius ; m Progress Rect F . right = m Center X + m Radius ; update Progress Shader ( ) ; m Progress Rect F . inset ( m Progress Stroke Width / NUM , m Progress Stroke Width / NUM ) ; }
public void register Node ( String oid String , Snmp Mib Node node ) throws Illegal Access Exception { Snmp Oid oid = new Snmp Oid ( oid String ) ; register Node ( oid . long Value ( ) , NUM , node ) ; }
public Week ( Date time , Time Zone zone ) { this ( time , zone , Locale . get Default ( ) ) ; }
public void write ( Byte Code Writer out ) throws IO Exception { out . write Short ( access Flags ) ; out . write UTF 8 Const ( name ) ; out . write UTF 8 Const ( descriptor ) ; out . write Short ( attributes . size ( ) ) ; for ( int i = NUM ; i < attributes . size ( ) ; i ++ ) { Attribute attr = attributes . get ( i ) ; attr . write ( out ) ; } }
public Out ( String filename ) { try { Output Stream os = new File Output Stream ( filename ) ; Output Stream Writer osw = new Output Stream Writer ( os , CHARSET NAME ) ; out = new Print Writer ( osw , BOOL ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public static boolean create File ( File target File ) { if ( target File . exists ( ) ) { if ( target File . is File ( ) ) return BOOL ; target File . delete ( ) ; } try { return target File . create New File ( ) ; } catch ( IO Exception e ) { return BOOL ; } }
public void test Zero Zero ( ) { byte a Bytes [ ] = { NUM } ; byte b Bytes [ ] = { NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . or ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
protected int execute Prepare ( Table table , List < Column > columns , String SQL , boolean keep , int type ) throws SQL Exception { int bind No = NUM ; Prepared Statement statement = null ; int affected Rows = NUM ; try { statement = db Conn . prepare Statement ( SQL ) ; for ( Column c : columns ) { set Column Value ( statement , bind No , c ) ; bind No ++ ; } affected Rows = statement . execute Update ( ) ; } finally { if ( statement != null && ! keep ) { statement . close ( ) ; statement = null ; } } if ( keep && type > - NUM ) table . set Statement ( type , statement ) ; return affected Rows ; }
private Validation Result discover Identity Providers For Selection List ( List < String > eligible Local Idp List , List < String > eligible External Idp List , Authn Request State t ) { log . debug ( STRING ) ; Validate . is True ( t . is Choose IDP View Required ( ) == null ) ; Idm Accessor accessor = t . get Idm Accessor ( ) ; String tenant IDP Cookie = t . get Tenant IDP Cookie ( ) ; String selected IDP Entity Id = tenant IDP Cookie ; if ( tenant IDP Cookie == null || tenant IDP Cookie . is Empty ( ) ) { String tenant IDP Header = t . get Tenant IDP Select Header ( ) ; if ( tenant IDP Header == null || tenant IDP Header . is Empty ( ) ) { List < String > eligible Idps = new Array List < > ( ) ; eligible Idps . add ( accessor . get Idp Entity Id ( ) ) ; eligible Idps . add All ( eligible External Idp List ) ; t . set IDP Entity Id List ( eligible Idps ) ; log . debug ( STRING ) ; t . set Need Choose IDP View ( BOOL ) ; return null ; } else { log . debug ( STRING + tenant IDP Header ) ; selected IDP Entity Id = tenant IDP Header ; t . add Tenant IDP Cookie ( tenant IDP Header , t . get Response ( ) ) ; } } t . set Need Choose IDP View ( BOOL ) ; if ( eligible Local Idp List . contains ( selected IDP Entity Id ) ) { log . debug ( STRING ) ; t . set Proxying ( BOOL ) ; } else { IDP Config idp Config To Use = accessor . get External Idp Config For Tenant ( accessor . get Tenant ( ) , selected IDP Entity Id ) ; if ( idp Config To Use == null ) { log . warn ( STRING + selected IDP Entity Id + STRING ) ; return new Validation Result ( Oasis Names . REQUESTER , Oasis Names . NO SUPPORTED IDP ) ; } else { t . set Ext IDP To Use ( idp Config To Use ) ; t . set Proxying ( BOOL ) ; } } return null ; }
public static void check Not Null Or Empty ( String string , String message ) { if ( string == null || string . is Empty ( ) ) { throw new Illegal Argument Exception ( message ) ; } }
public void shutdown ( ) { if ( image Download Executor != null ) { image Download Executor . shutdown ( ) ; } if ( unnamed Task Executor != null ) { unnamed Task Executor . shutdown ( ) ; } if ( download Executor != null ) { download Executor . shutdown ( ) ; } if ( main Task Executor != null ) { main Task Executor . shutdown ( ) ; } if ( scheduler != null ) { scheduler . shutdown ( ) ; } for ( Tmm Task Handle task : running Tasks ) { task . cancel ( ) ; } }
private char read Escape Character ( ) throws IO Exception { if ( pos == limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } char escaped = buffer [ pos ++ ] ; switch ( escaped ) { case STRING : if ( pos + NUM > limit && ! fill Buffer ( NUM ) ) { throw syntax Error ( STRING ) ; } String hex = string Pool . get ( buffer , pos , NUM ) ; pos += NUM ; return ( char ) Integer . parse Int ( hex , NUM ) ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : return STRING ; case STRING : case STRING : case STRING : default : return escaped ; } }
private void fix Spanned With Spaces ( Spannable String Builder builder , int width Measure Spec , int height Measure Spec ) { long start Fix = System . current Time Millis ( ) ; Fixing Result result = add Spaces Around Spans Until Fixed ( builder , width Measure Spec , height Measure Spec ) ; if ( result . fixed ) { remove Unneeded Spaces ( width Measure Spec , height Measure Spec , builder , result ) ; } else { fallback To String ( width Measure Spec , height Measure Spec ) ; } if ( Build Config . DEBUG ) { long fix Duration = System . current Time Millis ( ) - start Fix ; Log . d ( Html Text View . TAG , STRING + fix Duration ) ; } }
public Count Integration Test ( ) { set Response Log Length Limit ( NUM ) ; date Format = new Simple Date Format ( STRING ) ; Calendar cal = Calendar . get Instance ( ) ; cal . add ( Calendar . DATE , - NUM ) ; yesterday = date Format . format ( cal . get Time ( ) ) ; yesterday += STRING ; cal = Calendar . get Instance ( ) ; cal . add ( Calendar . DATE , NUM ) ; today = date Format . format ( cal . get Time ( ) ) ; today += STRING ; cal = Calendar . get Instance ( ) ; cal . add ( Calendar . DATE , NUM ) ; tomorrow = date Format . format ( cal . get Time ( ) ) ; tomorrow += STRING ; cal = Calendar . get Instance ( ) ; cal . add ( Calendar . DATE , NUM ) ; tomorrow Plus 3 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus 3 += STRING ; cal = Calendar . get Instance ( ) ; cal . add ( Calendar . DATE , NUM ) ; tomorrow Plus 2 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus 2 += STRING ; cal = Calendar . get Instance ( ) ; cal . add ( Calendar . DATE , NUM ) ; tomorrow Plus 1 = date Format . format ( cal . get Time ( ) ) ; tomorrow Plus 1 += STRING ; cal = Calendar . get Instance ( ) ; cal . add ( Calendar . DATE , - NUM ) ; yesterday Minus 3 = date Format . format ( cal . get Time ( ) ) ; yesterday Minus 3 += STRING ; experiment = Experiment Factory . create Experiment ( ) ; experiment . start Time = yesterday ; experiment . end Time = tomorrow Plus 3 ; experiment . sampling Percent = NUM ; experiment . label = STRING ; experiment . application Name = QBO + UUID . random UUID ( ) ; Default Name Exclusion Strategy experiment Comparison Strategy = new Default Name Exclusion Strategy ( STRING , STRING , STRING ) ; experiment . set Serialization Strategy ( experiment Comparison Strategy ) ; }
protected Metric reduce ( List < Metric > metrics ) { System Assert . require Argument ( metrics != null , STRING ) ; Metric Distiller distiller = new Metric Distiller ( ) ; distiller . distill ( metrics ) ; Map < Long , List < String > > collated = collate ( metrics ) ; Map < Long , String > min Datapoints = reduce ( collated , metrics ) ; String new Metric Name = distiller . get Metric ( ) == null ? default Metric Name : distiller . get Metric ( ) ; Metric new Metric = new Metric ( default Scope , new Metric Name ) ; new Metric . set Display Name ( distiller . get Display Name ( ) ) ; new Metric . set Units ( distiller . get Units ( ) ) ; new Metric . set Tags ( distiller . get Tags ( ) ) ; new Metric . set Datapoints ( min Datapoints ) ; return new Metric ; }
@ Override public boolean is Inside ( Point point ) { return attack Poly . contains ( point . x - bounds . x , point . y - bounds . y ) ; }
@ Suppress Warnings ( STRING ) private static void load Extensions ( final Class Loader class Loader ) { for ( final Map . Entry < Class , Set < Class > > entry : definition Map . entry Set ( ) ) { final Service Loader < ? > service Loader = Service Loader . load ( entry . get Key ( ) , class Loader ) ; for ( final Object o : service Loader ) { register Service Class ( o . get Class ( ) , extension Classloader Lookup , class Loader , entry . get Value ( ) ) ; } } }
public static Inet Address find Inet Address ( ) throws Socket Exception , Unknown Host Exception { final Enumeration < Network Interface > enum 1 = Network Interface . get Network Interfaces ( ) ; if ( enum 1 == null ) { final Inet Address ip 1 = Inet Address . get Local Host ( ) ; return ip 1 ; } final List < Inet Address > all But Loopback = new Array List < > ( ) ; while ( enum 1 . has More Elements ( ) ) { final Network Interface netface = enum 1 . next Element ( ) ; final Enumeration < Inet Address > enum 2 = netface . get Inet Addresses ( ) ; while ( enum 2 . has More Elements ( ) ) { final Inet Address ip 2 = enum 2 . next Element ( ) ; if ( ! ip 2 . is Loopback Address ( ) ) { all But Loopback . add ( ip 2 ) ; } } } for ( final Inet Address address : all But Loopback ) { if ( address . get Address ( ) . length == NUM && ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! is Private Network Address ( address ) ) { return address ; } } for ( final Inet Address address : all But Loopback ) { if ( ! address . is Link Local Address ( ) ) { return address ; } } return Inet Address . get Local Host ( ) ; }
private Bitmap compress ( String image Path , int width , int height ) { Bitmap Factory . Options options = new Bitmap Factory . Options ( ) ; options . in Just Decode Bounds = BOOL ; Bitmap Factory . decode File ( image Path , options ) ; int out H = options . out Height ; int out W = options . out Width ; int in Sample Size = NUM ; if ( out H > height || out W > width ) { int half H = out H / NUM ; int half W = out W / NUM ; while ( ( half H / in Sample Size ) > height && ( half W / in Sample Size ) > width ) { in Sample Size *= NUM ; } } options . in Sample Size = in Sample Size ; options . in Just Decode Bounds = BOOL ; int height Ratio = ( int ) Math . ceil ( options . out Height / ( float ) height ) ; int width Ratio = ( int ) Math . ceil ( options . out Width / ( float ) width ) ; if ( height Ratio > NUM || width Ratio > NUM ) { if ( height Ratio > width Ratio ) { options . in Sample Size = height Ratio ; } else { options . in Sample Size = width Ratio ; } } options . in Just Decode Bounds = BOOL ; return Bitmap Factory . decode File ( image Path , options ) ; }
protected ISVN Status [ ] collect Unversioned Folders ( ISVN Status [ ] statuses , boolean recursive ) { if ( statuses == null ) { return null ; } List < ISVN Status > processed = new Array List < ISVN Status > ( ) ; for ( ISVN Status status : statuses ) { processed . add ( status ) ; if ( status . get Node Kind ( ) != SVN Node Kind . FILE && status . get Text Status ( ) == SVN Status Kind . UNVERSIONED ) { File folder = status . get File ( ) ; if ( ! folder . is Directory ( ) && ! folder . exists ( ) ) continue ; Set < String > already Processed = new Hash Set < String > ( ) ; process Unversioned Folder ( folder , processed , recursive , already Processed ) ; } } return processed . to Array ( new ISVN Status [ processed . size ( ) ] ) ; }
public Transaction Input ( Outpoint source , int sequence , Script script ) { Objects . require Non Null ( source , STRING ) ; Objects . require Non Null ( script , STRING ) ; this . source = source ; this . sequence = sequence ; this . script = script ; }
public void remove Channel Map ( Channel Map channel Map ) { if ( m Channel Maps . contains ( channel Map ) ) { int index = m Channel Maps . index Of ( channel Map ) ; m Channel Maps . remove ( channel Map ) ; fire Interval Removed ( this , index , index ) ; broadcast ( new Channel Map Event ( channel Map , Event . DELETE ) ) ; } }
public boolean offer ( E o ) { if ( null == o ) { throw new Null Pointer Exception ( ) ; } grow To Size ( size + NUM ) ; elements [ size ] = o ; sift Up ( size ++ ) ; return BOOL ; }
@ Suppress Warnings ( STRING ) public Object put ( Object key , Object value ) { Object orig = remove ( key ) ; result . put ( key , value ) ; return orig ; }
public Id Range [ ] parse Id Range ( Imap Session session ) throws Decoding Exception { if ( session != null ) { char c = next Word Char ( ) ; if ( c == STRING ) { consume ( ) ; return Search Res Util . get Saved Sequence Set ( session ) ; } } Character Validator validator = new Message Set Char Validator ( ) ; String next Word = consume Word ( validator , BOOL ) ; int comma Pos = next Word . index Of ( STRING ) ; if ( comma Pos == - NUM ) { return new Id Range [ ] { parse Range ( next Word ) } ; } Array List < Id Range > range List = new Array List < Id Range > ( ) ; int pos = NUM ; while ( comma Pos != - NUM ) { String range = next Word . substring ( pos , comma Pos ) ; Id Range set = parse Range ( range ) ; range List . add ( set ) ; pos = comma Pos + NUM ; comma Pos = next Word . index Of ( STRING , pos ) ; } String range = next Word . substring ( pos ) ; range List . add ( parse Range ( range ) ) ; List < Id Range > merged = Id Range . merge Ranges ( range List ) ; return ( Id Range [ ] ) merged . to Array ( new Id Range [ merged . size ( ) ] ) ; }
private String remove Suffix ( String value , String to Remove ) { if ( ( value == null ) || ( to Remove == null ) || ! suffix ( value , to Remove ) ) { return value ; } return value . substring ( NUM , value . length ( ) - to Remove . length ( ) ) ; }
public void schedule ( Task Runnable task , Date time ) throws Illegal Argument Exception , Illegal State Exception { if ( shutdown The Pool ) { throw new Illegal State Exception ( STRING ) ; } else { if ( ( task != null ) && ( time != null ) ) { Head Task Runnable head = null ; do { head = task . get Head Task ( ) ; if ( head != null ) { if ( head . acquire Valid Lock ( ) ) { try { if ( head == task . get Head Task ( ) ) { if ( head . scheduled Execution Time ( ) == time . get Time ( ) ) { return ; } else { if ( ! head . is Timed Out ( ) ) { throw new Illegal State Exception ( STRING ) ; } } } } finally { head . release Lock And Notify ( ) ; } } } } while ( head != task . get Head Task ( ) ) ; synchronized ( task List ) { if ( ( head = ( Head Task Runnable ) task List . get ( time ) ) == null ) { task . set Next ( null ) ; task List . put ( time , new Head Task Runnable ( this , task , time ) ) ; } } if ( head == null ) { synchronized ( this ) { if ( ( next Run == null ) || ( time . get Time ( ) < next Run . get Time ( ) ) ) { next Run = time ; long delay = time . get Time ( ) - current Time Millis ( ) ; scheduler . set Wait ( ( ( delay < NUM ) ? NUM : delay ) ) ; } } } else { if ( head . acquire Valid Lock ( ) ) { try { task . set Head Task ( head ) ; Task Runnable tail Task = head . tail ( ) ; task . set Previous ( tail Task ) ; tail Task . set Next ( task ) ; task . set Next ( null ) ; head . set Tail ( task ) ; } finally { head . release Lock And Notify ( ) ; } } else { schedule ( task , time ) ; } } } else { throw new Illegal Argument Exception ( ) ; } } }
private static boolean create Zynamics Directory ( ) { final File dir = new File ( Config Helper . get Zynamics Directory ( Constants . COMPANY NAME ) ) ; return dir . exists ( ) || dir . mkdir ( ) ; }
public void update Button Action Performed ( ) { node Type = node Type Box . get Selected Index ( ) ; log . debug ( STRING + cur Node . get Node Type ( ) + STRING + node Type ) ; if ( cur Node . get Node Type ( ) != node Type ) { cur Node . set Node Type ( node Type ) ; } set Node Parameters ( ) ; changed Node = BOOL ; edit Mode = BOOL ; cur Node = null ; add Button . set Visible ( BOOL ) ; edit Button . set Visible ( BOOL ) ; delete Button . set Visible ( BOOL ) ; done Button . set Visible ( BOOL ) ; update Button . set Visible ( BOOL ) ; cancel Button . set Visible ( BOOL ) ; node Addr Field . set Visible ( BOOL ) ; node Addr Static . set Visible ( BOOL ) ; status Text 2 . set Text ( std Status 2 ) ; status Text 3 . set Text ( std Status 3 ) ; status Text 1 . set Text ( rb . get String ( STRING ) + STRING + Integer . to String ( node Address ) ) ; error In Status 1 = BOOL ; }
public Iterator < Escape Target > escape Target Iterator ( Basic Block source Block ) { List < Escape Target > escape Target List = escape Target List Map . get ( source Block ) ; if ( escape Target List == null ) { escape Target List = Collections . empty List ( ) ; } return escape Target List . iterator ( ) ; }
private void layout Item ( M Tab Bar Item item , I Style Provider styles ) { int content X = item . content Bounds . x + item . margin Width ; int content Y = item . content Bounds . y + item . margin Height ; int content Width = item . content Bounds . width - item . margin Width - item . margin Width ; int content Height = item . content Bounds . height - item . margin Height - item . margin Height ; if ( item . image Visible && item . text Visible ) { boolean item Vertical = ( item . text Position & ( SWT . TOP | SWT . BOTTOM ) ) != NUM ; boolean image Leading = ( item . text Position & ( SWT . RIGHT | SWT . BOTTOM ) ) != NUM ; Point image Size = item . image Visible ? compute Image Size ( item . get Image ( ) ) : new Point ( NUM , NUM ) ; Point text Size = item . text Visible ? compute Text Size ( item . get Text ( ) , item . font ) : new Point ( NUM , NUM ) ; int image W Hint = styles . get Width ( item , M Tab Bar Item . IMAGE , item Vertical ? content Width : SWT . DEFAULT ) ; int image H Hint = styles . get Height ( item , M Tab Bar Item . IMAGE , item Vertical ? SWT . DEFAULT : content Height ) ; int text W Hint = styles . get Width ( item , M Tab Bar Item . TEXT , item Vertical ? content Width : SWT . DEFAULT ) ; int text H Hint = styles . get Height ( item , M Tab Bar Item . TEXT , item Vertical ? SWT . DEFAULT : content Height ) ; Point image Area Size = item . image Visible ? compute Preferred Size ( image Size . x , image Size . y , image W Hint , image H Hint ) : new Point ( NUM , NUM ) ; Point text Area Size = item . text Visible ? compute Preferred Size ( text Size . x , text Size . y , text W Hint , text H Hint ) : new Point ( NUM , NUM ) ; if ( item Vertical ) { if ( image H Hint > NUM && text H Hint < NUM ) { text Area Size . y = Math . max ( NUM , content Height - image Area Size . y - item . v Spacing ) ; } else if ( image H Hint < NUM && text H Hint > NUM ) { image Area Size . y = Math . max ( NUM , content Height - text Area Size . y - item . v Spacing ) ; } } else { if ( image W Hint > NUM && text W Hint < NUM ) { text Area Size . x = Math . max ( NUM , content Width - image Area Size . x - item . h Spacing ) ; } else if ( image W Hint < NUM && text W Hint > NUM ) { image Area Size . x = Math . max ( NUM , content Width - text Area Size . x - item . h Spacing ) ; } } image Size = compute Constrained Size ( image Size . x , image Size . y , image Area Size . x , image Area Size . y ) ; text Size = compute Constrained Size ( text Size . x , text Size . y , text Area Size . x , text Area Size . y ) ; if ( item Vertical ) { item . image Bounds . x = content X + ( content Width - image Size . x ) / NUM ; item . image Bounds . y = content Y + ( image Area Size . y - image Size . y ) / NUM ; item . text Bounds . x = content X + ( content Width - text Size . x ) / NUM ; item . text Bounds . y = content Y + ( text Area Size . y - text Size . y ) / NUM ; if ( image Leading ) { item . text Bounds . y += image Area Size . y + item . v Spacing ; } else { item . image Bounds . y += text Area Size . y + item . v Spacing ; } } else { item . image Bounds . x = content X + ( image Area Size . x - image Size . x ) / NUM ; item . image Bounds . y = content Y + ( content Height - image Size . y ) / NUM ; item . text Bounds . x = content X + ( text Area Size . x - text Size . x ) / NUM ; item . text Bounds . y = content Y + ( text Area Size . y - text Size . y ) / NUM ; if ( image Leading ) { item . text Bounds . x += image Area Size . x + item . h Spacing ; } else { item . image Bounds . x += text Area Size . x + item . h Spacing ; } } item . image Bounds . width = image Size . x ; item . image Bounds . height = image Size . y ; item . text Bounds . width = text Size . x ; item . text Bounds . height = text Size . y ; } else if ( item . image Visible ) { Point image Size = compute Image Size ( item . get Image ( ) ) ; Point constrained Size = compute Constrained Size ( image Size . x , image Size . y , content Width , content Height ) ; item . image Bounds . x = content X + ( content Width - constrained Size . x ) / NUM ; item . image Bounds . y = content Y + ( content Height - constrained Size . y ) / NUM ; item . image Bounds . width = constrained Size . x ; item . image Bounds . height = constrained Size . y ; item . text Bounds . x = NUM ; item . text Bounds . y = NUM ; item . text Bounds . width = NUM ; item . text Bounds . height = NUM ; } else if ( item . text Visible ) { Point text Size = compute Text Size ( item . get Text ( ) , item . font ) ; Point constrained Size = compute Constrained Size ( text Size . x , text Size . y , content Width , content Height ) ; item . image Bounds . x = NUM ; item . image Bounds . y = NUM ; item . image Bounds . width = NUM ; item . image Bounds . height = NUM ; item . text Bounds . x = content X + ( content Width - constrained Size . x ) / NUM ; item . text Bounds . y = content Y + ( content Height - constrained Size . y ) / NUM ; item . text Bounds . width = constrained Size . x ; item . text Bounds . height = constrained Size . y ; } else { item . image Bounds . x = NUM ; item . image Bounds . y = NUM ; item . image Bounds . width = NUM ; item . image Bounds . height = NUM ; item . text Bounds . x = NUM ; item . text Bounds . y = NUM ; item . text Bounds . width = NUM ; item . text Bounds . height = NUM ; } }
private static Map < String , Snmp Oid > build Pool Index Map ( Snmp Table Handler handler ) { if ( handler instanceof Snmp Cached Data ) return build Pool Index Map ( ( Snmp Cached Data ) handler ) ; final Map < String , Snmp Oid > m = new Hash Map < > ( ) ; Snmp Oid index = null ; while ( ( index = handler . get Next ( index ) ) != null ) { final Memory Pool MX Bean mpm = ( Memory Pool MX Bean ) handler . get Data ( index ) ; if ( mpm == null ) continue ; final String name = mpm . get Name ( ) ; if ( name == null ) continue ; m . put ( name , index ) ; } return m ; }
public D Upgrade Crypto Strength ( J Frame parent ) { super ( parent , res . get String ( STRING ) , Dialog . Modality Type . DOCUMENT MODAL ) ; init Components ( ) ; }
public static Component create Separator ( ) { J Panel p = new J Panel ( ) ; p . set Layout ( new Border Layout ( ) ) ; J Separator separator = new J Separator ( Swing Constants . HORIZONTAL ) ; p . add ( separator , Border Layout . CENTER ) ; Dimension size = new Dimension ( FULL WIDTH , NUM ) ; p . set Preferred Size ( size ) ; return p ; }
public void insert ( final T object , final int index ) { synchronized ( m Lock ) { m List . add ( index , object ) ; } notify Data Set Changed ( ) ; }
public boolean verify Signature ( byte [ ] signature ) { content Digest . do Final ( m Dash , m Dash . length - h Len - s Len ) ; try { byte [ ] b = cipher . process Block ( signature , NUM , signature . length ) ; System . arraycopy ( b , NUM , block , block . length - b . length , b . length ) ; } catch ( Exception e ) { return BOOL ; } if ( block [ block . length - NUM ] != trailer ) { clear Block ( block ) ; return BOOL ; } byte [ ] db Mask = mask Generator Function 1 ( block , block . length - h Len - NUM , h Len , block . length - h Len - NUM ) ; for ( int i = NUM ; i != db Mask . length ; i ++ ) { block [ i ] ^= db Mask [ i ] ; } block [ NUM ] &= ( NUM > > ( ( block . length * NUM ) - em Bits ) ) ; for ( int i = NUM ; i != block . length - h Len - s Len - NUM ; i ++ ) { if ( block [ i ] != NUM ) { clear Block ( block ) ; return BOOL ; } } if ( block [ block . length - h Len - s Len - NUM ] != NUM ) { clear Block ( block ) ; return BOOL ; } System . arraycopy ( block , block . length - s Len - h Len - NUM , m Dash , m Dash . length - s Len , s Len ) ; content Digest . update ( m Dash , NUM , m Dash . length ) ; content Digest . do Final ( m Dash , m Dash . length - h Len ) ; for ( int i = block . length - h Len - NUM , j = m Dash . length - h Len ; j != m Dash . length ; i ++ , j ++ ) { if ( ( block [ i ] ^ m Dash [ j ] ) != NUM ) { clear Block ( m Dash ) ; clear Block ( block ) ; return BOOL ; } } clear Block ( m Dash ) ; clear Block ( block ) ; return BOOL ; }
public static final void draw Arc ( GL 2 gl , double cx , double cy , double r , double sa , double aa ) { double t ; double x = r ; double y = NUM ; t = x ; x = Math . cos ( sa ) * x - Math . sin ( sa ) * y ; y = Math . sin ( sa ) * t + Math . cos ( sa ) * y ; double sign = Math . signum ( aa ) ; double cos = COS ; double sin = sign >= NUM ? SIN : - SIN ; gl . gl Begin ( GL . GL LINE STRIP ) ; for ( int i = NUM ; i < N ; i ++ ) { gl . gl Vertex 2 d ( x + cx , y + cy ) ; t = x ; x = cos * x - sin * y ; y = sin * t + cos * y ; if ( Math . abs ( cos * i ) >= Math . abs ( aa ) ) break ; } gl . gl End ( ) ; }
public static void open Imdb For Person ( Context context , String name ) { if ( context == null || Text Utils . is Empty ( name ) ) { return ; } Intent intent = new Intent ( Intent . ACTION VIEW , Uri . parse ( String . format ( IMDB APP PERSON SEARCH URI , name ) ) ) ; intent . add Flags ( Intent . FLAG ACTIVITY CLEAR WHEN TASK RESET ) ; if ( ! Utils . try Start Activity ( context , intent ) ) { intent = new Intent ( Intent . ACTION VIEW , Uri . parse ( String . format ( IMDB PERSON SEARCH URL , name ) ) ) ; intent . add Flags ( Intent . FLAG ACTIVITY CLEAR WHEN TASK RESET ) ; context . start Activity ( intent ) ; } }
public static int round ( final float x ) { final int bits = Float . float To Raw Int Bits ( x ) ; final int biased Exp = ( bits > > NUM ) & NUM ; final int shift = ( NUM - NUM + Float . MAX EXPONENT ) - biased Exp ; if ( ( shift & - NUM ) == NUM ) { int extended Mantissa = NUM | ( bits & NUM ) ; if ( bits < NUM ) { extended Mantissa = - extended Mantissa ; } return ( ( extended Mantissa > > shift ) + NUM ) > > NUM ; } else { return ( int ) x ; } }
public static Plain Text plain ( byte text ) { return plain ( Integer . to String ( text ) ) ; }
@ POST @ Consumes ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Check Permission ( roles = { Role . TENANT ADMIN } , acls = { ACL . OWN } ) @ Path ( STRING ) public Catalog Service Rest Rep create Catalog Service ( Catalog Service Create Param create Param ) { Storage OS User user = get User From Context ( ) ; Catalog Category parent Catalog Category = catalog Category Manager . get Catalog Category By Id ( create Param . get Catalog Category ( ) ) ; verify Authorized In Tenant Org ( uri ( parent Catalog Category . get Tenant ( ) ) , user ) ; validate Param ( create Param , null ) ; Catalog Service catalog Service = create New Object ( create Param , parent Catalog Category ) ; List < Catalog Service Field > catalog Service Fields = create New Object List ( catalog Service , create Param . get Catalog Service Fields ( ) ) ; catalog Service Manager . create Catalog Service ( catalog Service , catalog Service Fields ) ; audit Op Success ( Operation Type Enum . CREATE CATALOG SERVICE , catalog Service . audit Parameters ( ) ) ; catalog Service = catalog Service Manager . get Catalog Service By Id ( catalog Service . get Id ( ) ) ; catalog Service Fields = catalog Service Manager . get Catalog Service Fields ( catalog Service . get Id ( ) ) ; Service Descriptor service Descriptor = get Service Descriptor ( catalog Service ) ; return map ( catalog Service , service Descriptor , catalog Service Fields ) ; }
public static synchronized void fit ( String description , Unsafe Block block ) { fit ( description , identity ( ) , block ) ; }
public static boolean make Dirs For File ( final File file ) { if ( file == null ) return BOOL ; Log . d ( STRING , STRING + file + STRING + file . is Directory ( ) ) ; final String file Parent Dir = file . get Parent ( ) ; final File file Dir = Text Utils . is Empty ( file Parent Dir ) ? null : new File ( file . get Parent ( ) ) ; boolean is Succeed = file Dir == null || file Dir . exists ( ) ; if ( is Succeed ) Log . d ( STRING , STRING + file Dir + STRING + is Succeed ) ; if ( ! is Succeed && file Dir != null ) { is Succeed = file Dir . mkdirs ( ) ; Log . d ( STRING , STRING + file Dir + STRING + is Succeed ) ; } return is Succeed ; }
public static String to String ( int [ ] oid ) { String Builder sb = new String Builder ( NUM * oid . length ) ; for ( int i = NUM ; i < oid . length - NUM ; ++ i ) { sb . append ( oid [ i ] ) ; sb . append ( STRING ) ; } sb . append ( oid [ oid . length - NUM ] ) ; return sb . to String ( ) ; }
private static void initialize ( ) { if ( ! initialized ) { try { String admin DN = ( String ) Access Controller . do Privileged ( new Admin DN Action ( ) ) ; String admin Password = ( String ) Access Controller . do Privileged ( new Admin Password Action ( ) ) ; SSO Token Manager mgr = SSO Token Manager . get Instance ( ) ; Service Config Manager scm = new Service Config Manager ( SERVICE NAME , mgr . create SSO Token ( new Auth Principal ( admin DN ) , admin Password ) ) ; if ( ! added Listener ) { added Listener = BOOL ; scm . add Listener ( new Admin Interface Utils ( ) ) ; } Service Config global Config = scm . get Global Config ( null ) ; Service Config templates Config = global Config . get Sub Config ( TEMPLATES ) ; Service Config struct Template Sub Config = templates Config . get Sub Config ( STRUCTURE TEMPLATES ) ; Service Config group Cont Config = struct Template Sub Config . get Sub Config ( GCCREATE ATTR NAME ) ; Service Config people Cont Config = struct Template Sub Config . get Sub Config ( PCCREATE ATTR NAME ) ; Service Config org Admin Config = struct Template Sub Config . get Sub Config ( ORG ADMIN ATTR NAME ) ; Service Config help Desk Admin Config = struct Template Sub Config . get Sub Config ( HELP DESK ADMIN ATTR NAME ) ; Service Config policy Admin Config = struct Template Sub Config . get Sub Config ( POLICY ADMIN ATTR NAME ) ; default GC Create During Org Config = get Config Attribute Value ( group Cont Config , default GC Create During Org Config ) ; default PC Create During Org Config = get Config Attribute Value ( people Cont Config , default PC Create During Org Config ) ; default ORGADMIN = get Config Attribute Value ( org Admin Config , default ORGADMIN ) ; default HELP DESK ADMIN = get Config Attribute Value ( help Desk Admin Config , default HELP DESK ADMIN ) ; default POLICY ADMIN = get Config Attribute Value ( policy Admin Config , default POLICY ADMIN ) ; Service Schema Manager sm = new Service Schema Manager ( CONSOLE SERVICE NAME , mgr . create SSO Token ( new Auth Principal ( admin DN ) , admin Password ) ) ; if ( ! added Listener ) { added Listener = BOOL ; sm . add Listener ( new Admin Interface Utils ( ) ) ; } Service Schema schema = sm . get Global Schema ( ) ; default AC = get Attribute Value ( schema , AC ATTR NAME , default AC ) ; default GC = get Attribute Value ( schema , GC ATTR NAME , default GC ) ; default PC = get Attribute Value ( schema , PC ATTR NAME , default PC ) ; } catch ( Exception e ) { debug . warning ( STRING + STRING + STRING + STRING , e ) ; } if ( debug . message Enabled ( ) ) { debug . message ( STRING + default PC + STRING + default GC + STRING + default AC + STRING + default PC Create During Org Config + STRING + default GC Create During Org Config + STRING + default ORGADMIN + STRING + default HELP DESK ADMIN + STRING + default POLICY ADMIN ) ; } initialized = BOOL ; } }
public void read ( Byte Code Parser in ) throws IO Exception { int length = in . read Int ( ) ; int exn Count = in . read Short ( ) ; for ( int i = NUM ; i < exn Count ; i ++ ) { int index = in . read Short ( ) ; if ( index == NUM ) { methods . add ( null ) ; } } }
void add String ( int c ) { if ( strpos == str . length ) { char newstr [ ] = new char [ str . length * NUM ] ; System . arraycopy ( str , NUM , newstr , NUM , str . length ) ; str = newstr ; } str [ strpos ++ ] = ( char ) c ; }
public final void compute Index ( ) { if ( index Computed ) { return ; } List < Long > cell List = Lists . new Array List ( ) ; List < Integer > edge List = Lists . new Array List ( ) ; for ( int i = NUM ; i < get Num Edges ( ) ; ++ i ) { S2 Point from = edge From ( i ) ; S2 Point to = edge To ( i ) ; Array List < S2 Cell Id > cover = Lists . new Array List ( ) ; int level = get Covering ( from , to , BOOL , cover ) ; minimum S 2 Level Used = Math . min ( minimum S 2 Level Used , level ) ; for ( S2 Cell Id cell Id : cover ) { cell List . add ( cell Id . id ( ) ) ; edge List . add ( i ) ; } } cells = new long [ cell List . size ( ) ] ; edges = new int [ edge List . size ( ) ] ; for ( int i = NUM ; i < cells . length ; i ++ ) { cells [ i ] = cell List . get ( i ) ; edges [ i ] = edge List . get ( i ) ; } sort Index ( ) ; index Computed = BOOL ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return IM TRUE ; case NUM : return IM FALSE ; default : return null ; } }
private URL check URL ( URL url ) { String protocol = url . get Protocol ( ) ; if ( protocol == null ) { throw new Repository Exception ( repository Name , STRING + url + STRING ) ; } for ( String supported Protocol : supported Protocols ) { if ( supported Protocol . equals ( protocol ) ) { try { if ( URI Pattern . match ( url White List , url . to URI ( ) ) ) { return url ; } } catch ( URI Syntax Exception ex ) { logger . warn ( STRING , url ) ; throw new Repository Exception ( repository Name , STRING + url + STRING ) ; } URL normalized Url = environment . resolve Repo URL ( url ) ; if ( normalized Url == null ) { logger . warn ( STRING , url , environment . repo Files ( ) ) ; throw new Repository Exception ( repository Name , STRING + url + STRING ) ; } return normalized Url ; } } throw new Repository Exception ( repository Name , STRING + protocol + STRING + url + STRING ) ; }
protected I Java Element Delta [ ] grow And Add To Array ( I Java Element Delta [ ] array , I Java Element Delta addition ) { I Java Element Delta [ ] old = array ; array = new I Java Element Delta [ old . length + NUM ] ; System . arraycopy ( old , NUM , array , NUM , old . length ) ; array [ old . length ] = addition ; return array ; }
@ Override public String to String ( ) { if ( get User Object ( ) instanceof Tv Show ) { Tv Show tv Show = ( Tv Show ) get User Object ( ) ; return tv Show . get Title ( ) ; } return super . to String ( ) ; }
public boolean is Empty ( ) { return hmap . is Empty ( ) ; }
public static String geometry To WKB ( Geometry g , Coordinate Transformation transformation ) { String Builder wkb = new String Builder ( BIG ENDIAN ) ; if ( g instanceof Point ) { wkb . append ( WKB POINT ) ; } else if ( g instanceof Line String ) { wkb . append ( WKB LINE STRING ) ; } else if ( g instanceof Multi Line String ) { wkb . append ( WKB MULTI LINE STRING ) ; } for ( Coordinate coordinate : g . get Coordinates ( ) ) { Coord c = transformation . transform ( MGC . coordinate 2 Coord ( coordinate ) ) ; wkb . append ( Long . to Hex String ( Double . double To Raw Long Bits ( c . get X ( ) ) ) ) ; wkb . append ( Long . to Hex String ( Double . double To Raw Long Bits ( c . get Y ( ) ) ) ) ; } return wkb . to String ( ) ; }
protected String use Associator ( Instances data ) throws Exception { Associator associator = null ; try { associator = Abstract Associator . make Copy ( m Associator ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + e ) ; } associator . build Associations ( data ) ; return associator . to String ( ) ; }
public Phone Durations Impl ( URL url ) throws IO Exception { Buffered Reader reader ; String line ; phone Durations = new Hash Map ( ) ; reader = new Buffered Reader ( new Input Stream Reader ( url . open Stream ( ) ) ) ; line = reader . read Line ( ) ; while ( line != null ) { if ( ! line . starts With ( STRING ) ) { parse And Add ( line ) ; } line = reader . read Line ( ) ; } reader . close ( ) ; }
public static int parse Int Default ( final String s , final int def ) { if ( s == null ) { return def ; } int r ; try { r = Integer . parse Int ( s ) ; } catch ( final Number Format Exception e ) { r = def ; } return r ; }
public Profile import Profile ( Profile profile ) throws Business Exception , JAXB Exception , IO Exception { if ( null == profile . get Id ( ) ) { throw new Business Exception ( STRING + profile . get Name ( ) + STRING , Configuration Interface Error Code Enum . IMPORT DATA NOT VALID ) ; } profile . set Import Date ( new Date ( ) ) ; if ( existing Profiles . contains Key ( profile . get Id ( ) ) ) { Profile old = existing Profiles . replace ( profile . get Id ( ) , profile ) ; Files . delete If Exists ( path Resolver . get Profile File Path ( old ) ) ; } else { existing Profiles . put ( profile . get Id ( ) , profile ) ; } save Profile ( profile ) ; return profile ; }
public static void write Tag Dict ( final Map < String , Collection < Category > > tag Dict , final File file ) throws File Not Found Exception , Unsupported Encoding Exception { final Print Writer writer = new Print Writer ( file , STRING ) ; for ( final java . util . Map . Entry < String , Collection < Category > > entry : tag Dict . entry Set ( ) ) { writer . print ( entry . get Key ( ) ) ; for ( final Category c : entry . get Value ( ) ) { writer . print ( STRING + c . to String ( ) ) ; } writer . println ( ) ; } writer . close ( ) ; }
public static void create Views ( List < Block > blocks , Block View Factory view Factory , Connection Manager connection Manager , Workspace View workspace View ) { for ( int i = NUM ; i < blocks . size ( ) ; i ++ ) { workspace View . add View ( view Factory . build Block Group Tree ( blocks . get ( i ) , connection Manager , null ) ) ; } }
protected void clear All Data ( SSO Token ID token ID ) { boolean removed = BOOL ; String key = token ID . to String ( ) ; synchronized ( map Token I Ds ) { removed = ( map Token I Ds . remove ( key ) != null ) ; } }
public D Netscape Ca Policy Url ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public File Operation Failed Exception ( String operation , String entity , String name ) { super ( String . format ( error Message , operation , entity , name ) ) ; }
public void close ( ) { if ( null != input Stream Reader ) { Carbon Util . close Streams ( input Stream Reader ) ; } }
public static final void shuffle ( double [ ] a , int start , int len , Random r ) { for ( int i = start + len ; i > NUM ; -- i ) { double t = a [ i ] ; int j = r . next Int ( i ) ; a [ i ] = a [ j ] ; a [ j ] = t ; } }
public SIP Header parse SIP Header ( String header ) throws Parse Exception { int start = NUM ; int end = header . length ( ) - NUM ; try { while ( header . char At ( start ) <= NUM ) start ++ ; while ( header . char At ( end ) <= NUM ) end -- ; } catch ( Array Index Out Of Bounds Exception e ) { throw new Parse Exception ( STRING , NUM ) ; } String Buffer buffer = new String Buffer ( end + NUM ) ; int i = start ; int line Start = start ; boolean end Of Line = BOOL ; while ( i <= end ) { char c = header . char At ( i ) ; if ( c == STRING || c == STRING ) { if ( ! end Of Line ) { buffer . append ( header . substring ( line Start , i ) ) ; end Of Line = BOOL ; } } else { if ( end Of Line ) { end Of Line = BOOL ; if ( c == STRING || c == STRING ) { buffer . append ( STRING ) ; line Start = i + NUM ; } else { line Start = i ; } } } i ++ ; } buffer . append ( header . substring ( line Start , i ) ) ; buffer . append ( STRING ) ; Header Parser hp = Parser Factory . create Parser ( buffer . to String ( ) ) ; if ( hp == null ) throw new Parse Exception ( STRING , NUM ) ; return hp . parse ( ) ; }
private static int convert Linear RG Bto SRGB ( int color ) { float input , output ; input = color / NUM ; if ( input <= NUM ) { output = input * NUM ; } else { output = ( NUM * ( ( float ) Math . pow ( input , ( NUM / NUM ) ) ) ) - NUM ; } return Math . round ( output * NUM ) ; }
public void record End ( long metric , boolean success ) { final String msg = STRING + m Module Name + STRING + m Run Id + STRING + metric + STRING + success ; m Usage Messages . add ( msg ) ; Diagnostic . developer Log ( msg ) ; m Client . record End ( metric , m Module Name , m Run Id , success ) ; }
static float rotate X ( float pX , float pY , float cX , float cY , float angle In Degrees ) { double angle = Math . to Radians ( angle In Degrees ) ; return ( float ) ( Math . cos ( angle ) * ( pX - cX ) - Math . sin ( angle ) * ( pY - cY ) + cX ) ; }
public boolean is Pronounceable ( String word ) { String lower Case Word = word . to Lower Case ( ) ; if ( prefix FSM == null || suffix FSM == null ) { throw new Error ( STRING ) ; } else { return ( prefix FSM . accept ( lower Case Word ) && suffix FSM . accept ( lower Case Word ) ) ; } }
public void compute Edge Ends ( Edge edge , List l ) { Edge Intersection List ei List = edge . get Edge Intersection List ( ) ; ei List . add Endpoints ( ) ; Iterator it = ei List . iterator ( ) ; Edge Intersection ei Prev = null ; Edge Intersection ei Curr = null ; if ( ! it . has Next ( ) ) return ; Edge Intersection ei Next = ( Edge Intersection ) it . next ( ) ; do { ei Prev = ei Curr ; ei Curr = ei Next ; ei Next = null ; if ( it . has Next ( ) ) ei Next = ( Edge Intersection ) it . next ( ) ; if ( ei Curr != null ) { create Edge End For Prev ( edge , l , ei Curr , ei Prev ) ; create Edge End For Next ( edge , l , ei Curr , ei Next ) ; } } while ( ei Curr != null ) ; }
@ Override public void trim ( Memory Trim Type trim Type ) { Array List < Entry < K , V > > old Entries ; final double trim Ratio = m Cache Trim Strategy . get Trim Ratio ( trim Type ) ; synchronized ( this ) { int target Cache Size = ( int ) ( m Cached Entries . get Size In Bytes ( ) * ( NUM - trim Ratio ) ) ; int target Eviction Queue Size = Math . max ( NUM , target Cache Size - get In Use Size In Bytes ( ) ) ; old Entries = trim Exclusively Owned Entries ( Integer . MAX VALUE , target Eviction Queue Size ) ; make Orphans ( old Entries ) ; } maybe Close ( old Entries ) ; maybe Notify Exclusive Entry Removal ( old Entries ) ; maybe Update Cache Params ( ) ; maybe Evict Entries ( ) ; }
public synchronized void update Line Width If Necessary ( int logical Line , int width In Pixels ) { if ( logical Line < my Line Widths . size ( ) ) { int current Width = my Line Widths . get ( logical Line ) ; if ( width In Pixels > current Width ) { my Line Widths . set ( logical Line , width In Pixels ) ; } if ( width In Pixels > my Max Width ) { my Max Width = width In Pixels ; } max Calculated Line = Math . max ( max Calculated Line , logical Line ) ; } }
public void enable Export ( boolean b ) { export Item . set Enabled ( b ) ; }
public void mouse Exited ( Mouse Event e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( get ID ( ) + STRING ) ; } super . mouse Exited ( e ) ; if ( the Map == e . get Source ( ) ) { auto Zoom = BOOL ; point 2 = null ; the Map . repaint ( ) ; } }
public Nutch Document filter ( Nutch Document doc , String url , Web Page page ) throws Indexing Exception { for ( Indexing Filter indexing Filter : indexing Filters ) { doc = indexing Filter . filter ( doc , url , page ) ; if ( doc == null ) return null ; } return doc ; }
public Ids Query Builder add Ids ( Collection < String > ids ) { values . add All ( ids ) ; return this ; }
private void skip ( Http Servlet Request request , Http Servlet Response response ) throws IO Exception { Print Writer out = response . get Writer ( ) ; String label = request . get Parameter ( STRING ) ; Monitor mon = remove Mon ( label , null , DEFAULT UNITS ) ; if ( mon == null ) { out . println ( ERROR + STRING ) ; } else { mon . skip ( ) ; out . println ( OK + STRING + mon ) ; } }
private static URI fix Uri ( URI uri 0 , Configuration cfg ) { if ( uri 0 == null ) return File System . get Default Uri ( cfg ) ; String scheme = uri 0 . get Scheme ( ) ; String authority = uri 0 . get Authority ( ) ; if ( authority == null ) { URI dflt Uri = File System . get Default Uri ( cfg ) ; if ( scheme == null || ( scheme . equals ( dflt Uri . get Scheme ( ) ) && dflt Uri . get Authority ( ) != null ) ) return dflt Uri ; } return uri 0 ; }
public Hessian Debug Output Stream ( Output Stream os , Print Writer dbg ) { os = os ; state = new Hessian Debug State ( dbg ) ; }
public void commit ( ) throws JMS Exception { ensure Open ( ) ; ensure TX ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + tx ) ; } try { send Messages ( this . sent Messages , tx ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + tx ) ; } commit Local Transaction ( ) ; renew Transaction ( ) ; } catch ( JMS Exception mf E ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STRING , mf E ) ; logger . log ( Level . SEVERE , STRING + tx ) ; } try { rollback ( ) ; } catch ( JMS Exception e ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STRING + tx , e ) ; } } Transaction Rolled Back Exception tE = new Transaction Rolled Back Exception ( STRING ) ; tE . set Linked Exception ( mf E ) ; throw tE ; } catch ( Transaction Exception te ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STRING , te ) ; logger . log ( Level . SEVERE , STRING + tx ) ; } try { rollback ( ) ; } catch ( JMS Exception e ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STRING + tx , e ) ; } } Transaction Rolled Back Exception e = new Transaction Rolled Back Exception ( STRING ) ; e . set Linked Exception ( te ) ; throw e ; } catch ( Remote Exception re ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STRING , re ) ; logger . log ( Level . SEVERE , STRING + tx ) ; } try { rollback ( ) ; } catch ( JMS Exception e ) { } Transaction Rolled Back Exception e = new Transaction Rolled Back Exception ( STRING ) ; e . set Linked Exception ( re ) ; throw e ; } catch ( Commit Failed Exception cfe ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STRING , cfe . orig ) ; logger . log ( Level . SEVERE , STRING + tx ) ; } try { rollback ( ) ; } catch ( JMS Exception e ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STRING + tx , e ) ; } } Transaction Rolled Back Exception e = new Transaction Rolled Back Exception ( STRING + tx + STRING ) ; e . set Linked Exception ( cfe . orig ) ; throw e ; } catch ( Transaction Create Exception tce ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STRING , tce . orig ) ; logger . log ( Level . SEVERE , STRING + tx ) ; } JMS Exception e = new JMS Exception ( STRING ) ; e . set Linked Exception ( tce . orig ) ; throw e ; } finally { sent Messages . clear ( ) ; unacked Messages . clear ( ) ; } }
public void delete On Query ( final Token Filter filter ) throws Core Token Exception , Illegal Argument Exception { filter . add Return Attribute ( Core Token Field . TOKEN ID ) ; Result Handler < Collection < Partial Token > , Core Token Exception > handler = handler Factory . get Delete On Query Handler ( ) ; try { attribute Query With Handler ( filter , handler ) ; } catch ( Core Token Exception e ) { throw new Query Failed Exception ( filter , e ) ; } }
public List < Boundary > populate Locations ( final Long area Id ) { List < Boundary > location List = new Linked List < Boundary > ( ) ; try { location List = boundary Service . get Child Boundaries By Boundary Id ( area Id ) ; } catch ( final Exception e ) { LOGGER . error ( STRING + e . get Message ( ) ) ; throw new Application Runtime Exception ( STRING , e ) ; } LOGGER . info ( STRING + location List . to String ( ) ) ; return location List ; }
private static String read Name ( byte data [ ] , int offset , Hash Set < Integer > jumps ) throws IO Exception { int c = data [ offset ] & NUM ; if ( ( c & NUM ) == NUM ) { c = ( ( c & NUM ) << NUM ) + ( data [ offset + NUM ] & NUM ) ; if ( jumps . contains ( c ) ) { throw new Dns Exception ( STRING , STRING ) ; } jumps . add ( c ) ; return read Name ( data , c , jumps ) ; } if ( c == NUM ) { return STRING ; } String s = new String ( data , offset + NUM , c ) ; String t = read Name ( data , offset + NUM + c , jumps ) ; if ( t . length ( ) > NUM ) { s = s + STRING + t ; } return s ; }
public Simple String [ ] split ( final char delim ) { List < Simple String > all = null ; byte low = ( byte ) ( delim & NUM ) ; byte high = ( byte ) ( delim > > NUM & NUM ) ; int las Pos = NUM ; for ( int i = NUM ; i < data . length ; i += NUM ) { if ( data [ i ] == low && data [ i + NUM ] == high ) { byte [ ] bytes = new byte [ i - las Pos ] ; System . arraycopy ( data , las Pos , bytes , NUM , bytes . length ) ; las Pos = i + NUM ; if ( all == null ) { all = new Array List < > ( NUM ) ; } all . add ( new Simple String ( bytes ) ) ; } } if ( all == null ) { return new Simple String [ ] { this } ; } else { byte [ ] bytes = new byte [ data . length - las Pos ] ; System . arraycopy ( data , las Pos , bytes , NUM , bytes . length ) ; all . add ( new Simple String ( bytes ) ) ; Simple String [ ] parts = new Simple String [ all . size ( ) ] ; return all . to Array ( parts ) ; } }
public void add Node ( List Item item ) { if ( item != null ) { if ( m tree . is Product ( ) ) { M Tree Node PR node = new M Tree Node PR ( m tree , item . id ) ; node . save Ex ( ) ; } else if ( m tree . is B Partner ( ) ) { M Tree Node BP node = new M Tree Node BP ( m tree , item . id ) ; node . save Ex ( ) ; } else if ( m tree . is Menu ( ) ) { M Tree Node MM node = new M Tree Node MM ( m tree , item . id ) ; node . save Ex ( ) ; } else { M Tree Node node = new M Tree Node ( m tree , item . id ) ; node . save Ex ( ) ; } } }
public void incr Stats ( Collection < Graph Node > nodes ) { total Count += nodes . size ( ) ; for ( Graph Node node : nodes ) { Element Kind Descriptor descr = find Descriptor ( node ) ; if ( null == descr ) { other Count ++ ; } else { int count = kind Counts . get ( descr ) ; kind Counts . put ( descr , count + NUM ) ; } } }
public void add To Global Blacklist ( String host , long timeout ) { if ( is Global Blacklist Enabled ( ) ) { synchronized ( global Blacklist ) { global Blacklist . put ( host , timeout ) ; } } }
public boolean add ( Tcp Discovery Node node ) { assert node != null ; assert node . internal Order ( ) > NUM ; rw Lock . write Lock ( ) . lock ( ) ; try { if ( nodes Map . contains Key ( node . id ( ) ) ) return BOOL ; long max Internal Order 0 = max Internal Order ( ) ; assert node . internal Order ( ) > max Internal Order 0 : STRING + STRING + this + STRING + node + STRING ; nodes Map . put ( node . id ( ) , node ) ; nodes = new Tree Set < > ( nodes ) ; node . last Update Time ( U . current Time Millis ( ) ) ; nodes . add ( node ) ; node Order = node . internal Order ( ) ; max Internal Order = node . internal Order ( ) ; initialize Minimum Version ( ) ; } finally { rw Lock . write Lock ( ) . unlock ( ) ; } return BOOL ; }
public double convexity Bias ( final double future Price , final double t , final double T , final double sigma , final double a ) { QL . require ( future Price >= NUM , STRING ) ; QL . require ( t >= NUM , STRING ) ; QL . require ( T >= t , STRING ) ; QL . require ( a >= NUM , STRING ) ; final double delta T = ( T - t ) ; final double temp Delta T = ( NUM - Math . exp ( - a * delta T ) ) / a ; final double half Sigma Square = sigma * sigma / NUM ; final double lambda = half Sigma Square * ( NUM - Math . exp ( - NUM * a * t ) ) / a * temp Delta T * temp Delta T ; final double temp T = ( NUM - Math . exp ( - a * t ) ) / a ; final double phi = half Sigma Square * temp Delta T * temp T * temp T ; final double z = lambda + phi ; final double future Rate = ( NUM - future Price ) / NUM ; return ( NUM - Math . exp ( - z ) ) * ( future Rate + NUM / ( T - t ) ) ; }
private boolean replace Bad Entry ( K Bucket Entry entry ) { List < K Bucket Entry > entries Ref = entries ; for ( int i = NUM , n = entries Ref . size ( ) ; i < n ; i ++ ) { K Bucket Entry e = entries Ref . get ( i ) ; if ( e . needs Replacement ( ) ) { modify Main Bucket ( e , entry ) ; return BOOL ; } } return BOOL ; }
public void paint Tabbed Pane Tab Background ( Synth Context context , Graphics g , int x , int y , int w , int h , int tab Index , int orientation ) { if ( orientation == J Tabbed Pane . LEFT ) { Affine Transform transform = new Affine Transform ( ) ; transform . scale ( - NUM , NUM ) ; transform . rotate ( Math . to Radians ( NUM ) ) ; paint Background ( context , g , y , x , h , w , transform ) ; } else if ( orientation == J Tabbed Pane . RIGHT ) { Affine Transform transform = new Affine Transform ( ) ; transform . rotate ( Math . to Radians ( NUM ) ) ; transform . translate ( NUM , - ( x + w ) ) ; paint Background ( context , g , y , NUM , h , w , transform ) ; } else if ( orientation == J Tabbed Pane . BOTTOM ) { Affine Transform transform = new Affine Transform ( ) ; transform . translate ( x , y ) ; transform . scale ( NUM , - NUM ) ; transform . translate ( NUM , - h ) ; paint Background ( context , g , NUM , NUM , w , h , transform ) ; } else { paint Background ( context , g , x , y , w , h , null ) ; } }
public static boolean is Supported RP Remove Protection Virtual Pool Change ( Volume volume , Virtual Pool current Vpool , Virtual Pool new Vpool , Db Client db Client , String Buffer not Supp Reason Buff ) { s logger . info ( String . format ( STRING , current Vpool . get Label ( ) , new Vpool . get Label ( ) ) ) ; if ( is Same Virtual Pool ( current Vpool , new Vpool , not Supp Reason Buff ) ) { return BOOL ; } if ( volume . check For Rp ( ) && Virtual Pool . v Pool Specifies Protection ( current Vpool ) && ! Virtual Pool . v Pool Specifies Protection ( new Vpool ) ) { List < String > excluded = new Array List < String > ( ) ; String [ ] exclude = new String [ ] { PROTECTION VARRAY SETTINGS , RP RPO VALUE , RP RPO TYPE , RP COPY MODE , ARRAY INFO , DRIVE TYPE , JOURNAL SIZE , JOURNAL VARRAY , JOURNAL VPOOL , MULTI VOLUME CONSISTENCY , METROPOINT , STANDBY JOURNAL VARRAY , STANDBY JOURNAL VPOOL } ; excluded . add All ( Arrays . as List ( exclude ) ) ; excluded . add All ( Arrays . as List ( GENERALLY EXCLUDED ) ) ; Map < String , Change > changes = analyze Changes ( current Vpool , new Vpool , null , excluded . to Array ( exclude ) , null ) ; if ( ! changes . is Empty ( ) ) { not Supp Reason Buff . append ( STRING ) ; fill In Not Supported Reasons ( changes , not Supp Reason Buff ) ; s logger . info ( STRING + STRING , not Supp Reason Buff . to String ( ) ) ; return BOOL ; } } else { s logger . warn ( STRING ) ; return BOOL ; } s logger . info ( STRING ) ; return BOOL ; }
private void read Object ( Object Input Stream ois ) throws Class Not Found Exception , IO Exception { ois . default Read Object ( ) ; boolean has Font = ois . read Boolean ( ) ; if ( has Font ) { String name = ( String ) ois . read Object ( ) ; int size = ois . read Int ( ) ; int style = ois . read Int ( ) ; f = new Font ( name , style , size ) ; } else { f = OM Text . DEFAULT FONT ; } stroke = read Stroke ( ois , OM Graphic . BASIC STROKE ) ; text Matte Stroke = read Stroke ( ois , DEFAULT TEXT MATTE STROKE ) ; }
public String format Amt ( final String amt , final String amt In ) { Big Decimal ammt = new Big Decimal ( NUM ) ; Number Format formatter ; formatter = new Decimal Format ( STRING ) ; final int val = amt In . equals Ignore Case ( STRING ) ? NUM : amt In . equals Ignore Case ( STRING ) ? NUM : NUM ; switch ( val ) { case NUM : ammt = Big Decimal . value Of ( Double . parse Double ( amt ) / NUM ) ; ammt = ammt . set Scale ( NUM , Big Decimal . ROUND HALF UP ) ; break ; case NUM : ammt = Big Decimal . value Of ( Double . parse Double ( amt ) / NUM ) ; ammt = ammt . set Scale ( NUM , Big Decimal . ROUND HALF UP ) ; break ; default : ammt = Big Decimal . value Of ( Double . value Of ( amt ) ) ; Big Decimal tmp Amt = new Big Decimal ( ammt . to Big Integer ( ) ) ; tmp Amt = tmp Amt . add ( Big Decimal . value Of ( NUM ) ) ; if ( ammt . double Value ( ) > tmp Amt . double Value ( ) ) ammt = ammt . set Scale ( NUM , Big Decimal . ROUND HALF UP ) ; } return formatter . format ( Double . value Of ( ammt . to String ( ) ) ) ; }
public static double overlap ( Spatial Comparable box 1 , Spatial Comparable box 2 ) { final int dim = assert Same Dimensionality ( box 1 , box 2 ) ; double omax , omin ; double overlap = NUM ; for ( int i = NUM ; i < dim ; i ++ ) { omax = Math . min ( box 1 . get Max ( i ) , box 2 . get Max ( i ) ) ; omin = Math . max ( box 1 . get Min ( i ) , box 2 . get Min ( i ) ) ; if ( omax <= omin ) { return NUM ; } overlap *= omax - omin ; } return overlap ; }
private void reset Combo ( ) { Object old Choice = null ; if ( requestors != null ) { old Choice = requestors . get Selected Item ( ) ; Action Listener [ ] actions = requestors . get Action Listeners ( ) ; for ( int loop = NUM ; loop < actions . length ; loop ++ ) { requestors . remove Action Listener ( actions [ loop ] ) ; } requestors . remove All Items ( ) ; for ( Drawing Tool Requestor requestor : drawing Tool Requestors ) { requestors . add Item ( requestor . get Name ( ) ) ; } if ( old Choice != null ) { requestors . set Selected Item ( old Choice ) ; } for ( int loop = NUM ; loop < actions . length ; loop ++ ) { requestors . add Action Listener ( actions [ loop ] ) ; } set Current Requestor ( ( String ) requestors . get Selected Item ( ) ) ; } create Button . set Enabled ( drawing Tool Requestors != null && ! drawing Tool Requestors . is Empty ( ) ) ; }
protected final void load To Have At Least ( int min Available ) throws IO Exception { if ( input Stream == null ) { throw construct Error ( STRING + min Available + STRING ) ; } int amount = input End - input Ptr ; if ( amount > NUM && input Ptr > NUM ) { curr Input Processed += input Ptr ; System . arraycopy ( input Buffer , input Ptr , input Buffer , NUM , amount ) ; input End = amount ; } else { input End = NUM ; } input Ptr = NUM ; while ( input End < min Available ) { int count = input Stream . read ( input Buffer , input End , input Buffer . length - input End ) ; if ( count < NUM ) { close Input ( ) ; if ( count == NUM ) { throw new IO Exception ( STRING + amount + STRING ) ; } throw construct Error ( STRING + min Available + STRING + min Available + STRING ) ; } input End += count ; } }
public Serial Message ( byte [ ] a , int l ) { super ( String . value Of ( a ) ) ; set Response Length ( l ) ; set Binary ( BOOL ) ; }
private Workflow . Method create Import Copy Method ( URI vplex URI , List < Volume Descriptor > volume Descriptors , URI project URI , URI tenant URI ) { return new Workflow . Method ( IMPORT COPY METHOD NAME , vplex URI , volume Descriptors , project URI , tenant URI ) ; }
public static String unify Line Separators ( String s ) { return unify Line Separators ( s , System . get Property ( STRING ) ) ; }
public boolean outer Class Has Annotation ( Annotation annotation ) { Class < ? > outer = type . get Declaring Class ( ) ; while ( outer != null ) { Annotation Accessor accessor = new Annotation Accessor ( supported Annotations , outer , ignore Annotation Failure ) ; if ( accessor . type Has ( annotation ) ) { return BOOL ; } outer = outer . get Declaring Class ( ) ; } return BOOL ; }
private String build Tool Tip ( final List < Navi Node > nodes ) { final String Builder tooltip = new String Builder ( STRING ) ; boolean first = BOOL ; for ( final Navi Node graph Node : nodes ) { if ( ! first ) { tooltip . append ( STRING ) ; } tooltip . append ( C Nodes Display String . get Display String ( graph Node ) ) ; first = BOOL ; } return tooltip + STRING ; }
protected static double compute H ( Double Array dist i , double [ ] pij row , double mbeta ) { final int len = dist i . size ( ) ; assert ( pij row . length == len ) ; double sum P = NUM ; for ( int j = NUM ; j < len ; j ++ ) { sum P += ( pij row [ j ] = Math . exp ( dist i . get ( j ) * mbeta ) ) ; } if ( ! ( sum P > NUM ) ) { return Double . NEGATIVE INFINITY ; } final double s = NUM / sum P ; double sum = NUM ; for ( int j = NUM ; j < len ; j ++ ) { sum += dist i . get ( j ) * ( pij row [ j ] *= s ) ; } return Math . log ( sum P ) - mbeta * sum ; }
public boolean add On Item Click Listener ( On Item Click Listener item Click Listener ) { return click Listeners . add ( item Click Listener ) ; }
@ Override int look For Selectable Position ( int position , boolean look Down ) { final List Adapter adapter = m Adapter ; if ( adapter == null || is In Touch Mode ( ) ) { return INVALID POSITION ; } final int count = adapter . get Count ( ) ; if ( ! m Are All Items Selectable ) { if ( look Down ) { position = Math . max ( NUM , position ) ; while ( position < count && ! adapter . is Enabled ( position ) ) { position ++ ; } } else { position = Math . min ( position , count - NUM ) ; while ( position >= NUM && ! adapter . is Enabled ( position ) ) { position -- ; } } if ( position < NUM || position >= count ) { return INVALID POSITION ; } return position ; } else { if ( position < NUM || position >= count ) { return INVALID POSITION ; } return position ; } }
public static String pad Left ( final String s , final int length ) { final int pad = length - s . length ( ) ; return pad > NUM ? get Space String ( pad ) + s : s ; }
public static String retrieve Generic Display Name ( String id , int style , Locale locale ) { String [ ] names = retrieve Display Names Impl ( id , locale ) ; if ( Objects . non Null ( names ) ) { return names [ NUM - style ] ; } else { return null ; } }
public static boolean is Cache Safe ( Class < ? > clazz , Class Loader class Loader ) { Assert . not Null ( clazz , STRING ) ; try { Class Loader target = clazz . get Class Loader ( ) ; if ( target == null ) { return BOOL ; } Class Loader cur = class Loader ; if ( cur == target ) { return BOOL ; } while ( cur != null ) { cur = cur . get Parent ( ) ; if ( cur == target ) { return BOOL ; } } return BOOL ; } catch ( Security Exception ex ) { return BOOL ; } }
public void write ( Print Stream out ) { out . println ( STRING ) ; write ( out , first Capitalized ) ; out . println ( STRING ) ; write ( out , not First Capitalized ) ; out . println ( STRING ) ; write ( out , table ) ; }
private int epoch Day To Epoch Month ( int epoch Day ) { int ndx = Arrays . binary Search ( hijrah Epoch Month Start Days , epoch Day ) ; if ( ndx < NUM ) { ndx = - ndx - NUM ; } return ndx ; }
private Object Stream Class read Class Desc ( boolean unshared ) throws IO Exception { byte tc = bin . peek Byte ( ) ; Object Stream Class descriptor ; switch ( tc ) { case TC NULL : descriptor = ( Object Stream Class ) read Null ( ) ; break ; case TC REFERENCE : descriptor = ( Object Stream Class ) read Handle ( unshared ) ; break ; case TC PROXYCLASSDESC : descriptor = read Proxy Desc ( unshared ) ; break ; case TC CLASSDESC : descriptor = read Non Proxy Desc ( unshared ) ; break ; default : throw new Stream Corrupted Exception ( String . format ( STRING , tc ) ) ; } if ( descriptor != null ) { validate Descriptor ( descriptor ) ; } return descriptor ; }
public static void register Mbeans ( M Bean Server m Bean Server ) { try { m Bean Server . register M Bean ( new Log 4 j MX Bean Imp ( ) , Log 4 j MX Bean Imp . get Object Name ( ) ) ; m Bean Server . register M Bean ( new Exception MX Bean Imp ( ) , Exception MX Bean Imp . get Object Name ( ) ) ; m Bean Server . register M Bean ( new Exception Delta MX Bean Imp ( ) , Exception Delta MX Bean Imp . get Object Name ( ) ) ; m Bean Server . register M Bean ( new Log 4 j Delta MX Bean Imp ( ) , Log 4 j Delta MX Bean Imp . get Object Name ( ) ) ; m Bean Server . register M Bean ( new Jamon MX Bean Imp ( ) , Jamon MX Bean Imp . get Object Name ( ) ) ; m Bean Server . register M Bean ( new Http Status MX Bean Imp ( ) , Http Status MX Bean Imp . get Object Name ( ) ) ; m Bean Server . register M Bean ( new Http Status Delta MX Bean Imp ( ) , Http Status Delta MX Bean Imp . get Object Name ( ) ) ; register Gc MX Bean ( m Bean Server ) ; register Mbeans From Props File ( m Bean Server ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Override void check After Unmarshalled ( ) { super . check After Unmarshalled ( ) ; assert Equals ( short Val . short Value ( ) , NUM ) ; assert Equals ( long Val , NUM ) ; assert Null ( a Arr ) ; assert Equals ( double Val , NUM ) ; }
@ Override public < R , A > Completable Future < R > collect ( final Collector < ? super T , A , R > collector ) { return Completable Future . supply Async ( null ) ; }
@ Suppress Warnings ( STRING ) private Object from Reflection Type ( final Object value ) { Field Descriptor descriptor = get Descriptor ( ) ; if ( descriptor . is Repeated ( ) ) { if ( descriptor . get Java Type ( ) == Field Descriptor . Java Type . MESSAGE || descriptor . get Java Type ( ) == Field Descriptor . Java Type . ENUM ) { final List result = new Array List ( ) ; for ( final Object element : ( List ) value ) { result . add ( singular From Reflection Type ( element ) ) ; } return result ; } else { return value ; } } else { return singular From Reflection Type ( value ) ; } }
public static void add Builder To Project ( I Project project , String builder Id ) throws Core Exception { if ( has Builder ( project , builder Id ) ) { return ; } I Project Description description = project . get Description ( ) ; List < I Command > builders = new Array List < I Command > ( Arrays . as List ( description . get Build Spec ( ) ) ) ; I Command new Builder = description . new Command ( ) ; new Builder . set Builder Name ( builder Id ) ; builders . add ( new Builder ) ; description . set Build Spec ( builders . to Array ( new I Command [ builders . size ( ) ] ) ) ; project . set Description ( description , null ) ; }
public static void show Reil Code ( final Window parent , final I Navi Code Node code Node ) { try { C Reil Instruction Dialog . show ( parent , code Node ) ; } catch ( final Internal Translation Exception exception ) { C Utility Functions . log Exception ( exception ) ; final String message = STRING + STRING ; final String description = C Utility Functions . create Description ( String . format ( STRING , code Node . get Address ( ) ) , new String [ ] { STRING } , new String [ ] { STRING + STRING } ) ; Navi Error Dialog . show ( parent , message , description , exception ) ; } }
public static String to String ( Reader reader , boolean buffered ) throws IO Exception { String Writer sw = new String Writer ( NUM ) ; if ( buffered ) copy ( to Buffered Reader ( reader ) , sw , - NUM ) ; else copy ( reader , sw , - NUM ) ; sw . close ( ) ; return sw . to String ( ) ; }
private int compute Number Of Letters In Perfect Overlap ( Lane i Lane , Lane j Lane ) { final int first Coordinate = Math . max ( i Lane . get First Non Gap Position ( ) , j Lane . get First Non Gap Position ( ) ) ; final int last Coordinate = Math . min ( i Lane . get Last Non Gap Position ( ) , j Lane . get Last Non Gap Position ( ) ) ; int count = NUM ; for ( int i = first Coordinate ; i < last Coordinate ; i ++ ) { char i Char = Character . to Lower Case ( i Lane . char At ( i ) ) ; char j Char = Character . to Lower Case ( j Lane . char At ( i ) ) ; if ( i Char != j Char && i Char != STRING && j Char != STRING ) return NUM ; else if ( Character . is Letter ( i Char ) ) count ++ ; } return count ; }
public void close ( ) throws IO Exception { if ( channel != null ) { if ( ! readonly ) { channel . force ( BOOL ) ; channel . truncate ( next Overflow Data ) ; } channel . close ( ) ; } if ( file != null ) { file . close ( ) ; } }
public String prep Operand ( String label , Data Type dt , Value Type vt ) { String Builder sb = new String Builder ( ) ; sb . append ( label ) ; sb . append ( Lop . DATATYPE PREFIX ) ; sb . append ( dt ) ; sb . append ( Lop . VALUETYPE PREFIX ) ; sb . append ( vt ) ; return sb . to String ( ) ; }
public static List < Point 2 D > divide Conquer Brownian Bridge ( double D , Point 2 D t0 y 0 , Point 2 D t1 y 1 , int depth , Space Time Rejector 1 D rejector ) { List < Point 2 D > points = new Linked List < Point 2 D > ( ) ; points . add ( t0 y 0 ) ; points . add ( t1 y 1 ) ; divide Conquer Brownian Bridge ( D , NUM , points , depth , rejector ) ; return points ; }
public static String which Doctype Public ( Document doc ) { Document Type doctype ; doctype = doc . get Doctype ( ) ; if ( doctype != null ) { try { return doctype . get Public Id ( ) ; } catch ( Error except ) { } } if ( doc instanceof HTML Document ) return DTD . XHTML Public Id ; return null ; }
protected List < Individual < A > > next Generation ( List < Individual < A > > population , Fitness Function < A > fitness Fn ) { List < Individual < A > > new Population = new Array List < Individual < A > > ( population . size ( ) ) ; for ( int i = NUM ; i < population . size ( ) ; i ++ ) { Individual < A > x = random Selection ( population , fitness Fn ) ; Individual < A > y = random Selection ( population , fitness Fn ) ; Individual < A > child = reproduce ( x , y ) ; if ( random . next Double ( ) <= mutation Probability ) { child = mutate ( child ) ; } new Population . add ( child ) ; } notify Progress Tracers ( get Iterations ( ) , population ) ; return new Population ; }
protected int draw Selected Text ( Graphics g , int x , int y , int p0 , int p1 ) throws Bad Location Exception { g . set Color ( selected ) ; Container c = get Container ( ) ; if ( c instanceof J Password Field ) { J Password Field f = ( J Password Field ) c ; if ( ! f . echo Char Is Set ( ) ) { return super . draw Selected Text ( g , x , y , p0 , p1 ) ; } char echo Char = f . get Echo Char ( ) ; int n = p1 - p0 ; for ( int i = NUM ; i < n ; i ++ ) { x = draw Echo Character ( g , x , y , echo Char ) ; } } return x ; }
public void handle Button 1 Request ( Request Invocation Event event ) throws Model Control Exception { submit Cycle = BOOL ; RM Realm Model model = ( RM Realm Model ) get Model ( ) ; String realm = ( String ) get Page Session Attribute ( AM Admin Constants . CURRENT REALM ) ; AM Property Sheet ps = ( AM Property Sheet ) get Child ( REALM PROPERTIES ) ; try { Map orig = model . get Attribute Values ( realm ) ; Map values = ps . get Attribute Values ( orig , BOOL , BOOL , model ) ; model . set Attribute Values ( realm , values ) ; set Inline Alert Message ( CC Alert . TYPE INFO , STRING , STRING ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } forward To ( ) ; }
private void add Minimized Section ( Composite parent , Form Toolkit toolkit , String section Title , int num Colums ) { Section section = toolkit . create Section ( parent , Expandable Composite . TITLE BAR | Expandable Composite . TWISTIE ) ; section . set Text ( section Title ) ; section . set Layout Data ( new Grid Data ( SWT . FILL , SWT . FILL , BOOL , BOOL ) ) ; Composite section Composite = toolkit . create Composite ( section ) ; Grid Layout grid Layout = new Grid Layout ( num Colums , BOOL ) ; grid Layout . margin Left = NUM ; grid Layout . margin Top = NUM ; section Composite . set Layout ( grid Layout ) ; section . set Client ( section Composite ) ; if ( ! minimized Sections . contains Key ( section Title ) ) { minimized Sections . put ( section Title , section Composite ) ; } }
public Jenkins Http Client ( URI uri ) { this . context = uri . get Path ( ) ; if ( ! context . ends With ( STRING ) ) { context += STRING ; } this . uri = uri ; this . mapper = get Default Mapper ( ) ; Http Params http Parameters = new Basic Http Params ( ) ; Http Connection Params . set Connection Timeout ( http Parameters , NUM ) ; Http Connection Params . set So Timeout ( http Parameters , NUM ) ; this . client = new Default Http Client ( new Pooling Client Connection Manager ( ) , http Parameters ) ; }
public ISO 9796 d 2 Signer ( Asymmetric Block Cipher cipher , Digest digest , boolean implicit ) { this . cipher = cipher ; this . digest = digest ; if ( implicit ) { trailer = TRAILER IMPLICIT ; } else { Integer trailer Obj = ( Integer ) trailer Map . get ( digest . get Algorithm Name ( ) ) ; if ( trailer Obj != null ) { trailer = trailer Obj . int Value ( ) ; } else { throw new Illegal Argument Exception ( STRING ) ; } } }
public final Pdf Object read Reference Table ( final Pdf Object linear Obj , final Pdf File Reader current Pdf File , final Object Reader object Reader ) throws Pdf Exception { int pointer = - NUM ; final int eof = ( int ) this . eof ; boolean islinearized Compressed = BOOL ; if ( linear Obj == null ) { pointer = read First Start Ref ( ) ; } else { final byte [ ] data = pdf datafile . get Pdf Buffer ( ) ; final int count = data . length ; int ptr = NUM ; for ( int i = NUM ; i < count ; i ++ ) { if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { ptr = i + NUM ; } if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { pointer = i ; i = count ; } else if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { islinearized Compressed = BOOL ; pointer = ptr ; while ( data [ pointer ] == NUM || data [ pointer ] == NUM || data [ pointer ] == NUM ) { pointer ++ ; } i = count ; } } } offset . add Xref ( pointer ) ; Pdf Object root Obj = null ; if ( pointer >= eof || pointer == NUM ) { Log Writer . write Log ( STRING ) ; offset . set Ref Table Invalid ( BOOL ) ; try { root Obj = new Page Object ( Broken Ref Table . find Offsets ( pdf datafile , offset ) ) ; } catch ( Error err ) { throw new Pdf Exception ( err . get Message ( ) + STRING ) ; } current Pdf File . read Object ( root Obj ) ; return root Obj ; } else if ( islinearized Compressed || is Compressed Stream ( pointer , eof ) ) { return read Compressed Stream ( root Obj , pointer , current Pdf File , object Reader , linear Obj ) ; } else { return read Legacy Reference Table ( root Obj , pointer , eof , current Pdf File ) ; } }
public static < T > List < T > find All ( final Collection < T > collection , final Filter < T > filter ) { final List < T > matches = new Array List < T > ( collection . size ( ) ) ; for ( final T element : collection ) { if ( filter . accept ( element ) ) { matches . add ( element ) ; } } return matches ; }
public static boolean is Samsung ( ) { return s Build Model . starts With ( STRING ) || s Build Model . contains ( STRING ) || s Build Model . starts With ( STRING ) || s Build Model . starts With ( STRING ) || s Build Model . starts With ( STRING ) ; }
private boolean do Character AVM ( int position ) throws Solver Timeout Exception { checkpoint Var ( Distance Estimator . get Distance ( cnstr ) ) ; boolean done = BOOL ; boolean has Improved = BOOL ; while ( ! done ) { if ( is Finished ( ) ) { throw new Solver Timeout Exception ( ) ; } done = BOOL ; String orig String = str Var . get Concrete Value ( ) ; char old Char = orig String . char At ( position ) ; char [ ] characters = orig String . to Char Array ( ) ; char replacement = old Char ; replacement = next Char ( replacement , NUM ) ; characters [ position ] = replacement ; String new String = new String ( characters ) ; str Var . set Concrete Value ( new String ) ; double new Dist = Distance Estimator . get Distance ( cnstr ) ; log . debug ( STRING + position + STRING + new String + STRING + new Dist + STRING + ( int ) replacement ) ; if ( dist Impr ( new Dist ) ) { checkpoint Var ( new Dist ) ; if ( new Dist == NUM ) return BOOL ; done = BOOL ; has Improved = BOOL ; iterate Character AVM ( position , NUM ) ; } else { replacement = next Char ( replacement , - NUM ) ; characters [ position ] = replacement ; new String = new String ( characters ) ; str Var . set Concrete Value ( new String ) ; new Dist = Distance Estimator . get Distance ( cnstr ) ; log . debug ( STRING + position + STRING + new String + STRING + new Dist + STRING + ( int ) replacement ) ; if ( dist Impr ( new Dist ) ) { checkpoint Var ( new Dist ) ; if ( new Dist == NUM ) return BOOL ; done = BOOL ; has Improved = BOOL ; iterate Character AVM ( position , - NUM ) ; } else { replacement = ( char ) ( old Char + NUM ) ; characters [ position ] = replacement ; new String = new String ( characters ) ; str Var . set Concrete Value ( new String ) ; new Dist = Distance Estimator . get Distance ( cnstr ) ; log . debug ( STRING + position + STRING + new String + STRING + new Dist + STRING + ( int ) replacement ) ; if ( dist Impr ( new Dist ) ) { checkpoint Var ( new Dist ) ; done = BOOL ; has Improved = BOOL ; break ; } else { replacement = ( char ) ( old Char + NUM ) ; characters [ position ] = replacement ; new String = new String ( characters ) ; str Var . set Concrete Value ( new String ) ; new Dist = Distance Estimator . get Distance ( cnstr ) ; log . debug ( STRING + position + STRING + new String + STRING + new Dist + STRING + ( int ) replacement ) ; if ( dist Impr ( new Dist ) ) { checkpoint Var ( new Dist ) ; done = BOOL ; has Improved = BOOL ; } else { restore Var ( ) ; } } if ( done ) log . debug ( STRING + position + STRING + new String + STRING + new Dist ) ; else log . debug ( STRING + position ) ; } } } return has Improved ; }
private Concurrent Skip List Map . Node < K , V > lo Node ( ) { if ( lo == null ) return m . find First ( ) ; else if ( lo Inclusive ) return m . find Near ( lo , GT | EQ ) ; else return m . find Near ( lo , GT ) ; }
public String to String ( int num Sets ) { if ( m sets . size ( ) == NUM ) { return STRING ; } String Buffer result = new String Buffer ( ) ; result . append ( STRING + m sets . size ( ) + STRING ) ; if ( num Sets > NUM ) { result . append ( STRING + num Sets ) ; } result . append ( STRING ) ; int count = NUM ; for ( Frequent Binary Item Set i : m sets ) { if ( num Sets > NUM && count > num Sets ) { break ; } result . append ( i . to String ( ) + STRING ) ; count ++ ; } return result . to String ( ) ; }
protected Shape create Shape ( int [ ] x Points , int [ ] y Points , int n Points , boolean close , boolean biased ) { float offset = biased ? ( float ) bias : NUM ; General Path path = new General Path ( General Path . WIND EVEN ODD ) ; if ( n Points > NUM ) { path . move To ( x Points [ NUM ] + offset , y Points [ NUM ] + offset ) ; int last X = x Points [ NUM ] ; int last Y = y Points [ NUM ] ; if ( close && ( Math . abs ( x Points [ n Points - NUM ] - last X ) < NUM ) && ( Math . abs ( y Points [ n Points - NUM ] - last Y ) < NUM ) ) { n Points -- ; } for ( int i = NUM ; i < n Points ; i ++ ) { if ( ( Math . abs ( x Points [ i ] - last X ) > NUM ) || ( Math . abs ( y Points [ i ] - last Y ) > NUM ) ) { path . line To ( x Points [ i ] + offset , y Points [ i ] + offset ) ; last X = x Points [ i ] ; last Y = y Points [ i ] ; } } if ( close ) path . close Path ( ) ; } return path ; }
protected int map Drag Operation From Modifiers ( Mouse Event e ) { int mods = e . get Modifiers Ex ( ) ; int btns = mods & Button Mask ; if ( ! ( btns == Input Event . BUTTON 1 DOWN MASK || btns == Input Event . BUTTON 2 DOWN MASK || btns == Input Event . BUTTON 3 DOWN MASK ) ) { return Dn D Constants . ACTION NONE ; } return Sun Drag Source Context Peer . convert Modifiers To Drop Action ( mods , get Source Actions ( ) ) ; }
public On Update Clause add Assignment ( Expression expression ) { assignments . add ( new Assignment ( expression ) ) ; return this ; }
public static Remote Views create Remote Views ( Context context , boolean show Play Icon ) { Remote Views remote Views = new Remote Views ( context . get Package Name ( ) , R . layout . remote view ) ; int icon Res = show Play Icon ? R . drawable . ic play : R . drawable . ic stop ; remote Views . set Image View Resource ( R . id . play pause , icon Res ) ; return remote Views ; }
public void remove Selection Listener ( final Network Selection Listener l ) { listener List . remove ( Network Selection Listener . class , l ) ; }
protected final void run On Ui Thread ( @ Non Null Runnable runnable ) { if ( Looper . my Looper ( ) == Looper . get Main Looper ( ) ) { runnable . run ( ) ; } else { m Poster . post ( runnable ) ; } }
public void initialize ( Map config Params ) throws Policy Exception { if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STRING + STRING ) ; } if ( config Params == null ) { throw ( new Policy Exception ( Res Bundle Utils . rb Name , STRING , null , null ) ) ; } Set org Name Set = ( Set ) config Params . get ( Policy Manager . ORGANIZATION NAME ) ; if ( ( org Name Set != null ) && ( ! org Name Set . is Empty ( ) ) ) { Iterator items = org Name Set . iterator ( ) ; org Name = ( String ) items . next ( ) ; } valid Dynamic Attr Names = ( Set ) config Params . get ( Policy Config . SELECTED DYNAMIC ATTRIBUTES ) ; if ( valid Dynamic Attr Names == null ) { valid Dynamic Attr Names = Collections . EMPTY SET ; } initialized = BOOL ; if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STRING + STRING + STRING + org Name + STRING + valid Dynamic Attr Names ) ; } }
public void remove NX Warrant ( Warrant w ) { w . remove Property Change Listener ( this ) ; war List . remove ( w ) ; war NX . remove ( w ) ; manager . deregister ( w ) ; w . dispose ( ) ; }
public void add Command To Side Menu ( Command cmd ) { check If Initialized ( ) ; if ( permanent Side Menu ) { construct Permanent Side Menu ( ) ; Button b = new Button ( cmd ) ; b . set Ends With 3 Points ( BOOL ) ; Integer gap = ( Integer ) cmd . get Client Property ( STRING ) ; if ( gap != null ) { b . set Gap ( gap . int Value ( ) ) ; } b . set Text Position ( Label . RIGHT ) ; String uiid = ( String ) cmd . get Client Property ( STRING ) ; if ( uiid != null ) { b . set UIID ( uiid ) ; } else { b . set UIID ( STRING ) ; } add Component To Side Menu ( permanent Side Menu Container , b ) ; } else { side Menu . add Command ( cmd ) ; side Menu . install Menu Bar ( ) ; } }
public boolean connect ( final String address ) { if ( m Bluetooth Adapter == null || address == null ) { Log . w ( TAG , STRING ) ; return BOOL ; } if ( m Bluetooth Device Address != null && address . equals ( m Bluetooth Device Address ) && m Bluetooth Gatt != null ) { Log . d ( TAG , STRING ) ; if ( m Bluetooth Gatt . connect ( ) ) { m Connection State = STATE CONNECTING ; return BOOL ; } else { return BOOL ; } } final Bluetooth Device device = m Bluetooth Adapter . get Remote Device ( address ) ; if ( device == null ) { Log . d ( TAG , STRING ) ; return BOOL ; } m Bluetooth Gatt = device . connect Gatt ( this , BOOL , m Gatt Callback ) ; Log . d ( TAG , STRING ) ; m Bluetooth Device Address = address ; m Connection State = STATE CONNECTING ; return BOOL ; }
private double log Normal Dens ( double x , double mean , double std Dev ) { double diff = x - mean ; return - ( diff * diff / ( NUM * std Dev * std Dev ) ) - m norm Const - Math . log ( std Dev ) ; }
public Shape inverse Transform ( Shape shape ) { General Path new Path = new General Path ( ) ; float [ ] coords = new float [ NUM ] ; for ( Path Iterator iterator = shape . get Path Iterator ( null ) ; iterator . is Done ( ) == BOOL ; iterator . next ( ) ) { int type = iterator . current Segment ( coords ) ; switch ( type ) { case Path Iterator . SEG MOVETO : Point 2 D p = inverse Transform ( new Point 2 D . Float ( coords [ NUM ] , coords [ NUM ] ) ) ; new Path . move To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) ) ; break ; case Path Iterator . SEG LINETO : p = inverse Transform ( new Point 2 D . Float ( coords [ NUM ] , coords [ NUM ] ) ) ; new Path . line To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) ) ; break ; case Path Iterator . SEG QUADTO : p = inverse Transform ( new Point 2 D . Float ( coords [ NUM ] , coords [ NUM ] ) ) ; Point 2 D q = inverse Transform ( new Point 2 D . Float ( coords [ NUM ] , coords [ NUM ] ) ) ; new Path . quad To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) , ( float ) q . get X ( ) , ( float ) q . get Y ( ) ) ; break ; case Path Iterator . SEG CUBICTO : p = inverse Transform ( new Point 2 D . Float ( coords [ NUM ] , coords [ NUM ] ) ) ; q = inverse Transform ( new Point 2 D . Float ( coords [ NUM ] , coords [ NUM ] ) ) ; Point 2 D r = inverse Transform ( new Point 2 D . Float ( coords [ NUM ] , coords [ NUM ] ) ) ; new Path . curve To ( ( float ) p . get X ( ) , ( float ) p . get Y ( ) , ( float ) q . get X ( ) , ( float ) q . get Y ( ) , ( float ) r . get X ( ) , ( float ) r . get Y ( ) ) ; break ; case Path Iterator . SEG CLOSE : new Path . close Path ( ) ; break ; } } return new Path ; }
private void clear Context ( Context context ) throws Naming Exception { for ( Naming Enumeration e = context . list Bindings ( STRING ) ; e . has More Elements ( ) ; ) { Binding binding = ( Binding ) e . next Element ( ) ; if ( binding . get Object ( ) instanceof Context ) { clear Context ( ( Context ) binding . get Object ( ) ) ; } context . unbind ( binding . get Name ( ) ) ; } }
public void start ( final Input Stream in ) throws SAX Exception , IO Exception , Parser Configuration Exception { SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; SAX Parser sax Parser = factory . new SAX Parser ( ) ; sax Parser . parse ( in , this ) ; }
public static Collection < String > string 2 Collection ( String in , String delimiter , boolean do Strip , Collection < String > collection ) { if ( in == null ) { return null ; } if ( collection == null ) { collection = new Array List < String > ( ) ; } if ( delimiter == null || delimiter . length ( ) == NUM ) { collection . add ( in ) ; return collection ; } int from Index = NUM ; int pos ; while ( ( pos = in . index Of ( delimiter , from Index ) ) >= NUM ) { String interim = in . substring ( from Index , pos ) ; if ( do Strip ) { interim = strip ( interim ) ; } if ( ! do Strip || interim . length ( ) > NUM ) { collection . add ( interim ) ; } from Index = pos + delimiter . length ( ) ; } String interim = in . substring ( from Index ) ; if ( do Strip ) { interim = strip ( interim ) ; } if ( ! do Strip || interim . length ( ) > NUM ) { collection . add ( interim ) ; } return collection ; }
public static String encode Base 64 ( byte [ ] input ) { return Datatype Converter . print Base 64 Binary ( input ) ; }
protected void handle Premove Drop ( int from Square , int to Square ) { Premove Info premove Info = new Premove Info ( ) ; premove Info . is Premove Drop = BOOL ; premove Info . to Square = to Square ; premove Info . from Square = from Square ; premove Info . from Piece = Chess Board Utils . piece Jail Square To Piece ( from Square ) ; premoves . add ( premove Info ) ; adjust Premove Label Highlights And Arrows ( ) ; board . unhide Pieces ( ) ; refresh Board ( ) ; }
public static String Buffer append Number ( String Buffer result , int n , int radix , int min Digits ) throws Illegal Argument Exception { if ( radix < NUM || radix > NUM ) { throw new Illegal Argument Exception ( STRING + radix ) ; } int abs = n ; if ( n < NUM ) { abs = - n ; result . append ( STRING ) ; } recursive Append Number ( result , abs , radix , min Digits ) ; return result ; }
private void stop ( ) { if ( this . throttle == null ) { return ; } internal Adjust = BOOL ; throttle . set Speed Setting ( - NUM ) ; speed Slider . set Value ( NUM ) ; if ( speed Spinner != null ) { speed Spinner Model . set Value ( Integer . value Of ( NUM ) ) ; } if ( speed Slider Continuous != null ) { speed Slider Continuous . set Value ( Integer . value Of ( NUM ) ) ; } internal Adjust = BOOL ; }
@ Override public void on Value Selected ( int picker Index , int new Value , boolean auto Advance ) { switch ( picker Index ) { case HOUR INDEX : if ( m Allow Auto Advance && auto Advance ) { update Header Hour ( new Value , BOOL ) ; set Current Item Showing ( MINUTE INDEX , BOOL , BOOL ) ; Accessibility Utils . make Announcement ( this , new Value + STRING + m Select Minutes ) ; } else { update Header Hour ( new Value , BOOL ) ; } break ; case MINUTE INDEX : update Header Minute ( new Value , BOOL ) ; break ; case AMPM INDEX : update Am Pm Label States ( new Value ) ; break ; case ENABLE PICKER INDEX : if ( ! is Typed Time Fully Legal ( ) ) { m Typed Times . clear ( ) ; } finish Kb Mode ( ) ; break ; } if ( m On Time Changed Listener != null ) { m On Time Changed Listener . on Time Changed ( this , get Current Hour ( ) , get Current Minute ( ) ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
static String parse Prefix ( String key ) { if ( key == null ) return null ; boolean inquotes = BOOL ; for ( int i = NUM ; i < key . length ( ) ; i ++ ) { char c = key . char At ( i ) ; if ( c == STRING ) { inquotes = ! inquotes ; } else if ( ( c == STRING || c == STRING ) && ! inquotes ) { return key . substring ( NUM , i ) ; } } return null ; }
public static boolean is Hex ( String str ) { if ( str == null || str . length ( ) == NUM ) return BOOL ; for ( int i = str . length ( ) - NUM ; i >= NUM ; i -- ) { char c = str . char At ( i ) ; if ( ! ( c >= STRING && c <= STRING ) ) { c = Character . to Lower Case ( c ) ; if ( ! ( c == STRING || c == STRING || c == STRING || c == STRING || c == STRING || c == STRING ) ) return BOOL ; } } return BOOL ; }
public static double sample Kurtosis Standard Error ( int size ) { int n = size ; return Math . sqrt ( NUM * n * ( n - NUM ) * ( n - NUM ) / ( ( n - NUM ) * ( n - NUM ) * ( n + NUM ) * ( n + NUM ) ) ) ; }
public static String to String ( Policy Qualifier Info policy Qualifier Info ) throws IO Exception { String Buffer sb Policy Qualifier = new String Buffer ( ) ; ASN 1 Object Identifier policy Qualifier Id = policy Qualifier Info . get Policy Qualifier Id ( ) ; Certificate Policy Qualifier Type certificate Policy Qualifier Type = Certificate Policy Qualifier Type . resolve Oid ( policy Qualifier Id . get Id ( ) ) ; if ( certificate Policy Qualifier Type == PKIX CPS POINTER QUALIFIER ) { DERIA 5 String cps Pointer = ( ( DERIA 5 String ) policy Qualifier Info . get Qualifier ( ) ) ; sb Policy Qualifier . append ( Message Format . format ( res . get String ( STRING ) , cps Pointer ) ) ; } else if ( certificate Policy Qualifier Type == PKIX USER NOTICE QUALIFIER ) { ASN 1 Encodable user Notice Obj = policy Qualifier Info . get Qualifier ( ) ; User Notice user Notice = User Notice . get Instance ( user Notice Obj ) ; sb Policy Qualifier . append ( Message Format . format ( res . get String ( STRING ) , to String ( user Notice ) ) ) ; } return sb Policy Qualifier . to String ( ) ; }
public < CT > CT call Batch Tasks ( Database Connection connection , boolean saved , Callable < CT > callable ) throws SQL Exception { if ( database Type . is Batch Use Transaction ( ) ) { return Transaction Manager . call In Transaction ( connection , saved , database Type , callable ) ; } boolean auto Commit At Start = BOOL ; try { if ( connection . is Auto Commit Supported ( ) ) { auto Commit At Start = connection . is Auto Commit ( ) ; if ( auto Commit At Start ) { connection . set Auto Commit ( BOOL ) ; logger . debug ( STRING , table Info . get Table Name ( ) ) ; } } try { return callable . call ( ) ; } catch ( SQL Exception e ) { throw e ; } catch ( Exception e ) { throw Sql Exception Util . create ( STRING , e ) ; } } finally { if ( auto Commit At Start ) { connection . set Auto Commit ( BOOL ) ; logger . debug ( STRING , table Info . get Table Name ( ) ) ; } } }

private int find Marker Segment Position ( Class cls , boolean first ) { if ( first ) { List Iterator iter = marker Sequence . list Iterator ( ) ; for ( int i = NUM ; iter . has Next ( ) ; i ++ ) { Marker Segment seg = ( Marker Segment ) iter . next ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } else { List Iterator iter = marker Sequence . list Iterator ( marker Sequence . size ( ) ) ; for ( int i = marker Sequence . size ( ) - NUM ; iter . has Previous ( ) ; i -- ) { Marker Segment seg = ( Marker Segment ) iter . previous ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } return - NUM ; }
@ Safe Varargs protected < T extends Abstract Option Value < ? , ? > > Abstract Options ( Function < T , T > value Filter , T ... values ) { require Non Null ( value Filter , STRING ) ; require Non Null ( values , STRING ) ; value Map = new Identity Hash Map < > ( ) ; put All ( value Filter , Stream . of ( values ) ) ; }
private void create Pre Streaming Tags ( int timestamp , boolean clear ) { log . debug ( STRING ) ; if ( clear ) { first Tags . clear ( ) ; } I Tag tag = null ; Io Buffer body = null ; if ( has Video ) { body = Io Buffer . allocate ( NUM ) ; body . set Auto Expand ( BOOL ) ; body . put ( PREFIX VIDEO CONFIG FRAME ) ; if ( video Decoder Bytes != null ) { body . put ( video Decoder Bytes ) ; } tag = new Tag ( Io Constants . TYPE VIDEO , timestamp , body . position ( ) , null , NUM ) ; body . flip ( ) ; tag . set Body ( body ) ; first Tags . add ( tag ) ; } if ( has Audio ) { body = Io Buffer . allocate ( NUM ) ; body . set Auto Expand ( BOOL ) ; body . put ( new byte [ ] { ( byte ) NUM , ( byte ) NUM } ) ; if ( audio Decoder Bytes != null ) { body . put ( audio Decoder Bytes ) ; } else { body . put ( AUDIO CONFIG FRAME AAC LC ) ; } body . put ( ( byte ) NUM ) ; tag = new Tag ( Io Constants . TYPE AUDIO , timestamp , body . position ( ) , null , tag . get Body Size ( ) ) ; body . flip ( ) ; tag . set Body ( body ) ; first Tags . add ( tag ) ; } }
public static void on Pause ( ) { Log . i ( TAG , STRING ) ; dismiss Dialog ( dialog ) ; if ( timer Task Hide != null ) timer Task Hide . cancel ( ) ; if ( timer Task Show != null ) timer Task Show . cancel ( ) ; Log . i ( TAG , STRING ) ; }
public static Uri add Message To Uri ( Content Resolver resolver , Uri uri , String address , String body , String subject , Long date , boolean read , boolean delivery Report ) { return add Message To Uri ( resolver , uri , address , body , subject , date , read , delivery Report , - NUM ) ; }
public void calc Auto Scale ( ) { double max No Of Major Ticks = NUM ; double max No Of Minor Ticks = NUM ; double nice Range = ( Helper . calc Nice Number ( get Range ( ) , BOOL ) ) ; set Major Tick Space ( Helper . calc Nice Number ( nice Range / ( max No Of Major Ticks - NUM ) , BOOL ) ) ; double nice Min Value = ( Math . floor ( get Min Value ( ) / get Major Tick Space ( ) ) * get Major Tick Space ( ) ) ; double nice Max Value = ( Math . ceil ( get Max Value ( ) / get Major Tick Space ( ) ) * get Major Tick Space ( ) ) ; set Minor Tick Space ( Helper . calc Nice Number ( get Major Tick Space ( ) / ( max No Of Minor Ticks - NUM ) , BOOL ) ) ; set Min Value ( nice Min Value ) ; set Max Value ( nice Max Value ) ; }
final V replace Node ( Object key , V value , Object cv ) { int hash = spread ( key . hash Code ( ) ) ; for ( Node < K , V > [ ] tab = table ; ; ) { Node < K , V > f ; int n , i , fh ; if ( tab == null || ( n = tab . length ) == NUM || ( f = tab At ( tab , i = ( n - NUM ) & hash ) ) == null ) break ; else if ( ( fh = f . hash ) == MOVED ) tab = help Transfer ( tab , f ) ; else { V old Val = null ; boolean validated = BOOL ; synchronized ( f ) { if ( tab At ( tab , i ) == f ) { if ( fh >= NUM ) { validated = BOOL ; for ( Node < K , V > e = f , pred = null ; ; ) { K ek ; if ( e . hash == hash && ( ( ek = e . key ) == key || ( ek != null && key . equals ( ek ) ) ) ) { V ev = e . val ; if ( cv == null || cv == ev || ( ev != null && cv . equals ( ev ) ) ) { old Val = ev ; if ( value != null ) e . val = value ; else if ( pred != null ) pred . next = e . next ; else set Tab At ( tab , i , e . next ) ; } break ; } pred = e ; if ( ( e = e . next ) == null ) break ; } } else if ( f instanceof Tree Bin ) { validated = BOOL ; Tree Bin < K , V > t = ( Tree Bin < K , V > ) f ; Tree Node < K , V > r , p ; if ( ( r = t . root ) != null && ( p = r . find Tree Node ( hash , key , null ) ) != null ) { V pv = p . val ; if ( cv == null || cv == pv || ( pv != null && cv . equals ( pv ) ) ) { old Val = pv ; if ( value != null ) p . val = value ; else if ( t . remove Tree Node ( p ) ) set Tab At ( tab , i , untreeify ( t . first ) ) ; } } } } } if ( validated ) { if ( old Val != null ) { if ( value == null ) add Count ( - NUM , - NUM ) ; return old Val ; } break ; } } } return null ; }
private static final boolean copy Header ( String name , String from Req , String Builder buf ) { int start = from Req . index Of ( name ) ; if ( start != - NUM ) { int end = from Req . index Of ( STRING , start ) ; if ( end != - NUM ) { buf . append ( from Req . sub Sequence ( start - NUM , end ) ) ; return BOOL ; } } return BOOL ; }
public void send Exception ( final Exception exception , final Map < String , String > properties ) { final Property Map Builder builder = new Property Map Builder ( properties ) ; logger . debug ( String . format ( STRING , exception . get Message ( ) , builder . to String ( ) ) ) ; if ( telemetry Client != null ) { telemetry Client . track Exception ( exception , builder . build ( ) , null ) ; } }
private void analyze Seed Document ( Document input Document , Map < String , List < String [ ] > > field Name 2 tokens Array , Map < String , Float > field Name 2 boost ) throws IO Exception { for ( int i = NUM ; i < text Field Names . length ; i ++ ) { String field Name = text Field Names [ i ] ; float boost = NUM ; List < String [ ] > tokenized Values = new Linked List < > ( ) ; if ( field Name . contains ( STRING ) ) { String [ ] field 2 boost = field Name . split ( STRING ) ; field Name = field 2 boost [ NUM ] ; boost = Float . parse Float ( field 2 boost [ NUM ] ) ; } Indexable Field [ ] field Values = input Document . get Fields ( field Name ) ; for ( Indexable Field field Value : field Values ) { Token Stream field Tokens = field Value . token Stream ( field 2 analyzer . get ( field Name ) , null ) ; String [ ] field Tokens Array = get Token Array ( field Tokens ) ; tokenized Values . add ( field Tokens Array ) ; } field Name 2 tokens Array . put ( field Name , tokenized Values ) ; field Name 2 boost . put ( field Name , boost ) ; text Field Names [ i ] = field Name ; } }
public URL find Resource ( String name , boolean check ) { Loader loader ; int [ ] cache = get Lookup Cache ( name ) ; for ( int i = NUM ; ( loader = get Next Loader ( cache , i ) ) != null ; i ++ ) { URL url = loader . find Resource ( name , check ) ; if ( url != null ) { return url ; } } return null ; }
public void to EPL ( String Writer writer , EP Statement Formatter formatter ) { formatter . begin Merge When Matched ( writer ) ; if ( matched ) { writer . write ( STRING ) ; } else { writer . write ( STRING ) ; } if ( optional Condition != null ) { writer . write ( STRING ) ; optional Condition . to EPL ( writer , Expression Precedence Enum . MINIMUM ) ; } for ( On Merge Matched Action action : actions ) { formatter . begin Merge Action ( writer ) ; action . to EPL ( writer ) ; } }
public static int index Of Parenthesis Match ( String str , int first ) throws URI Syntax Exception { int index = - NUM ; if ( first < NUM || first > str . length ( ) ) { throw new Illegal Argument Exception ( STRING + first ) ; } if ( str . char At ( first ) != STRING ) { throw new Illegal Argument Exception ( STRING ) ; } int depth = NUM ; char [ ] array = str . to Char Array ( ) ; for ( index = first + NUM ; index < array . length ; ++ index ) { char current = array [ index ] ; if ( current == STRING ) { depth ++ ; } else if ( current == STRING ) { if ( -- depth == NUM ) { break ; } } } if ( depth != NUM ) { throw new URI Syntax Exception ( str , STRING ) ; } return index ; }
public void unzip Archive ( final File archive , final File output Dir ) throws IO Exception { Zip File zipfile = new Zip File ( archive , encoding ) ; for ( Enumeration e = zipfile . get Entries ( ) ; e . has More Elements ( ) ; ) { final Zip Archive Entry entry = ( Zip Archive Entry ) e . next Element ( ) ; unzip Entry ( zipfile , entry , output Dir ) ; } zipfile . close ( ) ; }
public static void create Forward ( Inet Socket Address adb Sock Addr , Device device , String local Port Spec , String remote Port Spec ) throws Timeout Exception , Adb Command Rejected Exception , IO Exception { try ( Socket Channel adb Chan = Socket Channel . open ( adb Sock Addr ) ) { adb Chan . configure Blocking ( BOOL ) ; byte [ ] request = form Adb Request ( String . format ( STRING , device . get Serial Number ( ) , local Port Spec , remote Port Spec ) ) ; write ( adb Chan , request ) ; Adb Response resp = read Adb Response ( adb Chan , BOOL ) ; if ( ! resp . okay ) { Log . w ( STRING , STRING + resp . message ) ; throw new Adb Command Rejected Exception ( resp . message ) ; } } }
public void write ( long file Offset , byte [ ] buffer , int offset , int length ) throws IO Exception { file . seek ( file Offset ) ; file . write ( buffer , offset , length ) ; }
public Tag use ( String class Name , String tag Bundle Name , String tag Bundle Version , Identification id ) throws Page Exception { Queue < Tag > queue = get Queue ( to Id ( class Name , tag Bundle Name , tag Bundle Version ) ) ; Tag tag = queue . poll ( ) ; if ( tag != null ) return tag ; return load Tag ( class Name , tag Bundle Name , tag Bundle Version , id ) ; }
public void shutdown ( Shutdown Mode Amp mode , Exit Code exit Code , String msg ) { shutdown ( mode , exit Code , msg , null ) ; }
public static int expand J Tree Node ( javax . swing . J Tree tree , javax . swing . tree . Tree Model model , Object node , int row , int depth ) { if ( node != null && ! model . is Leaf ( node ) ) { tree . expand Row ( row ) ; if ( depth != NUM ) { for ( int index = NUM ; row + NUM < tree . get Row Count ( ) && index < model . get Child Count ( node ) ; index ++ ) { row ++ ; Object child = model . get Child ( node , index ) ; if ( child == null ) break ; javax . swing . tree . Tree Path path ; while ( ( path = tree . get Path For Row ( row ) ) != null && path . get Last Path Component ( ) != child ) row ++ ; if ( path == null ) break ; row = expand J Tree Node ( tree , model , child , row , depth - NUM ) ; } } } return row ; }
public static boolean is Absolute URI ( String system Id ) { if ( is Windows Absolute Path ( system Id ) ) { return BOOL ; } final int fragment Index = system Id . index Of ( STRING ) ; final int query Index = system Id . index Of ( STRING ) ; final int slash Index = system Id . index Of ( STRING ) ; final int colon Index = system Id . index Of ( STRING ) ; int index = system Id . length ( ) - NUM ; if ( fragment Index > NUM ) index = fragment Index ; if ( ( query Index > NUM ) && ( query Index < index ) ) index = query Index ; if ( ( slash Index > NUM ) && ( slash Index < index ) ) index = slash Index ; return ( ( colon Index > NUM ) && ( colon Index < index ) ) ; }
public void invoke ( Request request , Pattern Path Router . Routable Destination < Http Resource Model > destination ) throws Exception { Object return Val = method . invoke ( handler , args ) ; return Val = invoke Sub Resource ( request , destination , return Val ) ; responder . set Entity ( return Val ) ; responder . send ( ) ; }
@ Override public void mouse Released ( Mouse Event e ) { if ( m mouse State == NUM ) { m click Available = BOOL ; } else { m click Available = BOOL ; } if ( m mouse State == NUM && mouse In Bounds ( e ) ) { m mouse State = NUM ; Dimension ns = new Dimension ( m view Size . width / NUM , m view Size . height / NUM ) ; if ( ns . width < NUM ) { ns . width = NUM ; } if ( ns . height < NUM ) { ns . height = NUM ; } Dimension d = get Size ( ) ; Dimension np = new Dimension ( ( int ) ( d . width / NUM - ( ( double ) d . width / NUM - m view Pos . width ) / NUM ) , ( int ) ( d . height / NUM - ( ( double ) d . height / NUM - m view Pos . height ) / NUM ) ) ; animate Scaling ( np , ns , NUM ) ; } else if ( m mouse State == NUM ) { m mouse State = NUM ; Graphics g = get Graphics ( ) ; if ( m Zoom Box Color == null ) { g . set Color ( Color . black ) ; } else { g . set Color ( m Zoom Box Color ) ; } if ( m Zoom Box XOR Color == null ) { g . set XOR Mode ( Color . white ) ; } else { g . set XOR Mode ( m Zoom Box XOR Color ) ; } g . draw Rect ( m old Mouse Pos . width , m old Mouse Pos . height , m new Mouse Pos . width - m old Mouse Pos . width , m new Mouse Pos . height - m old Mouse Pos . height ) ; g . dispose ( ) ; int cw = m new Mouse Pos . width - m old Mouse Pos . width ; int ch = m new Mouse Pos . height - m old Mouse Pos . height ; if ( cw >= NUM && ch >= NUM ) { if ( mouse In Bounds ( e ) && ( get Size ( ) . width / cw ) <= NUM && ( get Size ( ) . height / ch ) <= NUM ) { Dimension ns = new Dimension ( ) ; Dimension np = new Dimension ( ) ; double nvsw = get Size ( ) . width / ( double ) ( cw ) ; double nvsh = get Size ( ) . height / ( double ) ( ch ) ; np . width = ( int ) ( ( m old Mouse Pos . width - m view Pos . width ) * - nvsw ) ; np . height = ( int ) ( ( m old Mouse Pos . height - m view Pos . height ) * - nvsh ) ; ns . width = ( int ) ( m view Size . width * nvsw ) ; ns . height = ( int ) ( m view Size . height * nvsh ) ; animate Scaling ( np , ns , NUM ) ; } } } else if ( m mouse State == NUM && m scaling == NUM ) { m mouse State = NUM ; set Font ( new Font ( STRING , NUM , NUM ) ) ; int s = - NUM ; for ( int noa = NUM ; noa < m num Nodes ; noa ++ ) { if ( m nodes [ noa ] . m quad == NUM ) { calc Screen Coords ( noa ) ; if ( e . get X ( ) <= m nodes [ noa ] . m center + m nodes [ noa ] . m side && e . get X ( ) >= m nodes [ noa ] . m center - m nodes [ noa ] . m side && e . get Y ( ) >= m nodes [ noa ] . m top && e . get Y ( ) <= m nodes [ noa ] . m top + m nodes [ noa ] . m height ) { s = noa ; } m nodes [ noa ] . m top = NUM ; } } if ( s == - NUM ) { m win Menu . show ( this , e . get X ( ) , e . get Y ( ) ) ; } else { m focus Node = s ; m node Menu . show ( this , e . get X ( ) , e . get Y ( ) ) ; } set Font ( m current Font ) ; } else if ( m mouse State == NUM ) { m mouse State = NUM ; m frame Limiter . stop ( ) ; repaint ( ) ; } }
public static final Collection < Race > find Races ( String stream , Collection < Race > races ) { Collection < Race > result = new Array List < > ( ) ; for ( Race r : races ) { for ( Entrant e : r . get Entrants ( ) ) { if ( stream . equals Ignore Case ( e . twitch ) ) { result . add ( r ) ; } } } return result ; }
public boolean temporal ( ) { return parameter Metadata . contains ( Metadata . TEMPORAL ) ; }
public void register Receiver ( Broadcast Receiver receiver , Intent Filter filter ) { synchronized ( m Receivers ) { Receiver Record entry = new Receiver Record ( filter , receiver ) ; Array List < Intent Filter > filters = m Receivers . get ( receiver ) ; if ( filters == null ) { filters = new Array List < Intent Filter > ( NUM ) ; m Receivers . put ( receiver , filters ) ; } filters . add ( filter ) ; for ( int i = NUM ; i < filter . count Actions ( ) ; i ++ ) { String action = filter . get Action ( i ) ; Array List < Receiver Record > entries = m Actions . get ( action ) ; if ( entries == null ) { entries = new Array List < Receiver Record > ( NUM ) ; m Actions . put ( action , entries ) ; } entries . add ( entry ) ; } } }
public void add Reg Exp ( Reg Exp Literal re ) { if ( re == null ) code Bug ( ) ; if ( regexps == null ) regexps = new Array List < Reg Exp Literal > ( ) ; regexps . add ( re ) ; re . put Int Prop ( REGEXP PROP , regexps . size ( ) - NUM ) ; }
public void add Biome Type ( Biome Dictionary . Type type ) { Array List < Biome Gen Base > entry List = new Array List < Biome Gen Base > ( ) ; entry List . add All ( Arrays . as List ( Biome Dictionary . get Biomes For Type ( type ) ) ) ; entry List . remove ( Biome Gen Base . hell ) ; entry List . remove ( Biome Gen Base . sky ) ; Iterator < Biome Gen Base > iter = entry List . iterator ( ) ; while ( iter . has Next ( ) ) { Biome Gen Base nextbiome = iter . next ( ) ; for ( Biome Entry entry : allowed Biomes ) { if ( Biome Dictionary . are Biomes Equivalent ( entry . biome , nextbiome ) ) iter . remove ( ) ; } } allowed Biomes . add All ( get Biomes Entries ( entry List ) ) ; }
static void calculate Tiled Layout ( Layout Iterator iter , int target Span ) { long preferred = NUM ; long current Preferred ; int last Margin = NUM ; int total Spacing = NUM ; int n = iter . get Count ( ) ; int adjustment Weights Count = Layout Iterator . Worst Adjustment Weight + NUM ; long gain [ ] = new long [ adjustment Weights Count ] ; long loss [ ] = new long [ adjustment Weights Count ] ; for ( int i = NUM ; i < adjustment Weights Count ; i ++ ) { gain [ i ] = loss [ i ] = NUM ; } for ( int i = NUM ; i < n ; i ++ ) { iter . set Index ( i ) ; int margin 0 = last Margin ; int margin 1 = ( int ) iter . get Leading Collapse Span ( ) ; iter . set Offset ( Math . max ( margin 0 , margin 1 ) ) ; total Spacing += iter . get Offset ( ) ; current Preferred = ( long ) iter . get Preferred Span ( target Span ) ; iter . set Span ( ( int ) current Preferred ) ; preferred += current Preferred ; gain [ iter . get Adjustment Weight ( ) ] += ( long ) iter . get Maximum Span ( target Span ) - current Preferred ; loss [ iter . get Adjustment Weight ( ) ] += current Preferred - ( long ) iter . get Minimum Span ( target Span ) ; last Margin = ( int ) iter . get Trailing Collapse Span ( ) ; } total Spacing += last Margin ; total Spacing += NUM * iter . get Border Width ( ) ; for ( int i = NUM ; i < adjustment Weights Count ; i ++ ) { gain [ i ] += gain [ i - NUM ] ; loss [ i ] += loss [ i - NUM ] ; } int allocated = target Span - total Spacing ; long desired Adjustment = allocated - preferred ; long adjustments Array [ ] = ( desired Adjustment > NUM ) ? gain : loss ; desired Adjustment = Math . abs ( desired Adjustment ) ; int adjustment Level = NUM ; for ( ; adjustment Level <= Layout Iterator . Worst Adjustment Weight ; adjustment Level ++ ) { if ( adjustments Array [ adjustment Level ] >= desired Adjustment ) { break ; } } float adjustment Factor = NUM ; if ( adjustment Level <= Layout Iterator . Worst Adjustment Weight ) { desired Adjustment -= ( adjustment Level > NUM ) ? adjustments Array [ adjustment Level - NUM ] : NUM ; if ( desired Adjustment != NUM ) { float maximum Adjustment = adjustments Array [ adjustment Level ] - ( ( adjustment Level > NUM ) ? adjustments Array [ adjustment Level - NUM ] : NUM ) ; adjustment Factor = desired Adjustment / maximum Adjustment ; } } int total Offset = ( int ) iter . get Border Width ( ) ; for ( int i = NUM ; i < n ; i ++ ) { iter . set Index ( i ) ; iter . set Offset ( iter . get Offset ( ) + total Offset ) ; if ( iter . get Adjustment Weight ( ) < adjustment Level ) { iter . set Span ( ( int ) ( ( allocated > preferred ) ? Math . floor ( iter . get Maximum Span ( target Span ) ) : Math . ceil ( iter . get Minimum Span ( target Span ) ) ) ) ; } else if ( iter . get Adjustment Weight ( ) == adjustment Level ) { int available Span = ( allocated > preferred ) ? ( int ) iter . get Maximum Span ( target Span ) - iter . get Span ( ) : iter . get Span ( ) - ( int ) iter . get Minimum Span ( target Span ) ; int adj = ( int ) Math . floor ( adjustment Factor * available Span ) ; iter . set Span ( iter . get Span ( ) + ( ( allocated > preferred ) ? adj : - adj ) ) ; } total Offset = ( int ) Math . min ( ( long ) iter . get Offset ( ) + ( long ) iter . get Span ( ) , Integer . MAX VALUE ) ; } int round Error = target Span - total Offset - ( int ) iter . get Trailing Collapse Span ( ) - ( int ) iter . get Border Width ( ) ; int adj = ( round Error > NUM ) ? NUM : - NUM ; round Error *= adj ; boolean can Adjust = BOOL ; while ( round Error > NUM && can Adjust ) { can Adjust = BOOL ; int offset Adjust = NUM ; for ( int i = NUM ; i < n ; i ++ ) { iter . set Index ( i ) ; iter . set Offset ( iter . get Offset ( ) + offset Adjust ) ; int cur Span = iter . get Span ( ) ; if ( round Error > NUM ) { int bound Gap = ( adj > NUM ) ? ( int ) Math . floor ( iter . get Maximum Span ( target Span ) ) - cur Span : cur Span - ( int ) Math . ceil ( iter . get Minimum Span ( target Span ) ) ; if ( bound Gap >= NUM ) { can Adjust = BOOL ; iter . set Span ( cur Span + adj ) ; offset Adjust += adj ; round Error -- ; } } } } }
public static void write Padded Integer ( Writer out , int value , int size ) throws IO Exception { if ( value < NUM ) { out . write ( STRING ) ; if ( value != Integer . MIN VALUE ) { value = - value ; } else { for ( ; size > NUM ; size -- ) { out . write ( STRING ) ; } out . write ( STRING + - ( long ) Integer . MIN VALUE ) ; return ; } } if ( value < NUM ) { for ( ; size > NUM ; size -- ) { out . write ( STRING ) ; } out . write ( value + STRING ) ; } else if ( value < NUM ) { for ( ; size > NUM ; size -- ) { out . write ( STRING ) ; } int d = ( ( value + NUM ) * NUM ) > > NUM ; out . write ( d + STRING ) ; out . write ( value - ( d << NUM ) - ( d << NUM ) + STRING ) ; } else { int digits ; if ( value < NUM ) { digits = NUM ; } else if ( value < NUM ) { digits = NUM ; } else { digits = ( int ) ( Math . log ( value ) / LOG 10 ) + NUM ; } for ( ; size > digits ; size -- ) { out . write ( STRING ) ; } out . write ( Integer . to String ( value ) ) ; } }
protected Object visit ( Binary Logic Operator filter , Object extra Data ) { LOGGER . finer ( STRING ) ; final List < Filter Builder > filter List = new Array List < > ( ) ; for ( final Filter child : filter . get Children ( ) ) { child . accept ( this , extra Data ) ; filter List . add ( filter Builder ) ; } final Filter Builder [ ] filters ; filters = filter List . to Array ( new Filter Builder [ filter List . size ( ) ] ) ; if ( extra Data . equals ( STRING ) ) { filter Builder = Filter Builders . and Filter ( filters ) ; } else { filter Builder = Filter Builders . or Filter ( filters ) ; } return extra Data ; }
public static String encode Base 64 ( byte [ ] input ) { return Datatype Converter . print Base 64 Binary ( input ) ; }
void define Labels ( ) { labels Values = calc Labels ( ) ; if ( handle Values ) labels = get Labels From Values ( ) ; else labels = get Labels From Data ( ) ; n Labels = labels . size ( ) ; }
public CLIQUE Unit ( CLIQUE Interval interval ) { intervals = new Array List < > ( ) ; intervals . add ( interval ) ; ids = DBID Util . new Hash Set ( ) ; assigned = BOOL ; }
public static String take While ( G String self , @ Closure Params ( value = From String . class , conflict Resolution Strategy = Pick First Resolver . class , options = { STRING , STRING } ) Closure condition ) { return take While ( self . to String ( ) , condition ) ; }
public Topological Node ( int node ID ) { this . node ID = node ID ; node Name = String . value Of ( node ID ) ; }
public void print Text ( String text , String color ) { view . print ( text , text . ends With ( STRING ) , color ) ; for ( Action Delegate action Delegate : action Delegates ) { action Delegate . on Console Output ( this ) ; } }
protected void ensure Rows Are Visible ( int begin Row , int end Row ) { if ( tree != null && begin Row >= NUM && end Row < get Row Count ( tree ) ) { boolean scroll Vert = Default Lookup . get Boolean ( tree , this , STRING , BOOL ) ; if ( begin Row == end Row ) { Rectangle scroll Bounds = get Path Bounds ( tree , get Path For Row ( tree , begin Row ) ) ; if ( scroll Bounds != null ) { if ( ! scroll Vert ) { scroll Bounds . x = tree . get Visible Rect ( ) . x ; scroll Bounds . width = NUM ; } tree . scroll Rect To Visible ( scroll Bounds ) ; } } else { Rectangle begin Rect = get Path Bounds ( tree , get Path For Row ( tree , begin Row ) ) ; if ( begin Rect != null ) { Rectangle vis Rect = tree . get Visible Rect ( ) ; Rectangle test Rect = begin Rect ; int begin Y = begin Rect . y ; int max Y = begin Y + vis Rect . height ; for ( int counter = begin Row + NUM ; counter <= end Row ; counter ++ ) { test Rect = get Path Bounds ( tree , get Path For Row ( tree , counter ) ) ; if ( test Rect == null ) { return ; } if ( ( test Rect . y + test Rect . height ) > max Y ) counter = end Row ; } tree . scroll Rect To Visible ( new Rectangle ( vis Rect . x , begin Y , NUM , test Rect . y + test Rect . height - begin Y ) ) ; } } } }
private void divide ( DBID Array Iter it , double [ ] data , Array List < DBI Ds > idx , int start , int end , int depth , Mean mean ) { final int count = end - start ; if ( depth == NUM ) { if ( count > NUM ) { Modifiable DBI Ds out = DBID Util . new Hash Set ( count ) ; it . seek ( start ) ; for ( int i = count ; i > NUM ; i -- , it . advance ( ) ) { out . add ( it ) ; } idx . add ( out ) ; } else { idx . add ( DBID Util . EMPTYDBIDS ) ; } return ; } else { if ( count > NUM ) { mean . reset ( ) ; for ( int i = start ; i < end ; i ++ ) { mean . put ( data [ i ] ) ; } final double m = mean . get Mean ( ) ; int pos = Arrays . binary Search ( data , start , end , m ) ; if ( pos >= NUM ) { int opt = ( start + end ) > > NUM ; while ( Double . compare ( data [ pos ] , m ) == NUM ) { if ( pos < opt ) { pos ++ ; } else if ( pos > opt ) { pos -- ; } else { break ; } } } else { pos = ( - pos - NUM ) ; } divide ( it , data , idx , start , pos , depth - NUM , mean ) ; divide ( it , data , idx , pos , end , depth - NUM , mean ) ; } else { divide ( it , data , idx , start , end , depth - NUM , mean ) ; divide ( it , data , idx , start , end , depth - NUM , mean ) ; } } }
void assert Thread Stays Alive ( Thread thread , long millis ) { try { delay ( millis ) ; assert True ( thread . is Alive ( ) ) ; } catch ( Interrupted Exception fail ) { thread Fail ( STRING ) ; } }
@ Override public Ndef Message create Ndef Message ( Nfc Event event ) { Log . v ( TAG , STRING ) ; Abstract Identity id To Send = panbox . get Identity ( ) ; Log . v ( TAG , STRING + id To Send ) ; if ( id To Send == null ) { return null ; } Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; Abstract Identity Manager idm = Identity Manager Android . get Instance ( context ) ; idm . export My Identity ( id To Send , baos ) ; try { baos . flush ( ) ; baos . close ( ) ; } catch ( IO Exception e1 ) { e1 . print Stack Trace ( ) ; } byte [ ] id File Data = baos . to Byte Array ( ) ; Ndef Record record = new Ndef Record ( Ndef Record . TNF MIME MEDIA , MIME TYPE . get Bytes ( Charset . for Name ( STRING ) ) , new byte [ NUM ] , id File Data ) ; Ndef Message msg = new Ndef Message ( new Ndef Record [ ] { record } ) ; return msg ; }
@ Override public double [ ] analyse ( double [ ] frame ) { if ( frame . length != get Frame Length Samples ( ) ) throw new Illegal Argument Exception ( STRING + get Frame Length Samples ( ) + STRING + frame . length ) ; System . arraycopy ( frame , NUM , real , NUM , frame . length ) ; if ( real . length > frame . length ) Arrays . fill ( real , frame . length , real . length , NUM ) ; FFT . real Transform ( real , BOOL ) ; return FFT . compute Power Spectrum FD ( real ) ; }
public boolean move drill item ( Brd Abit p drill item , Pla Vector Int p vector , int p max recursion depth , int p max via recursion depth , int p pull tight accuracy , int p pull tight time limit ) { shove fail clear ( ) ; Collection < Brd Item > contact list = p drill item . get normal contacts ( ) ; Iterator < Brd Item > it = contact list . iterator ( ) ; while ( it . has Next ( ) ) { Brd Item curr contact = it . next ( ) ; if ( curr contact . get fixed state ( ) == Item Fix State . SHOVE FIXED ) { curr contact . set fixed state ( Item Fix State . UNFIXED ) ; } } Net Nos List net no arr = p drill item . net nos ; changed area clear ( ) ; if ( ! move drill algo . insert ( p drill item , p vector , p max recursion depth , p max via recursion depth , null ) ) { return BOOL ; } Net Nos List opt net no arr = p max recursion depth <= NUM ? net no arr : Net Nos List . EMPTY ; Time Limit Stoppable t limit = new Time Limit Stoppable ( p pull tight time limit ) ; changed area optimize ( opt net no arr , p pull tight accuracy , null , t limit , null ) ; return BOOL ; }
public X Bee Address 64 ( String address Str ) { address = new int [ NUM ] ; if ( address Str . contains ( STRING ) ) { String Tokenizer st = new String Tokenizer ( address Str , STRING ) ; for ( int i = NUM ; i < address . length ; i ++ ) { String byte Str = st . next Token ( ) ; address [ i ] = Integer . parse Int ( byte Str , NUM ) ; } } else { for ( int i = NUM ; i < address . length ; i ++ ) { address [ i ] = Integer . parse Int ( address Str . substring ( i * NUM , i * NUM + NUM ) , NUM ) ; } } }

@ Override public void draw Node ( Graphics g , int w , int h ) { if ( ( m type & PURE INPUT ) == PURE INPUT ) { g . set Color ( Color . green ) ; } else { g . set Color ( Color . orange ) ; } Font Metrics fm = g . get Font Metrics ( ) ; int l = ( int ) ( m x * w ) - fm . string Width ( m id ) / NUM ; int t = ( int ) ( m y * h ) - fm . get Height ( ) / NUM ; g . fill 3 D Rect ( l , t , fm . string Width ( m id ) + NUM , fm . get Height ( ) + fm . get Descent ( ) + NUM , BOOL ) ; g . set Color ( Color . black ) ; g . draw String ( m id , l + NUM , t + fm . get Height ( ) + NUM ) ; }
public Pla Point Int round to the right ( Pla Direction p dir ) { Pla Point Float dir = p dir . to float ( ) ; double rounded x ; if ( dir . v y > NUM ) { rounded x = Math . ceil ( v x ) ; } else if ( dir . v y < NUM ) { rounded x = Math . floor ( v x ) ; } else { rounded x = Math . round ( v x ) ; } double rounded y ; if ( dir . v x > NUM ) { rounded y = Math . floor ( v y ) ; } else if ( dir . v x < NUM ) { rounded y = Math . ceil ( v y ) ; } else { rounded y = Math . round ( v y ) ; } return new Pla Point Int ( rounded x , rounded y ) ; }
public static File extract Archive ( File archive , File destination ) { File directory = get Unique File ( destination , archive . get Name ( ) ) ; Zip File zip File = null ; try { prepare Directory ( directory ) ; zip File = new Zip File ( archive ) ; Enumeration < ? extends Zip Entry > entries = zip File . entries ( ) ; while ( entries . has More Elements ( ) ) { Zip Entry entry = entries . next Element ( ) ; File Output Stream fos = null ; Input Stream is = null ; try { is = zip File . get Input Stream ( entry ) ; fos = new File Output Stream ( new File ( directory , entry . get Name ( ) ) ) ; int bytes ; byte [ ] packet = new byte [ COPY PACKET SIZE ] ; while ( ( bytes = is . read ( packet , NUM , COPY PACKET SIZE ) ) != - NUM ) fos . write ( packet , NUM , bytes ) ; } finally { try { if ( fos != null ) fos . close ( ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , STRING , e ) ; } try { if ( is != null ) is . close ( ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , STRING , e ) ; } } } } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , STRING , e ) ; return null ; } finally { try { if ( zip File != null ) zip File . close ( ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , STRING , e ) ; } } return directory ; }
public boolean authenticate User ( String username , String password , String uri ) throws Data Access Exception { if ( null == username || null == password ) { return BOOL ; } User Info user = get User Info ( username ) ; if ( user == null ) { return BOOL ; } String hashed Salted Password = Utilities . get Salted Password ( username , uri , password ) ; return hashed Salted Password . equals ( user . get Hashed Password ( ) ) ; }
public static String dump ( final Byte Buffer bytes ) { bytes . rewind ( ) ; final int columns = NUM ; final String Builder builder = new String Builder ( ) ; int i = NUM ; while ( bytes . has Remaining ( ) ) { if ( ( i % columns ) != NUM ) { builder . append ( STRING ) ; } else if ( i >= columns ) { builder . append ( String . format ( STRING ) ) ; } builder . append ( String . format ( STRING , bytes . get ( ) ) ) ; i ++ ; } return builder . to String ( ) ; }
public static void register M Bean ( Object mbean , Class < ? > mbean Interface , String mbean Name , boolean ignored ) { M Bean Server mbs = Management Factory . get Platform M Bean Server ( ) ; try { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + mbean . get Class ( ) ) ; Object Name name = generate M Bean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; if ( mbs . is Registered ( name ) ) mbs . unregister M Bean ( name ) ; mbs . register M Bean ( mbean , name ) ; } catch ( Exception e ) { throw new Server Runtime Exception ( STRING + mbean . get Class ( ) + STRING + mbean Interface + STRING + mbean Name , e ) ; } }
public static Set < String > to String Set ( Template Collection Model coll Model ) throws Template Model Exception { Set < String > set = new Hash Set < String > ( ) ; Template Model Iterator model It = coll Model . iterator ( ) ; while ( model It . has Next ( ) ) { set . add ( get As String Non Escaping ( ( Template Scalar Model ) model It . next ( ) ) ) ; } return set ; }
public static Key Store Handler open ( final File key Store File , final char [ ] password ) throws IO Exception , Key Store Exception { if ( ! key Store File . exists ( ) ) { throw new File Not Found Exception ( key Store File . get Absolute Path ( ) ) ; } final Key Store ks = Key Store . get Instance ( Key Store Handler . KEYSTORE TYPE ) ; try ( final File Input Stream fis = new File Input Stream ( key Store File ) ) { ks . load ( fis , password ) ; return new Key Store Handler ( ks , password , key Store File , Key Store Handler . get Secret Key Factory ( ) ) ; } catch ( final No Such Algorithm Exception | Certificate Exception ex ) { throw new Illegal State Exception ( STRING , ex ) ; } }
private void save Impl ( File Location loc ) throws IO Exception { Output Stream out = loc . get Output Stream ( ) ; Print Writer w = new Print Writer ( new Buffered Writer ( new Unicode Writer ( out , get Encoding ( ) ) ) ) ; try { write ( w ) ; } finally { w . close ( ) ; } }
public void required ( int table , int field ) { int table start = bb . capacity ( ) - table ; int vtable start = table start - bb . get Int ( table start ) ; boolean ok = bb . get Short ( vtable start + field ) != NUM ; if ( ! ok ) throw new Assertion Error ( STRING + field + STRING ) ; }
public static Element select Element ( X Path Expression expr , Node context ) { try { Object result = expr . evaluate ( context , X Path Constants . NODE ) ; if ( result == null ) { return null ; } else if ( result instanceof Element ) { return ( Element ) result ; } else { throw new Xml Exception ( STRING + result ) ; } } catch ( X Path Expression Exception e ) { throw new Xml Exception ( e ) ; } }
public static Http 2 Headers to Netty Http 2 ( Http Headers input Headers ) { final Http 2 Headers output Headers = new Default Http 2 Headers ( BOOL , input Headers . size ( ) ) ; output Headers . set ( input Headers ) ; output Headers . remove ( Http Header Names . CONNECTION ) ; output Headers . remove ( Http Header Names . TRANSFER ENCODING ) ; output Headers . remove ( Http Header Names . TRAILER ) ; return output Headers ; }
public final double sample Sigma ( int n ) { synchronized ( lock ) { long count = count . get ( ) ; long last Count = last Std Count ; last Std Count = count ; double sum = sum . get ( ) ; double last Sum = last Std Sum ; last Std Sum = sum ; double sum Square = sum Square ; sum Square = NUM ; if ( count == last Count ) return NUM ; double avg = ( sum - last Sum ) / ( count - last Count ) ; double part = ( count - last Count ) * sum Square - sum * sum ; if ( part < NUM ) part = NUM ; double std = Math . sqrt ( part ) / ( count - last Count ) ; return scale * ( avg + n * std ) ; } }
void init Program ( ) { gl Use Program ( this . program ) ; view Matrix Uniform = gl Get Uniform Location ( this . program , STRING ) ; proj Matrix Uniform = gl Get Uniform Location ( this . program , STRING ) ; viewport Size Uniform = gl Get Uniform Location ( this . program , STRING ) ; gl Use Program ( NUM ) ; }
public void test Float Value Neg Infinity ( ) { String a = STRING ; Big Decimal a Number = new Big Decimal ( a ) ; float result = Float . NEGATIVE INFINITY ; assert True ( STRING , a Number . float Value ( ) == result ) ; }
public static Key Store load Keystore ( final String key Store File , final String key Store Password , final Key Store Type Enum key Store Type ) throws IO Exception , Key Store Exception , No Such Algorithm Exception , Certificate Exception { final File Input Stream input Stream = new File Input Stream ( key Store File ) ; Key Store key Store ; try { key Store = get Key Store Instance ( key Store Type ) ; key Store . load ( input Stream , key Store Password . to Char Array ( ) ) ; } finally { if ( input Stream != null ) { input Stream . close ( ) ; } } return key Store ; }
public void remove From Dragging Connections ( Block root Block ) { if ( m Pending Drag == null ) { return ; } m Temp Connections . clear ( ) ; root Block . get All Connections Recursive ( m Temp Connections ) ; for ( int i = NUM ; i < m Temp Connections . size ( ) ; i ++ ) { Connection conn = m Temp Connections . get ( i ) ; m Dragged Connections . remove ( conn ) ; conn . set Drag Mode ( BOOL ) ; } }
private void scan ( Call Graph Node node ) throws CFG Builder Exception { Method method = node . get Method ( ) ; CFG cfg = class Context . get CFG ( method ) ; if ( method . is Synchronized ( ) ) { has Synchronization = BOOL ; } Iterator < Basic Block > i = cfg . block Iterator ( ) ; while ( i . has Next ( ) ) { Basic Block block = i . next ( ) ; Iterator < Instruction Handle > j = block . instruction Iterator ( ) ; while ( j . has Next ( ) ) { Instruction Handle handle = j . next ( ) ; Instruction ins = handle . get Instruction ( ) ; if ( ins instanceof Invoke Instruction ) { Invoke Instruction inv = ( Invoke Instruction ) ins ; Method called = is Self Call ( inv ) ; if ( called != null ) { Call Site call Site = new Call Site ( method , block , handle ) ; call Graph . create Edge ( node , call Graph . get Node For Method ( called ) , call Site ) ; called Method Set . add ( called ) ; } } else if ( ins instanceof MONITORENTER || ins instanceof MONITOREXIT ) { has Synchronization = BOOL ; } } } }
public Prompting Trust Manager ( final Console Application app , final String accepted Store Path , final X509 Trust Manager source Trust Manager ) throws Key Store Exception , IO Exception , No Such Algorithm Exception , Certificate Exception { Reject . if Null ( app , accepted Store Path ) ; this . app = app ; this . nested Trust Manager = source Trust Manager ; in Memory Trust Store = Key Store . get Instance ( Key Store . get Default Type ( ) ) ; on Disk Trust Store = Key Store . get Instance ( Key Store . get Default Type ( ) ) ; final File on Disk Trust Store Path = new File ( accepted Store Path ) ; in Memory Trust Store . load ( null , null ) ; if ( ! on Disk Trust Store Path . exists ( ) ) { on Disk Trust Store . load ( null , null ) ; } else { try ( final File Input Stream fos = new File Input Stream ( on Disk Trust Store Path ) ) { on Disk Trust Store . load ( fos , DEFAULT PASSWORD ) ; } } final Trust Manager Factory tmf = Trust Manager Factory . get Instance ( Trust Manager Factory . get Default Algorithm ( ) ) ; tmf . init ( in Memory Trust Store ) ; X509 Trust Manager x509 tm = null ; for ( final Trust Manager tm : tmf . get Trust Managers ( ) ) { if ( tm instanceof X509 Trust Manager ) { x509 tm = ( X509 Trust Manager ) tm ; break ; } } if ( x509 tm == null ) { throw new No Such Algorithm Exception ( ) ; } this . in Memory Trust Manager = x509 tm ; tmf . init ( on Disk Trust Store ) ; x509 tm = null ; for ( final Trust Manager tm : tmf . get Trust Managers ( ) ) { if ( tm instanceof X509 Trust Manager ) { x509 tm = ( X509 Trust Manager ) tm ; break ; } } if ( x509 tm == null ) { throw new No Such Algorithm Exception ( ) ; } this . on Disk Trust Manager = x509 tm ; }
public Pooled Executor With DM Stats ( Blocking Queue < Runnable > q , int pool Size , Thread Factory tf ) { this ( q , pool Size , null , tf ) ; }
public final void remove Helper Text Color ( @ Color Int final int color ) { int index = helper Text Colors . index Of ( color ) ; if ( index != - NUM ) { helper Text Colors . remove ( index ) ; verify Password Strength ( ) ; } }
private void advance ( ) { next = null ; while ( it . has Next ( ) ) { Grid Cache Entry Ex entry = it . next ( ) ; try { next = to Cache Entry ( entry , deserialize Binary ) ; if ( next == null ) continue ; break ; } catch ( Ignite Checked Exception e ) { throw CU . convert To Cache Exception ( e ) ; } catch ( Grid Cache Entry Removed Exception ignore ) { } } }
List Based Token Stream ( List < Attribute Source > tokens ) { this . tokens = tokens ; token Iterator = tokens . iterator ( ) ; }
@ Override protected Class < ? > resolve Class ( Object Stream Class object Stream Class ) throws IO Exception , Class Not Found Exception { Class < ? > clazz = Class . for Name ( object Stream Class . get Name ( ) , BOOL , class Loader ) ; if ( clazz != null ) { return clazz ; } else { return super . resolve Class ( object Stream Class ) ; } }
public static int find ( byte [ ] a , int from Index , int to Index , byte key ) { int result = - NUM ; if ( from Index < NUM ) { from Index = NUM ; } to Index = Math . min ( to Index , a . length ) ; for ( int i = from Index ; from Index < to Index && result == - NUM && i < to Index ; i ++ ) { if ( a [ i ] == key ) { result = i ; } } return result ; }
public Collection < Graph Node > compute Successor Nodes ( ) { Collection < Graph Node > result = Lists . new Array List ( ) ; for ( Graph Edge edge : get Forward Edges ( ) ) { result . add ( edge . get Tail ( ) ) ; } for ( Graph Edge edge : get Reverse Edges ( ) ) { result . add ( edge . get Head ( ) ) ; } return result ; }
public State Machine ( State [ ] s ) { for ( int i = NUM ; i < s . length ; i ++ ) states . add Element ( s [ i ] ) ; }
private static int [ ] Windows Reg Create Key Ex 1 ( int h Key , byte [ ] sub Key ) { int [ ] result = Windows Reg Create Key Ex ( h Key , sub Key ) ; if ( result [ ERROR CODE ] == ERROR SUCCESS ) { return result ; } else { long sleep Time = INIT SLEEP TIME ; for ( int i = NUM ; i < MAX ATTEMPTS ; i ++ ) { try { Thread . sleep ( sleep Time ) ; } catch ( Interrupted Exception e ) { return result ; } sleep Time *= NUM ; result = Windows Reg Create Key Ex ( h Key , sub Key ) ; if ( result [ ERROR CODE ] == ERROR SUCCESS ) { return result ; } } } return result ; }
public Tasker add UI Task ( Task task ) { tasks . add ( task ) ; task . set Run Type ( THREAD TYPE . UI ) ; last Added Task = task ; return this ; }
private void init Compute Program ( ) { gl Use Program ( compute Program ) ; Int Buffer work Group Size = Buffer Utils . create Int Buffer ( NUM ) ; gl Get Programiv ( compute Program , GL COMPUTE WORK GROUP SIZE , work Group Size ) ; work Group Size X = work Group Size . get ( NUM ) ; work Group Size Y = work Group Size . get ( NUM ) ; time Uniform = gl Get Uniform Location ( compute Program , STRING ) ; blend Factor Uniform = gl Get Uniform Location ( compute Program , STRING ) ; bounce Count Uniform = gl Get Uniform Location ( compute Program , STRING ) ; int boxes Resource Index = gl Get Program Resource Index ( compute Program , GL SHADER STORAGE BLOCK , STRING ) ; Int Buffer props = Buffer Utils . create Int Buffer ( NUM ) ; Int Buffer params = Buffer Utils . create Int Buffer ( NUM ) ; props . put ( NUM , GL BUFFER BINDING ) ; gl Get Program Resourceiv ( compute Program , GL SHADER STORAGE BLOCK , boxes Resource Index , props , null , params ) ; boxes Ssbo Binding = params . get ( NUM ) ; int loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; framebuffer Image Binding = params . get ( NUM ) ; loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Position Image Binding = params . get ( NUM ) ; loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Normal Image Binding = params . get ( NUM ) ; gl Use Program ( NUM ) ; }
public static void sort Methods ( Method Binding [ ] sorted Methods , int left , int right ) { Arrays . sort ( sorted Methods , left , right , METHOD COMPARATOR ) ; }
public static Object object From Byte Buffer ( byte [ ] buffer ) throws Exception { if ( buffer == null ) return null ; Byte Array Input Stream in Stream = new Byte Array Input Stream ( buffer ) ; Object Input Stream in = new Object Input Stream ( in Stream ) ; Object retval = in . read Object ( ) ; in . close ( ) ; return retval ; }
public String generate Group Name ( Set < String > existing Group Names , String storage Group Name ) { String storage Group Name Temp = storage Group Name . replace All ( Constants . SMIS PLUS REGEX , Constants . HYPHEN ) ; log . info ( STRING , storage Group Name , storage Group Name Temp ) ; String result = storage Group Name Temp ; if ( existing Group Names . contains ( storage Group Name Temp . to Lower Case ( ) ) ) { int size = existing Group Names . size ( ) ; for ( int index = NUM ; index <= size ; index ++ ) { result = String . format ( STRING , storage Group Name Temp , index ) ; if ( ! existing Group Names . contains ( result . to Lower Case ( ) ) ) { break ; } } } log . info ( String . format ( STRING , existing Group Names . size ( ) , storage Group Name Temp , result ) ) ; return result ; }
public Multiple Actions ( final Chat Action ... action ) { this . actions = Arrays . as List ( action ) ; }
public boolean add Row ( Table Entry entry ) { try { int row = list . size ( ) ; list . add ( entry ) ; fire Table Rows Inserted ( row , row ) ; } catch ( Exception e ) { return BOOL ; } return BOOL ; }
private int measure Child Collapse Margins ( View child , int parent Width Measure Spec , int width Used , int parent Height Measure Spec , int height Used , int [ ] collapsing Margins ) { final Margin Layout Params lp = ( Margin Layout Params ) child . get Layout Params ( ) ; final int left Diff = lp . left Margin - collapsing Margins [ NUM ] ; final int right Diff = lp . right Margin - collapsing Margins [ NUM ] ; final int left Margin = Math . max ( NUM , left Diff ) ; final int right Margin = Math . max ( NUM , right Diff ) ; final int h Margins = left Margin + right Margin ; collapsing Margins [ NUM ] = Math . max ( NUM , - left Diff ) ; collapsing Margins [ NUM ] = Math . max ( NUM , - right Diff ) ; final int child Width Measure Spec = get Child Measure Spec ( parent Width Measure Spec , get Padding Left ( ) + get Padding Right ( ) + h Margins + width Used , lp . width ) ; final int child Height Measure Spec = get Child Measure Spec ( parent Height Measure Spec , get Padding Top ( ) + get Padding Bottom ( ) + lp . top Margin + lp . bottom Margin + height Used , lp . height ) ; child . measure ( child Width Measure Spec , child Height Measure Spec ) ; return child . get Measured Width ( ) + h Margins ; }
protected Abstract Buffer reset ( long offset , long capacity , long max Capacity ) { this . offset = offset ; this . capacity = NUM ; this . initial Capacity = capacity ; this . max Capacity = max Capacity ; capacity ( initial Capacity ) ; references . set ( NUM ) ; rewind ( ) ; return this ; }
public Striped Lock Concurrent Hash Map ( @ Not Null Map < ? extends K , ? extends V > t ) { this ( Math . max ( ( int ) ( t . size ( ) / DEFAULT LOAD FACTOR ) + NUM , NUM ) ) ; put All ( t ) ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( m listenee != null ) { return BOOL ; } return BOOL ; }
protected String read Word ( Reader r ) throws IO Exception { String Buffer buf = new String Buffer ( ) ; char c = skip All Whitespace ( r ) ; while ( c != ( char ) - NUM && ! Character . is Whitespace ( c ) ) { buf . append ( c ) ; c = ( char ) r . read ( ) ; } if ( c == ( char ) - NUM ) { set Done ( BOOL ) ; } return buf . to String ( ) ; }
public Map < String , String > parse ( final String str , char separator ) { if ( str == null ) { return new Hash Map < String , String > ( ) ; } return parse ( str . to Char Array ( ) , separator ) ; }
public Index Schema create ( String resource Name , Solr Config config ) { Solr Resource Loader loader = config . get Resource Loader ( ) ; Input Stream schema Input Stream = null ; if ( null == resource Name ) { resource Name = Index Schema . DEFAULT SCHEMA FILE ; } try { schema Input Stream = loader . open Schema ( resource Name ) ; } catch ( Exception e ) { final String msg = STRING + resource Name ; log . error ( msg , e ) ; throw new Solr Exception ( Error Code . SERVER ERROR , msg , e ) ; } Input Source input Source = new Input Source ( schema Input Stream ) ; input Source . set System Id ( System Id Resolver . create System Id From Resource Name ( resource Name ) ) ; Index Schema schema = new Index Schema ( config , resource Name , input Source ) ; return schema ; }
private long acquire Read ( boolean interruptible , long deadline ) { W Node node = null , p ; for ( int spins = - NUM ; ; ) { W Node h ; if ( ( h = whead ) == ( p = wtail ) ) { for ( long m , s , ns ; ; ) { if ( ( m = ( s = state ) & ABITS ) < RFULL ? U . compare And Swap Long ( this , STATE , s , ns = s + RUNIT ) : ( m < WBIT && ( ns = try Inc Reader Overflow ( s ) ) != NUM ) ) return ns ; else if ( m >= WBIT ) { if ( spins > NUM ) { if ( Lock Support . next Secondary Seed ( ) >= NUM ) -- spins ; } else { if ( spins == NUM ) { W Node nh = whead , np = wtail ; if ( ( nh == h && np == p ) || ( h = nh ) != ( p = np ) ) break ; } spins = SPINS ; } } } } if ( p == null ) { W Node hd = new W Node ( WMODE , null ) ; if ( U . compare And Swap Object ( this , WHEAD , null , hd ) ) wtail = hd ; } else if ( node == null ) node = new W Node ( RMODE , p ) ; else if ( h == p || p . mode != RMODE ) { if ( node . prev != p ) node . prev = p ; else if ( U . compare And Swap Object ( this , WTAIL , p , node ) ) { p . next = node ; break ; } } else if ( ! U . compare And Swap Object ( p , WCOWAIT , node . cowait = p . cowait , node ) ) node . cowait = null ; else { for ( ; ; ) { W Node pp , c ; Thread w ; if ( ( h = whead ) != null && ( c = h . cowait ) != null && U . compare And Swap Object ( h , WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null ) U . unpark ( w ) ; if ( h == ( pp = p . prev ) || h == p || pp == null ) { long m , s , ns ; do { if ( ( m = ( s = state ) & ABITS ) < RFULL ? U . compare And Swap Long ( this , STATE , s , ns = s + RUNIT ) : ( m < WBIT && ( ns = try Inc Reader Overflow ( s ) ) != NUM ) ) return ns ; } while ( m < WBIT ) ; } if ( whead == h && p . prev == pp ) { long time ; if ( pp == null || h == p || p . status > NUM ) { node = null ; break ; } if ( deadline == NUM ) time = NUM ; else if ( ( time = deadline - System . nano Time ( ) ) <= NUM ) return cancel Waiter ( node , p , BOOL ) ; Thread wt = Thread . current Thread ( ) ; U . put Object ( wt , PARKBLOCKER , this ) ; node . thread = wt ; if ( ( h != pp || ( state & ABITS ) == WBIT ) && whead == h && p . prev == pp ) U . park ( BOOL , time ) ; node . thread = null ; U . put Object ( wt , PARKBLOCKER , null ) ; if ( interruptible && Thread . interrupted ( ) ) return cancel Waiter ( node , p , BOOL ) ; } } } } for ( int spins = - NUM ; ; ) { W Node h , np , pp ; int ps ; if ( ( h = whead ) == p ) { if ( spins < NUM ) spins = HEAD SPINS ; else if ( spins < MAX HEAD SPINS ) spins <<= NUM ; for ( int k = spins ; ; ) { long m , s , ns ; if ( ( m = ( s = state ) & ABITS ) < RFULL ? U . compare And Swap Long ( this , STATE , s , ns = s + RUNIT ) : ( m < WBIT && ( ns = try Inc Reader Overflow ( s ) ) != NUM ) ) { W Node c ; Thread w ; whead = node ; node . prev = null ; while ( ( c = node . cowait ) != null ) { if ( U . compare And Swap Object ( node , WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null ) U . unpark ( w ) ; } return ns ; } else if ( m >= WBIT && Lock Support . next Secondary Seed ( ) >= NUM && -- k <= NUM ) break ; } } else if ( h != null ) { W Node c ; Thread w ; while ( ( c = h . cowait ) != null ) { if ( U . compare And Swap Object ( h , WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null ) U . unpark ( w ) ; } } if ( whead == h ) { if ( ( np = node . prev ) != p ) { if ( np != null ) ( p = np ) . next = node ; } else if ( ( ps = p . status ) == NUM ) U . compare And Swap Int ( p , WSTATUS , NUM , WAITING ) ; else if ( ps == CANCELLED ) { if ( ( pp = p . prev ) != null ) { node . prev = pp ; pp . next = node ; } } else { long time ; if ( deadline == NUM ) time = NUM ; else if ( ( time = deadline - System . nano Time ( ) ) <= NUM ) return cancel Waiter ( node , node , BOOL ) ; Thread wt = Thread . current Thread ( ) ; U . put Object ( wt , PARKBLOCKER , this ) ; node . thread = wt ; if ( p . status < NUM && ( p != h || ( state & ABITS ) == WBIT ) && whead == h && node . prev == p ) U . park ( BOOL , time ) ; node . thread = null ; U . put Object ( wt , PARKBLOCKER , null ) ; if ( interruptible && Thread . interrupted ( ) ) return cancel Waiter ( node , node , BOOL ) ; } } } }
@ Override public String create Initial Load Sql For ( Node node , Trigger Router trigger , Table table , Trigger History trigger History , Channel channel , String override Select Sql ) { String sql = super . create Initial Load Sql For ( node , trigger , table , trigger History , channel , override Select Sql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
private void parse Line ( List < Elem > elems , String line ) { int i = NUM ; boolean last Was Open Brace = BOOL ; String Builder sb = new String Builder ( ) ; while ( i < line . length ( ) ) { char ch = line . char At ( i ++ ) ; if ( ch == STRING ) { if ( i < line . length ( ) && line . char At ( i ) == STRING ) { sb . append ( STRING ) ; i ++ ; } else if ( i < line . length ( ) && line . char At ( i ) == STRING ) { sb . append ( STRING ) ; i ++ ; } else if ( i < line . length ( ) && line . char At ( i ) == STRING ) { sb . append ( STRING ) ; i ++ ; } else if ( last Was Open Brace ) { sb . delete Char At ( sb . length ( ) - NUM ) ; flush Literal ( elems , sb ) ; i = parse Expr ( elems , line , i ) ; } else { sb . append ( STRING ) ; i ++ ; } last Was Open Brace = BOOL ; } else { last Was Open Brace = ch == STRING ; sb . append ( ch ) ; } } flush Literal ( elems , sb ) ; }
public static File create Container Schema File ( String schema Prefix File Name , String container Schema File Path ) throws Remote Exception { File default Schema File = null ; try { String schema File Path = Constants . Container . CONTAINER CONFIG DIRECTORY + STRING + Constants . Schemas . SCHEMAS FOLDER + STRING + Constants . Schemas . DEFAULT SCHEMA + Constants . Schemas . CONTAINER SCHEMA FILE SUFFIX ; Input Stream schema Input Stream = Resource Loader . get Resource Stream ( schema File Path ) ; String folder Owner Path = container Schema File Path . substring ( NUM , container Schema File Path . last Index Of ( File . separator ) ) ; File folder Owner Instance = new File ( folder Owner Path ) ; if ( ! folder Owner Instance . exists ( ) ) { folder Owner Instance . mkdirs ( ) ; } default Schema File = new File ( container Schema File Path ) ; File Output Stream fos = new File Output Stream ( default Schema File ) ; int read = NUM ; while ( read > NUM ) { byte [ ] read Bytes Array = new byte [ schema Input Stream . available ( ) ] ; read = schema Input Stream . read ( read Bytes Array ) ; fos . write ( read Bytes Array ) ; } fos . flush ( ) ; fos . close ( ) ; schema Input Stream . close ( ) ; Replace In File Utils file = new Replace In File Utils ( container Schema File Path ) ; file . replace In File ( STRING + Constants . Schemas . DEFAULT SCHEMA + STRING , STRING + schema Prefix File Name + STRING ) ; file . replace In File ( STRING + Constants . Schemas . DEFAULT SCHEMA + STRING , STRING + schema Prefix File Name + STRING ) ; file . close ( ) ; } catch ( Exception ex ) { throw new Remote Exception ( STRING , ex ) ; } return default Schema File ; }
public boolean is Aborted ( ) { return STATE Aborted . equals ( m state ) ; }
public void append ( long key , E value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = ideal Long Array Size ( pos + NUM ) ; long [ ] nkeys = new long [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + NUM ; }
@ Nullable private Ipc Shared Memory Server Endpoint reset Shmem Server ( ) throws Ignite Checked Exception { if ( bound Tcp Shmem Port >= NUM ) throw new Ignite Checked Exception ( STRING + bound Tcp Shmem Port ) ; if ( shmem Port == - NUM || U . is Windows ( ) ) return null ; Ignite Checked Exception last Ex = null ; for ( int port = shmem Port ; port < shmem Port + loc Port Range ; port ++ ) { try { Ipc Shared Memory Server Endpoint srv = new Ipc Shared Memory Server Endpoint ( log . get Logger ( Ipc Shared Memory Server Endpoint . class ) , loc Proc Desc . process Id ( ) , grid Name ) ; srv . set Port ( port ) ; srv . omit Out Of Resources Warning ( BOOL ) ; srv . start ( ) ; bound Tcp Shmem Port = port ; if ( log . is Info Enabled ( ) ) log . info ( STRING + bound Tcp Shmem Port + STRING + loc Host + STRING ) ; return srv ; } catch ( Ignite Checked Exception e ) { last Ex = e ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + port + STRING + loc Host + STRING ) ; } } throw new Ignite Checked Exception ( STRING + loc Port + STRING + loc Port Range + STRING + loc Host + STRING , last Ex ) ; }
private void close Connection ( Connection connection ) throws SQL Exception { if ( connection != null ) { try { connection . close ( ) ; } catch ( SQL Exception e ) { throw new SQL Exception ( STRING , e ) ; } } }
public Version remove Qualifier ( String qualifier ) { List < String > new Qualifiers = new Array List < > ( this . qualifiers ) ; new Qualifiers . remove ( qualifier ) ; return new Version ( major , minor , patch , new Qualifiers . to Array ( new String [ new Qualifiers . size ( ) ] ) ) ; }
public int load Signed 16 ( int addr ) { return ( load Signed 8 ( addr ) << NUM ) | load Unsigned 8 ( addr + NUM ) ; }
public static String to Hex String ( byte [ ] array ) { return to Hex String ( Byte Buffer . wrap ( array ) , NUM , array . length ) ; }
public static void register Baggage Handler ( Baggage Handler handler ) { handlers . add ( handler ) ; }
public Interval 1 D ( double min , double max ) { if ( Double . is Infinite ( min ) || Double . is Infinite ( max ) ) throw new Illegal Argument Exception ( STRING ) ; if ( Double . is Na N ( min ) || Double . is Na N ( max ) ) throw new Illegal Argument Exception ( STRING ) ; if ( min == NUM ) min = NUM ; if ( max == NUM ) max = NUM ; if ( min <= max ) { this . min = min ; this . max = max ; } else throw new Illegal Argument Exception ( STRING ) ; }
public static void assert Array Equals ( String message , Object [ ] expected , Object [ ] actual ) { if ( expected == null ) { assert Equals ( ( Object ) null , actual ) ; return ; } if ( actual == null ) { throw new Assertion Failed Error ( message + STRING + Arrays . to String ( expected ) + STRING ) ; } assert Equals ( message + STRING , expected . length , actual . length ) ; for ( int i = NUM ; i < expected . length ; i ++ ) { assert Equals ( message , expected [ i ] , actual [ i ] ) ; } }
protected void complete Current Text Node ( ) { if ( strip Whitespace Text ) { boolean whitespace = BOOL ; for ( int i = NUM , size = text Buffer . length ( ) ; i < size ; i ++ ) { if ( ! Character . is Whitespace ( text Buffer . char At ( i ) ) ) { whitespace = BOOL ; break ; } } if ( ! whitespace ) { current Element . add Text ( text Buffer . to String ( ) ) ; } } else { current Element . add Text ( text Buffer . to String ( ) ) ; } text Buffer . set Length ( NUM ) ; text In Text Buffer = BOOL ; }
public final < E extends Throwable > Mono < T > otherwise ( Class < E > type , Function < ? super E , ? extends Mono < ? extends T > > fallback ) { Objects . require Non Null ( type , STRING ) ; @ Suppress Warnings ( STRING ) Function < ? super Throwable , Mono < ? extends T > > handler = ( Function < ? super Throwable , Mono < ? extends T > > ) fallback ; return otherwise ( null , handler ) ; }
public synchronized I Floodlight Module Context load Modules From List ( Collection < String > config Mods , Properties prop ) throws Floodlight Module Exception { logger . debug ( STRING ) ; find All Modules ( config Mods ) ; Array List < I Floodlight Module > module List = new Array List < > ( ) ; Map < Class < ? extends I Floodlight Service > , I Floodlight Module > module Map = new Hash Map < > ( ) ; Hash Set < String > mods Visited = new Hash Set < > ( ) ; Array Deque < String > mods To Load = new Array Deque < > ( config Mods ) ; while ( ! mods To Load . is Empty ( ) ) { String module Name = mods To Load . remove First ( ) ; traverse Deps ( module Name , mods To Load , module List , module Map , mods Visited ) ; } parse Config Parameters ( prop ) ; loaded Module List = module List ; init Modules ( module List ) ; if ( startup Modules ) startup Modules ( module List ) ; return floodlight Module Context ; }
public void remove Tick Mark Section ( final Section SECTION ) { if ( null == SECTION ) return ; tick Mark Sections . remove ( SECTION ) ; Collections . sort ( tick Mark Sections , new Section Comparator ( ) ) ; fire Update Event ( REDRAW EVENT ) ; }
public static double raw Probability ( double x , double lambda ) { if ( lambda == NUM ) { return ( ( x == NUM ) ? NUM : NUM ) ; } if ( Double . is Infinite ( lambda ) || x < NUM ) { return NUM ; } if ( x <= lambda * Double . MIN NORMAL ) { return Math . exp ( - lambda ) ; } if ( lambda < x * Double . MIN NORMAL ) { double r = - lambda + x * Math . log ( lambda ) - Gamma Distribution . log Gamma ( x + NUM ) ; return Math . exp ( r ) ; } final double f = Math Util . TWOPI * x ; final double y = - stirling Error ( x ) - deviance Term ( x , lambda ) ; return Math . exp ( y ) / Math . sqrt ( f ) ; }
public void flush ( ) throws IO Exception { if ( print Writer != null ) { print Writer . flush ( ) ; } if ( gzip Output Stream != null ) { gzip Output Stream . flush ( ) ; } }
public Char Buffer replace ( int start , int end , String string ) { int length = length ( ) ; if ( start < NUM || end < start || length < start ) throw new String Index Out Of Bounds Exception ( ) ; int len = string . length ( ) ; ensure Capacity ( len + length - ( end - start ) ) ; char [ ] buffer = buffer ( ) ; if ( len < end - start ) { int tail = length - end ; for ( int i = NUM ; i < tail ; i ++ ) { buffer [ start + len + i ] = buffer [ end + i ] ; } } else { int tail = length - end ; for ( int i = tail - NUM ; i >= NUM ; i -- ) { buffer [ end + i ] = buffer [ start + len + i ] ; } } string . get Chars ( NUM , len , buffer , start ) ; length ( length + len - ( end - start ) ) ; return this ; }
public void add Listener ( final I Navi Graph Listener listener ) { super . add Listener ( listener ) ; m listeners . add Listener ( listener ) ; m synchronizer . add Listener ( listener ) ; }
public void action Performed ( Action Event e ) { try { int n = Integer . parse Int ( e . get Action Command ( ) ) ; set Value ( n ) ; } catch ( Number Format Exception e1 ) { set Text ( Integer . to String ( get Value ( ) ) ) ; } }
public static < T > String encode To Base 64 ( Coder < T > coder , T value ) throws Coder Exception { byte [ ] raw Value = encode To Byte Array ( coder , value ) ; return Base 64 . encode Base 64 URL Safe String ( raw Value ) ; }
public void test Correct Build ( ) { Iterator < String > iter = m Trie . iterator ( ) ; Hash Set < String > set = new Hash Set < String > ( ) ; while ( iter . has Next ( ) ) set . add ( iter . next ( ) ) ; assert Equals ( STRING , m Data . length , m Trie . size ( ) ) ; assert Equals ( STRING , m Data . length , set . size ( ) ) ; for ( int i = NUM ; i < m Data . length ; i ++ ) { if ( ! set . contains ( m Data [ i ] ) ) fail ( STRING + m Data [ i ] + STRING ) ; } }
public String subtract ( Object ... values ) { double result = Function Handler . get Double ( values [ NUM ] ) ; for ( int i = NUM ; i < values . length ; i ++ ) { result -= Function Handler . get Double ( values [ i ] ) ; } return Double . to String ( result ) ; }
public DB Instance Info retrieve DB Info ( String db Group Name , String host Name ) { Connection conn = null ; try { conn = create Connection ( BOOL ) ; return retrieve DB Info ( conn , db Group Name , host Name ) ; } catch ( Exception ex ) { logger . log ( Level . SEVERE , STRING , ex ) ; } finally { DB Utils . close ( conn ) ; } return null ; }
private void add Rounded Corner ( @ Non Null Geometry Arrays geo Arrays , @ Non Null float [ ] center , float [ ] radius , float rads 0 , float rads 1 , int triangles , @ Non Null Rect F view Port , float z ) { final float [ ] vertices = geo Arrays . triangle Vertices ; final short [ ] indices = geo Arrays . triangle Indices ; final int vertices Offset = geo Arrays . vertices Offset ; final int indices Offset = geo Arrays . indices Offset ; for ( int i = NUM ; i < triangles ; i ++ ) { final int current Offset = vertices Offset + i * NUM + ( i > NUM ? NUM * NUM : NUM ) ; final float rads = rads 0 + ( rads 1 - rads 0 ) * ( i / ( float ) triangles ) ; final float rads Next = rads 0 + ( rads 1 - rads 0 ) * ( ( i + NUM ) / ( float ) triangles ) ; final int triangle Edge 2 Offset ; if ( i == NUM ) { vertices [ current Offset ] = center [ NUM ] ; vertices [ current Offset + NUM ] = center [ NUM ] ; vertices [ current Offset + NUM ] = z ; vertices [ current Offset + NUM ] = ( vertices [ current Offset ] - view Port . left ) / view Port . width ( ) ; vertices [ current Offset + NUM ] = ( vertices [ current Offset + NUM ] - view Port . bottom ) / - view Port . height ( ) ; vertices [ current Offset + NUM ] = center [ NUM ] + radius [ NUM ] * ( float ) Math . cos ( rads ) ; vertices [ current Offset + NUM ] = center [ NUM ] + radius [ NUM ] * ( float ) Math . sin ( rads ) ; vertices [ current Offset + NUM ] = z ; vertices [ current Offset + NUM ] = ( vertices [ current Offset + NUM ] - view Port . left ) / view Port . width ( ) ; vertices [ current Offset + NUM ] = ( vertices [ current Offset + NUM ] - view Port . bottom ) / - view Port . height ( ) ; triangle Edge 2 Offset = NUM ; } else { triangle Edge 2 Offset = NUM ; } final int edge 2 Offset = current Offset + triangle Edge 2 Offset ; vertices [ edge 2 Offset ] = center [ NUM ] + radius [ NUM ] * ( float ) Math . cos ( rads Next ) ; vertices [ edge 2 Offset + NUM ] = center [ NUM ] + radius [ NUM ] * ( float ) Math . sin ( rads Next ) ; vertices [ edge 2 Offset + NUM ] = z ; vertices [ edge 2 Offset + NUM ] = ( vertices [ edge 2 Offset ] - view Port . left ) / view Port . width ( ) ; vertices [ edge 2 Offset + NUM ] = ( vertices [ edge 2 Offset + NUM ] - view Port . bottom ) / - view Port . height ( ) ; final int initial Idx = vertices Offset / NUM ; indices [ indices Offset + i * NUM ] = ( short ) ( initial Idx ) ; indices [ indices Offset + i * NUM + NUM ] = ( short ) ( initial Idx + i + NUM ) ; indices [ indices Offset + i * NUM + NUM ] = ( short ) ( initial Idx + i + NUM ) ; } }
public int compare ( Object o1 , Object o2 ) { String s1 = o1 == null ? STRING : o1 . to String ( ) ; String s2 = o2 == null ? STRING : o2 . to String ( ) ; return s1 . compare To ( s2 ) ; }
public void add Apply Action Listener ( Action Listener al ) { apply Button . add Action Listener ( al ) ; }
public Polynomial Function subtract ( final Polynomial Function p ) { int low Length = Fast Math . min ( coefficients . length , p . coefficients . length ) ; int high Length = Fast Math . max ( coefficients . length , p . coefficients . length ) ; double [ ] new Coefficients = new double [ high Length ] ; for ( int i = NUM ; i < low Length ; ++ i ) { new Coefficients [ i ] = coefficients [ i ] - p . coefficients [ i ] ; } if ( coefficients . length < p . coefficients . length ) { for ( int i = low Length ; i < high Length ; ++ i ) { new Coefficients [ i ] = - p . coefficients [ i ] ; } } else { System . arraycopy ( coefficients , low Length , new Coefficients , low Length , high Length - low Length ) ; } return new Polynomial Function ( new Coefficients ) ; }
protected static String literal Bits String ( Cst Literal Bits value ) { String Buffer sb = new String Buffer ( NUM ) ; sb . append ( STRING ) ; if ( value instanceof Cst Known Null ) { sb . append ( STRING ) ; } else { sb . append ( value . type Name ( ) ) ; sb . append ( STRING ) ; sb . append ( value . to Human ( ) ) ; } return sb . to String ( ) ; }
public static void copy Memory Field By Field ( long src Address , Object dest ) { Class clazz = dest . get Class ( ) ; while ( clazz != Object . class ) { for ( Field f : clazz . get Declared Fields ( ) ) { if ( ( f . get Modifiers ( ) & Modifier . STATIC ) == NUM ) { final Class type = f . get Type ( ) ; Preconditions . check Argument ( type . is Primitive ( ) , STRING ) ; final long offset = unsafe . object Field Offset ( f ) ; final long src = src Address + offset ; if ( type == int . class ) { unsafe . put Int ( dest , offset , unsafe . get Int ( src ) ) ; } else if ( type == long . class ) { unsafe . put Long ( dest , offset , unsafe . get Long ( src ) ) ; } else { throw new Illegal Argument Exception ( STRING + type ) ; } } } clazz = clazz . get Superclass ( ) ; } }
public final V remove ( int index ) { if ( GWT . is Script ( ) ) { V ret = js Array . get ( index ) ; js Array . remove ( index ) ; return ret ; } else { return java Array . remove ( index ) ; } }
@ Override public void action Performed ( Action Event event ) { String command = event . get Action Command ( ) ; if ( command . equals ( STRING ) ) { attempt Background Paint Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Outline Stroke Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Outline Paint Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Orientation Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Draw Lines Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Draw Shapes Selection ( ) ; } }
public static void clone Server Instance ( SSO Token sso Token , String server Name , String clone Name , String clone Id ) throws SMS Exception , SSO Exception , Configuration Exception { URL url = null ; try { url = new URL ( clone Name ) ; } catch ( Malformed URL Exception ex ) { String [ ] param = { clone Name } ; throw new Configuration Exception ( STRING , param ) ; } Service Config cfg = get Server Config ( sso Token , server Name ) ; if ( cfg != null ) { Map map = cfg . get Attributes ( ) ; Service Config sc = get Root Server Config With Retry ( sso Token ) ; if ( sc != null ) { Set set ID = new Hash Set ( NUM ) ; set ID . add ( clone Id ) ; map . put ( ATTR SERVER ID , set ID ) ; set Protocol Host Port URI ( map , clone Name ) ; sc . add Sub Config ( clone Name , SUBSCHEMA SERVER , NUM , map ) ; update Organization Alias ( sso Token , clone Name , BOOL ) ; } } }
public static < T extends Data Object > Data Object create Instance ( Class < T > clazz , URI id ) throws Instantiation Exception , Illegal Access Exception { T created = clazz . new Instance ( ) ; created . set Id ( id ) ; created . changed = null ; return created ; }
public Generic Sip Rtp Session create Rtp Session ( Contact Id contact , String feature Tag , String encoding ) { if ( s Logger . is Activated ( ) ) { s Logger . info ( STRING + contact ) ; } return new Originating Sip Rtp Session ( this , contact , feature Tag , m Rcs Settings , System . current Time Millis ( ) , m Contact Manager , encoding ) ; }
public static void draw Circled Text ( Graphics 2 D g , Font font , String text , int x , int y ) { Graphics 2 D g2 = ( Graphics 2 D ) g . create ( ) ; g2 . set Font ( font ) ; Font Metrics fm = g2 . get Font Metrics ( ) ; int padding = NUM ; Rectangle 2 D bounds = fm . get String Bounds ( text , g2 ) ; double th = bounds . get Height ( ) ; double tw = bounds . get Width ( ) ; float radius = ( float ) ( Math . max ( th , tw ) / NUM + padding ) ; Ellipse 2 D . Float circle = new Ellipse 2 D . Float ( x - radius , y - radius , NUM * radius + NUM , NUM * radius + NUM ) ; g2 . fill ( circle ) ; g2 . set Color ( Color . BLACK ) ; g2 . draw String ( text , ( int ) ( x - tw / NUM ) , ( y + fm . get Ascent ( ) / NUM ) ) ; if ( DEBUG ) { g2 . set Color ( Color . RED ) ; g2 . draw Line ( x - NUM , y , x + NUM , y ) ; g2 . draw Line ( x , y - NUM , x , y + NUM ) ; } g2 . dispose ( ) ; }
public void projection Changed ( Projection Event e ) { Projection new Proj = e . get Projection ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( new Proj != null ? new Proj . to String ( ) : STRING ) ; } if ( new Proj != null && ( projection == null || ( ! projection . equals ( new Proj ) ) ) ) { set Projection ( ( Projection ) new Proj . make Clone ( ) ) ; Object source = e . get Source ( ) ; if ( source instanceof Component ) { proj Component = ( Component ) source ; } } }
public static String byte Array To Hex String ( byte [ ] block ) { String Buffer buf = new String Buffer ( ) ; int len = block . length ; for ( int i = NUM ; i < len ; i ++ ) { byte 2 hex ( block [ i ] , buf ) ; if ( ( i < len - NUM ) & WITH BYTE SEPARATOR ) { buf . append ( BYTE SEPARATOR ) ; } } return buf . to String ( ) ; }
private static void add Input Field ( J Formatted Text Field input , String label Text , java . awt . Container cont , Object initial Value , Property Change Listener pcl ) { J Label label = new J Label ( label Text ) ; label . set Horizontal Alignment ( J Label . RIGHT ) ; cont . add ( label ) ; input . set Value ( initial Value ) ; input . set Horizontal Alignment ( J Formatted Text Field . RIGHT ) ; input . add Property Change Listener ( STRING , pcl ) ; cont . add ( input ) ; label . set Label For ( input ) ; }
private void write Deflated ( byte [ ] b , int offset , int length ) throws IO Exception { if ( length > NUM && ! def . finished ( ) ) { entry . bytes Read += length ; if ( length <= DEFLATER BLOCK SIZE ) { def . set Input ( b , offset , length ) ; deflate Until Input Is Needed ( ) ; } else { final int fullblocks = length / DEFLATER BLOCK SIZE ; for ( int i = NUM ; i < fullblocks ; i ++ ) { def . set Input ( b , offset + i * DEFLATER BLOCK SIZE , DEFLATER BLOCK SIZE ) ; deflate Until Input Is Needed ( ) ; } final int done = fullblocks * DEFLATER BLOCK SIZE ; if ( done < length ) { def . set Input ( b , offset + done , length - done ) ; deflate Until Input Is Needed ( ) ; } } } }
public float distance To Center ( float x , float y ) { Point F c = get Center ( ) ; float dist = NUM ; float x Dist = NUM ; float y Dist = NUM ; if ( x > c . x ) { x Dist = x - c . x ; } else { x Dist = c . x - x ; } if ( y > c . y ) { y Dist = y - c . y ; } else { y Dist = c . y - y ; } dist = ( float ) Math . sqrt ( Math . pow ( x Dist , NUM ) + Math . pow ( y Dist , NUM ) ) ; return dist ; }
@ Override public int clamp View Position Horizontal ( View child , int left , int dx ) { int left Bound = NUM ; int right Bound = NUM ; switch ( dragger View . get Drag Position ( ) ) { case RIGHT : if ( left > NUM ) { left Bound = dragger View . get Padding Left ( ) ; right Bound = ( int ) dragger Listener . drag Horizontal Drag Range ( ) ; } break ; case LEFT : if ( left < NUM ) { left Bound = ( int ) - dragger Listener . drag Horizontal Drag Range ( ) ; right Bound = dragger View . get Padding Left ( ) ; } break ; default : break ; } return Math . min ( Math . max ( left , left Bound ) , right Bound ) ; }
private void forward Post ( Http URL Connection connection , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { connection . set Do Output ( BOOL ) ; connection . set Do Input ( BOOL ) ; connection . set Use Caches ( BOOL ) ; connection . set Request Method ( STRING ) ; connection . set Request Property ( STRING , request . get Content Type ( ) ) ; handle Http Request ( connection , request , response ) ; handle Http Response ( connection , request , response ) ; }
protected double ln Xplusln Y ( double ln X , double ln Y ) { double ln Yminus Ln X , temp ; if ( ln Y > ln X ) { temp = ln X ; ln X = ln Y ; ln Y = temp ; } ln Yminus Ln X = ln Y - ln X ; if ( ln Yminus Ln X < MININUM EXPONENT ) { return ln X ; } else { return Math . log 1 p ( Math . exp ( ln Yminus Ln X ) ) + ln X ; } }
private void forward Get ( Http URL Connection connection , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { connection . set Use Caches ( BOOL ) ; connection . set Request Method ( STRING ) ; handle Http Response ( connection , request , response ) ; }
static SQL Warning convert Show Warnings To SQL Warnings ( Connection connection , int warning Count If Known , boolean for Truncation Only ) throws SQL Exception { java . sql . Statement stmt = null ; java . sql . Result Set warn Rs = null ; SQL Warning current Warning = null ; try { if ( warning Count If Known < NUM ) { stmt = connection . create Statement ( ) ; if ( stmt . get Max Rows ( ) != NUM ) { stmt . set Max Rows ( NUM ) ; } } else { stmt = connection . create Statement ( java . sql . Result Set . TYPE FORWARD ONLY , java . sql . Result Set . CONCUR READ ONLY ) ; stmt . set Fetch Size ( Integer . MIN VALUE ) ; } warn Rs = stmt . execute Query ( STRING ) ; while ( warn Rs . next ( ) ) { int code = warn Rs . get Int ( STRING ) ; if ( for Truncation Only ) { if ( code == Mysql Error Numbers . ER WARN DATA TRUNCATED || code == Mysql Error Numbers . ER WARN DATA OUT OF RANGE ) { Data Truncation new Truncation = new Mysql Data Truncation ( warn Rs . get String ( STRING ) , NUM , BOOL , BOOL , NUM , NUM , code ) ; if ( current Warning == null ) { current Warning = new Truncation ; } else { current Warning . set Next Warning ( new Truncation ) ; } } } else { String message = warn Rs . get String ( STRING ) ; SQL Warning new Warning = new SQL Warning ( message , SQL Error . mysql To Sql State ( code , connection . get Use Sql State Codes ( ) ) , code ) ; if ( current Warning == null ) { current Warning = new Warning ; } else { current Warning . set Next Warning ( new Warning ) ; } } } if ( for Truncation Only && ( current Warning != null ) ) { throw current Warning ; } return current Warning ; } finally { SQL Exception re Throw = null ; if ( warn Rs != null ) { try { warn Rs . close ( ) ; } catch ( SQL Exception sql Ex ) { re Throw = sql Ex ; } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQL Exception sql Ex ) { re Throw = sql Ex ; } } if ( re Throw != null ) { throw re Throw ; } } }
public static long read UINT 64 ( Input Stream stream ) throws IO Exception { long result = NUM ; for ( int i = NUM ; i <= NUM ; i += NUM ) { result |= ( long ) stream . read ( ) << i ; } return result ; }
public static boolean is Minified ( @ Not Null Char Sequence file Content , @ Not Null Parser Definition parser Definition , @ Not Null Token Set no WS Require After Token Set ) { Lexer lexer = parser Definition . create Lexer ( null ) ; lexer . start ( file Content ) ; if ( ! is Minified ( lexer , parser Definition , no WS Require After Token Set ) ) { return BOOL ; } else if ( lexer . get Token Type ( ) == null ) { return BOOL ; } int start Offset = file Content . length ( ) - COUNT OF CONSIDERING CHARACTERS FROM END OF FILE ; if ( start Offset <= NUM ) { return BOOL ; } lexer . start ( file Content , start Offset , file Content . length ( ) ) ; return is Minified ( lexer , parser Definition , no WS Require After Token Set ) ; }
private CSV Record ( List < String > record ) { this . record = Objects . require Non Null ( record ) ; }
private void schedule Send ( final int queue Size ) { if ( pending ) { return ; } if ( queue Size >= batch Size ) { enqueue Send ( ) ; return ; } if ( scheduled . compare And Set ( BOOL , BOOL ) ) { try { scheduler . schedule ( null , max Latency Ms , MILLISECONDS ) ; scheduler Queue Size . increment And Get ( ) ; } catch ( Rejected Execution Exception ignore ) { } } }
public static String join ( boolean [ ] self , String separator ) { String Builder buffer = new String Builder ( ) ; boolean first = BOOL ; if ( separator == null ) separator = STRING ; for ( boolean next : self ) { if ( first ) { first = BOOL ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to String ( ) ; }
private < T > Binding Amp < T > find Binding ( Key < T > key ) { Binding Set < T > set = ( Binding Set ) binding Set Map . get ( key . raw Class ( ) ) ; if ( set != null ) { Binding Amp < T > binding = set . find ( key ) ; if ( binding != null ) { return binding ; } } return null ; }
private void init Compute Program ( ) { gl Use Program ( compute Program ) ; Int Buffer work Group Size = Buffer Utils . create Int Buffer ( NUM ) ; gl Get Programiv ( compute Program , GL COMPUTE WORK GROUP SIZE , work Group Size ) ; work Group Size X = work Group Size . get ( NUM ) ; work Group Size Y = work Group Size . get ( NUM ) ; time Uniform = gl Get Uniform Location ( compute Program , STRING ) ; blend Factor Uniform = gl Get Uniform Location ( compute Program , STRING ) ; bounce Count Uniform = gl Get Uniform Location ( compute Program , STRING ) ; int boxes Resource Index = gl Get Program Resource Index ( compute Program , GL SHADER STORAGE BLOCK , STRING ) ; Int Buffer props = Buffer Utils . create Int Buffer ( NUM ) ; Int Buffer params = Buffer Utils . create Int Buffer ( NUM ) ; props . put ( NUM , GL BUFFER BINDING ) ; gl Get Program Resourceiv ( compute Program , GL SHADER STORAGE BLOCK , boxes Resource Index , props , null , params ) ; boxes Ssbo Binding = params . get ( NUM ) ; int loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; framebuffer Image Binding = params . get ( NUM ) ; loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Position Image Binding = params . get ( NUM ) ; loc = gl Get Uniform Location ( compute Program , STRING ) ; gl Get Uniformiv ( compute Program , loc , params ) ; world Normal Image Binding = params . get ( NUM ) ; gl Use Program ( NUM ) ; }
public boolean namespace Published To Mapgraph ( final String namespace ) throws Exception { assert Mapgraph Runtime Available ( ) ; final String repository Url = get Sparql Endpoint Url For Namespace Or Default ( namespace ) ; final Connect Options opts = new Connect Options ( repository Url , UUID . random UUID ( ) , null ) ; Jetty Response Listener response = null ; { opts . set Accept Header ( STRING ) ; opts . add Request Param ( MAPGRAPH , CHECK PUBLISHED ) ; opts . method = STRING ; } try { check Response Code ( response = do Connect ( opts ) ) ; final String response Body = response . get Response Body ( ) ; return response Body != null && response Body . contains ( STRING ) ; } finally { if ( response != null ) response . abort ( ) ; } }
public void space Vertical ( Array List < Integer > nodes ) { if ( m b Needs Undo Action ) { add Undo Action ( new space Vertical Action ( nodes ) ) ; } int n Min Y = - NUM ; int n Max Y = - NUM ; for ( int i Node = NUM ; i Node < nodes . size ( ) ; i Node ++ ) { int nY = get Position Y ( nodes . get ( i Node ) ) ; if ( nY < n Min Y || i Node == NUM ) { n Min Y = nY ; } if ( nY > n Max Y || i Node == NUM ) { n Max Y = nY ; } } for ( int i Node = NUM ; i Node < nodes . size ( ) ; i Node ++ ) { int n Node = nodes . get ( i Node ) ; m n Position Y . set ( n Node , ( int ) ( n Min Y + i Node * ( n Max Y - n Min Y ) / ( nodes . size ( ) - NUM ) ) ) ; } }
@ Override protected void on Activity Result ( int request Code , int result Code , Intent data ) { if ( request Code == GET CODE ) { Editable text = ( Editable ) m Results . get Text ( ) ; if ( result Code == RESULT CANCELED ) { text . append ( STRING ) ; } else { text . append ( STRING ) ; text . append ( Integer . to String ( result Code ) ) ; text . append ( STRING ) ; if ( data != null ) { text . append ( data . get Action ( ) ) ; } } text . append ( STRING ) ; } }
@ Override public void on Create ( Bundle saved Instance State ) { super . on Create ( saved Instance State ) ; set Retain Instance ( BOOL ) ; m Thread . start ( ) ; }
public Minute ( int minute , Hour hour ) { Param Checks . null Not Permitted ( hour , STRING ) ; this . minute = ( byte ) minute ; this . hour = ( byte ) hour . get Hour ( ) ; this . day = hour . get Day ( ) ; peg ( Calendar . get Instance ( ) ) ; }
public boolean add Undo Point ( ) { boolean result ; File temp File ; Object Output Stream oos ; Array List data ; if ( m Data == null ) return BOOL ; temp File = null ; try { temp File = File . create Temp File ( STRING , Serialized Instances Loader . FILE EXTENSION ) ; temp File . delete On Exit ( ) ; data = new Array List ( ) ; data . add ( m Current File ) ; data . add ( m Data ) ; oos = new Object Output Stream ( new Buffered Output Stream ( new File Output Stream ( temp File ) ) ) ; oos . write Object ( data ) ; oos . flush ( ) ; oos . close ( ) ; m Undo . add ( temp File ) ; result = BOOL ; } catch ( Exception e ) { result = BOOL ; handle Exception ( null , STRING + temp File + STRING , e ) ; J Option Pane . show Message Dialog ( this , STRING + temp File + STRING + e , STRING , J Option Pane . ERROR MESSAGE ) ; } update Menu ( ) ; return result ; }
public static boolean is Network Connected ( Context context ) { if ( context == null ) { return BOOL ; } Connectivity Manager cm = ( Connectivity Manager ) context . get System Service ( Context . CONNECTIVITY SERVICE ) ; Network Info network Info = cm . get Active Network Info ( ) ; return ( network Info != null && network Info . is Connected ( ) ) ; }
public void close ( ) throws java . io . IO Exception { if ( m writer != null ) m writer . close ( ) ; flush Buffer ( ) ; }
public Process ( final URL url ) throws IO Exception , XML Exception { init Context ( ) ; Reader in = new Input Stream Reader ( Web Service Tools . open Stream From URL ( url ) , get Encoding ( null ) ) ; read Process ( in ) ; in . close ( ) ; }
public static String extract Music ID From Media ID ( String media ID ) { int pos = media ID . index Of ( LEAF SEPARATOR ) ; if ( pos >= NUM ) { return media ID . substring ( pos + NUM ) ; } return null ; }
public static int [ ] values ( Integer [ ] array ) { int [ ] dest = new int [ array . length ] ; for ( int i = NUM ; i < array . length ; i ++ ) { Integer v = array [ i ] ; if ( v != null ) { dest [ i ] = v . int Value ( ) ; } } return dest ; }
static public void number Sort ( @ Nonnull String [ ] values ) throws Number Format Exception { for ( int i = NUM ; i <= values . length - NUM ; i ++ ) { for ( int j = values . length - NUM ; j >= i ; j -- ) { if ( Integer . parse Int ( values [ j ] ) > Integer . parse Int ( values [ j + NUM ] ) ) { String temp = values [ j ] ; values [ j ] = values [ j + NUM ] ; values [ j + NUM ] = temp ; } } } }
boolean verify String ( String str ) { if ( ( str . length ( ) > max Length ) || ( str . length ( ) < min Length ) ) { return BOOL ; } int i = NUM ; Enumeration e = format Constraints . elements ( ) ; if ( ! str . equals ( STRING ) ) { char c = str . char At ( i ) ; for ( ; e . has More Elements ( ) ; ) { Format Constraint constraint = ( Format Constraint ) e . next Element ( ) ; if ( constraint . count == Format Constraint . COUNT EXACTLY ONE ) { if ( ! verify Char ( c , constraint . type ) ) { return BOOL ; } i ++ ; if ( i < str . length ( ) ) { c = str . char At ( i ) ; } else { break ; } } else { int char Num = NUM ; while ( ( i < str . length ( ) ) && ( char Num < constraint . count ) ) { if ( ! verify Char ( c , constraint . type ) ) { break ; } i ++ ; char Num ++ ; if ( i < str . length ( ) ) { c = str . char At ( i ) ; } else { break ; } } if ( i >= str . length ( ) ) { break ; } } } if ( i < str . length ( ) ) { return BOOL ; } } while ( e . has More Elements ( ) ) { Format Constraint constraint = ( Format Constraint ) e . next Element ( ) ; if ( constraint . count == Format Constraint . COUNT EXACTLY ONE ) { return BOOL ; } } return BOOL ; }
public void read Data ( Data Input din ) throws IO Exception { int byte Count = din . read Unsigned Byte ( ) ; int record Count = byte Count / NUM ; records = new Record Request [ record Count ] ; for ( int i = NUM ; i < record Count ; i ++ ) { if ( din . read Byte ( ) != NUM ) { throw new IO Exception ( ) ; } int file = din . read Unsigned Short ( ) ; int record = din . read Unsigned Short ( ) ; if ( record < NUM || record >= NUM ) { throw new IO Exception ( ) ; } int count = din . read Unsigned Short ( ) ; records [ i ] = new Record Request ( file , record , count ) ; } }
protected String to String ( Trie Node node ) { String Buffer result ; int i ; String Buffer indentation ; result = new String Buffer ( ) ; indentation = new String Buffer ( ) ; for ( i = NUM ; i < node . get Level ( ) ; i ++ ) { indentation . append ( STRING ) ; } result . append ( indentation . to String ( ) ) ; if ( node . get Char ( ) == null ) { result . append ( STRING ) ; } else if ( node . get Char ( ) == Trie Node . STOP ) { result . append ( STRING ) ; } else { result . append ( STRING + node . get Char ( ) + STRING ) ; } result . append ( STRING ) ; for ( i = NUM ; i < node . get Child Count ( ) ; i ++ ) { result . append ( to String ( ( Trie Node ) node . get Child At ( i ) ) ) ; } return result . to String ( ) ; }
public Vector ( int capacity , int capacity Increment ) { if ( capacity < NUM ) { throw new Illegal Argument Exception ( STRING + capacity ) ; } element Data = new Element Array ( capacity ) ; element Count = NUM ; this . capacity Increment = capacity Increment ; }
protected static token do id ( ) throws java . io . IO Exception { String Buffer result = new String Buffer ( ) ; String result str ; Integer keyword num ; char buffer [ ] = new char [ NUM ] ; buffer [ NUM ] = ( char ) next char ; result . append ( buffer , NUM , NUM ) ; advance ( ) ; while ( id char ( next char ) ) { buffer [ NUM ] = ( char ) next char ; result . append ( buffer , NUM , NUM ) ; advance ( ) ; } result str = result . to String ( ) ; keyword num = ( Integer ) keywords . get ( result str ) ; if ( keyword num != null ) return new token ( keyword num . int Value ( ) ) ; return new str token ( sym . ID , result str ) ; }
public static double overlap ( Spatial Comparable box 1 , Spatial Comparable box 2 ) { final int dim = assert Same Dimensionality ( box 1 , box 2 ) ; double omax , omin ; double overlap = NUM ; for ( int i = NUM ; i < dim ; i ++ ) { omax = Math . min ( box 1 . get Max ( i ) , box 2 . get Max ( i ) ) ; omin = Math . max ( box 1 . get Min ( i ) , box 2 . get Min ( i ) ) ; if ( omax <= omin ) { return NUM ; } overlap *= omax - omin ; } return overlap ; }
public void test delete markers do Not Visit Deleted ( ) { final B Tree btree ; { Index Metadata md = new Index Metadata ( UUID . random UUID ( ) ) ; md . set Delete Markers ( BOOL ) ; btree = B Tree . create ( new Simple Memory Raw Store ( ) , md ) ; btree . insert ( NUM , STRING ) ; btree . insert ( NUM , STRING ) ; btree . insert ( NUM , STRING ) ; } final int flags = I Range Query . DEFAULT ; { I Tuple Cursor 2 < String > cursor = new Cursor ( btree , flags , null , null ) ; assert Equals ( new Test Tuple < String > ( flags , NUM , STRING , BOOL , NUM ) , cursor . seek ( NUM ) ) ; cursor . remove ( ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert True ( cursor . has Next ( ) ) ; assert Equals ( new Test Tuple < String > ( flags , NUM , STRING , BOOL , NUM ) , cursor . next ( ) ) ; assert False ( cursor . has Prior ( ) ) ; try { cursor . prior ( ) ; fail ( STRING + No Such Element Exception . class ) ; } catch ( No Such Element Exception ex ) { log . info ( STRING + ex ) ; } } }
public static String relative File ( Iterable < ? extends File > paths , String file ) { File path = select Path ( paths , file ) ; File rel File = relative File ( path , new File ( file ) ) ; return rel File . get Path ( ) ; }
private Boolean should Connect ( final I Project project ) { Check . not Null ( project , STRING ) ; if ( ! project . is Open ( ) ) { log . debug ( Message Format . format ( STRING , project . get Name ( ) ) ) ; return null ; } String provider Name ; try { provider Name = project . get Persistent Property ( Team Utils . PROVIDER PROP KEY ) ; } catch ( final Core Exception e ) { log . warn ( Message Format . format ( STRING , project . get Name ( ) ) , e ) ; return null ; } if ( provider Name == null || ! provider Name . equals ( TFS Repository Provider . PROVIDER ID ) ) { return null ; } String repository Status = null ; try { repository Status = project . get Persistent Property ( REPOSITORY STATUS KEY ) ; } catch ( final Core Exception e ) { log . warn ( Message Format . format ( STRING , project . get Name ( ) ) , e ) ; } if ( REPOSITORY STATUS OFFLINE VALUE . equals ( repository Status ) ) { return Boolean . FALSE ; } return Boolean . TRUE ; }
public Session Id ( byte [ ] session Id ) { if ( session Id == null ) { throw new Null Pointer Exception ( STRING ) ; } this . id = Arrays . copy Of ( session Id , session Id . length ) ; }
protected static void remove All Triggers ( Connection conn , String prefix ) throws SQL Exception { Statement stat = conn . create Statement ( ) ; Result Set rs = stat . execute Query ( STRING ) ; Statement stat 2 = conn . create Statement ( ) ; while ( rs . next ( ) ) { String schema = rs . get String ( STRING ) ; String name = rs . get String ( STRING ) ; if ( name . starts With ( prefix ) ) { name = String Utils . quote Identifier ( schema ) + STRING + String Utils . quote Identifier ( name ) ; stat 2 . execute ( STRING + name ) ; } } }
public boolean add Ignore ( final String name , final int duration , final String reply ) { final String Builder sbuf = new String Builder ( ) ; if ( duration != NUM ) { sbuf . append ( System . current Time Millis ( ) + duration * NUM ) ; } sbuf . append ( STRING ) ; if ( reply != null ) { sbuf . append ( reply ) ; } return set Keyed Slot ( STRING , STRING + name , sbuf . to String ( ) ) ; }
public void test Create Element NS 1 ( ) throws Throwable { Document doc ; Element element ; String namespace URI = STRING ; String qualified Name = STRING ; String node Name ; String ns URI ; String local Name ; String prefix ; String tag Name ; doc = ( Document ) load ( STRING , builder ) ; element = doc . create Element NS ( namespace URI , qualified Name ) ; node Name = element . get Node Name ( ) ; ns URI = element . get Namespace URI ( ) ; local Name = element . get Local Name ( ) ; prefix = element . get Prefix ( ) ; tag Name = element . get Tag Name ( ) ; assert Equals ( STRING , STRING , node Name ) ; assert Equals ( STRING , STRING , ns URI ) ; assert Equals ( STRING , STRING , local Name ) ; assert Equals ( STRING , STRING , prefix ) ; assert Equals ( STRING , STRING , tag Name ) ; }
public void write To File In Directory ( File directory , String file Name , String content ) { try { Files . write ( content , new File ( directory , file Name ) , Standard Charsets . UTF 8 ) ; } catch ( IO Exception ioe ) { throw new Runtime Exception ( ioe ) ; } }
public Point 2 D forward ( double lat , double lon , Point 2 D p , boolean is Radian ) { if ( ! is Radian ) { lat = Proj Math . deg To Rad ( lat ) ; lon = Proj Math . deg To Rad ( lon ) ; } lat = normalize Latitude ( lat ) ; lon = wrap Longitude ( lon ) ; double x = ( scaled radius * wrap Longitude ( lon - center X ) ) + wx ; double y = hy - ( scaled radius * ( More Math . asinh ( Math . tan ( lat ) ) - asinh of tan Ctr Lat ) ) ; p . set Location ( x , y ) ; return p ; }
protected boolean remove Level Xing ( Level Xing o ) { if ( ! no Warn Level Xing ) { int selected Value = J Option Pane . show Option Dialog ( this , rb . get String ( STRING ) , Bundle . get Message ( STRING ) , J Option Pane . YES NO CANCEL OPTION , J Option Pane . QUESTION MESSAGE , null , new Object [ ] { Bundle . get Message ( STRING ) , Bundle . get Message ( STRING ) , rb . get String ( STRING ) } , Bundle . get Message ( STRING ) ) ; if ( selected Value == NUM ) { return ( BOOL ) ; } if ( selected Value == NUM ) { no Warn Level Xing = BOOL ; } } if ( selected Object == o ) { selected Object = null ; } if ( prev Selected Object == o ) { prev Selected Object = null ; } Track Segment t = ( Track Segment ) o . get Connect A ( ) ; if ( t != null ) { substitute Anchor ( o . get Coords A ( ) , o , t ) ; } t = ( Track Segment ) o . get Connect B ( ) ; if ( t != null ) { substitute Anchor ( o . get Coords B ( ) , o , t ) ; } t = ( Track Segment ) o . get Connect C ( ) ; if ( t != null ) { substitute Anchor ( o . get Coords C ( ) , o , t ) ; } t = ( Track Segment ) o . get Connect D ( ) ; if ( t != null ) { substitute Anchor ( o . get Coords D ( ) , o , t ) ; } Layout Block lb = o . get Layout Block AC ( ) ; if ( lb != null ) { lb . decrement Use ( ) ; } Layout Block lbx = o . get Layout Block BD ( ) ; if ( lbx != null && lb != null && lbx != lb ) { lb . decrement Use ( ) ; } for ( int i = NUM ; i < xing List . size ( ) ; i ++ ) { Level Xing lx = xing List . get ( i ) ; if ( lx == o ) { xing List . remove ( i ) ; o . remove ( ) ; set Dirty ( BOOL ) ; repaint ( ) ; return ( BOOL ) ; } } return ( BOOL ) ; }
public static Buffered Image crop Image ( Buffered Image image , int crop Width , int crop Height ) { Buffered Image ret Img = null ; int width = NUM ; int height = NUM ; width = image . get Width ( ) ; height = image . get Height ( ) ; ret Img = new Buffered Image ( crop Width , crop Height , Buffered Image . TYPE INT RGB ) ; for ( int i = NUM ; i < crop Width ; i ++ ) { for ( int j = NUM ; j < crop Height ; j ++ ) { if ( i < width && j < height ) { ret Img . set RGB ( i , j , image . get RGB ( i , j ) ) ; } else { ret Img . set RGB ( i , j , NUM ) ; } } } return ret Img ; }
private void schedule Send ( final int queue Size ) { if ( pending ) { return ; } if ( queue Size >= batch Size ) { enqueue Send ( ) ; return ; } if ( scheduled . compare And Set ( BOOL , BOOL ) ) { try { scheduler . schedule ( null , max Latency Ms , MILLISECONDS ) ; scheduler Queue Size . increment And Get ( ) ; } catch ( Rejected Execution Exception ignore ) { } } }
public D Date Time Chooser ( J Frame parent , String title , Date date ) { super ( parent , title , Dialog . Modality Type . DOCUMENT MODAL ) ; init Components ( date ) ; }
private void add Mitre Join ( Coordinate p , Line Segment offset 0 , Line Segment offset 1 , double distance ) { boolean is Mitre Within Limit = BOOL ; Coordinate int Pt = null ; try { int Pt = H Coordinate . intersection ( offset 0 . p0 , offset 0 . p1 , offset 1 . p0 , offset 1 . p1 ) ; double mitre Ratio = distance <= NUM ? NUM : int Pt . distance ( p ) / Math . abs ( distance ) ; if ( mitre Ratio > buf Params . get Mitre Limit ( ) ) is Mitre Within Limit = BOOL ; } catch ( Not Representable Exception ex ) { int Pt = new Coordinate ( NUM , NUM ) ; is Mitre Within Limit = BOOL ; } if ( is Mitre Within Limit ) { seg List . add Pt ( int Pt ) ; } else { add Limited Mitre Join ( offset 0 , offset 1 , distance , buf Params . get Mitre Limit ( ) ) ; } }
public void test Multiply Diff Scale Neg Pos ( ) { String a = STRING ; int a Scale = - NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int c Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Big Decimal result = a Number . multiply ( b Number ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , c Scale , result . scale ( ) ) ; }
public static String format Simple Decimal With Zeros ( double d ) { return simple Format Force Zero . format ( d ) ; }
public Period Axis Label Info ( Class period Class , Date Format date Format , Rectangle Insets padding , Font label Font , Paint label Paint , boolean draw Dividers , Stroke divider Stroke , Paint divider Paint ) { Param Checks . null Not Permitted ( period Class , STRING ) ; Param Checks . null Not Permitted ( date Format , STRING ) ; Param Checks . null Not Permitted ( padding , STRING ) ; Param Checks . null Not Permitted ( label Font , STRING ) ; Param Checks . null Not Permitted ( label Paint , STRING ) ; Param Checks . null Not Permitted ( divider Stroke , STRING ) ; Param Checks . null Not Permitted ( divider Paint , STRING ) ; this . period Class = period Class ; this . date Format = ( Date Format ) date Format . clone ( ) ; this . padding = padding ; this . label Font = label Font ; this . label Paint = label Paint ; this . draw Dividers = draw Dividers ; this . divider Stroke = divider Stroke ; this . divider Paint = divider Paint ; }
public void add Item ( String item , int i ) { int old Max Length = max Length ; boolean hsb Was Vis = hsb Vis ; boolean vsb Was Vis = vsb Vis ; int added Index = NUM ; if ( i < NUM || i >= items . size ( ) ) { i = - NUM ; } current Index = - NUM ; if ( i == - NUM ) { items . add Element ( item ) ; i = NUM ; added Index = items . size ( ) - NUM ; } else { items . insert Element At ( item , i ) ; added Index = i ; for ( int j = NUM ; j < selected . length ; j ++ ) { if ( selected [ j ] >= i ) { selected [ j ] += NUM ; } } } if ( log . is Loggable ( Platform Logger . Level . FINER ) ) { log . finer ( STRING + item + STRING + added Index ) ; } boolean repaint Items = ! is Item Hidden ( added Index ) ; max Length = Math . max ( max Length , get Item Width ( added Index ) ) ; layout ( ) ; int options = NUM ; if ( vsb Vis != vsb Was Vis || hsb Vis != hsb Was Vis ) { options = PAINT ALL ; } else { options = ( repaint Items ? ( PAINT ITEMS ) : NUM ) | ( ( max Length != old Max Length || ( hsb Was Vis ^ hsb Vis ) ) ? ( PAINT HSCROLL ) : NUM ) | ( ( vsb . needs Repaint ( ) ) ? ( PAINT VSCROLL ) : NUM ) ; } if ( log . is Loggable ( Platform Logger . Level . FINEST ) ) { log . finest ( STRING + get Last Visible Item ( ) + STRING + ( hsb Was Vis ^ hsb Vis ) + STRING + repaint Items ) ; } repaint ( added Index , get Last Visible Item ( ) , options ) ; }
private final void add To Ties ( int id ) { if ( ties . length == numties ) { ties = Arrays . copy Of ( ties , ( ties . length << NUM ) + NUM ) ; } ties [ numties ] = id ; ++ numties ; }
static void put Federation ( String realm , String federation Id , Federation Element federation ) { String cache Key = build Cache Key ( realm , federation Id ) ; if ( federation != null ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + cache Key ) ; } federation Cache . put ( cache Key , federation ) ; } else { if ( debug . message Enabled ( ) ) { debug . message ( STRING + cache Key ) ; } federation Cache . remove ( cache Key ) ; config Cache . remove ( cache Key ) ; } }
public void read ( Reader policy ) throws Parsing Exception , IO Exception { if ( ! ( policy instanceof Buffered Reader ) ) { policy = new Buffered Reader ( policy ) ; } st = new Stream Tokenizer ( policy ) ; st . reset Syntax ( ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( STRING , STRING ) ; st . word Chars ( NUM + NUM , NUM ) ; st . whitespace Chars ( NUM , STRING ) ; st . comment Char ( STRING ) ; st . quote Char ( STRING ) ; st . quote Char ( STRING ) ; st . lower Case Mode ( BOOL ) ; st . ordinary Char ( STRING ) ; st . slash Slash Comments ( BOOL ) ; st . slash Star Comments ( BOOL ) ; lookahead = st . next Token ( ) ; Grant Entry ge = null ; while ( lookahead != Stream Tokenizer . TT EOF ) { if ( peek ( STRING ) ) { ge = parse Grant Entry ( ) ; if ( ge != null ) add ( ge ) ; } else if ( peek ( STRING ) && key Store Url String == null ) { parse Key Store Entry ( ) ; } else if ( peek ( STRING ) && store Pass URL == null ) { parse Store Pass URL ( ) ; } else if ( ge == null && key Store Url String == null && store Pass URL == null && peek ( STRING ) ) { if ( domain Entries == null ) { domain Entries = new Tree Map < > ( ) ; } Domain Entry de = parse Domain Entry ( ) ; if ( de != null ) { String domain Name = de . get Name ( ) ; if ( ! domain Entries . contains Key ( domain Name ) ) { domain Entries . put ( domain Name , de ) ; } else { Message Format form = new Message Format ( Resources Mgr . get String ( STRING ) ) ; Object [ ] source = { domain Name } ; throw new Parsing Exception ( form . format ( source ) ) ; } } } else { } match ( STRING ) ; } if ( key Store Url String == null && store Pass URL != null ) { throw new Parsing Exception ( Resources Mgr . get String ( STRING ) ) ; } }
protected void inject Into Volume Characterstic Container ( Map < String , String > volume Characterstic , String characterstic Key , String alt Char Key , CIM Instance volume Instance ) { Object value = get CIM Property Value ( volume Instance , characterstic Key ) ; if ( null == value ) { value = get CIM Property Value ( volume Instance , alt Char Key ) ; } String characterstic Name = Supported Volume Characterstics . get Volume Characterstic ( characterstic Key ) ; if ( null != value && null != characterstic Name ) { volume Characterstic . put ( characterstic Name , value . to String ( ) ) ; } }
@ Override @ Ui Thread public void on Detached From Recycler View ( @ Non Null Recycler View recycler View ) { super . on Detached From Recycler View ( recycler View ) ; m Attached Recycler View Pool . remove ( recycler View ) ; }
private void load File ( String filename , Abstract File Loader ... loaders ) { Data Sorted Table Model model ; this . m Filename = filename ; create Title ( ) ; if ( filename . equals ( STRING ) ) { model = null ; } else { model = new Data Sorted Table Model ( filename , loaders ) ; model . set Show Attribute Index ( get Show Attribute Index ( ) ) ; } m Table Data . set Model ( model ) ; set Changed ( BOOL ) ; create Name ( ) ; }
private void exp Param Changed ( ) { if ( m Exp == null ) return ; if ( m Experiment Type C Box . get Selected Item ( ) == TYPE CROSSVALIDATION TEXT ) { try { m num Folds = Integer . parse Int ( m Experiment Parameter T Field . get Text ( ) ) ; } catch ( Number Format Exception e ) { return ; } } else { try { m train Percent = Double . parse Double ( m Experiment Parameter T Field . get Text ( ) ) ; } catch ( Number Format Exception e ) { return ; } } if ( m Experiment Type C Box . get Selected Item ( ) == TYPE CROSSVALIDATION TEXT ) { if ( m Exp . get Result Producer ( ) instanceof Cross Validation Result Producer ) { Cross Validation Result Producer cvrp = ( Cross Validation Result Producer ) m Exp . get Result Producer ( ) ; cvrp . set Num Folds ( m num Folds ) ; } else { return ; } } else { if ( m Exp . get Result Producer ( ) instanceof Random Split Result Producer ) { Random Split Result Producer rsrp = ( Random Split Result Producer ) m Exp . get Result Producer ( ) ; rsrp . set Randomize Data ( m Experiment Type C Box . get Selected Item ( ) == TYPE RANDOMSPLIT TEXT ) ; rsrp . set Train Percent ( m train Percent ) ; } else { return ; } } m Support . fire Property Change ( STRING , null , null ) ; }
public static boolean is Gzip File ( Input Stream in ) throws IO Exception { if ( ! in . mark Supported ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } in . mark ( NUM ) ; try { final byte [ ] b = new byte [ NUM ] ; IO Utils . read Fully ( in , b , NUM , NUM ) ; final int magic = ( ( ( int ) b [ NUM ] & NUM ) << NUM ) | ( ( int ) b [ NUM ] & NUM ) ; return magic == GZIP Input Stream . GZIP MAGIC ; } finally { in . reset ( ) ; } }
@ Override public int hash Code ( ) { int hash ; if ( normalized . length ( ) > NUM ) { hash = normalized . hash Code ( ) ; } else { hash = original . hash Code ( ) ; } if ( matcher != null ) { hash ^= matcher . hash Code ( ) ; } return hash ; }
public static Inet Address decode ( byte value [ ] ) { try { return Inet Address . get By Address ( value ) ; } catch ( Unknown Host Exception e ) { throw new Illegal Argument Exception ( STRING , e ) ; } }
private Subject create Subject ( Principal Attribute identity Attribute , Date token End Time , Confirmation confirmation , Token Delegate last Delegate ) { assert identity Attribute != null ; assert token End Time != null ; assert confirmation != null ; String [ ] token Identity Value = identity Attribute . get Values ( ) ; assert token Identity Value . length == NUM ; String token Subject = token Identity Value [ NUM ] ; String token Subject Format = identity Attribute . get Name ( ) ; Subject subject = new Subject Builder ( ) . build Object ( ) ; subject . set Name ID ( create Name Id ( token Subject , token Subject Format ) ) ; subject . get Subject Confirmations ( ) . add ( create Subject Confirmation ( token End Time , confirmation , last Delegate ) ) ; log . debug ( STRING , subject ) ; return subject ; }
protected void expand For ( int index , int d ) { if ( index < size ) return ; int old Size = size , capacity = vector . length ; size = index + NUM ; if ( capacity >= size ) return ; while ( capacity < size ) capacity *= NUM ; int [ ] t = new int [ capacity ] ; System . arraycopy ( vector , NUM , t , NUM , old Size ) ; if ( d != NUM ) Arrays . fill ( t , old Size , size , d ) ; vector = t ; }
private List < String > build Command Line ( ) { List < String > command Line = new Array List < String > ( ) ; command Line . add ( executable ) ; command Line . add All ( jvm Arguments ) ; command Line . add All ( system Properties ) ; if ( classpath != null && jar Path == null ) { command Line . add ( STRING ) ; command Line . add ( classpath ) ; } if ( jar Path != null ) { command Line . add ( STRING ) ; command Line . add ( jar Path ) ; } if ( jar Path == null ) { command Line . add ( main Class ) ; } command Line . add All ( application Arguments ) ; return command Line ; }
public Image base For ( I Hex hex ) { return hex Tileset . get Base ( hex , boardview ) ; }
public static byte [ ] encode Base 64 ( byte [ ] binary Data , boolean is Chunked ) { int length Data Bits = binary Data . length * EIGHTBIT ; int fewer Than 24 bits = length Data Bits % TWENTYFOURBITGROUP ; int number Triplets = length Data Bits / TWENTYFOURBITGROUP ; byte encoded Data [ ] = null ; int encoded Data Length = NUM ; int nbr Chunks = NUM ; if ( fewer Than 24 bits != NUM ) { encoded Data Length = ( number Triplets + NUM ) * NUM ; } else { encoded Data Length = number Triplets * NUM ; } if ( is Chunked ) { nbr Chunks = ( CHUNK SEPARATOR . length == NUM ? NUM : ( int ) Math . ceil ( ( float ) encoded Data Length / CHUNK SIZE ) ) ; encoded Data Length += nbr Chunks * CHUNK SEPARATOR . length ; } encoded Data = new byte [ encoded Data Length ] ; byte k = NUM , l = NUM , b1 = NUM , b2 = NUM , b3 = NUM ; int encoded Index = NUM ; int data Index = NUM ; int i = NUM ; int next Separator Index = CHUNK SIZE ; int chunks So Far = NUM ; for ( i = NUM ; i < number Triplets ; i ++ ) { data Index = i * NUM ; b1 = binary Data [ data Index ] ; b2 = binary Data [ data Index + NUM ] ; b3 = binary Data [ data Index + NUM ] ; l = ( byte ) ( b2 & NUM ) ; k = ( byte ) ( b1 & NUM ) ; byte val 1 = ( ( b1 & SIGN ) == NUM ) ? ( byte ) ( b1 > > NUM ) : ( byte ) ( ( b1 ) > > NUM ^ NUM ) ; byte val 2 = ( ( b2 & SIGN ) == NUM ) ? ( byte ) ( b2 > > NUM ) : ( byte ) ( ( b2 ) > > NUM ^ NUM ) ; byte val 3 = ( ( b3 & SIGN ) == NUM ) ? ( byte ) ( b3 > > NUM ) : ( byte ) ( ( b3 ) > > NUM ^ NUM ) ; encoded Data [ encoded Index ] = look Up Base 64 Alphabet [ val 1 ] ; encoded Data [ encoded Index + NUM ] = look Up Base 64 Alphabet [ val 2 | ( k << NUM ) ] ; encoded Data [ encoded Index + NUM ] = look Up Base 64 Alphabet [ ( l << NUM ) | val 3 ] ; encoded Data [ encoded Index + NUM ] = look Up Base 64 Alphabet [ b3 & NUM ] ; encoded Index += NUM ; if ( is Chunked ) { if ( encoded Index == next Separator Index ) { System . arraycopy ( CHUNK SEPARATOR , NUM , encoded Data , encoded Index , CHUNK SEPARATOR . length ) ; chunks So Far ++ ; next Separator Index = ( CHUNK SIZE * ( chunks So Far + NUM ) ) + ( chunks So Far * CHUNK SEPARATOR . length ) ; encoded Index += CHUNK SEPARATOR . length ; } } } data Index = i * NUM ; if ( fewer Than 24 bits == EIGHTBIT ) { b1 = binary Data [ data Index ] ; k = ( byte ) ( b1 & NUM ) ; byte val 1 = ( ( b1 & SIGN ) == NUM ) ? ( byte ) ( b1 > > NUM ) : ( byte ) ( ( b1 ) > > NUM ^ NUM ) ; encoded Data [ encoded Index ] = look Up Base 64 Alphabet [ val 1 ] ; encoded Data [ encoded Index + NUM ] = look Up Base 64 Alphabet [ k << NUM ] ; encoded Data [ encoded Index + NUM ] = PAD ; encoded Data [ encoded Index + NUM ] = PAD ; } else if ( fewer Than 24 bits == SIXTEENBIT ) { b1 = binary Data [ data Index ] ; b2 = binary Data [ data Index + NUM ] ; l = ( byte ) ( b2 & NUM ) ; k = ( byte ) ( b1 & NUM ) ; byte val 1 = ( ( b1 & SIGN ) == NUM ) ? ( byte ) ( b1 > > NUM ) : ( byte ) ( ( b1 ) > > NUM ^ NUM ) ; byte val 2 = ( ( b2 & SIGN ) == NUM ) ? ( byte ) ( b2 > > NUM ) : ( byte ) ( ( b2 ) > > NUM ^ NUM ) ; encoded Data [ encoded Index ] = look Up Base 64 Alphabet [ val 1 ] ; encoded Data [ encoded Index + NUM ] = look Up Base 64 Alphabet [ val 2 | ( k << NUM ) ] ; encoded Data [ encoded Index + NUM ] = look Up Base 64 Alphabet [ l << NUM ] ; encoded Data [ encoded Index + NUM ] = PAD ; } if ( is Chunked ) { if ( chunks So Far < nbr Chunks ) { System . arraycopy ( CHUNK SEPARATOR , NUM , encoded Data , encoded Data Length - CHUNK SEPARATOR . length , CHUNK SEPARATOR . length ) ; } } return encoded Data ; }
private void write Java Parameter Spec ( Java Parameter Spec spec , Document document , Element parent Element ) { Element parameter = document . create Element ( STRING ) ; parent Element . append Child ( parameter ) ; parameter . set Attribute ( STRING , spec . get Package Name ( ) ) ; parameter . set Attribute ( STRING , spec . get Class Name ( ) ) ; parameter . set Attribute ( STRING , spec . get Half Signature ( ) ) ; parameter . set Attribute ( STRING , Integer . to String ( spec . get Param Idx ( ) ) ) ; }
private synchronized void read Object ( java . io . Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; init ( get Mask ( actions ) ) ; }
@ Override public synchronized void parse ( Input Stream in , String base URI ) throws IO Exception , RDF Parse Exception , RDF Handler Exception { if ( in == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( base URI == null ) { throw new Illegal Argument Exception ( STRING ) ; } Input Source input Source = new Input Source ( new BOM Input Stream ( in , BOOL ) ) ; input Source . set System Id ( base URI ) ; parse ( input Source ) ; }
public static boolean is Surrogate Pair ( String text , int idx ) { return ! ( idx < NUM || idx > text . length ( ) - NUM ) && is Surrogate High ( text . char At ( idx ) ) && is Surrogate Low ( text . char At ( idx + NUM ) ) ; }
public static File file ( String s ) { File f = new File ( s ) ; return f ; }
public void insert ( int row Index , Iterable < ? extends T > new Items ) { int ri = row Index ; int ri 2 = row Index - NUM ; for ( T t : new Items ) { ri 2 ++ ; items . add ( ri 2 , t ) ; } fire Table Rows Inserted ( ri , ri 2 ) ; }
public void put ( Double Min Max val ) { min = val . min < min ? val . min : min ; max = val . max > max ? val . max : max ; }
public Int Buffer minor Version Buffer ( ) { int [ ] holder = new int [ NUM ] ; holder [ NUM ] = get Minor Version ( ) ; Int Buffer ib = Int Buffer . wrap ( holder ) ; ib . limit ( NUM ) ; return ib ; }
public Create Index Request aliases ( X Content Builder source ) { return aliases ( source . bytes ( ) ) ; }
private byte [ ] generate Derived Key ( int bytes Needed ) { byte [ ] buf = new byte [ digest . get Digest Size ( ) ] ; byte [ ] key = new byte [ bytes Needed ] ; int offset = NUM ; for ( ; ; ) { digest . update ( password , NUM , password . length ) ; digest . update ( salt , NUM , salt . length ) ; digest . do Final ( buf , NUM ) ; int len = ( bytes Needed > buf . length ) ? buf . length : bytes Needed ; System . arraycopy ( buf , NUM , key , offset , len ) ; offset += len ; bytes Needed -= len ; if ( bytes Needed == NUM ) { break ; } digest . reset ( ) ; digest . update ( buf , NUM , buf . length ) ; } return key ; }
public Http Request header ( final String name , final String value ) { connection . set Request Property ( name , value ) ; return this ; }
public static void build Excel Sheet ( final JK Table Model model ) { final JK Excel Util sheet = new JK Excel Util ( model ) ; try { final File file = JKIO Util . create Temp File ( STRING ) ; sheet . write To ( file ) ; JKIO Util . execute File ( file . get Absolute Path ( ) ) ; file . delete On Exit ( ) ; } catch ( final IO Exception ex ) { throw new Runtime Exception ( ex ) ; } }
public static Object demux Array ( Object src , int [ ] dims , Class < ? > component Type ) { Object dst = null ; if ( component Type != byte . class ) { dst = Array . new Instance ( component Type , dims ) ; } else { int [ ] dims Temp = new int [ dims . length + NUM ] ; System . arraycopy ( dims , NUM , dims Temp , NUM , dims . length ) ; dims Temp [ dims . length ] = NUM ; dst = Array . new Instance ( component Type , dims Temp ) ; } fill Demux ( NUM , dims , src , NUM , dst ) ; return dst ; }
void unexpected Error Handling ( String message , final Throwable t ) { Throwable e = t ; while ( e . get Cause ( ) != null ) { e = e . get Cause ( ) ; } e . print Stack Trace ( ) ; if ( e instanceof Out Of Memory Error ) { Lone Option Dialog . show Message Dialog ( STRING + Client Game Configuration . get ( STRING ) + STRING ) ; } else if ( e instanceof Linkage Error || e instanceof Security Exception || e instanceof Class Not Found Exception ) { int res = Lone Option Dialog . show Confirm Dialog ( message + STRING + Client Game Configuration . get ( STRING ) + STRING , Client Game Configuration . get ( STRING ) , J Option Pane . YES NO OPTION , J Option Pane . QUESTION MESSAGE ) ; if ( res == J Option Pane . YES OPTION ) { clear Update Files ( ) ; } } else { String error Message = stacktrace To String ( e ) ; Lone Option Dialog . show Message Dialog ( message + STRING + error Message ) ; } System . exit ( NUM ) ; }
public String request Statistics ( ) { if ( interval > NUM ) { synchronized ( sbmutex ) { return sb . to String ( ) ; } } else { sb . set Length ( NUM ) ; make String Buffer ( sb ) ; return sb . to String ( ) ; } }
public static double min Cos Angle ( Spatial Comparable v1 , Spatial Comparable v2 ) { if ( v1 instanceof Number Vector && v2 instanceof Number Vector ) { return cos Angle ( ( Number Vector ) v1 , ( Number Vector ) v2 ) ; } final int dim 1 = v1 . get Dimensionality ( ) , dim 2 = v2 . get Dimensionality ( ) ; final int mindim = ( dim 1 <= dim 2 ) ? dim 1 : dim 2 ; double s1 = NUM , s2 = NUM , l1 = NUM , l2 = NUM ; for ( int k = NUM ; k < mindim ; k ++ ) { final double min 1 = v1 . get Min ( k ) , max 1 = v1 . get Max ( k ) ; final double min 2 = v2 . get Min ( k ) , max 2 = v2 . get Max ( k ) ; final double p1 = min 1 * min 2 , p2 = min 1 * max 2 ; final double p3 = max 1 * min 2 , p4 = max 1 * max 2 ; s1 += Math . max ( Math . max ( p1 , p2 ) , Math . max ( p3 , p4 ) ) ; s2 += Math . min ( Math . min ( p1 , p2 ) , Math . min ( p3 , p4 ) ) ; if ( max 1 < NUM ) { l1 += max 1 * max 1 ; } else if ( min 1 > NUM ) { l1 += min 1 * min 1 ; } if ( max 2 < NUM ) { l2 += max 2 * max 2 ; } else if ( min 2 > NUM ) { l2 += min 2 * min 2 ; } } for ( int k = mindim ; k < dim 1 ; k ++ ) { final double min 1 = v1 . get Min ( k ) , max 1 = v1 . get Max ( k ) ; if ( max 1 < NUM ) { l1 += max 1 * max 1 ; } else if ( min 1 > NUM ) { l1 += min 1 * min 1 ; } } for ( int k = mindim ; k < dim 2 ; k ++ ) { final double min 2 = v2 . get Min ( k ) , max 2 = v2 . get Max ( k ) ; if ( max 2 < NUM ) { l2 += max 2 * max 2 ; } else if ( min 2 > NUM ) { l2 += min 2 * min 2 ; } } final double cross = Math . max ( s1 , Math . abs ( s2 ) ) ; final double a = ( cross == NUM ) ? NUM : ( l1 == NUM || l2 == NUM ) ? NUM : Math . sqrt ( ( cross / l1 ) * ( cross / l2 ) ) ; return ( a < NUM ) ? a : NUM ; }
@ Override public void key Pressed ( Key Event e ) { synchronized ( key Lock ) { keys Down . add ( e . get Key Code ( ) ) ; } for ( Draw Listener listener : listeners ) listener . key Pressed ( e . get Key Code ( ) ) ; }
public static String slurp URL No Exceptions ( URL u ) { try { return slurp URL ( u ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public static Rename Participant [ ] load Rename Participants ( Refactoring Status status , Refactoring Processor processor , Object element , Rename Arguments arguments , I Participant Descriptor Filter filter , String [ ] affected Natures , Sharable Participants shared ) { Refactoring Participant [ ] participants = fg Rename Instance . get Participants ( status , processor , element , arguments , filter , affected Natures , shared ) ; Rename Participant [ ] result = new Rename Participant [ participants . length ] ; System . arraycopy ( participants , NUM , result , NUM , participants . length ) ; return result ; }
private Array List < Array DBI Ds > build One Dim Indexes ( Relation < ? extends Number Vector > relation ) { final int dim = Relation Util . dimensionality ( relation ) ; Array List < Array DBI Ds > subspace Index = new Array List < > ( dim + NUM ) ; Sort DBI Ds By Single Dimension comp = new Vector Util . Sort DBI Ds By Single Dimension ( relation ) ; for ( int i = NUM ; i < dim ; i ++ ) { Array Modifiable DBI Ds am DBI Ds = DBID Util . new Array ( relation . get DBI Ds ( ) ) ; comp . set Dimension ( i ) ; am DBI Ds . sort ( comp ) ; subspace Index . add ( am DBI Ds ) ; } return subspace Index ; }
private void paint Foreground Pressed ( Graphics 2 D g , int width , int height ) { Shape s = decode Arrow Path ( width , height ) ; g . set Paint ( pressed Color ) ; g . fill ( s ) ; }
private Osm User read User ( ) { String raw User Id ; String raw User Name ; raw User Id = reader . get Attribute Value ( null , ATTRIBUTE NAME USER ID ) ; raw User Name = reader . get Attribute Value ( null , ATTRIBUTE NAME USER ) ; if ( raw User Id != null ) { int user Id ; String user Name ; user Id = Integer . parse Int ( raw User Id ) ; if ( raw User Name == null ) { user Name = STRING ; } else { user Name = raw User Name ; } return new Osm User ( user Id , user Name ) ; } else { return Osm User . NONE ; } }
@ Override public XML Event next Event ( ) throws XML Stream Exception { log . log ( Level . FINE , STRING ) ; current Event = next Event ; if ( current Event . get Event Type ( ) != XML Stream Constants . END DOCUMENT ) { next Event = construct Event ( stream . next ( ) , stream ) ; } else { next Event = null ; } log . log ( Level . FINE , STRING , current Event ) ; return current Event ; }
private void close Connection ( Connection connection ) throws SQL Exception { if ( connection != null ) { try { connection . close ( ) ; } catch ( SQL Exception e ) { throw new SQL Exception ( STRING , e ) ; } } }
public void validate ( @ Non Null Object object , @ Non Null Exclusion Strategy exclusion Strategy ) throws Rave Exception { Class < ? > clazz = object . get Class ( ) ; Validated validated = clazz . get Annotation ( Validated . class ) ; Base Validator validator ; synchronized ( this ) { if ( validated == null && ! unannotated Model Validator . has Seen ( clazz ) ) { unannotated Model Validator . process Non Annotated Classes ( clazz ) ; } validator = class Validator Map . get ( clazz ) ; if ( validator == null ) { validator = get Validator Instance ( clazz ) ; } if ( validator == null ) { throw new Unsupported Object Exception ( Collections . singleton List ( new Rave Error ( clazz , STRING , Rave Error Strings . CLASS NOT SUPPORTED ERROR ) ) ) ; } } validator . validate ( object , exclusion Strategy ) ; }
void cross Over ( Bayes Net Representation other ) { boolean [ ] bits = new boolean [ m bits . length ] ; for ( int i = NUM ; i < m bits . length ; i ++ ) { bits [ i ] = m bits [ i ] ; } int i Cross Over Point = m bits . length ; do { for ( int i = i Cross Over Point ; i < m bits . length ; i ++ ) { m bits [ i ] = bits [ i ] ; } i Cross Over Point = m random . next Int ( m bits . length ) ; for ( int i = i Cross Over Point ; i < m bits . length ; i ++ ) { m bits [ i ] = other . m bits [ i ] ; } } while ( has Cycles ( ) ) ; calc Score ( ) ; }
public byte [ ] digest ( ) { byte [ ] result = engine Digest ( ) ; state = INITIAL ; return result ; }
public void show Perspective ( final String perspective Name ) { show Perspective ( model . get Perspective ( perspective Name ) ) ; }
public static double phred To Prob ( double phred ) { return Math . pow ( NUM , - phred / NUM ) ; }
protected Token < Token Type > read Delimited String Token ( char delimiter , char escape Char , Token Type token Type ) throws Simple Parser Exception { final Token Position position = get Token Position ( ) ; final String attachment = read Delimited String ( delimiter , escape Char ) ; return new Token < > ( token Type , position , attachment . length ( ) , attachment ) ; }
public void test Set String ( ) throws Exception { connection . set Auto Commit ( BOOL ) ; Prepared Statement stmt = connection . prepare Statement ( STRING ) ; try { stmt . set Int ( NUM , NUM ) ; stmt . set String ( NUM , TEST TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; stmt . set Int ( NUM , NUM ) ; stmt . set String ( NUM , TEST TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; stmt . set Int ( NUM , NUM ) ; stmt . set String ( NUM , TEST TEXT ) ; stmt . execute Update ( ) ; connection . commit ( ) ; } finally { stmt . close ( ) ; } connection . set Auto Commit ( BOOL ) ; }
public Eg Demand Details insert Advance Collection ( final String demand Reason , final Big Decimal advance Collection Amount , final Installment installment ) { Eg Demand Details demand Detail = null ; if ( advance Collection Amount != null && advance Collection Amount . compare To ( Big Decimal . ZERO ) > NUM ) { final Eg Demand Reason Master eg Demand Reason Master = demand Generic DAO . get Demand Reason Master By Code ( demand Reason , module ( ) ) ; if ( eg Demand Reason Master == null ) throw new Application Runtime Exception ( STRING ) ; final Eg Demand Reason eg Demand Reason = demand Generic DAO . get Dmd Reason By Dmd Reason Mster Install And Mod ( eg Demand Reason Master , installment , module ( ) ) ; if ( eg Demand Reason == null ) throw new Application Runtime Exception ( STRING ) ; demand Detail = create Demand Details ( eg Demand Reason , advance Collection Amount , Big Decimal . ZERO ) ; } return demand Detail ; }
private void load Database Header ( Byte Buffer bb ) throws IO Exception { if ( bb . get Int ( ) != MAGIC ) { throw new Error ( STRING ) ; } if ( bb . get Int ( ) != VERSION ) { throw new Error ( STRING ) ; } sample Rate = bb . get Int ( ) ; num Channels = bb . get Int ( ) ; lpc Min = bb . get Float ( ) ; lpc Range = bb . get Float ( ) ; }
public void handle Periodic Maintenance ( Operation post ) { post . complete ( ) ; }
public < T > T time ( Callable < T > event ) throws Exception { final long start Time = clock . get Tick ( ) ; try { return event . call ( ) ; } finally { update ( clock . get Tick ( ) - start Time ) ; } }
public static boolean is Post JDK 5 ( String bytecode Version ) { return JDK 5 . equals ( bytecode Version ) || JDK 6 . equals ( bytecode Version ) || JDK 7 . equals ( bytecode Version ) || JDK 8 . equals ( bytecode Version ) ; }
public Create Index Request mapping ( String type , Object ... source ) { mapping ( type , Put Mapping Request . build From Simplified Def ( type , source ) ) ; return this ; }
protected Data Input Stream open File On Mounted Obb ( String obb Path , String file Name ) { assert True ( STRING , m Sm . is Obb Mounted ( obb Path ) ) ; String path = m Sm . get Mounted Obb Path ( obb Path ) ; assert True ( STRING , path != null ) ; File in File = new File ( path , file Name ) ; Data Input Stream in Stream = null ; try { in Stream = new Data Input Stream ( new File Input Stream ( in File ) ) ; Log . i ( LOG TAG , STRING + file Name + STRING + path ) ; } catch ( File Not Found Exception e ) { Log . e ( LOG TAG , e . to String ( ) ) ; return null ; } catch ( Security Exception e ) { Log . e ( LOG TAG , e . to String ( ) ) ; return null ; } return in Stream ; }
public void remove Listener ( Circular Progress View Listener listener ) { listeners . remove ( listener ) ; }
public Http Health Check Service ( Health Checker ... health Checkers ) { this . health Checkers = Collections . unmodifiable List ( Arrays . as List ( health Checkers ) ) ; server Health = new Settable Health Checker ( ) ; server Health Updater = new Server Health Updater ( ) ; }
@ Override public void render Forms Onto G 2 In Headless ( final Object raw , final int page Index , final Map components To Ignore , final Form Factory form Factory ) { if ( forms Ordered == null || forms Ordered [ page Index ] == null ) { return ; } this . components To Ignore = components To Ignore ; Form Object form Object ; final boolean is Printing = form Factory != null ; final Graphics 2 D g2 = ( Graphics 2 D ) raw ; final Affine Transform default Af = g2 . get Transform ( ) ; final Affine Transform aff = g2 . get Transform ( ) ; aff . scale ( NUM , NUM ) ; g2 . set Transform ( aff ) ; for ( final Form Object next Val : forms Ordered [ page Index ] ) { if ( next Val != null ) { form Object = next Val ; final boolean [ ] flags = form Object . get Characteristics ( ) ; if ( ( ( flags [ NUM ] || ( is Printing && ! flags [ NUM ] ) ) ) ) { continue ; } render Component ( g2 , form Object , is Printing ) ; } } g2 . set Transform ( default Af ) ; }
public void log ( S retained , S discarded ) { if ( discarded == null ) return ; List < S > retained List = history Map . get ( retained ) ; if ( retained List == null ) { retained List = new Array List < > ( ) ; history Map . put ( retained , retained List ) ; } List < S > discarded List = history Map . get Or Default ( discarded , Collections . empty List ( ) ) ; history Map . remove ( discarded ) ; retained List . add All ( discarded List ) ; retained List . add ( discarded ) ; }
public final static boolean is Main Context ( App Context ctx ) { return ( ctx != null && ctx == main App Context ) ; }
private List < String > pick Table Names From Table Models ( ) { List < String > table Names = new Array List < String > ( ) ; for ( Table Model table Model : m Table Models ) { table Names . add ( table Model . get Table Name ( ) ) ; } return table Names ; }
public boolean contains One Category ( List categories ) { for ( Iterator iter = categories . iterator ( ) ; iter . has Next ( ) ; ) { Group Category category = ( Group Category ) iter . next ( ) ; if ( contains ( category ) ) return BOOL ; } return BOOL ; }
private void unmark Removed Default Session Token ( String site , String token ) { if ( removed Default Tokens == null ) return ; Hash Set < String > removed = removed Default Tokens . get ( site ) ; if ( removed == null ) return ; removed . remove ( token ) ; }
private boolean apply Volumes To Masks Using Rules ( Storage System storage , Export Group export Group , Map < URI , Map < URI , Integer > > existing Masks To Update With New Volumes , Map < URI , Map < URI , Integer > > volumes With No Mask , Map < Export Mask , Export Mask Policy > masks Map , Map < URI , Set < Initiator > > mask To Initiators Map , Set < URI > partial Masks , String token ) { boolean is VMAX 3 = storage . check If Vmax 3 ( ) ; if ( export Group . check Internal Flags ( Flag . RECOVERPOINT ) || ( export Group . check Internal Flags ( Flag . RECOVERPOINT JOURNAL ) ) ) { masks Map = apply Volumes To Masks Using RPVMAX Rules ( storage , export Group , masks Map ) ; if ( masks Map . is Empty ( ) ) { log . info ( STRING ) ; return BOOL ; } } if ( ! apply Volumes To Masks Using Rule ( export Group , token , existing Masks To Update With New Volumes , volumes With No Mask , masks Map , mask To Initiators Map , partial Masks , NUM , is VMAX 3 ) ) { return BOOL ; } if ( ! apply Volumes To Masks Using Rule ( export Group , token , existing Masks To Update With New Volumes , volumes With No Mask , masks Map , mask To Initiators Map , partial Masks , NUM , is VMAX 3 ) ) { return BOOL ; } if ( ! apply Volumes To Masks Using Rule ( export Group , token , existing Masks To Update With New Volumes , volumes With No Mask , masks Map , mask To Initiators Map , partial Masks , NUM , is VMAX 3 ) ) { return BOOL ; } return BOOL ; }
public Twitch Api Request ( Twitch Api origin , Request Type type , String url ) { this ( origin , type , url , null ) ; }
public static final long file Time To Unix Time ( File Time ftime ) { return ftime . to ( Time Unit . SECONDS ) ; }
public void add Address ( Address Entity address ) { addresses . add ( address ) ; }
static String write Configuration ( Configuration cfg , String path From Ignite Home ) throws IO Exception { if ( ! path From Ignite Home . starts With ( STRING ) ) path From Ignite Home = STRING + path From Ignite Home ; final String path = U . get Ignite Home ( ) + path From Ignite Home ; delete ( path ) ; File file = new File ( path ) ; try ( File Output Stream fos = new File Output Stream ( file ) ) { cfg . write Xml ( fos ) ; } assert True ( file . exists ( ) ) ; return path ; }
static synchronized String format ( String key , Object [ ] arguments ) { if ( message Format == null ) { message Format = new Message Format ( text Resources . get String ( key ) ) ; } else { message Format . apply Pattern ( text Resources . get String ( key ) ) ; } return ( message Format . format ( arguments ) ) ; }
protected Element insert Prosody Settings ( Element insert Here , Feature Set feature Set ) { if ( insert Here == null || feature Set == null ) throw new Null Pointer Exception ( STRING ) ; boolean have Prosody Info = BOOL ; for ( String att : XML 2 Utt Base . PROSODY ATTRIBUTES ) { if ( feature Set . get String ( att ) != null ) { have Prosody Info = BOOL ; break ; } } if ( ! have Prosody Info ) { return null ; } Document doc = insert Here . get Owner Document ( ) ; Element prosody = Mary XML . create Element ( doc , Mary XML . PROSODY ) ; insert Here . append Child ( prosody ) ; for ( String att : XML 2 Utt Base . PROSODY ATTRIBUTES ) { String val = feature Set . get String ( att ) ; if ( val != null ) { prosody . set Attribute ( att , val ) ; } } return prosody ; }
public static void save Photo To SD Card ( Bitmap photo Bitmap , String path , String photo Name ) { if ( check SD Card Available ( ) ) { File dir = new File ( path ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } File photo File = new File ( path , photo Name + STRING ) ; File Output Stream file Output Stream = null ; try { file Output Stream = new File Output Stream ( photo File ) ; if ( photo Bitmap != null ) { if ( photo Bitmap . compress ( Bitmap . Compress Format . PNG , NUM , file Output Stream ) ) { file Output Stream . flush ( ) ; } } } catch ( File Not Found Exception e ) { photo File . delete ( ) ; e . print Stack Trace ( ) ; } catch ( IO Exception e ) { photo File . delete ( ) ; e . print Stack Trace ( ) ; } finally { try { file Output Stream . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } }
private void check Protocol Already Exists ( Set < String > protocols , String protocol Type ) { if ( ! protocols . contains ( protocol Type ) ) { protocols . add ( protocol Type ) ; } }
@ Override public V put ( K key , V value ) { if ( key == null ) return put For Null Key ( value ) ; int hash = hash ( key ) ; int i = index For ( hash , table . length ) ; for ( Entry < K , V > e = table [ i ] ; e != null ; e = e . next ) { Object k ; if ( e . hash == hash && ( ( k = e . key ) == key || key . equals ( k ) ) ) { V old Value = e . value ; e . value = value ; e . record Access ( this ) ; return old Value ; } } mod Count ++ ; add Entry ( hash , key , value , i ) ; return null ; }
public Custom Configuration Builder ( Class Loader cl , String resource ) throws Configuration Exception { this ( ) ; Input Stream is = cl . get Resource As Stream ( resource ) ; if ( is == null ) throw new Configuration Exception ( STRING + resource + STRING ) ; try { try { load ( is ) ; loaded On Instantiation = BOOL ; } finally { is . close ( ) ; } } catch ( IO Exception e ) { throw new Configuration Exception ( e ) ; } }
private static void log Start Record ( Logger logger ) { try { Log Message Provider Base provider = ( Log Message Provider Base ) Message Provider Factory . get Provider ( STRING ) ; SSO Token ssot = Log Manager Util . get Logging SSO Token ( ) ; String location = lm . get Property ( Log Constants . LOG LOCATION ) ; String [ ] s = { location } ; com . sun . identity . log . Log Record lr = provider . create Log Record ( Log Constants . START LOG NEW LOGGER NAME , s , ssot ) ; logger . log ( lr , ssot ) ; } catch ( IO Exception ioex ) { Debug . error ( STRING + logger . get Name ( ) + STRING + ioex . get Message ( ) ) ; } }
protected Size 2 D draw Horizontal ( Graphics 2 D g2 , Rectangle 2 D chart Area ) { double start Y ; double top Space ; double bottom Space ; double left Space ; double right Space ; double w = get Width ( ) ; double h = get Height ( ) ; Rectangle Insets padding = get Padding ( ) ; top Space = padding . calculate Top Outset ( h ) ; bottom Space = padding . calculate Bottom Outset ( h ) ; left Space = padding . calculate Left Outset ( w ) ; right Space = padding . calculate Right Outset ( w ) ; if ( get Position ( ) == Rectangle Edge . TOP ) { start Y = chart Area . get Y ( ) + top Space ; } else { start Y = chart Area . get Y ( ) + chart Area . get Height ( ) - bottom Space - h ; } Horizontal Alignment horizontal Alignment = get Horizontal Alignment ( ) ; double start X = NUM ; if ( horizontal Alignment == Horizontal Alignment . CENTER ) { start X = chart Area . get X ( ) + left Space + chart Area . get Width ( ) / NUM - w / NUM ; } else if ( horizontal Alignment == Horizontal Alignment . LEFT ) { start X = chart Area . get X ( ) + left Space ; } else if ( horizontal Alignment == Horizontal Alignment . RIGHT ) { start X = chart Area . get X ( ) + chart Area . get Width ( ) - right Space - w ; } g2 . draw Image ( this . image , ( int ) start X , ( int ) start Y , ( int ) w , ( int ) h , null ) ; return new Size 2 D ( chart Area . get Width ( ) + left Space + right Space , h + top Space + bottom Space ) ; }
private static final Private Key construct Private Key ( byte [ ] encoded Key , String encoded Key Algorithm ) throws Invalid Key Exception , No Such Algorithm Exception { Private Key key = null ; try { Key Factory key Factory = Key Factory . get Instance ( encoded Key Algorithm , Sun JCE . get Instance ( ) ) ; PKCS 8 Encoded Key Spec key Spec = new PKCS 8 Encoded Key Spec ( encoded Key ) ; return key Factory . generate Private ( key Spec ) ; } catch ( No Such Algorithm Exception nsae ) { try { Key Factory key Factory = Key Factory . get Instance ( encoded Key Algorithm ) ; PKCS 8 Encoded Key Spec key Spec = new PKCS 8 Encoded Key Spec ( encoded Key ) ; key = key Factory . generate Private ( key Spec ) ; } catch ( No Such Algorithm Exception nsae 2 ) { throw new No Such Algorithm Exception ( STRING + STRING + encoded Key Algorithm + STRING ) ; } catch ( Invalid Key Spec Exception ikse 2 ) { Invalid Key Exception ike = new Invalid Key Exception ( STRING ) ; ike . init Cause ( ikse 2 ) ; throw ike ; } } catch ( Invalid Key Spec Exception ikse ) { Invalid Key Exception ike = new Invalid Key Exception ( STRING ) ; ike . init Cause ( ikse ) ; throw ike ; } return key ; }
private Object execute Between ( Page Context pc , SQL sql , Query qr , Operation 3 expression , int row ) throws Page Exception { Object left = execute Exp ( pc , sql , qr , expression . get Exp ( ) , row ) ; Object right 1 = execute Exp ( pc , sql , qr , expression . get Left ( ) , row ) ; Object right 2 = execute Exp ( pc , sql , qr , expression . get Right ( ) , row ) ; return ( ( Operator . compare ( left , right 1 ) >= NUM ) && ( Operator . compare ( left , right 2 ) <= NUM ) ) ? Boolean . TRUE : Boolean . FALSE ; }
@ Override public Completable Future < Optional < T > > min ( final Comparator < ? super T > comparator ) { return Completable Future . supply Async ( null , exec ) ; }
final public void println ( int v ) { Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( newline , NUM , newline . length ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
public void test restart Safe one Write No Commit ( ) { I Atomic Store store = ( I Atomic Store ) get Store ( ) ; try { assert True ( store . is Stable ( ) ) ; final Random r = new Random ( ) ; final int len = NUM ; final byte [ ] expected = new byte [ len ] ; r . next Bytes ( expected ) ; final Byte Buffer tmp = Byte Buffer . wrap ( expected ) ; final long addr 1 = store . write ( tmp ) ; assert Equals ( len , tmp . position ( ) ) ; assert Equals ( tmp . position ( ) , tmp . limit ( ) ) ; final Byte Buffer actual = store . read ( addr 1 ) ; assert Equals ( expected , actual ) ; assert Equals ( NUM , actual . position ( ) ) ; assert Equals ( expected . length , actual . limit ( ) ) ; store = ( I Atomic Store ) reopen Store ( store ) ; assert True ( store . is Stable ( ) ) ; try { store . read ( addr 1 ) ; fail ( STRING + Illegal Argument Exception . class ) ; } catch ( Runtime Exception ex ) { if ( Inner Cause . is Inner Cause ( ex , Illegal Argument Exception . class ) ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + ex ) ; } else { fail ( STRING + Illegal Argument Exception . class + STRING + ex , ex ) ; } } } finally { store . destroy ( ) ; } }
public Core Admin Handler ( final Core Container core Container ) { this . core Container = core Container ; Hash Map < String , Map < String , Task Object > > map = new Hash Map < > ( NUM , NUM ) ; map . put ( RUNNING , Collections . synchronized Map ( new Linked Hash Map < String , Task Object > ( ) ) ) ; map . put ( COMPLETED , Collections . synchronized Map ( new Linked Hash Map < String , Task Object > ( ) ) ) ; map . put ( FAILED , Collections . synchronized Map ( new Linked Hash Map < String , Task Object > ( ) ) ) ; request Status Map = Collections . unmodifiable Map ( map ) ; }
@ Suppress Warnings ( STRING ) @ Not Null private static Text Range process Smart Tabs ( @ Not Null Helper helper , @ Not Null Text Range range , int tab Width ) { Char Sequence prev Line Indent = helper . get Prev Line Indent ( ) ; if ( prev Line Indent == null ) { return process Tabs ( helper , range , tab Width ) ; } Char Sequence current Line Indent = helper . get Current Line Indent ( ) ; int line Start = NUM ; int start = Math . max ( NUM , range . get Start Offset ( ) - helper . get Current Line Start Offset ( ) ) ; int end = Math . min ( current Line Indent . length ( ) , range . get End Offset ( ) - helper . get Current Line Start Offset ( ) ) ; int indent Offset = NUM ; int tabs Replaced = NUM ; for ( int i = line Start ; i < end && indent Offset < prev Line Indent . length ( ) ; i ++ , indent Offset ++ ) { char c = current Line Indent . char At ( i ) ; if ( prev Line Indent . char At ( indent Offset ) == STRING ) { if ( c == STRING ) { continue ; } else { break ; } } if ( c == STRING ) { continue ; } if ( end - i < tab Width ) { break ; } boolean can Replace = BOOL ; for ( int j = i + NUM , max = Math . min ( end , i + tab Width ) ; j < max ; j ++ ) { if ( current Line Indent . char At ( j ) != STRING ) { can Replace = BOOL ; break ; } } if ( ! can Replace ) { break ; } if ( i < start ) { i += tab Width - NUM ; continue ; } helper . replace ( i , i + tab Width , STRING ) ; tabs Replaced ++ ; end -= tab Width - NUM ; } return tabs Replaced > NUM ? Text Range . create ( range . get Start Offset ( ) , range . get End Offset ( ) - tabs Replaced * ( tab Width - NUM ) ) : range ; }
protected double kNN Distance ( ) { double knn Dist = NUM ; for ( int i = NUM ; i < get Num Entries ( ) ; i ++ ) { Mk Max Entry entry = get Entry ( i ) ; knn Dist = Math . max ( knn Dist , entry . get Knn Distance ( ) ) ; } return knn Dist ; }
public static Test Diagnostic Line from Java Source Line ( String filename , String original Line , long line Number ) { final String trimmed Line = original Line . trim ( ) ; long error Line = line Number + NUM ; if ( trimmed Line . starts With ( STRING ) ) { String rest Of Line = trimmed Line . substring ( NUM ) ; String [ ] diagnostic Strs = rest Of Line . split ( STRING ) ; List < Test Diagnostic > diagnostics = new Array List < > ( diagnostic Strs . length ) ; for ( String diagnostic : diagnostic Strs ) { diagnostics . add ( from Java File Comment ( filename , error Line , diagnostic ) ) ; } return new Test Diagnostic Line ( filename , error Line , original Line , Collections . unmodifiable List ( diagnostics ) ) ; } else if ( trimmed Line . starts With ( STRING ) ) { String diagnostic String = trimmed Line . substring ( NUM ) ; Test Diagnostic diagnostic = from Java File Comment ( STRING , NUM , diagnostic String ) ; return new Test Diagnostic Line ( STRING , NUM , original Line , Collections . singleton List ( diagnostic ) ) ; } else { return new Test Diagnostic Line ( filename , error Line , original Line , EMPTY ) ; } }
public String encode ( String p String , String charset ) throws Unsupported Encoding Exception { if ( p String == null ) { return null ; } return new String ( encode ( p String . get Bytes ( charset ) ) , String Encodings . US ASCII ) ; }
public void slide ( ) { int position = NUM ; if ( items != null ) { position = items . size ( ) / NUM ; } slide ( position ) ; }
public boolean is Debugging Finer ( ) { return logger . is Loggable ( Level . FINER ) ; }
private static void sort 1 ( long [ ] x , int off , int len ) { if ( len < NUM ) { for ( int i = off ; i < len + off ; i ++ ) for ( int j = i ; j > off && x [ j - NUM ] > x [ j ] ; j -- ) swap ( x , j , j - NUM ) ; return ; } int m = off + ( len > > NUM ) ; if ( len > NUM ) { int l = off ; int n = off + len - NUM ; if ( len > NUM ) { int s = len / NUM ; l = med 3 ( x , l , l + s , l + NUM * s ) ; m = med 3 ( x , m - s , m , m + s ) ; n = med 3 ( x , n - NUM * s , n - s , n ) ; } m = med 3 ( x , l , m , n ) ; } long v = x [ m ] ; int a = off , b = a , c = off + len - NUM , d = c ; while ( BOOL ) { while ( b <= c && x [ b ] <= v ) { if ( x [ b ] == v ) swap ( x , a ++ , b ) ; b ++ ; } while ( c >= b && x [ c ] >= v ) { if ( x [ c ] == v ) swap ( x , c , d -- ) ; c -- ; } if ( b > c ) break ; swap ( x , b ++ , c -- ) ; } int s , n = off + len ; s = Math . min ( a - off , b - a ) ; vecswap ( x , off , b - s , s ) ; s = Math . min ( d - c , n - d - NUM ) ; vecswap ( x , b , n - s , s ) ; if ( ( s = b - a ) > NUM ) sort 1 ( x , off , s ) ; if ( ( s = d - c ) > NUM ) sort 1 ( x , n - s , s ) ; }
public void reset ( ) { coords . remove All Elements ( ) ; xypoints . remove All Elements ( ) ; profile Line . set Location ( set LL Points ( ) , OM Graphic . RADIANS ) ; state Machine . reset ( ) ; layer . repaint ( ) ; last Mouse = null ; }
@ Layoutlib Delegate static float cos ( float angle ) { return ( float ) Math . cos ( angle ) ; }
@ Override public int process Image ( String name , final int data Pointer , final Pdf Object X Object ) throws Pdf Exception { String key = null ; if ( Image Commands . reject Superimposed Images ) { key = ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) + STRING + ( ( int ) gs . CTM [ NUM ] [ NUM ] ) ; } try { if ( System . get Property ( STRING ) == null ) { process X Image ( name , name , key , X Object ) ; } } catch ( final Error e ) { Log Writer . write Log ( STRING + e . get Message ( ) ) ; parser Options . images Processed Fully = BOOL ; error Tracker . add Page Failure Message ( STRING + e + STRING ) ; } catch ( final Exception e ) { Log Writer . write Log ( STRING + e ) ; parser Options . images Processed Fully = BOOL ; error Tracker . add Page Failure Message ( STRING + e + STRING ) ; } return data Pointer ; }
public byte [ ] embed Data ( byte [ ] msg , String msg File Name , byte [ ] cover , String cover File Name , String stego File Name ) throws Open Stego Exception { Buffered Image image = null ; Dct LSB Output Stream os = null ; int img Type = NUM ; try { if ( cover == null ) { image = Image Util . generate Random Image ( ( DCT Data Header . get Max Header Size ( ) + msg . length ) * NUM * DCT . NJPEG * DCT . NJPEG ) ; } else { image = Image Util . byte Array To Image ( cover , cover File Name ) ; } img Type = image . get Type ( ) ; os = new Dct LSB Output Stream ( image , msg . length , msg File Name , this . config ) ; os . write ( msg ) ; os . close ( ) ; return Image Util . image To Byte Array ( os . get Image ( img Type ) , stego File Name , this ) ; } catch ( IO Exception io Ex ) { throw new Open Stego Exception ( io Ex ) ; } }
private void parse Session String ( ) { if ( is Parsed ) { return ; } if ( is Null ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } String server ID = null ; try { String sid String = encrypted String ; if ( is C 66 Encoded ( ) ) { sid String = c66 Decode Cookie String ( encrypted String ) ; } int outer Index = sid String . last Index Of ( STRING ) ; if ( outer Index == - NUM ) { is Parsed = BOOL ; return ; } String outer = sid String . substring ( outer Index + NUM ) ; int tail Index = outer . index Of ( STRING ) ; tail = outer . substring ( tail Index + NUM ) ; if ( tail Index != - NUM ) { String extension Part = outer . substring ( NUM , tail Index ) ; extensions = new Dynamic Session ID Extensions ( new Legacy Session ID Extensions ( extension Part ) ) ; } else { extensions = new Legacy Session ID Extensions ( ) ; } server ID = extensions . get Site ID ( ) ; if ( server ID != null ) { set Server ID ( server ID ) ; } } catch ( Exception e ) { debug . error ( STRING + encrypted String + STRING , e ) ; throw new Illegal Argument Exception ( STRING + encrypted String + STRING + e ) ; } is Parsed = BOOL ; }
static Automaton reverse ( Automaton a , Set < Integer > initial States ) { if ( Operations . is Empty ( a ) ) { return new Automaton ( ) ; } int num States = a . get Num States ( ) ; Automaton . Builder builder = new Automaton . Builder ( ) ; builder . create State ( ) ; for ( int s = NUM ; s < num States ; s ++ ) { builder . create State ( ) ; } builder . set Accept ( NUM , BOOL ) ; Transition t = new Transition ( ) ; for ( int s = NUM ; s < num States ; s ++ ) { int num Transitions = a . get Num Transitions ( s ) ; a . init Transition ( s , t ) ; for ( int i = NUM ; i < num Transitions ; i ++ ) { a . get Next Transition ( t ) ; builder . add Transition ( t . dest + NUM , s + NUM , t . min , t . max ) ; } } Automaton result = builder . finish ( ) ; int s = NUM ; Bit Set accept States = a . get Accept States ( ) ; while ( s < num States && ( s = accept States . next Set Bit ( s ) ) != - NUM ) { result . add Epsilon ( NUM , s + NUM ) ; if ( initial States != null ) { initial States . add ( s + NUM ) ; } s ++ ; } result . finish State ( ) ; return result ; }
private void notify After ( Faces Context context , Lifecycle lifecycle ) { UI View Root view Root = context . get View Root ( ) ; if ( null == view Root ) { return ; } Method Expression after Phase = view Root . get After Phase Listener ( ) ; if ( null != after Phase ) { try { Phase Event event = new Phase Event ( context , Phase Id . RESTORE VIEW , lifecycle ) ; after Phase . invoke ( context . get EL Context ( ) , new Object [ ] { event } ) ; } catch ( Exception e ) { if ( LOGGER . is Loggable ( Level . SEVERE ) ) { LOGGER . log ( Level . SEVERE , STRING , new Object [ ] { after Phase . get Expression String ( ) , ( STRING ) } ) ; } return ; } } }
public static < T > boolean equals ( final Collection < T > c1 , final Collection < T > c2 ) { if ( c1 == null || c2 == null ) { return c1 == c2 ; } if ( c1 . size ( ) != c2 . size ( ) ) { return BOOL ; } if ( c1 == c2 ) { return BOOL ; } if ( ! c1 . contains All ( c2 ) ) { return BOOL ; } return c2 . contains All ( c1 ) ; }
public boolean check Root By Super User Apk ( ) { File su Apk = new File ( SU APK ) ; if ( su Apk . exists ( ) ) { if ( Constants . DEBUG MODE ENABLED ) { Log . d ( TAG , STRING ) ; } return BOOL ; } return BOOL ; }
private void create Expression Parameter List ( Filter Node node , int no Of Expressions , List < Expression > parameter Filter ) { if ( no Of Expressions <= node . get Child Count ( ) ) { for ( int index = NUM ; index < no Of Expressions ; index ++ ) { Expression Node expression Node = ( Expression Node ) node . get Child At ( index ) ; Expression expression = add Expression ( expression Node ) ; parameter Filter . add ( expression ) ; } } }
public < E extends T > E max ( Iterable < E > iterable ) { Iterator < E > iterator = iterable . iterator ( ) ; E max So Far = iterator . next ( ) ; while ( iterator . has Next ( ) ) { max So Far = max ( max So Far , iterator . next ( ) ) ; } return max So Far ; }
public void bind Tree ( Container ui , int defer , boolean object Lead ) { int component Count = ui . get Component Count ( ) ; for ( int iter = NUM ; iter < component Count ; iter ++ ) { Component c = ui . get Component At ( iter ) ; if ( c instanceof Container ) { bind Tree ( ( Container ) c , defer , object Lead ) ; continue ; } String bind = c . get Cloud Bound Property ( ) ; if ( bind != null && bind . length ( ) > NUM ) { String attribute Name = c . get Cloud Destination Property ( ) ; if ( attribute Name != null ) { bind Property ( c , bind , attribute Name , defer , object Lead ) ; } } } }
public void register Template ( String class Name , Class template ) { templates . put ( class Name , new Injection Template ( template . get Name ( ) ) ) ; }
public void write Field ( final String name , final long value ) throws java . io . IO Exception { write Field ( name , Long . to String ( value ) ) ; }
private void extract Row Key And Data ( String line , Default Category Dataset dataset , List column Keys ) { Comparable row Key = null ; int field Index = NUM ; int start = NUM ; for ( int i = NUM ; i < line . length ( ) ; i ++ ) { if ( line . char At ( i ) == this . field Delimiter ) { if ( field Index == NUM ) { String key = line . substring ( start , i ) ; row Key = remove String Delimiters ( key ) ; } else { Double value = Double . value Of ( remove String Delimiters ( line . substring ( start , i ) ) ) ; dataset . add Value ( value , row Key , ( Comparable ) column Keys . get ( field Index - NUM ) ) ; } start = i + NUM ; field Index ++ ; } } Double value = Double . value Of ( remove String Delimiters ( line . substring ( start , line . length ( ) ) ) ) ; dataset . add Value ( value , row Key , ( Comparable ) column Keys . get ( field Index - NUM ) ) ; }
protected void draw Oval ( int x , int y , int w , int h , Color fill Color , Paint fill Paint , Color pen Color , boolean shadow ) { if ( fill Color != null || fill Paint != null ) { if ( shadow ) { g . set Color ( mx Constants . SHADOW COLOR ) ; g . fill Oval ( x + mx Constants . SHADOW OFFSETX , y + mx Constants . SHADOW OFFSETY , w , h ) ; } if ( fill Paint != null ) { g . set Paint ( fill Paint ) ; } else { g . set Color ( fill Color ) ; } g . fill Oval ( x , y , w , h ) ; } if ( pen Color != null ) { g . set Color ( pen Color ) ; g . draw Oval ( x , y , w , h ) ; } }
Class < ? > load Class ( String class Name , Class Loader cl ) throws Class Not Found Exception { Class < ? > cls = Class . for Name ( class Name , BOOL , cl ) ; return cls ; }
private void enable Device Capabilities Area ( boolean enabled ) { m Disable Camera Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Widgets Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Secure Camera Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Notification Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Unredacted Checkbox . set Enabled ( enabled ) ; m Disable Keyguard Trust Agent Checkbox . set Enabled ( enabled ) ; }
void draw Letter ( Graphics g , char letter , int ax , int ay , int aw , int ah , float align , int index ) { String str = format Item Num ( index , letter ) ; str = is Left To Right ? str + STRING : STRING + str ; Font Metrics fm = Swing Utilities 2 . get Font Metrics ( null , g ) ; int stringwidth = Swing Utilities 2 . string Width ( null , fm , str ) ; int gap = is Left To Right ? - ( stringwidth + bulletgap ) : ( aw + bulletgap ) ; int x = ax + gap ; int y = Math . max ( ay + fm . get Ascent ( ) , ay + ( int ) ( ah * align ) ) ; Swing Utilities 2 . draw String ( null , g , str , x , y ) ; }
synchronized private void insert Text ( String a String ) { Attributed String attrib String = new Attributed String ( a String ) ; attrib String . add Attribute ( Attribute . LANGUAGE , get Locale ( ) , NUM , a String . length ( ) ) ; Text Hit Info the Caret = Text Hit Info . after Offset ( a String . length ( ) - NUM ) ; Input Method Event event = new Input Method Event ( f Awt Focussed Component , Input Method Event . INPUT METHOD TEXT CHANGED , attrib String . get Iterator ( ) , a String . length ( ) , the Caret , the Caret ) ; LWC Toolkit . post Event ( LWC Toolkit . target To App Context ( f Awt Focussed Component ) , event ) ; f Current Text = null ; f Current Text As String = null ; f Current Text Length = NUM ; }
public void action Performed ( java . awt . event . Action Event e ) { String command = e . get Action Command ( ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + command ) ; } if ( command == Layers Panel . Layer Top Cmd || command == Layers Panel . Layer Bottom Cmd || command == Layers Panel . Layer Up Cmd || command == Layers Panel . Layer Down Cmd || command == Layers Panel . Layer Remove Cmd ) { if ( selected != null ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + command + STRING + selected . get Name ( ) ) ; } fire Property Change ( command , null , selected ) ; } else { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + command + STRING ) ; } } if ( command == Layers Panel . Layer Remove Cmd ) { selected = null ; delete . set Enabled ( BOOL ) ; } } else if ( command . equals ( Layers Panel . Layer Add Cmd ) ) { if ( layer Add Panel != null ) { layer Add Panel . show Panel ( ) ; } } }
public static String to String ( Local Date data , String modelo ) { return data == null ? STRING : data . format ( formatter ( modelo ) ) ; }
@ Suppress Warnings ( STRING ) @ Json Creator public static Client Detail Response V 2 from Parts ( @ Json Property ( STRING ) String name , @ Json Property ( STRING ) String description , @ Json Property ( STRING ) long created At Seconds , @ Json Property ( STRING ) long updated At Seconds , @ Json Property ( STRING ) String created By , @ Json Property ( STRING ) String updated By , @ Json Property ( STRING ) Optional < Long > last Seen Seconds ) { return new Auto Value Client Detail Response V 2 ( name , description , created At Seconds , updated At Seconds , created By , updated By , last Seen Seconds ) ; }
public Info create Info ( String value ) { Information Field info Impl = new Information Field ( ) ; try { info Impl . set Value ( value ) ; } catch ( Sdp Exception s ) { s . print Stack Trace ( ) ; } return info Impl ; }
public Connection Info ( @ Nullable String user , @ Nullable String password , String driver Class Name , String authless Url , String full Url ) { this . user = user ; this . password = password ; this . driver Class Name = driver Class Name ; this . authless Url = authless Url ; this . full Url = full Url ; }
private void add ( String world , Permission Holder holder , String permission ) { try { if ( world != null && ! world . equals ( STRING ) ) { holder . set Permission ( permission , BOOL , server , world ) ; } else { holder . set Permission ( permission , BOOL , server ) ; } } catch ( Object Already Has Exception ignored ) { } save ( holder ) ; }
public Doubling Retry Schedule ( long start Interval , long max Interval , int multiplier ) { this ( ) ; start Interval = Math . max ( NUM , start Interval ) ; max Interval = Math . max ( NUM , max Interval ) ; multiplier = Math . max ( NUM , multiplier ) ; }
private boolean vdc Properties Changed ( ) { long local Vdc Config Version = local Vdc Prop Info . get Property ( Vdc Config Util . VDC CONFIG VERSION ) == null ? NUM : Long . parse Long ( local Vdc Prop Info . get Property ( Vdc Config Util . VDC CONFIG VERSION ) ) ; long target Vdc Config Version = target Site Info . get Vdc Config Version ( ) ; log . info ( STRING , local Vdc Config Version , target Vdc Config Version ) ; return local Vdc Config Version != target Vdc Config Version ; }
@ Override public void open Element ( String tag Name ) { Element new Element = document . create Element ( tag Name ) ; current . append Child ( new Element ) ; current = new Element ; }
public Format ( String p Format String ) { String l Format Vars [ ] = p Format String . split ( STRING ) ; m Id = Integer . parse Int ( l Format Vars [ NUM ] ) ; }
protected void update ( I Interval interval ) { if ( intervals == null ) { intervals = new Array List < I Interval > ( ) ; } intervals . add ( interval ) ; }
static URL fix Pure Query Targets ( URL base , String target ) throws Malformed URL Exception { if ( ! target . starts With ( STRING ) ) return new URL ( base , target ) ; String base Path = base . get Path ( ) ; String base Right Most = STRING ; int base Right Most Idx = base Path . last Index Of ( STRING ) ; if ( base Right Most Idx != - NUM ) { base Right Most = base Path . substring ( base Right Most Idx + NUM ) ; } if ( target . starts With ( STRING ) ) target = base Right Most + target ; return new URL ( base , target ) ; }
public Time Counter start ( ) { switch ( state ) { case UNSTARTED : start Time Millis = System . current Time Millis ( ) ; break ; case RUNNING : throw new Illegal State Exception ( STRING ) ; case STOPPED : start Time Millis += System . current Time Millis ( ) - stop Time Millis ; break ; default : throw new Illegal State Exception ( STRING + state ) ; } state = State . RUNNING ; return this ; }
public Commit Time Index ( final I Raw Store store , final Checkpoint checkpoint , final Index Metadata metadata , boolean read Only ) { super ( store , checkpoint , metadata , read Only ) ; }
private void on Open Editor ( String path , Editor Part Presenter editor ) { final List < Breakpoint > file Breakpoints = breakpoints . get ( path ) ; if ( file Breakpoints != null ) { final Breakpoint Renderer breakpoint Renderer = get Breakpoint Renderer For Editor ( editor ) ; if ( breakpoint Renderer != null ) { for ( final Breakpoint breakpoint : file Breakpoints ) { re Add Breakpoint Mark ( breakpoint Renderer , breakpoint ) ; } } } if ( current Breakpoint != null && path . equals ( current Breakpoint . get Path ( ) ) ) { Breakpoint Renderer breakpoint Renderer = get Breakpoint Renderer For File ( path ) ; if ( breakpoint Renderer != null ) { breakpoint Renderer . set Line Active ( current Breakpoint . get Line Number ( ) , BOOL ) ; } } }
private void read Header ( ) throws IO Exception { byte [ ] signature Bytes = new byte [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) signature Bytes [ i ] = plog Stream . read Byte ( ) ; String stringified Header = new String ( signature Bytes , STRING ) ; if ( ! stringified Header . equals ( STRING ) ) { throw new IO Exception ( STRING ) ; } int major file version = read Swapped Integer ( plog Stream ) ; int minor file version = read Swapped Integer ( plog Stream ) ; if ( major file version != NUM || minor file version != NUM ) { throw new IO Exception ( STRING + major file version + STRING + minor file version + STRING ) ; } logger . info ( STRING ) ; return ; }
private void parse Last Consonant ( ) { if ( ! valid Vi Syll ) return ; if ( i Cur Pos > str Syllable . length ( ) ) str Last Consonant = ZERO ; String str Con = str Syllable . substring ( i Cur Pos , str Syllable . length ( ) ) ; if ( str Con . length ( ) > NUM ) { valid Vi Syll = BOOL ; return ; } Iterator iter = al Last Consonants . iterator ( ) ; while ( iter . has Next ( ) ) { String temp Last Con = ( String ) iter . next ( ) ; if ( str Con . equals ( temp Last Con ) ) { str Last Consonant = temp Last Con ; i Cur Pos += str Last Consonant . length ( ) ; return ; } } str Last Consonant = ZERO ; if ( i Cur Pos >= str Syllable . length ( ) ) valid Vi Syll = BOOL ; else valid Vi Syll = BOOL ; return ; }
private J Panel create Left Side ( ) { J Panel left Panel = new J Panel ( ) ; list Model = new Custom List Model ( ) ; left Panel . set Layout ( new Border Layout ( ) ) ; list Box = new J List < String > ( list Model ) ; list Box . set Cell Renderer ( new Jlist Renderer ( ) ) ; list Box . set Selection Mode ( List Selection Model . SINGLE SELECTION ) ; list Box . add List Selection Listener ( new Custom List Selection Listener ( ) ) ; J Scroll Pane scroll Pane = new J Scroll Pane ( list Box ) ; scroll Pane . set Border ( Border Factory . create Empty Border ( ) ) ; left Panel . add ( scroll Pane , Border Layout . CENTER ) ; scroll Pane . set Border ( Border Factory . create Titled Border ( STRING ) ) ; J Panel control Panel = create Control Panel ( ) ; left Panel . add ( control Panel , Border Layout . SOUTH ) ; return left Panel ; }
private void remove Gaps ( int nodes Level [ ] ) { int temp = m nodes . size ( ) ; int temp 2 = graph Matrix [ NUM ] . length , temp Cnt = NUM ; for ( int n = NUM ; n < temp ; n ++ ) { for ( int i = NUM ; i < temp 2 ; i ++ ) { int len = graph Matrix . length ; if ( graph Matrix [ n ] [ i ] > NUM ) { if ( nodes Level [ i ] > nodes Level [ n ] + NUM ) { int temp Matrix [ ] [ ] = new int [ graph Matrix . length + ( nodes Level [ i ] - nodes Level [ n ] - NUM ) ] [ graph Matrix . length + ( nodes Level [ i ] - nodes Level [ n ] - NUM ) ] ; int level = nodes Level [ n ] + NUM ; copy Matrix ( graph Matrix , temp Matrix ) ; String s1 = new String ( STRING + temp Cnt ++ ) ; m nodes . add ( new Graph Node ( s1 , s1 , SINGULAR DUMMY ) ) ; int temp 3 [ ] = new int [ node Levels [ level ] . length + NUM ] ; System . arraycopy ( node Levels [ level ] , NUM , temp 3 , NUM , node Levels [ level ] . length ) ; temp 3 [ temp 3 . length - NUM ] = m nodes . size ( ) - NUM ; node Levels [ level ] = temp 3 ; level ++ ; int k ; for ( k = len ; k < len + nodes Level [ i ] - nodes Level [ n ] - NUM - NUM ; k ++ ) { String s2 = new String ( STRING + temp Cnt ) ; m nodes . add ( new Graph Node ( s2 , s2 , SINGULAR DUMMY ) ) ; temp 3 = new int [ node Levels [ level ] . length + NUM ] ; System . arraycopy ( node Levels [ level ] , NUM , temp 3 , NUM , node Levels [ level ] . length ) ; temp 3 [ temp 3 . length - NUM ] = m nodes . size ( ) - NUM ; node Levels [ level ++ ] = temp 3 ; temp Matrix [ k ] [ k + NUM ] = temp Matrix [ n ] [ i ] ; temp Cnt ++ ; if ( k > len ) { temp Matrix [ k ] [ k - NUM ] = - NUM * temp Matrix [ n ] [ i ] ; } } temp Matrix [ k ] [ i ] = temp Matrix [ n ] [ i ] ; temp Matrix [ n ] [ len ] = temp Matrix [ n ] [ i ] ; temp Matrix [ len ] [ n ] = - NUM * temp Matrix [ n ] [ i ] ; temp Matrix [ i ] [ k ] = - NUM * temp Matrix [ n ] [ i ] ; if ( k > len ) { temp Matrix [ k ] [ k - NUM ] = - NUM * temp Matrix [ n ] [ i ] ; } temp Matrix [ n ] [ i ] = NUM ; temp Matrix [ i ] [ n ] = NUM ; graph Matrix = temp Matrix ; } else { graph Matrix [ i ] [ n ] = - NUM * graph Matrix [ n ] [ i ] ; } } } } }
byte [ ] javac Compile ( String package Name , String class Name , String source ) { File dir = new File ( COMPILE DIR ) ; if ( package Name != null ) { dir = new File ( dir , package Name . replace ( STRING , STRING ) ) ; File Utils . create Directories ( dir . get Absolute Path ( ) ) ; } File java File = new File ( dir , class Name + STRING ) ; File class File = new File ( dir , class Name + STRING ) ; try { Output Stream f = File Utils . new Output Stream ( java File . get Absolute Path ( ) , BOOL ) ; Writer out = IO Utils . get Buffered Writer ( f ) ; class File . delete ( ) ; out . write ( source ) ; out . close ( ) ; if ( JAVAC SUN != null ) { javac Sun ( java File ) ; } else { javac Process ( java File ) ; } byte [ ] data = new byte [ ( int ) class File . length ( ) ] ; Data Input Stream in = new Data Input Stream ( new File Input Stream ( class File ) ) ; in . read Fully ( data ) ; in . close ( ) ; return data ; } catch ( Exception e ) { throw Db Exception . convert ( e ) ; } finally { java File . delete ( ) ; class File . delete ( ) ; } }
public synchronized void register ( Platform platform ) { check Not Null ( platform ) ; logger . log ( Level . FINE , STRING + platform . get Class ( ) + STRING + super . to String ( ) + STRING ) ; platforms . add ( platform ) ; if ( first Seen Version != null ) { if ( ! first Seen Version . equals ( platform . get Version ( ) ) ) { logger . log ( Level . WARNING , STRING + STRING , new Object [ ] { first Seen Version , platform . get Version ( ) } ) ; } } else { first Seen Version = platform . get Version ( ) ; } }
public Action Request Helper depends On ( Action Request Helper dependency , boolean terminate On Failure ) { dependency . terminate On Failure ( terminate On Failure ) ; m Dependencies . add ( dependency ) ; return this ; }
static boolean is Big Integer ( Object obj ) { return obj instanceof Big Integer && obj . get Class ( ) == Big Integer . class ; }
public static void to Xml ( final Config to Convert , final Output Stream stream , Boolean pretty Xml ) throws JAXB Exception { Marshaller var Marshaller = get Marshaller ( pretty Xml ) ; var Marshaller . marshal ( to Convert , stream ) ; }
protected Vector 2 D [ ] create Triangle Vertices ( float triangle Size ) { Vector 2 D [ ] p = new Vector 2 D [ NUM ] ; double f ; f = NUM * Math . PI / NUM ; p [ NUM ] = new Vector 2 D ( triangle Size * Math . sin ( f ) , triangle Size * Math . cos ( f ) ) ; f = NUM * Math . PI / NUM ; p [ NUM ] = new Vector 2 D ( triangle Size * Math . sin ( f ) , triangle Size * Math . cos ( f ) ) ; f = NUM * Math . PI / NUM ; p [ NUM ] = new Vector 2 D ( triangle Size * Math . sin ( f ) , triangle Size * Math . cos ( f ) ) ; return p ; }
private void heapify Up ( int twopos , Comparable < Object > cur ) { while ( twopos > NUM ) { final int parent = ( twopos - NUM ) > > > NUM ; Comparable < Object > par = twoheap [ parent ] ; if ( cur . compare To ( par ) >= NUM ) { break ; } twoheap [ twopos ] = par ; twopos = parent ; } twoheap [ twopos ] = cur ; }
public void insert ( String key , char val ) { int len = key . length ( ) + NUM ; if ( freenode + len > eq . length ) { redim Node Arrays ( eq . length + BLOCK SIZE ) ; } char [ ] strkey = new char [ len -- ] ; key . get Chars ( NUM , len , strkey , NUM ) ; strkey [ len ] = NUM ; root = insert ( root , strkey , NUM , val ) ; }
void write ( Environment env , Data Output Stream out , Constant Pool tab ) throws IO Exception { out . write Byte ( CONSTANT CLASS ) ; out . write Short ( tab . index ( name ) ) ; }
public void initialize Properties ( Properties properties ) { Properties new Props = new Properties ( ) ; new Props . put All ( system Config Props ) ; new Props . put All ( properties ) ; system Config Props = new Props ; }
public void fire Synapses Updated ( ) { for ( Network Listener listener : network Listeners ) { listener . update Synapses ( ) ; } }
public static void append Content Prefix ( Http Servlet Request request , String Builder url Buffer ) { try { append Content Prefix ( request , ( Appendable ) url Buffer ) ; } catch ( IO Exception e ) { throw Util Misc . init Cause ( new Internal Error ( e . get Message ( ) ) , e ) ; } }
public void remove Error Listener ( final Error Listener error Listener ) { if ( error Listeners != null ) { error Listeners . remove ( error Listener ) ; } }
public static IXML Parser create Default XML Parser ( ) throws Class Not Found Exception , Instantiation Exception , Illegal Access Exception { String class Name = XML Parser Factory . DEFAULT CLASS ; try { class Name = System . get Property ( XML Parser Factory . CLASS KEY , XML Parser Factory . DEFAULT CLASS ) ; } catch ( Access Control Exception e ) { } return XML Parser Factory . create XML Parser ( class Name , new Std XML Builder ( ) ) ; }
public static void import Expression Types ( final C Connection connection , final int raw Module Id , final int module Id ) throws SQL Exception { final String query = STRING + C Table Names . EXPRESSION TYPES TABLE + STRING + module Id + STRING + STRING + String . format ( C Table Names . RAW EXPRESSION TYPES TABLE , raw Module Id ) ; connection . execute Update ( query , BOOL ) ; }
public Object read Cost Matrix Old ( Element node ) throws Exception { weka . classifiers . Cost Matrix matrix ; weka . core . matrix . Matrix matrix New ; String Writer writer ; if ( DEBUG ) { trace ( new Throwable ( ) , node . get Attribute ( ATT NAME ) ) ; } m Current Node = node ; matrix New = ( weka . core . matrix . Matrix ) read Matrix ( node ) ; writer = new String Writer ( ) ; matrix New . write ( writer ) ; matrix = new weka . classifiers . Cost Matrix ( new String Reader ( writer . to String ( ) ) ) ; return matrix ; }
public void record Volume Operation ( Db Client db Client , Operation Type Enum op Type , Operation . Status status , Object ... ext Param ) { try { boolean op Status = ( Operation . Status . ready == status ) ? BOOL : BOOL ; String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ; String ev Desc = op Type . get Description ( ) ; String op Stage = Audit Log Manager . AUDITOP END ; logger . info ( STRING , op Type . to String ( ) , ev Type . to String ( ) + STRING + ev Desc ) ; URI uri = ( URI ) ext Param [ NUM ] ; record Bourne Volume Event ( db Client , ev Type , status , ev Desc , uri ) ; String id = uri . to String ( ) ; Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; } catch ( Exception e ) { logger . error ( STRING , op Type . to String ( ) , e ) ; } }
public Core Token Exception ( int error Code , Throwable cause ) { super ( cause ) ; this . error Code = error Code ; this . message = get Localized Message ( Locale . get Default ( ) ) ; }
public D View Certificate ( Window parent , String title , X509 Certificate [ ] certs , Kse Frame kse Frame , int import Export ) throws Crypto Exception { super ( parent , title , Dialog . Modality Type . DOCUMENT MODAL ) ; this . kse Frame = kse Frame ; this . import Export = import Export ; init Components ( certs ) ; }
public void test Compute Classpath For Library ( ) throws Core Exception , Unsupported Encoding Exception { final I Path project Relative Jar Path = new Path ( STRING ) ; final String folder Name = STRING ; add And Create Jar Library Entry ( java Project A , project Relative Jar Path ) ; add And Create Folder Library Entry ( java Project A , folder Name ) ; List < File > actual Cp = get List Of Files ( GWT Compile Runner . compute Classpath ( java Project A ) ) ; List < File > expected Cp = new Array List < File > ( ) ; expected Cp . add ( get File ( java Project A . get Project ( ) , project Relative Jar Path . to OS String ( ) ) ) ; expected Cp . add ( get File ( java Project A . get Project ( ) , folder Name ) ) ; assert Equals ( expected Cp , actual Cp ) ; }
private static String normalize Helper ( String number , Map < Character , Character > normalization Replacements , boolean remove Non Matches ) { String Builder normalized Number = new String Builder ( number . length ( ) ) ; for ( int i = NUM ; i < number . length ( ) ; i ++ ) { char character = number . char At ( i ) ; Character new Digit = normalization Replacements . get ( Character . to Upper Case ( character ) ) ; if ( new Digit != null ) { normalized Number . append ( new Digit ) ; } else if ( ! remove Non Matches ) { normalized Number . append ( character ) ; } } return normalized Number . to String ( ) ; }
private int [ ] do Union ( int [ ] c2 ) { int [ ] result = new int [ chars . length + c2 . length ] ; int i = NUM ; int j = NUM ; int index = NUM ; while ( i < chars . length && j < c2 . length ) { int ub ; if ( chars [ i ] < c2 [ j ] ) { result [ index ++ ] = chars [ i ] ; ub = chars [ ++ i ] ; } else { result [ index ++ ] = c2 [ j ] ; ub = c2 [ ++ j ] ; } while ( i % NUM == NUM || j % NUM == NUM || ( i < chars . length && chars [ i ] <= ub + NUM ) ) { while ( i < chars . length && chars [ i ] <= ub + NUM ) { ++ i ; } if ( i % NUM == NUM ) { ub = chars [ i ] ; } else if ( i > NUM && chars [ i - NUM ] > ub ) { ub = chars [ i - NUM ] ; } while ( j < c2 . length && c2 [ j ] <= ub + NUM ) { ++ j ; } if ( j % NUM == NUM ) { ub = c2 [ j ] ; } else if ( j > NUM && c2 [ j - NUM ] > ub ) { ub = c2 [ j - NUM ] ; } } result [ index ++ ] = ub ; } if ( i < chars . length ) { for ( int k = i ; k < chars . length ; k ++ ) { result [ index ++ ] = chars [ k ] ; } } if ( j < c2 . length ) { for ( int k = j ; k < c2 . length ; k ++ ) { result [ index ++ ] = c2 [ k ] ; } } if ( result . length > index ) { int [ ] tmpbuf = new int [ index ] ; System . arraycopy ( result , NUM , tmpbuf , NUM , index ) ; return tmpbuf ; } return result ; }
public void remove Sub Config ( String sub Config Name ) throws SMS Exception , SSO Exception { validate Service Config Impl ( ) ; sub Config Name = SMS Schema . unescape Name ( sub Config Name ) ; String sdn = STRING + sub Config Name + STRING + sc . get DN ( ) ; Service Config Manager Impl scm Impl = Service Config Manager Impl . get Instance ( token , get Service Name ( ) , get Version ( ) ) ; Service Config Impl s Config Impl = sc . get Sub Config ( token , sub Config Name ) ; if ( s Config Impl != null ) { Service Config Impl . delete Instance ( token , scm Impl , null , sdn , STRING , s Config Impl . get Group Name ( ) , ( get Component Name ( ) + STRING + SMS Schema . escape Special Characters ( sub Config Name ) ) , BOOL , ss ) ; } Cached SMS Entry c Entry = Cached SMS Entry . get Instance ( token , sdn ) ; if ( c Entry . is Dirty ( ) ) { c Entry . refresh ( ) ; } SMS Entry entry = c Entry . get Cloned SMS Entry ( ) ; entry . delete ( token ) ; c Entry . refresh ( entry ) ; Cached Sub Entries cse = Cached Sub Entries . get Instance ( token , sc . get DN ( ) ) ; cse . remove ( sub Config Name ) ; }
public void add Group Listener ( final Group Listener listener ) { group Listeners . add ( listener ) ; }
public void write Task Container Mapping ( String task Name , Integer container Id ) { Integer existing Container Id = task Name To Container Id . get ( task Name ) ; if ( existing Container Id != null && ! existing Container Id . equals ( container Id ) ) { log . info ( STRING , new Object [ ] { task Name , existing Container Id , container Id } ) ; } else { log . debug ( STRING , task Name , container Id ) ; } if ( container Id == null ) { send ( new Delete ( get Source ( ) , task Name , Set Task Container Mapping . TYPE ) ) ; task Name To Container Id . remove ( task Name ) ; } else { send ( new Set Task Container Mapping ( get Source ( ) , task Name , String . value Of ( container Id ) ) ) ; task Name To Container Id . put ( task Name , container Id ) ; } }
public Tungsten Properties subset ( String prefix , boolean remove Prefix , boolean remove Props ) { Tungsten Properties tp = new Tungsten Properties ( ) ; Set < String > prefix Keys = key Names ( prefix ) ; int name Index = NUM ; if ( remove Prefix ) name Index = prefix . length ( ) ; for ( String key : prefix Keys ) { String new Key = key . substring ( name Index ) ; if ( new Key . length ( ) > NUM ) tp . set Object ( new Key , get Object ( key ) ) ; if ( remove Props ) remove ( key ) ; } return tp ; }
@ Suppress Warnings ( STRING ) public static < E > void transform String Collection ( Collection < String > original , Collection < E > collection , Class < E > element Class ) throws Preference Exception { Method parse Method = find Parse Method ( element Class ) ; if ( null != parse Method ) { for ( String to Transform : original ) { try { Object transformed = parse Method . invoke ( null , to Transform ) ; if ( element Class . is Assignable From ( transformed . get Class ( ) ) ) { collection . add ( ( E ) transformed ) ; } } catch ( Exception e ) { throw new Preference Exception ( STRING + element Class . get Name ( ) + STRING , e ) ; } } } else { throw new Preference Exception ( STRING + element Class . get Name ( ) + STRING + element Class . get Name ( ) + STRING ) ; } }
static void remove Size Hints ( X Decorated Peer window , long mask ) { mask &= X Util Constants . P Max Size | X Util Constants . P Min Size ; X Toolkit . awt Lock ( ) ; try { X Size Hints hints = window . get Hints ( ) ; if ( ( hints . get flags ( ) & mask ) == NUM ) { return ; } hints . set flags ( hints . get flags ( ) & ~ mask ) ; if ( ins Log . is Loggable ( Platform Logger . Level . FINER ) ) { ins Log . finer ( STRING + Xlib Wrapper . hints To String ( hints . get flags ( ) ) ) ; } Xlib Wrapper . X Set WM Normal Hints ( X Toolkit . get Display ( ) , window . get Window ( ) , hints . p Data ) ; } finally { X Toolkit . awt Unlock ( ) ; } }
public Component Manager ( ) { gral Components = new Sequence Collection ( ) ; gral Seeds = Collections . unmodifiable Set ( Collections . < Sequence > empty Set ( ) ) ; }
public static boolean requires Unsynchronization ( byte [ ] aby Source ) { for ( int i = NUM ; i < aby Source . length - NUM ; i ++ ) { if ( ( ( aby Source [ i ] & MPEG Frame Header . SYNC BYTE 1 ) == MPEG Frame Header . SYNC BYTE 1 ) && ( ( aby Source [ i + NUM ] & MPEG Frame Header . SYNC BYTE 2 ) == MPEG Frame Header . SYNC BYTE 2 ) ) { if ( logger . is Loggable ( Level . FINEST ) ) { logger . finest ( STRING + i ) ; } return BOOL ; } } return BOOL ; }
final static String HMAC MD 5 ( byte [ ] key , byte [ ] text ) throws No Such Algorithm Exception { Message Digest md 5 = Message Digest . get Instance ( STRING ) ; if ( key . length > MD 5 BLOCKSIZE ) { key = md 5 . digest ( key ) ; } byte [ ] ipad = new byte [ MD 5 BLOCKSIZE ] ; byte [ ] opad = new byte [ MD 5 BLOCKSIZE ] ; byte [ ] digest ; int i ; for ( i = NUM ; i < key . length ; i ++ ) { ipad [ i ] = key [ i ] ; opad [ i ] = key [ i ] ; } for ( i = NUM ; i < MD 5 BLOCKSIZE ; i ++ ) { ipad [ i ] ^= NUM ; opad [ i ] ^= NUM ; } md 5 . update ( ipad ) ; md 5 . update ( text ) ; digest = md 5 . digest ( ) ; md 5 . update ( opad ) ; md 5 . update ( digest ) ; digest = md 5 . digest ( ) ; String Buffer digest String = new String Buffer ( ) ; for ( i = NUM ; i < digest . length ; i ++ ) { if ( ( digest [ i ] & NUM ) < NUM ) { digest String . append ( STRING + Integer . to Hex String ( digest [ i ] & NUM ) ) ; } else { digest String . append ( Integer . to Hex String ( digest [ i ] & NUM ) ) ; } } Arrays . fill ( ipad , ( byte ) NUM ) ; Arrays . fill ( opad , ( byte ) NUM ) ; ipad = null ; opad = null ; return ( digest String . to String ( ) ) ; }
void capture ( final Context context , final Request request , final Capture Point mode ) { String Writer out = new String Writer ( ) ; Print Writer writer = new Print Writer ( out ) ; String id = context . get Id ( ) ; switch ( mode ) { case REQUEST : capture Request ( writer , request , id ) ; break ; case FILTERED REQUEST : capture Filtered Request ( writer , request , id ) ; break ; default : throw new Illegal Argument Exception ( STRING + mode . name ( ) ) ; } if ( capture Context ) { writer . println ( STRING ) ; capture Context As Json ( writer , context ) ; } logger . info ( out . to String ( ) ) ; }
public static final byte [ ] inflate ( byte [ ] in ) throws IO Exception { Byte Array Output Stream out Stream = new Byte Array Output Stream ( EXPECTED COMPRESSION RATIO * in . length ) ; Inflater Input Stream in Stream = new Inflater Input Stream ( new Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [ BUF SIZE ] ; while ( BOOL ) { int size = in Stream . read ( buf ) ; if ( size <= NUM ) break ; out Stream . write ( buf , NUM , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
public static < T > void add First Item ( J Combo Box < T > combobox , T item ) { int idx = - NUM ; Default Combo Box Model < T > model = ( Default Combo Box Model < T > ) combobox . get Model ( ) ; for ( int i = NUM ; i < model . get Size ( ) ; i ++ ) { T t = model . get Element At ( i ) ; if ( Objects . equals ( t , item ) ) { idx = i ; break ; } } model . insert Element At ( item , NUM ) ; if ( idx >= NUM ) { model . remove Element At ( idx + NUM ) ; } }
@ Not Null public static Hg Version parse Version And Extension Info ( @ Nullable String output , @ Not Null List < String > error Lines ) throws Parse Exception { if ( String Util . is Empty Or Spaces ( output ) ) { throw new Parse Exception ( STRING + output , NUM ) ; } Matcher matcher = HG VERSION PATTERN . matcher ( output ) ; if ( matcher . matches ( ) ) { return new Hg Version ( get Int Group ( matcher , NUM ) , get Int Group ( matcher , NUM ) , get Int Group ( matcher , NUM ) , parse Unsupported Extensions ( error Lines ) ) ; } LOGGER . error ( STRING + output ) ; throw new Parse Exception ( STRING + output , NUM ) ; }
public void test huffman Recoder Stress ( ) throws IO Exception { final int ntrials = NUM ; final int percent Zero = NUM ; final Random r = new Random ( ) ; for ( int trial = NUM ; trial < ntrials ; trial ++ ) { final int [ ] frequency = new int [ NUM ] ; for ( int i = NUM ; i < frequency . length ; i ++ ) { if ( r . next Int ( ) < percent Zero ) { frequency [ i ] = NUM ; } else { frequency [ i ] = r . next Int ( NUM ) ; } } do Recoder Round Trip Test ( frequency ) ; } }
public Set < Entry < T , double [ ] > > entry Set ( ) { return Collections . unmodifiable Set ( map . entry Set ( ) ) ; }
public R params To Json Entity ( String elapsed Field In Json Streamer ) { try { m Http Entity = create Json Streamer Entity ( elapsed Field In Json Streamer ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return ( R ) this ; }
@ Suppress Warnings ( STRING ) public Composite Transaction Adaptor ( Stack < Composite Transaction > lineage , String tid , boolean serial , Recovery Coordinator adaptor ) { super ( tid , ( Stack < Composite Transaction > ) lineage . clone ( ) , serial ) ; adaptor For Replay Requests = adaptor ; Stack < Composite Transaction > tmp = ( Stack < Composite Transaction > ) lineage . clone ( ) ; Composite Transaction parent = null ; while ( ! tmp . empty ( ) ) { parent = tmp . pop ( ) ; } root = parent . get Tid ( ) ; }
public void p2 ant ( Action < P2 Ant Runner > ant Modifier ) { this . ant Modifier = Objects . require Non Null ( ant Modifier ) ; }
public static String to Json ( final Object object , final boolean indent ) { final String Builder s = new String Builder ( ) ; encode ( s , object , indent , indent ? NUM : - NUM ) ; return s . to String ( ) ; }
private Calendar trim To Midnight ( Calendar calendar ) { calendar . set ( Calendar . HOUR OF DAY , NUM ) ; calendar . set ( Calendar . MINUTE , NUM ) ; calendar . set ( Calendar . SECOND , NUM ) ; calendar . set ( Calendar . MILLISECOND , NUM ) ; return calendar ; }
public static String cut Surrounding ( String string , String prefix , String suffix ) { int start = NUM ; int end = string . length ( ) ; if ( string . starts With ( prefix ) ) { start = prefix . length ( ) ; } if ( string . ends With ( suffix ) ) { end -= suffix . length ( ) ; } return string . substring ( start , end ) ; }
public static Coordinate [ ] create Sine Star ( double basex , double basey , double size , double arm Len , int n Arms , int n Pts ) { double arm Base Len = size / NUM - arm Len ; if ( arm Base Len < NUM ) arm Base Len = NUM ; double ang Inc = NUM * Math . PI / n Arms ; int n Arm Pt = n Pts / n Arms ; if ( n Arm Pt < NUM ) n Arm Pt = NUM ; int n Pts 2 = n Arm Pt * n Arms ; Coordinate [ ] pts = new Coordinate [ n Pts 2 + NUM ] ; int i Pt = NUM ; double star Ang = NUM ; for ( int i Arm = NUM ; i Arm < n Arms ; i Arm ++ ) { for ( int i Arm Pt = NUM ; i Arm Pt < n Arm Pt ; i Arm Pt ++ ) { double ang = i Arm Pt * ( NUM * Math . PI / n Arm Pt ) ; double len = arm Len * ( NUM - Math . cos ( ang ) / NUM ) + arm Base Len ; double x = len * Math . cos ( star Ang + i Arm Pt * ang Inc / n Arm Pt ) + basex ; double y = len * Math . sin ( star Ang + i Arm Pt * ang Inc / n Arm Pt ) + basey ; Coordinate pt = new Coordinate ( x , y ) ; pts [ i Pt ++ ] = pt ; } star Ang += ang Inc ; } pts [ i Pt ] = pts [ NUM ] ; return pts ; }
public static String [ ] split String ( final String str , final char split Char ) { final int length = str . length ( ) ; final String Builder bulder = new String Builder ( Math . max ( NUM , length ) ) ; int counter = NUM ; for ( int i = NUM ; i < length ; i ++ ) { if ( str . char At ( i ) == split Char ) { counter ++ ; } } final String [ ] result = new String [ counter ] ; int position = NUM ; for ( int i = NUM ; i < length ; i ++ ) { final char chr = str . char At ( i ) ; if ( chr == split Char ) { result [ position ++ ] = bulder . to String ( ) ; bulder . set Length ( NUM ) ; } else { bulder . append ( chr ) ; } } if ( position < result . length ) { result [ position ] = bulder . to String ( ) ; } return result ; }
private void step With Timeout ( Any Kind Of Step step , int isolate Id ) throws Player Debug Exception { int timeout = m session . get Preference ( Session Manager . PREF RESPONSE TIMEOUT ) ; long timeout Time = System . current Time Millis ( ) + timeout ; step . step ( ) ; Isolate Session worker Session = m session . get Worker Session ( isolate Id ) ; while ( System . current Time Millis ( ) < timeout Time && ! worker Session . is Suspended ( ) ) { process Events ( ) ; if ( ! m session . is Suspended ( ) ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { } } } if ( System . current Time Millis ( ) >= timeout Time && ! worker Session . is Suspended ( ) ) throw new No Response Exception ( timeout ) ; }
public int process Packet ( byte [ ] in , int in Off , int in Len , byte [ ] output , int out Off ) throws Illegal State Exception , Invalid Cipher Text Exception , Data Length Exception { if ( key Param == null ) { throw new Illegal State Exception ( STRING ) ; } int n = nonce . length ; int q = NUM - n ; if ( q < NUM ) { int limit Len = NUM << ( NUM * q ) ; if ( in Len >= limit Len ) { throw new Illegal State Exception ( STRING ) ; } } byte [ ] iv = new byte [ block Size ] ; iv [ NUM ] = ( byte ) ( ( q - NUM ) & NUM ) ; System . arraycopy ( nonce , NUM , iv , NUM , nonce . length ) ; Block Cipher ctr Cipher = new SIC Block Cipher ( cipher ) ; ctr Cipher . init ( for Encryption , new Parameters With IV ( key Param , iv ) ) ; int output Len ; int in Index = in Off ; int out Index = out Off ; if ( for Encryption ) { output Len = in Len + mac Size ; if ( output . length < ( output Len + out Off ) ) { throw new Output Length Exception ( STRING ) ; } calculate Mac ( in , in Off , in Len , mac Block ) ; ctr Cipher . process Block ( mac Block , NUM , mac Block , NUM ) ; while ( in Index < ( in Off + in Len - block Size ) ) { ctr Cipher . process Block ( in , in Index , output , out Index ) ; out Index += block Size ; in Index += block Size ; } byte [ ] block = new byte [ block Size ] ; System . arraycopy ( in , in Index , block , NUM , in Len + in Off - in Index ) ; ctr Cipher . process Block ( block , NUM , block , NUM ) ; System . arraycopy ( block , NUM , output , out Index , in Len + in Off - in Index ) ; System . arraycopy ( mac Block , NUM , output , out Off + in Len , mac Size ) ; } else { if ( in Len < mac Size ) { throw new Invalid Cipher Text Exception ( STRING ) ; } output Len = in Len - mac Size ; if ( output . length < ( output Len + out Off ) ) { throw new Output Length Exception ( STRING ) ; } System . arraycopy ( in , in Off + output Len , mac Block , NUM , mac Size ) ; ctr Cipher . process Block ( mac Block , NUM , mac Block , NUM ) ; for ( int i = mac Size ; i != mac Block . length ; i ++ ) { mac Block [ i ] = NUM ; } while ( in Index < ( in Off + output Len - block Size ) ) { ctr Cipher . process Block ( in , in Index , output , out Index ) ; out Index += block Size ; in Index += block Size ; } byte [ ] block = new byte [ block Size ] ; System . arraycopy ( in , in Index , block , NUM , output Len - ( in Index - in Off ) ) ; ctr Cipher . process Block ( block , NUM , block , NUM ) ; System . arraycopy ( block , NUM , output , out Index , output Len - ( in Index - in Off ) ) ; byte [ ] calculated Mac Block = new byte [ block Size ] ; calculate Mac ( output , out Off , output Len , calculated Mac Block ) ; if ( ! Arrays . constant Time Are Equal ( mac Block , calculated Mac Block ) ) { throw new Invalid Cipher Text Exception ( STRING ) ; } } return output Len ; }
private void log Entry ( Log Entry entry ) { String Builder log Message = new String Builder ( STRING ) ; log Message . append ( entry . get Bundle ( ) ) ; if ( entry . get Service Reference ( ) != null ) { log Message . append ( STRING ) ; log Message . append ( entry . get Service Reference ( ) ) ; } log Message . append ( STRING ) ; log Message . append ( entry . get Message ( ) ) ; Throwable ex = entry . get Exception ( ) ; switch ( entry . get Level ( ) ) { case Log Service . LOG ERROR : { default Entry Logger . error ( log Message . to String ( ) , ex ) ; break ; } case Log Service . LOG WARNING : { default Entry Logger . warn ( log Message . to String ( ) , ex ) ; break ; } case Log Service . LOG INFO : { default Entry Logger . info ( log Message . to String ( ) , ex ) ; break ; } case Log Service . LOG DEBUG : { default Entry Logger . debug ( log Message . to String ( ) , ex ) ; break ; } default : { default Entry Logger . warn ( STRING + entry . get Level ( ) + STRING + log Message . to String ( ) , ex ) ; } } }
public static byte [ ] hash ( byte [ ] input ) { if ( input != null ) { final Message Digest digest ; try { digest = Message Digest . get Instance ( STRING ) ; byte [ ] hashed Bytes = input ; digest . update ( hashed Bytes , NUM , hashed Bytes . length ) ; return hashed Bytes ; } catch ( No Such Algorithm Exception e ) { Log . e ( TAG , STRING + input + STRING + e . get Message ( ) , e ) ; } } else { Log . w ( TAG , STRING ) ; } return null ; }
public static String generate Native Guid ( Protection System device , String unique Id , String type ) { String type Str = STRING ; if ( OBJECT TYPE SET . contains ( type ) ) { type Str = type ; } return String . format ( STRING , device Type Map . get ( device . get System Type ( ) ) , device . get Installation Id ( ) , type Str , unique Id ) ; }
public void test Get Servlet Names For Jsp File With Single Servlet ( ) throws Exception { String xml = WEBAPP TEST HEADER + STRING + STRING + STRING + STRING + STRING ; Web Xml web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( xml . get Bytes ( STRING ) ) , get Entity Resolver ( ) ) ; List < String > servlet Names = Web Xml Utils . get Servlet Names For Jsp File ( web Xml , STRING ) ; assert Equals ( NUM , servlet Names . size ( ) ) ; assert Equals ( STRING , servlet Names . get ( NUM ) ) ; }
@ Override public boolean equals ( Object object ) { if ( this == object ) { return BOOL ; } if ( ( null == object ) || ( get Class ( ) != object . get Class ( ) ) ) { return BOOL ; } final Team other = ( Team ) object ; return ( id == other . id ) && Objects . equals ( players , other . players ) ; }
@ Override public void debug ( String msg , Throwable t ) { if ( logger . is Loggable ( Level . FINE ) ) { log ( SELF , Level . FINE , msg , t ) ; } }
public void remove Event Listener ( SIP Dialog Event Listener old Listener ) { event Listeners . remove ( old Listener ) ; }
@ Override public OS Process Handler create Process Handler ( String working Directory , Map < String , String > env Variables ) throws Execution Exception { startup Process Handler . destroy Process ( ) ; Process Builder dummy Process = new Process Builder ( STRING ) ; try { return new OS Process Handler ( dummy Process . start ( ) , Gct Bundle . get String ( STRING ) ) ; } catch ( IO Exception ioe ) { throw new Execution Exception ( ioe ) ; } }
@ Not Null public static SQF Command Expression create Private Decl From Existing ( @ Not Null Project project , @ Not Null SQF Private Decl decl , @ Not Null String ... var Names ) { List < SQF Private Decl Var > decl Vars = decl . get Private Vars ( ) ; String text = STRING ; for ( SQF Private Decl Var decl Var : decl Vars ) { text += STRING + decl Var . get Var Name ( ) + STRING ; } for ( int i = NUM ; i < var Names . length ; i ++ ) { text += STRING + var Names [ i ] + ( i != var Names . length - NUM ? STRING : STRING ) ; } return ( SQF Command Expression ) create Element ( project , text , SQF Types . COMMAND EXPRESSION ) ; }
@ Action ( value = STRING ) public String report ( ) { final Report Request report Input = new Report Request ( CASH COLLECTION TEMPLATE , crit Params , Report Data Source Type . SQL ) ; final Report Output report Output = report Service . create Report ( report Input ) ; report Id = report Viewer Util . add Report To Temp Cache ( report Output ) ; return REPORT ; }
public static boolean starts With ( char s [ ] , int len , String prefix ) { final int prefix Len = prefix . length ( ) ; if ( prefix Len > len ) return BOOL ; for ( int i = NUM ; i < prefix Len ; i ++ ) if ( s [ i ] != prefix . char At ( i ) ) return BOOL ; return BOOL ; }
@ Suppress Warnings ( STRING ) public static String unqualified Class Name ( Class type ) { if ( type . is Array ( ) ) { return unqualified Class Name ( type . get Component Type ( ) ) + STRING ; } String name = type . get Name ( ) ; return name . substring ( name . last Index Of ( STRING ) + NUM ) ; }
public boolean fire Map Mouse Pressed ( Mouse Event evt ) { if ( DEBUG ) { logger . fine ( STRING ) ; } boolean consumed = BOOL ; if ( DEBUG ) { logger . fine ( STRING + ( proxy != null ) + STRING + evt . is Shift Down ( ) + STRING ) ; } if ( proxy == null || evt . is Shift Down ( ) || ( proxy Distribution Mask & PROXY DISTRIB MOUSE PRESSED ) > NUM ) { evt = new Map Mouse Event ( get Parent Mode ( ) , evt ) ; if ( DEBUG && proxy != null && evt . is Shift Down ( ) ) { logger . fine ( STRING ) ; } Iterator < Map Mouse Listener > it = iterator ( ) ; while ( it . has Next ( ) && ! consumed ) { Map Mouse Listener target = it . next ( ) ; consumed = target . mouse Pressed ( evt ) && consume Events ; if ( consumed ) { priority Listener = target ; } } } boolean ignore Consumed = ! consumed || ( consumed && ( ( proxy Distribution Mask & PROXY ACK CONSUMED MOUSE PRESSED ) == NUM ) ) ; if ( proxy != null && ignore Consumed && ! evt . is Shift Down ( ) ) { proxy . mouse Pressed ( evt ) ; consumed = BOOL ; } else { if ( DEBUG && evt . is Shift Down ( ) ) { logger . fine ( STRING ) ; } } return consumed ; }
private static String descriptor From Proto Array ( String [ ] protos , String return Type ) { String Builder builder = new String Builder ( ) ; builder . append ( STRING ) ; for ( int i = NUM ; i < protos . length ; i ++ ) { builder . append ( protos [ i ] ) ; } builder . append ( STRING ) ; builder . append ( return Type ) ; return builder . to String ( ) ; }
@ Override void to XML ( String Builder xml , int level ) { indent ( xml , level ) ; xml . append ( STRING ) ; for ( int i = NUM ; i < bytes . length ; i ++ ) { byte b = bytes [ i ] ; if ( b < NUM ) xml . append ( STRING ) ; xml . append ( Integer . to Hex String ( b ) ) ; } xml . append ( STRING ) ; }
protected void paint Content Border Right Edge ( Graphics g , int x , int y , int w , int h , boolean draw Broken , Rectangle sel Rect , boolean is Content Border Painted ) { if ( is Content Border Painted ) { g . set Color ( dark Shadow ) ; g . fill Rect ( x + w - NUM , y , NUM , h ) ; } }
private void write Final Results ( String output Dir , double total TT , double [ ] total Route T Ts , double [ ] avg Route T Ts , int [ ] route Users , int number Of Stucked Agents ) { Print Stream stream ; String filename = output Dir + STRING ; try { stream = new Print Stream ( new File ( filename ) ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; return ; } log . info ( STRING + total TT ) ; String header = STRING ; String Buffer result Line = new String Buffer ( ) ; result Line . append ( total TT ) ; String latex Format = STRING + ( int ) total TT ; log . info ( STRING ) ; for ( int route Nr = NUM ; route Nr < number Of Routes ; route Nr ++ ) { log . info ( STRING + route Nr + STRING + route Users [ route Nr ] ) ; header += STRING + route Nr ; result Line . append ( STRING + route Users [ route Nr ] ) ; latex Format += STRING + route Users [ route Nr ] ; } log . info ( STRING ) ; for ( int route Nr = NUM ; route Nr < number Of Routes ; route Nr ++ ) { log . info ( STRING + route Nr + STRING + avg Route T Ts [ route Nr ] ) ; header += STRING + route Nr ; result Line . append ( STRING + avg Route T Ts [ route Nr ] ) ; latex Format += STRING + ( Double . is Na N ( avg Route T Ts [ route Nr ] ) ? STRING : ( int ) avg Route T Ts [ route Nr ] ) ; } log . info ( STRING + number Of Stucked Agents ) ; header += STRING ; result Line . append ( STRING + number Of Stucked Agents ) ; latex Format += STRING ; log . info ( STRING + latex Format ) ; stream . println ( header ) ; stream . println ( result Line . to String ( ) ) ; stream . close ( ) ; log . info ( STRING + filename ) ; }
public int execute ( String sql ) throws SQL Exception { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql ) ; return statement . execute Update ( sql ) ; }
@ Layoutlib Delegate static long current Thread Time Micro ( ) { return System . current Time Millis ( ) * NUM ; }
public static List < Entry > make Entries ( List < String > ldif Lines ) { return make Entries ( ldif Lines . to Array ( new String [ ldif Lines . size ( ) ] ) ) ; }
public int format ( long val , byte [ ] buf , int off , int len ) { if ( val == Long . MIN VALUE ) { if ( len > MAX LONG LENGTH ) { return format ( STRING , buf , off , len ) ; } else { truncation Filler ( buf , off , len ) ; return off + len ; } } long pos = Math . abs ( val ) ; int ndig = NUM ; long dmax = Byte Formatter . NUMBER BASE ; while ( ndig < MAX LONG LENGTH && pos >= dmax ) { ndig ++ ; dmax *= Byte Formatter . NUMBER BASE ; } if ( val < NUM ) { ndig ++ ; } if ( ndig > len || ndig > buf . length - off ) { truncation Filler ( buf , off , len ) ; return off + len ; } off += ndig ; int xoff = off - NUM ; buf [ xoff ] = ( byte ) STRING ; boolean last = pos == NUM ; while ( ! last ) { int giga = ( int ) ( pos % LONG TO INT MODULO ) ; pos /= LONG TO INT MODULO ; last = pos == NUM ; for ( int i = NUM ; i < MAXIMUM SINGLE DIGIT INTEGER ; i ++ ) { buf [ xoff ] = Byte Formatter . DIGITS [ giga % Byte Formatter . NUMBER BASE ] ; xoff -- ; giga /= Byte Formatter . NUMBER BASE ; if ( last && giga == NUM ) { break ; } } } if ( val < NUM ) { buf [ xoff ] = ( byte ) STRING ; } return off ; }
private void append Affix ( String Buffer buffer , String affix Pattern , String exp Affix , boolean localized ) { if ( affix Pattern == null ) { append Affix ( buffer , exp Affix , localized ) ; } else { int i ; for ( int pos = NUM ; pos < affix Pattern . length ( ) ; pos = i ) { i = affix Pattern . index Of ( QUOTE , pos ) ; if ( i < NUM ) { append Affix ( buffer , affix Pattern . substring ( pos ) , localized ) ; break ; } if ( i > pos ) { append Affix ( buffer , affix Pattern . substring ( pos , i ) , localized ) ; } char c = affix Pattern . char At ( ++ i ) ; ++ i ; if ( c == QUOTE ) { buffer . append ( c ) ; } else if ( c == CURRENCY SIGN && i < affix Pattern . length ( ) && affix Pattern . char At ( i ) == CURRENCY SIGN ) { ++ i ; buffer . append ( c ) ; } else if ( localized ) { switch ( c ) { case PATTERN PERCENT : c = symbols . get Percent ( ) ; break ; case PATTERN PER MILLE : c = symbols . get Per Mill ( ) ; break ; case PATTERN MINUS : c = symbols . get Minus Sign ( ) ; break ; } } buffer . append ( c ) ; } } }
private boolean check Class Implements Compliance ( ) { Class < ? > [ ] interfaces = m Class . get Interfaces ( ) ; Set < String > inter Face Set = new Hash Set < > ( ) ; for ( Class < ? > c : interfaces ) { inter Face Set . add ( c . get Canonical Name ( ) ) ; } for ( String inter : impl Interfaces ) { if ( ! inter Face Set . contains ( inter ) ) { return BOOL ; } } return BOOL ; }
private void compute Handler Live Set ( ) { if ( ir . get Handler Liveness Computed ( ) && current Block . has Exception Handlers ( ) ) { Enumeration < Basic Block > e = current Block . get Exceptional Out ( ) ; while ( e . has More Elements ( ) ) { Exception Handler Basic Block handler Block = ( Exception Handler Basic Block ) e . next Element ( ) ; handler Live Set . add ( handler Block . get Live Set ( ) ) ; } } }
public int checksum ts ( ) { return calculate Checksum ( compile checksum . to String ( ) + compile checksum ts . to String ( ) ) ; }
public void append Local Variable Label ( I Local Variable local Variable , long flags ) { if ( get Flag ( flags , F PRE TYPE SIGNATURE ) ) { append Type Signature Label ( local Variable , local Variable . get Type Signature ( ) , flags ) ; f Buffer . append ( STRING ) ; } if ( get Flag ( flags , F FULLY QUALIFIED ) ) { append Element Label ( local Variable . get Declaring Member ( ) , M PARAMETER TYPES | M FULLY QUALIFIED | T FULLY QUALIFIED | ( flags & QUALIFIER FLAGS ) ) ; f Buffer . append ( STRING ) ; } f Buffer . append ( get Element Name ( local Variable ) ) ; if ( get Flag ( flags , F APP TYPE SIGNATURE ) ) { int offset = f Buffer . length ( ) ; f Buffer . append ( DECL STRING ) ; append Type Signature Label ( local Variable , local Variable . get Type Signature ( ) , flags ) ; } if ( get Flag ( flags , F POST QUALIFIED ) ) { f Buffer . append ( CONCAT STRING ) ; append Element Label ( local Variable . get Declaring Member ( ) , M PARAMETER TYPES | M FULLY QUALIFIED | T FULLY QUALIFIED | ( flags & QUALIFIER FLAGS ) ) ; } }
static public Item Stack chisel Block ( final I Continuous Inventory selected , final Acting Player player , final Voxel Blob vb , final World world , final Block Pos pos , final Enum Facing side , final int x , final int y , final int z , Item Stack output , final List < Entity Item > spawnlist ) { final boolean is Creative = player . is Creative ( ) ; final int blk = vb . get ( x , y , z ) ; if ( blk == NUM ) { return output ; } if ( ! can Mine ( selected , Block . get State By Id ( blk ) , player . get Player ( ) , world , pos ) ) { return output ; } selected . use Item ( blk ) ; final boolean spawn Bit = Chisels And Bits . get Items ( ) . item Block Bit != null ; if ( ! world . is Remote && ! is Creative ) { double hit X = x * one 16 th ; double hit Y = y * one 16 th ; double hit Z = z * one 16 th ; final double offset = NUM ; hit X += side . get Front Offset X ( ) * offset ; hit Y += side . get Front Offset Y ( ) * offset ; hit Z += side . get Front Offset Z ( ) * offset ; if ( output == null || ! Item Chiseled Bit . same Bit ( output , blk ) || output . stack Size == NUM ) { output = Item Chiseled Bit . create Stack ( blk , NUM , BOOL ) ; if ( spawn Bit ) { spawnlist . add ( new Entity Item ( world , pos . get X ( ) + hit X , pos . get Y ( ) + hit Y , pos . get Z ( ) + hit Z , output ) ) ; } } else { output . stack Size ++ ; } } else { output = Item Chiseled Bit . create Stack ( blk , NUM , BOOL ) ; } vb . clear ( x , y , z ) ; return output ; }
public Socket create Socket ( Inet Address address , int port , Inet Address my Address , int my Port ) throws IO Exception { if ( my Address != null ) { Socket sock = new Socket ( ) ; sock . bind ( new Inet Socket Address ( my Address , NUM ) ) ; try { sock . connect ( new Inet Socket Address ( address , port ) , NUM ) ; } catch ( Socket Timeout Exception e ) { throw new Connect Exception ( STRING + address + STRING + port ) ; } return sock ; } else { Socket sock = new Socket ( ) ; if ( my Port != NUM ) { sock . bind ( new Inet Socket Address ( port ) ) ; } try { sock . connect ( new Inet Socket Address ( address , port ) , NUM ) ; } catch ( Socket Timeout Exception e ) { throw new Connect Exception ( STRING + address + STRING + port ) ; } return sock ; } }
public static boolean install Normal ( Context context , String file Path ) { Intent i = new Intent ( Intent . ACTION VIEW ) ; File file = new File ( file Path ) ; if ( file == null || ! file . exists ( ) || ! file . is File ( ) || file . length ( ) <= NUM ) { return BOOL ; } i . set Data And Type ( Uri . parse ( STRING + file Path ) , STRING ) ; i . add Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; context . start Activity ( i ) ; return BOOL ; }
private List < I Item > create Insert List ( List < I Item > item Drag List ) { List < I Item > temp List = new Array List < I Item > ( ) ; List < I Item > insert List = new Array List < I Item > ( ) ; int depth = NUM ; int removed = NUM ; for ( I Item item : item Drag List ) { create Insert List ( item , temp List , insert List , depth , removed ) ; } this . number Of Controls = temp List . size ( ) - removed ; return insert List ; }
public final Pdf Object read Reference Table ( final Pdf Object linear Obj , final Pdf File Reader current Pdf File , final Object Reader object Reader ) throws Pdf Exception { int pointer = - NUM ; final int eof = ( int ) this . eof ; boolean islinearized Compressed = BOOL ; if ( linear Obj == null ) { pointer = read First Start Ref ( ) ; } else { final byte [ ] data = pdf datafile . get Pdf Buffer ( ) ; final int count = data . length ; int ptr = NUM ; for ( int i = NUM ; i < count ; i ++ ) { if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { ptr = i + NUM ; } if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { pointer = i ; i = count ; } else if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { islinearized Compressed = BOOL ; pointer = ptr ; while ( data [ pointer ] == NUM || data [ pointer ] == NUM || data [ pointer ] == NUM ) { pointer ++ ; } i = count ; } } } offset . add Xref ( pointer ) ; Pdf Object root Obj = null ; if ( pointer >= eof || pointer == NUM ) { Log Writer . write Log ( STRING ) ; offset . set Ref Table Invalid ( BOOL ) ; try { root Obj = new Page Object ( Broken Ref Table . find Offsets ( pdf datafile , offset ) ) ; } catch ( Error err ) { throw new Pdf Exception ( err . get Message ( ) + STRING ) ; } current Pdf File . read Object ( root Obj ) ; return root Obj ; } else if ( islinearized Compressed || is Compressed Stream ( pointer , eof ) ) { return read Compressed Stream ( root Obj , pointer , current Pdf File , object Reader , linear Obj ) ; } else { return read Legacy Reference Table ( root Obj , pointer , eof , current Pdf File ) ; } }
protected int number Of Attributes ( int total , double fraction ) { int k = ( int ) Math . round ( ( fraction < NUM ) ? total * fraction : fraction ) ; if ( k > total ) k = total ; if ( k < NUM ) k = NUM ; return k ; }
public One Must Be Set Global Constraint ( Parameter < ? > ... params ) { parameters = Arrays . as List ( params ) ; }
public Rhythm Overlay inflate Overlay ( String config String , @ Non Null Map < String , String > vars ) { List < String > config Strings = Arrays . as List ( config String . split ( STRING ) ) ; return inflate Overlay Internal ( config Strings , vars , NUM ) ; }
private void handle File ( File file , Uri Deployment Scanner Context ctx ) { boolean changed ; Long last Mod ; if ( file . is Directory ( ) ) { Grid Tuple < Long > dir Last Modified = F . t ( file . last Modified ( ) ) ; changed = check Gar Directory Changed ( file , dir Last Modified ) ; last Mod = dir Last Modified . get ( ) ; } else { last Mod = tstamp Cache . get ( file ) ; changed = last Mod == null || last Mod != file . last Modified ( ) ; last Mod = file . last Modified ( ) ; } if ( changed ) { tstamp Cache . put ( file , last Mod ) ; if ( ctx . get Logger ( ) . is Debug Enabled ( ) ) ctx . get Logger ( ) . debug ( STRING + file ) ; String file Name = file . get Name ( ) ; try { File cp File = ctx . create Temp File ( file Name , ctx . get Deploy Directory ( ) ) ; cp File . delete On Exit ( ) ; if ( file . is Directory ( ) ) { cp File = new File ( cp File . get Parent ( ) , STRING + cp File . get Name ( ) ) ; cp File . delete On Exit ( ) ; } U . copy ( file , cp File , BOOL ) ; String file Uri = get File Uri ( file . get Absolute Path ( ) ) ; assert last Mod != null ; ctx . get Listener ( ) . on New Or Updated File ( cp File , file Uri , last Mod ) ; } catch ( IO Exception e ) { U . error ( ctx . get Logger ( ) , STRING + file Name , e ) ; } } }
public void flip ( W Component Peer peer , Component target , Volatile Image back Buffer , int x1 , int y1 , int x2 , int y2 , Buffer Capabilities . Flip Contents flip Action ) { if ( flip Action == Buffer Capabilities . Flip Contents . COPIED || flip Action == Buffer Capabilities . Flip Contents . UNDEFINED ) { Graphics g = peer . get Graphics ( ) ; try { g . draw Image ( back Buffer , x1 , y1 , x2 , y2 , x1 , y1 , x2 , y2 , null ) ; } finally { g . dispose ( ) ; } } else if ( flip Action == Buffer Capabilities . Flip Contents . BACKGROUND ) { Graphics g = back Buffer . get Graphics ( ) ; try { g . set Color ( target . get Background ( ) ) ; g . fill Rect ( NUM , NUM , back Buffer . get Width ( ) , back Buffer . get Height ( ) ) ; } finally { g . dispose ( ) ; } } }
protected void load Value ( String s Value ) { try { value = Integer . parse Int ( s Value . trim ( ) ) ; } catch ( Number Format Exception nfe ) { revert To Default ( ) ; } }
public static List < SOAP Element > input Needed ( SOAP Element ele ) { List < SOAP Element > l = new Array List < SOAP Element > ( ) ; log . trace ( STRING + ele . get Node Name ( ) ) ; input Needed ( ele , l ) ; log . trace ( STRING + l ) ; return l ; }
private void draw Line Progress ( Canvas canvas ) { float unit Degrees = ( float ) ( NUM * Math . PI / m Line Count ) ; float outer Circle Radius = m Radius ; float inter Circle Radius = m Radius - m Line Width ; int progress Line Count = ( int ) ( ( float ) get Progress ( ) / ( float ) get Max ( ) * m Line Count ) ; for ( int i = NUM ; i < m Line Count ; i ++ ) { float rotate Degrees = i * unit Degrees ; float start X = m Center X + ( float ) Math . sin ( rotate Degrees ) * inter Circle Radius ; float start Y = m Center X - ( float ) Math . cos ( rotate Degrees ) * inter Circle Radius ; float stop X = m Center X + ( float ) Math . sin ( rotate Degrees ) * outer Circle Radius ; float stop Y = m Center X - ( float ) Math . cos ( rotate Degrees ) * outer Circle Radius ; if ( i < progress Line Count ) { canvas . draw Line ( start X , start Y , stop X , stop Y , m Progress Paint ) ; } else { canvas . draw Line ( start X , start Y , stop X , stop Y , m Progress Background Paint ) ; } } }
protected void stop Output Test ( ) { if ( test Running && out Test ) { out Timer . stop ( ) ; status Text 1 . set Text ( STRING + Integer . to String ( num Iterations ) + STRING ) ; status Text 1 . set Visible ( BOOL ) ; status Text 2 . set Text ( STRING ) ; status Text 2 . set Visible ( BOOL ) ; } }
@ HLE Function ( nid = NUM , version = NUM ) public int sce Net Adhoc Game Mode Create Master ( T Pointer data , int size ) { check Initialized ( ) ; master Game Mode Area = new Game Mode Area ( data . get Address ( ) , size ) ; start Game Mode ( ) ; return NUM ; }
public static void clear Cache ( ) { cached Networks . clear ( ) ; }
public static void copy File ( File source File , File dest File ) throws IO Exception { if ( ! source File . exists ( ) ) { throw new IO Exception ( STRING + source File . get Absolute Path ( ) ) ; } copy File ( new File Input Stream ( source File ) , new File Output Stream ( dest File ) ) ; }
@ Suppress Lint ( STRING ) void rebuild ( ) { if ( m Journal Writer != null ) { close Quietly ( m Journal Writer ) ; } Writer writer = null ; try { Array List < Entry > entries = m Cache . get Entry Collection ( ) ; m Line Count = entries . size ( ) ; writer = new Buffered Writer ( new Output Stream Writer ( new File Output Stream ( m Journal File Tmp ) , US ASCII ) ) ; for ( Entry entry : entries ) { if ( entry . is Readable ( ) ) { writer . write ( CLEAN ENTRY PREFIX + STRING + entry . get Key ( ) + STRING + String . value Of ( entry . get Length In Bytes ( ) ) + STRING ) ; } else { writer . write ( DIRTY ENTRY PREFIX + STRING + entry . get Key ( ) + STRING ) ; } } writer . flush ( ) ; if ( m Journal File . exists ( ) ) { m Journal File . rename To ( m Journal File Backup ) ; } m Journal File Tmp . rename To ( m Journal File ) ; create Journal Writer ( ) ; m Journal File Backup . delete ( ) ; } catch ( IO Exception ignored ) { } finally { close Quietly ( writer ) ; } }
public static File save File ( String log Data ) { File dir = get Log Dir ( ) ; if ( dir == null ) { return null ; } File Writer file Writer = null ; File output = null ; try { output = new File ( dir , get Log File Name ( ) ) ; file Writer = new File Writer ( output , BOOL ) ; file Writer . write ( log Data ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { if ( file Writer != null ) { try { file Writer . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } return output ; }
private static List < Command > load Rewrites ( Content Resolver content Resolver , Uri uri ) throws IO Exception { Input Stream input Stream = content Resolver . open Input Stream ( uri ) ; List < Command > commands = new Array List < > ( ) ; if ( input Stream != null ) { Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( input Stream ) ) ; String line ; while ( ( line = reader . read Line ( ) ) != null ) { add Line ( commands , line ) ; } input Stream . close ( ) ; } return commands ; }
@ Override public State Connection service ( ) throws IO Exception { try { Connection Protocol request = request Or Create ( ) ; if ( request == null ) { log . warning ( STRING + this ) ; return State Connection . CLOSE ; } State Connection next = request . service ( ) ; if ( next != State Connection . CLOSE ) { return next ; } else { return on Close Read ( ) ; } } catch ( Out Of Memory Error e ) { String msg = STRING ; Shutdown System . shutdown Out Of Memory ( msg ) ; log . log ( Level . WARNING , e . to String ( ) , e ) ; } catch ( Throwable e ) { e . print Stack Trace ( ) ; log . log ( Level . WARNING , e . to String ( ) , e ) ; } return State Connection . CLOSE ; }
private Map < UUID , Collection < Hadoop Input Split > > mappers ( Collection < Cluster Node > top , Collection < UUID > top Ids , Iterable < Hadoop Input Split > splits ) throws Ignite Checked Exception { Map < UUID , Collection < Hadoop Input Split > > mappers = new Hash Map < > ( ) ; Map < String , Collection < UUID > > nodes = group By Host ( top ) ; Map < UUID , Integer > node Loads = new Hash Map < > ( top . size ( ) , NUM ) ; for ( UUID node Id : top Ids ) node Loads . put ( node Id , NUM ) ; for ( Hadoop Input Split split : splits ) { UUID node Id = node For Split ( split , top Ids , nodes , node Loads ) ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + split + STRING + node Id + STRING ) ; Collection < Hadoop Input Split > node Splits = mappers . get ( node Id ) ; if ( node Splits == null ) { node Splits = new Array List < > ( ) ; mappers . put ( node Id , node Splits ) ; } node Splits . add ( split ) ; node Loads . put ( node Id , node Loads . get ( node Id ) + NUM ) ; } return mappers ; }
public void handle Request ( String request , Output Stream out ) throws IO Exception , Map Request Format Exception { Properties request Properties = convert Request To Props ( request ) ; String request Type = request Properties . get Property ( REQUEST ) ; if ( request Type != null ) { if ( request Type . equals Ignore Case ( MAP ) ) { Debug . message ( STRING , STRING ) ; handle Map Request ( request Properties , out ) ; } else if ( request Type . equals Ignore Case ( CAPABILITIES ) ) { Debug . message ( STRING , STRING ) ; handle Capabilities Request ( request Properties , out ) ; } else if ( request Type . equals Ignore Case ( PAN ) ) { Debug . message ( STRING , STRING ) ; handle Pan Request ( request Properties , out ) ; } else if ( request Type . equals Ignore Case ( RECENTER ) ) { Debug . message ( STRING , STRING ) ; handle Recenter Request ( request Properties , out ) ; } else { throw new Map Request Format Exception ( STRING + request Type ) ; } } else { throw new Map Request Format Exception ( STRING + request ) ; } }
public String format ( float val ) { Decimal Format df = get Float Format ( ) ; if ( df != null ) { return df . format ( val ) ; } return Float . to String ( val ) ; }
public void add Identity Position ( int position , Set < Identity > participants ) { for ( Identity participant : participants ) { Set < Integer > positions = identity Positions . get ( participant . get Id ( ) ) ; if ( positions == null ) { positions = new Hash Set < > ( ) ; identity Positions . put ( participant . get Id ( ) , positions ) ; } positions . add ( position ) ; } }
public static Rectangle 2 D calc Aligned String Bounds ( String text , Graphics 2 D g2 , float x , float y , Text Anchor anchor ) { Rectangle 2 D text Bounds = new Rectangle 2 D . Double ( ) ; float [ ] adjust = derive Text Bounds Anchor Offsets ( g2 , text , anchor , text Bounds ) ; text Bounds . set Rect ( x + adjust [ NUM ] , y + adjust [ NUM ] + adjust [ NUM ] , text Bounds . get Width ( ) , text Bounds . get Height ( ) ) ; return text Bounds ; }
public boolean reinit ( ) { Map < String , Integer > new Entry Colour Map = build Entry Colour Map ( ) ; if ( new Entry Colour Map == null || new Entry Colour Map . size ( ) < NUM ) { return BOOL ; } Map < String , Entry Hierarchy Data > new Entry Hierarchy Data Map ; try { new Entry Hierarchy Data Map = entry Hierarchy Data Resource Reader . read ( entry Hierarchy Data Resource ) ; } catch ( IO Exception e ) { LOGGER . warn ( STRING + e . get Message ( ) ) ; return BOOL ; } if ( new Entry Hierarchy Data Map == null || new Entry Hierarchy Data Map . size ( ) < NUM ) { return BOOL ; } entry Colour Map = new Entry Colour Map ; entry Hierarchy Data Map = new Entry Hierarchy Data Map ; return BOOL ; }
private static boolean add Book Line ( String line , List < Byte > bin Book ) throws Chess Parse Error { Position pos = Text IO . read FEN ( Text IO . start Pos FEN ) ; Undo Info ui = new Undo Info ( ) ; String [ ] str Moves = line . split ( STRING ) ; for ( String str Move : str Moves ) { int bad = NUM ; if ( str Move . ends With ( STRING ) ) { str Move = str Move . substring ( NUM , str Move . length ( ) - NUM ) ; bad = NUM ; } Move m = Text IO . string To Move ( pos , str Move ) ; if ( m == null ) { return BOOL ; } int prom = piece To Prom ( m . promote To ) ; int val = m . from + ( m . to << NUM ) + ( prom << NUM ) + ( bad << NUM ) ; bin Book . add ( ( byte ) ( val > > NUM ) ) ; bin Book . add ( ( byte ) ( val & NUM ) ) ; pos . make Move ( m , ui ) ; } bin Book . add ( ( byte ) NUM ) ; bin Book . add ( ( byte ) NUM ) ; return BOOL ; }
public static boolean contains Modifiable Variable Modification ( Protocol Message object ) { for ( Modifiable Variable Holder holder : object . get All Modifiable Variable Holders ( ) ) { for ( Field f : holder . get All Modifiable Variable Fields ( ) ) { if ( contains Modifiable Variable Modification ( holder , f ) ) { return BOOL ; } } } return BOOL ; }
public boolean save As Geo JSON ( File file ) { try { File Writer fw = new File Writer ( file ) ; Buffered Writer writer = new Buffered Writer ( fw , NUM ) ; boolean result = save As Geo JSON ( writer ) ; writer . close ( ) ; return result ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } }
public static List < String > read File To List ( String file Path ) { File file = new File ( file Path ) ; List < String > file Content = new Array List < String > ( ) ; if ( file == null || ! file . is File ( ) ) { return null ; } Buffered Reader reader = null ; try { reader = new Buffered Reader ( new File Reader ( file ) ) ; String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { file Content . add ( line ) ; } reader . close ( ) ; return file Content ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING , e ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING , e ) ; } } } }
public double do Operation ( ) throws Operator Failed Exception { double logq ; final double alpha = ( arctan Transform ? Math . atan ( bias ) * SCALE ALPHA : Math . log ( bias ) ) ; final Node Ref root = tree . get Root ( ) ; double max Height = tree . get Node Height ( root ) ; Node Ref i ; Node Ref iP = null ; Node Ref Ci P = null ; Node Ref Pi P = null ; double height = Double . Na N ; List < Node Ref > destinations = null ; do { i = tree . get Node ( Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } while ( root == i || tree . get Parent ( i ) == root ) ; iP = tree . get Parent ( i ) ; Ci P = get Other Child ( tree , iP , i ) ; Pi P = tree . get Parent ( iP ) ; height = tree . get Node Height ( iP ) ; destinations = get Intersecting Edges ( tree , height ) ; if ( destinations . size ( ) == NUM ) { throw new Operator Failed Exception ( STRING ) ; } double [ ] pdf = get Destination Probabilities ( tree , i , height , max Height , destinations , alpha ) ; destinations . remove ( i ) ; destinations . remove ( Ci P ) ; int r = Math Utils . random Choice PDF ( pdf ) ; double forward Probability = pdf [ r ] ; final Node Ref j = destinations . get ( r ) ; final Node Ref jP = tree . get Parent ( j ) ; tree . begin Tree Edit ( ) ; tree . remove Child ( iP , Ci P ) ; tree . remove Child ( Pi P , iP ) ; tree . add Child ( Pi P , Ci P ) ; tree . remove Child ( jP , j ) ; tree . add Child ( iP , j ) ; tree . add Child ( jP , iP ) ; tree . end Tree Edit ( ) ; final List < Node Ref > reverse Destinations = get Intersecting Edges ( tree , height ) ; double reverse Probability = get Reverse Probability ( tree , Ci P , j , height , max Height , reverse Destinations , alpha ) ; logq = Math . log ( reverse Probability ) - Math . log ( forward Probability ) ; return logq ; }
private void close Internal ( ) { final Bigdata Sail Repository Connection cxn = tl Tx . get ( ) ; if ( cxn != null ) { close ( cxn ) ; } }
Buffered Image create Image ( final int w , final int h , final byte [ ] rgb ) { final Buffered Image image ; byte [ ] image Data = data To RGB Byte Array ( rgb , w , h ) ; image = new Buffered Image ( w , h , Buffered Image . TYPE INT RGB ) ; final Raster raster = Color Space Convertor . create Interleaved Raster ( image Data , w , h ) ; image . set Data ( raster ) ; return image ; }
void remove ( Visible Object object ) { if ( objects . remove ( object . get Object Id ( ) ) != null ) { if ( object instanceof Player ) { check Activeness ( player Count . decrement And Get ( ) > NUM ) ; } } }
@ Suppress Warnings ( STRING ) public static void create Project Guideline ( Zip File zip , Project a Project , Repository Service a Repository ) throws IO Exception { for ( Enumeration zip Enumerate = zip . entries ( ) ; zip Enumerate . has More Elements ( ) ; ) { Zip Entry entry = ( Zip Entry ) zip Enumerate . next Element ( ) ; String entry Name = normalize Entry Name ( entry ) ; if ( entry Name . starts With ( GUIDELINE ) ) { String filename = Filename Utils . get Name ( entry . get Name ( ) ) ; File guideline Dir = a Repository . get Guidelines File ( a Project ) ; File Utils . force Mkdir ( guideline Dir ) ; File Utils . copy Input Stream To File ( zip . get Input Stream ( entry ) , new File ( guideline Dir , filename ) ) ; LOG . info ( STRING + filename + STRING + a Project . get Name ( ) + STRING + a Project . get Id ( ) + STRING ) ; } } }
public Block Transform Extent ( Extent extent , Transform transform , Block Registry block Registry ) { super ( extent ) ; check Not Null ( transform ) ; check Not Null ( block Registry ) ; this . transform = transform ; this . block Registry = block Registry ; BLOCK TRANSFORM = new Base Block [ Fawe Cache . CACHE BLOCK . length ] ; BLOCK TRANSFORM INVERSE = new Base Block [ Fawe Cache . CACHE BLOCK . length ] ; Transform inverse = transform . inverse ( ) ; for ( int i = NUM ; i < BLOCK TRANSFORM . length ; i ++ ) { Base Block block = Fawe Cache . CACHE BLOCK [ i ] ; if ( block != null ) { BLOCK TRANSFORM [ i ] = transform ( new Base Block ( block ) , transform , block Registry ) ; BLOCK TRANSFORM INVERSE [ i ] = transform ( new Base Block ( block ) , inverse , block Registry ) ; } } }
private void write Non Proxy Desc ( Object Stream Class desc , boolean unshared ) throws IO Exception { bout . write Byte ( TC CLASSDESC ) ; handles . assign ( unshared ? null : desc ) ; if ( protocol == PROTOCOL VERSION 1 ) { desc . write Non Proxy ( this ) ; } else { write Class Descriptor ( desc ) ; } Class < ? > cl = desc . for Class ( ) ; bout . set Block Data Mode ( BOOL ) ; if ( cl != null && is Custom Subclass ( ) ) { Reflect Util . check Package Access ( cl ) ; } annotate Class ( cl ) ; bout . set Block Data Mode ( BOOL ) ; bout . write Byte ( TC ENDBLOCKDATA ) ; write Class Desc ( desc . get Super Desc ( ) , BOOL ) ; }
public void restore From Stream ( final Byte Array Input Stream bis ) throws IO Exception , Class Not Found Exception { final Object Input os = new Object Input Stream ( bis ) ; final int size = ( Integer ) os . read Object ( ) ; max size = size ; items = new Object [ size ] ; Object next Object ; Integer type ; for ( int i = NUM ; i < size ; i ++ ) { type = ( Integer ) os . read Object ( ) ; if ( type . compare To ( BASICSTROKE ) == NUM ) { final float w = os . read Float ( ) ; final int current line cap style = os . read Int ( ) ; final int current line join style = os . read Int ( ) ; final float mitre limit = os . read Float ( ) ; final float [ ] current line dash array = ( float [ ] ) os . read Object ( ) ; final float current line dash phase = os . read Float ( ) ; next Object = new Basic Stroke ( w , current line cap style , current line join style , mitre limit , current line dash array , current line dash phase ) ; } else if ( type . compare To ( RECT ) == NUM ) { final float x = os . read Float ( ) ; final float y = os . read Float ( ) ; final float w = os . read Float ( ) ; final float h = os . read Float ( ) ; next Object = new Rectangle 2 D . Float ( x , y , w , h ) ; } else if ( type . compare To ( BUFFERED IMAGE ) == NUM ) { final byte [ ] bytes = ( byte [ ] ) os . read Object ( ) ; next Object = Default Image Helper . read ( bytes ) ; } else if ( type . compare To ( GENERAL PATH ) == NUM ) { next Object = Path Serializer . deserialize Path ( os ) ; } else if ( type . compare To ( T1 GLYPH ) == NUM ) { final T1 Glyph glyph = ( T1 Glyph ) os . read Object ( ) ; final int count = ( Integer ) os . read Object ( ) ; final General Path [ ] paths = new General Path [ count ] ; for ( int j = NUM ; j < count ; j ++ ) { paths [ j ] = Path Serializer . deserialize Path ( os ) ; } final Vector Path vp = new Vector Path ( ) ; vp . set ( paths ) ; vp . set Current item ( paths . length ) ; glyph . set Paths ( vp ) ; next Object = glyph ; } else if ( type . compare To ( TTGLYPH ) == NUM ) { final TT Glyph glyph = ( TT Glyph ) os . read Object ( ) ; final int count = ( Integer ) os . read Object ( ) ; final General Path [ ] paths = new General Path [ count ] ; for ( int j = NUM ; j < count ; j ++ ) { paths [ j ] = Path Serializer . deserialize Path ( os ) ; } final Vector Path vp = new Vector Path ( ) ; vp . set ( paths ) ; vp . set Current item ( paths . length ) ; glyph . set Paths ( vp ) ; next Object = glyph ; } else if ( type . compare To ( T3 GLYPH ) == NUM ) { next Object = new T3 Glyph ( os ) ; } else if ( type . compare To ( TEXTUREDPAINT ) == NUM ) { final byte [ ] bytes = ( byte [ ] ) os . read Object ( ) ; final Buffered Image img = Default Image Helper . read ( bytes ) ; final float x = os . read Float ( ) ; final float y = os . read Float ( ) ; final float w = os . read Float ( ) ; final float h = os . read Float ( ) ; final Rectangle 2 D anchor = new Rectangle 2 D . Float ( x , y , w , h ) ; next Object = new Pdf Texture Paint ( img , anchor ) ; } else if ( type . compare To ( AREA ) == NUM ) { final General Path path = Path Serializer . deserialize Path ( os ) ; next Object = new Area ( path ) ; } else { next Object = os . read Object ( ) ; } items [ i ] = next Object ; } }
private void reset Coordinator Data ( Coordinator Client coordinator , Cassandra Token Manager token Manager 1 , Cassandra Token Manager token Manager 2 , Base 64 Token Encoder encoder 1 , Base 64 Token Encoder encoder 2 , Token Key Generator token Key Generator 1 , Token Key Generator token Key Generator 2 ) throws Exception { final long ROTATION INTERVAL MSECS = NUM ; Db Client db Client = get Db Client ( ) ; coordinator = new Test Coordinator ( ) ; token Manager 1 = new Cassandra Token Manager ( ) ; encoder 1 = new Base 64 Token Encoder ( ) ; token Key Generator 1 = new Token Key Generator ( ) ; Token Max Life Values Holder holder 1 = new Token Max Life Values Holder ( ) ; holder 1 . set Key Rotation Interval In M Secs ( ROTATION INTERVAL MSECS ) ; token Manager 1 . set Token Max Life Values Holder ( holder 1 ) ; token Manager 1 . set Db Client ( db Client ) ; token Manager 1 . set Coordinator ( coordinator ) ; encoder 1 . set Coordinator ( coordinator ) ; token Key Generator 1 . set Token Max Life Values Holder ( holder 1 ) ; encoder 1 . set Token Key Generator ( token Key Generator 1 ) ; encoder 1 . manager Init ( ) ; token Manager 1 . set Token Encoder ( encoder 1 ) ; token Manager 2 = new Cassandra Token Manager ( ) ; encoder 2 = new Base 64 Token Encoder ( ) ; token Key Generator 2 = new Token Key Generator ( ) ; Token Max Life Values Holder holder 2 = new Token Max Life Values Holder ( ) ; holder 2 . set Key Rotation Interval In M Secs ( ROTATION INTERVAL MSECS ) ; token Manager 2 . set Token Max Life Values Holder ( holder 2 ) ; token Manager 2 . set Db Client ( db Client ) ; token Manager 2 . set Coordinator ( coordinator ) ; encoder 2 . set Coordinator ( coordinator ) ; token Key Generator 2 . set Token Max Life Values Holder ( holder 2 ) ; encoder 2 . set Token Key Generator ( token Key Generator 2 ) ; encoder 2 . manager Init ( ) ; token Manager 2 . set Token Encoder ( encoder 2 ) ; Storage OS User DAO user DAO = new Storage OS User DAO ( ) ; user DAO . set User Name ( STRING ) ; final String token 1 = token Manager 1 . get Token ( user DAO ) ; Assert . assert Not Null ( token 1 ) ; Token On Wire tw 1 = encoder 1 . decode ( token 1 ) ; String key 1 = tw 1 . get Encryption Key Id ( ) ; final String token 2 = token Manager 2 . get Token ( user DAO ) ; Assert . assert Not Null ( token 2 ) ; Token On Wire tw 2 = encoder 2 . decode ( token 2 ) ; String key 2 = tw 2 . get Encryption Key Id ( ) ; Assert . assert Equals ( key 1 , key 2 ) ; }
Builder add Query Parameter ( String name , String value ) { if ( name == null ) throw new Illegal Argument Exception ( STRING ) ; if ( encoded Query Names And Values == null ) encoded Query Names And Values = new Array List < > ( ) ; encoded Query Names And Values . add ( canonicalize ( name , QUERY COMPONENT ENCODE SET , BOOL , BOOL ) ) ; encoded Query Names And Values . add ( value != null ? canonicalize ( value , QUERY COMPONENT ENCODE SET , BOOL , BOOL ) : null ) ; return this ; }
private static img create Control Button Image ( String name , String js command , boolean enabled ) { String Buffer img Name = new String Buffer ( STRING + name ) ; if ( ! enabled ) img Name . append ( STRING ) ; img Name . append ( STRING ) ; img img = new img ( Web Env . get Image Directory ( img Name . to String ( ) ) , name ) ; if ( enabled ) img . set Alt ( Msg . get Msg ( AD Language , name ) ) ; img . set ID ( STRING ) ; if ( js command != null && js command . length ( ) > NUM && enabled ) { img . set On Click ( STRING + FORM NAME + STRING + M Command + STRING + name + STRING + js command ) ; } return img ; }
public static List < Principal User Dto > transform To Dto ( List < Principal User > users ) { if ( users == null ) { throw new Web Application Exception ( STRING , Status . INTERNAL SERVER ERROR ) ; } List < Principal User Dto > result = new Array List < > ( ) ; for ( Principal User user : users ) { result . add ( transform To Dto ( user ) ) ; } return result ; }
public final long decrement And Get ( ) { return unsafe . get And Add Long ( this , value Offset , - NUM ) - NUM ; }
public void pan And Zoom ( int min X , int min Y , int max X , int max Y ) { float curr Zoom = map Controller . get Zoom ( ) ; Lng Lat tl = Util . normalize Lng Lat ( map Controller . coordinates At Screen Position ( NUM , NUM ) ) ; Lng Lat br = Util . normalize Lng Lat ( map Controller . coordinates At Screen Position ( window Width , window Height ) ) ; int from Min X = Area Panel . convert Lon To X ( tl . longitude ) ; int from Min Y = Area Panel . convert Lat To Y ( tl . latitude ) ; int from Max X = Area Panel . convert Lon To X ( br . longitude ) ; int from Max Y = Area Panel . convert Lat To Y ( br . latitude ) ; max Y = ( int ) ( ( ( float ) max Y - min Y ) * window Height / point Area Height ) + min Y ; float zoom Multiplier = Math . min ( ( ( float ) from Max X - from Min X ) / ( max X - min X ) , ( ( float ) from Max Y - from Min Y ) / ( max Y - min Y ) ) ; float new Zoom = ( float ) ( curr Zoom + Math . log ( zoom Multiplier ) / Math . log ( NUM ) ) ; Lng Lat new Pos = new Lng Lat ( Area Panel . convert X To Lon ( ( max X - min X ) / NUM + min X ) , Area Panel . convert Y To Lat ( ( max Y - min Y ) / NUM + min Y ) ) ; map Controller . set Position Eased ( new Pos , AUTOZOOM PAN EASE MS ) ; map Controller . set Zoom Eased ( new Zoom , AUTOZOOM ZOOM EASE MS ) ; notify Screen Moved ( ) ; }
public final void add ( V value ) { if ( GWT . is Script ( ) ) { js Array . add ( value ) ; } else { java Array . add ( value ) ; } }
@ Override public synchronized void clear ( ) { File [ ] files = m Root Directory . list Files ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } m Entries . clear ( ) ; m Total Size = NUM ; Volley Log . d ( STRING ) ; }
public String product Publication Date ( ) { return properties . get Property ( STRING ) ; }
private void use Our U Is ( ) { for ( String ui Name : UI LIST ) { ui Name = ui Name + STRING ; ui Defaults . put ( ui Name , UI PACKAGE PREFIX + ui Name ) ; } }
public void make Immutable ( ) { super . make Immutable ( ) ; }
public KNN Distance Order Result run ( Database database , Relation < O > relation ) { final Distance Query < O > distance Query = database . get Distance Query ( relation , get Distance Function ( ) ) ; final KNN Query < O > knn Query = database . get KNN Query ( distance Query , k + NUM ) ; final int size = ( int ) ( ( sample <= NUM ) ? Math . ceil ( relation . size ( ) * sample ) : sample ) ; DBI Ds sample = DBID Util . random Sample ( relation . get DBI Ds ( ) , size , rnd ) ; Finite Progress prog = LOG . is Verbose ( ) ? new Finite Progress ( STRING , size , LOG ) : null ; double [ ] knn Distances = new double [ size ] ; int i = NUM ; for ( DBID Iter iditer = sample . iter ( ) ; iditer . valid ( ) ; iditer . advance ( ) , i ++ ) { final KNN List neighbors = knn Query . get KNN For DBID ( iditer , k + NUM ) ; knn Distances [ i ] = neighbors . get KNN Distance ( ) ; LOG . increment Processed ( prog ) ; } LOG . ensure Completed ( prog ) ; return new KNN Distance Order Result ( knn Distances , k ) ; }
public static Sparse Int Array adjust Position ( Sparse Int Array positions , int start Position , int end Position , int adjust By ) { Sparse Int Array new Positions = new Sparse Int Array ( ) ; for ( int i = NUM , size = positions . size ( ) ; i < size ; i ++ ) { int position = positions . key At ( i ) ; if ( position < start Position || position > end Position ) { new Positions . put ( position , positions . value At ( i ) ) ; } else if ( adjust By > NUM ) { new Positions . put ( position + adjust By , positions . value At ( i ) ) ; } else if ( adjust By < NUM ) { if ( position > start Position + adjust By && position <= start Position ) { ; } else { new Positions . put ( position + adjust By , positions . value At ( i ) ) ; } } } return new Positions ; }
private Resolved Migration create Available Migration ( String version ) { Resolved Migration migration = new Resolved Migration ( ) ; migration . set Version ( Migration Version . from Version ( version ) ) ; migration . set Description ( STRING ) ; migration . set Script ( STRING ) ; migration . set Type ( Migration Type . CQL ) ; return migration ; }
public boolean draw Image ( Image img , int x , int y , Color bg , Image Observer observer ) { if ( img == null ) { return BOOL ; } if ( is Hi DPI Image ( img ) ) { final int img W = img . get Width ( null ) ; final int img H = img . get Height ( null ) ; return draw Hi DPI Image ( img , x , y , x + img W , y + img H , NUM , NUM , img W , img H , bg , observer ) ; } try { return imagepipe . copy Image ( this , img , x , y , bg , observer ) ; } catch ( Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . copy Image ( this , img , x , y , bg , observer ) ; } catch ( Invalid Pipe Exception e2 ) { return BOOL ; } } finally { surface Data . mark Dirty ( ) ; } }
public void begin Display ( Display Event event ) throws Model Control Exception { super . begin Display ( event ) ; Server Site Model model = ( Server Site Model ) get Model ( ) ; String server Name = ( String ) get Page Session Attribute ( PG ATTR SERVER NAME ) ; Object [ ] param = { server Name } ; pt Model . set Page Title Text ( Message Format . format ( model . get Localized String ( STRING ) , param ) ) ; set Display Field Value ( STRING , Message Format . format ( model . get Localized String ( STRING ) , param ) ) ; }
private void purge Array ( char [ ] array ) { Arrays . fill ( array , STRING ) ; }
public REST Endpoint Builder parameter ( String name , String value ) { if ( name . starts With ( STRING ) || name . starts With ( STRING ) ) { name = name . substring ( NUM ) ; } parameters . put ( name , value ) ; return this ; }
@ Override public void clear ( ) { for ( int i = NUM ; i < array . length ( ) ; i ++ ) { array . set ( i , default Get Key Return Value ) ; } size . set ( NUM ) ; }
void refresh Preferred Countries ( ) { if ( country Preference == null || country Preference . length ( ) == NUM ) { preferred Countries = null ; } else { List < Country > local Country List = new Array List < > ( ) ; for ( String name Code : country Preference . split ( STRING ) ) { Country country = Country . get Country For Name Code From Custom Master List ( custom Master Countries List , custom Language , name Code ) ; if ( country != null ) { if ( ! is Already In List ( country , local Country List ) ) { local Country List . add ( country ) ; } } } if ( local Country List . size ( ) == NUM ) { preferred Countries = null ; } else { preferred Countries = local Country List ; } } if ( preferred Countries != null ) { for ( Country country : preferred Countries ) { country . log ( ) ; } } else { } }
public void remove Pause Listener ( Animator Pause Listener listener ) { if ( m Pause Listeners == null ) { return ; } m Pause Listeners . remove ( listener ) ; if ( m Pause Listeners . size ( ) == NUM ) { m Pause Listeners = null ; } }
public void make Immutable ( ) { if ( mutable ) { if ( attr Values != null ) { attr Values = Collections . unmodifiable List ( attr Values ) ; } if ( value Strings != null ) { value Strings = Collections . unmodifiable List ( value Strings ) ; } if ( any Map != null ) { any Map = Collections . unmodifiable Map ( any Map ) ; } mutable = BOOL ; } }
protected String use Clusterer ( Instances data ) throws Exception { String result ; Clusterer clusterer ; int i ; double cluster ; try { clusterer = Abstract Clusterer . make Copy ( m Clusterer ) ; } catch ( Exception e ) { clusterer = null ; e . print Stack Trace ( ) ; fail ( STRING + e ) ; } clusterer . build Clusterer ( data ) ; result = STRING ; for ( i = NUM ; i < data . num Instances ( ) ; i ++ ) { if ( i > NUM ) result += STRING ; try { cluster = clusterer . cluster Instance ( data . instance ( i ) ) ; result += STRING + ( i + NUM ) + STRING + cluster ; } catch ( Exception e ) { result += STRING + ( i + NUM ) + STRING + e . to String ( ) ; } } return result ; }
public void add Component ( Multiblock Component component ) { if ( get Component For Location ( component . get Relative Position ( ) ) != null ) throw new Illegal Argument Exception ( STRING ) ; components . add ( component ) ; change Axis For New Component ( component . get Relative Position ( ) ) ; calculate Cost For New Component ( component ) ; add Component To Location Cache ( component ) ; }
public static Optional < Input Stream > open Stream ( final URI uri ) { try { return Url Streams . open Stream ( uri . to URL ( ) ) ; } catch ( final Malformed URL Exception e ) { throw new Illegal State Exception ( STRING + uri , e ) ; } }
public Short Banded Raster ( Sample Model sample Model , Point origin ) { this ( sample Model , sample Model . create Data Buffer ( ) , new Rectangle ( origin . x , origin . y , sample Model . get Width ( ) , sample Model . get Height ( ) ) , origin , null ) ; }
public static Optional < Notification > try Find ( @ Nonnull final Iterable < Notification > notifications , final long id ) { final com . google . common . base . Optional < Notification > result = Iterables . try Find ( notifications , null ) ; if ( result . is Present ( ) ) { return Optional . of ( result . get ( ) ) ; } return Optional . empty ( ) ; }
private boolean execute ( String command , File arg , List < String > lines ) { Process Builder pb = new Process Builder ( command , arg . get Absolute Path ( ) ) ; pb . redirect Error Stream ( BOOL ) ; try { Process proc = pb . start ( ) ; Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( proc . get Input Stream ( ) ) ) ; String line ; while ( ( line = reader . read Line ( ) ) != null ) { lines . add ( line ) ; } proc . wait For ( ) ; return proc . exit Value ( ) == NUM ; } catch ( Exception e ) { log . error ( STRING + command + STRING + arg , e ) ; lines . add ( e . get Message ( ) ) ; return BOOL ; } }
@ Request Processing ( value = STRING , method = HTTP Request Method . POST ) @ Before ( advice Class = { Stopwatch Start Advice . class , Mall Admin Check . class } ) @ After ( advice Class = Stopwatch End Advice . class ) public void charge Point ( final HTTP Request Context context , final Http Servlet Request request , final Http Servlet Response response ) throws Exception { final String user Name = request . get Parameter ( User . USER NAME ) ; final String point Str = request . get Parameter ( Common . POINT ) ; final String memo = request . get Parameter ( Common . MEMO ) ; if ( String Utils . is Blank ( point Str ) || ! String Utils . is Numeric ( memo ) ) { final Abstract Free Marker Renderer renderer = new Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( STRING ) ; final Map < String , Object > data Model = renderer . get Data Model ( ) ; data Model . put ( Keys . MSG , STRING ) ; filler . fill Header And Footer ( request , response , data Model ) ; return ; } final JSON Object user = user Query Service . get User By Name ( user Name ) ; if ( null == user ) { final Abstract Free Marker Renderer renderer = new Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( STRING ) ; final Map < String , Object > data Model = renderer . get Data Model ( ) ; data Model . put ( Keys . MSG , STRING + user Name + STRING ) ; filler . fill Header And Footer ( request , response , data Model ) ; return ; } final JSON Object current User = ( JSON Object ) request . get Attribute ( User . USER ) ; try { final int point = Integer . value Of ( point Str ) ; final String transfer Id = pointtransfer Mgmt Service . transfer ( Pointtransfer . ID C SYS , user . opt String ( Keys . OBJECT ID ) , Pointtransfer . TRANSFER TYPE C CHARGE , point , memo + STRING + current User . opt String ( Keys . OBJECT ID ) ) ; final JSON Object notification = new JSON Object ( ) ; notification . put ( Notification . NOTIFICATION USER ID , user . opt String ( Keys . OBJECT ID ) ) ; notification . put ( Notification . NOTIFICATION DATA ID , transfer Id ) ; notification Mgmt Service . add Point Charge Notification ( notification ) ; } catch ( final Exception e ) { final Abstract Free Marker Renderer renderer = new Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( STRING ) ; final Map < String , Object > data Model = renderer . get Data Model ( ) ; data Model . put ( Keys . MSG , e . get Message ( ) ) ; filler . fill Header And Footer ( request , response , data Model ) ; return ; } response . send Redirect ( Latkes . get Serve Path ( ) + STRING ) ; }
public Multiple Composite Space Predicate ( List < I Space Predicate > operands ) { if ( operands == null ) throw new Illegal Argument Exception ( STRING ) ; for ( int i = NUM ; i < operands . size ( ) ; i ++ ) if ( operands . get ( i ) == null ) throw new Illegal Argument Exception ( STRING + i + STRING ) ; this . operands List = operands ; }
public static Value decode Value ( final String s ) { if ( s == null ) return null ; final int slen = s . length ( ) ; if ( slen == NUM ) throw new Illegal Argument Exception ( STRING ) ; final char ch = s . char At ( NUM ) ; if ( ch == STRING || ch == STRING ) { final int close Quote Pos = s . last Index Of ( ch ) ; if ( close Quote Pos == NUM ) throw new Illegal Argument Exception ( s ) ; final String label = s . substring ( NUM , close Quote Pos ) ; if ( slen == close Quote Pos + NUM ) { return new Literal Impl ( label ) ; } final char ch 2 = s . char At ( close Quote Pos + NUM ) ; if ( ch 2 == STRING ) { final String language Code = s . substring ( close Quote Pos + NUM ) ; return new Literal Impl ( label , language Code ) ; } else if ( ch 2 == STRING ) { if ( slen <= close Quote Pos + NUM ) throw new Illegal Argument Exception ( s ) ; if ( s . char At ( close Quote Pos + NUM ) != STRING ) throw new Illegal Argument Exception ( s ) ; final String datatype Str = s . substring ( close Quote Pos + NUM ) ; final URI datatype URI = decode URI ( datatype Str ) ; return new Literal Impl ( label , datatype URI ) ; } else { throw new Illegal Argument Exception ( s ) ; } } else if ( ch == STRING ) { if ( s . char At ( slen - NUM ) != STRING ) throw new Illegal Argument Exception ( s ) ; final String uri Str = s . substring ( NUM , slen - NUM ) ; return new URI Impl ( uri Str ) ; } else { throw new Illegal Argument Exception ( s ) ; } }
private Set < Eg Demand Details > create All Dmd Details ( final List < Installment > inst List , final Hash Map < Installment , Tax Calculation Info > inst Tax Map ) { LOGGER . debug ( STRING ) ; final Set < Eg Demand Details > dmd Det Set = new Hash Set < Eg Demand Details > ( ) ; for ( final Installment inst : inst List ) { final Tax Calculation Info tax Calc Info = inst Tax Map . get ( inst ) ; final Map < String , Big Decimal > tax Map = tax Calculator . get Misc Taxes For Prop ( tax Calc Info . get Unit Tax Calculation Infos ( ) ) ; for ( final Map . Entry < String , Big Decimal > tax : tax Map . entry Set ( ) ) { final Eg Demand Reason eg Dmd Rsn = property Tax Util . get Demand Reason By Code And Installment ( tax . get Key ( ) , inst ) ; dmd Det Set . add ( create Demand Details ( tax . get Value ( ) , eg Dmd Rsn , inst ) ) ; } } LOGGER . debug ( STRING + dmd Det Set ) ; return dmd Det Set ; }
public int read ( byte [ ] bytes , int offset , int count ) throws IO Exception { if ( bytes == null ) throw new Illegal Argument Exception ( STRING ) ; int starting Count = count ; int copy Count = Math . min ( limit - position , count ) ; while ( BOOL ) { System . arraycopy ( buffer , position , bytes , offset , copy Count ) ; position += copy Count ; count -= copy Count ; if ( count == NUM ) break ; offset += copy Count ; copy Count = optional ( count ) ; if ( copy Count == - NUM ) { if ( starting Count == count ) return - NUM ; break ; } if ( position == limit ) break ; } return starting Count - count ; }
public void test concurrent modification insert split root leaf ( ) { final B Tree btree ; { Index Metadata md = new Index Metadata ( UUID . random UUID ( ) ) ; md . set Branching Factor ( NUM ) ; btree = B Tree . create ( new Simple Memory Raw Store ( ) , md ) ; btree . insert ( NUM , STRING ) ; btree . insert ( NUM , STRING ) ; btree . insert ( NUM , STRING ) ; } { I Tuple Cursor 2 < String > cursor = new Cursor ( btree ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . seek ( NUM ) ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . tuple ( ) ) ; btree . insert ( NUM , STRING ) ; assert Equals ( Test Key Builder . as Sort Key ( NUM ) , cursor . current Key ( ) ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . tuple ( ) ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . prior ( ) ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . tuple ( ) ) ; btree . remove ( NUM ) ; assert Equals ( Test Key Builder . as Sort Key ( NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . next ( ) ) ; btree . remove ( NUM ) ; assert Equals ( Test Key Builder . as Sort Key ( NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; btree . insert ( NUM , STRING ) ; assert Equals ( Test Key Builder . as Sort Key ( NUM ) , cursor . current Key ( ) ) ; assert Equals ( null , cursor . tuple ( ) ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . next ( ) ) ; assert Equals ( new Test Tuple < String > ( NUM , STRING ) , cursor . tuple ( ) ) ; } }
private synchronized void stop Ims Connection ( Termination Reason reason Code ) throws Payload Exception , Network Exception , Contact Manager Exception { if ( m Ims Polling Thread Id == - NUM ) { return ; } if ( s Logger . is Activated ( ) ) { s Logger . info ( STRING ) ; } m Ims Polling Thread Id = - NUM ; m Ims Polling Thread . interrupt ( ) ; m Ims Polling Thread = null ; if ( m Ims Services Started ) { m Ims Module . stop Ims Services ( reason Code ) ; m Ims Services Started = BOOL ; } }
public void copy String ( String encoding , String s ) throws Unsupported Encoding Exception { super . set Content Encoding ( encoding ) ; content = s . get Bytes ( encoding ) ; }
private void compare Surrogate Key Data ( List < String > data , Dictionary reverse Dictionary ) { int surrogate Key = NUM ; for ( int i = NUM ; i < data . size ( ) ; i ++ ) { surrogate Key ++ ; assert True ( surrogate Key == reverse Dictionary . get Surrogate Key ( data . get ( i ) ) ) ; } }
public static String Buffer string Substitution ( String arg Str , Map vars ) { String Buffer arg Buf = new String Buffer ( ) ; for ( int c Idx = NUM ; c Idx < arg Str . length ( ) ; ) { char ch = arg Str . char At ( c Idx ) ; switch ( ch ) { case STRING : String Buffer name Buf = new String Buffer ( ) ; for ( ++ c Idx ; c Idx < arg Str . length ( ) ; ++ c Idx ) { ch = arg Str . char At ( c Idx ) ; if ( ch == STRING || Character . is Letter Or Digit ( ch ) ) name Buf . append ( ch ) ; else break ; } if ( name Buf . length ( ) > NUM ) { String value = ( String ) vars . get ( name Buf . to String ( ) ) ; if ( value != null ) { arg Buf . append ( value ) ; } } break ; default : arg Buf . append ( ch ) ; ++ c Idx ; break ; } } return arg Buf ; }
public static Uri rename Scrap File ( String file Extension , String unique Identifier , Context context ) { String file Path = get Scrap Path ( context ) ; if ( unique Identifier == null ) { unique Identifier = STRING ; } File new Temp File = new File ( get Scrap Path ( context , STRING + unique Identifier + file Extension ) ) ; File old Temp File = new File ( file Path ) ; boolean deleted = new Temp File . delete ( ) ; if ( ! old Temp File . rename To ( new Temp File ) ) { return null ; } return Uri . from File ( new Temp File ) ; }
public synchronized void initialize ( ) { if ( m Initialized ) { return ; } m Initialized = BOOL ; if ( ! m Root Directory . exists ( ) ) { if ( ! m Root Directory . mkdirs ( ) ) { Volley Log . e ( STRING , m Root Directory . get Absolute Path ( ) ) ; } return ; } File [ ] files = m Root Directory . list Files ( ) ; if ( files == null ) { return ; } Volley Log . d ( STRING , files . length ) ; Executor Service executor = new Thread Pool Executor ( CACHE LOAD THREADS , CACHE LOAD THREADS , NUM , Time Unit . MILLISECONDS , m Queue ) ; for ( File file : files ) { Callable < Cache Header > callable = new Header Parser Callable ( file ) ; Runnable Future < Cache Header > submit = new Reordering Future Task ( callable ) ; m Loading Files . put ( file . get Name ( ) , submit ) ; executor . execute ( submit ) ; } }
public int diff common Suffix ( String text 1 , String text 2 ) { int text 1 length = text 1 . length ( ) ; int text 2 length = text 2 . length ( ) ; int n = Math . min ( text 1 length , text 2 length ) ; for ( int i = NUM ; i <= n ; i ++ ) { if ( text 1 . char At ( text 1 length - i ) != text 2 . char At ( text 2 length - i ) ) { return i - NUM ; } } return n ; }
protected static @ Not Null String convert Map To Groovy Source ( @ Not Null Map < String , Object > map ) { String Builder sb = new String Builder ( ) ; for ( Map . Entry < String , Object > entry : map . entry Set ( ) ) { if ( sb . length ( ) > NUM ) { sb . append ( STRING ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( STRING ) ; sb . append ( convert Value To Groovy Source ( entry . get Value ( ) ) ) ; } return sb . to String ( ) ; }
public static Multivalued Map < String , String > decode ( Multivalued Map < String , String > map ) { Multivalued Map Impl < String , String > decoded = new Multivalued Map Impl < String , String > ( ) ; for ( Map . Entry < String , List < String > > entry : map . entry Set ( ) ) { List < String > values = entry . get Value ( ) ; for ( String value : values ) { try { decoded . add ( URL Decoder . decode ( entry . get Key ( ) , UTF 8 ) , URL Decoder . decode ( value , UTF 8 ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Runtime Exception ( e ) ; } } } return decoded ; }
public Buffered Image to Image ( Drawing drawing , java . util . List < Figure > figures , Affine Transform transform , Dimension image Size ) { Color background = drawing . get ( CANVAS FILL COLOR ) ; double opacity = drawing . get ( CANVAS FILL OPACITY ) ; if ( background == null ) { background = new Color ( NUM , NUM , NUM , NUM ) ; } else { background = new Color ( background . get Red ( ) , background . get Green ( ) , background . get Blue ( ) , ( int ) ( background . get Alpha ( ) * opacity ) ) ; } Buffered Image buf = new Buffered Image ( Math . max ( NUM , image Size . width ) , Math . max ( NUM , image Size . height ) , ( background . get Alpha ( ) == NUM ) ? Buffered Image . TYPE INT RGB : Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g = buf . create Graphics ( ) ; Composite saved Composite = g . get Composite ( ) ; g . set Composite ( Alpha Composite . get Instance ( Alpha Composite . SRC ) ) ; g . set Color ( background ) ; g . fill Rect ( NUM , NUM , buf . get Width ( ) , buf . get Height ( ) ) ; g . set Composite ( saved Composite ) ; set Rendering Hints ( g ) ; g . transform ( transform ) ; for ( Figure f : figures ) { f . draw ( g ) ; } g . dispose ( ) ; if ( image Type != Buffered Image . TYPE INT ARGB ) { Buffered Image buf 2 = new Buffered Image ( buf . get Width ( ) , buf . get Height ( ) , image Type ) ; g = buf 2 . create Graphics ( ) ; set Rendering Hints ( g ) ; g . set Composite ( Alpha Composite . get Instance ( Alpha Composite . SRC ) ) ; g . draw Image ( buf , NUM , NUM , null ) ; g . dispose ( ) ; buf . flush ( ) ; buf = buf 2 ; } return buf ; }
public static long pause ( final long sleep Time MS ) { final long start Time = System . current Time Millis ( ) ; do { try { final long sleep Time = sleep Time MS - ( System . current Time Millis ( ) - start Time ) ; Thread . sleep ( sleep Time > NUM ? sleep Time : NUM ) ; } catch ( Interrupted Exception e ) { } } while ( ( System . current Time Millis ( ) - start Time ) < sleep Time MS ) ; return System . current Time Millis ( ) - start Time ; }
public void next ( Controller Animator animator ) { if ( animator == null ) throw new Null Pointer Exception ( STRING ) ; if ( iterator . has Next ( ) ) { View current View = iterator . next ( ) ; if ( is Using Default Listener ( ) ) current View . set On Click Listener ( null ) ; if ( iterator . next Index ( ) < m Views . size ( ) ) { View next View = m Views . get ( iterator . next Index ( ) ) ; if ( is Using Default Listener ( ) ) next View . set On Click Listener ( listener ) ; animator . set Old View ( current View ) ; animator . set New View ( next View ) ; current View . start Animation ( animator ) ; if ( iterator . next Index ( ) == m Views . size ( ) - NUM ) if ( has Controller Listener ( ) ) m Listener . on End Reached ( ) ; } else { if ( m Loop ) { iterator = m Views . list Iterator ( ) ; View next View = m Views . get ( NUM ) ; if ( m Use Default Listener ) next View . set On Click Listener ( listener ) ; animator . set Old View ( current View ) ; animator . set New View ( next View ) ; current View . start Animation ( animator ) ; } } } }
protected static Method resolve Java Method ( Bsh Class Manager bcm , Class clas , String name , Class [ ] types , boolean static Only ) throws Util Eval Error { if ( clas == null ) throw new Interpreter Error ( STRING ) ; Method method = null ; if ( bcm == null ) Interpreter . debug ( STRING ) ; else method = bcm . get Resolved Method ( clas , name , types , static Only ) ; if ( method == null ) { boolean public Only = ! Capabilities . have Accessibility ( ) ; try { method = find Overloaded Method ( clas , name , types , public Only ) ; } catch ( Security Exception e ) { throw new Util Target Error ( STRING + clas , e ) ; } check Found Static Method ( method , static Only , clas ) ; if ( method != null && ! public Only ) { try { Reflect Manager . RM Set Accessible ( method ) ; } catch ( Util Eval Error e ) { } } if ( method != null && bcm != null ) bcm . cache Resolved Method ( clas , types , method ) ; } return method ; }
private void process Pre Destroy View Map ( System Event se ) { if ( LOGGER . is Loggable ( Level . FINEST ) ) { LOGGER . log ( Level . FINEST , STRING ) ; } UI View Root view Root = ( UI View Root ) se . get Source ( ) ; Map < String , Object > view Map = view Root . get View Map ( BOOL ) ; if ( view Map != null && ! view Map . is Empty ( ) ) { Faces Context faces Context = Faces Context . get Current Instance ( ) ; if ( context Manager != null ) { context Manager . clear ( faces Context , view Map ) ; context Manager . fire Destroyed Event ( faces Context , view Root ) ; } destroy Beans ( faces Context , view Map ) ; } }
private static void save ( Bitmap src , String file Name , Bitmap . Compress Format format , int quality ) throws Image Save Exception { File Output Stream output Stream = null ; try { output Stream = new File Output Stream ( file Name ) ; src . compress ( format , quality , output Stream ) ; output Stream . close ( ) ; } catch ( IO Exception e ) { throw new Image Save Exception ( e ) ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch ( IO Exception e1 ) { e1 . print Stack Trace ( ) ; } } } }
@ Override public Node item ( int index ) { Node this Node ; if ( root Node . changes ( ) != changes ) { nodes = new Array List ( ) ; changes = root Node . changes ( ) ; } final int current Size = nodes . size ( ) ; if ( index < current Size ) { return ( Node ) nodes . get ( index ) ; } else { if ( current Size == NUM ) { this Node = root Node ; } else { this Node = ( Node Impl ) ( nodes . get ( current Size - NUM ) ) ; } while ( this Node != null && index >= nodes . size ( ) ) { this Node = next Matching Element After ( this Node ) ; if ( this Node != null ) { nodes . add ( this Node ) ; } } return this Node ; } }
public final void render ( Terminal Emulator m Emulator , Canvas canvas , int top Row , int selection Y 1 , int selection Y 2 , int selection X 1 , int selection X 2 ) { final boolean reverse Video = m Emulator . is Reverse Video ( ) ; final int end Row = top Row + m Emulator . m Rows ; final int columns = m Emulator . m Columns ; final int cursor Col = m Emulator . get Cursor Col ( ) ; final int cursor Row = m Emulator . get Cursor Row ( ) ; final boolean cursor Visible = m Emulator . is Showing Cursor ( ) ; final Terminal Buffer screen = m Emulator . get Screen ( ) ; final int [ ] palette = m Emulator . m Colors . m Current Colors ; if ( reverse Video ) canvas . draw Color ( palette [ Text Style . COLOR INDEX FOREGROUND ] , Porter Duff . Mode . SRC ) ; float height Offset = m Font Line Spacing And Ascent ; for ( int row = top Row ; row < end Row ; row ++ ) { height Offset += m Font Line Spacing ; final int cursor X = ( row == cursor Row && cursor Visible ) ? cursor Col : - NUM ; int selx 1 = - NUM , selx 2 = - NUM ; if ( row >= selection Y 1 && row <= selection Y 2 ) { if ( row == selection Y 1 ) selx 1 = selection X 1 ; selx 2 = ( row == selection Y 2 ) ? selection X 2 : m Emulator . m Columns ; } Terminal Row line Object = screen . allocate Full Line If Necessary ( screen . external To Internal Row ( row ) ) ; final char [ ] line = line Object . m Text ; final int chars Used In Line = line Object . get Space Used ( ) ; long last Run Style = NUM ; boolean last Run Inside Cursor = BOOL ; int last Run Start Column = - NUM ; int last Run Start Index = NUM ; boolean last Run Font Width Mismatch = BOOL ; int current Char Index = NUM ; float measured Width For Run = NUM ; for ( int column = NUM ; column < columns ; ) { final char char At Index = line [ current Char Index ] ; final boolean char Is Highsurrogate = Character . is High Surrogate ( char At Index ) ; final int chars For Code Point = char Is Highsurrogate ? NUM : NUM ; final int code Point = char Is Highsurrogate ? Character . to Code Point ( char At Index , line [ current Char Index + NUM ] ) : char At Index ; final int code Point Wc Width = Wc Width . width ( code Point ) ; final boolean inside Cursor = ( column >= selx 1 && column <= selx 2 ) || ( cursor X == column || ( code Point Wc Width == NUM && cursor X == column + NUM ) ) ; final long style = line Object . get Style ( column ) ; final float measured Code Point Width = ( code Point < ascii Measures . length ) ? ascii Measures [ code Point ] : m Text Paint . measure Text ( line , current Char Index , chars For Code Point ) ; final boolean font Width Mismatch = Math . abs ( measured Code Point Width / m Font Width - code Point Wc Width ) > NUM ; if ( style != last Run Style || inside Cursor != last Run Inside Cursor || font Width Mismatch || last Run Font Width Mismatch ) { if ( column == NUM ) { } else { final int column Width Since Last Run = column - last Run Start Column ; final int chars Since Last Run = current Char Index - last Run Start Index ; draw Text Run ( canvas , line , palette , height Offset , last Run Start Column , column Width Since Last Run , last Run Start Index , chars Since Last Run , measured Width For Run , last Run Inside Cursor , last Run Style , reverse Video ) ; } measured Width For Run = NUM ; last Run Style = style ; last Run Inside Cursor = inside Cursor ; last Run Start Column = column ; last Run Start Index = current Char Index ; last Run Font Width Mismatch = font Width Mismatch ; } measured Width For Run += measured Code Point Width ; column += code Point Wc Width ; current Char Index += chars For Code Point ; while ( current Char Index < chars Used In Line && Wc Width . width ( line , current Char Index ) <= NUM ) { current Char Index += Character . is High Surrogate ( line [ current Char Index ] ) ? NUM : NUM ; } } final int column Width Since Last Run = columns - last Run Start Column ; final int chars Since Last Run = current Char Index - last Run Start Index ; draw Text Run ( canvas , line , palette , height Offset , last Run Start Column , column Width Since Last Run , last Run Start Index , chars Since Last Run , measured Width For Run , last Run Inside Cursor , last Run Style , reverse Video ) ; } }
public GTS Encoder ( long base Timestamp , byte [ ] key ) { this . base Timestamp = base Timestamp ; this . stream = new Byte Array Output Stream ( ) ; this . wrapping Key = null == key ? null : Arrays . copy Of ( key , key . length ) ; }
public static Lat Lng translate Point ( Lat Lng point , double distance , double bearing ) { distance = distance / NUM ; double lat = Math . to Radians ( point . latitude ) ; double lng = Math . to Radians ( point . longitude ) ; bearing = Math . to Radians ( bearing ) ; double Lat 2 = Math . asin ( ( Math . sin ( lat ) * Math . cos ( distance / EARTH ) ) + ( Math . cos ( lat ) * Math . sin ( distance / EARTH ) * Math . cos ( bearing ) ) ) ; double Long 2 = lng + Math . atan 2 ( Math . sin ( bearing ) * Math . sin ( distance / EARTH ) * Math . cos ( lat ) , Math . cos ( distance / EARTH ) - ( Math . sin ( lat ) * Math . sin ( Lat 2 ) ) ) ; Lat 2 = Math . to Degrees ( Lat 2 ) ; Long 2 = Math . to Degrees ( Long 2 ) ; return new Lat Lng ( Lat 2 , Long 2 ) ; }
private static Counter < String > load Weights ( String wts Initial File , boolean uniform Start Weights , boolean randomize Start Weights , Translation Model < I String , String > translation Model ) { Counter < String > weights = IO Tools . read Weights ( wts Initial File ) ; if ( weights == null ) weights = new Classic Counter < > ( ) ; if ( uniform Start Weights ) { Set < String > feature Names = new Hash Set < > ( weights . key Set ( ) ) ; feature Names . add All ( Feature Utils . get Baseline Features ( translation Model ) ) ; for ( String key : feature Names ) { if ( key . starts With ( N Gram Language Model Featurizer . DEFAULT FEATURE NAME ) ) { weights . set Count ( key , NUM ) ; } else if ( key . starts With ( Word Penalty Featurizer . FEATURE NAME ) ) { weights . set Count ( key , - NUM ) ; } else { weights . set Count ( key , NUM ) ; } } } if ( randomize Start Weights ) { double scale = NUM ; Optimizer Utils . randomize Weights In Place ( weights , scale ) ; } return weights ; }
public void close ( ) { flush ( ) ; if ( writer != null ) { try { writer . close ( ) ; } catch ( IO Exception e ) { Debug . error ( file Name + STRING , e ) ; } } stop Buffer Timer ( ) ; }
public static Partial Merkle Tree build From Leaves ( Network Parameters params , byte [ ] include Bits , List < Sha 256 Hash > all Leaf Hashes ) { int height = NUM ; while ( get Tree Width ( all Leaf Hashes . size ( ) , height ) > NUM ) height ++ ; List < Boolean > bit List = new Array List < Boolean > ( ) ; List < Sha 256 Hash > hashes = new Array List < Sha 256 Hash > ( ) ; traverse And Build ( height , NUM , all Leaf Hashes , include Bits , bit List , hashes ) ; byte [ ] bits = new byte [ ( int ) Math . ceil ( bit List . size ( ) / NUM ) ] ; for ( int i = NUM ; i < bit List . size ( ) ; i ++ ) if ( bit List . get ( i ) ) Utils . set Bit LE ( bits , i ) ; return new Partial Merkle Tree ( params , bits , hashes , all Leaf Hashes . size ( ) ) ; }
public void put Len Bytes ( byte [ ] bytes ) { ensure Capacity ( NUM + bytes . length ) ; put Field Length ( bytes . length ) ; System . arraycopy ( bytes , NUM , this . byte Buffer , this . position , bytes . length ) ; this . position += bytes . length ; }
private boolean region Dialing From Matches Number ( Phone Number number , String region Dialing From ) { List < String > region Codes = get Region Codes For Country Code ( number . get Country Code ( ) ) ; return region Codes . contains ( region Dialing From ) ; }
public String normalize Uri ( String uri ) { if ( uri != null && ! uri . ends With ( STRING ) ) { uri += STRING ; } return uri ; }
static public void sync Classification Block 2 Summary ( int data Set Id , int total Data Sets , I Classification Block classification Block , Data Table table ) { final Map < Integer , Integer [ ] > class Id 2 count = new Hash Map < > ( ) ; table . set Class 2 Counts ( classification Block . get Name ( ) , class Id 2 count ) ; for ( Integer class Id : classification Block . get Key Set ( ) ) { int sum = classification Block . get Weighted Sum ( class Id ) ; if ( sum > NUM ) { if ( class Id 2 count . get ( class Id ) == null ) class Id 2 count . put ( class Id , new Integer [ total Data Sets ] ) ; Integer total = class Id 2 count . get ( class Id ) [ data Set Id ] ; if ( total != null ) class Id 2 count . get ( class Id ) [ data Set Id ] = total + sum ; else class Id 2 count . get ( class Id ) [ data Set Id ] = sum ; } } if ( table . get Additional Reads ( ) > NUM ) { if ( class Id 2 count . get ( Id Mapper . NOHITS ID ) == null ) class Id 2 count . put ( Id Mapper . NOHITS ID , new Integer [ total Data Sets ] ) ; Integer total = class Id 2 count . get ( Id Mapper . NOHITS ID ) [ data Set Id ] ; if ( total != null ) class Id 2 count . get ( Id Mapper . NOHITS ID ) [ data Set Id ] = total + ( int ) table . get Additional Reads ( ) ; else class Id 2 count . get ( Id Mapper . NOHITS ID ) [ data Set Id ] = ( int ) table . get Additional Reads ( ) ; } }
public static String convert To ARGB ( int color ) { String alpha = Integer . to Hex String ( Color . alpha ( color ) ) ; String red = Integer . to Hex String ( Color . red ( color ) ) ; String green = Integer . to Hex String ( Color . green ( color ) ) ; String blue = Integer . to Hex String ( Color . blue ( color ) ) ; if ( alpha . length ( ) == NUM ) { alpha = STRING + alpha ; } if ( red . length ( ) == NUM ) { red = STRING + red ; } if ( green . length ( ) == NUM ) { green = STRING + green ; } if ( blue . length ( ) == NUM ) { blue = STRING + blue ; } return STRING + alpha + red + green + blue ; }
@ After Class public void stop Jetty ( ) throws Exception { server . stop ( ) ; }
protected Date Time Data parse ( String str ) throws Schema Date Time Exception { Date Time Data date = new Date Time Data ( str , this ) ; int len = str . length ( ) ; date . year = YEAR ; if ( str . char At ( NUM ) != STRING || str . char At ( NUM ) != STRING ) { throw new Schema Date Time Exception ( STRING + str ) ; } date . month = parse Int ( str , NUM , NUM ) ; int start = NUM ; if ( str . char At ( start ++ ) != STRING ) { throw new Schema Date Time Exception ( STRING + str ) ; } date . day = parse Int ( str , start , start + NUM ) ; if ( MONTHDAY SIZE < len ) { if ( ! is Next Char UTC Sign ( str , MONTHDAY SIZE , len ) ) { throw new Schema Date Time Exception ( STRING + str ) ; } else { get Time Zone ( str , date , MONTHDAY SIZE , len ) ; } } validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != NUM && date . utc != STRING ) { normalize ( date ) ; } date . position = NUM ; return date ; }
synchronized String create Local Id ( ) { long local Id Number = random . next Long ( ) ; String local Id = STRING + Long . to Hex String ( local Id Number ) ; if ( ! is Local Id ( local Id ) ) { throw new Illegal State Exception ( STRING + local Id + STRING + STRING ) ; } return local Id ; }
private void load AD Sequences ( ) { if ( ! is Object Exists ( STRING , m tables ) ) return ; s logger . log ( Level . FINE , STRING , get Direction ( ) ) ; String sql = s db Engine . sql AD get Sequences ( get Vendor ( ) , get Catalog ( ) , get Schema ( ) ) ; Result Set rs = null ; Statement stmt = null ; m sequence System = new Hash Map < String , Long > ( ) ; m sequence User = new Hash Map < String , Long > ( ) ; stmt = set Statement ( ) ; rs = execute Query ( stmt , sql ) ; while ( get Result Set Next ( rs ) ) { String seq Name = get Result Set String ( rs , STRING ) ; if ( seq Name != null ) { seq Name = seq Name . to Upper Case ( ) ; long seq System = get Result Set Long ( rs , STRING ) ; long seq User = get Result Set Long ( rs , STRING ) ; m sequence System . put ( seq Name , seq System ) ; m sequence User . put ( seq Name , seq User ) ; } } release Result Set ( rs ) ; release Statement ( stmt ) ; s logger . log ( Level . FINE , STRING , Integer . to String ( m sequence System . size ( ) ) ) ; s logger . flush ( ) ; return ; }
void on Exception ( JMS Exception jE ) { if ( error Handler != null ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + cnx Key ) ; } error Handler . on Exception ( jE ) ; } else { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + cnx Key ) ; } } }
public void terminate ( ) throws IO Exception { try { try { synchronized ( m Jobs ) { while ( m Busy || ! m Jobs . is Empty ( ) ) { m Jobs . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { Program State . set Abort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally { Program State . clear Abort ( ) ; try { synchronized ( m Queue Thread ) { while ( ! m Queue Done ) { m Queue Thread . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { } } }
public static J Panel horizontal J Panel ( final Component west Component , final Component east Component ) { return horizontal J Panel ( west Component , Optional . empty ( ) , east Component ) ; }
public Str Builder insert ( int index , final boolean value ) { validate Index ( index ) ; if ( value ) { ensure Capacity ( size + NUM ) ; System . arraycopy ( buffer , index , buffer , index + NUM , size - index ) ; buffer [ index ++ ] = STRING ; buffer [ index ++ ] = STRING ; buffer [ index ++ ] = STRING ; buffer [ index ] = STRING ; size += NUM ; } else { ensure Capacity ( size + NUM ) ; System . arraycopy ( buffer , index , buffer , index + NUM , size - index ) ; buffer [ index ++ ] = STRING ; buffer [ index ++ ] = STRING ; buffer [ index ++ ] = STRING ; buffer [ index ++ ] = STRING ; buffer [ index ] = STRING ; size += NUM ; } return this ; }
public static int dial Down Heat ( Mounted weapon , Weapon Type wtype ) { return Compute . dial Down Heat ( weapon , wtype , NUM ) ; }
private static void add Id ( final String Builder buf , final byte [ ] id ) { buf . append ( STRING ) ; boolean backslash = BOOL ; for ( final byte b : id ) { buf . append ( ( char ) ( b & NUM ) ) ; if ( b == STRING && backslash ) { buf . append ( STRING ) ; } else { backslash = b == STRING ; } } buf . append ( STRING ) ; }
final V do Remove ( Object key , Object value ) { if ( key == null ) throw new Null Pointer Exception ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) < NUM ) break outer ; if ( c > NUM ) { b = n ; n = f ; continue ; } if ( value != null && ! value . equals ( v ) ) break outer ; if ( ! n . cas Value ( v , null ) ) break ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find Node ( key ) ; else { find Predecessor ( key , cmp ) ; if ( head . right == null ) try Reduce Level ( ) ; } @ Suppress Warnings ( STRING ) V vv = ( V ) v ; return vv ; } } return null ; }

public void reopen Read Write ( ) { synchronized ( m Lock ) { throw If Not Open Locked ( ) ; if ( ! is Read Only Locked ( ) ) { return ; } final int old Open Flags = m Configuration Locked . open Flags ; m Configuration Locked . open Flags = ( m Configuration Locked . open Flags & ~ OPEN READONLY ) ; try { m Connection Pool Locked . reconfigure ( m Configuration Locked ) ; } catch ( Runtime Exception ex ) { m Configuration Locked . open Flags = old Open Flags ; throw ex ; } } }
public static boolean is Conversion Supported ( Audio Format . Encoding target Encoding , Audio Format source Format ) { List codecs = get Format Conversion Providers ( ) ; for ( int i = NUM ; i < codecs . size ( ) ; i ++ ) { Format Conversion Provider codec = ( Format Conversion Provider ) codecs . get ( i ) ; if ( codec . is Conversion Supported ( target Encoding , source Format ) ) { return BOOL ; } } return BOOL ; }
private boolean advance Api Between Or Later ( Tree Set < Area Panel Info > sorted Api Tree , Area Panel Info api , int min Time , int max Time , int end Time ) { sorted Api Tree . remove ( api ) ; Area Panel ap = api . ap ( ) ; Time Tree root Tt = ap . get Time Tree ( ) ; Time Tree tt = root Tt . get Encompassig Time Tree Or Max Time Tree Before Time ( max Time , BOOL ) ; if ( tt == null || tt . get Min Time Secs ( ) < min Time ) { tt = root Tt . get Encompassig Time Tree Or Min Time Tree After Time ( max Time , BOOL ) ; if ( api . set Tt ( tt , end Time ) ) { sorted Api Tree . add ( api ) ; } return BOOL ; } else { if ( api . set Tt ( tt , end Time ) ) sorted Api Tree . add ( api ) ; return BOOL ; } }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . POST ) @ Response Body public Rest Wrapper update ( @ Model Attribute ( STRING ) @ Valid Users users , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { String hashed Password = Digest Utils . sha 1 Hex ( users . get Password ( ) ) ; users . set Password ( hashed Password ) ; com . wipro . ats . bdre . md . dao . jpa . Users jpa Users = new com . wipro . ats . bdre . md . dao . jpa . Users ( ) ; jpa Users . set Password ( hashed Password ) ; jpa Users . set Username ( users . get Username ( ) ) ; jpa Users . set Enabled ( ( users . get Enabled ( ) == NUM ) ? BOOL : BOOL ) ; users DAO . update ( jpa Users ) ; rest Wrapper = new Rest Wrapper ( users , Rest Wrapper . OK ) ; LOGGER . info ( STRING + users . get Username ( ) + STRING + principal . get Name ( ) + users ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
private void send Request Option ( ) throws IO Exception { String request = STRING + m Parameters . host + STRING + m Parameters . port + m Parameters . path + STRING + add Headers ( ) ; Log . i ( TAG , request . substring ( NUM , request . index Of ( STRING ) ) ) ; m Output Stream . write ( request . get Bytes ( STRING ) ) ; m Output Stream . flush ( ) ; Response . parse Response ( m Buffered Reader ) ; }
@ Override public Result do Comparison Test ( final Properties properties ) throws Exception { final long timeout = Long . parse Long ( properties . get Property ( Test Options . TIMEOUT ) ) ; final int nclients = Integer . parse Int ( properties . get Property ( Test Options . NCLIENTS ) ) ; final int ntrials = Integer . parse Int ( properties . get Property ( Test Options . NTRIALS ) ) ; final int key Len = Integer . parse Int ( properties . get Property ( Test Options . KEYLEN ) ) ; final int nops = Integer . parse Int ( properties . get Property ( Test Options . NOPS ) ) ; final double abort Rate = Double . parse Double ( properties . get Property ( Test Options . ABORT RATE ) ) ; final Result result = do Concurrent Client Test ( journal , timeout , nclients , ntrials , key Len , nops , abort Rate ) ; return result ; }
public static void thread Dump ( ) { LOG . error ( STRING ) ; final Thread MX Bean threads = Management Factory . get Thread MX Bean ( ) ; long [ ] thread Ids = threads . get All Thread Ids ( ) ; Print Writer print Writer = null ; try { print Writer = new Print Writer ( new File Writer ( THREAD DUMP FILE PATH , BOOL ) ) ; print Writer . println ( STRING + new Date ( ) ) ; for ( long thread Id : thread Ids ) { Thread Info thread Info = threads . get Thread Info ( thread Id , NUM ) ; print Writer . println ( STRING + thread Info . get Thread Name ( ) + STRING + thread Info . get Blocked Time ( ) + STRING + thread Info . get Blocked Count ( ) + STRING + thread Info . get Lock Name ( ) + STRING + thread Info . get Waited Count ( ) + STRING + thread Info . get Waited Time ( ) + STRING + thread Info . is Suspended ( ) ) ; Stack Trace Element [ ] stack Trace = thread Info . get Stack Trace ( ) ; for ( Stack Trace Element element : stack Trace ) { print Writer . println ( element ) ; } } } catch ( IO Exception ioe ) { ioe . print Stack Trace ( ) ; } finally { if ( print Writer != null ) { try { print Writer . flush ( ) ; print Writer . close ( ) ; } catch ( Exception e2 ) { } } } }
public void add Delete ( I Resource delete ) { if ( f Delete == null ) f Delete = new Array List ( NUM ) ; f Delete . add ( delete ) ; if ( f Ignore Count == NUM ) { internal Add ( new Delete Description ( delete ) ) ; } }
public static double min ( final double a , final double b ) { if ( a > b ) { return b ; } if ( a < b ) { return a ; } if ( a != b ) { return Double . Na N ; } long bits = Double . double To Raw Long Bits ( a ) ; if ( bits == NUM ) { return a ; } return b ; }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Object ( knn Distance ) ; }
public void add ( String method Name , List < Expression > parameters , boolean is Property ) { chain . add ( new Dot Expression Item ( method Name , parameters , is Property ) ) ; }
public static boolean is Category Top ( Servlet Request request , String product Category Id ) { return is Category Top ( ( Delegator ) request . get Attribute ( STRING ) , ( Local Dispatcher ) request . get Attribute ( STRING ) , product Category Id ) ; }
private void commercial Button Clicked ( String command ) { int length = Integer . parse Int ( command ) ; J Toggle Button button = commercial Buttons . get ( length ) ; if ( button . is Selected ( ) ) { if ( scheduled Commercial Time == NUM ) { run Commercial ( length ) ; } else { scheduled Commercial Length = length ; update ( ) ; } } else { scheduled Commercial Time = NUM ; set Commercial Result ( STRING ) ; } }
public static double float To Double Lower ( float f ) { if ( Float . is Na N ( f ) ) { return Double . Na N ; } if ( Float . is Infinite ( f ) ) { if ( f < NUM ) { return Double . NEGATIVE INFINITY ; } else { return Double . long Bits To Double ( NUM ) ; } } long bits = Double . double To Raw Long Bits ( ( double ) f ) ; if ( ( bits & NUM ) == NUM ) { if ( bits == NUM ) { return + NUM ; } if ( f == Float . MIN VALUE ) { return Double . long Bits To Double ( NUM ) ; } if ( Float . MIN NORMAL > f ) { final long bits 2 = Double . double To Raw Long Bits ( ( double ) - Math . next Up ( - f ) ) ; bits = ( bits > > > NUM ) + ( bits 2 > > > NUM ) + NUM ; } else { bits -= NUM ; } return Double . long Bits To Double ( bits ) ; } else { if ( bits == NUM ) { return Double . long Bits To Double ( NUM ) ; } if ( f == - Float . MIN VALUE ) { return Double . long Bits To Double ( NUM ) ; } if ( - Float . MIN NORMAL < f ) { final long bits 2 = Double . double To Raw Long Bits ( ( double ) - Math . next Up ( - f ) ) ; bits = ( bits > > > NUM ) + ( bits 2 > > > NUM ) - NUM ; } else { bits += NUM ; } return Double . long Bits To Double ( bits ) ; } }
public void subscribe ( AWS Iot Message message ) throws AWS Iot Exception { try { subscribe Topic ( message ) ; } catch ( Aws Iot Retryable Exception e ) { if ( client . get Max Offline Queue Size ( ) > NUM && subscribe Queue . size ( ) < client . get Max Offline Queue Size ( ) ) { subscribe Queue . add ( message ) ; } else { LOGGER . info ( STRING + message . get Topic ( ) ) ; throw new AWS Iot Exception ( e ) ; } } }
public static boolean is Solaris ( ) { return os Name . index Of ( STRING ) > - NUM || os Name . index Of ( STRING ) > - NUM ; }
private List < Quote > download Url ( String url Param ) throws IO Exception , Xml Pull Parser Exception { Input Stream is = null ; try { URL url = new URL ( url Param ) ; Http URL Connection conn = ( Http URL Connection ) url . open Connection ( ) ; conn . set Read Timeout ( NUM ) ; conn . set Connect Timeout ( NUM ) ; conn . set Request Method ( STRING ) ; conn . set Do Input ( BOOL ) ; conn . connect ( ) ; int response = conn . get Response Code ( ) ; Log . d ( STRING , STRING + response ) ; if ( response == NUM ) { is = conn . get Input Stream ( ) ; return read XML ( is ) ; } } finally { if ( is != null ) { is . close ( ) ; } } return null ; }
public boolean ends With ( Name n ) { if ( n instanceof Composite Name ) { return ( impl . ends With ( n . size ( ) , n . get All ( ) ) ) ; } else { return BOOL ; } }
private int calculate Total Width ( float star Size , int number Of Stars , float stars Separation , boolean padding ) { return Math . round ( star Size * number Of Stars + stars Separation * ( number Of Stars - NUM ) ) + ( padding ? get Padding Left ( ) + get Padding Right ( ) : NUM ) ; }
@ Suppress Warnings ( { STRING , STRING } ) public static boolean is Regex ( String s , int groups ) { Pattern p ; try { p = Pattern . compile ( s ) ; } catch ( Pattern Syntax Exception e ) { return BOOL ; } return get Group Count ( p ) >= groups ; }
public void flush ( ) { clear Buffer ( ) ; try { out . flush ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
private void update Display Name ( ) { String class Name = m Attributes . get ( STRING ) ; if ( class Name == null ) return ; String text = m Attributes . get ( STRING ) ; if ( text == null ) return ; String content Description = m Attributes . get ( STRING ) ; if ( content Description == null ) return ; String index = m Attributes . get ( STRING ) ; if ( index == null ) return ; String bounds = m Attributes . get ( STRING ) ; if ( bounds == null ) { return ; } class Name = class Name . replace ( STRING , STRING ) ; class Name = class Name . replace ( STRING , STRING ) ; String Builder builder = new String Builder ( ) ; builder . append ( STRING ) ; builder . append ( index ) ; builder . append ( STRING ) ; builder . append ( class Name ) ; if ( ! text . is Empty ( ) ) { builder . append ( STRING ) ; builder . append ( text ) ; } if ( ! content Description . is Empty ( ) ) { builder . append ( STRING ) ; builder . append ( content Description ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( bounds ) ; m Display Name = builder . to String ( ) ; }
public static Sentence new Conjunction ( Sentence ... conjuncts ) { return new Conjunction ( Arrays . as List ( conjuncts ) ) ; }
public void remove Temporary Maps ( Bit Field object Ids ) { for ( String map Name : store . get Map Names ( ) ) { if ( map Name . starts With ( STRING ) ) { MV Map < ? , ? > map = store . open Map ( map Name ) ; store . remove Map ( map ) ; } else if ( map Name . starts With ( STRING ) || map Name . starts With ( STRING ) ) { int id = Integer . parse Int ( map Name . substring ( NUM + map Name . index Of ( STRING ) ) ) ; if ( ! object Ids . get ( id ) ) { Value Data Type key Type = new Value Data Type ( null , null , null ) ; Value Data Type value Type = new Value Data Type ( null , null , null ) ; Transaction t = transaction Store . begin ( ) ; Transaction Map < ? , ? > m = t . open Map ( map Name , key Type , value Type ) ; transaction Store . remove Map ( m ) ; t . commit ( ) ; } } } }
public static void write Histogram ( T Double Double Hash Map map , String key Col , String val Col , String file , boolean descending ) throws IO Exception { Buffered Writer writer = new Buffered Writer ( new File Writer ( file ) ) ; writer . write ( key Col ) ; writer . write ( TAB ) ; writer . write ( val Col ) ; writer . new Line ( ) ; double [ ] keys = map . keys ( ) ; Arrays . sort ( keys ) ; if ( descending ) Array Utils . reverse ( keys ) ; for ( double key : keys ) { writer . write ( String . value Of ( key ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( map . get ( key ) ) ) ; writer . new Line ( ) ; } writer . close ( ) ; }
@ Override protected Date Time Data parse ( String str ) throws Schema Date Time Exception { Date Time Data date = new Date Time Data ( str , this ) ; int len = str . length ( ) ; int end = get Date ( str , NUM , len , date ) ; parse Time Zone ( str , end , len , date ) ; validate Date Time ( date ) ; save Unnormalized ( date ) ; if ( date . utc != NUM && date . utc != STRING ) { normalize ( date ) ; } return date ; }
private static void update Platform Server List ( String server URL , String host Name ) throws SMS Exception , SSO Exception { SSO Token token = get Admin SSO Token ( ) ; Service Schema Manager ssm = new Service Schema Manager ( STRING , token ) ; Service Schema ss = ssm . get Global Schema ( ) ; Attribute Schema as = ss . get Attribute Schema ( STRING ) ; Set < String > values = as . get Default Values ( ) ; if ( ! is In Platform List ( values , server URL ) ) { String instance Name = get Next Available Server Id ( values ) ; values . add ( server URL + STRING + instance Name ) ; as . set Default Values ( values ) ; Organization Config Manager ocm = new Organization Config Manager ( token , STRING ) ; Map < String , Object > attrs = ocm . get Attributes ( STRING ) ; Set < String > orig Values = ( Set < String > ) attrs . get ( STRING ) ; if ( ! orig Values . contains ( host Name ) ) { values = new Hash Set < String > ( ) ; values . add ( host Name ) ; ocm . add Attribute Values ( STRING , STRING , values ) ; } } }
public static Segment Infos read Segment Infos ( Index Commit commit ) throws IO Exception { String filename = Index File Names . file Name From Generation ( Index File Names . SEGMENTS , STRING , commit . get Generation ( ) ) ; return Segment Infos . read Commit ( commit . get Directory ( ) , filename ) ; }
public void add Sequence Element ( Sequence Element elem ) { for ( Fragment comment : open Fragments ) { comment . add Element ( elem ) ; } for ( Fragment comment : closing Fragments ) { comment . add Element ( elem ) ; } }
private final void write String Segments ( char [ ] cbuf , int offset , int total Len ) throws IO Exception , Json Generation Exception { do { int len = Math . min ( output Max Contiguous , total Len ) ; if ( ( output Tail + len ) > output End ) { flush Buffer ( ) ; } write String Segment ( cbuf , offset , len ) ; offset += len ; total Len -= len ; } while ( total Len > NUM ) ; }
public static void convert Matsim 2 KS ( String signal Systems Filename , String signal Groups Filename , String signal Control Filename , String network Filename , String lanes Filename , String population Filename , double start Time , double end Time , double signals Bounding Box Offset , double cutting Bounding Box Offset , double free Speed Filter , boolean use Free Speed Travel Time , double maximal Link Length , double matsim Pop Sample Size , double ks Model Commodity Sample Size , double min Commodity Flow , boolean simplify Network , int cells X , int cells Y , String scenario Description , String date Format , String output Directory ) throws Exception { String sp Cost = STRING ; if ( ! use Free Speed Travel Time ) sp Cost = STRING ; output Directory += date Format + STRING + min Commodity Flow + STRING + start Time + STRING + end Time + STRING + free Speed Filter + STRING + sp Cost + STRING + cutting Bounding Box Offset + STRING + signals Bounding Box Offset + STRING ; String ks Model Output Filename = STRING + Double . to String ( min Commodity Flow ) + STRING + Double . to String ( start Time ) + STRING + Double . to String ( cutting Bounding Box Offset ) + STRING ; Output Directory Logging . init Logging With Output Directory ( output Directory ) ; String shape File Directory = create Shape File Directory ( output Directory ) ; Scenario full Scenario = Dg Scenario Utils . load Scenario ( network Filename , population Filename , lanes Filename , signal Systems Filename , signal Groups Filename , signal Control Filename ) ; Net Lanes Signals Shrinker scenario Shrinker = new Net Lanes Signals Shrinker ( full Scenario , CRS ) ; scenario Shrinker . shrink Scenario ( output Directory , shape File Directory , cutting Bounding Box Offset , free Speed Filter , use Free Speed Travel Time , maximal Link Length , simplify Network ) ; Zone Builder zone Builder = new Zone Builder ( CRS ) ; Dg Zones zones = zone Builder . create And Write Zones ( scenario Shrinker . get Shrinked Network ( ) , scenario Shrinker . get Cutting Bounding Box ( ) , cells X , cells Y , shape File Directory ) ; Population To Od pop 2 od = new Population To Od ( ) ; pop 2 od . set Matsim Pop Sample Size ( matsim Pop Sample Size ) ; pop 2 od . set Original To Simplified Link Mapping ( scenario Shrinker . get Original To Simplified Link Id Matching ( ) ) ; pop 2 od . convert Population 2 Od Pairs ( zones , full Scenario . get Network ( ) , full Scenario . get Population ( ) , CRS , scenario Shrinker . get Shrinked Network ( ) , scenario Shrinker . get Cutting Bounding Box ( ) , start Time , end Time , shape File Directory ) ; M2 KS 2010 Converter converter = new M2 KS 2010 Converter ( scenario Shrinker . get Shrinked Network ( ) , scenario Shrinker . get Shrinked Lanes ( ) , scenario Shrinker . get Shrinked Signals ( ) , signals Bounding Box Offset , CRS ) ; String description = create Description ( cells X , cells Y , start Time , end Time , cutting Bounding Box Offset , matsim Pop Sample Size , ks Model Commodity Sample Size , min Commodity Flow ) ; converter . set Ks Model Commodity Sample Size ( ks Model Commodity Sample Size ) ; converter . set Min Commodity Flow ( min Commodity Flow ) ; converter . convert And Write ( output Directory , shape File Directory , ks Model Output Filename , scenario Description , description , zones , start Time , end Time ) ; print Statistics ( cells X , cells Y , cutting Bounding Box Offset , start Time , end Time ) ; log . info ( STRING + output Directory ) ; Output Directory Logging . close Output Dir Logging ( ) ; }
private double calculate Node Times ( Tree Model tree , Node Ref node ) { Node Ref parent = tree . get Parent ( node ) ; double time 0 = NUM ; if ( ! tree . is External ( node ) ) { Node Ref child 1 = tree . get Child ( node , NUM ) ; double t1 = calculate Node Times ( tree , child 1 ) ; Node Ref child 2 = tree . get Child ( node , NUM ) ; double t2 = calculate Node Times ( tree , child 2 ) ; time 0 = ( t1 + t2 ) / NUM ; } if ( parent == null ) return NUM ; double branch Time = tree . get Node Height ( parent ) - tree . get Node Height ( node ) ; double time 1 = time 0 + branch Time ; node Times [ node . get Number ( ) ] = time 0 ; return time 1 ; }
private int [ ] make Reordered Buffer ( int col First , int last Value , int [ ] last Expansion , boolean forward ) { int [ ] result ; int first Value = ordering . get Unicode Order ( col First ) ; if ( first Value >= Rule Based Collator . CONTRACTCHARINDEX ) { first Value = forward ? next Contract Char ( col First ) : prev Contract Char ( col First ) ; } int [ ] first Expansion = null ; if ( first Value >= Rule Based Collator . EXPANDCHARINDEX ) { first Expansion = ordering . get Expand Value List ( first Value ) ; } if ( ! forward ) { int temp 1 = first Value ; first Value = last Value ; last Value = temp 1 ; int [ ] temp 2 = first Expansion ; first Expansion = last Expansion ; last Expansion = temp 2 ; } if ( first Expansion == null && last Expansion == null ) { result = new int [ NUM ] ; result [ NUM ] = first Value ; result [ NUM ] = last Value ; } else { int first Length = first Expansion == null ? NUM : first Expansion . length ; int last Length = last Expansion == null ? NUM : last Expansion . length ; result = new int [ first Length + last Length ] ; if ( first Expansion == null ) { result [ NUM ] = first Value ; } else { System . arraycopy ( first Expansion , NUM , result , NUM , first Length ) ; } if ( last Expansion == null ) { result [ first Length ] = last Value ; } else { System . arraycopy ( last Expansion , NUM , result , first Length , last Length ) ; } } return result ; }
public boolean is Set Status ( ) { return isset bit vector . get ( STATUS ISSET ID ) ; }
public void add Capabilities Listener ( Set < Contact Id > contacts , Capabilities Listener listener ) throws Rcs Service Not Available Exception , Rcs Generic Exception { if ( m Api == null ) { throw new Rcs Service Not Available Exception ( ) ; } if ( contacts == null || contacts . is Empty ( ) ) { throw new Rcs Illegal Argument Exception ( STRING ) ; } try { I Capabilities Listener rcs Listener = new Capabilities Listener Impl ( listener ) ; m Capabilities Listeners . put ( listener , new Weak Reference < > ( rcs Listener ) ) ; for ( Contact Id contact : contacts ) { m Api . add Capabilities Listener 2 ( contact , rcs Listener ) ; } } catch ( Exception e ) { Rcs Illegal Argument Exception . assert Exception ( e ) ; throw new Rcs Generic Exception ( e ) ; } }
public static String trim Word ( final String word ) { String tempword = word . to Lower Case ( ) ; while ( tempword . length ( ) > NUM ) { final char c = tempword . char At ( NUM ) ; if ( c == STRING ) { tempword = tempword . substring ( NUM ) ; } else { break ; } } while ( tempword . length ( ) > NUM ) { final char c = tempword . char At ( tempword . length ( ) - NUM ) ; if ( c == STRING ) { tempword = tempword . substring ( NUM , tempword . length ( ) - NUM ) ; } else { break ; } } return tempword ; }
public static final Index Created Event create Test Index Creation Status ( ) { Index Created Event to Return = new Index Created Event ( UUID . random UUID ( ) , new Date ( ) , new Date ( ) , create Test Index One Field ( ) , NUM , NUM ) ; to Return . calculate Values ( ) ; return to Return ; }
public List < Validation Error Message > validate Value ( String value ) { error Message Ids . clear ( ) ; if ( data Restrictions . is Required ( ) && value Null Or Empty ( value ) ) { error Message Ids . add ( new Validation Error Message ( STRING , id , null ) ) ; } else { if ( ! value Null Or Empty ( value ) ) { for ( Abstract Validation Rule rule : data Restrictions . get Validation Rules ( ) ) { if ( ! rule . validate ( value ) ) { error Message Ids . add ( new Validation Error Message ( rule . get Message Id ( ) , id , rule ) ) ; } } } } return error Message Ids ; }
public void commit ( int task Id ) throws Interrupted Exception , Replicator Exception { Concurrent Linked Queue < Repl DBMS Event > queue = task Queues . get ( task Id ) ; if ( queue . size ( ) == NUM ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + task Id ) ; } return ; } if ( commit Action != null ) commit Action . execute ( task Id ) ; synchronized ( serial Queue ) { while ( queue . peek ( ) != null ) { Repl DBMS Event event = queue . poll ( ) ; boolean ok = serial Queue . offer ( event , commit Timeout , Time Unit . SECONDS ) ; if ( ! ok ) { throw new Replicator Exception ( STRING + task Id + STRING + commit Timeout ) ; } if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + task Id + STRING + event . get Seqno ( ) + STRING + event . get Shard Id ( ) ) ; } } queue . clear ( ) ; commit Count ++ ; } }
public byte [ ] encrypt ( Faces Context faces Context , byte [ ] bytes ) { byte [ ] securedata = null ; try { Secure Random rand = new Secure Random ( ) ; byte [ ] iv = new byte [ NUM ] ; rand . next Bytes ( iv ) ; Iv Parameter Spec ivspec = new Iv Parameter Spec ( iv ) ; Cipher encrypt Cipher = Cipher . get Instance ( CIPHER CODE ) ; Secret Key sec Key = get Secret Key ( faces Context ) ; encrypt Cipher . init ( Cipher . ENCRYPT MODE , sec Key , ivspec ) ; Mac encrypt Mac = Mac . get Instance ( MAC CODE ) ; encrypt Mac . init ( sec Key ) ; encrypt Mac . update ( iv ) ; byte [ ] encdata = encrypt Cipher . do Final ( bytes ) ; byte [ ] mac Bytes = encrypt Mac . do Final ( encdata ) ; byte [ ] tmp = concat Bytes ( mac Bytes , iv ) ; securedata = concat Bytes ( tmp , encdata ) ; } catch ( No Such Algorithm Exception | No Such Padding Exception | Invalid Key Exception | Invalid Algorithm Parameter Exception | Illegal State Exception | Illegal Block Size Exception | Bad Padding Exception e ) { if ( LOGGER . is Loggable ( Level . SEVERE ) ) { LOGGER . log ( Level . SEVERE , STRING + STRING , e ) ; } return null ; } return securedata ; }
void write External ( Data Output out ) throws IO Exception { final int time Secs = ( time End Of Day ? NUM : time . to Second Of Day ( ) ) ; final int std Offset = standard Offset . get Total Seconds ( ) ; final int before Diff = offset Before . get Total Seconds ( ) - std Offset ; final int after Diff = offset After . get Total Seconds ( ) - std Offset ; final int time Byte = ( time Secs % NUM == NUM ? ( time End Of Day ? NUM : time . get Hour ( ) ) : NUM ) ; final int std Offset Byte = ( std Offset % NUM == NUM ? std Offset / NUM + NUM : NUM ) ; final int before Byte = ( before Diff == NUM || before Diff == NUM || before Diff == NUM ? before Diff / NUM : NUM ) ; final int after Byte = ( after Diff == NUM || after Diff == NUM || after Diff == NUM ? after Diff / NUM : NUM ) ; final int dow Byte = ( dow == null ? NUM : dow . get Value ( ) ) ; int b = ( month . get Value ( ) << NUM ) + ( ( dom + NUM ) << NUM ) + ( dow Byte << NUM ) + ( time Byte << NUM ) + ( time Definition . ordinal ( ) << NUM ) + ( std Offset Byte << NUM ) + ( before Byte << NUM ) + after Byte ; out . write Int ( b ) ; if ( time Byte == NUM ) { out . write Int ( time Secs ) ; } if ( std Offset Byte == NUM ) { out . write Int ( std Offset ) ; } if ( before Byte == NUM ) { out . write Int ( offset Before . get Total Seconds ( ) ) ; } if ( after Byte == NUM ) { out . write Int ( offset After . get Total Seconds ( ) ) ; } }
public void draw Bars On Graph ( Graphics 2 D g2 d , Array List < Comparable Label > ordered Date Set , Hash Map < Comparable Label , Integer [ ] > bar Data Points , long y Max Mark ) { int section Width = this . graph Width / ordered Date Set . size ( ) ; int x Offset = section Width / NUM ; int y Value ; float y Offset Perc ; int number Of Bars = bar Data Points . get ( ordered Date Set . get ( NUM ) ) . length ; int bar Width = section Width / ( number Of Bars + NUM ) ; for ( int date Pos = NUM ; date Pos < ordered Date Set . size ( ) ; date Pos ++ ) { for ( int bar Number = NUM ; bar Number < number Of Bars ; bar Number ++ ) { y Value = bar Data Points . get ( ordered Date Set . get ( date Pos ) ) [ bar Number ] ; y Offset Perc = y Value / ( float ) y Max Mark ; int x Left Bar = this . graph Left + date Pos * section Width + bar Width / NUM + bar Width * bar Number ; draw Bar ( g2 d , Math . round ( this . graph Height * y Offset Perc ) , bar Width , x Left Bar , this . graph Bottom , this . bar Colors [ bar Number ] ) ; if ( Math . round ( this . graph Height * y Offset Perc ) == NUM && y Value != NUM ) { g2 d . set Color ( this . bar Colors [ bar Number ] ) ; g2 d . draw Line ( x Left Bar , this . graph Bottom , x Left Bar + bar Width , this . graph Bottom ) ; } } } }
final public void println ( Object v ) { Writer out = this . out ; if ( out == null ) return ; try { if ( v == null ) out . write ( null Chars , NUM , null Chars . length ) ; else { String s = v . to String ( ) ; out . write ( s , NUM , s . length ( ) ) ; } out . write ( newline , NUM , newline . length ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
private URI canonicalize ( String uri String ) throws URI Syntax Exception { if ( ( uri String == null ) || ( uri String . compare To ( STRING ) == NUM ) ) { uri String = STRING ; return new URI ( uri String ) ; } URI u = new URI ( uri String ) ; if ( u . is Absolute ( ) ) { if ( u . is Opaque ( ) ) { String scheme = u . get Scheme ( ) ; String ssp = u . get Scheme Specific Part ( ) ; String frag = u . get Fragment ( ) ; URI u2 = null ; int c1 index = uri String . index Of ( STRING ) ; int c2 index = uri String . last Index Of ( STRING ) ; if ( c2 index != c1 index ) { if ( frag == null ) { u2 = new URI ( scheme + STRING + ssp ) ; } else { u2 = new URI ( scheme + STRING + ssp + STRING + frag ) ; } return u2 ; } u2 = new URI ( STRING + uri String ) ; return u2 ; } else { return u ; } } else { String ssp = u . get Scheme Specific Part ( ) ; if ( ssp . starts With ( STRING ) ) { return u ; } else { return new URI ( STRING + uri String ) ; } } }
@ Override public void draw ( Graphics 2 D g2 , Dial Plot plot , Rectangle 2 D frame , Rectangle 2 D view ) { g2 . set Paint ( this . fill Paint ) ; Rectangle 2 D f = Dial Plot . rectangle By Radius ( frame , this . radius , this . radius ) ; Ellipse 2 D e = new Ellipse 2 D . Double ( f . get X ( ) , f . get Y ( ) , f . get Width ( ) , f . get Height ( ) ) ; g2 . fill ( e ) ; g2 . set Paint ( this . outline Paint ) ; g2 . set Stroke ( this . outline Stroke ) ; g2 . draw ( e ) ; }
public void process Connection ( Data Input Stream dis , Data Output Stream dos Param ) throws IO Exception , Exception { GZIP Output Stream gzip = new GZIP Output Stream ( new Buffered Output Stream ( dos Param ) ) ; Data Output Stream dos = new Data Output Stream ( gzip ) ; byte response Status = Response Status . STATUS ERROR ; try { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; String name = dis . read UTF ( ) ; String pw = dis . read UTF ( ) ; String serializer = dis . read UTF ( ) ; @ Suppress Warnings ( STRING ) String locale = dis . read UTF ( ) ; byte action = dis . read Byte ( ) ; Context . open Session ( ) ; try { Context . authenticate ( name , pw ) ; } catch ( Context Authentication Exception ex ) { response Status = Response Status . STATUS ACCESS DENIED ; } if ( response Status != Response Status . STATUS ACCESS DENIED ) { Data Output Stream dos Temp = new Data Output Stream ( baos ) ; if ( action == ACTION DOWNLOAD PATIENTS ) download Patients ( String . value Of ( dis . read Int ( ) ) , dos Temp , serializer , BOOL ) ; else if ( action == ACTION DOWNLOAD SS PATIENTS ) download Patients ( String . value Of ( dis . read Int ( ) ) , dos Temp , serializer , BOOL ) ; else if ( action == ACTION DOWNLOAD COHORTS ) Patient Download Manager . download Cohorts ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD SAVED SEARCHES ) Patient Download Manager . download Saves Searches ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD FORMS ) Xform Download Manager . download Xforms ( dos Temp , serializer ) ; else if ( action == ACTION UPLOAD FORMS ) submit Xforms ( dis , dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD USERS ) User Download Manager . download Users ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD USERS AND FORMS ) download Users And Forms ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD FILTERED PATIENTS ) download Patients ( dis . read UTF ( ) , dis . read UTF ( ) , dos Temp , serializer ) ; response Status = Response Status . STATUS SUCCESS ; } dos . write Byte ( response Status ) ; if ( response Status == Response Status . STATUS SUCCESS ) dos . write ( baos . to Byte Array ( ) ) ; dos . close ( ) ; gzip . finish ( ) ; } catch ( Exception ex ) { log . error ( ex . get Message ( ) , ex ) ; try { dos . write Byte ( response Status ) ; dos . flush ( ) ; gzip . finish ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } finally { Context . close Session ( ) ; } }
public void add Import ( @ Not Null Psi Element importable , @ Not Null Psi File System Item file , @ Nullable Qualified Name path ) { my Imports . add ( new Import Candidate Holder ( importable , file , null , path ) ) ; }
private void draw Overflow Indicator ( final Workflow Annotation anno , final Graphics 2 D g , final Rectangle 2 D loc , final boolean printing ) { if ( printing ) { return ; } Graphics 2 D g2 = ( Graphics 2 D ) g . create ( ) ; int size = NUM ; int x Offset = NUM ; int y Offset = NUM ; int step Size = size / NUM ; int dot Size = NUM ; int x = ( int ) loc . get Max X ( ) - size - x Offset ; int y = ( int ) loc . get Max Y ( ) - size - y Offset ; Gradient Paint gp = new Gradient Paint ( x , y , Color . WHITE , x , y + size * NUM , Color . LIGHT GRAY ) ; g2 . set Paint ( gp ) ; g2 . fill Rect ( x , y , size , size ) ; g2 . set Color ( Color . BLACK ) ; g2 . draw Rect ( x , y , size , size ) ; g2 . fill Oval ( x + step Size , y + step Size * NUM , dot Size , dot Size ) ; g2 . fill Oval ( x + step Size * NUM , y + step Size * NUM , dot Size , dot Size ) ; g2 . fill Oval ( x + step Size * NUM , y + step Size * NUM , dot Size , dot Size ) ; g2 . dispose ( ) ; }
public Weak Loader Listener ( Env Loader Listener listener ) { listener Ref = new Weak Reference < > ( listener ) ; }
private Object [ ] unmarshal Parameters Unchecked ( Method method , Object Input in ) throws IO Exception , Class Not Found Exception { Class < ? > [ ] types = method . get Parameter Types ( ) ; Object [ ] params = new Object [ types . length ] ; for ( int i = NUM ; i < types . length ; i ++ ) { params [ i ] = unmarshal Value ( types [ i ] , in ) ; } return params ; }
private void load Data From Service ( ) { List < Invocation Sequence Data > invoc Data ; if ( ! auto Update ) { if ( template . get Method Ident ( ) != Id Definition . ID NOT USED ) { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , template . get Method Ident ( ) , limit , from Date , to Date , result Comparator ) ; } else { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , limit , from Date , to Date , result Comparator ) ; } } else { if ( template . get Method Ident ( ) != Id Definition . ID NOT USED ) { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , template . get Method Ident ( ) , limit , result Comparator ) ; } else { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , limit , result Comparator ) ; } } invocation Sequence Data . clear ( ) ; if ( ! invoc Data . is Empty ( ) ) { invocation Sequence Data . add All ( invoc Data ) ; } }
void draw Letter ( Graphics g , char letter , int ax , int ay , int aw , int ah , float align , int index ) { String str = format Item Num ( index , letter ) ; str = is Left To Right ? str + STRING : STRING + str ; Font Metrics fm = Swing Utilities 2 . get Font Metrics ( null , g ) ; int stringwidth = Swing Utilities 2 . string Width ( null , fm , str ) ; int gap = is Left To Right ? - ( stringwidth + bulletgap ) : ( aw + bulletgap ) ; int x = ax + gap ; int y = Math . max ( ay + fm . get Ascent ( ) , ay + ( int ) ( ah * align ) ) ; Swing Utilities 2 . draw String ( null , g , str , x , y ) ; }
public int sync ( String entity Id , Collection < Statement > statements , Collection < String > value List ) { long start = System . current Time Millis ( ) ; int modified = execute ( STRING , UPDATE COUNT RESPONSE , get Sync Query ( entity Id , statements , value List ) ) ; log . debug ( STRING , entity Id , System . current Time Millis ( ) - start , modified ) ; return modified ; }
public static Properties read Properties ( Class clazz ) { return read Properties ( clazz . get Name ( ) ) ; }
public static Buffered Image resize Image ( Image image ) { Buffered Image result = new Buffered Image ( NUM , NUM , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D graphics = result . create Graphics ( ) ; graphics . draw Image ( image , NUM , NUM , NUM , NUM , null ) ; graphics . dispose ( ) ; return result ; }
public final boolean is Cancelled ( ) { return cancelled ; }
public void add ( Directed Edge de ) { out Edges . add ( de ) ; sorted = BOOL ; }
@ Override protected void on Message On Producer Thread ( T msg ) { synchronized ( lock ) { if ( pending == null ) { pending = new Array List < > ( ) ; queue . schedule ( flush Runnable , interval , time Unit ) ; } pending . add ( msg ) ; } }
public Date ( String date , String date Format ) { if ( ( date == null ) || ( date . length ( ) == NUM ) ) { return ; } if ( date Format == null ) { m format = DATE TIME FORMAT ; if ( date . length ( ) == LEN STRING IN DATE FORMAT ) { m format = DATE FORMAT ; } } else { m format = date Format ; } if ( ( m format . equals ( DATE TIME FORMAT ) && ! right Length For Date Time ( date ) ) || ( m format . equals ( DATE FORMAT ) && ( date . length ( ) != LEN STRING IN DATE FORMAT ) ) ) { m invalid Date = date ; } else { m date = Trading Calendar . get Zoned Date Time From Date Time String ( date . trim ( ) , m format ) ; m invalid Date = null ; } }
private boolean is In Thumb Range ( float touch X , double normalized Thumb Value ) { return Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) <= thumb Half Width ; }
public boolean cleanup ( ) throws IO Exception { File System file System = File System . get ( config ) ; boolean success = BOOL ; for ( Path file : files ) { success &= file System . delete ( file , BOOL ) ; } return success ; }
private boolean can Be Placed At Position ( final boolean requires All Bound , final Group Node Var Binding Info binding Info , final Hash Set < I Variable < ? > > known Bound , final Map < I Variable < ? > , Integer > remaining Maybe Bound , int i ) { final Set < I Variable < ? > > left To Be Bound = binding Info . left To Be Bound ( known Bound ) ; if ( left To Be Bound . is Empty ( ) ) { return BOOL ; } if ( ! requires All Bound ) { boolean more Can Be Bound = BOOL ; final Set < I Variable < ? > > can Be Bound = remaining Maybe Bound . key Set ( ) ; for ( I Variable < ? > left To Be Bound Var : left To Be Bound ) { more Can Be Bound |= can Be Bound . contains ( left To Be Bound Var ) ; if ( more Can Be Bound ) { break ; } } if ( ! more Can Be Bound ) { return BOOL ; } } return BOOL ; }
private void enqueue Next Task ( String queue Name , Dispatcher Task dispatcher Task ) { synchronized ( sync Root ) { Queue < Dispatcher Task > queue = task Queues Map . get ( queue Name ) ; if ( queue == null ) { queue = new Linked List < > ( ) ; task Queues Map . put ( queue Name , queue ) ; } queue . add ( dispatcher Task ) ; } }
public void dump ( Writer writer ) { Decimal Format number Format = new Decimal Format ( ) ; number Format . set Maximum Fraction Digits ( NUM ) ; number Format . set Minimum Fraction Digits ( NUM ) ; Print Writer pw = new Print Writer ( new Buffered Writer ( writer ) ) ; if ( get Number Of Frames ( ) == NUM ) { pw . println ( STRING ) ; pw . println ( STRING + get Number Of Frames ( ) ) ; pw . flush ( ) ; return ; } pw . println ( STRING ) ; pw . println ( STRING + get Number Of Frames ( ) ) ; pw . println ( STRING + get Number Of Channels ( ) ) ; pw . println ( STRING + get Number Of Samples ( ) ) ; pw . println ( STRING + sample Rate ) ; pw . println ( STRING + number Format . format ( lpc Minimum ) ) ; pw . println ( STRING + number Format . format ( lpc Range ) ) ; pw . println ( STRING + residual Fold ) ; pw . println ( STRING + number Format . format ( POST EMPHASIS ) ) ; int i ; pw . print ( STRING ) ; for ( i = NUM ; i < get Number Of Frames ( ) ; i ++ ) { pw . print ( times [ i ] + STRING ) ; } pw . print ( STRING ) ; for ( i = NUM ; i < get Number Of Frames ( ) ; i ++ ) { short [ ] frame = get Frame ( i ) ; for ( int j = NUM ; j < frame . length ; j ++ ) { pw . print ( ( ( ( int ) frame [ j ] ) + NUM ) + STRING ) ; } } pw . print ( STRING ) ; for ( i = NUM ; i < get Number Of Frames ( ) ; i ++ ) { pw . print ( sizes [ i ] + STRING ) ; } pw . print ( STRING ) ; for ( i = NUM ; i < get Number Of Samples ( ) ; i ++ ) { if ( residuals [ i ] == NUM ) { pw . print ( NUM ) ; } else { pw . print ( ( ( ( int ) residuals [ i ] ) + NUM ) ) ; } pw . print ( STRING ) ; pw . flush ( ) ; } pw . flush ( ) ; }
private void create Field ( Result Set rs ) { Grid Field VO vo F = Grid Field VO . create Parameter ( Env . get Ctx ( ) , m Window No , rs ) ; Grid Field m Field = new Grid Field ( vo F ) ; m m Fields . add ( m Field ) ; gbc . gridy = m line ++ ; gbc . gridwidth = NUM ; gbc . fill = Grid Bag Constraints . HORIZONTAL ; gbc . gridx = NUM ; gbc . weightx = NUM ; J Label label = V Editor Factory . get Label ( m Field ) ; if ( label == null ) { gbc . insets = null Inset ; center Panel . add ( Box . create Horizontal Strut ( NUM ) , gbc ) ; } else { gbc . insets = label Inset ; center Panel . add ( label , gbc ) ; } gbc . insets = field Inset ; gbc . fill = Grid Bag Constraints . HORIZONTAL ; gbc . gridwidth = NUM ; gbc . gridx = NUM ; gbc . weightx = NUM ; V Editor v Editor = V Editor Factory . get Editor ( m Field , BOOL ) ; v Editor . add Vetoable Change Listener ( this ) ; m Field . add Property Change Listener ( v Editor ) ; Object default Object = m Field . get Default ( ) ; m Field . set Value ( default Object , BOOL ) ; center Panel . add ( ( Component ) v Editor , gbc ) ; m v Editors . add ( v Editor ) ; if ( vo F . is Range ) { gbc . gridx = NUM ; gbc . weightx = NUM ; gbc . fill = Grid Bag Constraints . NONE ; center Panel . add ( new J Label ( STRING ) , gbc ) ; gbc . gridx = NUM ; gbc . insets = field Inset Right ; gbc . weightx = NUM ; gbc . fill = Grid Bag Constraints . HORIZONTAL ; gbc . anchor = Grid Bag Constraints . WEST ; Grid Field VO vo F 2 = Grid Field VO . create Parameter ( vo F ) ; Grid Field m Field 2 = new Grid Field ( vo F 2 ) ; m m Fields 2 . add ( m Field 2 ) ; V Editor v Editor 2 = V Editor Factory . get Editor ( m Field 2 , BOOL ) ; m Field 2 . add Property Change Listener ( v Editor 2 ) ; Object default Object 2 = m Field 2 . get Default ( ) ; m Field 2 . set Value ( default Object 2 , BOOL ) ; center Panel . add ( ( Component ) v Editor 2 , gbc ) ; m v Editors 2 . add ( v Editor 2 ) ; } else { m m Fields 2 . add ( null ) ; m v Editors 2 . add ( null ) ; } }
private void remove incomplete expansion room ( Expand Room Freespace Incomplete p room ) { if ( p room == null ) return ; remove all doors ( p room ) ; incomplete expansion rooms . remove ( p room ) ; }
static double compute Desired Ellipsoid Magnitude ( final Planet Model planet Model , final double z ) { return NUM / Math . sqrt ( ( NUM - z * z ) * planet Model . inverse Ab Squared + z * z * planet Model . inverse C Squared ) ; }
private void validate Vcenter Credentials ( Vcenter Param param , Vcenter vcenter ) { if ( String Utils . is Blank ( param . get Password ( ) ) && vcenter != null ) { param . set Password ( String Utils . trim To Null ( vcenter . get Password ( ) ) ) ; } if ( String Utils . is Blank ( param . get User Name ( ) ) && vcenter != null ) { param . set User Name ( String Utils . trim To Null ( vcenter . get Username ( ) ) ) ; } Arg Validator . check Field Not Null ( param . get User Name ( ) , STRING ) ; Arg Validator . check Field Not Null ( param . get Password ( ) , STRING ) ; }
public void create Accrual Based Journal Entries And Reversals For Loan ( final Office office , final String currency Code , final Integer account Type To Be Debited , final Integer account Type To Be Credited , final Long loan Product Id , final Long payment Type Id , final Long loan Id , final String transaction Id , final Date transaction Date , final Big Decimal amount , final Boolean is Reversal ) { int account Type To Debit Id = account Type To Be Debited ; int account Type To Credit Id = account Type To Be Credited ; if ( is Reversal ) { account Type To Debit Id = account Type To Be Credited ; account Type To Credit Id = account Type To Be Debited ; } create Journal Entries For Loan ( office , currency Code , account Type To Debit Id , account Type To Credit Id , loan Product Id , payment Type Id , loan Id , transaction Id , transaction Date , amount ) ; }
private Pla Line Int smoothen corner ( Pla Line Int Alist p line arr , int p start no ) { if ( p line arr . size ( ) - p start no < NUM ) return null ; Pla Line Int cur line = p line arr . get ( p start no ) ; Pla Line Int a line = p line arr . get ( p start no + NUM ) ; Pla Line Int b line = p line arr . get ( p start no + NUM ) ; Pla Line Int d line = p line arr . get ( p start no + NUM ) ; Pla Point Float curr corner = a line . intersection approx ( b line ) ; if ( curr corner . is Na N ( ) ) return null ; double cosinus angle = a line . cos angle ( b line ) ; if ( cosinus angle > COS ANGLE MAX ) return null ; Pla Point Float prev corner = cur line . intersection approx ( a line ) ; if ( prev corner . is Na N ( ) ) return null ; Pla Point Float next corner = b line . intersection approx ( d line ) ; if ( next corner . is Na N ( ) ) return null ; Pla Direction prev dir = a line . direction ( ) ; Pla Direction next dir = b line . direction ( ) ; Pla Direction middle dir = prev dir . middle approx ( next dir ) ; Pla Line Int translate line = new Pla Line Int ( curr corner . round ( ) , middle dir ) ; double prev dist = translate line . distance signed ( prev corner ) ; double next dist = translate line . distance signed ( next corner ) ; Pla Point Float nearest point ; double max translate dist ; if ( Math . abs ( prev dist ) < Math . abs ( next dist ) ) { nearest point = prev corner ; max translate dist = prev dist ; } else { nearest point = next corner ; max translate dist = next dist ; } if ( Math . abs ( max translate dist ) < NUM ) return null ; Pla Line Int Alist curr lines = new Pla Line Int Alist ( p line arr . size ( NUM ) ) ; p line arr . append to ( curr lines , NUM ) ; curr lines . add null ( p start no + NUM ) ; double translate dist = max translate dist ; double delta dist = max translate dist ; Pla Side side of nearest point = translate line . side of ( nearest point ) ; int sign = Signum . as int ( max translate dist ) ; Pla Line Int result = null ; while ( Math . abs ( delta dist ) > min move dist ) { boolean check ok = BOOL ; Pla Line Int new line = translate line . translate ( - translate dist ) ; Pla Side new line side of nearest point = new line . side of ( nearest point ) ; if ( new line side of nearest point == side of nearest point || new line side of nearest point == Pla Side . COLLINEAR ) { curr lines . set ( p start no + NUM , new line ) ; Polyline tmp = new Polyline ( curr lines ) ; if ( tmp . plaline len ( ) == curr lines . size ( ) ) { Shape Tile shape to check = tmp . offset shape ( curr half width , p start no + NUM ) ; check ok = r board . check trace ( shape to check , curr layer , curr net no arr , curr cl type , contact pins ) ; } delta dist /= NUM ; if ( check ok ) { result = new line ; if ( translate dist == max translate dist ) { break ; } translate dist += delta dist ; } else { translate dist -= delta dist ; } } else { double shorten value = sign * NUM ; max translate dist -= shorten value ; translate dist -= shorten value ; delta dist -= shorten value ; } } if ( result == null ) return null ; curr lines . changed area join corner ( r board . changed area , p start no , curr layer ) ; curr lines . changed area join corner ( r board . changed area , p start no + NUM , curr layer ) ; return result ; }
public Sensor create New Sensor ( String system Name , String user Name ) { Sensor s ; String s Name = Serial Address . normalize System Name ( system Name ) ; if ( s Name . equals ( STRING ) ) { log . error ( STRING + system Name ) ; return null ; } s = get By System Name ( s Name ) ; if ( s != null ) { log . error ( STRING + system Name ) ; return null ; } String alt Name = Serial Address . convert System Name To Alternate ( s Name ) ; s = get By System Name ( alt Name ) ; if ( s != null ) { log . error ( STRING + system Name + STRING + alt Name + STRING ) ; return null ; } int bit = Serial Address . get Bit From System Name ( s Name ) ; if ( ( bit <= NUM ) || ( bit >= SENSORSPERNODE ) ) { log . error ( STRING + Integer . to String ( bit ) + STRING + Integer . to String ( SENSORSPERNODE - NUM ) ) ; return null ; } if ( user Name == null ) { s = new Serial Sensor ( s Name ) ; } else { s = new Serial Sensor ( s Name , user Name ) ; } Serial Node node = Serial Address . get Node From System Name ( s Name ) ; if ( node == null ) { log . warn ( STRING + s Name + STRING ) ; return s ; } node . register Sensor ( s , bit - NUM ) ; return s ; }
public void post Process Distances ( double distances [ ] ) { for ( int i = NUM ; i < distances . length ; i ++ ) { distances [ i ] = Math . sqrt ( distances [ i ] ) ; } }
public void fill area ( Pla Point Float [ ] [ ] p point lists , Graphics p g , Color p color , double p translucency factor ) { if ( p color == null ) return ; General Path draw path = new General Path ( General Path . WIND EVEN ODD ) ; for ( int jndex = NUM ; jndex < p point lists . length ; ++ jndex ) { Polygon draw polygon = new Polygon ( ) ; Pla Point Float [ ] curr point list = p point lists [ jndex ] ; for ( int index = NUM ; index < curr point list . length ; index ++ ) { Point 2 D curr corner = coordinate transform . board to screen ( curr point list [ index ] ) ; draw polygon . add Point ( ( int ) Math . round ( curr corner . get X ( ) ) , ( int ) Math . round ( curr corner . get Y ( ) ) ) ; } draw path . append ( draw polygon , BOOL ) ; } Graphics 2 D g2 = ( Graphics 2 D ) p g ; g2 . set Color ( p color ) ; set translucency ( g2 , p translucency factor ) ; g2 . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g2 . fill ( draw path ) ; }
public void move To Previous Date ( ) { if ( disable Auto Date Selection && user Selected Item == null ) return ; if ( selected Date Item != null ) { Calendar cal = Calendar . get Instance ( ) ; cal . set ( selected Date Item . get Year ( ) , selected Date Item . get Month ( ) , selected Date Item . get Day ( ) ) ; cal . add ( Calendar . DATE , - NUM ) ; if ( selected Date Item . get Month ( ) != cal . get ( Calendar . MONTH ) ) { selected Date Item . set Day ( cal . get ( Calendar . DAY OF MONTH ) ) ; selected Date Item . set Month ( cal . get ( Calendar . MONTH ) ) ; selected Date Item . set Year ( cal . get ( Calendar . YEAR ) ) ; should Override Computed Date = BOOL ; move To Previous Month ( ) ; } else { selected Date Item . set Day ( cal . get ( Calendar . DAY OF MONTH ) ) ; selected Date Item . set Month ( cal . get ( Calendar . MONTH ) ) ; selected Date Item . set Year ( cal . get ( Calendar . YEAR ) ) ; month View Pager Adapter . set Selected Item ( selected Date Item ) ; } } }
public static boolean is Valid Template ( String template ) { template = template . trim ( ) ; if ( template . index Of ( STRING ) == - NUM ) { return BOOL ; } String s = template . trim ( ) ; if ( s . last Index Of ( STRING ) != s . length ( ) - NUM ) { return BOOL ; } if ( get Method Signature ( template ) == null ) { return BOOL ; } if ( get Method Body ( template ) == null ) { return BOOL ; } return BOOL ; }
public synchronized boolean send Reply For One Result ( DM dm , Partitioned Region pr , long start Time , Object one Result , boolean last Result , boolean send Results In Order ) throws Cache Exception , Force Reattempt Exception , Interrupted Exception { if ( this . reply Last Msg ) { return BOOL ; } if ( Thread . interrupted ( ) ) throw new Interrupted Exception ( ) ; int msg Num = this . reply Msg Num ; this . reply Last Msg = last Result ; send Reply ( get Sender ( ) , this . processor Id , dm , null , one Result , pr , start Time , msg Num , last Result , send Results In Order ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING ) ; } this . reply Msg Num ++ ; return BOOL ; }
private int inv Wm Transform ( double alpha , double f1 , double f2 , double f3 ) { double s = alpha * Math . abs ( f3 - f1 ) / NUM ; double l = f1 ; int x = NUM ; while ( l < f2 ) { l += s ; x ++ ; } if ( Math . abs ( l - s - f2 ) < Math . abs ( l - f2 ) ) { return ( x + NUM ) % NUM ; } else { return x % NUM ; } }
@ Override public State Connection service ( ) { try { State Connection next State = state . service ( this ) ; return next State ; } catch ( Throwable e ) { log . warning ( e . to String ( ) ) ; log . log ( Level . FINER , e . to String ( ) , e ) ; to Close ( ) ; return State Connection . CLOSE READ A ; } }
int terminal ( int [ ] flags ) throws RE Syntax Exception { switch ( pattern . char At ( idx ) ) { case RE . OP EOL : case RE . OP BOL : case RE . OP ANY : return node ( pattern . char At ( idx ++ ) , NUM ) ; case STRING : return character Class ( ) ; case STRING : return expr ( flags ) ; case STRING : syntax Error ( STRING ) ; case STRING : internal Error ( ) ; case STRING : syntax Error ( STRING ) ; case NUM : syntax Error ( STRING ) ; case STRING : case STRING : case STRING : case STRING : syntax Error ( STRING ) ; case STRING : { int idx Before Escape = idx ; switch ( escape ( ) ) { case ESC CLASS : case ESC COMPLEX : flags [ NUM ] &= ~ NODE NULLABLE ; return node ( RE . OP ESCAPE , pattern . char At ( idx - NUM ) ) ; case ESC BACKREF : { char backreference = ( char ) ( pattern . char At ( idx - NUM ) - STRING ) ; if ( parens <= backreference ) { syntax Error ( STRING ) ; } flags [ NUM ] |= NODE NULLABLE ; return node ( RE . OP BACKREF , backreference ) ; } default : idx = idx Before Escape ; flags [ NUM ] &= ~ NODE NULLABLE ; break ; } } } flags [ NUM ] &= ~ NODE NULLABLE ; return atom ( ) ; }
@ Override public void draw Item ( Graphics 2 D g2 , Category Item Renderer State state , Rectangle 2 D data Area , Category Plot plot , Category Axis domain Axis , Value Axis range Axis , Category Dataset dataset , int row , int column , int pass ) { int visible Row = state . get Visible Series Index ( row ) ; if ( visible Row < NUM ) { return ; } Number data Value = dataset . get Value ( row , column ) ; if ( data Value == null ) { return ; } double value = data Value . double Value ( ) ; Rectangle 2 D adjusted = new Rectangle 2 D . Double ( data Area . get X ( ) , data Area . get Y ( ) + get Y Offset ( ) , data Area . get Width ( ) - get X Offset ( ) , data Area . get Height ( ) - get Y Offset ( ) ) ; Plot Orientation orientation = plot . get Orientation ( ) ; double bar W 0 = calculate Bar W 0 ( plot , orientation , adjusted , domain Axis , state , visible Row , column ) ; double [ ] bar L 0 L 1 = calculate Bar L 0 L 1 ( value ) ; if ( bar L 0 L 1 == null ) { return ; } Rectangle Edge edge = plot . get Range Axis Edge ( ) ; double trans L 0 = range Axis . value To Java 2 D ( bar L 0 L 1 [ NUM ] , adjusted , edge ) ; double trans L 1 = range Axis . value To Java 2 D ( bar L 0 L 1 [ NUM ] , adjusted , edge ) ; double bar L 0 = Math . min ( trans L 0 , trans L 1 ) ; double bar Length = Math . abs ( trans L 1 - trans L 0 ) ; Rectangle 2 D bar ; if ( orientation . is Horizontal ( ) ) { bar = new Rectangle 2 D . Double ( bar L 0 , bar W 0 , bar Length , state . get Bar Width ( ) ) ; } else { bar = new Rectangle 2 D . Double ( bar W 0 , bar L 0 , state . get Bar Width ( ) , bar Length ) ; } if ( state . get Element Hinting ( ) ) { begin Element Group ( g2 , dataset . get Row Key ( row ) , dataset . get Column Key ( column ) ) ; } Paint item Paint = get Item Paint ( row , column ) ; g2 . set Paint ( item Paint ) ; g2 . fill ( bar ) ; double x0 = bar . get Min X ( ) ; double x1 = x0 + get X Offset ( ) ; double x2 = bar . get Max X ( ) ; double x3 = x2 + get X Offset ( ) ; double y0 = bar . get Min Y ( ) - get Y Offset ( ) ; double y1 = bar . get Min Y ( ) ; double y2 = bar . get Max Y ( ) - get Y Offset ( ) ; double y3 = bar . get Max Y ( ) ; General Path bar 3 d Right = null ; General Path bar 3 d Top ; if ( bar Length > NUM ) { bar 3 d Right = new General Path ( ) ; bar 3 d Right . move To ( ( float ) x2 , ( float ) y3 ) ; bar 3 d Right . line To ( ( float ) x2 , ( float ) y1 ) ; bar 3 d Right . line To ( ( float ) x3 , ( float ) y0 ) ; bar 3 d Right . line To ( ( float ) x3 , ( float ) y2 ) ; bar 3 d Right . close Path ( ) ; g2 . set Paint ( Paint Alpha . darker ( item Paint ) ) ; g2 . fill ( bar 3 d Right ) ; } bar 3 d Top = new General Path ( ) ; bar 3 d Top . move To ( ( float ) x0 , ( float ) y1 ) ; bar 3 d Top . line To ( ( float ) x1 , ( float ) y0 ) ; bar 3 d Top . line To ( ( float ) x3 , ( float ) y0 ) ; bar 3 d Top . line To ( ( float ) x2 , ( float ) y1 ) ; bar 3 d Top . close Path ( ) ; g2 . fill ( bar 3 d Top ) ; if ( is Draw Bar Outline ( ) && state . get Bar Width ( ) > BAR OUTLINE WIDTH THRESHOLD ) { g2 . set Stroke ( get Item Outline Stroke ( row , column ) ) ; g2 . set Paint ( get Item Outline Paint ( row , column ) ) ; g2 . draw ( bar ) ; if ( bar 3 d Right != null ) { g2 . draw ( bar 3 d Right ) ; } g2 . draw ( bar 3 d Top ) ; } if ( state . get Element Hinting ( ) ) { end Element Group ( g2 ) ; } Category Item Label Generator generator = get Item Label Generator ( row , column ) ; if ( generator != null && is Item Label Visible ( row , column ) ) { draw Item Label ( g2 , dataset , row , column , plot , generator , bar , ( value < NUM ) ) ; } Entity Collection entities = state . get Entity Collection ( ) ; if ( entities != null ) { General Path bar Outline = new General Path ( ) ; bar Outline . move To ( ( float ) x0 , ( float ) y3 ) ; bar Outline . line To ( ( float ) x0 , ( float ) y1 ) ; bar Outline . line To ( ( float ) x1 , ( float ) y0 ) ; bar Outline . line To ( ( float ) x3 , ( float ) y0 ) ; bar Outline . line To ( ( float ) x3 , ( float ) y2 ) ; bar Outline . line To ( ( float ) x2 , ( float ) y3 ) ; bar Outline . close Path ( ) ; add Item Entity ( entities , dataset , row , column , bar Outline ) ; } }
public Map < I Cloud . MBS File , Outcome > write ( Byte String signature , IO Function < Output Stream , Long > writer ) throws IO Exception , Interrupted Exception { logger . trace ( STRING , Bytes . hex ( signature ) ) ; lock . lock Interruptibly ( ) ; try { Map < I Cloud . MBS File , Outcome > outcomes = new Hash Map < > ( ) ; Set < I Cloud . MBS File > files = signature To File Set . remove ( signature ) ; if ( files == null ) { logger . warn ( STRING , Bytes . hex ( signature ) ) ; } else { for ( I Cloud . MBS File file : files ) { outcomes . put ( file , cloud Writer . write ( file , writer ) ) ; out Bytes . add And Get ( file . get Size ( ) ) ; } logger . debug ( STRING , out Bytes , failed Bytes , total Bytes ) ; } logger . trace ( STRING ) ; return outcomes ; } finally { lock . unlock ( ) ; } }
public static boolean is Network Connected ( Context context ) { if ( context == null ) { return BOOL ; } Connectivity Manager cm = ( Connectivity Manager ) context . get System Service ( Context . CONNECTIVITY SERVICE ) ; Network Info network Info = cm . get Active Network Info ( ) ; return ( network Info != null && network Info . is Connected ( ) ) ; }
public void put ( String name , String supported , String key , String value , String level ) { IDFF Auth Context c = new IDFF Auth Context ( ) ; c . name = name ; c . supported = supported ; c . key = key ; c . value = value ; c . level = level ; collections . put ( name , c ) ; }
public final void close ( Gs Server Packet close Packet , boolean forced ) { synchronized ( guard ) { if ( is Write Disabled ( ) ) { return ; } pending Close = BOOL ; is Forced Closing = forced ; send Msg Queue . clear ( ) ; send Msg Queue . add Last ( close Packet ) ; enable Write Interest ( ) ; } }
private List build Edge Rings ( Collection dir Edges ) { List edge Rings = new Array List ( ) ; for ( Iterator it = dir Edges . iterator ( ) ; it . has Next ( ) ; ) { Directed Edge de = ( Directed Edge ) it . next ( ) ; if ( de . is In Result ( ) && de . get Edge Ring ( ) == null ) { Maximal Edge Ring er = new Maximal Edge Ring ( de , geometry Factory ) ; er . link Directed Edges For Minimal Edge Rings ( ) ; List min Edge Rings = er . build Minimal Rings ( ) ; edge Rings . add All ( min Edge Rings ) ; } } return edge Rings ; }
public static void use Internal Frames ( J Root Pane root Pane ) { if ( root Pane != null ) { use Internal Frames ( root Pane . get Layered Pane ( ) ) ; } else { use Internal Frames ( ( J Layered Pane ) null ) ; } }
public void write Int ( int value ) throws IO Exception { check Write Primitive Types ( ) ; primitive Types . write Int ( value ) ; }
public static void register Container M Bean ( String container Name , IJ Space Container container ) { M Bean Server m Bean Server = get M Bean Server ( container Name ) ; if ( m Bean Server == null ) return ; if ( m M Beans Repository . contains Key ( container Name ) ) return ; try { JMX Space Container mbean = new JMX Space Container ( container , CONTAINER MBEAN DESCR URL ) ; Object Name obj Name = Object Name Factory . build Object Name ( DEFAULT DOMAIN , mbean . get Type ( ) , container Name ) ; m M Beans Repository . put ( container Name , m Bean Server . register M Bean ( mbean , obj Name ) ) ; } catch ( Instance Already Exists Exception e ) { if ( logger . is Loggable ( Level . CONFIG ) ) { logger . config ( STRING + container Name + STRING ) ; } } catch ( Exception ex ) { if ( logger . is Loggable ( Level . WARNING ) ) { logger . log ( Level . WARNING , STRING + container Name + STRING , ex ) ; } } if ( logger . is Loggable ( Level . CONFIG ) ) { logger . config ( STRING + container Name + STRING ) ; } }
public static List < Module Spec > expand Spec Wildcards ( List < File > dirs , List < Module Spec > modules , Backend for Backend ) { List < Module Spec > result = new Array List < Module Spec > ( modules . size ( ) ) ; for ( Module Spec spec : modules ) { List < String > names = new Array List < String > ( ) ; expand Wildcard ( names , dirs , spec . get Name ( ) , for Backend ) ; for ( String name : names ) { result . add ( new Module Spec ( name , spec . get Version ( ) ) ) ; } } return result ; }
public Charset charset ( ) { return charset != null ? Charset . for Name ( charset ) : null ; }
public NS Number ( String text ) { if ( text == null ) throw new Illegal Argument Exception ( STRING ) ; try { long l ; if ( text . starts With ( STRING ) ) { l = Long . parse Long ( text . substring ( NUM ) , NUM ) ; } else { l = Long . parse Long ( text ) ; } double Value = long Value = l ; type = INTEGER ; } catch ( Exception ex ) { try { double Value = Double . parse Double ( text ) ; long Value = Math . round ( double Value ) ; type = REAL ; } catch ( Exception ex 2 ) { try { bool Value = text . equals Ignore Case ( STRING ) || text . equals Ignore Case ( STRING ) ; if ( ! bool Value && ! ( text . equals Ignore Case ( STRING ) || text . equals Ignore Case ( STRING ) ) ) { throw new Exception ( STRING ) ; } type = BOOLEAN ; double Value = long Value = bool Value ? NUM : NUM ; } catch ( Exception ex 3 ) { throw new Illegal Argument Exception ( STRING ) ; } } } }
public static Throwable sanitize ( Throwable t ) { if ( ! Boolean . get Boolean ( STRING ) ) { Stack Trace Element [ ] trace = t . get Stack Trace ( ) ; List < Stack Trace Element > new Trace = new Array List < Stack Trace Element > ( ) ; for ( Stack Trace Element stack Trace Element : trace ) { if ( is Application Class ( stack Trace Element . get Class Name ( ) ) ) { new Trace . add ( stack Trace Element ) ; } } STACK LOG . log ( Level . WARNING , STRING , t ) ; Stack Trace Element [ ] clean = new Stack Trace Element [ new Trace . size ( ) ] ; new Trace . to Array ( clean ) ; t . set Stack Trace ( clean ) ; } return t ; }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case Eip Package . CHANNEL TO ENDPOINT : return to Endpoint != null ; case Eip Package . CHANNEL FROM ENDPOINT : return from Endpoint != null ; case Eip Package . CHANNEL NAME : return NAME EDEFAULT == null ? name != null : ! NAME EDEFAULT . equals ( name ) ; case Eip Package . CHANNEL GUARANTEED : return guaranteed != GUARANTEED EDEFAULT ; } return super . e Is Set ( feature ID ) ; }
public static void load Library ( String libname ) throws IO Exception { File lib = jni Extractor . extract Jni ( libname ) ; System . load ( lib . get Absolute Path ( ) ) ; }
private static Map < Token , Matcher > create Matchers ( Map < Token , Pattern > patterns , Char Sequence char Sequence ) { Map < Token , Matcher > matchers = new Hash Map < > ( ) ; for ( Token token : patterns . key Set ( ) ) { Pattern pattern = patterns . get ( token ) ; Matcher matcher = pattern . matcher ( char Sequence ) ; matchers . put ( token , matcher ) ; } return matchers ; }
private void fill Ordinal To Block Mapping For Dimension ( ) { int block Ordinal = - NUM ; Carbon Dimension dimension = null ; int index = NUM ; int prvcolumn Group Id = - NUM ; while ( index < dimensions . size ( ) ) { dimension = dimensions . get ( index ) ; if ( dimension . is Columnar ( ) || dimension . column Group Id ( ) != prvcolumn Group Id ) { block Ordinal ++ ; } dimension Ordinal To Block Mapping . put ( dimension . get Ordinal ( ) , block Ordinal ) ; prvcolumn Group Id = dimension . column Group Id ( ) ; index ++ ; } index = NUM ; while ( index < complex Dimensions . size ( ) ) { dimension = complex Dimensions . get ( index ) ; dimension Ordinal To Block Mapping . put ( dimension . get Ordinal ( ) , ++ block Ordinal ) ; block Ordinal = fill Complex Dimension Child Block Index ( block Ordinal , dimension ) ; index ++ ; } fill Block To Dimension Ordinal Mapping ( ) ; }
public static Field find Field ( Class < ? > type , String name ) throws No Such Field Exception { if ( name == null ) { throw new Illegal Argument Exception ( STRING ) ; } Field field = type . get Field ( name ) ; if ( ! Modifier . is Public ( field . get Modifiers ( ) ) ) { throw new No Such Field Exception ( STRING + name + STRING ) ; } type = field . get Declaring Class ( ) ; if ( ! Modifier . is Public ( type . get Modifiers ( ) ) || ! is Package Accessible ( type ) ) { throw new No Such Field Exception ( STRING + name + STRING ) ; } return field ; }
@ Suppress Warnings ( STRING ) protected void Build New LG Subrs ( int Font ) throws java . io . IO Exception { if ( fonts [ Font ] . is CID ) { h Subrs Used = new Generic Array < > ( fonts [ Font ] . fdprivate Offsets . length ) ; l Subrs Used = new Generic Array < > ( fonts [ Font ] . fdprivate Offsets . length ) ; New L Subrs Index = new byte [ fonts [ Font ] . fdprivate Offsets . length ] [ ] ; fonts [ Font ] . Private Subrs Offset = new int [ fonts [ Font ] . fdprivate Offsets . length ] ; fonts [ Font ] . Private Subrs Offsets Array = new int [ fonts [ Font ] . fdprivate Offsets . length ] [ ] ; List < Integer > FD In List = new Array List < > ( FD Array Used ) ; for ( int j = NUM ; j < FD In List . size ( ) ; j ++ ) { int FD = ( int ) FD In List . get ( j ) ; h Subrs Used . set ( FD , new Hash Map < Integer , int [ ] > ( ) ) ; l Subrs Used . set ( FD , new Array List < Integer > ( ) ) ; Build FD Subrs Offsets ( Font , FD ) ; if ( fonts [ Font ] . Private Subrs Offset [ FD ] >= NUM ) { Build Subr Used ( Font , FD , fonts [ Font ] . Private Subrs Offset [ FD ] , fonts [ Font ] . Private Subrs Offsets Array [ FD ] , h Subrs Used . get ( FD ) , l Subrs Used . get ( FD ) ) ; New L Subrs Index [ FD ] = Build New Index ( fonts [ Font ] . Private Subrs Offsets Array [ FD ] , h Subrs Used . get ( FD ) , RETURN OP ) ; } } } else if ( fonts [ Font ] . private Subrs >= NUM ) { fonts [ Font ] . Subrs Offsets = get Index ( fonts [ Font ] . private Subrs ) ; Build Subr Used ( Font , - NUM , fonts [ Font ] . private Subrs , fonts [ Font ] . Subrs Offsets , h Subrs Used Non CID , l Subrs Used Non CID ) ; } Build G Subrs Used ( Font ) ; if ( fonts [ Font ] . private Subrs >= NUM ) New Subrs Index Non CID = Build New Index ( fonts [ Font ] . Subrs Offsets , h Subrs Used Non CID , RETURN OP ) ; New G Subrs Index = Build New Index ( gsubr Offsets , hG Subrs Used , RETURN OP ) ; }
public int swap ( ) { if ( ! m Egl . egl Swap Buffers ( m Egl Display , m Egl Surface ) ) { return m Egl . egl Get Error ( ) ; } return EGL 10 . EGL SUCCESS ; }
protected void collect Query Parameters ( Http Request request , Http Parameters out ) { String url = request . get Request Url ( ) ; int q = url . index Of ( STRING ) ; if ( q >= NUM ) { out . put All ( O Auth . decode Form ( url . substring ( q + NUM ) ) , BOOL ) ; } }
public void add Line ( String line ) { int index = line . index Of ( STRING , NUM ) ; if ( index != - NUM ) { add Lenient ( line . substring ( NUM , index ) , line . substring ( index + NUM ) ) ; } else if ( line . starts With ( STRING ) ) { add Lenient ( STRING , line . substring ( NUM ) ) ; } else { add Lenient ( STRING , line ) ; } }
public static void merge Nodes ( Tree Node master , Tree Node slave ) { Default Mutable Tree Node master Node = ( Default Mutable Tree Node ) master ; Default Mutable Tree Node slave Node = ( Default Mutable Tree Node ) slave ; int master Cnt = master Node . get Child Count ( ) ; while ( slave Node . get Child Count ( ) > NUM ) { Default Mutable Tree Node slave Node Child = ( Default Mutable Tree Node ) slave Node . get First Child ( ) ; for ( int m = NUM ; m < master Cnt ; m ++ ) { Default Mutable Tree Node master At M = ( Default Mutable Tree Node ) master Node . get Child At ( m ) ; if ( do Custom Merge ( slave Node Child , master At M ) ) { slave Node Child = null ; break ; } if ( Merge Help Utilities . compare Names ( master At M , slave Node Child ) == NUM ) { if ( Merge Help Utilities . have Equal ID ( master At M , slave Node Child ) ) { Merge Help Utilities . merge Nodes ( DEFAULT MERGE TYPE , master At M , slave Node Child ) ; slave Node Child . remove From Parent ( ) ; slave Node Child = null ; break ; } Merge Help Utilities . mark Nodes ( master At M , slave Node Child ) ; master Node . add ( slave Node Child ) ; Merge Help Utilities . merge Node Children ( DEFAULT MERGE TYPE , slave Node Child ) ; slave Node Child = null ; break ; } } if ( slave Node Child != null ) { master Node . add ( slave Node Child ) ; Merge Help Utilities . merge Node Children ( DEFAULT MERGE TYPE , slave Node Child ) ; } } slave Node . remove From Parent ( ) ; slave Node = null ; }
public void test Negate Positive ( ) { String a = STRING ; int a Scale = NUM ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal c Number = new Big Decimal ( new Big Integer ( c ) , c Scale ) ; assert Equals ( STRING , c Number , a Number . negate ( ) ) ; }
private static void bind List ( Class < ? > item Type , Object target , Field field , Parameter Access parameters ) { String field Name = field . get Name ( ) ; Class < ? > field Type = field . get Type ( ) ; List < Parameter Access > item Parameters = create Item Parameters ( item Type , parameters ) ; Object array = Array . new Instance ( item Type , item Parameters . size ( ) ) ; for ( int i = NUM ; i < item Parameters . size ( ) ; i ++ ) { Object item Value = create And Bind Item ( item Parameters . get ( i ) , item Type ) ; Array . set ( array , i , item Value ) ; } Object target Value = convert Array ( array , field Type , item Type ) ; try { field . set Accessible ( BOOL ) ; field . set ( target , target Value ) ; } catch ( Exception e ) { String message = String . format ( STRING , field Name ) ; throw new Binding Exception ( message , e ) ; } }
public void switch To Advanced ( Experiment exp ) { if ( exp == null ) { exp = m simple Panel . get Experiment ( ) ; } if ( exp != null ) { m Advanced Setup R But . set Selected ( BOOL ) ; m advanced Panel . set Experiment ( exp ) ; } remove ( m simple Panel ) ; m simple Panel . remove Notes Frame ( ) ; add ( m advanced Panel , Border Layout . CENTER ) ; validate ( ) ; repaint ( ) ; }
private void parse Arguments ( String [ ] args ) throws IO Exception { for ( int i = NUM ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg . equals ( STRING ) ) { i ++ ; if ( args . length <= i ) { parsing Error ( arg + STRING ) ; } indirectory = new File ( args [ i ] ) ; if ( ! indirectory . exists ( ) ) { parsing Error ( args [ i ] + STRING ) ; } } else if ( arg . equals ( STRING ) ) { i ++ ; if ( args . length <= i ) { parsing Error ( arg + STRING ) ; } outdirectory = new File ( args [ i ] ) ; } else if ( arg . equals ( STRING ) ) { i ++ ; if ( args . length <= i ) { parsing Error ( arg + STRING ) ; } File config = new File ( args [ i ] ) ; if ( ! config . exists ( ) ) { parsing Error ( arg + STRING + args [ i ] + STRING ) ; } ner Annotator = Ner Annotator Manager . build Ner Annotator ( new Resource Manager ( args [ i ] ) , View Names . NER CONLL ) ; } else if ( arg . equals ( STRING ) ) { i ++ ; try { max = Integer . parse Int ( args [ i ] ) ; } catch ( Number Format Exception nfe ) { parsing Error ( STRING + args [ i ] + STRING ) ; } } else { parsing Error ( STRING + arg + STRING ) ; } } if ( ner Annotator == null ) { parsing Error ( STRING ) ; } if ( outdirectory != null && ! outdirectory . exists ( ) ) { if ( indirectory == null ) outdirectory . create New File ( ) ; else if ( indirectory . is Directory ( ) ) { outdirectory . mkdirs ( ) ; } else { outdirectory . create New File ( ) ; } } }
private boolean zoning Enabled ( Export Mask export Mask ) { if ( Network Util . are Network System Discovered ( db Client ) ) { List < Export Group > export Groups = Export Utils . get Export Groups For Mask ( export Mask . get Id ( ) , db Client ) ; for ( Export Group export Group : export Groups ) { if ( Network Scheduler . is Zoning Required ( db Client , export Group . get Virtual Array ( ) ) ) { return BOOL ; } } } return BOOL ; }
public Collection < XML Element > consume Child Elements ( Interpreter < Boolean > interpreter ) throws Unable To Complete Exception { List < XML Element > elements = new Array List < XML Element > ( ) ; List < Node > doomed = new Array List < Node > ( ) ; Node List child Nodes = elem . get Child Nodes ( ) ; for ( int i = NUM ; i < child Nodes . get Length ( ) ; ++ i ) { Node child Node = child Nodes . item ( i ) ; if ( child Node . get Node Type ( ) == Node . ELEMENT NODE ) { XML Element child Element = provider . get ( ( Element ) child Node ) ; if ( interpreter . interpret Element ( child Element ) ) { elements . add ( child Element ) ; doomed . add ( child Node ) ; } } } for ( Node n : doomed ) { elem . remove Child ( n ) ; } return elements ; }
public boolean has Name Value ( String name ) { return hmap . contains Key ( name . to Lower Case ( ) ) ; }
private static String prepend If Missing ( final String str , final Char Sequence prefix , final boolean ignore Case , final Char Sequence ... prefixes ) { if ( str == null || is Empty ( prefix ) || starts With ( str , prefix , ignore Case ) ) { return str ; } if ( prefixes != null && prefixes . length > NUM ) { for ( final Char Sequence p : prefixes ) { if ( starts With ( str , p , ignore Case ) ) { return str ; } } } return prefix . to String ( ) + str ; }
public boolean is First Window ( Accessibility Window Info base Window , int window Type ) { int index = get Window Index ( base Window ) ; if ( index <= NUM ) { return BOOL ; } for ( int i = index - NUM ; i > NUM ; i -- ) { Accessibility Window Info window = m Windows . get ( i ) ; if ( window != null && window . get Type ( ) == window Type ) { return BOOL ; } } return BOOL ; }
public void fire Property Change ( String property Name , long old Value , long new Value ) { if ( change Support == null || old Value == new Value ) { return ; } fire Property Change ( property Name , Long . value Of ( old Value ) , Long . value Of ( new Value ) ) ; }
public Abstract Surface Object ( ) { this . visible = BOOL ; this . unique Id = next Unique Id ( ) ; this . last Modified Time = System . current Time Millis ( ) ; this . enable Batch Picking = BOOL ; }
public Version ( String spec ) { if ( spec == null ) { throw new Null Pointer Exception ( ) ; } Pattern pattern 2 = Pattern . compile ( STRING ) ; Matcher matcher 2 = pattern 2 . matcher ( spec ) ; Pattern pattern 3 = Pattern . compile ( STRING ) ; Matcher matcher 3 = pattern 3 . matcher ( spec ) ; Pattern pattern 4 = Pattern . compile ( STRING ) ; Matcher matcher 4 = pattern 4 . matcher ( spec ) ; Pattern pattern 5 = Pattern . compile ( STRING ) ; Matcher matcher 5 = pattern 5 . matcher ( spec ) ; if ( matcher 2 . matches ( ) ) { this . major Version = Integer . parse Int ( matcher 2 . group ( NUM ) ) ; this . minor Version = Integer . parse Int ( matcher 2 . group ( NUM ) ) ; this . minor Subversion = Integer . parse Int ( matcher 2 . group ( NUM ) ) ; this . incremental Release = NUM ; } else if ( matcher 3 . matches ( ) ) { this . major Version = Integer . parse Int ( matcher 3 . group ( NUM ) ) ; this . minor Version = Integer . parse Int ( matcher 3 . group ( NUM ) ) ; this . minor Subversion = Integer . parse Int ( matcher 3 . group ( NUM ) ) ; this . incremental Release = Integer . parse Int ( matcher 3 . group ( NUM ) ) ; } else if ( matcher 4 . matches ( ) ) { this . major Version = Integer . parse Int ( matcher 4 . group ( NUM ) ) ; this . minor Version = Integer . parse Int ( matcher 4 . group ( NUM ) ) ; this . minor Subversion = Integer . parse Int ( matcher 4 . group ( NUM ) ) ; this . incremental Release = NUM ; } else if ( matcher 5 . matches ( ) ) { this . major Version = Integer . parse Int ( matcher 5 . group ( NUM ) ) ; this . minor Version = Integer . parse Int ( matcher 5 . group ( NUM ) ) ; this . minor Subversion = Integer . parse Int ( matcher 5 . group ( NUM ) ) ; this . incremental Release = Integer . parse Int ( matcher 5 . group ( NUM ) ) ; } else { throw new Illegal Argument Exception ( STRING + STRING + spec ) ; } }
private String create New Review ( Task Data task Data , Appraise Plugin Review Client client ) throws Core Exception { boolean can Request Review = client . can Request Review ( task Data ) ; if ( ! can Request Review ) { throw new Core Exception ( Status . CANCEL STATUS ) ; } String task Id = null ; try { Review review = build Review From Task Data ( task Data ) ; review . set Timestamp ( System . current Time Millis ( ) / NUM ) ; String review Commit Hash = get Review Commit Hash ( task Data ) ; task Id = client . write Review ( review Commit Hash , review ) ; if ( task Id == null ) { throw new Core Exception ( Status . CANCEL STATUS ) ; } } catch ( Git Client Exception e ) { throw new Core Exception ( new Status ( I Status . ERROR , Appraise Connector Plugin . PLUGIN ID , STRING , e ) ) ; } return task Id ; }
@ Override public synchronized void power On Self Test ( ) throws Error { Log . i ( Mary . LOG , STRING ) ; try { Mary Data Type in Type = maryxml To Mbrola . input Type ( ) ; Collection voices = Voice . get Available Voices ( this ) ; if ( voices . is Empty ( ) ) throw new Error ( STRING ) ; Voice v = ( Voice ) voices . iterator ( ) . next ( ) ; assert v != null ; Mary Data in = new Mary Data ( in Type , v . get Locale ( ) ) ; String example = in Type . example Text ( v . get Locale ( ) ) ; if ( example != null ) { in . read From ( new String Reader ( example ) ) ; in . set Default Voice ( v ) ; Mary Data mbrola = maryxml To Mbrola . process ( in ) ; mbrola . set Audio File Format ( new Audio File Format ( Audio File Format . Type . WAVE , Voice . AF 22050 , Audio System . NOT SPECIFIED ) ) ; mbrola . set Default Voice ( v ) ; mbrola Caller . process ( mbrola ) ; } else { Log . d ( Mary . LOG , STRING ) ; } } catch ( Throwable t ) { throw new Error ( STRING + to String ( ) + STRING , t ) ; } Log . i ( Mary . LOG , STRING ) ; }
public final void render ( Terminal Emulator m Emulator , Canvas canvas , int top Row , int selection Y 1 , int selection Y 2 , int selection X 1 , int selection X 2 ) { final boolean reverse Video = m Emulator . is Reverse Video ( ) ; final int end Row = top Row + m Emulator . m Rows ; final int columns = m Emulator . m Columns ; final int cursor Col = m Emulator . get Cursor Col ( ) ; final int cursor Row = m Emulator . get Cursor Row ( ) ; final boolean cursor Visible = m Emulator . is Showing Cursor ( ) ; final Terminal Buffer screen = m Emulator . get Screen ( ) ; final int [ ] palette = m Emulator . m Colors . m Current Colors ; if ( reverse Video ) canvas . draw Color ( palette [ Text Style . COLOR INDEX FOREGROUND ] , Porter Duff . Mode . SRC ) ; float height Offset = m Font Line Spacing And Ascent ; for ( int row = top Row ; row < end Row ; row ++ ) { height Offset += m Font Line Spacing ; final int cursor X = ( row == cursor Row && cursor Visible ) ? cursor Col : - NUM ; int selx 1 = - NUM , selx 2 = - NUM ; if ( row >= selection Y 1 && row <= selection Y 2 ) { if ( row == selection Y 1 ) selx 1 = selection X 1 ; selx 2 = ( row == selection Y 2 ) ? selection X 2 : m Emulator . m Columns ; } Terminal Row line Object = screen . allocate Full Line If Necessary ( screen . external To Internal Row ( row ) ) ; final char [ ] line = line Object . m Text ; final int chars Used In Line = line Object . get Space Used ( ) ; long last Run Style = NUM ; boolean last Run Inside Cursor = BOOL ; int last Run Start Column = - NUM ; int last Run Start Index = NUM ; boolean last Run Font Width Mismatch = BOOL ; int current Char Index = NUM ; float measured Width For Run = NUM ; for ( int column = NUM ; column < columns ; ) { final char char At Index = line [ current Char Index ] ; final boolean char Is Highsurrogate = Character . is High Surrogate ( char At Index ) ; final int chars For Code Point = char Is Highsurrogate ? NUM : NUM ; final int code Point = char Is Highsurrogate ? Character . to Code Point ( char At Index , line [ current Char Index + NUM ] ) : char At Index ; final int code Point Wc Width = Wc Width . width ( code Point ) ; final boolean inside Cursor = ( column >= selx 1 && column <= selx 2 ) || ( cursor X == column || ( code Point Wc Width == NUM && cursor X == column + NUM ) ) ; final long style = line Object . get Style ( column ) ; final float measured Code Point Width = ( code Point < ascii Measures . length ) ? ascii Measures [ code Point ] : m Text Paint . measure Text ( line , current Char Index , chars For Code Point ) ; final boolean font Width Mismatch = Math . abs ( measured Code Point Width / m Font Width - code Point Wc Width ) > NUM ; if ( style != last Run Style || inside Cursor != last Run Inside Cursor || font Width Mismatch || last Run Font Width Mismatch ) { if ( column == NUM ) { } else { final int column Width Since Last Run = column - last Run Start Column ; final int chars Since Last Run = current Char Index - last Run Start Index ; draw Text Run ( canvas , line , palette , height Offset , last Run Start Column , column Width Since Last Run , last Run Start Index , chars Since Last Run , measured Width For Run , last Run Inside Cursor , last Run Style , reverse Video ) ; } measured Width For Run = NUM ; last Run Style = style ; last Run Inside Cursor = inside Cursor ; last Run Start Column = column ; last Run Start Index = current Char Index ; last Run Font Width Mismatch = font Width Mismatch ; } measured Width For Run += measured Code Point Width ; column += code Point Wc Width ; current Char Index += chars For Code Point ; while ( current Char Index < chars Used In Line && Wc Width . width ( line , current Char Index ) <= NUM ) { current Char Index += Character . is High Surrogate ( line [ current Char Index ] ) ? NUM : NUM ; } } final int column Width Since Last Run = columns - last Run Start Column ; final int chars Since Last Run = current Char Index - last Run Start Index ; draw Text Run ( canvas , line , palette , height Offset , last Run Start Column , column Width Since Last Run , last Run Start Index , chars Since Last Run , measured Width For Run , last Run Inside Cursor , last Run Style , reverse Video ) ; } }
public boolean overlaps Time Range ( int from Time , int to Time ) { int first Stop Time , last Stop Time ; if ( this . headway Seconds != null ) { first Stop Time = Integer . MAX VALUE ; last Stop Time = Integer . MIN VALUE ; if ( this . headway Seconds . length == NUM ) { LOG . warn ( STRING ) ; return BOOL ; } for ( int i = NUM ; i < this . headway Seconds . length ; i ++ ) { first Stop Time = Math . min ( first Stop Time , this . start Times [ i ] ) ; last Stop Time = Math . max ( last Stop Time , this . end Times [ i ] + this . arrivals [ this . arrivals . length - NUM ] ) ; } } else { first Stop Time = departures [ NUM ] ; last Stop Time = arrivals [ arrivals . length - NUM ] ; } return first Stop Time <= to Time && last Stop Time >= from Time ; }
public static Color Own for String ( String color String , int transparency ) { boolean error = BOOL ; Color Own return Color = null ; if ( color String == null ) { error = BOOL ; } else { for ( Entry < String , Color Own > c : COLOR MAP . entry Set ( ) ) { if ( color String . equals Ignore Case ( c . get Key ( ) ) ) { return Color = c . get Value ( ) ; break ; } } if ( return Color == null ) { try { return Color = new Color Own ( color String ) ; } catch ( Number Format Exception e ) { error = BOOL ; } } if ( return Color != null ) { return Color = return Color . transparency ( transparency ) ; } } if ( error ) { throw new Style Exception ( STRING + EXAMPLE TEXT ) ; } return return Color ; }
private static Linked List < Mary Module > modules Required For Processing ( Mary Data Type source Type , Mary Data Type target Type , Locale locale , Voice voice , Linked List < Mary Data Type > seen Types ) { if ( source Type . equals ( target Type ) ) { Log . d ( Mary . LOG , STRING ) ; return new Linked List < Mary Module > ( ) ; } List < Mary Module > candidates = null ; if ( voice != null ) candidates = voice . get Preferred Modules Accepting Type ( source Type ) ; if ( candidates == null || candidates . is Empty ( ) ) { candidates = get ( source Type , locale , voice ) ; } if ( candidates == null || candidates . is Empty ( ) ) { return null ; } for ( Iterator < Mary Module > it = candidates . iterator ( ) ; it . has Next ( ) ; ) { Mary Module candidate = it . next ( ) ; Mary Data Type output Type = candidate . output Type ( ) ; if ( ! seen Types . contains ( output Type ) ) { seen Types . add ( output Type ) ; Log . d ( Mary . LOG , STRING + candidate . name ( ) + STRING + source Type . name ( ) + STRING + output Type + STRING + locale + STRING + voice + STRING ) ; Linked List < Mary Module > path = modules Required For Processing ( output Type , target Type , locale , voice , seen Types ) ; if ( path != null ) { path . add First ( candidate ) ; return path ; } seen Types . remove Last ( ) ; } } return null ; }
public double length ( ) { return Math . sqrt ( Number Conversions . square ( x ) + Number Conversions . square ( y ) + Number Conversions . square ( z ) ) ; }
public static long seconds Since Millis ( long time In Millis ) { return ( System . current Time Millis ( ) - time In Millis ) / NUM ; }
public Flat Buffer Builder init ( Byte Buffer existing bb ) { bb = existing bb ; bb . clear ( ) ; bb . order ( Byte Order . LITTLE ENDIAN ) ; minalign = NUM ; space = bb . capacity ( ) ; vtable in use = NUM ; nested = BOOL ; finished = BOOL ; object start = NUM ; num vtables = NUM ; vector num elems = NUM ; return this ; }
private Map < String , String > produce Stream ( String topic ) { List < Integer > subnet = new Array List < > ( ) ; for ( int i = NUM ; i <= CNT ; i ++ ) subnet . add ( i ) ; Collections . shuffle ( subnet ) ; List < Producer Record < String , String > > messages = new Array List < > ( CNT ) ; Map < String , String > key Val Map = new Hash Map < > ( ) ; for ( int evt = NUM ; evt < CNT ; evt ++ ) { long runtime = System . current Time Millis ( ) ; String ip = KEY PREFIX + subnet . get ( evt ) ; String msg = runtime + VALUE URL + ip ; messages . add ( new Producer Record < > ( topic , ip , msg ) ) ; key Val Map . put ( ip , msg ) ; } embedded Broker . send Messages ( messages ) ; return key Val Map ; }
private static String string Of Char ( char ch , int len ) { String Buffer buf = new String Buffer ( ) ; for ( int i = NUM ; i < len ; i ++ ) { buf . append ( ch ) ; } return buf . to String ( ) ; }
public static List < Response > execute Batch And Wait ( Request Batch requests ) { Validate . not Empty And Contains No Nulls ( requests , STRING ) ; Http URL Connection connection = null ; try { connection = to Http Connection ( requests ) ; } catch ( Exception ex ) { List < Response > responses = Response . construct Error Responses ( requests . get Requests ( ) , null , new Facebook Exception ( ex ) ) ; run Callbacks ( requests , responses ) ; return responses ; } List < Response > responses = execute Connection And Wait ( connection , requests ) ; return responses ; }
public void trim ( String a Text , int [ ] a Span ) { int begin = a Span [ NUM ] ; int end = a Span [ NUM ] - NUM ; String data = a Text ; while ( ( begin < ( data . length ( ) - NUM ) ) && trim Char ( data . char At ( begin ) ) ) { begin ++ ; } while ( ( end > NUM ) && trim Char ( data . char At ( end ) ) ) { end -- ; } end ++ ; a Span [ NUM ] = begin ; a Span [ NUM ] = end ; }
public void remove Script Finished Listener ( Script Execution Listener l ) { m Finished Listeners . remove ( l ) ; }
public void test get Put Byte Array With Offset And Length ( ) { final int capacity = NUM ; final Byte Array Buffer buf = new Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( NUM ) ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( capacity - NUM ) ) ; final int pos = NUM ; for ( int i = NUM ; i < LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - NUM ) ] ; final int off = ( expected . length / NUM == NUM ? NUM : r . next Int ( expected . length / NUM ) ) ; final int len = ( expected . length == NUM ? NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( NUM , Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( NUM , Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) NUM , buf . get Byte ( NUM ) ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( pos + capacity - NUM ) ) ; }
private Object [ ] ensure Capacity ( int min Capacity ) { if ( tmp . length < min Capacity ) { int new Size = min Capacity ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size |= new Size > > NUM ; new Size ++ ; if ( new Size < NUM ) new Size = min Capacity ; else new Size = Math . min ( new Size , a . length > > > NUM ) ; Object [ ] new Array = new Object [ new Size ] ; tmp = new Array ; } return tmp ; }
public void CL ( int session Number , String client Line ) { this . max Session Number = Math . max ( this . max Session Number , session Number ) ; test Elements . add ( new Client Request ( session Number , client Line ) ) ; }
public static void update Point On Circle ( Point F point To Update , float radius , double angle Degrees , Point F center ) { if ( radius < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } double angle Radians = Math . to Radians ( angle Degrees ) ; float x = ( float ) ( radius * Math . sin ( angle Radians ) + center . x ) ; float y = ( float ) ( radius * - Math . cos ( angle Radians ) + center . y ) ; point To Update . set ( x , y ) ; }
private static int count Gaps Dash Dot ( String sequence ) { int count = NUM ; for ( int i = NUM ; i < sequence . length ( ) ; i ++ ) { int a = sequence . char At ( i ) ; if ( a == STRING || a == STRING ) count ++ ; } return count ; }
public CRL Number Extension ( int crl Num ) throws IO Exception { this ( PKIX Extensions . CRL Number Id , BOOL , Big Integer . value Of ( crl Num ) , NAME , LABEL ) ; }
static private double calc Log Prob At Mu ( double mu ) { final double sigma = calc Sigma From Mu ( mu ) ; return ( - s log Sqrt Two Pi - Math . log ( sigma ) ) ; }
private boolean is Position On Line ( final float x , final float y , final float node 1 X , final float node 1 Y , final float node 2 X , final float node 2 Y ) { float tolerance = Data Style . get Current ( ) . way Tolerance Value / NUM ; if ( Geo Math . is Between ( x , node 1 X , node 2 X , tolerance ) && Geo Math . is Between ( y , node 1 Y , node 2 Y , tolerance ) ) { return ( Geo Math . get Line Distance ( x , y , node 1 X , node 1 Y , node 2 X , node 2 Y ) < tolerance ) ; } return BOOL ; }
protected final void drag Exit ( final int x , final int y ) { Drag Source Event event = new Drag Source Event ( get Drag Source Context ( ) , x , y ) ; Event Dispatcher dispatcher = new Event Dispatcher ( DISPATCH EXIT , event ) ; Sun Toolkit . invoke Later On App Context ( Sun Toolkit . target To App Context ( get Component ( ) ) , dispatcher ) ; start Secondary Event Loop ( ) ; }
protected static String extract Bucket ( String s3 uri ) { return s3 uri . substring ( s3 uri . index Of ( STRING ) + NUM , s3 uri . index Of ( STRING , s3 uri . index Of ( STRING ) ) ) ; }
private void send SMS ( String message , String contact Information ) { Resolved Contact rc = m Contacts Resolver . resolve Contact ( contact Information , Contacts Resolver . TYPE CELL ) ; if ( rc == null ) { send ( R . string . chat no match for , contact Information ) ; } else if ( rc . is Distinct ( ) ) { send SMS By Phone Number ( message , rc . get Number ( ) , rc . get Name ( ) ) ; } else { ask For More Details ( rc . get Candidates ( ) ) ; } }
public boolean is Safe Class ( Soot Class clz ) { return safe Classes . contains ( clz . get Name ( ) ) ; }
private boolean update Locked ( ) { boolean is Active = BOOL ; long next Retry Time Millis = Long . MAX VALUE ; long now = system Facade . current Time Millis ( ) ; Collection < File Download Info > all Downloads = downloads Repository . get All Downloads ( ) ; update Total Bytes For ( all Downloads ) ; List < Download Batch > download Batches = batch Repository . retrieve Batches For ( all Downloads ) ; for ( Download Batch download Batch : download Batches ) { if ( download Batch . is Active ( ) ) { is Active = BOOL ; break ; } } for ( Download Batch download Batch : download Batches ) { if ( download Batch . is Deleted ( ) || download Batch . prune ( download Deleter ) ) { continue ; } if ( ! is Active && download Ready Checker . can Download ( download Batch ) ) { boolean is Batch Starting For The First Time = batch Repository . is Batch Starting For The First Time ( download Batch . get Batch Id ( ) ) ; if ( is Batch Starting For The First Time ) { handle Batch Starting For The First Time ( download Batch ) ; } download Or Continue Batch ( download Batch . get Downloads ( ) ) ; is Active = BOOL ; } else if ( download Batch . scan Completed Media If Ready ( download Scanner ) ) { is Active = BOOL ; } next Retry Time Millis = download Batch . next Action Millis ( now , next Retry Time Millis ) ; } batch Repository . delete Marked Batches For ( all Downloads ) ; update User Visible Notification ( download Batches ) ; if ( next Retry Time Millis > NUM && next Retry Time Millis < Long . MAX VALUE ) { L Log . v ( STRING + next Retry Time Millis + STRING ) ; Intent intent = new Intent ( Constants . ACTION RETRY ) ; intent . set Class ( this , Download Receiver . class ) ; alarm Manager . set ( Alarm Manager . RTC WAKEUP , now + next Retry Time Millis , Pending Intent . get Broadcast ( this , NUM , intent , Pending Intent . FLAG ONE SHOT ) ) ; } if ( ! is Active ) { move Submitted Tasks To Batch Status If Necessary ( ) ; } return is Active ; }
public boolean is Running ( ) { return running ; }
static private String read From Stdin ( ) throws IO Exception { final Line Number Reader r = new Line Number Reader ( new Input Stream Reader ( System . in ) ) ; try { final String Builder sb = new String Builder ( ) ; String s ; while ( ( s = r . read Line ( ) ) != null ) { if ( r . get Line Number ( ) > NUM ) sb . append ( STRING ) ; sb . append ( s ) ; } return sb . to String ( ) ; } finally { r . close ( ) ; } }
@ Override public String to String ( ) { final String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; sb . append ( get Request ID ( ) ) ; sb . append ( STRING ) ; sb . append ( timestamp ) ; sb . append ( STRING ) ; sb . append ( get Request ( ) ) ; sb . append ( STRING ) ; return sb . to String ( ) ; }
public void test empty Journal ( ) throws IO Exception , Interrupted Exception , Execution Exception { final File out = File . create Temp File ( get Name ( ) , Options . JNL ) ; try { final Journal src = get Store ( get Properties ( ) ) ; try { try { final Future < Journal > f = src . compact ( out ) ; final Journal new Journal = f . get ( ) ; try { new Journal . destroy ( ) ; } finally { fail ( STRING + Illegal Argument Exception . class ) ; } } catch ( Illegal Argument Exception ex ) { log . info ( STRING + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
private void generate Flow ( ACL Rule rule , String dpid , String flow Name ) { int priority ; if ( dpid 2 Flow Priority . get ( dpid ) == null ) { dpid 2 Flow Priority . put ( dpid , NUM ) ; priority = NUM ; } else { priority = dpid 2 Flow Priority . get ( dpid ) ; } if ( rule . get Nw src ( ) != null ) { Hash Map < String , Object > flow = new Hash Map < String , Object > ( ) ; flow . put ( Static Flow Entry Pusher . COLUMN SWITCH , dpid ) ; flow . put ( Static Flow Entry Pusher . COLUMN NAME , flow Name ) ; flow . put ( Static Flow Entry Pusher . COLUMN ACTIVE , Boolean . to String ( BOOL ) ) ; flow . put ( Static Flow Entry Pusher . COLUMN COOKIE , STRING ) ; flow . put ( Static Flow Entry Pusher . COLUMN PRIORITY , Integer . to String ( priority ) ) ; dpid 2 Flow Priority . put ( dpid , -- priority ) ; flow . put ( Static Flow Entry Pusher . COLUMN DL TYPE , STRING ) ; flow . put ( Static Flow Entry Pusher . COLUMN NW SRC , rule . get Nw src ( ) ) ; if ( rule . get Nw dst ( ) != null ) { flow . put ( Static Flow Entry Pusher . COLUMN NW DST , rule . get Nw dst ( ) ) ; } if ( rule . get Nw proto ( ) != NUM ) { flow . put ( Static Flow Entry Pusher . COLUMN NW PROTO , Integer . to String ( rule . get Nw proto ( ) ) ) ; } if ( rule . get Action ( ) == Action . ALLOW ) { flow . put ( Static Flow Entry Pusher . COLUMN ACTIONS , STRING ) ; } if ( rule . get Tp dst ( ) != NUM ) { flow . put ( Static Flow Entry Pusher . COLUMN TP DST , Integer . to String ( rule . get Tp dst ( ) ) ) ; } storage Source . insert Row Async ( Static Flow Entry Pusher . TABLE NAME , flow ) ; } else { Hash Map < String , Object > flow = new Hash Map < String , Object > ( ) ; flow . put ( Static Flow Entry Pusher . COLUMN SWITCH , dpid ) ; flow . put ( Static Flow Entry Pusher . COLUMN NAME , flow Name ) ; flow . put ( Static Flow Entry Pusher . COLUMN ACTIVE , Boolean . to String ( BOOL ) ) ; flow . put ( Static Flow Entry Pusher . COLUMN COOKIE , STRING ) ; flow . put ( Static Flow Entry Pusher . COLUMN PRIORITY , Integer . to String ( priority ) ) ; dpid 2 Flow Priority . put ( dpid , -- priority ) ; flow . put ( Static Flow Entry Pusher . COLUMN DL TYPE , STRING ) ; flow . put ( Static Flow Entry Pusher . COLUMN NW DST , rule . get Nw dst ( ) ) ; if ( rule . get Nw proto ( ) != NUM ) { flow . put ( Static Flow Entry Pusher . COLUMN NW PROTO , Integer . to String ( rule . get Nw proto ( ) ) ) ; } if ( rule . get Action ( ) == Action . ALLOW ) { flow . put ( Static Flow Entry Pusher . COLUMN ACTIONS , STRING ) ; } if ( rule . get Tp dst ( ) != NUM ) { flow . put ( Static Flow Entry Pusher . COLUMN TP DST , Integer . to String ( rule . get Tp dst ( ) ) ) ; } storage Source . insert Row Async ( Static Flow Entry Pusher . TABLE NAME , flow ) ; } logger . info ( STRING + flow Name + STRING + dpid ) ; }
public static double pow Fast ( double value , int power ) { if ( USE JDK MATH ) { return STRICT MATH ? Strict Math . pow ( value , power ) : Math . pow ( value , power ) ; } if ( power > NUM ) { double odd Remains = NUM ; do { if ( ( power & NUM ) != NUM ) { odd Remains *= value ; } value *= value ; power >>= NUM ; } while ( power > NUM ) ; if ( power == NUM ) { return odd Remains * value * value * value ; } else { double v2 = value * value ; if ( power == NUM ) { return odd Remains * v2 * v2 ; } else { return odd Remains * v2 * v2 * value ; } } } else if ( power >= NUM ) { if ( power < NUM ) { if ( power == NUM ) { return value * value ; } else if ( power != NUM ) { return value ; } else { return NUM ; } } else { if ( power == NUM ) { return value * value * value ; } else { double v2 = value * value ; if ( power == NUM ) { return v2 * v2 ; } else { return v2 * v2 * value ; } } } } else { if ( power == Integer . MIN VALUE ) { return NUM / ( Fast Math . pow Fast ( value , Integer . MAX VALUE ) * value ) ; } else { return NUM / Fast Math . pow Fast ( value , - power ) ; } } }
void find Classes Deriving From ( String super name , Map < String , Class Reader > zip Classes , Map < String , Class Reader > in Out Found ) throws Log Abort Exception { Class Reader super clazz = find Class ( super name , zip Classes , in Out Found ) ; for ( Entry < String , Class Reader > entry : zip Classes . entry Set ( ) ) { String class Name = entry . get Key ( ) ; if ( super name . equals ( class Name ) ) { continue ; } Class Reader class Reader = entry . get Value ( ) ; Class Reader parent cr = class Reader ; while ( parent cr != null ) { String parent name = internal To Binary Class Name ( parent cr . get Super Name ( ) ) ; if ( parent name == null ) { break ; } else if ( super name . equals ( parent name ) ) { in Out Found . put ( class Name , class Reader ) ; break ; } parent cr = zip Classes . get ( parent name ) ; } } }
public POS Mikheev Feature Extractor ( String view Name , String json ) { this . view Name = view Name ; this . counter = POS Mikheev Counter . read ( json ) ; }
private Map < String , Annotation Mirror > annos In Type ( Type Element type Element ) { return create Imported Annotations Map ( Element Filter . types In ( type Element . get Enclosed Elements ( ) ) ) ; }
public Way [ ] split At Nodes ( Way way , Node node 1 , Node node 2 , boolean create Polygons ) { Log . d ( STRING , STRING + way . get Osm Id ( ) + STRING + node 1 . get Osm Id ( ) + STRING + node 2 . get Osm Id ( ) ) ; dirty = BOOL ; undo . save ( way ) ; List < Node > nodes = way . get Nodes ( ) ; if ( nodes . size ( ) < NUM ) { return null ; } List < Node > nodes For New Way = new Linked List < Node > ( ) ; List < Node > nodes For Old Way 1 = new Linked List < Node > ( ) ; List < Node > nodes For Old Way 2 = new Linked List < Node > ( ) ; boolean found 1 = BOOL ; boolean found 2 = BOOL ; for ( Iterator < Node > it = way . get Removable Nodes ( ) ; it . has Next ( ) ; ) { Node way Node = it . next ( ) ; if ( ! found 1 && way Node . get Osm Id ( ) == node 1 . get Osm Id ( ) ) { found 1 = BOOL ; nodes For New Way . add ( way Node ) ; if ( ! found 2 ) nodes For Old Way 1 . add ( way Node ) ; else nodes For Old Way 2 . add ( way Node ) ; } else if ( ! found 2 && way Node . get Osm Id ( ) == node 2 . get Osm Id ( ) ) { found 2 = BOOL ; nodes For New Way . add ( way Node ) ; if ( ! found 1 ) nodes For Old Way 1 . add ( way Node ) ; else nodes For Old Way 2 . add ( way Node ) ; } else if ( ( found 1 && ! found 2 ) || ( ! found 1 && found 2 ) ) { nodes For New Way . add ( way Node ) ; } else if ( ! found 1 && ! found 2 ) { nodes For Old Way 1 . add ( way Node ) ; } else if ( found 1 && found 2 ) { nodes For Old Way 2 . add ( way Node ) ; } } Log . d ( STRING , STRING + nodes For New Way . size ( ) + STRING + nodes For Old Way 1 . size ( ) + STRING + nodes For Old Way 2 . size ( ) ) ; List < Node > old Nodes = way . get Nodes ( ) ; old Nodes . clear ( ) ; if ( nodes For Old Way 1 . size ( ) == NUM ) { old Nodes . add All ( nodes For Old Way 2 ) ; } else if ( nodes For Old Way 2 . size ( ) == NUM ) { old Nodes . add All ( nodes For Old Way 1 ) ; } else if ( nodes For Old Way 1 . get ( NUM ) == nodes For Old Way 2 . get ( nodes For Old Way 2 . size ( ) - NUM ) ) { old Nodes . add All ( nodes For Old Way 2 ) ; nodes For Old Way 1 . remove ( NUM ) ; old Nodes . add All ( nodes For Old Way 1 ) ; } else { old Nodes . add All ( nodes For Old Way 1 ) ; nodes For Old Way 2 . remove ( NUM ) ; old Nodes . add All ( nodes For Old Way 2 ) ; } try { if ( create Polygons && way . length ( ) > NUM ) { way . add Node ( way . get First Node ( ) ) ; } way . update State ( Osm Element . STATE MODIFIED ) ; api Storage . insert Element Safe ( way ) ; Way new Way = factory . create Way With New Id ( ) ; new Way . add Tags ( way . get Tags ( ) ) ; new Way . add Nodes ( nodes For New Way , BOOL ) ; if ( create Polygons && new Way . length ( ) > NUM ) { new Way . add Node ( new Way . get First Node ( ) ) ; } insert Element Unsafe ( new Way ) ; if ( way . has Parent Relations ( ) ) { Array List < Relation > relations = new Array List < Relation > ( way . get Parent Relations ( ) ) ; dirty = BOOL ; for ( Relation r : relations ) { Log . d ( STRING , STRING + r . get Osm Id ( ) + STRING + relations . size ( ) + STRING + r . get Description ( ) ) ; Relation Member rm = r . get Member ( way ) ; undo . save ( r ) ; Relation Member new Member = new Relation Member ( rm . get Role ( ) , new Way ) ; r . add Member After ( rm , new Member ) ; new Way . add Parent Relation ( r ) ; r . update State ( Osm Element . STATE MODIFIED ) ; api Storage . insert Element Safe ( r ) ; } } record Imagery ( ) ; Way [ ] result = new Way [ NUM ] ; result [ NUM ] = way ; result [ NUM ] = new Way ; return result ; } catch ( Storage Exception e ) { e . print Stack Trace ( ) ; } return null ; }
void update Cursor ( ) { if ( model . get Hovering Operator ( ) != null || model . get Hovering Port ( ) != null ) { set Cursor ( Cursor . get Predefined Cursor ( Cursor . HAND CURSOR ) ) ; } else { set Cursor ( Cursor . get Default Cursor ( ) ) ; } }
public static boolean is Middle Mouse Button ( Mouse Event an Event ) { return ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 2 DOWN MASK ) > NUM ; }
@ Override public boolean execute Script Line ( final String line ) { boolean success = BOOL ; String with Props Expanded = line ; try { if ( line . contains ( STRING ) ) { with Props Expanded = expand Properties ( line ) ; } String log Message = STRING ; if ( ! line . equals ( with Props Expanded ) ) { if ( ! is Quiet Mode ( ) ) { Gfsh . println ( STRING + with Props Expanded ) ; } log Message = STRING ; expanded Prop Commands Map . put ( with Props Expanded , line ) ; } if ( gfsh File Logger . fine Enabled ( ) ) { gfsh File Logger . fine ( log Message + with Props Expanded ) ; } success = super . execute Script Line ( with Props Expanded ) ; } catch ( Exception e ) { set Last Execution Status ( - NUM ) ; } finally { gfsh History . set Auto Flush ( BOOL ) ; gfsh History . add To History ( line ) ; gfsh History . set Auto Flush ( BOOL ) ; expanded Prop Commands Map . clear ( ) ; } return success ; }
private void synchronize Changed ( ) { clock . set Synchronize ( synchronize Check Box . is Selected ( ) , BOOL ) ; changed = BOOL ; }
protected void reopen ( ) throws IO Exception { if ( input Stream != null ) { Debug . message ( STRING , STRING ) ; input Stream . close ( ) ; } input Stream Count = NUM ; }
private void read ASCII ( final Buffered Reader buffer ) throws Number Format Exception , IO Exception { Raj Log . i ( STRING ) ; final List < Float > vertices = new Array List < Float > ( ) ; final List < Float > normals = new Array List < Float > ( ) ; final float [ ] temp Norms = new float [ NUM ] ; int next Offset , prev Offset , i , insert ; String line ; line = buffer . read Line ( ) ; while ( ( line = buffer . read Line ( ) ) != null ) { if ( line . contains ( STRING ) ) { next Offset = line . last Index Of ( STRING ) ; temp Norms [ NUM ] = Float . parse Float ( line . substring ( next Offset + NUM ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( STRING , prev Offset - NUM ) ; temp Norms [ NUM ] = Float . parse Float ( line . substring ( next Offset + NUM , prev Offset ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( STRING , prev Offset - NUM ) ; temp Norms [ NUM ] = Float . parse Float ( line . substring ( next Offset + NUM , prev Offset ) ) ; for ( i = NUM ; i < NUM ; i ++ ) { normals . add ( temp Norms [ NUM ] ) ; normals . add ( temp Norms [ NUM ] ) ; normals . add ( temp Norms [ NUM ] ) ; } } else if ( line . contains ( STRING ) ) { insert = vertices . size ( ) ; next Offset = line . last Index Of ( STRING ) ; vertices . add ( Float . parse Float ( line . substring ( next Offset + NUM ) ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( STRING , prev Offset - NUM ) ; vertices . add ( insert , Float . parse Float ( line . substring ( next Offset + NUM , prev Offset ) ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( STRING , prev Offset - NUM ) ; vertices . add ( insert , Float . parse Float ( line . substring ( next Offset + NUM , prev Offset ) ) ) ; } } float [ ] vertices Arr = new float [ vertices . size ( ) ] ; float [ ] normals Arr = new float [ normals . size ( ) ] ; for ( i = NUM ; i < vertices Arr . length ; i ++ ) { vertices Arr [ i ] = vertices . get ( i ) ; normals Arr [ i ] = normals . get ( i ) ; } vertices . clear ( ) ; normals . clear ( ) ; int [ ] indices Arr = new int [ vertices Arr . length / NUM ] ; for ( i = NUM ; i < indices Arr . length ; i ++ ) indices Arr [ i ] = i ; m Root Object . set Data ( vertices Arr , normals Arr , null , null , indices Arr , BOOL ) ; }
private static XMP Node add Qualifier Node ( XMP Node xmp Parent , String name , String value ) throws XMP Exception { boolean is Lang = XML LANG . equals ( name ) ; XMP Node new Qual = null ; new Qual = new XMP Node ( name , is Lang ? Utils . normalize Lang Value ( value ) : value , null ) ; xmp Parent . add Qualifier ( new Qual ) ; return new Qual ; }
public Entity Bomb add Time ( int time ) { fuse Time = Math . max ( fuse Time + time , fuse Time ) ; return this ; }
@ Override protected void on Delete Complete ( int token , Object cookie , int result ) { if ( token == m Delete Token ) { synchronized ( s Deleting Threads Lock ) { s Deleting Threads = BOOL ; if ( DELETEDEBUG ) { Log . v ( TAG , STRING + s Deleting Threads ) ; } s Deleting Threads Lock . notify All ( ) ; } Unread Badge Service . update ( m Context ) ; Notification Manager . create ( m Context ) ; } }
public long time Since Last ( ) { long current Time = System . current Time Millis ( ) ; return current Time - last Message Time ; }
public void add COS Attribute ( String attr Name , int qualifier ) throws UMS Exception { String Builder attr Str = new String Builder ( ) ; if ( qualifier < ICOS Definition . min Qualifier || qualifier > ICOS Definition . max Qualifier ) { String msg = i18 n . get String ( IUMS Constants . BAD COS ATTR QUALIFIER ) ; throw new UMS Exception ( msg ) ; } attr Str . append ( attr Name ) ; attr Str . append ( STRING ) ; attr Str . append ( ICOS Definition . qualifiers [ qualifier ] ) ; modify ( ICOS Definition . COSATTRIBUTE , attr Str . to String ( ) , Modification Type . ADD ) ; }
@ Deprecated public static Source Data Tag Quality from XML ( Element dom Element ) { Node List fields = dom Element . get Child Nodes ( ) ; int fields Count = fields . get Length ( ) ; String field Name ; String field Value String ; Node field Node ; Source Data Tag Quality result = new Source Data Tag Quality ( ) ; for ( int i = NUM ; i != fields Count ; i ++ ) { field Node = fields . item ( i ) ; if ( field Node . get Node Type ( ) == Node . ELEMENT NODE ) { field Name = field Node . get Node Name ( ) ; Node field Value Node = field Node . get First Child ( ) ; if ( field Value Node != null ) { field Value String = field Value Node . get Node Value ( ) ; } else { field Value String = STRING ; } if ( field Name . equals ( XML ELEMENT QUALITY CODE ) ) { short code = Short . parse Short ( field Value String ) ; result . quality Code = Source Data Tag Quality Code . get Enum ( code ) ; } else if ( field Name . equals ( XML ELEMENT QUALITY DESC ) ) { result . description = field Value String ; } } } return result ; }
public static Method Annotation convert Method Annotation ( Class Name Rewriter class Name Rewriter , Method Annotation annotation ) { if ( class Name Rewriter != Identity Class Name Rewriter . instance ( ) ) { annotation = new Method Annotation ( class Name Rewriter . rewrite Class Name ( annotation . get Class Name ( ) ) , annotation . get Method Name ( ) , rewrite Method Signature ( class Name Rewriter , annotation . get Method Signature ( ) ) , annotation . is Static ( ) ) ; } return annotation ; }
public static Boolean verify JWT ( final String jwt , final String secret ) throws Hmac Exception { try { Signed JWT signed JWT = Signed JWT . parse ( jwt ) ; JWS Verifier jws Verifier = new MAC Verifier ( secret ) ; return signed JWT . verify ( jws Verifier ) ; } catch ( Parse Exception | JOSE Exception ex ) { throw new Hmac Exception ( STRING , ex ) ; } }
public void flatten Symbol Table ( boolean flatten All Tables ) { if ( ! flatten All Tables ) { List < Symbol > new Symbols = new Array List < Symbol > ( ) ; if ( this . symbol Table != null ) { for ( int i = NUM ; i < symbols . size ( ) ; i ++ ) { Symbol symbol = symbols . get ( i ) ; if ( symbol . get Containing Table ( ) == this ) { new Symbols . add ( symbol ) ; } } } symbols = new Symbols ; } variable Names = new String [ symbols . size ( ) ] ; is Consts = new boolean [ symbols . size ( ) ] ; for ( int i = NUM ; i < symbols . size ( ) ; i ++ ) { Symbol symbol = symbols . get ( i ) ; variable Names [ i ] = symbol . get Name ( ) ; is Consts [ i ] = symbol . get Decl Type ( ) == Token . CONST ; symbol . set Index ( i ) ; } }
@ Override public synchronized void add Data Source Listener ( Data Source Listener dsl ) { m data Listeners . add Element ( dsl ) ; }
public static Set < Annotation Mirror > glb Of Bounds ( final Annotated Intersection Type isect , final Qualifier Hierarchy qualifier Hierarchy ) { Set < Annotation Mirror > result = Annotation Utils . create Annotation Set ( ) ; for ( final Annotation Mirror top : qualifier Hierarchy . get Top Annotations ( ) ) { final Annotation Mirror glb Anno = glb Of Bounds In Hierarchy ( isect , top , qualifier Hierarchy ) ; if ( glb Anno != null ) { result . add ( glb Anno ) ; } } return result ; }
public boolean to Active ( ) { Lifecycle State state ; synchronized ( this ) { state = state ; if ( state . is After Active ( ) && ! state . is Stopped ( ) ) { return BOOL ; } state = ACTIVE ; last Change Time = Current Time . current Time ( ) ; } if ( log != null && log . is Loggable ( level ) ) log . log ( level , STRING + name ) ; notify Listeners ( state , ACTIVE ) ; return BOOL ; }
public byte [ ] receive Message ( ) throws IO Exception { byte [ ] prefix = new byte [ NUM ] ; int idx = NUM ; while ( idx < NUM ) { int read = in . read ( prefix , idx , NUM - idx ) ; if ( read < NUM ) throw new IO Exception ( STRING ) ; idx += read ; } int len = U . bytes To Int ( prefix , NUM ) ; byte [ ] res = new byte [ len ] ; idx = NUM ; while ( idx < len ) { int read = in . read ( res , idx , len - idx ) ; if ( read < NUM ) throw new IO Exception ( STRING ) ; idx += read ; } return res ; }
public double evaluate ( Vector Instance x , Vector Instance y ) throws Exception { double dot Prod = x . dot Product ( y ) ; double z = m gamma * dot Prod + m coef 0 ; double a = Math . exp ( z ) ; double b = Math . exp ( - z ) ; return ( ( a - b ) / ( a + b ) ) ; }
void cancel Included Only ( ) { if ( ! show All ) { all Button . do Click ( ) ; } }
@ Override public List < App Entry > load In Background ( ) { List < Application Info > apps = m Pm . get Installed Applications ( Package Manager . GET UNINSTALLED PACKAGES | Package Manager . GET DISABLED COMPONENTS ) ; if ( apps == null ) { apps = new Array List < Application Info > ( ) ; } final Context context = get Context ( ) ; List < App Entry > entries = new Array List < App Entry > ( apps . size ( ) ) ; for ( int i = NUM ; i < apps . size ( ) ; i ++ ) { App Entry entry = new App Entry ( this , apps . get ( i ) ) ; entry . load Label ( context ) ; entries . add ( entry ) ; } Collections . sort ( entries , ALPHA COMPARATOR ) ; return entries ; }
public static String strip Suffix ( String name , String suffix , boolean recursive Strip ) { if ( name . length ( ) < NUM ) { return name ; } int suffix Start = name . last Index Of ( suffix . char At ( NUM ) ) ; if ( suffix Start != - NUM && name . region Matches ( suffix Start , suffix , NUM , name . length ( ) - suffix Start ) ) { name = name . substring ( NUM , suffix Start ) ; } if ( recursive Strip && name . ends With ( suffix ) ) { return strip Suffix ( name , suffix , recursive Strip ) ; } return name ; }
@ Override public void parse ( String a Line ) throws IO Exception { String [ ] tokens = a Line . split ( STRING ) ; if ( tokens . length == NUM ) { clear ( ) ; query Name = tokens [ NUM ] ; } else { query Name = tokens [ NUM ] ; ref Name = tokens [ NUM ] ; bit Score = Basic . parse Int ( tokens [ NUM ] ) ; expected = Basic . parse Float ( tokens [ NUM ] ) ; percent Identity = Basic . parse Int ( tokens [ NUM ] ) ; } }
protected void draw Actor ( int x , int y , int w , int h , Color fill Color , Paint fill Paint , Color pen Color , boolean shadow ) { float width = w * NUM / NUM ; General Path path = new General Path ( ) ; path . move To ( x , y + h ) ; path . curve To ( x , y + NUM * h / NUM , x , y + NUM * h / NUM , x + w / NUM , y + NUM * h / NUM ) ; path . curve To ( x + w / NUM - width , y + NUM * h / NUM , x + w / NUM - width , y , x + w / NUM , y ) ; path . curve To ( x + w / NUM + width , y , x + w / NUM + width , y + NUM * h / NUM , x + w / NUM , y + NUM * h / NUM ) ; path . curve To ( x + w , y + NUM * h / NUM , x + w , y + NUM * h / NUM , x + w , y + h ) ; path . close Path ( ) ; draw Path ( path , fill Color , fill Paint , pen Color , shadow ) ; }
private static boolean trusted ( Set set , Trust Verifier . Context ctx ) throws Remote Exception { return trusted ( set . iterator ( ) , ctx ) ; }
public static Persistent Search Request Control new Control ( final boolean is Critical , final boolean changes Only , final boolean return E Cs , final Collection < Persistent Search Change Type > change Types ) { Reject . if Null ( change Types ) ; final Set < Persistent Search Change Type > copy Of Change Types = Enum Set . none Of ( Persistent Search Change Type . class ) ; copy Of Change Types . add All ( change Types ) ; return new Persistent Search Request Control ( is Critical , changes Only , return E Cs , Collections . unmodifiable Set ( copy Of Change Types ) ) ; }
private void build Network ( final Network network , int [ ] nodes Per Layer , Point 2 D initial Position , final Neuron input Neuron Template ) { set Label ( STRING ) ; List < Neuron > input Layer Neurons = new Array List < Neuron > ( ) ; for ( int i = NUM ; i < nodes Per Layer [ NUM ] ; i ++ ) { input Layer Neurons . add ( new Neuron ( network , input Neuron Template ) ) ; } Neuron Group input Layer = new Neuron Group ( network , input Layer Neurons ) ; input Layer . set Clamped ( BOOL ) ; add Neuron Group ( input Layer ) ; input Layer . set Layout Based On Size ( initial Position ) ; Synapse synapse = Synapse . get Template Synapse ( new Static Synapse Rule ( ) ) ; synapse . set Lower Bound ( - NUM ) ; synapse . set Upper Bound ( NUM ) ; Neuron Group last Layer = input Layer ; for ( int i = NUM ; i < nodes Per Layer . length ; i ++ ) { List < Neuron > hidden Layer Neurons = new Array List < Neuron > ( ) ; for ( int j = NUM ; j < nodes Per Layer [ i ] ; j ++ ) { Sigmoidal Rule rule = new Sigmoidal Rule ( ) ; Neuron neuron = new Neuron ( network , rule ) ; rule . set Lower Bound ( NUM ) ; neuron . set Update Priority ( i ) ; hidden Layer Neurons . add ( neuron ) ; } Neuron Group hidden Layer = new Neuron Group ( network , hidden Layer Neurons ) ; hidden Layer . set Layout Based On Size ( ) ; add Neuron Group ( hidden Layer ) ; Network Layout Manager . offset Neuron Group ( last Layer , hidden Layer , Direction . NORTH , between Layer Interval ) ; All To All connection = new All To All ( ) ; Synapse Group lh = connect Neuron Groups ( last Layer , hidden Layer , connection ) ; lh . randomize Connection Weights ( ) ; last Layer = hidden Layer ; } }
public static Number multiply ( Character left , Number right ) { return Number Number Multiply . multiply ( Integer . value Of ( left ) , right ) ; }
public static String pad Right ( String s , int len , char pad ch ) { if ( s . length ( ) >= len ) { return s ; } else { String Builder sb = new String Builder ( ) ; int n = len - s . length ( ) ; sb . append ( s ) ; for ( int i = NUM ; i < n ; i ++ ) { sb . append ( pad ch ) ; } return sb . to String ( ) ; } }
public void add Diagram Change Listener ( mx Diagram Change Listener listener ) { if ( diagram Change Listeners == null ) { diagram Change Listeners = new Array List < mx Diagram Change Listener > ( ) ; } diagram Change Listeners . add ( listener ) ; }
public void write ( final byte b [ ] , final int off , final int len ) throws IO Exception { if ( m store == null ) { throw new Illegal State Exception ( ERR NO STORE ) ; } if ( m is Saved ) { throw new Illegal State Exception ( ERR ALREADY SAVED ) ; } if ( ( m count + len ) > m blob Threshold ) { for ( int i = NUM ; i < len ; i ++ ) { write ( b [ off + i ] ) ; } } else { System . arraycopy ( b , off , m buf , m count , len ) ; m count += len ; m bytes Written += len ; } }
public Weak Close Listener ( Object resource ) { resource Ref = new Weak Reference < Object > ( resource ) ; }
protected List < T > create New Row ( final T value ) { Array List < T > row = new Array List < T > ( ) ; for ( int i = NUM ; i < get Logical Column Count ( ) ; i ++ ) { row . add ( value ) ; } return row ; }
private void check Report Interval Value ( final int request Interval ) { final long current Timestamp = System . current Time Millis ( ) ; if ( m Timestamp > NUM ) { final long diff = current Timestamp - m Timestamp ; if ( diff < ( request Interval - Test Common . OFFSET REPORT INTERVAL ) || diff > ( request Interval + Test Common . OFFSET REPORT INTERVAL ) ) { m Waiter . fail ( STRING + request Interval + STRING + ( current Timestamp - m Timestamp ) ) ; } } m Timestamp = current Timestamp ; }
public void tear Down ( ) throws Exception { Throwable t = thread Failure . get And Set ( null ) ; if ( t != null ) { if ( t instanceof Error ) throw ( Error ) t ; else if ( t instanceof Runtime Exception ) throw ( Runtime Exception ) t ; else if ( t instanceof Exception ) throw ( Exception ) t ; else { Assertion Failed Error afe = new Assertion Failed Error ( t . to String ( ) ) ; afe . init Cause ( t ) ; throw afe ; } } }
public static double ellipsoidal Distance ( Lat Lon p1 , Lat Lon p2 , double equatorial Radius , double polar Radius ) { final double F = ( equatorial Radius - polar Radius ) / equatorial Radius ; final double R = NUM - F ; final double EPS = NUM ; if ( p1 == null || p2 == null ) { throw new Illegal Argument Exception ( STRING ) ; } double GLAT 1 = p1 . get Latitude ( ) . radians ; double GLAT 2 = p2 . get Latitude ( ) . radians ; double TU 1 = R * Math . sin ( GLAT 1 ) / Math . cos ( GLAT 1 ) ; double TU 2 = R * Math . sin ( GLAT 2 ) / Math . cos ( GLAT 2 ) ; double CU 1 = NUM / Math . sqrt ( TU 1 * TU 1 + NUM ) ; double SU 1 = CU 1 * TU 1 ; double CU 2 = NUM / Math . sqrt ( TU 2 * TU 2 + NUM ) ; double S = CU 1 * CU 2 ; double BAZ = S * TU 2 ; double FAZ = BAZ * TU 1 ; double GLON 1 = p1 . get Longitude ( ) . radians ; double GLON 2 = p2 . get Longitude ( ) . radians ; double X = GLON 2 - GLON 1 ; double D , SX , CX , SY , CY , Y , SA , C2 A , CZ , E , C ; do { SX = Math . sin ( X ) ; CX = Math . cos ( X ) ; TU 1 = CU 2 * SX ; TU 2 = BAZ - SU 1 * CU 2 * CX ; SY = Math . sqrt ( TU 1 * TU 1 + TU 2 * TU 2 ) ; CY = S * CX + FAZ ; Y = Math . atan 2 ( SY , CY ) ; SA = S * SX / SY ; C2 A = - SA * SA + NUM ; CZ = FAZ + FAZ ; if ( C2 A > NUM ) { CZ = - CZ / C2 A + CY ; } E = CZ * CZ * NUM - NUM ; C = ( ( - NUM * C2 A + NUM ) * F + NUM ) * C2 A * F / NUM ; D = X ; X = ( ( E * CY * C + CZ ) * SY * C + Y ) * SA ; X = ( NUM - C ) * X * F + GLON 2 - GLON 1 ; } while ( Math . abs ( D - X ) > EPS ) ; X = Math . sqrt ( ( NUM / R / R - NUM ) * C2 A + NUM ) + NUM ; X = ( X - NUM ) / X ; C = NUM - X ; C = ( X * X / NUM + NUM ) / C ; D = ( NUM * X * X - NUM ) * X ; X = E * CY ; S = NUM - E - E ; S = ( ( ( ( SY * SY * NUM - NUM ) * S * CZ * D / NUM - X ) * D / NUM + CZ ) * SY * D + Y ) * C * equatorial Radius * R ; return S ; }
public char [ ] to Char Array ( ) { synchronized ( lock ) { char [ ] result = new char [ count ] ; System . arraycopy ( buf , NUM , result , NUM , count ) ; return result ; } }
public void insert Separator ( int index ) { synchronized ( get Tree Lock ( ) ) { if ( index < NUM ) { throw new Illegal Argument Exception ( STRING ) ; } int nitems = get Item Count ( ) ; Vector < Menu Item > temp Items = new Vector < > ( ) ; for ( int i = index ; i < nitems ; i ++ ) { temp Items . add Element ( get Item ( index ) ) ; remove ( index ) ; } add Separator ( ) ; for ( int i = NUM ; i < temp Items . size ( ) ; i ++ ) { add ( temp Items . element At ( i ) ) ; } } }
public static String [ ] split On Char With Quoting ( String s , char split Char , char quote Char , char escape Char ) { List < String > result = new Array List < > ( ) ; int i = NUM ; int length = s . length ( ) ; String Builder b = new String Builder ( ) ; while ( i < length ) { char curr = s . char At ( i ) ; if ( curr == split Char ) { if ( b . length ( ) > NUM ) { result . add ( b . to String ( ) ) ; b = new String Builder ( ) ; } i ++ ; } else if ( curr == quote Char ) { i ++ ; while ( i < length ) { curr = s . char At ( i ) ; if ( curr == escape Char ) { b . append ( s . char At ( i + NUM ) ) ; i += NUM ; } else if ( curr == quote Char ) { i ++ ; break ; } else { b . append ( s . char At ( i ) ) ; i ++ ; } } } else { b . append ( curr ) ; i ++ ; } } if ( b . length ( ) > NUM ) { result . add ( b . to String ( ) ) ; } return result . to Array ( new String [ NUM ] ) ; }
private List < Quote > download Url ( String url Param ) throws IO Exception , Xml Pull Parser Exception { Input Stream is = null ; try { URL url = new URL ( url Param ) ; Http URL Connection conn = ( Http URL Connection ) url . open Connection ( ) ; conn . set Read Timeout ( NUM ) ; conn . set Connect Timeout ( NUM ) ; conn . set Request Method ( STRING ) ; conn . set Do Input ( BOOL ) ; conn . connect ( ) ; int response = conn . get Response Code ( ) ; Log . d ( STRING , STRING + response ) ; if ( response == NUM ) { is = conn . get Input Stream ( ) ; return read XML ( is ) ; } } finally { if ( is != null ) { is . close ( ) ; } } return null ; }
public Custom Entry Concurrent Hash Map ( final Map < ? extends K , ? extends V > m ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT LOAD FACTOR ) + NUM , DEFAULT INITIAL CAPACITY ) , DEFAULT LOAD FACTOR , DEFAULT CONCURRENCY LEVEL , BOOL ) ; put All ( m ) ; }
@ Nullable public Rule Type matching Rule ( Proto Element elem ) { Rule Type result = rule Map . get ( elem ) ; if ( result != null ) { return result ; } for ( int i = rules . size ( ) - NUM ; i >= NUM ; i -- ) { Rule Wrapper < Rule Type > rule Wrapper = rules . get ( i ) ; String matched Selector = rule Wrapper . get Matched Selector ( elem ) ; if ( matched Selector != null ) { rule Map . put ( elem , rule Wrapper . rule ) ; if ( unmatched Rules . contains Key ( rule Wrapper ) ) { Set < String > unmatched Selectors = unmatched Rules . get ( rule Wrapper ) ; unmatched Selectors . remove ( matched Selector ) ; if ( unmatched Selectors . is Empty ( ) ) { unmatched Rules . remove ( rule Wrapper ) ; } } return rule Wrapper . rule ; } } return null ; }
public void write ( Input Stream stream ) { if ( is Final ) { log . warning ( STRING ) ; return ; } try { int n Read ; byte [ ] buffer = new byte [ NUM * NUM ] ; while ( ( n Read = stream . read ( buffer , NUM , buffer . length ) ) != - NUM ) { byte [ ] new Data = new byte [ data . length + n Read ] ; System . arraycopy ( data , NUM , new Data , NUM , data . length ) ; System . arraycopy ( buffer , NUM , new Data , data . length , n Read ) ; data = new Data ; } } catch ( IO Exception e ) { log . warning ( STRING ) ; } }
public boolean contains Exclude Result Prefix ( String prefix , String uri ) { if ( uri == null || ( null == m exclude Result Prefixes && null == m Extension Element UR Is ) ) return super . contains Exclude Result Prefix ( prefix , uri ) ; if ( prefix . length ( ) == NUM ) prefix = Constants . ATTRVAL DEFAULT PREFIX ; if ( m exclude Result Prefixes != null ) for ( int i = NUM ; i < m exclude Result Prefixes . size ( ) ; i ++ ) { if ( uri . equals ( get Namespace For Prefix ( m exclude Result Prefixes . element At ( i ) ) ) ) return BOOL ; } if ( m Extension Element UR Is != null && m Extension Element UR Is . contains ( uri ) ) return BOOL ; return super . contains Exclude Result Prefix ( prefix , uri ) ; }
private OM Graphic List plot Data Sources ( GLOBE Temp Data temperature data ) { Debug . message ( STRING , STRING ) ; int num graphics = NUM ; OM Graphic List graphics = new OM Graphic List ( ) ; graphics . set Traverse Mode ( OM Graphic List . LAST ADDED ON TOP ) ; Enumeration site enum = temperature data . get All Sites ( ) ; while ( site enum . has More Elements ( ) ) { GLOBE Site site = ( GLOBE Site ) site enum . next Element ( ) ; graphics . add ( site . get Graphic ( ) ) ; num graphics ++ ; } Debug . message ( STRING , STRING + num graphics + STRING ) ; return graphics ; }
public static boolean is Jdbc Package ( String package Name ) { return package Name != null && ( package Name . starts With ( STRING ) || package Name . starts With ( STRING ) || package Name . starts With ( MYSQL JDBC PACKAGE ROOT ) ) ; }
Async Connector ( RMI Socket Factory factory , String host , int port , Access Control Context acc ) { this . factory = factory ; this . host = host ; this . port = port ; this . acc = acc ; Security Manager security = System . get Security Manager ( ) ; if ( security != null ) { security . check Connect ( host , port ) ; } }
Map . Entry < K , V > do Remove First Entry ( ) { for ( ; ; ) { Node < K , V > b = head . node ; Node < K , V > n = b . next ; if ( n == null ) return null ; Node < K , V > f = n . next ; if ( n != b . next ) continue ; Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; continue ; } if ( ! n . cas Value ( v , null ) ) continue ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find First ( ) ; clear Index To First ( ) ; return new Abstract Map . Simple Immutable Entry < K , V > ( n . key , ( V ) v ) ; } }
public Compute Task Cancelled Checked Exception ( Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
protected int normalize ( char [ ] src , int src Start , int src Limit , char [ ] dest , int dest Start , int dest Limit , Unicode Set nx ) { int src Len = ( src Limit - src Start ) ; int dest Len = ( dest Limit - dest Start ) ; if ( src Len > dest Len ) { return src Len ; } System . arraycopy ( src , src Start , dest , dest Start , src Len ) ; return src Len ; }
@ Non Null private List < String > map Obsolete Elements ( List < String > names ) { List < String > elements To Remove = new Array List < > ( names . size ( ) ) ; for ( String name : names ) { if ( name . starts With ( STRING ) ) continue ; elements To Remove . add ( name ) ; } return elements To Remove ; }
private void reflect Member Variables In Right Button ( ) { final boolean last Page Reached = ( view Pager . get Current Item ( ) + NUM ) == pages . size ( ) ; final boolean button Should Be Invisible = last Page Reached || right Button Disabled ; final boolean button Is Currently Invisible = right Button . get Visibility ( ) == View . INVISIBLE ; final boolean should Update Button = button Should Be Invisible != button Is Currently Invisible ; if ( should Update Button ) { final Animator button Animator = button Should Be Invisible ? button Animator Factory . new Right Button Disappear Animator ( right Button ) : button Animator Factory . new Right Button Appear Animator ( right Button ) ; if ( button Should Be Invisible ) { disable Button ( button Animator , right Button ) ; } else { enable Button ( button Animator , right Button ) ; } } }
public void remove Action ( Update Action action ) { action List . remove ( action ) ; for ( Update Manager Listener listener : listeners ) { listener . action Removed ( action ) ; } }
private double extremum alpha n ( int n , double [ ] alpha ) { if ( vec . double Value ( n ) == NUM ) { return Math Util . HALFPI ; } double tan = NUM ; for ( int j = n + NUM ; j < vec . get Dimensionality ( ) ; j ++ ) { double alpha j = j == vec . get Dimensionality ( ) - NUM ? NUM : alpha [ j ] ; tan += vec . double Value ( j ) * sinus Product ( n + NUM , j , alpha ) * Math . cos ( alpha j ) ; } tan /= vec . double Value ( n ) ; double alpha n = Math . atan ( tan ) ; if ( alpha n < NUM ) { alpha n = Math . PI + alpha n ; } return alpha n ; }
public Pair < String , String > next ( ) { current Header Position = next Header Position ; Pair < String , String > result = new Pair < > ( next Header , next Sequence ) ; next Header = next Next Header ; next Header Position = next Next Header Position ; next Sequence = null ; next Next Header = null ; if ( next Header != null ) { String a Line ; try { while ( ( a Line = r . read Line ( ) ) != null ) { if ( a Line . starts With ( STRING ) ) { next Next Header = a Line ; next Next Header Position = position ; position += a Line . length ( ) + end Of Line Bytes ; break ; } else { position += a Line . length ( ) + end Of Line Bytes ; parts . add ( a Line ) ; } } number Of Sequences Read ++ ; } catch ( IO Exception e ) { Basic . caught ( e ) ; } next Sequence = Basic . concatenate And Remove White Spaces ( parts ) ; parts . clear ( ) ; } else try { close ( ) ; } catch ( IO Exception ex ) { Basic . caught ( ex ) ; } return result ; }
public void add ( Boolean bool ) { elements . add ( bool == null ? Json Null . INSTANCE : new Json Primitive ( bool ) ) ; }
private static void add All Children To Set ( View root View , Set < View > the Set ) { if ( ! ( root View instanceof View Group ) ) { return ; } View Group root View Group = ( View Group ) root View ; for ( int i = NUM ; i < root View Group . get Child Count ( ) ; ++ i ) { View next View = root View Group . get Child At ( i ) ; the Set . add ( next View ) ; add All Children To Set ( next View , the Set ) ; } }
protected Storage Port check Port Exists In DB ( String native Guid ) { Storage Port port = null ; List < Storage Port > port In DB = Custom Query Utility . get Active Storage Port By Native Guid ( db Client , native Guid ) ; if ( port In DB != null && ! port In DB . is Empty ( ) ) { port = port In DB . get ( NUM ) ; } return port ; }
public void prepend Split Element ( Fragment a Split ) { splits . add ( NUM , a Split ) ; }
@ Override public void start Element ( String uri , String local Name , String q Name , Attributes attributes ) { if ( element Processor != null ) { element Processor = element Processor . get Child ( uri , local Name , q Name ) ; } else if ( ELEMENT NAME OSM . equals ( q Name ) ) { element Processor = osm Element Processor ; } else { throw new Osm Runtime Exception ( STRING ) ; } element Processor . begin ( attributes ) ; }
public void close ( ) throws IO Exception { flush ( ) ; if ( os != null && os != System . out && os != System . err ) os . close ( ) ; buffer = null ; }
public void accept ( Context context ) { if ( null != call Reference ) { Respoke Call call = call Reference . get ( ) ; if ( null != call ) { call . direct Connection Did Accept ( context ) ; } } }
private boolean attempt To Extract Idd ( ) { Pattern international Prefix = regex Cache . get Pattern For Regex ( STRING + Phone Number Util . PLUS SIGN + STRING + current Metadata . get International Prefix ( ) ) ; Matcher idd Matcher = international Prefix . matcher ( accrued Input Without Formatting ) ; if ( idd Matcher . looking At ( ) ) { is Complete Number = BOOL ; int start Of Country Calling Code = idd Matcher . end ( ) ; national Number . set Length ( NUM ) ; national Number . append ( accrued Input Without Formatting . substring ( start Of Country Calling Code ) ) ; prefix Before National Number . set Length ( NUM ) ; prefix Before National Number . append ( accrued Input Without Formatting . substring ( NUM , start Of Country Calling Code ) ) ; if ( accrued Input Without Formatting . char At ( NUM ) != Phone Number Util . PLUS SIGN ) { prefix Before National Number . append ( SEPARATOR BEFORE NATIONAL NUMBER ) ; } return BOOL ; } return BOOL ; }
public void cut ( ) { build ( ) ; is Cut = BOOL ; for ( Task t : get Tasks ( ) ) { my Assignments . add All ( Arrays . as List ( t . get Assignments ( ) ) ) ; my Task Manager . delete Task ( t ) ; t . delete ( ) ; } }
public J Caret ( final int blink Period , final Color caret Color ) { Preconditions . check Argument ( blink Period >= NUM , STRING ) ; Preconditions . check Not Null ( caret Color , STRING ) ; m caret Timer = new Timer ( blink Period , m listener ) ; m caret Timer . set Repeats ( BOOL ) ; m caret Timer . start ( ) ; }
public synchronized void release ( ) { if ( event Queue != null ) { event Queue . clear ( ) ; event Queue = null ; } if ( control Queue != null ) { control Queue . clear ( ) ; control Queue = null ; } if ( watch Predicates != null ) { watch Predicates . clear ( ) ; watch Predicates = null ; } }
private boolean cmd Requires Stream ( String cmd ) { for ( String prefix : stream Cmds Prefix ) { if ( cmd . starts With ( prefix ) ) { return BOOL ; } } return stream Cmds . contains ( cmd ) ; }
public void transform Point ( Object native Transform , float [ ] in , float [ ] out ) { Affine Transform t = ( Affine Transform ) native Transform ; t . transform ( in , NUM , out , NUM , NUM ) ; clamp ( out ) ; }
public void test Signum Negative ( ) { String a = STRING ; int a Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; assert Equals ( STRING , - NUM , a Number . signum ( ) ) ; }
public Painter Chain add Painter ( Painter p ) { if ( chain . length != NUM ) { Painter [ ] new Chain = new Painter [ chain . length + NUM ] ; System . arraycopy ( chain , NUM , new Chain , NUM , chain . length ) ; new Chain [ chain . length ] = p ; return new Painter Chain ( new Chain ) ; } return new Painter Chain ( new Painter [ ] { p } ) ; }
private Layout parse Layout ( Token Stream tokens ) { Doc . Group Kind kind = Doc . Group Kind . VERTICAL ; Doc separator = Doc . BREAK ; int nest = NUM ; if ( tokens . has ( STRING ) ) { tokens . next ( ) ; kind = Doc . Group Kind . VERTICAL ; } else if ( tokens . has ( STRING ) ) { tokens . next ( ) ; kind = Doc . Group Kind . HORIZONTAL ; } else if ( tokens . has ( STRING ) ) { tokens . next ( ) ; kind = Doc . Group Kind . AUTO ; } else if ( tokens . has ( STRING ) ) { tokens . next ( ) ; kind = Doc . Group Kind . FILL ; } if ( tokens . has ( INT LITERAL ) ) { nest = Integer . parse Int ( tokens . next ( ) ) ; } if ( tokens . has ( JOIN SEPARATOR ) ) { tokens . next ( ) ; Elem expr = parse Expr ( tokens ) ; if ( expr != null ) { separator = eval Parsing Time ( expr ) ; } } return Layout . create ( separator , kind , nest ) ; }
@ Override public boolean swipe ( Selector obj , String dir , float percent , int steps ) throws Ui Object Not Found Exception { if ( obj . to Ui Object 2 ( ) == null ) { return swipe ( device . find Object ( obj . to Ui Selector ( ) ) , dir , steps ) ; } return swipe ( obj . to Ui Object 2 ( ) , dir , percent , steps ) ; }
private void filter Already Synced ( Contact Sync Entry sync Entry ) { final String selection = String . format ( Locale . US , STRING , Database Columns . NUMBER , sync Entry . get Joined Numbers Csv ( ) ) ; final Cursor cursor = DB Interface . query ( BOOL , Table Uploaded Contacts . NAME , null , selection , null , null , null , null , null ) ; if ( cursor != null ) { while ( cursor . move To Next ( ) ) { sync Entry . remove Number ( cursor . get String ( cursor . get Column Index ( Database Columns . NUMBER ) ) ) ; } cursor . close ( ) ; } }
static void write String To File ( final String string , final File file ) throws IO Exception { create File ( file ) ; try ( Print Writer print Writer = new Print Writer ( file ) ) { print Writer . print ( string ) ; } }
private boolean is JMX Enabled ( ) { return Boolean . parse Boolean ( System . get Property ( System Properties . JMX ENABLED PROP , System Properties . JMX ENABLED DEFAULT VALUE ) ) ; }
public static String render ( Tree tree ) { String Builder sb = new String Builder ( ) ; render Tree ( tree , NUM , BOOL , BOOL , BOOL , BOOL , sb ) ; sb . append ( STRING ) ; return sb . to String ( ) ; }
public Text Editor replace All ( String regex , String replacement ) { if ( text . length ( ) > NUM ) { final String r = replacement ; Pattern p = Pattern . compile ( regex , Pattern . MULTILINE ) ; Matcher m = p . matcher ( text ) ; String Buffer sb = new String Buffer ( ) ; while ( m . find ( ) ) { m . append Replacement ( sb , r ) ; } m . append Tail ( sb ) ; text = sb ; } return this ; }
public final boolean equals Ignore Case ( Char Segment b ) { int length = length ; if ( length != b . length ) return BOOL ; char [ ] buffer = buffer ; char [ ] b Buffer = b . buffer ; int offset = offset ; int b Offset = b . offset ; for ( int i = length - NUM ; i >= NUM ; i -- ) { char ca = buffer [ offset + i ] ; char cb = b Buffer [ b Offset + i ] ; if ( ca != cb && Character . to Lower Case ( ca ) != Character . to Lower Case ( cb ) ) return BOOL ; } return BOOL ; }
protected synchronized long numchunks ( ) throws IO Exception { if ( backing Random Access File . length ( ) <= f Header . header Size ( ) ) { return NUM ; } else { long len = backing Random Access File . length ( ) - f Header . header Size ( ) ; return ( ( ( len % CHUNK ENC SIZE ) == NUM ) ? ( len / CHUNK ENC SIZE ) : ( ( len / CHUNK ENC SIZE ) + NUM ) ) ; } }
private Set < Pin Swappable > calculate swap pin infos ( ) { Tree Set < Pin Swappable > result = new Tree Set < Pin Swappable > ( ) ; if ( target set == null ) return result ; for ( Brd Item curr item : target set ) { if ( ! ( curr item instanceof Brd Abit Pin ) ) continue ; Brd Abit Pin a pin = ( Brd Abit Pin ) curr item ; Collection < Brd Abit Pin > curr swapppable pins = a pin . get swappable pins ( ) ; for ( Brd Abit Pin curr swappable pin : curr swapppable pins ) { result . add ( new Pin Swappable ( r board , curr swappable pin ) ) ; } } Item Selection Filter selection filter = new Item Selection Filter ( Item Selection Choice . PINS ) ; Collection < Brd Item > picked items = r board . pick items ( prev corner , layer active no , selection filter ) ; for ( Brd Item curr item : picked items ) { if ( ! ( curr item instanceof Brd Abit Pin ) ) continue ; Brd Abit Pin a pin = ( Brd Abit Pin ) curr item ; Collection < Brd Abit Pin > curr swapppable pins = a pin . get swappable pins ( ) ; for ( Brd Abit Pin curr swappable pin : curr swapppable pins ) { result . add ( new Pin Swappable ( r board , curr swappable pin ) ) ; } } return result ; }
@ Override public void run ( int conn Id , String [ ] args ) { if ( ! can Run Restricted Command ( conn Id ) ) { server . send Server Chat ( conn Id , STRING ) ; return ; } if ( args . length > NUM ) { String s Final File = args [ NUM ] ; if ( ! s Final File . ends With ( STRING ) && ! s Final File . ends With ( STRING ) ) { s Final File = s Final File + STRING ; } if ( ! s Final File . ends With ( STRING ) ) { s Final File = s Final File + STRING ; } load ( new File ( STRING , s Final File ) , conn Id ) ; } else { server . send Server Chat ( conn Id , STRING ) ; } }
public String parse DTD Markup ( ) throws IO Exception { String Builder str Buff = new String Builder ( ) ; ch = read Ch ( ) ; while ( BOOL ) { switch ( ch ) { case STRING : ch = read Ch ( ) ; return str Buff . to String ( ) ; case - NUM : error ( STRING ) ; return str Buff . to String ( ) ; case STRING : ln ++ ; ch = read Ch ( ) ; lf Count ++ ; break ; case STRING : ch = read Ch ( ) ; break ; case STRING : ln ++ ; if ( ( ch = read Ch ( ) ) == STRING ) { ch = read Ch ( ) ; crlf Count ++ ; } else { cr Count ++ ; } break ; default : str Buff . append ( ( char ) ( ch & NUM ) ) ; ch = read Ch ( ) ; break ; } } }
public static String display Outputs ( Set < String > output Names , Local Variable Map symbol Table ) { String Builder sb = new String Builder ( ) ; if ( output Names . is Empty ( ) ) { sb . append ( STRING ) ; } else { int count = NUM ; for ( String output Name : output Names ) { sb . append ( STRING ) ; sb . append ( ++ count ) ; sb . append ( STRING ) ; if ( symbol Table . get ( output Name ) != null ) { sb . append ( STRING ) ; sb . append ( determine Output Type As String ( symbol Table , output Name ) ) ; sb . append ( STRING ) ; } sb . append ( output Name ) ; if ( symbol Table . get ( output Name ) != null ) { sb . append ( STRING ) ; sb . append ( symbol Table . get ( output Name ) ) ; } sb . append ( STRING ) ; } } return sb . to String ( ) ; }
public static Generalized Sem Pm serializable Instance ( ) { Dag dag = new Dag ( ) ; Graph Node node 1 = new Graph Node ( STRING ) ; dag . add Node ( node 1 ) ; return new Generalized Sem Pm ( Dag . serializable Instance ( ) ) ; }
public static void drop Temporary Output Tables ( String table , int number Of Partitions , Connection connection ) { table = table . replace ( STRING , STRING ) ; for ( int i = NUM ; i < number Of Partitions ; i ++ ) { String Builder drop Table Query = new String Builder ( ) ; drop Table Query . append ( STRING ) ; drop Table Query . append ( table ) ; drop Table Query . append ( STRING ) ; drop Table Query . append ( i ) ; LOG . info ( STRING ) ; LOG . info ( drop Table Query ) ; execute Statement If Exists ( drop Table Query . to String ( ) , connection ) ; } }
private Segment create Mapped Segment ( Segment Descriptor descriptor ) { File segment File = Segment File . create Segment File ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; Buffer buffer = Mapped Buffer . allocate ( segment File , Math . min ( DEFAULT BUFFER SIZE , descriptor . max Segment Size ( ) ) , Integer . MAX VALUE ) ; descriptor . copy To ( buffer ) ; Segment segment = new Segment ( new Segment File ( segment File ) , buffer . slice ( ) , descriptor , create Index ( descriptor ) , new Offset Predicate ( ) , serializer . clone ( ) , this ) ; LOGGER . debug ( STRING , segment ) ; return segment ; }
private boolean validate Email ( final String email ) { if ( email . is Empty ( ) ) { bad Email Title = STRING ; bad Email Reason = STRING ; return BOOL ; } else { if ( ! email . contains ( STRING ) || ! email . contains ( STRING ) || ( email . length ( ) <= NUM ) ) { bad Email Title = STRING ; bad Email Reason = STRING ; return BOOL ; } } return BOOL ; }
public synchronized boolean retain All ( Collection c ) { Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( len != NUM ) { int newlen = NUM ; Object [ ] temp = new Object [ len ] ; for ( int i = NUM ; i < len ; ++ i ) { Object element = elements [ i ] ; if ( c . contains ( element ) ) temp [ newlen ++ ] = element ; } if ( newlen != len ) { set Array ( copy Of Range ( temp , NUM , newlen , Object [ ] . class ) ) ; return BOOL ; } } return BOOL ; }
private double max Ignore Na N ( double a , double b ) { if ( Double . is Na N ( a ) ) { return b ; } if ( Double . is Na N ( b ) ) { return a ; } return Math . max ( a , b ) ; }
public void crab Down Dir Block For Read ( Block Id blk ) { lock Tbl . s Lock ( blk , tx Num ) ; read Index Blks . add ( blk ) ; }
@ Visible For Testing protected Http URL Connection create Connection ( ) throws Request Failure Exception { try { URL url = new URL ( m Generator . get Server Url ( ) ) ; Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Connect Timeout ( MS CONNECTION TIMEOUT ) ; connection . set Read Timeout ( MS CONNECTION TIMEOUT ) ; return connection ; } catch ( Malformed URL Exception e ) { throw new Request Failure Exception ( STRING , e ) ; } catch ( IO Exception e ) { throw new Request Failure Exception ( STRING , e ) ; } }
public static int find Word Start ( String line , int pos , String no Word Sep ) { char ch = line . char At ( pos - NUM ) ; if ( no Word Sep == null ) no Word Sep = STRING ; boolean select No Letter = ( ! Character . is Letter Or Digit ( ch ) && no Word Sep . index Of ( ch ) == - NUM ) ; int word Start = NUM ; for ( int i = pos - NUM ; i >= NUM ; i -- ) { ch = line . char At ( i ) ; if ( select No Letter ^ ( ! Character . is Letter Or Digit ( ch ) && no Word Sep . index Of ( ch ) == - NUM ) ) { word Start = i + NUM ; break ; } } return word Start ; }
private Map < Location , Abstract State > flatten Art Onto Vpc Locations ( ) { Set Multimap < Location , Abstract State > vpc Sensitive Reached = Hash Multimap . create ( ) ; Deque < Abstract State > worklist = new Linked List < Abstract State > ( ) ; worklist . add ( art . get Root ( ) ) ; Set < Abstract State > visited = new Hash Set < Abstract State > ( ) ; visited . add ( art . get Root ( ) ) ; while ( ! worklist . is Empty ( ) ) { Abstract State head State = worklist . remove First ( ) ; if ( is Vpc State Bot ( head State ) ) continue ; Based Number Element vpc Val = get VPC ( head State ) ; Vpc Location head Vpc Loc = new Vpc Location ( vpc Val , ( RTL Label ) head State . get Location ( ) ) ; vpc Sensitive Reached . put ( head Vpc Loc , head State ) ; Set < Pair < CFA Edge , Abstract State > > successors = art . get Children ( head State ) ; for ( Pair < CFA Edge , Abstract State > s Pair : successors ) { Abstract State next State = s Pair . get Right ( ) ; if ( ! visited . contains ( next State ) ) { visited . add ( next State ) ; worklist . add ( next State ) ; } } } Map < Location , Abstract State > constants = new Hash Map < Location , Abstract State > ( ) ; for ( Location l : vpc Sensitive Reached . key Set ( ) ) { constants . put ( l , Lattices . join All ( vpc Sensitive Reached . get ( l ) ) ) ; } return constants ; }
public void generate ( Batch Environment env , Class Doc input Class , File dest Dir ) { Remote Class remote Class = Remote Class . for Class ( env , input Class ) ; if ( remote Class == null ) { return ; } Stub Skeleton Writer writer = new Stub Skeleton Writer ( env , remote Class , version ) ; File stub File = source File For Class ( writer . stub Class Name ( ) , dest Dir ) ; try { Indenting Writer out = new Indenting Writer ( new Output Stream Writer ( new File Output Stream ( stub File ) ) ) ; writer . write Stub ( out ) ; out . close ( ) ; if ( env . verbose ( ) ) { env . output ( Resources . get Text ( STRING , stub File . get Path ( ) ) ) ; } env . add Generated File ( stub File ) ; } catch ( IO Exception e ) { env . error ( STRING , stub File . to String ( ) ) ; return ; } File skeleton File = source File For Class ( writer . skeleton Class Name ( ) , dest Dir ) ; if ( version == Stub Version . V1 1 || version == Stub Version . VCOMPAT ) { try { Indenting Writer out = new Indenting Writer ( new Output Stream Writer ( new File Output Stream ( skeleton File ) ) ) ; writer . write Skeleton ( out ) ; out . close ( ) ; if ( env . verbose ( ) ) { env . output ( Resources . get Text ( STRING , skeleton File . get Path ( ) ) ) ; } env . add Generated File ( skeleton File ) ; } catch ( IO Exception e ) { env . error ( STRING , skeleton File . to String ( ) ) ; return ; } } else { File skeleton Class File = class File For Class ( writer . skeleton Class Name ( ) , dest Dir ) ; skeleton File . delete ( ) ; skeleton Class File . delete ( ) ; } }
protected void create Entity At ( final String clazz , final int type , final int x , final int y ) { logger . debug ( STRING + clazz + STRING + type + STRING + x + STRING + y ) ; final int ENTRY POINT = NUM ; final int ZONE CHANGE = NUM ; final int DOOR = NUM ; final int PORTAL = NUM ; final int PORTAL STAIRS DOWN = NUM ; final int PORTAL STAIRS UP = NUM ; final int ONE WAY PORTAL DESTINATION = NUM ; try { if ( clazz . contains ( STRING ) ) { switch ( type ) { case ENTRY POINT : case ZONE CHANGE : set Entry Point ( x , y ) ; break ; case ONE WAY PORTAL DESTINATION : case PORTAL STAIRS UP : case PORTAL STAIRS DOWN : create Level Portal At ( type , x , y ) ; break ; case PORTAL : break ; case DOOR : break ; default : logger . error ( STRING + clazz + STRING + type + STRING + x + STRING + y + STRING + get ID ( ) + STRING ) ; break ; } } else if ( clazz . contains ( STRING ) ) { final Sheep sheep = new Sheep ( ) ; sheep . set Position ( x , y ) ; add ( sheep ) ; } else if ( clazz . contains ( STRING ) ) { final Entity Manager manager = Singleton Repository . get Entity Manager ( ) ; if ( manager . is Creature ( clazz , type ) ) { final Creature creature = manager . get Creature ( clazz , type ) ; final Creature Respawn Point point = new Creature Respawn Point ( this , x , y , creature , NUM ) ; add ( point ) ; } else { logger . error ( STRING + clazz + STRING + type + STRING + x + STRING + y + STRING + get ID ( ) + STRING ) ; } } else if ( clazz . contains ( STRING ) ) { final Passive Entity Respawn Point passive Entityrespawn Point = Passive Entity Respawn Point Factory . create ( clazz , type , get ID ( ) , x , y ) ; if ( passive Entityrespawn Point != null ) { passive Entityrespawn Point . set Position ( x , y ) ; add ( passive Entityrespawn Point ) ; passive Entityrespawn Point . set Start State ( ) ; } } } catch ( final Runtime Exception e ) { logger . error ( STRING + type + STRING + x + STRING + y + STRING , e ) ; } }
private byte [ ] add Exif ( byte [ ] jpeg ) { Exif Interface exif = new Exif Interface ( ) ; exif . add Date Time Stamp Tag ( Exif Interface . TAG DATE TIME , System . current Time Millis ( ) , Time Zone . get Default ( ) ) ; Byte Array Output Stream jpeg Out = new Byte Array Output Stream ( ) ; try { exif . write Exif ( jpeg , jpeg Out ) ; } catch ( IO Exception e ) { Log . e ( TAG , STRING , e ) ; } return jpeg Out . to Byte Array ( ) ; }
public static int bytes To Int ( final byte [ ] bytes ) { final Byte Buffer buffer = Byte Buffer . allocate ( NUM ) ; buffer . put ( bytes , NUM , NUM ) ; buffer . flip ( ) ; return buffer . get Int ( ) ; }
@ Override public void mouse Exited ( Mouse Event evt ) { delegate . mouse Moved ( evt ) ; }
public static String remove Formatting ( String line ) { int length = line . length ( ) ; String Buffer buffer = new String Buffer ( ) ; for ( int i = NUM ; i < length ; i ++ ) { char ch = line . char At ( i ) ; if ( ch == STRING || ch == STRING || ch == STRING || ch == STRING ) { } else { buffer . append ( ch ) ; } } return buffer . to String ( ) ; }
private Priority Queue < Facility Charging Price > update Charging Price ( Priority Queue < Facility Charging Price > charging Price ) { while ( last Charging Price Parking Index < max Chargable Energy . size ( ) && get Minimum Energy That Needs To Be Charged ( ) <= NUM ) { charging Price = add New Parking Charging Prices ( last Charging Price Parking Index , charging Price ) ; last Charging Price Parking Index ++ ; } return charging Price ; }
public boolean has Update Listeners ( ) { boolean is Empty = ! listeners . is Empty ( ) ; return is Empty ; }
private void save Memory Block Serialized ( Image Data image Data , File file Serialize ) throws Exception { File Output Stream fos = null ; Object Output Stream oos = null ; try { fos = new File Output Stream ( file Serialize ) ; oos = new Object Output Stream ( fos ) ; oos . write Object ( image Data ) ; add Scan File ( file Serialize ) ; } catch ( Exception e ) { throw e ; } finally { if ( oos != null ) { oos . close ( ) ; } if ( fos != null ) { fos . close ( ) ; } } }
public Service Config create Global Config ( Map attrs ) throws SMS Exception , SSO Exception { validate SSM ( ) ; Service Schema Impl ss = ssm . get Schema ( Schema Type . GLOBAL ) ; if ( ss == null ) { String [ ] args = { service Name } ; throw ( new SMS Exception ( IUMS Constants . UMS BUNDLE NAME , STRING , args ) ) ; } String org DN = scm . construct Service Config DN ( SMS Utils . DEFAULT , Create Service Config . GLOBAL CONFIG NODE , null ) ; try { Create Service Config . create Sub Config Entry ( token , org DN , ss , null , null , attrs , SMS Entry . base DN ) ; } catch ( Service Already Exists Exception slee ) { } return ( get Global Config ( null ) ) ; }
public void edit ID Repo ( String realm Name , String id Repo Name , Map values ) throws AM Console Exception { String [ ] params = { realm Name , id Repo Name } ; log Event ( STRING , params ) ; values . remove ( STRING ) ; try { Service Config Manager svc Cfg Mgr = new Service Config Manager ( Id Constants . REPO SERVICE , get User SSO Token ( ) ) ; Service Config cfg = svc Cfg Mgr . get Organization Config ( realm Name , null ) ; Service Config ss = cfg . get Sub Config ( id Repo Name ) ; ss . set Attributes ( values ) ; log Event ( STRING , params ) ; } catch ( SMS Exception e ) { String str Error = get Error String ( e ) ; String [ ] params Ex = { realm Name , id Repo Name , str Error } ; log Event ( STRING , params Ex ) ; throw new AM Console Exception ( str Error ) ; } catch ( SSO Exception e ) { String str Error = get Error String ( e ) ; String [ ] params Ex = { realm Name , id Repo Name , str Error } ; log Event ( STRING , params Ex ) ; throw new AM Console Exception ( str Error ) ; } }
protected void add Source Code Remark On Attribute ( Test Solution test Solution , Element element , String message Code , String attribute Name ) { if ( attribute Name != null ) { Collection < Evidence Element > evidence Element List = new Array List < > ( ) ; Evidence Element ee = get Evidence Element ( Evidence Store . TARGETTED ELEMENT FROM SCOPE EE , attribute Name ) ; evidence Element List . add ( ee ) ; process Remark Service . add Source Code Remark On Element ( test Solution , element , message Code , evidence Element List ) ; } }
public long [ ] undo ( ) { if ( actions == null ) return null ; Object [ ] action = actions . undo Action ( ) ; if ( action == null ) return null ; commit Changes ( ) ; long [ ] result = null ; @ Suppress Warnings ( STRING ) List < Range > current Action = ( List < Range > ) action [ NUM ] ; if ( action [ NUM ] == Action History . Action Type . DELETE ) { result = insert Ranges ( current Action ) ; } else if ( action [ NUM ] == Action History . Action Type . INSERT ) { result = delete Ranges ( current Action ) ; } else if ( action [ NUM ] == Action History . Action Type . OVERWRITE ) { result = overwrite Ranges ( current Action . sub List ( NUM , current Action . size ( ) - NUM ) ) ; } notify Listeners ( ) ; return result ; }
public Future < Void > update Table Entity Async ( Table Entity table Entity , boolean commit ) { update Table Entity ( table Entity , commit ) ; return new Async Result < Void > ( null ) ; }
private Environment Logger build Parent Tree ( String child Name ) { if ( child Name == null || child Name . equals ( STRING ) ) return null ; int p = child Name . last Index Of ( STRING ) ; String parent Name ; if ( p > NUM ) parent Name = child Name . substring ( NUM , p ) ; else parent Name = STRING ; Environment Logger parent = null ; Soft Reference < Environment Logger > parent Ref = env Loggers . get ( parent Name ) ; if ( parent Ref != null ) parent = parent Ref . get ( ) ; if ( parent != null ) return parent ; else { parent = new Environment Logger ( parent Name , null ) ; env Loggers . put ( parent Name , new Soft Reference < Environment Logger > ( parent ) ) ; Environment Logger grandparent = build Parent Tree ( parent Name ) ; if ( grandparent != null ) parent . set Parent ( grandparent ) ; return parent ; } }
protected void convert From ( Blackboard bb , Sql Node from ) { if ( from == null ) { bb . set Root ( Logical Values . create One Row ( cluster ) , BOOL ) ; return ; } final Sql Call call ; final Sql Node [ ] operands ; switch ( from . get Kind ( ) ) { case AS : convert From ( bb , ( ( Sql Call ) from ) . operand ( NUM ) ) ; return ; case WITH ITEM : convert From ( bb , ( ( Sql With Item ) from ) . query ) ; return ; case WITH : convert From ( bb , ( ( Sql With ) from ) . body ) ; return ; case TABLESAMPLE : operands = ( ( Sql Basic Call ) from ) . get Operands ( ) ; Sql Sample Spec sample Spec = Sql Literal . sample Value ( operands [ NUM ] ) ; if ( sample Spec instanceof Sql Sample Spec . Sql Substitution Sample Spec ) { String sample Name = ( ( Sql Sample Spec . Sql Substitution Sample Spec ) sample Spec ) . get Name ( ) ; dataset Stack . push ( sample Name ) ; convert From ( bb , operands [ NUM ] ) ; dataset Stack . pop ( ) ; } else if ( sample Spec instanceof Sql Sample Spec . Sql Table Sample Spec ) { Sql Sample Spec . Sql Table Sample Spec table Sample Spec = ( Sql Sample Spec . Sql Table Sample Spec ) sample Spec ; convert From ( bb , operands [ NUM ] ) ; Rel Opt Sampling Parameters params = new Rel Opt Sampling Parameters ( table Sample Spec . is Bernoulli ( ) , table Sample Spec . get Sample Percentage ( ) , table Sample Spec . is Repeatable ( ) , table Sample Spec . get Repeatable Seed ( ) ) ; bb . set Root ( new Sample ( cluster , bb . root , params ) , BOOL ) ; } else { throw Util . new Internal ( STRING + sample Spec ) ; } return ; case IDENTIFIER : final Sql Validator Namespace from Namespace = validator . get Namespace ( from ) . resolve ( ) ; if ( from Namespace . get Node ( ) != null ) { convert From ( bb , from Namespace . get Node ( ) ) ; return ; } final String dataset Name = dataset Stack . is Empty ( ) ? null : dataset Stack . peek ( ) ; boolean [ ] used Dataset = { BOOL } ; Rel Opt Table table = Sql Validator Util . get Rel Opt Table ( from Namespace , catalog Reader , dataset Name , used Dataset ) ; final Rel Node table Rel ; if ( should Convert Table Access ) { table Rel = to Rel ( table ) ; } else { table Rel = Logical Table Scan . create ( cluster , table ) ; } bb . set Root ( table Rel , BOOL ) ; if ( used Dataset [ NUM ] ) { bb . set Dataset ( dataset Name ) ; } return ; case JOIN : final Sql Join join = ( Sql Join ) from ; final Sql Validator Scope scope = validator . get Join Scope ( from ) ; final Blackboard from Blackboard = create Blackboard ( scope , null , BOOL ) ; Sql Node left = join . get Left ( ) ; Sql Node right = join . get Right ( ) ; final boolean is Natural = join . is Natural ( ) ; final Join Type join Type = join . get Join Type ( ) ; final Sql Validator Scope left Scope = Util . first ( validator . get Join Scope ( left ) , ( ( Delegating Scope ) bb . scope ) . get Parent ( ) ) ; final Blackboard left Blackboard = create Blackboard ( left Scope , null , BOOL ) ; final Sql Validator Scope right Scope = Util . first ( validator . get Join Scope ( right ) , ( ( Delegating Scope ) bb . scope ) . get Parent ( ) ) ; final Blackboard right Blackboard = create Blackboard ( right Scope , null , BOOL ) ; convert From ( left Blackboard , left ) ; Rel Node left Rel = left Blackboard . root ; convert From ( right Blackboard , right ) ; Rel Node right Rel = right Blackboard . root ; Join Rel Type converted Join Type = convert Join Type ( join Type ) ; Rex Node condition Exp ; final Sql Validator Namespace left Namespace = validator . get Namespace ( left ) ; final Sql Validator Namespace right Namespace = validator . get Namespace ( right ) ; if ( is Natural ) { final Rel Data Type left Row Type = left Namespace . get Row Type ( ) ; final Rel Data Type right Row Type = right Namespace . get Row Type ( ) ; final List < String > column List = Sql Validator Util . derive Natural Join Column List ( left Row Type , right Row Type ) ; condition Exp = convert Using ( left Namespace , right Namespace , column List ) ; } else { condition Exp = convert Join Condition ( from Blackboard , left Namespace , right Namespace , join . get Condition ( ) , join . get Condition Type ( ) , left Rel , right Rel ) ; } final Rel Node join Rel = create Join ( from Blackboard , left Rel , right Rel , condition Exp , converted Join Type ) ; bb . set Root ( join Rel , BOOL ) ; return ; case SELECT : case INTERSECT : case EXCEPT : case UNION : final Rel Node rel = convert Query Recursive ( from , BOOL , null ) . project ( ) ; bb . set Root ( rel , BOOL ) ; return ; case VALUES : convert Values Impl ( bb , ( Sql Call ) from , null ) ; return ; case UNNEST : call = ( Sql Call ) from ; final List < Sql Node > nodes = call . get Operand List ( ) ; final Sql Unnest Operator operator = ( Sql Unnest Operator ) call . get Operator ( ) ; for ( Sql Node node : nodes ) { replace Subqueries ( bb , node , Rel Opt Util . Logic . TRUE FALSE UNKNOWN ) ; } final List < Rex Node > exprs = new Array List < > ( ) ; final List < String > field Names = new Array List < > ( ) ; for ( Ord < Sql Node > node : Ord . zip ( nodes ) ) { exprs . add ( bb . convert Expression ( node . e ) ) ; field Names . add ( validator . derive Alias ( node . e , node . i ) ) ; } final Rel Node input = Rel Opt Util . create Project ( ( null != bb . root ) ? bb . root : Logical Values . create One Row ( cluster ) , exprs , field Names , BOOL ) ; Uncollect uncollect = new Uncollect ( cluster , cluster . trait Set Of ( Convention . NONE ) , input , operator . with Ordinality ) ; bb . set Root ( uncollect , BOOL ) ; return ; case COLLECTION TABLE : call = ( Sql Call ) from ; assert call . get Operand List ( ) . size ( ) == NUM ; final Sql Call call 2 = call . operand ( NUM ) ; convert Collection Table ( bb , call 2 ) ; return ; default : throw Util . new Internal ( STRING + from ) ; } }
private void determine Available Sample Rates ( ) throws Lib Usb Exception , Usb Exception { m Sample Rates . clear ( ) ; try { byte [ ] raw Count = read Array ( Command . GET SAMPLE RATES , NUM , NUM , NUM ) ; if ( raw Count != null ) { int count = Endian Utils . read Swapped Integer ( raw Count , NUM ) ; byte [ ] raw Rates = read Array ( Command . GET SAMPLE RATES , NUM , count , ( count * NUM ) ) ; for ( int x = NUM ; x < count ; x ++ ) { int rate = Endian Utils . read Swapped Integer ( raw Rates , ( x * NUM ) ) ; m Sample Rates . add ( new Airspy Sample Rate ( x , rate , format Sample Rate ( rate ) ) ) ; } } } catch ( Lib Usb Exception e ) { } if ( m Sample Rates . is Empty ( ) ) { m Sample Rates . add ( DEFAULT SAMPLE RATE ) ; } }
public void start ( ) throws IO Exception { this . is Running = BOOL ; Thread thread = new Thread ( this ) ; thread . set Daemon ( BOOL ) ; thread . set Name ( STRING ) ; thread . set Priority ( Thread . MAX PRIORITY ) ; thread . start ( ) ; }
static byte [ ] append Data ( byte [ ] binary data , final byte [ ] decoded stream data ) { if ( decoded stream data != null ) { final int current length = binary data . length + NUM ; int processed length = decoded stream data . length ; if ( processed length > NUM ) { while ( decoded stream data [ processed length - NUM ] == NUM ) { processed length -- ; } final byte [ ] temp = new byte [ current length ] ; System . arraycopy ( binary data , NUM , temp , NUM , current length - NUM ) ; temp [ current length - NUM ] = STRING ; binary data = new byte [ current length + processed length ] ; System . arraycopy ( temp , NUM , binary data , NUM , current length ) ; System . arraycopy ( decoded stream data , NUM , binary data , current length , processed length ) ; } } return binary data ; }
private String build Virtual Volume Name ( List < String > native Volume Names ) { s logger . info ( STRING ) ; String Builder name Builder = new String Builder ( ) ; if ( native Volume Names . size ( ) == NUM ) { name Builder . append ( V Plex Api Constants . DEVICE PREFIX ) ; name Builder . append ( native Volume Names . get ( NUM ) ) ; name Builder . append ( V Plex Api Constants . VIRTUAL VOLUME SUFFIX ) ; } else { name Builder . append ( V Plex Api Constants . DIST DEVICE PREFIX ) ; for ( String native Volume Name : native Volume Names ) { name Builder . append ( V Plex Api Constants . DIST DEVICE NAME DELIM ) ; name Builder . append ( native Volume Name ) ; } name Builder . append ( V Plex Api Constants . VIRTUAL VOLUME SUFFIX ) ; } s logger . info ( STRING , name Builder . to String ( ) ) ; return name Builder . to String ( ) ; }
protected static String serialize DOM Source ( DOM Source dom Source ) { try { String Writer writer = new String Writer ( ) ; Stream Result result = new Stream Result ( writer ) ; Transformer Factory tf = Transformer Factory . new Instance ( ) ; Transformer transformer = tf . new Transformer ( ) ; transformer . set Output Property ( Output Keys . ENCODING , DEFAULT ENCODING ) ; transformer . set Output Property ( Output Keys . INDENT , DEFAULT INDENT ) ; transformer . transform ( dom Source , result ) ; writer . flush ( ) ; return writer . to String ( ) ; } catch ( Throwable e ) { log . log ( Level . SEVERE , STRING , e ) ; } return null ; }
public List < Server Address > addresses ( ) { return addresses ; }
public static Boolean String To Boolean ( String str ) throws Exception { if ( str == null ) { return null ; } if ( str . equals ( STRING ) || str . equals ( STRING ) ) { return Boolean . TRUE ; } if ( str . equals ( STRING ) || str . equals ( STRING ) ) { return Boolean . FALSE ; } throw new Exception ( ) ; }
public static byte [ ] instrument ( byte [ ] original Bytes , String recorder Class , String recorder Method , Class Loader loader ) { try { Class Reader cr = new Class Reader ( original Bytes ) ; Class Writer cw = new Static Class Writer ( cr , Class Writer . COMPUTE FRAMES , loader ) ; Verifying Class Adapter vcw = new Verifying Class Adapter ( cw , original Bytes , cr . get Class Name ( ) ) ; Class Visitor adapter = new Allocation Class Adapter ( vcw , recorder Class , recorder Method ) ; cr . accept ( adapter , Class Reader . SKIP FRAMES ) ; return vcw . to Byte Array ( ) ; } catch ( Runtime Exception e ) { logger . log ( Level . WARNING , STRING , e ) ; throw e ; } catch ( Error e ) { logger . log ( Level . WARNING , STRING , e ) ; throw e ; } }
private boolean use Advanced Anti Aliasing ( Map < String , Object > args ) throws Transcoder Exception { boolean use Advanced = BOOL ; boolean flash Type As Name = BOOL ; String advanced Str = ( String ) args . get ( ADVANTIALIASING ) ; if ( advanced Str == null ) { advanced Str = ( String ) args . get ( FLASHTYPE ) ; } else { flash Type As Name = BOOL ; } if ( advanced Str != null ) { if ( advanced Str . equals Ignore Case ( STRING ) ) { use Advanced = BOOL ; } else if ( advanced Str . equals Ignore Case ( STRING ) ) { use Advanced = BOOL ; } else if ( flash Type As Name ) { throw new Bad Flash Type ( ) ; } else { throw new Bad Advanced Anti Aliasing ( ) ; } } else { use Advanced = fonts Config . get Flash Type ( ) ; } return use Advanced ; }
public static void main ( String [ ] args ) { main ( suite ( ) , args ) ; }
@ Override public boolean has Feature ( String feature , String version ) { boolean result = super . has Feature ( feature , version ) ; if ( ! result ) { boolean any Version = version == null || version . length ( ) == NUM ; if ( feature . starts With ( STRING ) ) { feature = feature . substring ( NUM ) ; } return ( ( feature . equals Ignore Case ( STRING ) && ( any Version || version . equals ( STRING ) ) ) || ( feature . equals Ignore Case ( STRING ) && ( any Version || version . equals ( STRING ) ) ) || ( feature . equals Ignore Case ( STRING ) && ( any Version || version . equals ( STRING ) ) ) || ( feature . equals Ignore Case ( STRING ) && ( any Version || version . equals ( STRING ) ) ) || ( feature . equals Ignore Case ( STRING ) && ( any Version || version . equals ( STRING ) ) ) ) ; } return result ; }
public boolean run ( ) { try { if ( m Executor . is Shutdown ( ) || m Executor . is Terminated ( ) ) { Log . e ( TAG , STRING ) ; m Executor = Executors . new Single Thread Executor ( ) ; } for ( Task task : tasks ) { final Thread Runnable thread Runnable = new Thread Runnable ( task ) ; final Future future = m Executor . submit ( thread Runnable ) ; runable Map . put ( thread Runnable , future ) ; } tasks . clear ( ) ; } catch ( Exception Rejected Execution Exception ) { Log . e ( TAG , STRING , Rejected Execution Exception ) ; return BOOL ; } return BOOL ; }
private synchronized void update Thread Panel ( boolean force Update ) { if ( ! force Update && ! is Visible ( ) ) { return ; } thread Panel . remove All ( ) ; Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . gridx = NUM ; gbc . gridy = NUM ; gbc . weightx = NUM ; gbc . weighty = NUM ; gbc . fill = Grid Bag Constraints . HORIZONTAL ; gbc . ipady = NUM ; for ( Progress Thread current Thread : Progress Thread . get Current Threads ( ) ) { Progress Thread Display pg Panel = new Progress Thread Display ( current Thread , BOOL ) ; thread Panel . add ( pg Panel , gbc ) ; MAPPING PG TO UI . put ( current Thread , pg Panel ) ; update Progress Message ( current Thread ) ; update Progress ( current Thread ) ; gbc . gridy += NUM ; } for ( Progress Thread queued Thread : Progress Thread . get Queued Threads ( ) ) { Progress Thread Display pg Panel = new Progress Thread Display ( queued Thread , BOOL ) ; thread Panel . add ( pg Panel , gbc ) ; MAPPING PG TO UI . put ( queued Thread , pg Panel ) ; gbc . gridy += NUM ; } gbc . gridy += NUM ; gbc . weighty = NUM ; gbc . fill = Grid Bag Constraints . BOTH ; thread Panel . add ( new J Label ( ) , gbc ) ; thread Panel . revalidate ( ) ; thread Panel . repaint ( ) ; }
private static short Call Nonvirtual Short Method V ( JNI Environment env , int obj JREF , int class JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object obj = env . get JNI Ref ( obj JREF ) ; Object return Obj = JNI Helpers . invoke With Var Arg ( obj , method ID , arg Address , Type Reference . Short , BOOL ) ; return Reflection . unwrap Short ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
public static void draw Horizontal Margin Indicator ( Graphics 2 D g , String text , int x1 , int x2 , int y ) { if ( x1 > x2 ) { int temp = x1 ; x1 = x2 ; x2 = temp ; } if ( text == null ) { g . draw Line ( x1 , y , x2 , y ) ; g . draw Line ( x1 , y , x1 + CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x1 , y , x1 + CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; g . draw Line ( x2 , y , x2 - CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x2 , y , x2 - CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; return ; } Canvas c = new Canvas ( ) ; Font Metrics fm = c . get Font Metrics ( s Font ) ; g . set Font ( s Font ) ; int padding = NUM ; Rectangle 2 D bounds = fm . get String Bounds ( text , g ) ; int th = ( int ) bounds . get Height ( ) ; int tw = ( int ) bounds . get Width ( ) ; int offset = NUM * CONNECTION ARROW SIZE ; int w = ( ( x2 - x1 ) - ( tw + NUM * padding ) ) / NUM ; if ( w <= padding ) { g . draw Line ( x1 , y , x2 , y ) ; g . draw String ( text , x1 + w + padding , y + offset ) ; g . draw Line ( x1 , y - CONNECTION ARROW SIZE , x1 , y + CONNECTION ARROW SIZE ) ; g . draw Line ( x2 , y - CONNECTION ARROW SIZE , x2 , y + CONNECTION ARROW SIZE ) ; } else { g . draw Line ( x1 , y , x1 + w , y ) ; g . draw Line ( x2 - w , y , x2 , y ) ; g . draw String ( text , x1 + w + padding , ( int ) ( y + ( bounds . get Height ( ) / NUM ) ) ) ; g . draw Line ( x1 , y , x1 + CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x1 , y , x1 + CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; g . draw Line ( x2 , y , x2 - CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x2 , y , x2 - CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; } }
protected void remove Background ( Positionable Label b ) { for ( int i = NUM ; i < background Image . size ( ) ; i ++ ) { if ( b == background Image . get ( i ) ) { background Image . remove ( i ) ; set Dirty ( BOOL ) ; return ; } } }
int parse Tr Block Content ( int current Offset , char open Quote , char close Quote ) { int block Start Offset = current Offset ; Char Sequence buffer = get Buffer ( ) ; int buffer End = get Buffer End ( ) ; boolean is Escaped = BOOL ; boolean is Quote Differs = open Quote != close Quote ; int quotes Level = NUM ; while ( current Offset < buffer End ) { char current Char = buffer . char At ( current Offset ) ; if ( ! is Escaped && quotes Level == NUM && current Char == close Quote ) { if ( current Offset > block Start Offset ) { push Preparsed Token ( block Start Offset , current Offset , STRING CONTENT ) ; } break ; } if ( is Quote Differs && ! is Escaped ) { if ( current Char == open Quote ) { quotes Level ++ ; } else if ( current Char == close Quote ) { quotes Level -- ; } } is Escaped = ( current Char == STRING && ! is Escaped ) ; current Offset ++ ; } return current Offset ; }
public static String format Integer If Possible ( double value , int number Of Digits , boolean grouping Character ) { if ( Double . is Na N ( value ) ) { return STRING ; } if ( Double . is Infinite ( value ) ) { if ( value < NUM ) { return STRING + FORMAT SYMBOLS . get Infinity ( ) ; } else { return FORMAT SYMBOLS . get Infinity ( ) ; } } long long Value = Math . round ( value ) ; if ( Math . abs ( long Value - value ) < epsilon Display Value ) { INTEGER FORMAT . set Grouping Used ( grouping Character ) ; return INTEGER FORMAT . format ( value ) ; } return format Number ( value , number Of Digits , grouping Character ) ; }
@ Nullable private Grid Rest Request create Rest Request ( Grid Nio Session ses , Grid Client Message msg ) { Grid Rest Request rest Req = null ; if ( msg instanceof Grid Client Authentication Request ) { Grid Client Authentication Request req = ( Grid Client Authentication Request ) msg ; rest Req = new Grid Rest Task Request ( ) ; rest Req . command ( NOOP ) ; rest Req . credentials ( req . credentials ( ) ) ; } else if ( msg instanceof Grid Client Cache Request ) { Grid Client Cache Request req = ( Grid Client Cache Request ) msg ; Grid Rest Cache Request rest Cache Req = new Grid Rest Cache Request ( ) ; rest Cache Req . cache Name ( req . cache Name ( ) ) ; rest Cache Req . cache Flags ( req . cache Flags On ( ) ) ; rest Cache Req . key ( req . key ( ) ) ; rest Cache Req . value ( req . value ( ) ) ; rest Cache Req . value 2 ( req . value 2 ( ) ) ; Map vals = req . values ( ) ; if ( vals != null ) rest Cache Req . values ( new Hash Map < Object , Object > ( vals ) ) ; rest Cache Req . command ( cache Cmd Map . get ( req . operation ( ) ) ) ; rest Req = rest Cache Req ; } else if ( msg instanceof Grid Client Task Request ) { Grid Client Task Request req = ( Grid Client Task Request ) msg ; Grid Rest Task Request rest Task Req = new Grid Rest Task Request ( ) ; rest Task Req . command ( EXE ) ; rest Task Req . task Name ( req . task Name ( ) ) ; rest Task Req . params ( Arrays . as List ( req . argument ( ) ) ) ; rest Req = rest Task Req ; } else if ( msg instanceof Grid Client Topology Request ) { Grid Client Topology Request req = ( Grid Client Topology Request ) msg ; Grid Rest Topology Request rest Top Req = new Grid Rest Topology Request ( ) ; rest Top Req . include Metrics ( req . include Metrics ( ) ) ; rest Top Req . include Attributes ( req . include Attributes ( ) ) ; if ( req . node Id ( ) != null ) { rest Top Req . command ( NODE ) ; rest Top Req . node Id ( req . node Id ( ) ) ; } else if ( req . node Ip ( ) != null ) { rest Top Req . command ( NODE ) ; rest Top Req . node Ip ( req . node Ip ( ) ) ; } else rest Top Req . command ( TOPOLOGY ) ; rest Req = rest Top Req ; } if ( rest Req != null ) { rest Req . destination Id ( msg . destination Id ( ) ) ; rest Req . client Id ( msg . client Id ( ) ) ; rest Req . session Token ( msg . session Token ( ) ) ; rest Req . address ( ses . remote Address ( ) ) ; } return rest Req ; }
public void initialize ( Context context , Haptic Feedback Controller haptic Feedback Controller , int initial Hours Of Day , int initial Minutes , boolean is 24 Hour Mode ) { if ( m Time Initialized ) { Log . e ( TAG , STRING ) ; return ; } m Haptic Feedback Controller = haptic Feedback Controller ; m Is 24 Hour Mode = is 24 Hour Mode ; m Hide Am Pm = m Accessibility Manager . is Touch Exploration Enabled ( ) || m Is 24 Hour Mode ; m Circle View . initialize ( context , m Hide Am Pm ) ; m Circle View . invalidate ( ) ; if ( ! m Hide Am Pm ) { m Am Pm Circles View . initialize ( context , initial Hours Of Day < NUM ? AM : PM ) ; m Am Pm Circles View . invalidate ( ) ; } Resources res = context . get Resources ( ) ; int [ ] hours = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int [ ] hours 24 = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int [ ] minutes = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; String [ ] hours Texts = new String [ NUM ] ; String [ ] inner Hours Texts = new String [ NUM ] ; String [ ] minutes Texts = new String [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { hours Texts [ i ] = Language Utils . get Persian Numbers ( is 24 Hour Mode ? String . format ( STRING , hours 24 [ i ] ) : String . format ( STRING , hours [ i ] ) ) ; inner Hours Texts [ i ] = Language Utils . get Persian Numbers ( String . format ( STRING , hours [ i ] ) ) ; minutes Texts [ i ] = Language Utils . get Persian Numbers ( String . format ( STRING , minutes [ i ] ) ) ; } m Hour Radial Texts View . initialize ( res , hours Texts , ( is 24 Hour Mode ? inner Hours Texts : null ) , m Hide Am Pm , BOOL ) ; m Hour Radial Texts View . set Selection ( is 24 Hour Mode ? initial Hours Of Day : initial Hours Of Day % NUM ) ; m Hour Radial Texts View . invalidate ( ) ; m Minute Radial Texts View . initialize ( res , minutes Texts , null , m Hide Am Pm , BOOL ) ; m Minute Radial Texts View . set Selection ( initial Minutes ) ; m Minute Radial Texts View . invalidate ( ) ; set Value For Item ( HOUR INDEX , initial Hours Of Day ) ; set Value For Item ( MINUTE INDEX , initial Minutes ) ; int hour Degrees = ( initial Hours Of Day % NUM ) * HOUR VALUE TO DEGREES STEP SIZE ; m Hour Radial Selector View . initialize ( context , m Hide Am Pm , is 24 Hour Mode , BOOL , hour Degrees , is Hour Inner Circle ( initial Hours Of Day ) ) ; int minute Degrees = initial Minutes * MINUTE VALUE TO DEGREES STEP SIZE ; m Minute Radial Selector View . initialize ( context , m Hide Am Pm , BOOL , BOOL , minute Degrees , BOOL ) ; m Time Initialized = BOOL ; }
protected void linear Layout ( Visual Table labels ) { Rectangle 2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; double span = m hi - m lo ; double pspan = m prevhi - m prevlo ; double vlo = NUM ; if ( m lo >= NUM ) { vlo = Math . pow ( NUM , Math . floor ( Math Lib . log 10 ( m lo ) ) ) ; } else { vlo = - Math . pow ( NUM , NUM + Math . floor ( Math Lib . log 10 ( - m lo ) ) ) ; } Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) { Visual Item item = ( Visual Item ) iter . next ( ) ; reset ( item ) ; double v = item . get Double ( VALUE ) ; double x = span == NUM ? NUM : ( ( v - m lo ) / span ) * breadth ; set ( item , x , b ) ; } Index index = labels . index ( VALUE ) ; double step = get Linear Step ( span , span == NUM ? NUM : breadth / span ) ; if ( step == NUM ) step = NUM ; int r ; for ( double x , v = vlo ; v <= m hi ; v += step ) { x = ( ( v - m lo ) / span ) * breadth ; if ( x < - NUM ) { continue ; } else if ( ( r = index . get ( v ) ) >= NUM ) { Visual Item item = labels . get Item ( r ) ; item . set Visible ( BOOL ) ; item . set End Visible ( BOOL ) ; } else { Visual Item item = labels . add Item ( ) ; item . set ( LABEL , m nf . format ( v ) ) ; item . set Double ( VALUE , v ) ; double f = pspan == NUM ? NUM : ( ( v - m prevlo ) / pspan ) ; if ( f <= NUM || f >= NUM ) item . set Start Visible ( BOOL ) ; set ( item , f * breadth , b ) ; set ( item , x , b ) ; } } }
private Template Value template Value ( String value ) { Template Value template Val = new Template File . Template Value ( null ) ; template Val . append ( value ) ; return template Val ; }
public static String truncate Custom Status ( String custom Status ) { if ( custom Status == null ) { return custom Status ; } return custom Status . length ( ) > CUSTOM STATUS SIZE BYTES ? custom Status . substring ( NUM , CUSTOM STATUS SIZE BYTES ) : custom Status ; }
private void update Zoning Map ( Un Managed Export Mask mask , List < com . emc . storageos . db . client . model . Initiator > initiators , List < com . emc . storageos . db . client . model . Storage Port > storage Ports ) { Zone Info Map zoning Map = network Device Controller . get Initiators Zone Info Map ( initiators , storage Ports ) ; for ( Zone Info zone Info : zoning Map . values ( ) ) { log . info ( STRING , zone Info . get Zone Name ( ) , zone Info . get Initiator Wwn ( ) , zone Info . get Port Wwn ( ) ) ; } mask . set Zoning Map ( zoning Map ) ; }
public static boolean is Extension ( String filename , Collection < String > extensions ) { if ( filename == null ) { return BOOL ; } if ( extensions == null || extensions . is Empty ( ) ) { return index Of Extension ( filename ) == - NUM ; } String file Ext = get Extension ( filename ) ; for ( String extension : extensions ) { if ( file Ext . equals ( extension ) ) { return BOOL ; } } return BOOL ; }
private void write Directory Post Resource ( String Builder sb , String path ) { sb . append ( STRING + DIR RESOURCE SET + STRING ) ; sb . append ( path . replace ( STRING , STRING ) ) ; }
public static void write To File ( String file Name , String content ) throws IO Exception { File Writer file Writer = null ; try { file Writer = new File Writer ( file Name ) ; file Writer . write ( content ) ; } finally { close If Not Null ( file Writer ) ; } }
abstract < E > void dispatch ( Event Listener < E > listener , E event ) ;
private Job Store ( Context context , File data Dir ) { m Context = context ; m Dirty Operations = NUM ; File system Dir = new File ( data Dir , STRING ) ; File job Dir = new File ( system Dir , STRING ) ; job Dir . mkdirs ( ) ; m Jobs File = new Atomic File ( new File ( job Dir , STRING ) ) ; m Job Set = new Array Set < Job Status > ( ) ; read Job Map From Disk ( m Job Set ) ; }
public void text ( int [ ] glyph Indices , int [ ] glyph Advances ) { int [ ] codes = ( int [ ] ) font Codes . get ( font Id ) ; if ( codes == null ) { return ; } char [ ] chars = new char [ glyph Indices . length ] ; for ( int i = NUM ; i < chars . length ; i ++ ) { int index = glyph Indices [ i ] ; if ( index >= codes . length ) { chars [ i ] = ( char ) index ; } else { chars [ i ] = ( char ) ( codes [ index ] ) ; } } output . print ( chars ) ; }
private Set < Integer > compute Id 2 Data Rec ( int number Of Data Sets , Node v , Map < Integer , Integer [ ] > id 2 counts , Map < Integer , Set < Integer > > id 2 ids Below , Map < Integer , Node Data > id 2 data ) { final int id = ( Integer ) v . get Info ( ) ; final Set < Integer > ids Below = new Hash Set < > ( ) ; id 2 ids Below . put ( id , ids Below ) ; ids Below . add ( id ) ; for ( Edge e = v . get First Out Edge ( ) ; e != null ; e = v . get Next Out Edge ( e ) ) { Node w = e . get Target ( ) ; final Set < Integer > all Below = compute Id 2 Data Rec ( number Of Data Sets , w , id 2 counts , id 2 ids Below , id 2 data ) ; ids Below . add All ( all Below ) ; } int [ ] assigned = new int [ number Of Data Sets ] ; int [ ] summarized = new int [ number Of Data Sets ] ; long total = NUM ; final Integer [ ] counts = id 2 counts . get ( id ) ; if ( counts != null ) { int top = Math . min ( assigned . length , counts . length ) ; for ( int i = NUM ; i < top ; i ++ ) { if ( counts [ i ] != null ) { assigned [ i ] = counts [ i ] ; total += counts [ i ] ; } } } for ( Integer below : id 2 ids Below . get ( id ) ) { Integer [ ] count Below = id 2 counts . get ( below ) ; if ( count Below != null ) { int top = Math . min ( summarized . length , count Below . length ) ; for ( int i = NUM ; i < top ; i ++ ) { if ( count Below [ i ] != null ) { summarized [ i ] += count Below [ i ] ; total += count Below [ i ] ; } } } } if ( total > NUM ) id 2 data . put ( id , new Node Data ( assigned , summarized ) ) ; return ids Below ; }
public void remove Method ( Soot Method m ) { check Level ( SIGNATURES ) ; if ( ! m . is Declared ( ) || m . get Declaring Class ( ) != this ) throw new Runtime Exception ( STRING + m . get Name ( ) ) ; if ( sub Sig To Methods . get ( m . get Numbered Sub Signature ( ) ) == null ) { throw new Runtime Exception ( STRING + m . get Sub Signature ( ) + STRING + this ) ; } sub Sig To Methods . put ( m . get Numbered Sub Signature ( ) , null ) ; method List . remove ( m ) ; m . set Declared ( BOOL ) ; }
public Operation remove Pragma Directive ( String directive ) { String existing Directives = get Request Header ( PRAGMA HEADER ) ; if ( existing Directives != null ) { directive = existing Directives . replace ( directive , STRING ) ; add Request Header ( PRAGMA HEADER , directive ) ; } return this ; }
public void close ( ) throws Illegal State Exception { synchronized ( Splash Screen . class ) { check Visible ( ) ; close ( splash Ptr ) ; image = null ; Splash Screen . mark Closed ( ) ; } }
protected int decode Line Prefix ( Pushback Input Stream in Stream , Output Stream out Stream ) throws IO Exception { int c ; c = in Stream . read ( ) ; if ( c == STRING ) { c = in Stream . read ( ) ; c = in Stream . read ( ) ; if ( ( c != STRING ) && ( c != - NUM ) ) in Stream . unread ( c ) ; throw new CE Stream Exhausted ( ) ; } else if ( c == - NUM ) { throw new CE Format Exception ( STRING ) ; } c = ( c - STRING ) & NUM ; if ( c > bytes Per Line ( ) ) { throw new CE Format Exception ( STRING ) ; } return ( c ) ; }
protected void re Init ( ) { if ( is Logging Enabled ( ) ) stack Logger . log Debug ( STRING ) ; message Processors = new Array List < Message Processor > ( ) ; this . io Handler = new IO Handler ( this ) ; pending Transactions = new Concurrent Hash Map < String , SIP Server Transaction > ( ) ; client Transaction Table = new Concurrent Hash Map < String , SIP Client Transaction > ( ) ; server Transaction Table = new Concurrent Hash Map < String , SIP Server Transaction > ( ) ; retransmission Alert Transactions = new Concurrent Hash Map < String , SIP Server Transaction > ( ) ; merge Table = new Concurrent Hash Map < String , SIP Server Transaction > ( ) ; this . dialog Table = new Concurrent Hash Map < String , SIP Dialog > ( ) ; this . early Dialog Table = new Concurrent Hash Map < String , SIP Dialog > ( ) ; this . terminated Server Transactions Pending Ack = new Concurrent Hash Map < String , SIP Server Transaction > ( ) ; this . forked Client Transaction Table = new Concurrent Hash Map < String , SIP Client Transaction > ( ) ; this . timer = new Timer ( ) ; this . active Client Transaction Count = new Atomic Integer ( NUM ) ; }
public boolean is IPC Method ( Soot Method method ) { return ipc Methods . contains Poly ( method ) ; }
protected Q Name push Q Name ( String local Name , String qualified Name , Namespace namespace , String prefix ) { if ( ( prefix == null ) || ( prefix . length ( ) == NUM ) ) { this . default Namespace = null ; } return create Q Name ( local Name , qualified Name , namespace ) ; }
public String product ( Properties ctx , int Window No , Grid Tab m Tab , Grid Field m Field , Object value ) { Integer M Product ID = ( Integer ) value ; if ( M Product ID == null || M Product ID . int Value ( ) == NUM ) return STRING ; final I M Requisition req = Grid Tab Wrapper . create ( m Tab . get Parent Tab ( ) , I M Requisition . class ) ; final I M Requisition Line line = Grid Tab Wrapper . create ( m Tab , I M Requisition Line . class ) ; set Price ( ctx , Window No , req , line ) ; M Product product = M Product . get ( ctx , M Product ID ) ; line . set C UOM ID ( product . get C UOM ID ( ) ) ; line . set M Attribute Set Instance ID ( product . get M Attribute Set Instance ID ( ) ) ; return STRING ; }
private void rewrite Save File ( Iterable < Track Point > data ) { File Output Stream file Output = null ; Data Output Stream out = null ; try { file Output = ctx . open File Output ( SAVEFILE , Context . MODE PRIVATE ) ; out = new Data Output Stream ( new Buffered Output Stream ( file Output ) ) ; out . write Int ( Track Point . FORMAT VERSION ) ; for ( Track Point point : data ) { point . to Stream ( out ) ; } } catch ( Exception e ) { mark Saving Broken ( STRING , e ) ; } finally { Saving Helper . close ( out ) ; } }
public void test new Tx read Only release Time Respects Reads On Commit Time ( ) throws IO Exception { final Properties p = new Properties ( ) ; p . set Property ( Abstract Transaction Service . Options . MIN RELEASE AGE , STRING ) ; final Mock Transaction Service service = new Fixture ( p ) ; try { assert Equals ( NUM , service . get Min Release Age ( ) ) ; final long old Release Time = service . get Release Time ( ) ; assert Equals ( NUM , old Release Time ) ; final long tx 0 = service . new Tx ( I Tx . UNISOLATED ) ; final Tx State tx State 0 = service . get Tx State ( tx 0 ) ; final long ts = service . next Timestamp ( ) ; assert True ( ts > Math . abs ( tx 0 ) ) ; final long tx 1 = service . new Tx ( I Tx . UNISOLATED ) ; final Tx State tx State 1 = service . get Tx State ( tx 0 ) ; assert True ( ts < Math . abs ( tx 1 ) ) ; assert Equals ( tx State 0 . get Reads On Commit Time ( ) , tx State 1 . get Reads On Commit Time ( ) ) ; service . commit ( tx 0 ) ; final long new Release Time = service . get Release Time ( ) ; assert Equals ( old Release Time , new Release Time ) ; service . new Tx ( ts ) ; } finally { service . destroy ( ) ; } }
@ Override public void stop ( Runnable callback ) { stop ( ) ; callback . run ( ) ; }
protected int read ( Input Stream input Stream , byte [ ] buffer , char [ ] divider ) throws IO Exception { int index = NUM ; int divider Index = NUM ; do { byte read Byte = ( byte ) ( NUM & input Stream . read ( ) ) ; if ( read Byte == - NUM ) { return index ; } if ( read Byte == divider [ divider Index ] ) { divider Index ++ ; } if ( divider Index == divider . length ) { index -= divider Index - NUM ; for ( int i = index ; i < index + divider Index ; i ++ ) { if ( i >= buffer . length ) { break ; } buffer [ i ] = NUM ; } return index ; } buffer [ index ] = read Byte ; index ++ ; } while ( index < buffer . length ) ; return index ; }
private static void generate Graph File ( Trans Meta trans Meta , String graph File ) throws Graph Generator Exception { Data Output Stream dos = null ; try { String xml = trans Meta . get XML ( ) ; dos = new Data Output Stream ( new File Output Stream ( new File ( graph File ) ) ) ; dos . write ( xml . get Bytes ( STRING ) ) ; } catch ( Kettle Exception kettel Exception ) { throw new Graph Generator Exception ( STRING , kettel Exception ) ; } catch ( File Not Found Exception e ) { throw new Graph Generator Exception ( STRING , e ) ; } catch ( Unsupported Encoding Exception ue ) { throw new Graph Generator Exception ( STRING , ue ) ; } catch ( IO Exception ioe ) { throw new Graph Generator Exception ( STRING , ioe ) ; } finally { if ( dos != null ) { try { dos . close ( ) ; } catch ( IO Exception e ) { e . get Message ( ) ; } } } }
public void test new Tx read Only release Time Respects Reads On Commit Time ( ) throws IO Exception { final Properties p = new Properties ( ) ; p . set Property ( Abstract Transaction Service . Options . MIN RELEASE AGE , STRING ) ; final Mock Transaction Service service = new Fixture ( p ) ; try { assert Equals ( NUM , service . get Min Release Age ( ) ) ; final long old Release Time = service . get Release Time ( ) ; assert Equals ( NUM , old Release Time ) ; final long tx 0 = service . new Tx ( I Tx . UNISOLATED ) ; final Tx State tx State 0 = service . get Tx State ( tx 0 ) ; final long ts = service . next Timestamp ( ) ; assert True ( ts > Math . abs ( tx 0 ) ) ; final long tx 1 = service . new Tx ( I Tx . UNISOLATED ) ; final Tx State tx State 1 = service . get Tx State ( tx 0 ) ; assert True ( ts < Math . abs ( tx 1 ) ) ; assert Equals ( tx State 0 . get Reads On Commit Time ( ) , tx State 1 . get Reads On Commit Time ( ) ) ; service . commit ( tx 0 ) ; final long new Release Time = service . get Release Time ( ) ; assert Equals ( old Release Time , new Release Time ) ; service . new Tx ( ts ) ; } finally { service . destroy ( ) ; } }
public void delete Entity Config ( String realm , String entity Id ) throws SAML 2 Meta Exception { if ( entity Id == null ) { return ; } if ( realm == null ) { realm = STRING ; } String [ ] objs = { entity Id , realm } ; try { Map old Attrs = config Inst . get Configuration ( realm , entity Id ) ; Set old Values = ( Set ) old Attrs . get ( ATTR ENTITY CONFIG ) ; if ( old Values == null || old Values . is Empty ( ) ) { Log Util . error ( Level . INFO , Log Util . NO ENTITY DESCRIPTOR DELETE ENTITY CONFIG , objs , null ) ; throw new SAML 2 Meta Exception ( STRING , objs ) ; } remove From Circle Of Trust ( realm , entity Id ) ; Set attr = new Hash Set ( ) ; attr . add ( ATTR ENTITY CONFIG ) ; config Inst . delete Configuration ( realm , entity Id , attr ) ; Log Util . access ( Level . INFO , Log Util . ENTITY CONFIG DELETED , objs , null ) ; SAML 2 Meta Cache . put Entity Config ( realm , entity Id , null ) ; } catch ( Configuration Exception e ) { debug . error ( STRING , e ) ; String [ ] data = { e . get Message ( ) , entity Id , realm } ; Log Util . error ( Level . INFO , Log Util . CONFIG ERROR DELETE ENTITY CONFIG , data , null ) ; throw new SAML 2 Meta Exception ( e ) ; } }
public static void load Room Member Avatar ( Context context , MX Session session , Image View image View , Room Member room Member ) { if ( null != room Member ) { Vector Utils . load User Avatar ( context , session , image View , room Member . avatar Url , room Member . get User Id ( ) , room Member . displayname ) ; } }
@ Override public void key Pressed ( Key Event e ) { if ( enable Arrow Keys && e . is Action Key ( ) && e . get Key Code ( ) == Key Event . VK RIGHT ) { e . consume ( ) ; open Popup ( ) ; if ( popup != null ) { time Menu Panel . select First Entry ( ) ; } } if ( enable Arrow Keys && e . is Action Key ( ) && e . get Key Code ( ) == Key Event . VK UP ) { e . consume ( ) ; if ( up Pressed || ! is Enabled ( ) ) { return ; } up Pressed = BOOL ; if ( get Time ( ) == null ) { set Time ( Local Time . NOON ) ; } z Internal Try Change Time By Increment ( NUM ) ; increase Timer . start ( ) ; } if ( enable Arrow Keys && e . is Action Key ( ) && e . get Key Code ( ) == Key Event . VK DOWN ) { e . consume ( ) ; if ( down Pressed || ! is Enabled ( ) ) { return ; } down Pressed = BOOL ; if ( get Time ( ) == null ) { set Time ( Local Time . NOON ) ; } z Internal Try Change Time By Increment ( - NUM ) ; decrease Timer . start ( ) ; } }
private void add Span ( Cache Span span ) { Tree Set < Cache Span > spans For Key = cached Spans . get ( span . key ) ; if ( spans For Key == null ) { spans For Key = new Tree Set < > ( ) ; cached Spans . put ( span . key , spans For Key ) ; } spans For Key . add ( span ) ; total Space += span . length ; notify Span Added ( span ) ; }
public static java . sql . Timestamp to Timestamp ( String month Str , String day Str , String year Str , String hour Str , String minute Str , String second Str ) { java . util . Date new Date = to Date ( month Str , day Str , year Str , hour Str , minute Str , second Str ) ; if ( new Date != null ) { return new java . sql . Timestamp ( new Date . get Time ( ) ) ; } else { return null ; } }
protected boolean schedule New Task ( String task Id ) { LOG . info ( String . format ( STRING , task Id ) ) ; int container Index = Task Utils . get Container Index For Task Id ( task Id ) ; tasks Id . put ( container Index , task Id ) ; to Schedule Tasks . add ( task Id ) ; LOG . info ( String . format ( STRING , task Id ) ) ; return BOOL ; }
private void apply Ltp ( Single Channel Element sce ) { Long Term Prediction ltp = sce . ics . ltp ; final int offsets [ ] = sce . ics . swb Offset ; if ( sce . ics . window Sequence [ NUM ] != EIGHT SHORT SEQUENCE ) { final float pred Time [ ] = sce . ret ; final float pred Freq [ ] = ac . buf Mdct ; int num Samples = NUM ; if ( ltp . lag < NUM ) { num Samples = ltp . lag + NUM ; } for ( int i = NUM ; i < num Samples ; i ++ ) { pred Time [ i ] = sce . ltp State [ i + NUM - ltp . lag ] * ltp . coef ; } Arrays . fill ( pred Time , num Samples , NUM , NUM ) ; windowing And Mdct Ltp ( pred Freq , pred Time , sce . ics ) ; if ( sce . tns . present ) { apply Tns ( pred Freq , sce . tns , sce . ics , BOOL ) ; } for ( int sfb = NUM ; sfb < Math . min ( sce . ics . max Sfb , MAX LTP LONG SFB ) ; sfb ++ ) { if ( ltp . used [ sfb ] ) { for ( int i = offsets [ sfb ] ; i < offsets [ sfb + NUM ] ; i ++ ) { sce . coeffs [ i ] += pred Freq [ i ] ; } } } } }
public static String service From Config File Name ( String config File Name ) { String prefx = Replication Service Manager . CONFIG FILE PREFIX ; String suffix = Replication Service Manager . CONFIG FILE SUFFIX ; if ( config File Name . contains ( prefx ) && config File Name . ends With ( suffix ) ) { int iP = config File Name . index Of ( prefx ) ; return config File Name . substring ( iP + prefx . length ( ) , config File Name . length ( ) - suffix . length ( ) ) ; } else return null ; }

public byte [ ] to Entropy ( List < String > words ) throws Mnemonic Exception . Mnemonic Length Exception , Mnemonic Exception . Mnemonic Word Exception , Mnemonic Exception . Mnemonic Checksum Exception { if ( words . size ( ) % NUM > NUM ) throw new Mnemonic Exception . Mnemonic Length Exception ( STRING ) ; if ( words . size ( ) == NUM ) throw new Mnemonic Exception . Mnemonic Length Exception ( STRING ) ; int concat Len Bits = words . size ( ) * NUM ; boolean [ ] concat Bits = new boolean [ concat Len Bits ] ; int wordindex = NUM ; for ( String word : words ) { int ndx = Collections . binary Search ( this . word List , word ) ; if ( ndx < NUM ) throw new Mnemonic Exception . Mnemonic Word Exception ( word ) ; for ( int ii = NUM ; ii < NUM ; ++ ii ) concat Bits [ ( wordindex * NUM ) + ii ] = ( ndx & ( NUM << ( NUM - ii ) ) ) != NUM ; ++ wordindex ; } int checksum Length Bits = concat Len Bits / NUM ; int entropy Length Bits = concat Len Bits - checksum Length Bits ; byte [ ] entropy = new byte [ entropy Length Bits / NUM ] ; for ( int ii = NUM ; ii < entropy . length ; ++ ii ) for ( int jj = NUM ; jj < NUM ; ++ jj ) if ( concat Bits [ ( ii * NUM ) + jj ] ) entropy [ ii ] |= NUM << ( NUM - jj ) ; byte [ ] hash = Sha 256 Hash . hash ( entropy ) ; boolean [ ] hash Bits = bytes To Bits ( hash ) ; for ( int i = NUM ; i < checksum Length Bits ; ++ i ) if ( concat Bits [ entropy Length Bits + i ] != hash Bits [ i ] ) throw new Mnemonic Exception . Mnemonic Checksum Exception ( ) ; return entropy ; }
@ Override public boolean on Preference Tree Click ( Preference Screen preference Screen , Preference preference ) { log ( STRING + preference ) ; if ( preference == m Airplane Mode Preference && Boolean . parse Boolean ( System Properties . get ( Telephony Properties . PROPERTY INECM MODE ) ) ) { start Activity For Result ( new Intent ( Telephony Intents . ACTION SHOW NOTICE ECM BLOCK OTHERS , null ) , REQUEST CODE EXIT ECM ) ; return BOOL ; } else if ( preference == find Preference ( KEY MANAGE MOBILE PLAN ) ) { on Manage Mobile Plan Click ( ) ; } return super . on Preference Tree Click ( preference Screen , preference ) ; }
public void read Proxy Authenticate Header ( Sip Response response ) { Proxy Authenticate Header header = ( Proxy Authenticate Header ) response . get Header ( Proxy Authenticate Header . NAME ) ; if ( header != null ) { m Digest . set Realm ( header . get Realm ( ) ) ; m Digest . set Qop ( header . get Qop ( ) ) ; m Digest . set Nextnonce ( header . get Nonce ( ) ) ; } }
public static Boolean value Of ( String value ) { return value != null ? Boolean . value Of ( value ) : null ; }
public void test Consume Queue ( ) throws Exception { Message Producer producer = create Producer ( NUM ) ; consumer Destination = session . create Queue ( get Consumer Subject ( ) ) ; producer Destination = session . create Queue ( get Producer Subject ( ) ) ; Message Consumer consumer = create Consumer ( ) ; connection . start ( ) ; for ( int i = NUM ; i < data . length ; i ++ ) { Message message = session . create Text Message ( data [ i ] ) ; message . set String Property ( STRING , data [ i ] ) ; message . set Int Property ( STRING , i ) ; if ( verbose ) { if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING + message + STRING + data [ i ] ) ; } } producer . send ( producer Destination , message ) ; } assert Not Null ( consumer . receive ( NUM ) ) ; }
public Parse Exception ( final int line , final int column , final String message ) { super ( Integer . to String ( line ) + STRING + column + STRING + message ) ; this . line = line ; this . column = column ; }
public boolean draw Image ( Image img , Affine Transform xform , Image Observer obs ) { if ( img == null ) { return BOOL ; } m Drawing Area . add Infinite ( ) ; m Print Metrics . draw Image ( this , img ) ; return m Graphics . draw Image ( img , xform , obs ) ; }
public int digest ( byte [ ] buf , int offset , int len ) throws Digest Exception { if ( buf == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( buf . length - offset < len ) { throw new Illegal Argument Exception ( STRING ) ; } int num Bytes = engine Digest ( buf , offset , len ) ; state = INITIAL ; return num Bytes ; }
public Tree Visualizer ( Tree Display Listener tdl , String dot , Node Place p ) { super ( ) ; initialize ( ) ; if ( m Show Border ) { set Border ( Border Factory . create Titled Border ( STRING ) ) ; } m listener = tdl ; Tree Build builder = new Tree Build ( ) ; Node n = null ; n = builder . create ( new String Reader ( dot ) ) ; m highlight Node = NUM ; m top Node = n ; m placer = p ; m placer . place ( m top Node ) ; m view Pos = new Dimension ( NUM , NUM ) ; m view Size = new Dimension ( NUM , NUM ) ; m n View Pos = new Dimension ( NUM , NUM ) ; m n View Size = new Dimension ( NUM , NUM ) ; m scaling = NUM ; m num Nodes = Node . get Count ( m top Node , NUM ) ; m num Levels = Node . get Height ( m top Node , NUM ) ; m nodes = new Node Info [ m num Nodes ] ; m edges = new Edge Info [ m num Nodes - NUM ] ; array Fill ( m top Node , m nodes , m edges ) ; change Font Size ( NUM ) ; m mouse State = NUM ; m old Mouse Pos = new Dimension ( NUM , NUM ) ; m new Mouse Pos = new Dimension ( NUM , NUM ) ; m frame Limiter = new Timer ( NUM , this ) ; m win Menu = new J Popup Menu ( ) ; m top N = new J Menu Item ( STRING ) ; m top N . set Action Command ( STRING ) ; m fit To Screen = new J Menu Item ( STRING ) ; m fit To Screen . set Action Command ( STRING ) ; m select Font = new J Menu ( STRING ) ; m select Font . set Action Command ( STRING ) ; m auto Scale = new J Menu Item ( STRING ) ; m auto Scale . set Action Command ( STRING ) ; m select Font Group = new Button Group ( ) ; m accept = new J Menu Item ( STRING ) ; m accept . set Action Command ( STRING ) ; m win Menu . add ( m top N ) ; m win Menu . add Separator ( ) ; m win Menu . add ( m fit To Screen ) ; m win Menu . add ( m auto Scale ) ; m win Menu . add Separator ( ) ; m win Menu . add ( m select Font ) ; if ( m listener != null ) { m win Menu . add Separator ( ) ; m win Menu . add ( m accept ) ; } m top N . add Action Listener ( this ) ; m fit To Screen . add Action Listener ( this ) ; m auto Scale . add Action Listener ( this ) ; m accept . add Action Listener ( this ) ; m size 24 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 22 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 20 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 18 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 16 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 14 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 12 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 10 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 8 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 6 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 4 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 2 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 1 = new J Radio Button Menu Item ( STRING , BOOL ) ; m size 24 . set Action Command ( STRING ) ; m size 22 . set Action Command ( STRING ) ; m size 20 . set Action Command ( STRING ) ; m size 18 . set Action Command ( STRING ) ; m size 16 . set Action Command ( STRING ) ; m size 14 . set Action Command ( STRING ) ; m size 12 . set Action Command ( STRING ) ; m size 10 . set Action Command ( STRING ) ; m size 8 . set Action Command ( STRING ) ; m size 6 . set Action Command ( STRING ) ; m size 4 . set Action Command ( STRING ) ; m size 2 . set Action Command ( STRING ) ; m size 1 . set Action Command ( STRING ) ; m select Font Group . add ( m size 24 ) ; m select Font Group . add ( m size 22 ) ; m select Font Group . add ( m size 20 ) ; m select Font Group . add ( m size 18 ) ; m select Font Group . add ( m size 16 ) ; m select Font Group . add ( m size 14 ) ; m select Font Group . add ( m size 12 ) ; m select Font Group . add ( m size 10 ) ; m select Font Group . add ( m size 8 ) ; m select Font Group . add ( m size 6 ) ; m select Font Group . add ( m size 4 ) ; m select Font Group . add ( m size 2 ) ; m select Font Group . add ( m size 1 ) ; m select Font . add ( m size 24 ) ; m select Font . add ( m size 22 ) ; m select Font . add ( m size 20 ) ; m select Font . add ( m size 18 ) ; m select Font . add ( m size 16 ) ; m select Font . add ( m size 14 ) ; m select Font . add ( m size 12 ) ; m select Font . add ( m size 10 ) ; m select Font . add ( m size 8 ) ; m select Font . add ( m size 6 ) ; m select Font . add ( m size 4 ) ; m select Font . add ( m size 2 ) ; m select Font . add ( m size 1 ) ; m size 24 . add Item Listener ( this ) ; m size 22 . add Item Listener ( this ) ; m size 20 . add Item Listener ( this ) ; m size 18 . add Item Listener ( this ) ; m size 16 . add Item Listener ( this ) ; m size 14 . add Item Listener ( this ) ; m size 12 . add Item Listener ( this ) ; m size 10 . add Item Listener ( this ) ; m size 8 . add Item Listener ( this ) ; m size 6 . add Item Listener ( this ) ; m size 4 . add Item Listener ( this ) ; m size 2 . add Item Listener ( this ) ; m size 1 . add Item Listener ( this ) ; m node Menu = new J Popup Menu ( ) ; m visualise = new J Menu Item ( STRING ) ; m visualise . set Action Command ( STRING ) ; m visualise . add Action Listener ( this ) ; m node Menu . add ( m visualise ) ; if ( m listener != null ) { m rem Children = new J Menu Item ( STRING ) ; m rem Children . set Action Command ( STRING ) ; m rem Children . add Action Listener ( this ) ; m node Menu . add ( m rem Children ) ; m classify Child = new J Menu Item ( STRING ) ; m classify Child . set Action Command ( STRING ) ; m classify Child . add Action Listener ( this ) ; m node Menu . add ( m classify Child ) ; } m focus Node = - NUM ; m highlight Node = - NUM ; add Mouse Motion Listener ( this ) ; add Mouse Listener ( this ) ; m frame Limiter . set Repeats ( BOOL ) ; m frame Limiter . start ( ) ; }
public static Angle rhumb Azimuth ( Lat Lon p1 , Lat Lon p2 ) { if ( p1 == null || p2 == null ) { throw new Illegal Argument Exception ( STRING ) ; } double lat 1 = p1 . get Latitude ( ) . radians ; double lon 1 = p1 . get Longitude ( ) . radians ; double lat 2 = p2 . get Latitude ( ) . radians ; double lon 2 = p2 . get Longitude ( ) . radians ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) return Angle . ZERO ; double d Lon = lon 2 - lon 1 ; double d Phi = Math . log ( Math . tan ( lat 2 / NUM + Math . PI / NUM ) / Math . tan ( lat 1 / NUM + Math . PI / NUM ) ) ; if ( Math . abs ( d Lon ) > Math . PI ) { d Lon = d Lon > NUM ? - ( NUM * Math . PI - d Lon ) : ( NUM * Math . PI + d Lon ) ; } double azimuth Radians = Math . atan 2 ( d Lon , d Phi ) ; return Double . is Na N ( azimuth Radians ) ? Angle . ZERO : Angle . from Radians ( azimuth Radians ) ; }
public boolean is Option Checked ( int index ) { if ( index >= checkbox Panel . get Components ( ) . length ) { return BOOL ; } J Check Box checkbox = ( J Check Box ) checkbox Panel . get Component ( index ) ; if ( checkbox . is Selected ( ) ) { return BOOL ; } else { return BOOL ; } }
private void paint Check Icon Disabled And Selected ( Graphics 2 D g , int width , int height ) { Shape s = shape Generator . create Check Mark ( NUM , NUM , width , height ) ; g . set Paint ( icon Disabled Selected ) ; g . fill ( s ) ; }
public static int find URI Split Index ( String uri ) { int uri Length = uri . length ( ) ; int i = uri Length - NUM ; while ( i >= NUM ) { char c = uri . char At ( i ) ; if ( c == STRING || c == STRING || ! XML Util . is NC Name Char ( c ) ) { break ; } i -- ; } i ++ ; while ( i < uri Length ) { char c = uri . char At ( i ) ; if ( c == STRING || XML Util . is Letter ( c ) ) { break ; } i ++ ; } if ( i == uri Length ) { i = - NUM ; } return i ; }
public static void write File ( String to Write , String file Name ) throws File Not Found Exception , Unsupported Encoding Exception { logger . debug ( STRING + file Name ) ; Print Writer writer = null ; try { writer = new Print Writer ( file Name , STRING ) ; writer . println ( to Write ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } }
private void try Correct Photo File Captured ( ) { if ( m Photo File Capture == null || m Files Created While Capture Photo == null || m Files Created While Capture Photo . size ( ) <= NUM ) return ; long capture Size = m Photo File Capture . length ( ) ; for ( File file : m Files Created While Capture Photo ) { if ( Media Utils . is Image Extension ( Media Utils . get File Extension ( file ) ) && file . length ( ) >= capture Size && ! file . equals ( m Photo File Capture ) ) { boolean value = m Photo File Capture . delete ( ) ; m Photo File Capture = file ; Log . i ( TAG , String . format ( STRING , m Photo File Capture , value ) ) ; return ; } } }
protected void initialize Content Model Stack ( ) { if ( f Op Stack == null ) { f Op Stack = new short [ NUM ] ; f Node Index Stack = new int [ NUM ] ; f Prev Node Index Stack = new int [ NUM ] ; } else if ( f Depth == f Op Stack . length ) { short [ ] new Stack = new short [ f Depth * NUM ] ; System . arraycopy ( f Op Stack , NUM , new Stack , NUM , f Depth ) ; f Op Stack = new Stack ; int [ ] new Int Stack = new int [ f Depth * NUM ] ; System . arraycopy ( f Node Index Stack , NUM , new Int Stack , NUM , f Depth ) ; f Node Index Stack = new Int Stack ; new Int Stack = new int [ f Depth * NUM ] ; System . arraycopy ( f Prev Node Index Stack , NUM , new Int Stack , NUM , f Depth ) ; f Prev Node Index Stack = new Int Stack ; } f Op Stack [ f Depth ] = - NUM ; f Node Index Stack [ f Depth ] = - NUM ; f Prev Node Index Stack [ f Depth ] = - NUM ; }
private void grow Spine ( ) { int size = ( spine . length << NUM ) + NUM ; spine = new int [ size ] ; spine Empty = new int [ size ] ; threshold = ( int ) ( spine . length * load Factor ) ; Arrays . fill ( spine Empty , - NUM ) ; Grid Unsafe . copy Memory ( spine Empty , INT ARR OFF , spine , INT ARR OFF , spine Empty . length << NUM ) ; for ( int i = NUM ; i < this . size ; i ++ ) { Object obj = objs [ i ] ; int idx = hash ( obj ) % spine . length ; insert ( objs [ i ] , i , idx ) ; } }
public void close ( ) { Thread current = thread ; thread = null ; if ( current != null ) { current . interrupt ( ) ; try { current . join ( ) ; } catch ( Interrupted Exception e ) { log . error ( e . get Message ( ) , e ) ; } } try { buffer . close ( ) ; } catch ( IO Exception e ) { log . error ( e . get Message ( ) , e ) ; } }
Vcf Record [ ] merge Records ( Vcf Record [ ] records , Vcf Header [ ] headers , Vcf Header dest Header , Set < String > unmergeable Format Fields , boolean preserve Formats ) { assert records . length == headers . length ; final Multi Map < Integer , Vcf Record > record Sets = new Multi Map < > ( BOOL ) ; final Multi Map < Integer , Vcf Header > header Sets = new Multi Map < > ( BOOL ) ; for ( int i = NUM ; i < records . length ; i ++ ) { record Sets . put ( records [ i ] . get Length ( ) , records [ i ] ) ; header Sets . put ( records [ i ] . get Length ( ) , headers [ i ] ) ; } final Array List < Vcf Record > ret = new Array List < > ( ) ; for ( Integer key : record Sets . key Set ( ) ) { final Collection < Vcf Record > recs = record Sets . get ( key ) ; final Collection < Vcf Header > heads = header Sets . get ( key ) ; final Vcf Record [ ] recs Array = recs . to Array ( new Vcf Record [ recs . size ( ) ] ) ; final Vcf Header [ ] heads Array = heads . to Array ( new Vcf Header [ heads . size ( ) ] ) ; final Vcf Record merged = merge Records With Same Ref ( recs Array , heads Array , dest Header , unmergeable Format Fields , ! preserve Formats ) ; if ( merged != null ) { ret . add ( merged ) ; } else { final Vcf Record [ ] rec Holder = new Vcf Record [ NUM ] ; final Vcf Header [ ] head Holder = new Vcf Header [ NUM ] ; for ( int i = NUM ; i < recs Array . length ; i ++ ) { rec Holder [ NUM ] = recs Array [ i ] ; head Holder [ NUM ] = heads Array [ i ] ; ret . add ( merge Records With Same Ref ( rec Holder , head Holder , dest Header , unmergeable Format Fields , ! preserve Formats ) ) ; } } } return ret . to Array ( new Vcf Record [ ret . size ( ) ] ) ; }
public static void dump ( Result Set rs ) throws SQL Exception { Result Set Meta Data md = rs . get Meta Data ( ) ; for ( int i = NUM ; i < md . get Column Count ( ) ; i ++ ) { int index = i + NUM ; String info = md . get Column Label ( index ) ; String name = md . get Column Name ( index ) ; if ( info == null ) info = name ; else if ( name != null && ! name . equals ( info ) ) info += STRING + name + STRING ; info += STRING + rs . get String ( index ) ; info += STRING + md . get Column Type Name ( index ) + STRING + md . get Precision ( index ) ; if ( md . get Scale ( index ) != NUM ) info += STRING + md . get Scale ( index ) ; info += STRING ; log . fine ( info ) ; } }
public Pla Point Float [ ] tangential points ( Pla Point Float p to point , double p distance ) { double dx = Math . abs ( v x - p to point . v x ) ; double dy = Math . abs ( v y - p to point . v y ) ; boolean situation turned = ( dy > dx ) ; Pla Point Float pole ; Pla Point Float circle center ; if ( situation turned ) { pole = new Pla Point Float ( - v y , v x ) ; circle center = new Pla Point Float ( - p to point . v y , p to point . v x ) ; } else { pole = this ; circle center = p to point ; } dx = pole . v x - circle center . v x ; dy = pole . v y - circle center . v y ; double dx square = dx * dx ; double dy square = dy * dy ; double dist square = dx square + dy square ; double radius square = p distance * p distance ; double discriminant = radius square * dy square - ( radius square - dx square ) * dist square ; if ( discriminant <= NUM ) { return new Pla Point Float [ NUM ] ; } double square root = Math . sqrt ( discriminant ) ; Pla Point Float [ ] result = new Pla Point Float [ NUM ] ; double a1 = radius square * dy ; double dy 1 = ( a1 + p distance * square root ) / dist square ; double dy 2 = ( a1 - p distance * square root ) / dist square ; double first point y = dy 1 + circle center . v y ; double first point x = ( radius square - dy * dy 1 ) / dx + circle center . v x ; double second point y = dy 2 + circle center . v y ; double second point x = ( radius square - dy * dy 2 ) / dx + circle center . v x ; if ( situation turned ) { result [ NUM ] = new Pla Point Float ( first point y , - first point x ) ; result [ NUM ] = new Pla Point Float ( second point y , - second point x ) ; } else { result [ NUM ] = new Pla Point Float ( first point x , first point y ) ; result [ NUM ] = new Pla Point Float ( second point x , second point y ) ; } return result ; }
public void remove Arguments ( String label ) { List < PB Argument > remove = new Array List < > ( ) ; for ( PB Argument arg : l arguments ) { if ( arg . is Label ( label ) ) remove . add ( arg ) ; } l arguments . remove All ( remove ) ; }
public Annotating Graph Mouse Plugin ( Render Context < V , E > rc , int selection Modifiers , int additional Modifiers ) { super ( selection Modifiers ) ; this . rc = rc ; this . basic Transformer = rc . get Multi Layer Transformer ( ) ; this . additional Modifiers = additional Modifiers ; this . lens Paintable = new Lens Paintable ( ) ; this . annotation Manager = new Annotation Manager ( rc ) ; this . cursor = Cursor . get Predefined Cursor ( Cursor . HAND CURSOR ) ; }
public double [ ] breadth First Search ( double intial Value , double first Value , IBFS Traversable < N > traversable , I Double Bfs Next Level Value Iterator < N > next Value Iterator , List < Integer > sources ) { double [ ] results = new double [ nodes . length ] ; Arrays . fill ( results , intial Value ) ; boolean [ ] already Scanned = new boolean [ nodes . length ] ; Arrays . fill ( already Scanned , BOOL ) ; Set < Integer > current Nodes Index = new Hash Set < > ( sources ) ; iterative Double Breadth First Search ( results , already Scanned , current Nodes Index , first Value , NUM , traversable , next Value Iterator ) ; return results ; }
public View Ref Render ( View Render < T > view ) { Objects . require Non Null ( view ) ; view = view ; type = type Of ( view ) ; priority = priority Of ( view ) ; }
public static void encode Multicast Announcement ( Multicast Announcement announcement , Datagram Buffer Factory bufs ) throws IO Exception { try { Linked List groups = new Linked List ( ) ; groups . add All ( Arrays . as List ( announcement . get Groups ( ) ) ) ; do { Byte Buffer buf = bufs . new Buffer ( ) ; int slim = buf . limit ( ) ; buf . limit ( slim - SERVICE ID LEN ) ; buf . put Long ( announcement . get Sequence Number ( ) ) ; put Utf ( buf , announcement . get Host ( ) ) ; buf . put Short ( int To Ushort ( announcement . get Port ( ) ) ) ; int ngroups = NUM ; int ngroups Pos = buf . position ( ) ; buf . put Short ( ( short ) NUM ) ; try { while ( ! groups . is Empty ( ) && ngroups < MAX USHORT ) { put Utf ( buf , ( String ) groups . get First ( ) ) ; groups . remove First ( ) ; ngroups ++ ; } } catch ( Buffer Overflow Exception e ) { if ( ngroups == NUM ) { throw e ; } } buf . put Short ( ngroups Pos , int To Ushort ( ngroups ) ) ; Service ID id = announcement . get Service ID ( ) ; buf . limit ( slim ) ; buf . put Long ( id . get Most Significant Bits ( ) ) ; buf . put Long ( id . get Least Significant Bits ( ) ) ; } while ( ! groups . is Empty ( ) ) ; } catch ( Runtime Exception e ) { throw new Discovery Protocol Exception ( null , e ) ; } }
public void add Property Change Listener ( Property Change Listener listener ) { if ( property Change Support == null ) { property Change Support = new Property Change Support ( this ) ; } property Change Support . add Property Change Listener ( listener ) ; }
public void remove Policy ( String policy Name ) throws SSO Exception , No Permission Exception , Policy Exception { if ( policy Name == null ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING ) ; } throw ( new Invalid Name Exception ( Res Bundle Utils . rb Name , STRING , null , STRING , Policy Exception . POLICY ) ) ; } try { Policy Manager . init Admin Subject ( ) ; Service Config o Config = scm . get Organization Config ( org , null ) ; Service Config named Policy = ( o Config == null ) ? null : o Config . get Sub Config ( NAMED POLICY ) ; if ( named Policy != null ) { Policy policy = get Policy ( policy Name ) ; named Policy . remove Sub Config ( policy Name ) ; if ( policy != null ) { Privilege Index Store pis = Privilege Index Store . get Instance ( Subject Utils . create Super Admin Subject ( ) , get Organization DN ( ) ) ; if ( policy . is Referral Policy ( ) ) { pis . delete Referral ( ( policy Name ) ) ; } else { pis . delete ( Privilege Utils . policy To Privileges ( policy ) ) ; } policy Cache . send Policy Change Notification ( null , policy , Service Listener . REMOVED ) ; } } } catch ( Entitlement Exception e ) { debug . error ( STRING + e . get Message ( ) ) ; } catch ( Service Not Found Exception snfe ) { debug . error ( STRING + snfe . get Message ( ) ) ; } catch ( SMS Exception smse ) { String objs [ ] = { policy Name , org } ; if ( Policy Utils . log Status ) { Policy Utils . log Error Message ( STRING , objs , token ) ; } debug . error ( STRING + policy Name + STRING + org , smse ) ; if ( smse . get Exception Code ( ) == SMS Exception . STATUS NO PERMISSION ) { throw ( new No Permission Exception ( Res Bundle Utils . rb Name , STRING , null ) ) ; } else { throw ( new Policy Exception ( Res Bundle Utils . rb Name , STRING , objs , smse ) ) ; } } String objs [ ] = { policy Name , org } ; if ( Policy Utils . log Status ) { Policy Utils . log Access Message ( STRING , objs , token ) ; } }
public void remove Dummy Lun Path ( Storage System storage System , URI block Object URI ) throws Exception { log . info ( STRING ) ; HDS Api Client api Client = HDS Utils . get HDS Api Client ( hds Api Factory , storage System ) ; HDS Api Export Manager api Export Manager = api Client . get HDS Api Export Manager ( ) ; String system Object Id = HDS Utils . get System Object ID ( storage System ) ; Block Object block Obj = Block Object . fetch ( db Client , block Object URI ) ; String dummy Lun Path Id = get Dummy HSD Path Id ( storage System , block Obj ) ; if ( dummy Lun Path Id != null ) { api Export Manager . delete Lun Paths From System ( system Object Id , Arrays . as List ( dummy Lun Path Id ) , storage System . get Model ( ) ) ; log . info ( STRING ) ; } else { log . info ( STRING ) ; } }
public static long convert String To Time Millis ( String time ) { long result = NUM ; if ( time . ends With ( STRING ) ) { long hours To Add = Integer . value Of ( String Utils . remove ( time , STRING ) ) ; result = ( ( NUM * NUM ) * NUM ) * hours To Add ; } else if ( time . ends With ( STRING ) ) { long mins To Add = Integer . value Of ( String Utils . remove ( time , STRING ) ) ; result = ( NUM * NUM ) * mins To Add ; } else if ( time . ends With ( STRING ) ) { long secs To Add = Integer . value Of ( String Utils . remove ( time , STRING ) ) ; result = NUM * secs To Add ; } return result ; }
public void remove Activity ( Activity activity ) { if ( activity Stack == null ) { activity Stack = new Stack < Activity > ( ) ; } activity Stack . remove ( activity ) ; }
protected void add Items ( List < ? extends Action > actions ) { Action Container Factory factory = new Action Container Factory ( null ) ; for ( Action action : actions ) { Abstract Action Ext a = ( Abstract Action Ext ) action ; if ( action . is Enabled ( ) ) { if ( a . is State Action ( ) ) add Item ( create Check Box ( ( Abstract Action Ext ) action ) ) ; else { add Item ( factory . create Button ( action ) ) ; } } } }
public void remove From Active List ( Download Info Runnable download Info Runnable ) { m Active List . remove ( download Info Runnable ) ; }
private void end Current Line Of TLA ( ) { if ( tlacode Next Line . length ( ) != NUM ) { tlacode . add Element ( tlacode Next Line ) ; mapping Vector . add Element ( mapping Vector Next Line ) ; tlacode Next Line = STRING ; mapping Vector Next Line = new Vector ( ) ; } else { if ( mapping Vector Next Line . size ( ) != NUM ) { Vector last Line = ( Vector ) mapping Vector . element At ( mapping Vector . size ( ) - NUM ) ; for ( int i = NUM ; i < mapping Vector Next Line . size ( ) ; i ++ ) { Mapping Object obj = ( Mapping Object ) mapping Vector Next Line . element At ( i ) ; if ( obj . get Type ( ) == Mapping Object . RIGHT PAREN || obj . get Type ( ) == Mapping Object . LEFT PAREN || obj . get Type ( ) == Mapping Object . BREAK ) { last Line . add ( obj ) ; } else { Pcal Debug . Report Bug ( STRING ) ; } mapping Vector Next Line = new Vector ( ) ; } } } }
public static String to Camel Case ( String input , boolean first Char Uppercase , char separator ) { int length = input . length ( ) ; String Builder sb = new String Builder ( length ) ; boolean upper Case = first Char Uppercase ; for ( int i = NUM ; i < length ; i ++ ) { char ch = input . char At ( i ) ; if ( ch == separator ) { upper Case = BOOL ; } else if ( upper Case ) { sb . append ( Character . to Upper Case ( ch ) ) ; upper Case = BOOL ; } else { sb . append ( ch ) ; } } return sb . to String ( ) ; }
public static String remove ( String string , char ch ) { int string Len = string . length ( ) ; char [ ] result = new char [ string Len ] ; int offset = NUM ; for ( int i = NUM ; i < string Len ; i ++ ) { char c = string . char At ( i ) ; if ( c == ch ) { continue ; } result [ offset ] = c ; offset ++ ; } if ( offset == string Len ) { return string ; } return new String ( result , NUM , offset ) ; }
private boolean provides Http Request Metrics ( Class < ? > c ) { return implements Interface ( c , HTTP SERVLET REQUEST CLASS , HTTP REQUEST WHITE LIST , HTTP REQUEST BLACK LIST ) ; }
static void remove Duplicate Affix ( List < String > str List , boolean is Suffix ) { Hash Set < String > str Set = new Hash Set < String > ( str List ) ; str List . clear ( ) ; str List . add All ( str Set ) ; if ( is Suffix ) { Collections . sort ( str List , null ) ; } else { Collections . sort ( str List , null ) ; } }
public static double next Double ( ) { Random random = get Random ( ) ; double value = random . next Double ( ) ; if ( ! is Test ) free Random List . free ( random ) ; return value ; }
public static boolean is Same Week ( final Date date 1 , final Date date 2 ) { final Calendar cal 1 = Calendar . get Instance ( ) ; cal 1 . set First Day Of Week ( Calendar . MONDAY ) ; cal 1 . set Time ( date 1 ) ; final Calendar cal 2 = Calendar . get Instance ( ) ; cal 2 . set First Day Of Week ( Calendar . MONDAY ) ; cal 2 . set Time ( date 2 ) ; return cal 1 . get ( Calendar . ERA ) == cal 2 . get ( Calendar . ERA ) && cal 1 . get ( Calendar . YEAR ) == cal 2 . get ( Calendar . YEAR ) && cal 1 . get ( Calendar . WEEK OF YEAR ) == cal 2 . get ( Calendar . WEEK OF YEAR ) ; }
public void store Last PVP Action Time ( ) { put ( STRING , System . current Time Millis ( ) ) ; }
public void merge contents ( ) { if ( contents . length == NUM ) return ; Arrays . sort ( contents ) ; List < Call Chain Info > unique calls = new Array List < Call Chain Info > ( ) ; unique calls . add ( contents [ NUM ] ) ; for ( int ii = NUM ; ii < contents . length ; ii ++ ) { Call Chain Info top = unique calls . get ( unique calls . size ( ) - NUM ) ; if ( contents [ ii ] . method == top . method ) top . merge ( contents [ ii ] ) ; else unique calls . add ( contents [ ii ] ) ; } logger . info ( STRING , method , contents . length , unique calls . size ( ) ) ; contents = unique calls . to Array ( new Call Chain Info [ NUM ] ) ; }
public Feature ( String line , Map cp Str 2 Int , Map lb Str 2 Int ) { String Tokenizer str Tok = new String Tokenizer ( line , STRING ) ; int len = str Tok . count Tokens ( ) ; String str Id Str = str Tok . next Token ( ) ; int idx = Integer . parse Int ( str Tok . next Token ( ) ) ; float val = NUM ; double wgt = Double . parse Double ( str Tok . next Token ( ) ) ; String Tokenizer str Id Tok = new String Tokenizer ( str Id Str , STRING ) ; String prefix = str Id Tok . next Token ( ) ; if ( prefix . compare To Ignore Case ( STRING ) == NUM ) { Integer y Int = ( Integer ) lb Str 2 Int . get ( str Id Tok . next Token ( ) ) ; Integer yp Int = ( Integer ) lb Str 2 Int . get ( str Id Tok . next Token ( ) ) ; if ( y Int != null && yp Int != null ) { e Feature 1 Init ( y Int . int Value ( ) , yp Int . int Value ( ) ) ; } } else if ( prefix . compare To Ignore Case ( STRING ) == NUM ) { Integer y Int = ( Integer ) lb Str 2 Int . get ( str Id Tok . next Token ( ) ) ; Integer cp Int = ( Integer ) cp Str 2 Int . get ( str Id Tok . next Token ( ) ) ; if ( y Int != null && cp Int != null ) { s Feature 1 Init ( y Int . int Value ( ) , cp Int . int Value ( ) ) ; } } this . idx = idx ; this . val = val ; this . wgt = wgt ; }
public void record Block Volume Operation ( Db Client db Client , Operation Type Enum op Type , Operation . Status status , Object ... ext Param ) { try { boolean op Status = ( Operation . Status . ready == status ) ? BOOL : BOOL ; String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ; String ev Desc = op Type . get Description ( ) ; String op Stage = Audit Log Manager . AUDITOP END ; logger . info ( STRING , op Type . to String ( ) , ev Type . to String ( ) + STRING + ev Desc ) ; record Bourne Volume Event ( db Client , get Id ( ) , ev Type , status , ev Desc ) ; String id = ( String ) ext Param [ NUM ] ; switch ( op Type ) { case CREATE BLOCK VOLUME : case DELETE BLOCK VOLUME : Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; case EXPAND BLOCK VOLUME : String size = ( String ) ext Param [ NUM ] ; Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id , size ) ; break ; case CREATE VOLUME FULL COPY : Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; case DETACH VOLUME FULL COPY : Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; case RESTORE VOLUME FULL COPY : case RESYNCHRONIZE VOLUME FULL COPY : case ACTIVATE VOLUME FULL COPY : Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; default : logger . error ( STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , op Type . to String ( ) , e ) ; } }
double evaluate Instance Leave One Out ( Instance instance , double [ ] inst A ) throws Exception { Decision Table Hash Key thekey ; double [ ] temp Dist ; double [ ] norm Dist ; thekey = new Decision Table Hash Key ( inst A ) ; if ( m class Is Nominal ) { if ( ( temp Dist = m entries . get ( thekey ) ) == null ) { throw new Error ( STRING ) ; } else { norm Dist = new double [ temp Dist . length ] ; System . arraycopy ( temp Dist , NUM , norm Dist , NUM , temp Dist . length ) ; norm Dist [ ( int ) instance . class Value ( ) ] -= instance . weight ( ) ; boolean ok = BOOL ; for ( double element : norm Dist ) { if ( Utils . gr ( element , NUM ) ) { ok = BOOL ; break ; } } m class Prior Counts [ ( int ) instance . class Value ( ) ] -= instance . weight ( ) ; double [ ] class Priors = m class Prior Counts . clone ( ) ; Utils . normalize ( class Priors ) ; if ( ! ok ) { norm Dist = class Priors ; } m class Prior Counts [ ( int ) instance . class Value ( ) ] += instance . weight ( ) ; Utils . normalize ( norm Dist ) ; if ( m evaluation Measure == EVAL AUC ) { m evaluation . evaluate Model Once And Record Prediction ( norm Dist , instance ) ; } else { m evaluation . evaluate Model Once ( norm Dist , instance ) ; } return Utils . max Index ( norm Dist ) ; } } else { if ( ( temp Dist = m entries . get ( thekey ) ) != null ) { norm Dist = new double [ temp Dist . length ] ; System . arraycopy ( temp Dist , NUM , norm Dist , NUM , temp Dist . length ) ; norm Dist [ NUM ] -= ( instance . class Value ( ) * instance . weight ( ) ) ; norm Dist [ NUM ] -= instance . weight ( ) ; if ( Utils . eq ( norm Dist [ NUM ] , NUM ) ) { double [ ] temp = new double [ NUM ] ; temp [ NUM ] = m majority ; m evaluation . evaluate Model Once ( temp , instance ) ; return m majority ; } else { double [ ] temp = new double [ NUM ] ; temp [ NUM ] = norm Dist [ NUM ] / norm Dist [ NUM ] ; m evaluation . evaluate Model Once ( temp , instance ) ; return temp [ NUM ] ; } } else { throw new Error ( STRING ) ; } } }
public boolean accept ( File f ) { if ( f != null ) { if ( f . is Directory ( ) ) { return BOOL ; } String extension = get Extension ( f ) ; if ( ( extension != null ) && ( filters . get ( get Extension ( f ) ) != null ) ) { return BOOL ; } } return BOOL ; }
@ Override public Poll Result start Poll ( Poll Controller conn ) { try { boolean is New = conn . enable Keepalive If New ( this ) ; if ( ! enable Keepalive ( conn , is New ) ) { return Poll Result . CLOSED ; } if ( conn . to Keepalive Start ( ) ) { active Count . increment And Get ( ) ; return Poll Result . START ; } else { return Poll Result . DATA ; } } catch ( IO Exception e ) { conn . on Poll Read Close ( ) ; throw new Illegal State Exception ( e ) ; } }
private void init Space Startup State Manager ( ) throws Create Exception { List < String > target Names = cluster Policy . m Replication Policy . m Replication Group Members Names ; String space Name = cluster Policy . m Replication Policy . m Own Member Name ; startup Manager = new Replication Startup Manager ( space Name ) ; for ( String name : target Names ) { if ( name . equals ( space Name ) ) continue ; } try { if ( startup Manager . should Wait ( target Names ) ) { logger . info ( STRING ) ; startup Manager . wait For Last Space ( ) ; } } catch ( Interrupted Exception e ) { throw new Create Exception ( STRING , e ) ; } }
private double min Ignore Na N ( double a , double b ) { if ( Double . is Na N ( a ) ) { return b ; } if ( Double . is Na N ( b ) ) { return a ; } return Math . min ( a , b ) ; }
public Configure Xml Element Count Dialog NB ( Xml Element Count xml Element Count ) { this . xml Element Count = xml Element Count ; init Components ( ) ; configure String List NB 1 . set Validator ( new XML Element Validator ( ) ) ; final Iterate Model number Of Tags Iterator = xml Element Count . get Number Of Elements Iterator ( ) ; configure Iterate Model NB 2 . set Start At ( String . value Of ( number Of Tags Iterator . get Start At ( ) ) ) ; configure Iterate Model NB 2 . set Stop At ( String . value Of ( number Of Tags Iterator . get Stop At ( ) ) ) ; configure Iterate Model NB 2 . set Increment ( String . value Of ( number Of Tags Iterator . get Increment ( ) ) ) ; configure Iterate Model NB 2 . set Iterate Strategie ( number Of Tags Iterator . get Iterate Strategie ( ) ) ; List < String > elements = Arrays . as List ( xml Element Count . get Elements ( ) ) ; configure String List NB 1 . set String List ( elements ) ; }
public final static int log Base 2 ( double number ) { int log = NUM ; while ( number > NUM ) { number = Math . floor ( number / NUM ) ; ++ log ; } return log ; }
public Entry create Root ( User user , String id , String type , String notebook Id , Long mod Time , Long create Time , Errors errors ) { if ( user == null ) { Errors . add ( errors , error Messages . error User Is Null ( ) ) ; return null ; } if ( mod Time == null ) { Errors . add ( errors , error Messages . error Mod Time Is Null ( ) ) ; return null ; } if ( create Time == null ) { Errors . add ( errors , error Messages . error Create Time Is Null ( ) ) ; return null ; } if ( id != null && ! id Generator . is Id Well Formed ( id ) ) { Errors . add ( errors , error Messages . error Id Is Invalid ( ) ) ; return null ; } if ( notebook Id != null && ! id Generator . is Id Well Formed ( notebook Id ) ) { Errors . add ( errors , error Messages . error Notebook Id Is Invalid ( ) ) ; return null ; } if ( create Time . long Value ( ) > mod Time . long Value ( ) ) { mod Time = create Time ; } Entry root = new Entry ( ) ; root . set Db ( db ) ; if ( id == null ) { id = id Generator . get Another Id ( ) ; } root . set Id ( id ) ; root . set Create Time ( create Time ) ; root . set Mod Time ( mod Time ) ; root . set Type ( type ) ; root . set User Id ( user . get Id ( ) ) ; root . set Notebook Id ( notebook Id ) ; db . persist Entry ( root ) ; return root ; }
public Parameter Type File ( String key , String description , boolean optional , String [ ] extensions ) { super ( key , description , null ) ; set Optional ( optional ) ; this . extensions = extensions ; }
protected int read Block ( ) { block Size = read ( ) ; int n = NUM ; if ( block Size > NUM ) { try { int count = NUM ; while ( n < block Size ) { count = in . read ( block , n , block Size - n ) ; if ( count == - NUM ) break ; n += count ; } } catch ( IO Exception e ) { } if ( n < block Size ) { status = STATUS FORMAT ERROR ; } } return n ; }
public void destroy ( ) { for ( int i = NUM ; i < runs . size ( ) ; i ++ ) { final Run run = ( Run ) runs . get ( i ) ; run . destroy ( ) ; } }
public static void register Dynamic Type Converter ( Java Dynamic Type Converter the Converter ) { if ( ! m dyn Converters . contains ( the Converter ) ) { m dyn Converters . add Element ( the Converter ) ; } }
public void remove Sensor Assignment ( Sensor sensor ) { if ( sensor == null ) { return ; } for ( Positionable Point po : layout Editor . point List ) { if ( ( po . get East Bound Sensor ( ) != null ) && po . get East Bound Sensor ( ) == sensor ) { po . set East Bound Sensor ( null ) ; } if ( ( po . get West Bound Sensor ( ) != null ) && po . get West Bound Sensor ( ) == sensor ) { po . set West Bound Sensor ( null ) ; } } for ( Layout Turnout to : layout Editor . turnout List ) { if ( ( to . get Sensor A ( ) != null ) && to . get Sensor A ( ) == sensor ) { to . set Sensor A ( null ) ; } if ( ( to . get Sensor B ( ) != null ) && to . get Sensor B ( ) == sensor ) { to . set Sensor B ( null ) ; } if ( ( to . get Sensor C ( ) != null ) && to . get Sensor C ( ) == sensor ) { to . set Sensor C ( null ) ; } if ( ( to . get Sensor D ( ) != null ) && to . get Sensor D ( ) == sensor ) { to . set Sensor D ( null ) ; } } for ( Layout Slip to : layout Editor . slip List ) { if ( ( to . get Sensor A ( ) != null ) && to . get Sensor A ( ) == sensor ) { to . set Sensor A ( null ) ; } if ( ( to . get Sensor B ( ) != null ) && to . get Sensor B ( ) == sensor ) { to . set Sensor B ( null ) ; } if ( ( to . get Sensor C ( ) != null ) && to . get Sensor C ( ) == sensor ) { to . set Sensor C ( null ) ; } if ( ( to . get Sensor D ( ) != null ) && to . get Sensor D ( ) == sensor ) { to . set Sensor D ( null ) ; } } for ( Level Xing x : layout Editor . xing List ) { if ( ( x . get Sensor A ( ) != null ) && x . get Sensor A ( ) == sensor ) { x . set Sensor A Name ( null ) ; } if ( ( x . get Sensor B ( ) != null ) && x . get Sensor B ( ) == sensor ) { x . set Sensor B Name ( null ) ; } if ( ( x . get Sensor C ( ) != null ) && x . get Sensor C ( ) == sensor ) { x . set Sensor C Name ( null ) ; } if ( ( x . get Sensor D ( ) != null ) && x . get Sensor D ( ) == sensor ) { x . set Sensor D Name ( null ) ; } } }
private static void transfer From ( File Channel channel , Input Stream in ) throws IO Exception { Readable Byte Channel read Channel = Channels . new Channel ( in ) ; if ( ! BROKEN NIO ) { channel . transfer From ( read Channel , NUM , MAX EMPTYDB SIZE ) ; } else { Byte Buffer bb = Byte Buffer . allocate ( NUM ) ; while ( read Channel . read ( bb ) >= NUM ) { bb . flip ( ) ; channel . write ( bb ) ; bb . clear ( ) ; } } }
public Queued Media Player ( Context context ) { m Context = context ; m Current Player = new Managed Media Player ( ) ; m Next Player = new Managed Media Player ( ) ; m Next Player . set Audio Session Id ( m Current Player . get Audio Session Id ( ) ) ; m Current Player . set On Prepared Listener ( this ) ; m Current Player . set On Error Listener ( this ) ; m Current Player . set On Completion Listener ( this ) ; m Next Player . set On Prepared Listener ( this ) ; m Next Player . set On Error Listener ( this ) ; m Next Player . set On Completion Listener ( this ) ; m Queue = Collections . empty List ( ) ; m Queue Index = NUM ; }
public void if Present Or Else ( Consumer < ? super T > consumer , Runnable empty Action ) { if ( value != null ) consumer . accept ( value ) ; else empty Action . run ( ) ; }
protected void send Intensity ( double intensity ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + STRING + last Output Step + STRING + max Dim Step ) ; } int new Step = ( int ) Math . round ( intensity * max Dim Step ) ; if ( ( new Step < NUM ) || ( new Step > max Dim Step ) ) { log . error ( STRING + new Step + STRING + intensity ) ; } if ( new Step == last Output Step ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING ) ; } return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity ) ; } Insteon Sequence out = new Insteon Sequence ( ) ; out . add Function ( idhighbyte , idmiddlebyte , idlowbyte , Constants . FUNCTION REQ STD , Constants . FLAG STD , Constants . CMD LIGHT CHG , new Step ) ; tc . send Insteon Sequence ( out , null ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + intensity + STRING + idhighbyte + idmiddlebyte + idlowbyte + STRING + new Step ) ; } last Output Step = new Step ; }
public Thread Monitor ( M Bean Server Connection server ) throws IO Exception { this . server = server ; this . tmbean = new Platform MX Bean Proxy ( server , THREAD MXBEAN NAME , Thread MX Bean . class ) ; try { objname = new Object Name ( THREAD MXBEAN NAME ) ; } catch ( Malformed Object Name Exception e ) { Internal Error ie = new Internal Error ( e . get Message ( ) ) ; ie . init Cause ( e ) ; throw ie ; } parse M Bean Info ( ) ; }
public void delete ( ) throws IO Exception { close ( ) ; Io Utils . delete Contents ( directory ) ; }
@ Override public boolean execute ( @ Not Null Psi Element pe , @ Not Null Resolve State state ) { if ( pe instanceof Psi Variable ) { final Psi Variable pvar = ( Psi Variable ) pe ; final String pvar name = pvar . get Name ( ) ; if ( pvar name . starts With ( my Prefix ) ) { if ( ! my Static Sensitive Flag || ( ! my Static Scope Flag || pvar . has Modifier Property ( Psi Modifier . STATIC ) ) ) { my Result List . add ( pvar ) ; } } } return BOOL ; }
private void write Esc ( char ch [ ] , int start , int length , boolean is Att Val ) throws SAX Exception { for ( int i = start ; i < start + length ; i ++ ) { switch ( ch [ i ] ) { case STRING : write ( STRING ) ; break ; case STRING : write ( STRING ) ; break ; case STRING : write ( STRING ) ; break ; case STRING : if ( is Att Val ) { write ( STRING ) ; } else { write ( STRING ) ; } break ; default : if ( ! unicode Mode && ch [ i ] > STRING ) { write ( STRING ) ; write ( Integer . to String ( ch [ i ] ) ) ; write ( STRING ) ; } else { write ( ch [ i ] ) ; } } } }
private String convert Millis To Mins Secs ( long milliseconds ) { int seconds Value = ( int ) ( milliseconds / NUM ) % NUM ; int minutes Value = ( int ) ( ( milliseconds / ( NUM * NUM ) ) % NUM ) ; int hours Value = ( int ) ( ( milliseconds / ( NUM * NUM * NUM ) ) % NUM ) ; String seconds = STRING ; String minutes = STRING ; String hours = STRING ; if ( seconds Value < NUM ) { seconds = STRING + seconds Value ; } else { seconds = STRING + seconds Value ; } minutes = STRING + minutes Value ; hours = STRING + hours Value ; String output = STRING ; if ( hours Value != NUM ) { minutes = STRING + minutes Value ; hours = STRING + hours Value ; output = hours + STRING + minutes + STRING + seconds ; } else { minutes = STRING + minutes Value ; hours = STRING + hours Value ; output = minutes + STRING + seconds ; } return output ; }
public I Chat Message send Message 2 ( Geoloc geoloc ) throws Remote Exception { if ( geoloc == null ) { throw new Server Api Illegal Argument Exception ( STRING ) ; } if ( ! is Allowed To Send Message ( ) ) { throw new Server Api Permission Denied Exception ( STRING ) ; } String label = geoloc . get Label ( ) ; if ( label != null ) { int label Length = label . length ( ) ; int label Max Length = m Rcs Settings . get Max Geoloc Label Length ( ) ; if ( label Length > label Max Length ) { throw new Server Api Illegal Argument Exception ( STRING + label Length + STRING + label Max Length + STRING ) ; } } try { long timestamp = System . current Time Millis ( ) ; final Chat Message geoloc Msg = Chat Utils . create Geoloc Message ( null , geoloc , timestamp , timestamp ) ; Chat Message Persisted Storage Accessor persisted Storage = new Chat Message Persisted Storage Accessor ( m Messaging Log , geoloc Msg . get Message Id ( ) , geoloc Msg . get Remote Contact ( ) , geoloc Msg . get Content ( ) , geoloc Msg . get Mime Type ( ) , m Chat Id , Direction . OUTGOING ) ; add Outgoing Group Chat Message ( geoloc Msg , Content . Status . QUEUED , Content . Reason Code . UNSPECIFIED ) ; if ( ! m Chat Service . is Group Chat Active ( m Chat Id ) ) { m Chat Service . set Group Chat State And Reason Code ( m Chat Id , Group Chat . State . STARTED , Group Chat . Reason Code . UNSPECIFIED ) ; } m Im Service . try To Dequeue Group Chat Messages And Group File Transfers ( m Chat Id ) ; return new Chat Message Impl ( persisted Storage ) ; } catch ( Server Api Base Exception e ) { if ( ! e . should Not Be Logged ( ) ) { s Logger . error ( Exception Util . get Full Stack Trace ( e ) ) ; } throw e ; } catch ( Exception e ) { s Logger . error ( Exception Util . get Full Stack Trace ( e ) ) ; throw new Server Api Generic Exception ( e ) ; } }
synchronized void remove ( Pg Server Thread t ) { running . remove ( t ) ; }
public void dock ( Node node , Dock Pos dock Pos ) { dock ( node , dock Pos , root ) ; }
@ Nullable private String override Xml File Content ( @ Not Null Document vd Document , @ Nullable String Builder error Log ) { int target Width = NUM ; int target Height = NUM ; try { target Width = Integer . parse Int ( my Context . get Vector Width ( ) ) ; target Height = Integer . parse Int ( my Context . get Vector Height ( ) ) ; } catch ( Number Format Exception e ) { error Log . append ( STRING + my Context . get Vector Width ( ) + STRING + my Context . get Vector Height ( ) ) ; return null ; } if ( target Width <= NUM || target Height <= NUM ) { error Log . append ( STRING ) ; return null ; } if ( target Width > Vd Preview . MAX PREVIEW IMAGE SIZE || target Height > Vd Preview . MAX PREVIEW IMAGE SIZE ) { error Log . append ( STRING + Vd Preview . MAX PREVIEW IMAGE SIZE ) ; return null ; } Vd Override Info info = new Vd Override Info ( target Width , target Height , my Context . get Vector Opacity ( ) , my Context . get Vector Auto Mirrored ( ) ) ; String xml File Content = Vd Preview . override Xml Content ( vd Document , info , error Log ) ; return xml File Content ; }
@ Nullable public Codenvy License load ( ) throws License Exception { String license Text ; try { license Text = new String ( Files . read All Bytes ( license File ) , UTF 8 ) ; } catch ( No Such File Exception e ) { throw new License Not Found Exception ( STRING ) ; } catch ( IO Exception e ) { throw new License Exception ( e . get Message ( ) , e ) ; } if ( is Null Or Empty ( license Text ) ) { throw new License Not Found Exception ( STRING ) ; } return license Factory . create ( license Text ) ; }
@ Nullable public static Network Parameters from Pmt Protocol ID ( String pmt Protocol Id ) { if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID MAINNET ) ) { return Main Net Params . get ( ) ; } else if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID TESTNET ) ) { return Test Net 3 Params . get ( ) ; } else { return null ; } }
public void read From Stream ( Data Input Stream dis , int version ) throws IO Exception { for ( int c = NUM ; c < NUM ; c ++ ) { Array List < Time Control Field > tc = new Array List < Time Control Field > ( ) ; if ( c == NUM ) tc W = tc ; else tc B = tc ; int nw = dis . read Int ( ) ; for ( int i = NUM ; i < nw ; i ++ ) { int time = dis . read Int ( ) ; int moves = dis . read Int ( ) ; int inc = dis . read Int ( ) ; tc . add ( new Time Control Field ( time , moves , inc ) ) ; } } }
public Rect update Fast Scroller Bounds ( int last Touch Y ) { m Invalidate Rect . set ( m Bg Bounds ) ; if ( is Visible ( ) ) { int edge Padding = m Rv . get Max Scrollbar Width ( ) ; int bg Padding = ( m Bg Original Size - m Text Bounds . height ( ) ) / NUM ; int bg Height = m Bg Original Size ; int bg Width = Math . max ( m Bg Original Size , m Text Bounds . width ( ) + ( NUM * bg Padding ) ) ; if ( Utilities . is Rtl ( m Res ) ) { m Bg Bounds . left = m Rv . get Background Padding ( ) . left + ( NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . right = m Bg Bounds . left + bg Width ; } else { m Bg Bounds . right = m Rv . get Width ( ) - m Rv . get Background Padding ( ) . right - ( NUM * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . left = m Bg Bounds . right - bg Width ; } m Bg Bounds . top = last Touch Y - ( int ) ( FAST SCROLL OVERLAY Y OFFSET FACTOR * bg Height ) ; m Bg Bounds . top = Math . max ( edge Padding , Math . min ( m Bg Bounds . top , m Rv . get Height ( ) - edge Padding - bg Height ) ) ; m Bg Bounds . bottom = m Bg Bounds . top + bg Height ; } else { m Bg Bounds . set Empty ( ) ; } m Invalidate Rect . union ( m Bg Bounds ) ; return m Invalidate Rect ; }
public D Netscape Ca Policy Url ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public boolean textbox Key Typed ( char p 146201 1 , int p 146201 2 ) { if ( ! field 146213 o ) return BOOL ; else switch ( p 146201 1 ) { case NUM : func 146202 e ( ) ; func 146199 i ( NUM ) ; return BOOL ; case NUM : Gui Screen . set Clipboard String ( func 146207 c ( ) ) ; return BOOL ; case NUM : if ( field 146226 p ) func 146191 b ( Gui Screen . get Clipboard String ( ) ) ; return BOOL ; case NUM : Gui Screen . set Clipboard String ( func 146207 c ( ) ) ; if ( field 146226 p ) func 146191 b ( STRING ) ; return BOOL ; default : switch ( p 146201 2 ) { case NUM : if ( Gui Screen . is Ctrl Key Down ( ) ) { if ( field 146226 p ) func 146177 a ( - NUM ) ; } else if ( field 146226 p ) func 146175 b ( - NUM ) ; return BOOL ; case NUM : if ( Gui Screen . is Shift Key Down ( ) ) func 146199 i ( NUM ) ; else func 146196 d ( ) ; return BOOL ; case NUM : if ( Gui Screen . is Shift Key Down ( ) ) { if ( Gui Screen . is Ctrl Key Down ( ) ) func 146199 i ( func 146183 a ( - NUM , func 146186 n ( ) ) ) ; else func 146199 i ( func 146186 n ( ) - NUM ) ; } else if ( Gui Screen . is Ctrl Key Down ( ) ) func 146190 e ( func 146187 c ( - NUM ) ) ; else func 146182 d ( - NUM ) ; return BOOL ; case NUM : if ( Gui Screen . is Shift Key Down ( ) ) { if ( Gui Screen . is Ctrl Key Down ( ) ) func 146199 i ( func 146183 a ( NUM , func 146186 n ( ) ) ) ; else func 146199 i ( func 146186 n ( ) + NUM ) ; } else if ( Gui Screen . is Ctrl Key Down ( ) ) func 146190 e ( func 146187 c ( NUM ) ) ; else func 146182 d ( NUM ) ; return BOOL ; case NUM : if ( Gui Screen . is Shift Key Down ( ) ) func 146199 i ( field 146216 j . length ( ) ) ; else func 146202 e ( ) ; return BOOL ; case NUM : if ( Gui Screen . is Ctrl Key Down ( ) ) { if ( field 146226 p ) func 146177 a ( NUM ) ; } else if ( field 146226 p ) func 146175 b ( NUM ) ; return BOOL ; default : if ( Chat Allowed Characters . is Allowed Character ( p 146201 1 ) ) { if ( field 146226 p ) func 146191 b ( Character . to String ( p 146201 1 ) ) ; return BOOL ; } else return BOOL ; } } }
public static Funktion Config find From Folder ( File folder ) throws IO Exception { if ( folder . is Directory ( ) ) { File file = new File ( folder , FILE NAME ) ; if ( file != null && file . exists ( ) && file . is File ( ) ) { return load From File ( file ) ; } File parent File = folder . get Parent File ( ) ; if ( parent File != null ) { return find From Folder ( parent File ) ; } Funktion Config answer = try Find Config On Class Path ( ) ; if ( answer != null ) { return answer ; } throw new IO Exception ( STRING + file . get Path ( ) ) ; } else if ( folder . is File ( ) ) { return load From File ( folder ) ; } Funktion Config answer = try Find Config On Class Path ( ) ; if ( answer != null ) { return answer ; } throw new IO Exception ( STRING + folder . get Path ( ) ) ; }
public static boolean is Windows 7 ( ) { return os Name . index Of ( STRING ) > - NUM && os Version . equals ( STRING ) ; }
public static Array List < Instruction > create Deep Copy Instruction Set ( Array List < Instruction > inst Set , long pid , int ID Prefix , Program prog , Hash Set < String > fn Stack , Hash Set < String > fn Created , boolean plain , boolean cp Functions ) throws DML Runtime Exception { Array List < Instruction > tmp = new Array List < Instruction > ( ) ; for ( Instruction inst : inst Set ) { if ( inst instanceof Function Call CP Instruction && cp Functions ) { Function Call CP Instruction finst = ( Function Call CP Instruction ) inst ; create Deep Copy Function Program Block ( finst . get Namespace ( ) , finst . get Function Name ( ) , pid , ID Prefix , prog , fn Stack , fn Created , plain ) ; } tmp . add ( clone Instruction ( inst , pid , plain , cp Functions ) ) ; } return tmp ; }
private void add Node To List ( List vm List , int start Index For Node , int end Index For Node ) { vm List . clear ( ) ; for ( int i = start Index For Node ; i < end Index For Node ; i ++ ) { vm List . add ( vm [ i ] ) ; } }
@ Override public List < Proxy > select ( URI uri ) { Array List < Proxy > proxies = new Array List < Proxy > ( ) ; proxies . add ( Proxy . NO PROXY ) ; return proxies ; }
public void add Externs ( String [ ] definitions ) { add Strings ( EXTERNS , definitions ) ; add Strings ( linker more , EXTERNS , definitions ) ; new Linker Options After Compile . add ( EXTERNS ) ; }
Vcf Record [ ] merge Records ( Vcf Record [ ] records , Vcf Header [ ] headers , Vcf Header dest Header , Set < String > unmergeable Format Fields , boolean preserve Formats ) { assert records . length == headers . length ; final Multi Map < Integer , Vcf Record > record Sets = new Multi Map < > ( BOOL ) ; final Multi Map < Integer , Vcf Header > header Sets = new Multi Map < > ( BOOL ) ; for ( int i = NUM ; i < records . length ; i ++ ) { record Sets . put ( records [ i ] . get Length ( ) , records [ i ] ) ; header Sets . put ( records [ i ] . get Length ( ) , headers [ i ] ) ; } final Array List < Vcf Record > ret = new Array List < > ( ) ; for ( Integer key : record Sets . key Set ( ) ) { final Collection < Vcf Record > recs = record Sets . get ( key ) ; final Collection < Vcf Header > heads = header Sets . get ( key ) ; final Vcf Record [ ] recs Array = recs . to Array ( new Vcf Record [ recs . size ( ) ] ) ; final Vcf Header [ ] heads Array = heads . to Array ( new Vcf Header [ heads . size ( ) ] ) ; final Vcf Record merged = merge Records With Same Ref ( recs Array , heads Array , dest Header , unmergeable Format Fields , ! preserve Formats ) ; if ( merged != null ) { ret . add ( merged ) ; } else { final Vcf Record [ ] rec Holder = new Vcf Record [ NUM ] ; final Vcf Header [ ] head Holder = new Vcf Header [ NUM ] ; for ( int i = NUM ; i < recs Array . length ; i ++ ) { rec Holder [ NUM ] = recs Array [ i ] ; head Holder [ NUM ] = heads Array [ i ] ; ret . add ( merge Records With Same Ref ( rec Holder , head Holder , dest Header , unmergeable Format Fields , ! preserve Formats ) ) ; } } } return ret . to Array ( new Vcf Record [ ret . size ( ) ] ) ; }
public LDIF Change Record Reader ( final String ... ldif Lines ) { super ( Arrays . as List ( ldif Lines ) ) ; }
@ Deprecated public static boolean equals ( final Event person Event , Id < Person > person Id , final Event Log deq Sim Event ) { return equals ( person Event , deq Sim Event ) ; }
public static License read ( final String license ) { final String trimmed License = license . trim ( ) ; if ( s Licenses . contains Key ( trimmed License ) ) { return s Licenses . get ( trimmed License ) ; } else { throw new Illegal State Exception ( String . format ( STRING , trimmed License ) ) ; } }
public Geo Distance Sort Builder geo Distance ( Geo Distance geo Distance ) { this . geo Distance = geo Distance ; return this ; }
public static final Geo Time Serie sub Serie ( Geo Time Serie gts , long starttimestamp , long stoptimestamp , boolean overwrite , boolean copy Labels , Geo Time Serie subgts ) { if ( null == subgts ) { subgts = new Geo Time Serie ( NUM ) ; subgts . set Name ( gts . get Name ( ) ) ; if ( copy Labels ) { subgts . set Labels ( gts . get Labels ( ) ) ; } } else { GTS Helper . reset ( subgts ) ; } if ( null == gts . ticks || NUM == gts . values ) { return subgts ; } GTS Helper . sort ( gts ) ; int lastidx = Arrays . binary Search ( gts . ticks , NUM , gts . values , stoptimestamp ) ; if ( - NUM == lastidx ) { return subgts ; } else if ( lastidx < NUM ) { lastidx = - lastidx - NUM ; if ( lastidx >= gts . values ) { lastidx = gts . values - NUM ; } } int firstidx = Arrays . binary Search ( gts . ticks , NUM , lastidx + NUM , starttimestamp ) ; if ( firstidx < NUM ) { firstidx = - firstidx - NUM ; } if ( firstidx >= gts . values ) { return subgts ; } for ( int i = firstidx ; i <= lastidx ; i ++ ) { if ( gts . ticks [ i ] >= starttimestamp && gts . ticks [ i ] <= stoptimestamp ) { set Value ( subgts , gts . ticks [ i ] , null != gts . locations ? gts . locations [ i ] : Geo Time Serie . NO LOCATION , null != gts . elevations ? gts . elevations [ i ] : Geo Time Serie . NO ELEVATION , value At Index ( gts , i ) , overwrite ) ; } } return subgts ; }
protected List < ? extends Itemset > frequent Itemsets ( List < ? extends Itemset > candidates , Relation < Bit Vector > relation , int needed , DBI Ds ids , Array Modifiable DBI Ds survivors , int length ) { if ( candidates . is Empty ( ) ) { return Collections . empty List ( ) ; } Itemset first = candidates . get ( NUM ) ; if ( candidates . size ( ) > length * length * length * NUM && first instanceof Sparse Itemset ) { @ Suppress Warnings ( STRING ) List < Sparse Itemset > sparsecand = ( List < Sparse Itemset > ) candidates ; return frequent Itemsets Sparse ( sparsecand , relation , needed , ids , survivors , length ) ; } for ( DBID Iter iditer = ids . iter ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { Bit Vector bv = relation . get ( iditer ) ; int lives = NUM ; for ( Itemset candidate : candidates ) { if ( candidate . contained In ( bv ) ) { candidate . increase Support ( ) ; ++ lives ; } } if ( lives > length ) { survivors . add ( iditer ) ; } } List < Itemset > frequent = new Array List < > ( candidates . size ( ) ) ; for ( Iterator < ? extends Itemset > iter = candidates . iterator ( ) ; iter . has Next ( ) ; ) { final Itemset candidate = iter . next ( ) ; if ( candidate . get Support ( ) >= needed ) { frequent . add ( candidate ) ; } } return frequent ; }
public static final void write Boolean Array Xml ( boolean [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . to String ( N ) ) ; for ( int i = NUM ; i < N ; i ++ ) { out . start Tag ( null , STRING ) ; out . attribute ( null , STRING , Boolean . to String ( val [ i ] ) ) ; out . end Tag ( null , STRING ) ; } out . end Tag ( null , STRING ) ; }
protected Rewritten Outbound Url process Encode URL ( Http Servlet Response hs Response , Http Servlet Request hs Request , boolean encode Url Has Been Run , String outbound Url ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + outbound Url ) ; } if ( outbound Url == null ) { return new Rewritten Outbound Url ( null , BOOL ) ; } boolean final Encode Outbound Url = BOOL ; String final To Url = outbound Url ; final List outbound Rules = conf . get Outbound Rules ( ) ; try { for ( int i = NUM ; i < outbound Rules . size ( ) ; i ++ ) { final Outbound Rule outbound Rule = ( Outbound Rule ) outbound Rules . get ( i ) ; if ( ! encode Url Has Been Run && outbound Rule . is Encode First ( ) ) { continue ; } if ( encode Url Has Been Run && ! outbound Rule . is Encode First ( ) ) { continue ; } final Rewritten Outbound Url rewritten Url = outbound Rule . execute ( final To Url , hs Request , hs Response ) ; if ( rewritten Url != null ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + outbound Rule . get Display Name ( ) + STRING ) ; } final To Url = rewritten Url . get Target ( ) ; final Encode Outbound Url = rewritten Url . is Encode ( ) ; if ( outbound Rule . is Last ( ) ) { log . debug ( STRING ) ; break ; } } } } catch ( Invocation Target Exception e ) { try { handle Invocation Target Exception ( hs Request , hs Response , e ) ; } catch ( Servlet Exception e1 ) { log . error ( e1 ) ; } catch ( IO Exception e1 ) { log . error ( e1 ) ; } } return new Rewritten Outbound Url ( final To Url , final Encode Outbound Url ) ; }
public Amqp Client ( URI remote URI , String username , String password ) { this . remote URI = remote URI ; this . password = password ; this . username = username ; }
public static Collection < String > names ( Flags flags ) { final Collection < String > results = new Array List < String > ( ) ; if ( flags . contains ( Flags . Flag . ANSWERED ) ) { results . add ( ANSWERED OUTPUT CAPITALISED ) ; } if ( flags . contains ( Flags . Flag . DELETED ) ) { results . add ( DELETED OUTPUT CAPITALISED ) ; } if ( flags . contains ( Flags . Flag . DRAFT ) ) { results . add ( DRAFT OUTPUT CAPITALISED ) ; } if ( flags . contains ( Flags . Flag . FLAGGED ) ) { results . add ( FLAGGED OUTPUT CAPITALISED ) ; } if ( flags . contains ( Flags . Flag . RECENT ) ) { results . add ( RECENT OUTPUT CAPITALISED ) ; } if ( flags . contains ( Flags . Flag . SEEN ) ) { results . add ( SEEN OUTPUT CAPITALISED ) ; } String [ ] user Flags = flags . get User Flags ( ) ; Collections . add All ( results , user Flags ) ; if ( flags . contains ( Flags . Flag . USER ) ) { results . add ( USER OUTPUT CAPITALISED ) ; } return results ; }
public static boolean contains Key ( Key Store key Store ) throws Crypto Exception { try { Enumeration < String > aliases = key Store . aliases ( ) ; while ( aliases . has More Elements ( ) ) { String alias = aliases . next Element ( ) ; if ( is Key Entry ( alias , key Store ) ) { return BOOL ; } } return BOOL ; } catch ( Key Store Exception ex ) { throw new Crypto Exception ( res . get String ( STRING ) , ex ) ; } }
void purge Orphaned Articles ( ) { if ( ! is DB Available ( ) ) return ; long time = System . current Time Millis ( ) ; safely Delete Articles ( STRING + TABLE FEEDS + STRING , null ) ; Log . d ( TAG , STRING + ( System . current Time Millis ( ) - time ) + STRING ) ; }
public void reclaim Views ( List < View > views ) { int child Count = get Child Count ( ) ; Recycler Listener listener = m Recycler . m Recycler Listener ; for ( int i = NUM ; i < child Count ; i ++ ) { View child = get Child At ( i ) ; PLA Abs List View . Layout Params lp = ( PLA Abs List View . Layout Params ) child . get Layout Params ( ) ; if ( lp != null && m Recycler . should Recycle View Type ( lp . view Type ) ) { views . add ( child ) ; if ( listener != null ) { listener . on Moved To Scrap Heap ( child ) ; } } } m Recycler . reclaim Scrap Views ( views ) ; remove All Views In Layout ( ) ; }
public void test Using Proxy Selector ( ) throws Exception { Mock Server server = new Mock Server ( STRING ) ; Mock Server proxy = new Mock Server ( STRING ) ; URL url = new URL ( STRING + server . port ( ) ) ; Proxy Selector def PS = Proxy Selector . get Default ( ) ; Proxy Selector . set Default ( new Test Proxy Selector ( server . port ( ) , proxy . port ( ) ) ) ; try { Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Connect Timeout ( NUM ) ; connection . set Read Timeout ( NUM ) ; server . start ( ) ; synchronized ( bound ) { if ( ! server . started ) bound . wait ( NUM ) ; } proxy . start ( ) ; synchronized ( bound ) { if ( ! proxy . started ) bound . wait ( NUM ) ; } connection . connect ( ) ; server . join ( ) ; proxy . join ( ) ; assert True ( STRING , connection . using Proxy ( ) ) ; assert True ( STRING , proxy . accepted ) ; connection . disconnect ( ) ; assert True ( STRING , connection . using Proxy ( ) ) ; } finally { Proxy Selector . set Default ( def PS ) ; } }
public void paint ( Graphics g ) { g . set Color ( Color . white ) ; g . fill Rect ( NUM , NUM , get Width ( ) , get Height ( ) ) ; g . set Color ( Color . BLACK ) ; for ( int stripe X = NUM ; stripe X < get Width ( ) ; stripe X += CHECKER SIZE ) { for ( int y = NUM , row = NUM ; y < get Height ( ) ; y += CHECKER SIZE / NUM , ++ row ) { int x = ( row % NUM == NUM ) ? stripe X : ( stripe X + CHECKER SIZE / NUM ) ; g . fill Rect ( x , y , CHECKER SIZE / NUM , CHECKER SIZE / NUM ) ; } } g . translate ( NUM , translate Y ) ; super . paint ( g ) ; }
public static long jenkins ( final Bit Vector bv , final long prefix Length , final long [ ] aa , final long bb [ ] , final long cc [ ] ) { if ( prefix Length == NUM ) return aa [ NUM ] ^ NUM ; int state Offset = ( int ) ( prefix Length / ( NUM * Long . SIZE ) ) ; long from = ( state Offset * NUM ) * Long . SIZE ; long a = aa [ state Offset ] ; long b = bb [ state Offset ] ; long c = cc [ state Offset ] ; if ( prefix Length - from > Long . SIZE * NUM ) { a += bv . get Long ( from , from + Long . SIZE ) ; b += bv . get Long ( from + Long . SIZE , from + NUM * Long . SIZE ) ; c += bv . get Long ( from + NUM * Long . SIZE , Math . min ( from + NUM * Long . SIZE , prefix Length ) ) ; a -= b ; a -= c ; a ^= ( c > > > NUM ) ; b -= c ; b -= a ; b ^= ( a << NUM ) ; c -= a ; c -= b ; c ^= ( b > > > NUM ) ; a -= b ; a -= c ; a ^= ( c > > > NUM ) ; b -= c ; b -= a ; b ^= ( a << NUM ) ; c -= a ; c -= b ; c ^= ( b > > > NUM ) ; a -= b ; a -= c ; a ^= ( c > > > NUM ) ; b -= c ; b -= a ; b ^= ( a << NUM ) ; c -= a ; c -= b ; c ^= ( b > > > NUM ) ; a -= b ; a -= c ; a ^= ( c > > > NUM ) ; b -= c ; b -= a ; b ^= ( a << NUM ) ; c -= a ; c -= b ; c ^= ( b > > > NUM ) ; from += NUM * Long . SIZE ; } c += prefix Length ; long residual = prefix Length - from ; if ( residual > NUM ) { if ( residual > Long . SIZE ) { a += bv . get Long ( from , from + Long . SIZE ) ; residual -= Long . SIZE ; } if ( residual != NUM ) b += bv . get Long ( prefix Length - residual , prefix Length ) ; } a -= b ; a -= c ; a ^= ( c > > > NUM ) ; b -= c ; b -= a ; b ^= ( a << NUM ) ; c -= a ; c -= b ; c ^= ( b > > > NUM ) ; a -= b ; a -= c ; a ^= ( c > > > NUM ) ; b -= c ; b -= a ; b ^= ( a << NUM ) ; c -= a ; c -= b ; c ^= ( b > > > NUM ) ; a -= b ; a -= c ; a ^= ( c > > > NUM ) ; b -= c ; b -= a ; b ^= ( a << NUM ) ; c -= a ; c -= b ; c ^= ( b > > > NUM ) ; a -= b ; a -= c ; a ^= ( c > > > NUM ) ; b -= c ; b -= a ; b ^= ( a << NUM ) ; c -= a ; c -= b ; c ^= ( b > > > NUM ) ; return c ; }
private boolean serialize Compact RDF Attr Props ( XMP Node parent Node , int indent ) throws IO Exception { boolean all Are Attrs = BOOL ; for ( Iterator it = parent Node . iterate Children ( ) ; it . has Next ( ) ; ) { XMP Node prop = ( XMP Node ) it . next ( ) ; if ( can Be RDF Attr Prop ( prop ) ) { write Newline ( ) ; write Indent ( indent ) ; write ( prop . get Name ( ) ) ; write ( STRING ) ; append Node Value ( prop . get Value ( ) , BOOL ) ; write ( STRING ) ; } else { all Are Attrs = BOOL ; } } return all Are Attrs ; }
public static Pair < Integer , Boolean > show Yes No Question With Checkbox ( final Component parent , final String msg , final String check Box Title ) { J Check Box checkbox = null ; Object params ; if ( check Box Title != null ) { checkbox = new J Check Box ( check Box Title ) ; params = new Object [ ] { msg , checkbox } ; } else { params = msg ; } final int option = J Option Pane . show Confirm Dialog ( is Iconified ( parent ) ? null : parent , params , System . get Property ( DEFAULT WINDOW TITLE PROPERTY ) , J Option Pane . YES NO OPTION , J Option Pane . QUESTION MESSAGE ) ; return Pair . make ( option , check Box Title != null ? checkbox . is Selected ( ) : BOOL ) ; }
public void pop ( ) { state = ( Graphics State ) stack . pop ( ) ; set Transform ( state . xform ) ; set Clip ( state . cliprgn ) ; }
public static void create Index ( Connection conn , String schema , String table , String column List ) throws SQL Exception { init ( conn ) ; Prepared Statement prep = conn . prepare Statement ( STRING + SCHEMA + STRING ) ; prep . set String ( NUM , schema ) ; prep . set String ( NUM , table ) ; prep . set String ( NUM , column List ) ; prep . execute ( ) ; create Trigger ( conn , schema , table ) ; index Existing Rows ( conn , schema , table ) ; }
public synchronized int index Of ( I Audio Processor processor ) { return processors . index Of ( processor ) ; }
protected int decompress ( Short Buffer compressed Data , int npix ) { int llfirt ; int lllen ; if ( ! ( compressed Data . get ( NUM ) > NUM ) ) { lllen = ( compressed Data . get ( HEADER SIZE FIELD 2 ) << SHIFT 15 BITS ) + compressed Data . get ( HEADER SIZE FIELD 1 ) ; llfirt = compressed Data . get ( NUM ) ; } else { lllen = compressed Data . get ( MINI HEADER SIZE FIELD ) ; llfirt = MINI HEADER SIZE ; } final int xe = npix ; int op = NUM ; int x1 = NUM ; int pv = NUM ; for ( int ip = llfirt ; ip <= lllen ; ++ ip ) { final int opcode = compressed Data . get ( ip ) / FIRST VALUE WITH 13 BIT ; final int data = compressed Data . get ( ip ) & LAST VALUE FITTING IN 12 BIT ; final int sw 0001 = opcode + NUM ; if ( sw 0001 == OPCODE 1 || sw 0001 == OPCODE 5 || sw 0001 == OPCODE 6 ) { final int x2 = x1 + data - NUM ; final int i2 = Math . min ( x2 , xe ) ; final int np = i2 - Math . max ( x1 , NUM ) + NUM ; if ( np > NUM ) { final int otop = op + np - NUM ; if ( ! ( opcode == OPCODE 4 ) ) { for ( int index = op ; index <= otop ; ++ index ) { put ( index , NUM ) ; } if ( opcode == OPCODE 5 && i2 == x2 ) { put ( otop , pv ) ; } } else { for ( int index = op ; index <= otop ; ++ index ) { put ( index , pv ) ; } } op = otop + NUM ; } x1 = x2 + NUM ; } else if ( sw 0001 == OPCODE 2 ) { pv = ( compressed Data . get ( ip + NUM ) << SHIFT 12 BITS ) + data ; ++ ip ; } else if ( sw 0001 == OPCODE 3 ) { pv += data ; } else if ( sw 0001 == OPCODE 4 ) { pv -= data ; } else if ( sw 0001 == OPCODE 7 ) { pv += data ; if ( x1 >= NUM && x1 <= xe ) { put ( op , pv ) ; ++ op ; } ++ x1 ; } else if ( sw 0001 == OPCODE 8 ) { pv -= data ; if ( x1 >= NUM && x1 <= xe ) { put ( op , pv ) ; ++ op ; } ++ x1 ; } if ( x1 > xe ) { break ; } } for ( int index = op ; index < npix ; ++ index ) { put ( index , NUM ) ; } return npix ; }
public void initialize ( Map config Params ) { String delimiter Config = ( String ) config Params . get ( Resource Match . RESOURCE COMPARATOR DELIMITER ) ; if ( delimiter Config != null ) { this . delimiter = delimiter Config ; } String case Config = ( String ) config Params . get ( Resource Match . RESOURCE COMPARATOR CASE SENSITIVE ) ; if ( case Config != null ) { if ( case Config . equals ( STRING ) ) { this . case Sensitive = BOOL ; } else if ( case Config . equals ( STRING ) ) { this . case Sensitive = BOOL ; } else { this . case Sensitive = BOOL ; } } String wildcard Config = ( String ) config Params . get ( Resource Match . RESOURCE COMPARATOR WILDCARD ) ; if ( wildcard Config != null ) { this . wildcard = wildcard Config ; } String one Level Wildcard Config = ( String ) config Params . get ( Resource Match . RESOURCE COMPARATOR ONE LEVEL WILDCARD ) ; if ( one Level Wildcard Config != null ) { this . one Level Wildcard = one Level Wildcard Config ; } if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + delimiter + STRING + wildcard + STRING + one Level Wildcard + STRING + case Config ) ; } one Level Wildcard Length = one Level Wildcard . length ( ) ; wildcard Length = wildcard . length ( ) ; if ( one Level Wildcard . index Of ( wildcard ) != - NUM ) { wildcard Embedded = BOOL ; } else { wildcard Embedded = BOOL ; } if ( wildcard . index Of ( one Level Wildcard ) != - NUM ) { one Level Wildcard Embedded = BOOL ; } else { one Level Wildcard Embedded = BOOL ; } if ( debug . message Enabled ( ) ) { debug . message ( STRING + wildcard Embedded + STRING + one Level Wildcard Embedded ) ; } return ; }
public static boolean is SSH ( String uri ) { return uri != null && uri . starts With ( STRING ) ; }
private Scan State switch State ( Scan State desired , Enum Set < Scan State > allowed ) { final Scan State old ; final long timestamp ; final long sequence ; synchronized ( this ) { old = state ; if ( ! allowed . contains ( state ) ) throw new Illegal State Exception ( state . to String ( ) ) ; state = desired ; timestamp = System . current Time Millis ( ) ; sequence = get Next Seq Number ( ) ; } LOG . fine ( STRING + old + STRING + desired ) ; if ( old != desired ) queue State Changed Notification ( sequence , timestamp , old , desired ) ; return old ; }
private boolean parse Autolink ( ) { String m ; if ( ( m = match ( EMAIL AUTOLINK ) ) != null ) { String dest = m . substring ( NUM , m . length ( ) - NUM ) ; Link node = new Link ( STRING + dest , null ) ; node . append Child ( new Text ( dest ) ) ; append Node ( node ) ; return BOOL ; } else if ( ( m = match ( AUTOLINK ) ) != null ) { String dest = m . substring ( NUM , m . length ( ) - NUM ) ; Link node = new Link ( dest , null ) ; node . append Child ( new Text ( dest ) ) ; append Node ( node ) ; return BOOL ; } else { return BOOL ; } }
private static void insert Comments In Cu ( Compilation Unit cu , Comments Collection comments Collection ) { if ( comments Collection . size ( ) == NUM ) return ; List < Comment > comments = comments Collection . get All ( ) ; Position Utils . sort By Begin Position ( comments ) ; List < Node > children = cu . get Children Nodes ( ) ; Position Utils . sort By Begin Position ( children ) ; if ( cu . get Package ( ) != null && ( children . size ( ) == NUM || Position Utils . are In Order ( comments . get ( NUM ) , children . get ( NUM ) ) ) ) { cu . set Comment ( comments . get ( NUM ) ) ; comments . remove ( NUM ) ; } insert Comments In Node ( cu , comments ) ; }
public static boolean reveal In Finder ( final File file ) throws File Not Found Exception { if ( file == null || ! file . exists ( ) ) throw new File Not Found Exception ( ) ; final String file Name = file . get Absolute Path ( ) ; final Security Manager security = System . get Security Manager ( ) ; if ( security != null ) security . check Read ( file Name ) ; return reveal In Finder ( file Name ) ; }
public synchronized void check Access ( License Checker Callback callback ) { if ( m Policy . allow Access ( ) ) { Log . i ( TAG , STRING ) ; callback . allow ( Policy . LICENSED ) ; } else { License Validator validator = new License Validator ( m Policy , new Null Device Limiter ( ) , callback , generate Nonce ( ) , m Package Name , m Version Code ) ; if ( m Service == null ) { Log . i ( TAG , STRING ) ; try { boolean bind Result = m Context . bind Service ( new Intent ( STRING ) , this , Context . BIND AUTO CREATE ) ; if ( bind Result ) { m Pending Checks . offer ( validator ) ; } else { Log . e ( TAG , STRING ) ; handle Service Connection Error ( validator ) ; } } catch ( Exception e ) { callback . application Error ( License Checker Callback . ERROR MISSING PERMISSION ) ; } } else { m Pending Checks . offer ( validator ) ; run Checks ( ) ; } } }
void open ( ) { if ( ! main Frame . can Navigate Away ( ) ) { return ; } if ( ask To Save ( ) ) { return ; } boolean loading = BOOL ; Save Type file Type ; try Again : while ( loading ) { int value = save Open File Chooser . show Open Dialog ( main Frame ) ; if ( value != J File Chooser . APPROVE OPTION ) { return ; } loading = BOOL ; file Type = convert Filter To Type ( save Open File Chooser . get File Filter ( ) ) ; final File f = save Open File Chooser . get Selected File ( ) ; if ( ! file Type . is Valid ( f ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STRING , STRING , J Option Pane . WARNING MESSAGE ) ; loading = BOOL ; continue ; } switch ( file Type ) { case XML ANALYSIS : if ( ! f . get Name ( ) . ends With ( STRING ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , L10 N . get Local String ( STRING , STRING ) ) ; loading = BOOL ; continue try Again ; } if ( ! main Frame . open Analysis ( f , file Type ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STRING ) ; loading = BOOL ; continue try Again ; } break ; case FBP FILE : if ( ! open FBP File ( f ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STRING ) ; loading = BOOL ; continue try Again ; } break ; case FBA FILE : if ( ! open FBA File ( f ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STRING ) ; loading = BOOL ; continue try Again ; } break ; default : assert BOOL ; } } }
protected static String [ ] split String By Delimiter Points ( String s Str , Integer [ ] i Res ) { Array List al Res = new Array List ( ) ; for ( int i Cnt = NUM ; i Cnt < i Res . length ; i Cnt ++ ) { if ( i Cnt == NUM ) al Res . add ( s Str . substring ( NUM , i Res [ i Cnt ] ) ) ; else al Res . add ( s Str . substring ( i Res [ i Cnt - NUM ] , i Res [ i Cnt ] ) ) ; } if ( i Res . length > NUM ) al Res . add ( s Str . substring ( i Res [ i Res . length - NUM ] ) ) ; else al Res . add ( s Str ) ; String [ ] s Res = new String [ al Res . size ( ) ] ; al Res . to Array ( s Res ) ; return s Res ; }
public static boolean [ ] convert String To Boolean Arr ( String no Dictionary Col Mapping ) { String [ ] splitted Value = null != no Dictionary Col Mapping ? no Dictionary Col Mapping . split ( Carbon Common Constants . COMA SPC CHARACTER ) : new String [ NUM ] ; boolean [ ] no Dictionary Mapping = new boolean [ splitted Value . length ] ; int index = NUM ; for ( String str : splitted Value ) { no Dictionary Mapping [ index ++ ] = Boolean . parse Boolean ( str ) ; } return no Dictionary Mapping ; }
private void clear Atp Tab ( ) { m model Atp = new Default Table Model ( ) ; m table Atp . set Row Count ( NUM ) ; m table Atp . set Model ( m model Atp ) ; }
public double [ ] RG Bto IHS ( double r , double g , double b ) { double [ ] ret = new double [ NUM ] ; double i , h , s ; double min RGB = b ; i = r + g + b ; if ( g < min RGB ) { min RGB = g ; } if ( r < min RGB ) { min RGB = r ; } if ( i == NUM ) { h = NUM ; } else if ( b == min RGB ) { h = ( g - b ) / ( i - NUM * b ) ; } else if ( r == min RGB ) { h = ( b - r ) / ( i - NUM * r ) + NUM ; } else { h = ( r - g ) / ( i - NUM * g ) + NUM ; } if ( h <= NUM ) { s = ( i - NUM * b ) / i ; } else if ( h <= NUM ) { s = ( i - NUM * r ) / i ; } else { s = ( i - NUM * g ) / i ; } ret [ NUM ] = i ; ret [ NUM ] = h ; ret [ NUM ] = s ; return ret ; }
private Concurrent Buffered Update ( final Network network ) { this . network = network ; current Available Processors = get Available Consumer Processors ( ) ; executors = Executors . new Fixed Thread Pool ( current Available Processors ) ; for ( Neuron n : network . get Flat Neuron List ( ) ) { neurons . add ( n ) ; } for ( Neuron Group ng : network . get Flat Neuron Group List ( ) ) { neurons . add All ( ng . get Neuron List ( ) ) ; } task Set = new Cyclic Task Queue ( neurons , current Available Processors ) ; }
public Serial Message ( byte [ ] a , int l ) { super ( String . value Of ( a ) ) ; set Response Length ( l ) ; set Binary ( BOOL ) ; }
@ Override @ Suppress Warnings ( STRING ) public void completed ( int bytes Transferred , boolean can Invoke Direct ) { update Buffers ( bytes Transferred ) ; release Buffers ( ) ; synchronized ( result ) { if ( result . is Done ( ) ) return ; enable Writing ( ) ; if ( gathering Write ) { result . set Result ( ( V ) Long . value Of ( bytes Transferred ) ) ; } else { result . set Result ( ( V ) Integer . value Of ( bytes Transferred ) ) ; } } if ( can Invoke Direct ) { Invoker . invoke Unchecked ( result ) ; } else { Invoker . invoke ( result ) ; } }
public void write Golomb ( int divisor , int value ) throws IO Exception { int q = value / divisor ; for ( int i = NUM ; i < q ; i ++ ) { write Bit ( BOOL , MAX PROBABILITY / NUM ) ; } write Bit ( BOOL , MAX PROBABILITY / NUM ) ; int r = value - q * divisor ; int bit = NUM - Integer . number Of Leading Zeros ( divisor - NUM ) ; if ( r < ( ( NUM << bit ) - divisor ) ) { bit -- ; } else { r += ( NUM << bit ) - divisor ; } for ( ; bit >= NUM ; bit -- ) { write Bit ( ( ( r > > > bit ) & NUM ) == NUM , MAX PROBABILITY / NUM ) ; } }
public static Metric Value from Number Value ( Number number ) { if ( number == null ) { return EMPTY ; } else if ( number instanceof Float || number instanceof Double ) { return from Dbl Value ( number . double Value ( ) ) ; } else if ( number instanceof Byte || number instanceof Short || number instanceof Integer || number instanceof Long ) { return from Int Value ( number . long Value ( ) ) ; } else { throw new Illegal Argument Exception ( STRING + number . get Class ( ) ) ; } }
void add ( int start , int end ) { final Map . Entry < Integer , Integer > floor = m Intervals . floor Entry ( start ) ; final Map . Entry < Integer , Integer > end Floor = m Intervals . lower Entry ( end ) ; final int actual Start ; final int actual End ; if ( floor != null && start >= floor . get Key ( ) && end <= floor . get Value ( ) ) { return ; } if ( floor == null || start > floor . get Value ( ) ) { actual Start = start ; } else { actual Start = Math . min ( floor . get Key ( ) , start ) ; } if ( end Floor == null ) { actual End = end ; } else { actual End = Math . max ( end Floor . get Value ( ) , end ) ; } remove Contained By ( actual Start , actual End ) ; m Intervals . put ( actual Start , actual End ) ; }
public static boolean assert Equals ( final double a , final double b ) { if ( Double . is Na N ( a ) && Double . is Na N ( b ) ) { return BOOL ; } if ( a == b ) { return BOOL ; } throw new Exam Exception ( a + STRING + b ) ; }
protected void prepare ( ) { for ( Process Info Parameter para : get Parameter ( ) ) { String name = para . get Parameter Name ( ) ; if ( para . get Parameter ( ) == null ) ; else if ( name . equals ( X M Product . COLUMNNAME M Product ID ) ) { p M Product ID = para . get Parameter As Int ( ) ; } else if ( name . equals ( X M Warehouse . COLUMNNAME M Warehouse ID ) ) { p M Warehouse ID = para . get Parameter As Int ( ) ; } else if ( name . equals ( STRING ) ) { p Date Trx = ( Timestamp ) para . get Parameter ( ) ; } else if ( name . equals ( X PP Order BOM Line . COLUMNNAME Qty Required ) ) { p Qty Requiered = ( Big Decimal ) para . get Parameter ( ) ; } else if ( name . equals ( X PP Product BOM Line . COLUMNNAME Backflush Group ) ) { p Backflush Group = ( String ) para . get Parameter ( ) ; } else if ( name . equals ( X T BOM Line . COLUMNNAME Level No ) ) { p Level No = para . get Parameter As Int ( ) ; } else log . log ( Level . SEVERE , STRING + name ) ; } }
public static boolean is Truncated ( Content content ) { byte [ ] content Bytes = content . get Content ( ) ; if ( content Bytes == null ) return BOOL ; Metadata metadata = content . get Metadata ( ) ; if ( metadata == null ) return BOOL ; String length Str = metadata . get ( Response . CONTENT LENGTH ) ; if ( length Str != null ) length Str = length Str . trim ( ) ; if ( String Util . is Empty ( length Str ) ) { return BOOL ; } int in Header Size ; String url = content . get Url ( ) ; try { in Header Size = Integer . parse Int ( length Str ) ; } catch ( Number Format Exception e ) { LOG . warn ( STRING + url , e ) ; return BOOL ; } int actual Size = content Bytes . length ; if ( in Header Size > actual Size ) { LOG . info ( url + STRING + in Header Size + STRING + actual Size ) ; return BOOL ; } if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( url + STRING + actual Size + STRING + in Header Size ) ; } return BOOL ; }
private static int New String UTF ( JNI Environment env , Address utf 8 bytes ) { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { String return String = JNI Generic Helpers . create UTF String From C ( utf 8 bytes ) ; return env . push JNI Ref ( return String ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
public void make Backup File ( String name ) { File file = find File ( name ) ; if ( file == null ) { log . info ( STRING + name + STRING ) ; } else if ( file . can Write ( ) ) { String backup Name = backup File Name ( file . get Absolute Path ( ) ) ; File backup File = find File ( backup Name ) ; if ( backup File != null ) { if ( backup File . delete ( ) ) { log . debug ( STRING + backup Name ) ; } } if ( file . rename To ( new File ( backup Name ) ) ) { log . debug ( STRING + backup Name ) ; } else { log . error ( STRING + backup Name ) ; } } }
public void load Demo Files ( ) throws IO Exception { File from Dir = new File ( Xml File . xml Dir ( ) , STRING ) ; copy Backup Set ( from Dir , get Operations Root ( ) ) ; log . debug ( STRING , demo Panel File Name ) ; File src = new File ( from Dir , demo Panel File Name ) ; File dst = new File ( get Operations Root ( ) , demo Panel File Name ) ; File Helper . copy ( src . get Absolute Path ( ) , dst . get Absolute Path ( ) , BOOL ) ; }
private void add Port Bindings ( Command Input input , Port Binding [ ] port Bindings ) { Map < String , Map < String , String > > exposed Ports Map = new Hash Map < > ( ) ; input . with Property ( DOCKER CONTAINER EXPOSED PORTS PROP NAME , exposed Ports Map ) ; Map < String , Object > host Config = get Or Add Map ( input , DOCKER CONTAINER HOST CONFIG PROP NAME ) ; Map < String , List < Map < String , String > > > port Bindings Map = new Hash Map < > ( ) ; host Config . put ( DOCKER CONTAINER PORT BINDINGS PROP NAME , port Bindings Map ) ; for ( Port Binding port Binding : port Bindings ) { exposed Ports Map . put ( port Binding . container Port , Collections . empty Map ( ) ) ; Docker Port Mapping mapping = Docker Port Mapping . from String ( port Binding . to String ( ) ) ; Map < String , List < Map < String , String > > > port Details = mapping . to Map ( ) ; port Bindings Map . put All ( port Details ) ; } }
private void init App Settings ( ) { log . debug ( STRING ) ; Game Settings local Settings = new Game Settings ( ) ; init Settings ( local Settings ) ; settings = local Settings . to Read Only ( ) ; log . debug ( STRING + settings . to String ( ) ) ; }
public void add Region ( Region r ) { regions . add ( r ) ; }
public static void silent Close Input Stream ( Input Stream is ) { try { if ( is != null ) { is . close ( ) ; } } catch ( IO Exception e ) { Log . w ( LOG TAG , STRING , e ) ; } }
@ Override public void start Element ( String uri , String local Name , String q Name , Attributes attributes ) { if ( element Processor != null ) { element Processor = element Processor . get Child ( uri , local Name , q Name ) ; } else if ( ELEMENT NAME OSM . equals ( q Name ) ) { element Processor = osm Element Processor ; } else { throw new Osm Runtime Exception ( STRING ) ; } element Processor . begin ( attributes ) ; }
public void stop ( int timeout ) throws Interrupted Exception { if ( ! isclosed . compare And Set ( BOOL , BOOL ) ) { return ; } List < Web Socket > sockets To Close = null ; synchronized ( connections ) { sockets To Close = new Array List < Web Socket > ( connections ) ; } for ( Web Socket ws : sockets To Close ) { ws . close ( Close Frame . GOING AWAY ) ; } synchronized ( this ) { if ( selectorthread != null && selectorthread != Thread . current Thread ( ) ) { selector . wakeup ( ) ; selectorthread . interrupt ( ) ; selectorthread . join ( timeout ) ; } } }
public Business Object Data Create Request create Business Object Data Create Request ( String namespace Code , String business Object Definition Name , String business Object Format Usage , String business Object Format File Type , Integer business Object Format Version , String partition Key , String partition Value , String business Object Data Status Code , String storage Name , String storage Directory Path , List < Storage File > storage Files ) { Business Object Data Create Request business Object Data Create Request = new Business Object Data Create Request ( ) ; business Object Data Create Request . set Namespace ( namespace Code ) ; business Object Data Create Request . set Business Object Definition Name ( business Object Definition Name ) ; business Object Data Create Request . set Business Object Format Usage ( business Object Format Usage ) ; business Object Data Create Request . set Business Object Format File Type ( business Object Format File Type ) ; business Object Data Create Request . set Business Object Format Version ( business Object Format Version ) ; business Object Data Create Request . set Partition Key ( partition Key ) ; business Object Data Create Request . set Partition Value ( partition Value ) ; business Object Data Create Request . set Status ( business Object Data Status Code ) ; List < Storage Unit Create Request > storage Units = new Array List < > ( ) ; business Object Data Create Request . set Storage Units ( storage Units ) ; Storage Unit Create Request storage Unit = new Storage Unit Create Request ( ) ; storage Units . add ( storage Unit ) ; storage Unit . set Storage Name ( storage Name ) ; if ( storage Directory Path != null ) { Storage Directory storage Directory = new Storage Directory ( ) ; storage Unit . set Storage Directory ( storage Directory ) ; storage Directory . set Directory Path ( storage Directory Path ) ; } storage Unit . set Storage Files ( storage Files ) ; return business Object Data Create Request ; }
protected void calculate Bar Width ( Category Plot plot , Rectangle 2 D data Area , int renderer Index , Category Item Renderer State state ) { Category Axis domain Axis = get Domain Axis ( plot , renderer Index ) ; Category Dataset dataset = plot . get Dataset ( renderer Index ) ; if ( dataset != null ) { int columns = dataset . get Column Count ( ) ; int rows = state . get Visible Series Count ( ) >= NUM ? state . get Visible Series Count ( ) : dataset . get Row Count ( ) ; double space = NUM ; Plot Orientation orientation = plot . get Orientation ( ) ; if ( orientation == Plot Orientation . HORIZONTAL ) { space = data Area . get Height ( ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { space = data Area . get Width ( ) ; } double max Width = space * get Maximum Bar Width ( ) ; double category Margin = NUM ; double current Item Margin = NUM ; if ( columns > NUM ) { category Margin = domain Axis . get Category Margin ( ) ; } if ( rows > NUM ) { current Item Margin = get Item Margin ( ) ; } double used = space * ( NUM - domain Axis . get Lower Margin ( ) - domain Axis . get Upper Margin ( ) - category Margin - current Item Margin ) ; if ( ( rows * columns ) > NUM ) { state . set Bar Width ( Math . min ( used / ( rows * columns ) , max Width ) ) ; } else { state . set Bar Width ( Math . min ( used , max Width ) ) ; } } }
@ Requires Permission ( Manifest . permission . CAMERA ) public Camera Source start ( ) throws IO Exception { synchronized ( m Camera Lock ) { if ( m Camera != null ) { return this ; } m Camera = create Camera ( ) ; if ( Build . VERSION . SDK INT >= Build . VERSION CODES . HONEYCOMB ) { m Dummy Surface Texture = new Surface Texture ( DUMMY TEXTURE NAME ) ; m Camera . set Preview Texture ( m Dummy Surface Texture ) ; } else { m Dummy Surface View = new Surface View ( m Context ) ; m Camera . set Preview Display ( m Dummy Surface View . get Holder ( ) ) ; } m Camera . start Preview ( ) ; m Processing Thread = new Thread ( m Frame Processor ) ; m Frame Processor . set Active ( BOOL ) ; m Processing Thread . start ( ) ; } return this ; }
public void remove Breakpoint Listener ( final Breakpoint Listener listener ) { breakpoint Listeners . remove ( listener ) ; }
public void paint Peer ( Graphics g ) { reset Colors ( ) ; int width = get Width ( ) ; int height = get Height ( ) ; flush ( ) ; g . set Color ( get Background Color ( ) ) ; g . fill Rect ( NUM , NUM , width - NUM , height - NUM ) ; draw 3 D Rect ( g , NUM , NUM , width , height , BOOL ) ; Mapping Data mapping Data = ( Mapping Data ) get Mapping Data ( ) ; X Menu Item Peer [ ] item Vector = mapping Data . get Items ( ) ; X Menu Item Peer selected Item = get Selected Item ( ) ; for ( int i = NUM ; i < item Vector . length ; i ++ ) { X Menu Item Peer item = item Vector [ i ] ; g . set Font ( item . get Target Font ( ) ) ; Rectangle bounds = item . get Bounds ( ) ; Point text Origin = item . get Text Origin ( ) ; if ( item == selected Item ) { g . set Color ( get Selected Color ( ) ) ; g . fill Rect ( bounds . x , bounds . y , bounds . width , bounds . height ) ; draw 3 D Rect ( g , bounds . x , bounds . y , bounds . width , bounds . height , BOOL ) ; } if ( is Frame Peer Enabled ( ) && item . is Target Item Enabled ( ) ) { g . set Color ( get Foreground Color ( ) ) ; } else { g . set Color ( get Disabled Color ( ) ) ; } g . draw String ( item . get Target Label ( ) , text Origin . x , text Origin . y ) ; } flush ( ) ; }
private static void print Error ( int error Code , String cause , Throwable throwable , boolean include Stack Trace ) { print Error ( error Code , cause ) ; if ( include Stack Trace ) { if ( TLC Globals . debug ) { Debug Printer . print ( STRING ) ; throwable . print Stack Trace ( Tool IO . out ) ; } } }
@ Override public Void visit Variable ( Variable Element e , Void p ) { if ( ! check For Serial ( e ) ) { if ( e . get Kind ( ) == ENUM CONSTANT || e . get Constant Value ( ) != null || heuristically Constant ( e ) ) check All Caps ( e ) ; else check Camel Case ( e , BOOL ) ; } return null ; }
public void register Push Services With Token ( final String token ) { String http URI ; String http Method ; JSON Object data = new JSON Object ( ) ; try { data . put ( STRING , token ) ; data . put ( STRING , STRING ) ; Shared Preferences prefs = app Context . get Shared Preferences ( app Context . get Package Name ( ) , Context . MODE PRIVATE ) ; if ( null != prefs ) { String last Known Push Token = prefs . get String ( PROPERTY LAST VALID PUSH TOKEN , STRING ) ; String last Known Push Token ID = prefs . get String ( PROPERTY LAST VALID PUSH TOKEN ID , STRING ) ; if ( ( null == last Known Push Token ID ) || ( last Known Push Token ID . equals ( STRING ) ) ) { http URI = String . format ( STRING , local Connection ID ) ; http Method = STRING ; create Or Update Push Service Token ( token , http URI , http Method , data , prefs ) ; } else if ( ! last Known Push Token . equals ( STRING ) && ! last Known Push Token . equals ( token ) ) { http URI = String . format ( STRING , local Connection ID , last Known Push Token ID ) ; http Method = STRING ; create Or Update Push Service Token ( token , http URI , http Method , data , prefs ) ; } } } catch ( JSON Exception e ) { Log . d ( STRING , STRING ) ; } }
private static double log Add ( double x , double y ) { if ( y <= x ) { return x + Math . log 1 p ( Math . exp ( y - x ) ) ; } else { return y + Math . log 1 p ( Math . exp ( x - y ) ) ; } }
private void build Symetric Natural Join Definition ( List < Object > definitions , Domain left , Domain right , Expression AST left Alias , Expression AST right Alias ) { try { if ( left Alias == null ) left Alias = create Referring Expression ( left ) ; if ( right Alias == null ) right Alias = create Referring Expression ( right ) ; Table tleft = universe . get Table ( left ) ; Table tright = universe . get Table ( right ) ; Set < String > lnames = add Column Name ( tleft ) ; Set < String > rnames = add Column Name ( tright ) ; lnames . retain All ( rnames ) ; for ( String name : lnames ) { Column cleft = tleft . find Column By Name ( name ) ; Column cright = tright . find Column By Name ( name ) ; if ( cleft != null && cright != null ) { I Domain dleft = cleft . get Type Domain ( ) ; I Domain dright = cright . get Type Domain ( ) ; if ( dleft . is Instance Of ( dright ) || dright . is Instance Of ( dleft ) ) { Expression AST eleft = Expression Maker . COMPOSE ( left Alias , new Column Reference ( cleft ) ) ; Expression AST eright = Expression Maker . COMPOSE ( right Alias , new Column Reference ( cright ) ) ; Expression AST equal = Expression Maker . EQUAL ( eleft , eright ) ; definitions . add ( equal ) ; } } } } catch ( Scope Exception | Execution Exception e1 ) { } }
public static List < List < Channel > > compare Channels ( List < Channel > local Channels , List < Channel > server Channels ) { List < Channel > channels To Add = new Array List < > ( ) ; List < Channel > channels To Delete = new Array List < > ( ) ; List < Channel > channels To Update = new Array List < > ( ) ; Map < String , Channel > local Channel Map = new Array Map < > ( ) ; Map < String , Channel > server Channel Map = new Array Map < > ( ) ; for ( Channel channel : local Channels ) { local Channel Map . put ( channel . get Generated Id ( ) , channel ) ; } for ( Channel channel : server Channels ) { server Channel Map . put ( channel . get Generated Id ( ) , channel ) ; } for ( Channel channel : server Channel Map . values ( ) ) { if ( ! local Channel Map . contains Key ( channel . get Generated Id ( ) ) ) { channels To Add . add ( channel ) ; } } for ( Channel channel : local Channel Map . values ( ) ) { if ( ! server Channel Map . contains Key ( channel . get Generated Id ( ) ) ) { channels To Delete . add ( channel ) ; } } for ( Channel channel : server Channel Map . values ( ) ) { Channel local Channel = local Channel Map . get ( channel . get Generated Id ( ) ) ; if ( local Channel != null ) { if ( ! local Channel . metadata Equals ( channel ) ) { channel . set Id ( local Channel . get Id ( ) ) ; channels To Update . add ( channel ) ; } } } List < List < Channel > > channel Comparison = new Array List < > ( ) ; channel Comparison . add ( channels To Update ) ; channel Comparison . add ( channels To Add ) ; channel Comparison . add ( channels To Delete ) ; return channel Comparison ; }
private File upload To Tmp ( ) throws Import Exception { if ( file File Name == null ) { return null ; } File tmp File = data Dir . tmp File ( shortname , file File Name ) ; LOG . debug ( STRING + shortname + STRING + tmp File . get Absolute Path ( ) ) ; Input Stream input = null ; Output Stream output = null ; try { input = new File Input Stream ( file ) ; output = new File Output Stream ( tmp File ) ; IO Utils . copy ( input , output ) ; output . flush ( ) ; LOG . debug ( STRING + file File Name + STRING + file Content Type ) ; } catch ( IO Exception e ) { LOG . error ( e ) ; throw new Import Exception ( STRING , e ) ; } finally { if ( output != null ) { IO Utils . close Quietly ( output ) ; } if ( input != null ) { IO Utils . close Quietly ( input ) ; } } return tmp File ; }
public E take ( ) throws Interrupted Exception { final Reentrant Lock lock = this . lock ; lock . lock Interruptibly ( ) ; try { for ( ; ; ) { E first = q . peek ( ) ; if ( first == null ) available . await ( ) ; else { long delay = first . get Delay ( NANOSECONDS ) ; if ( delay <= NUM ) return q . poll ( ) ; first = null ; if ( leader != null ) available . await ( ) ; else { Thread this Thread = Thread . current Thread ( ) ; leader = this Thread ; try { available . await Nanos ( delay ) ; } finally { if ( leader == this Thread ) leader = null ; } } } } } finally { if ( leader == null && q . peek ( ) != null ) available . signal ( ) ; lock . unlock ( ) ; } }
public boolean submit Action ( Action 0 action ) { boolean submitted = BOOL ; Thread current Thread = Thread . current Thread ( ) ; if ( current Thread . equals ( duty Thread ) ) { action . call ( ) ; } else { submitted = actions . offer ( action ) ; } return submitted ; }
boolean match Attribute Selections ( HTML Element element ) { if ( get Tag Id ( ) == TAG CSS ILLEGAL SELECTOR ) { return BOOL ; } if ( attribute Selections == null ) { return BOOL ; } for ( Enumeration e = attribute Selections . elements ( ) ; e . has More Elements ( ) ; ) { Att String att Str = ( Att String ) e . next Element ( ) ; if ( att Str . constraint == Att String . LANG ) { String lang = att Str . value ; String elem Lang = get Lang ( element ) ; if ( ( elem Lang == null ) || ( ( ! lang . equals ( elem Lang ) ) && ( ! elem Lang . starts With ( lang + STRING ) ) ) ) { return BOOL ; } } else { String element Val = element . get Attribute ( att Str . attribute ) ; if ( element Val == null ) { return BOOL ; } if ( att Str . value != null ) { switch ( att Str . constraint ) { case Att String . EQUALS : if ( ! element Val . equals ( att Str . value ) ) { return BOOL ; } break ; case Att String . BEGINS WITH : if ( ( ! element Val . equals ( att Str . value ) ) && ( ! element Val . starts With ( att Str . value + STRING ) ) ) { return BOOL ; } break ; case Att String . CONTAINS WORD : String str = STRING + element Val + STRING ; if ( str . index Of ( STRING + att Str . value + STRING ) == - NUM ) { return BOOL ; } break ; } } } } return BOOL ; }
public void remove Value ( Value value ) { action Values . remove ( value ) ; action Values As Array = null ; }
@ Override public void channel Open ( Channel Handler Context channel Handler Context , Channel State Event channel State Event ) throws Exception { total conns . increment And Get ( ) ; curr conns . increment And Get ( ) ; channel Group . add ( channel Handler Context . get Channel ( ) ) ; }
@ Override public void on New Frame ( final Head Transform head Transform ) { FPS Counter . log Frame ( ) ; if ( pref Show Env && ! bg Env . is Ready ( ) ) { if ( pref Show Env String . equals ( STRING ) ) bg Env . init ( NUM ) ; else bg Env . init ( NUM ) ; bg Env . set Fixed Model ( ) ; move Thing ( bg Env ) ; } Matrix . set Look At M ( m Camera , NUM , NUM , NUM , CAMERA Z , NUM , NUM , NUM , NUM , NUM , NUM ) ; GLES 20 . gl Clear Color ( r , g , b , a ) ; head Transform . get Head View ( m Head View SDK , NUM ) ; m Head View Use = get Head View ( ) ; if ( screen . is Looking At Object ( m Head View Use ) ) { aim Point . set Alpha ( NUM ) ; } else { aim Point . set Alpha ( NUM ) ; } for ( Button Thing button : button List ) { if ( button . is Looking At Object ( m Head View Use ) && ! button . is Hidden ) { if ( fuse Start == - NUM ) { fuse Start = System Clock . elapsed Realtime ( ) ; fuse Button = button ; } else if ( fuse Button == button ) { check Fuse ( System Clock . elapsed Realtime ( ) ) ; } } else if ( fuse Button == button ) { check Fuse ( NUM ) ; fuse Start = - NUM ; fuse Button = null ; } } Engine . check GL Error ( STRING ) ; }
public static boolean is Next Window ( URI id ) { return NEXT . equals ( id ) ; }
public Queue Event offer ( byte [ ] data , long timeout ) throws Keeper Exception , Interrupted Exception { Timer Context time = stats . time ( dir + STRING ) ; try { String path = create Data ( dir + STRING + prefix , data , Create Mode . PERSISTENT SEQUENTIAL ) ; String watch ID = create Data ( dir + STRING + response prefix + path . substring ( path . last Index Of ( STRING ) + NUM ) , null , Create Mode . EPHEMERAL ) ; Object lock = new Object ( ) ; Latch Child Watcher watcher = new Latch Child Watcher ( lock ) ; synchronized ( lock ) { if ( zookeeper . exists ( watch ID , watcher , BOOL ) != null ) { watcher . await ( timeout ) ; } } byte [ ] bytes = zookeeper . get Data ( watch ID , null , null , BOOL ) ; zookeeper . delete ( watch ID , - NUM , BOOL ) ; return new Queue Event ( watch ID , bytes , watcher . get Watched Event ( ) ) ; } finally { time . stop ( ) ; } }
public Property XML Builder ( String service Name , AM Model model , Set attribute Schemas , Schema Type schema Type ) throws SMS Exception , SSO Exception { this . model = model ; this . service Name = service Name ; svc Schema Manager = new Service Schema Manager ( service Name , model . get User SSO Token ( ) ) ; if ( schema Type != null ) { if ( load Section Order ( ) ) { schema Types = new Hash Set < Schema Type > ( ) ; schema Types . add ( schema Type ) ; get Sections For Type ( ) ; } } get Service Resource Bundle ( ) ; if ( service Bundle != null ) { map Type To Attribute Schema = new Hash Map ( attribute Schemas . size ( ) * NUM ) ; map Type To Attribute Schema . put ( NULL TYPE , attribute Schemas ) ; } }
public static String Buffer string Substitution ( String arg Str , Map vars ) { String Buffer arg Buf = new String Buffer ( ) ; for ( int c Idx = NUM ; c Idx < arg Str . length ( ) ; ) { char ch = arg Str . char At ( c Idx ) ; switch ( ch ) { case STRING : String Buffer name Buf = new String Buffer ( ) ; for ( ++ c Idx ; c Idx < arg Str . length ( ) ; ++ c Idx ) { ch = arg Str . char At ( c Idx ) ; if ( ch == STRING || Character . is Letter Or Digit ( ch ) ) name Buf . append ( ch ) ; else break ; } if ( name Buf . length ( ) > NUM ) { String value = ( String ) vars . get ( name Buf . to String ( ) ) ; if ( value != null ) { arg Buf . append ( value ) ; } } break ; default : arg Buf . append ( ch ) ; ++ c Idx ; break ; } } return arg Buf ; }
static public Array List < String > generate Array List ( String [ ] array ) { Argument Checking . not Null ( array , STRING ) ; Array List < String > list = new Array List < String > ( array . length ) ; for ( int i = NUM ; i < array . length ; ++ i ) { list . add ( i , array [ i ] ) ; } return list ; }
private void show Next Super Toast ( ) { final Super Activity Toast super Activity Toast = m List . peek ( ) ; if ( m List . is Empty ( ) || super Activity Toast . get Activity ( ) == null ) { return ; } if ( ! super Activity Toast . is Showing ( ) ) { final Message message = obtain Message ( Messages . DISPLAY ) ; message . obj = super Activity Toast ; send Message ( message ) ; } }
public void test vmstat header and data parse ( ) { final Pattern pattern = VM Stat Collector . pattern ; final String h0 = STRING ; final String h1 = STRING ; final String d1 = STRING ; { final String [ ] fields = pattern . split ( h0 . trim ( ) , NUM ) ; for ( int i = NUM ; i < fields . length ; i ++ ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + i + STRING + fields [ i ] + STRING ) ; } assert Field ( h0 , fields , NUM , STRING ) ; assert Field ( h0 , fields , NUM , STRING ) ; } { final String [ ] fields = pattern . split ( h1 . trim ( ) , NUM ) ; for ( int i = NUM ; i < fields . length ; i ++ ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + i + STRING + fields [ i ] + STRING ) ; } assert Field ( h1 , fields , NUM , STRING ) ; assert Field ( h1 , fields , NUM , STRING ) ; assert Field ( h1 , fields , NUM , STRING ) ; assert Field ( h1 , fields , NUM , STRING ) ; assert Field ( h1 , fields , NUM , STRING ) ; assert Field ( h1 , fields , NUM , STRING ) ; assert Field ( h1 , fields , NUM , STRING ) ; assert Field ( h1 , fields , NUM , STRING ) ; assert Field ( h1 , fields , NUM , STRING ) ; assert Field ( h1 , fields , NUM , STRING ) ; assert Field ( h1 , fields , NUM , STRING ) ; } { final String [ ] fields = pattern . split ( d1 . trim ( ) , NUM ) ; assert Field ( d1 , fields , NUM , STRING ) ; assert Field ( d1 , fields , NUM , STRING ) ; assert Field ( d1 , fields , NUM , STRING ) ; assert Field ( d1 , fields , NUM , STRING ) ; assert Field ( d1 , fields , NUM , STRING ) ; assert Field ( d1 , fields , NUM , STRING ) ; assert Field ( d1 , fields , NUM , STRING ) ; assert Field ( d1 , fields , NUM , STRING ) ; assert Field ( d1 , fields , NUM , STRING ) ; assert Field ( d1 , fields , NUM , STRING ) ; assert Field ( d1 , fields , NUM , STRING ) ; } }
private String extract Context ( String s , int position ) { String Builder sb = new String Builder ( ) ; int j = position - NUM ; char c = s . char At ( j ) ; while ( j > NUM && c != STRING && c != STRING ) { c = s . char At ( -- j ) ; } String ps = j > NUM ? s . substring ( j + NUM , position ) : s . substring ( NUM , position ) ; ps = convert ( ps ) ; sb . append ( STRING ) ; sb . append ( ps ) ; sb . append ( STRING ) ; sb . append ( lexicon . has Word ( ps ) ? NUM : NUM ) ; j = position + NUM ; c = s . char At ( j ) ; while ( j < s . length ( ) && c != STRING && c != STRING ) { c = s . char At ( j ++ ) ; } String ns = j < s . length ( ) ? s . substring ( position + NUM , j - NUM ) : s . substring ( position + NUM ) ; ns = convert ( ns ) ; sb . append ( STRING ) ; sb . append ( ns ) ; sb . append ( STRING ) ; sb . append ( lexicon . has Word ( ns ) ? NUM : NUM ) ; sb . append ( STRING ) ; sb . append ( ps ) ; sb . append ( STRING ) ; sb . append ( ns ) ; return sb . to String ( ) ; }
@ Override public void run ( ) { try { while ( running ) { step ( ) ; try { Thread . sleep ( step Pause ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } } } catch ( Null Pointer Exception e ) { robot Gui . notify Initialize ( ) ; } catch ( Robot Exception e ) { } try { running Lock . acquire ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } running = BOOL ; gui . enable Buttons ( gui . button State Normal ) ; button . set Text ( gui . auto Locate Title ) ; running Lock . release ( ) ; }
public int read ( Byte Buffer dst ) throws IO Exception { if ( ! dst . has Remaining ( ) ) return NUM ; if ( ! is Hand Shake Complete ( ) ) { if ( is Blocking ( ) ) { while ( ! is Hand Shake Complete ( ) ) { process Handshake ( ) ; } } else { process Handshake ( ) ; if ( ! is Hand Shake Complete ( ) ) { return NUM ; } } } int purged = read Remaining ( dst ) ; if ( purged != NUM ) return purged ; assert ( in Data . position ( ) == NUM ) ; in Data . clear ( ) ; if ( ! in Crypt . has Remaining ( ) ) in Crypt . clear ( ) ; else in Crypt . compact ( ) ; if ( is Blocking ( ) || read Engine Result . get Status ( ) == Status . BUFFER UNDERFLOW ) if ( socket Channel . read ( in Crypt ) == - NUM ) { return - NUM ; } in Crypt . flip ( ) ; unwrap ( ) ; int transfered = transfere To ( in Data , dst ) ; if ( transfered == NUM && is Blocking ( ) ) { return read ( dst ) ; } return transfered ; }
private Class Vertex add Class And Get Class Vertex ( X Class xclass ) { if ( xclass == null ) { throw new Illegal State Exception ( ) ; } Linked List < X Class > work List = new Linked List < X Class > ( ) ; work List . add ( xclass ) ; while ( ! work List . is Empty ( ) ) { X Class work = work List . remove First ( ) ; Class Vertex vertex = class Descriptor To Vertex Map . get ( work . get Class Descriptor ( ) ) ; if ( vertex != null && vertex . is Finished ( ) ) { continue ; } if ( vertex == null ) { vertex = Class Vertex . create Resolved Class Vertex ( work . get Class Descriptor ( ) , work ) ; add Vertex To Graph ( work . get Class Descriptor ( ) , vertex ) ; } add Supertype Edges ( vertex , work List ) ; vertex . set Finished ( BOOL ) ; } return class Descriptor To Vertex Map . get ( xclass . get Class Descriptor ( ) ) ; }
public void wait For Ready ( long how long ) throws IO Exception { long since = System . current Time Millis ( ) ; synchronized ( state mutex ) { while ( BOOL ) { if ( state == State . DEMO ) { return ; } else if ( state == State . ERROR || state == State . DISCONNECTED ) { throw new IO Exception ( STRING ) ; } else if ( ( System . current Time Millis ( ) - since ) >= how long ) { try { disconnect ( ) ; } catch ( IO Exception e ) { } throw new IO Exception ( STRING ) ; } long p = Math . min ( how long - ( System . current Time Millis ( ) - since ) , how long ) ; if ( p > NUM ) { try { state mutex . wait ( p ) ; } catch ( Interrupted Exception e ) { } } } } }
void delete Replica Based On Count ( Cluster State cluster State , Zk Node Props message , Named List results , Runnable on Complete , boolean parallel ) throws Keeper Exception , Interrupted Exception { ocmh . check Required ( message , COLLECTION PROP , COUNT PROP ) ; int count = Integer . parse Int ( message . get Str ( COUNT PROP ) ) ; String collection Name = message . get Str ( COLLECTION PROP ) ; String shard = message . get Str ( SHARD ID PROP ) ; Doc Collection coll = cluster State . get Collection ( collection Name ) ; Slice slice = null ; if ( shard != null ) { slice = coll . get Slice ( shard ) ; if ( slice == null ) { throw new Solr Exception ( Solr Exception . Error Code . BAD REQUEST , STRING + shard + STRING + collection Name ) ; } } Map < Slice , Set < String > > shard To Replicas Mapping = new Hash Map < Slice , Set < String > > ( ) ; if ( slice != null ) { Set < String > replicas To Be Deleted = pick Replicas Tobe Deleted ( slice , shard , collection Name , count ) ; shard To Replicas Mapping . put ( slice , replicas To Be Deleted ) ; } else { Collection < Slice > all Slices = coll . get Slices ( ) ; for ( Slice individual Slice : all Slices ) { Set < String > replicas To Be Deleted = pick Replicas Tobe Deleted ( individual Slice , individual Slice . get Name ( ) , collection Name , count ) ; shard To Replicas Mapping . put ( individual Slice , replicas To Be Deleted ) ; } } for ( Slice shard Slice : shard To Replicas Mapping . key Set ( ) ) { String shard Id = shard Slice . get Name ( ) ; Set < String > replicas = shard To Replicas Mapping . get ( shard Slice ) ; for ( String replica : replicas ) { log . debug ( STRING , replica , shard Id , count ) ; delete Core ( shard Slice , collection Name , replica , message , shard , results , on Complete , parallel ) ; } results . add ( STRING , shard Id ) ; results . add ( STRING , replicas ) ; } }
default Type Declaration as Type ( ) { throw new Unsupported Operation Exception ( String . format ( STRING , this ) ) ; }
protected static @ Not Null String convert Map To Groovy Source ( @ Not Null Map < String , Object > map ) { String Builder sb = new String Builder ( ) ; for ( Map . Entry < String , Object > entry : map . entry Set ( ) ) { if ( sb . length ( ) > NUM ) { sb . append ( STRING ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( STRING ) ; sb . append ( convert Value To Groovy Source ( entry . get Value ( ) ) ) ; } return sb . to String ( ) ; }
public void upload Image ( Multipart File file , Long cheque ID , String username ) { if ( ! file . is Empty ( ) ) { Photo photo = new Photo ( ) ; try { photo . set Bytes ( file . get Bytes ( ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } photo . set Name ( file . get Original Filename ( ) ) ; photo . set Content Type ( file . get Content Type ( ) ) ; photo . set Cheque Id ( cheque ID . to String ( ) ) ; photo . set Username ( username ) ; photo . set Add Date ( Offset Date Time . now ( ) ) ; photo Repository . save ( photo ) ; } }
public void record Bounds ( final Planet Model planet Model , final Lat Lon Bounds bounds Info , final Membership ... bounds ) { final double A = this . x ; final double B = this . y ; final double C = this . z ; if ( ! bounds Info . check No Top Latitude Bound ( ) || ! bounds Info . check No Bottom Latitude Bound ( ) ) { if ( ( Math . abs ( A ) >= MINIMUM RESOLUTION || Math . abs ( B ) >= MINIMUM RESOLUTION ) ) { final Plane vertical Plane = construct Normalized Z Plane ( A , B ) ; final Geo Point [ ] points = find Intersections ( planet Model , vertical Plane , bounds , NO BOUNDS ) ; for ( final Geo Point point : points ) { add Point ( bounds Info , bounds , point ) ; } } else { final Geo Point [ ] points = find Intersections ( planet Model , normal X Plane , NO BOUNDS , NO BOUNDS ) ; bounds Info . add Z Value ( points [ NUM ] ) ; } } if ( ! bounds Info . check No Longitude Bound ( ) ) { double a ; double b ; double c ; if ( Math . abs ( C ) < MINIMUM RESOLUTION ) { if ( Math . abs ( D ) >= MINIMUM RESOLUTION ) { if ( Math . abs ( A ) > Math . abs ( B ) ) { a = B * B * planet Model . inverse Ab Squared + A * A * planet Model . inverse Ab Squared ; b = NUM * B * D * planet Model . inverse Ab Squared ; c = D * D * planet Model . inverse Ab Squared - A * A ; double sqrt Clause = b * b - NUM * a * c ; if ( Math . abs ( sqrt Clause ) < MINIMUM RESOLUTION SQUARED ) { double y0 = - b / ( NUM * a ) ; double x0 = ( - D - B * y0 ) / A ; double z0 = NUM ; add Point ( bounds Info , bounds , new Geo Point ( x0 , y0 , z0 ) ) ; } else if ( sqrt Clause > NUM ) { double sqrt Result = Math . sqrt ( sqrt Clause ) ; double denom = NUM / ( NUM * a ) ; double Hdenom = NUM / A ; double y0 a = ( - b + sqrt Result ) * denom ; double y0 b = ( - b - sqrt Result ) * denom ; double x0 a = ( - D - B * y0 a ) * Hdenom ; double x0 b = ( - D - B * y0 b ) * Hdenom ; double z0 a = NUM ; double z0 b = NUM ; add Point ( bounds Info , bounds , new Geo Point ( x0 a , y0 a , z0 a ) ) ; add Point ( bounds Info , bounds , new Geo Point ( x0 b , y0 b , z0 b ) ) ; } } else { a = B * B * planet Model . inverse Ab Squared + A * A * planet Model . inverse Ab Squared ; b = NUM * A * D * planet Model . inverse Ab Squared ; c = D * D * planet Model . inverse Ab Squared - B * B ; double sqrt Clause = b * b - NUM * a * c ; if ( Math . abs ( sqrt Clause ) < MINIMUM RESOLUTION SQUARED ) { double x0 = - b / ( NUM * a ) ; double y0 = ( - D - A * x0 ) / B ; double z0 = NUM ; add Point ( bounds Info , bounds , new Geo Point ( x0 , y0 , z0 ) ) ; } else if ( sqrt Clause > NUM ) { double sqrt Result = Math . sqrt ( sqrt Clause ) ; double denom = NUM / ( NUM * a ) ; double Idenom = NUM / B ; double x0 a = ( - b + sqrt Result ) * denom ; double x0 b = ( - b - sqrt Result ) * denom ; double y0 a = ( - D - A * x0 a ) * Idenom ; double y0 b = ( - D - A * x0 b ) * Idenom ; double z0 a = NUM ; double z0 b = NUM ; add Point ( bounds Info , bounds , new Geo Point ( x0 a , y0 a , z0 a ) ) ; add Point ( bounds Info , bounds , new Geo Point ( x0 b , y0 b , z0 b ) ) ; } } } } else { double E = A * A * planet Model . inverse C Squared + C * C * planet Model . inverse Ab Squared ; double F = B * B * planet Model . inverse C Squared + C * C * planet Model . inverse Ab Squared ; double G = NUM * A * B * planet Model . inverse C Squared ; double H = NUM * A * D * planet Model . inverse C Squared ; double I = NUM * B * D * planet Model . inverse C Squared ; double J = D * D * planet Model . inverse C Squared - C * C ; if ( Math . abs ( J ) >= MINIMUM RESOLUTION && J > NUM ) { if ( Math . abs ( H ) > Math . abs ( I ) ) { a = E * I * I - G * H * I + F * H * H ; b = NUM * E * I * J - NUM * G * H * J ; c = NUM * E * J * J - J * H * H ; double sqrt Clause = b * b - NUM * a * c ; if ( Math . abs ( sqrt Clause ) < MINIMUM RESOLUTION CUBED ) { double y0 = - b / ( NUM * a ) ; double x0 = ( - NUM * J - I * y0 ) / H ; double z0 = ( - A * x0 - B * y0 - D ) / C ; add Point ( bounds Info , bounds , new Geo Point ( x0 , y0 , z0 ) ) ; } else if ( sqrt Clause > NUM ) { double sqrt Result = Math . sqrt ( sqrt Clause ) ; double denom = NUM / ( NUM * a ) ; double Hdenom = NUM / H ; double Cdenom = NUM / C ; double y0 a = ( - b + sqrt Result ) * denom ; double y0 b = ( - b - sqrt Result ) * denom ; double x0 a = ( - NUM * J - I * y0 a ) * Hdenom ; double x0 b = ( - NUM * J - I * y0 b ) * Hdenom ; double z0 a = ( - A * x0 a - B * y0 a - D ) * Cdenom ; double z0 b = ( - A * x0 b - B * y0 b - D ) * Cdenom ; add Point ( bounds Info , bounds , new Geo Point ( x0 a , y0 a , z0 a ) ) ; add Point ( bounds Info , bounds , new Geo Point ( x0 b , y0 b , z0 b ) ) ; } } else { a = E * I * I - G * H * I + F * H * H ; b = NUM * F * H * J - NUM * G * I * J ; c = NUM * F * J * J - J * I * I ; double sqrt Clause = b * b - NUM * a * c ; if ( Math . abs ( sqrt Clause ) < MINIMUM RESOLUTION CUBED ) { double x0 = - b / ( NUM * a ) ; double y0 = ( - NUM * J - H * x0 ) / I ; double z0 = ( - A * x0 - B * y0 - D ) / C ; add Point ( bounds Info , bounds , new Geo Point ( x0 , y0 , z0 ) ) ; } else if ( sqrt Clause > NUM ) { double sqrt Result = Math . sqrt ( sqrt Clause ) ; double denom = NUM / ( NUM * a ) ; double Idenom = NUM / I ; double Cdenom = NUM / C ; double x0 a = ( - b + sqrt Result ) * denom ; double x0 b = ( - b - sqrt Result ) * denom ; double y0 a = ( - NUM * J - H * x0 a ) * Idenom ; double y0 b = ( - NUM * J - H * x0 b ) * Idenom ; double z0 a = ( - A * x0 a - B * y0 a - D ) * Cdenom ; double z0 b = ( - A * x0 b - B * y0 b - D ) * Cdenom ; add Point ( bounds Info , bounds , new Geo Point ( x0 a , y0 a , z0 a ) ) ; add Point ( bounds Info , bounds , new Geo Point ( x0 b , y0 b , z0 b ) ) ; } } } } } }
public static Parse Result parse ( String expression , String epl Statement Error Msg , boolean add Please Check , Parse Rule Selector parse Rule Selector , boolean rewrite Script ) throws EP Exception { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + expression ) ; } Char Stream input ; try { input = new No Case Sensitive Stream ( new String Reader ( expression ) ) ; } catch ( IO Exception ex ) { throw new EP Exception ( STRING + expression + STRING , ex ) ; } Esper EPL 2 Grammar Lexer lex = new Lexer ( input ) ; Common Token Stream tokens = new Common Token Stream ( lex ) ; Esper EPL 2 Grammar Parser parser = Parse Helper . new Parser ( tokens ) ; Tree tree ; try { tree = parse Rule Selector . invoke Parse Rule ( parser ) ; } catch ( Recognition Exception ex ) { tokens . fill ( ) ; if ( rewrite Script && is Contains Script Expression ( tokens ) ) { return handle Script Rewrite ( tokens , epl Statement Error Msg , add Please Check , parse Rule Selector ) ; } log . debug ( STRING + expression + STRING , ex ) ; throw Exception Convertor . convert Statement ( ex , epl Statement Error Msg , add Please Check , parser ) ; } catch ( Runtime Exception e ) { try { tokens . fill ( ) ; } catch ( Runtime Exception ex ) { log . debug ( STRING + e . get Message ( ) , e ) ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + epl Statement Error Msg + STRING , e ) ; } if ( e . get Cause ( ) instanceof Recognition Exception ) { if ( rewrite Script && is Contains Script Expression ( tokens ) ) { return handle Script Rewrite ( tokens , epl Statement Error Msg , add Please Check , parse Rule Selector ) ; } throw Exception Convertor . convert Statement ( ( Recognition Exception ) e . get Cause ( ) , epl Statement Error Msg , add Please Check , parser ) ; } else { throw e ; } } if ( rewrite Script && is Contains Script Expression ( tokens ) ) { return handle Script Rewrite ( tokens , epl Statement Error Msg , add Please Check , parse Rule Selector ) ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; AST Util . dump AST ( tree ) ; } String expression Without Annotation = expression ; if ( tree instanceof Esper EPL 2 Grammar Parser . Start EPL Expression Rule Context ) { Esper EPL 2 Grammar Parser . Start EPL Expression Rule Context epl = ( Esper EPL 2 Grammar Parser . Start EPL Expression Rule Context ) tree ; expression Without Annotation = get No Annotation ( expression , epl . annotation Enum ( ) , tokens ) ; } else if ( tree instanceof Esper EPL 2 Grammar Parser . Start Pattern Expression Rule Context ) { Esper EPL 2 Grammar Parser . Start Pattern Expression Rule Context pattern = ( Esper EPL 2 Grammar Parser . Start Pattern Expression Rule Context ) tree ; expression Without Annotation = get No Annotation ( expression , pattern . annotation Enum ( ) , tokens ) ; } return new Parse Result ( tree , expression Without Annotation , tokens , Collections . < String > empty List ( ) ) ; }
public void add Remove And Get Time Nanos ( long duration ) { rmv Time Nanos . add And Get ( duration ) ; get Time Nanos . add And Get ( duration ) ; if ( delegate != null ) delegate . add Remove And Get Time Nanos ( duration ) ; }
private float check Valid ( final float val ) { float tempval = val ; if ( val > NUM ) { tempval = NUM ; } if ( val < NUM ) { tempval = NUM ; } return tempval ; }
private void validate Layout ( ) { List < String > missing Ids = new Array List < String > ( ) ; for ( String id : layout . string Key Set ( ) ) { if ( layout . get Cell ( id ) == null ) { missing Ids . add ( id ) ; } } if ( missing Ids . size ( ) > NUM ) { throw new Illegal State Exception ( STRING + missing Ids ) ; } for ( String cell : layout . get Cells ( ) ) { String id = layout . parse ( cell , Layout Constants . ID ) ; if ( layout . get ( id ) == null ) { missing Ids . add ( id ) ; } } if ( missing Ids . size ( ) > NUM ) { throw new Illegal State Exception ( STRING + missing Ids ) ; } }
public void add ( Permission permission ) { if ( ! ( permission instanceof Property Permission ) ) throw new Illegal Argument Exception ( STRING + permission ) ; if ( is Read Only ( ) ) throw new Security Exception ( STRING ) ; Property Permission pp = ( Property Permission ) permission ; String prop Name = pp . get Name ( ) ; synchronized ( this ) { Property Permission existing = perms . get ( prop Name ) ; if ( existing != null ) { int old Mask = existing . get Mask ( ) ; int new Mask = pp . get Mask ( ) ; if ( old Mask != new Mask ) { int effective = old Mask | new Mask ; String actions = Property Permission . get Actions ( effective ) ; perms . put ( prop Name , new Property Permission ( prop Name , actions ) ) ; } } else { perms . put ( prop Name , pp ) ; } } if ( ! all allowed ) { if ( prop Name . equals ( STRING ) ) all allowed = BOOL ; } }
private boolean execute ( String command , File arg , List < String > lines ) { Process Builder pb = new Process Builder ( command , arg . get Absolute Path ( ) ) ; pb . redirect Error Stream ( BOOL ) ; try { Process proc = pb . start ( ) ; Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( proc . get Input Stream ( ) ) ) ; String line ; while ( ( line = reader . read Line ( ) ) != null ) { lines . add ( line ) ; } proc . wait For ( ) ; return proc . exit Value ( ) == NUM ; } catch ( Exception e ) { log . error ( STRING + command + STRING + arg , e ) ; lines . add ( e . get Message ( ) ) ; return BOOL ; } }
@ Override public Selectable Channel selectable Channel ( ) { if ( s != null ) { return s . get Channel ( ) ; } else { return null ; } }
private void process Tag ( final String Builder builder ) { boolean started = BOOL ; while ( template Reader . has Next Character ( ) ) { final char tag Character = template Reader . next Character ( ) ; if ( ! started && Strings . is Whitespace ( tag Character ) ) { continue ; } started = BOOL ; if ( tag Character == syntax . get Argument Opening ( ) ) { process Argument ( ) ; } else if ( tag Character == syntax . get Tag Opening ( ) && is Next Character Comment Opening ( ) ) { process Comment ( ) ; } else if ( tag Character == syntax . get Tag Closing ( ) ) { process Tag Entity ( builder ) ; return ; } else { builder . append ( tag Character ) ; } } throw Error ( STRING + builder . to String ( ) ) ; }
private Design File open dialog ( Stat stat , String p design dir name ) { J File Chooser file chooser = new J File Chooser ( p design dir name ) ; File Filter file filter = new File Filter ( Design File . all file extensions ) ; file chooser . set File Filter ( file filter ) ; file chooser . show Open Dialog ( null ) ; File curr design file = file chooser . get Selected File ( ) ; if ( curr design file == null ) return null ; return new Design File ( stat , curr design file , file chooser ) ; }
private static int Windows Reg Set Value Ex 1 ( int h Key , byte [ ] value Name , byte [ ] value ) { int result = Windows Reg Set Value Ex ( h Key , value Name , value ) ; if ( result == ERROR SUCCESS ) { return result ; } else { long sleep Time = INIT SLEEP TIME ; for ( int i = NUM ; i < MAX ATTEMPTS ; i ++ ) { try { Thread . sleep ( sleep Time ) ; } catch ( Interrupted Exception e ) { return result ; } sleep Time *= NUM ; result = Windows Reg Set Value Ex ( h Key , value Name , value ) ; if ( result == ERROR SUCCESS ) { return result ; } } } return result ; }
public Date parse Date ( String str ) { try { return date Format . parse ( str ) ; } catch ( java . text . Parse Exception e ) { throw new Runtime Exception ( e ) ; } }
private void sort ( int column Index , int sort Count ) { Sort Order order = Sort Order . values ( ) [ sort Count % NUM ] ; List < Row Sorter . Sort Key > sort Keys = new Array List < > ( ) ; if ( column Index != NUM ) { sort Keys . add ( new Row Sorter . Sort Key ( NUM , Sort Order . DESCENDING ) ) ; } sort Keys . add ( new Row Sorter . Sort Key ( column Index , order ) ) ; sorter . set Sort Keys ( sort Keys ) ; this . sort Count = sort Count ; sorted Column = column Index ; }
public final void search Pattern ( I Progress Monitor monitor ) throws Java Model Exception { Assert . is Not Null ( f Pattern ) ; if ( monitor == null ) monitor = new Null Progress Monitor ( ) ; try { monitor . begin Task ( STRING , NUM ) ; monitor . set Task Name ( Refactoring Core Messages . Refactoring Search Engine searching occurrences ) ; try { Search Engine engine = null ; if ( f Owner != null ) engine = new Search Engine ( f Owner ) ; else engine = new Search Engine ( f Working Copies ) ; engine . search ( f Pattern , Search Utils . get Default Search Participants ( ) , f Scope , get Collector ( ) , new Sub Progress Monitor ( monitor , NUM , Sub Progress Monitor . SUPPRESS SUBTASK LABEL ) ) ; } catch ( Core Exception exception ) { throw new Java Model Exception ( exception ) ; } } finally { monitor . done ( ) ; } }
@ Override public Object annotation Button ( final Form Object form ) { final int subtype = form . get Parameter Constant ( Pdf Dictionary . Subtype ) ; if ( subtype == Pdf Dictionary . Popup ) { return create Annotation Popup ( form ) ; } if ( ! form . is Appearance Used ( ) ) { switch ( subtype ) { case Pdf Dictionary . Text : return create Annotation Text ( form ) ; case Pdf Dictionary . Free Text : return create Annotation Free Text ( form ) ; case Pdf Dictionary . Highlight : return create Anntoation Highlight ( form ) ; case Pdf Dictionary . Underline : return create Annotation Underline ( form ) ; case Pdf Dictionary . Ink : return create Annotation Ink ( form ) ; case Pdf Dictionary . Strick Out : return create Annotation Strike Out ( form ) ; } } return setup Annotation Button ( form ) ; }
private String reset Preferred IDP Cookie ( String existing Cookie Value , String to Add Cookie Value , boolean b Is SAML 2 ) { String Buffer return Cookie = new String Buffer ( ) ; String encoded Cookie To Add = Base 64 . encode ( generate Succinct ID ( to Add Cookie Value , b Is SAML 2 ) ) ; String Tokenizer st = new String Tokenizer ( existing Cookie Value , IDP Discovery Constants . PREFERRED COOKIE SEPERATOR ) ; while ( st . has More Tokens ( ) ) { String cur Idp String = ( String ) st . next Token ( ) ; if ( cur Idp String . equals ( encoded Cookie To Add ) ) { continue ; } else { return Cookie . append ( cur Idp String + STRING ) ; } } return Cookie . append ( encoded Cookie To Add ) ; return return Cookie . to String ( ) ; }
static void create Directory ( final String directory ) throws IO Exception { File dir = new File ( directory ) ; if ( ! dir . exists ( ) ) { if ( ! dir . mkdirs ( ) ) { throw new IO Exception ( STRING + directory ) ; } } }
public int find Julian Day From Position ( int position ) { if ( m Row Info == null || position < NUM ) { return NUM ; } int len = m Row Info . size ( ) ; if ( position >= len ) return NUM ; for ( int index = position ; index >= NUM ; index -- ) { Row Info row = m Row Info . get ( index ) ; if ( row . m Type == TYPE DAY ) { return row . m Day ; } } return NUM ; }
final public void println ( double v ) { String s = String . value Of ( v ) ; write ( s , NUM , s . length ( ) ) ; println ( ) ; }
public static void move And Mask ( final I Translation Environment environment , final long offset , final Operand Size value Size , final String value , final String sub Register , final List < Reil Instruction > instructions ) throws Illegal Argument Exception , Internal Translation Exception , Illegal Argument Exception { Preconditions . check Not Null ( environment , STRING ) ; Preconditions . check Not Null ( value , STRING ) ; Preconditions . check Not Null ( sub Register , STRING ) ; Preconditions . check Not Null ( value Size , STRING ) ; Preconditions . check Not Null ( instructions , STRING ) ; final String parent Register = get Parent Register ( sub Register ) ; final Operand Size register Size = get Register Size ( sub Register ) ; final Operand Size parent Register Size = get Register Size ( parent Register ) ; final Operand Size arch Size = environment . get Architecture Size ( ) ; if ( register Size . get Byte Size ( ) >= arch Size . get Byte Size ( ) ) { throw new Internal Translation Exception ( STRING ) ; } if ( value Size . get Byte Size ( ) >= arch Size . get Byte Size ( ) ) { throw new Internal Translation Exception ( STRING ) ; } if ( value Size . get Byte Size ( ) >= parent Register Size . get Byte Size ( ) ) { throw new Internal Translation Exception ( STRING ) ; } final String mask = String . value Of ( get Negative Mask ( sub Register ) ) ; if ( is Higher 8 Bit Register ( sub Register ) ) { final String shifted Value = environment . get Next Variable String ( ) ; final String masked Value = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create Bsh ( offset , value Size , value , value Size , STRING , arch Size , shifted Value ) ) ; instructions . add ( Reil Helpers . create And ( offset + NUM , arch Size , parent Register , arch Size , mask , arch Size , masked Value ) ) ; instructions . add ( Reil Helpers . create Or ( offset + NUM , arch Size , shifted Value , arch Size , masked Value , arch Size , parent Register ) ) ; } else { final String masked Value = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create And ( offset , arch Size , parent Register , arch Size , mask , arch Size , masked Value ) ) ; instructions . add ( Reil Helpers . create Or ( offset + NUM , value Size , value , arch Size , masked Value , arch Size , parent Register ) ) ; } }
public void clear Interceptors ( ) { clear Request Interceptors ( ) ; clear Response Interceptors ( ) ; }
private String prep Operand ( String label ) { String Builder sb = new String Builder ( STRING ) ; sb . append ( label ) ; sb . append ( Lop . DATATYPE PREFIX ) ; sb . append ( get Data Type ( ) ) ; sb . append ( Lop . VALUETYPE PREFIX ) ; sb . append ( get Value Type ( ) ) ; return sb . to String ( ) ; }
private static void analyze New String Set Contains Old String Set Values ( String Set a , String Set b , String name , Hash Map < String , Change > changes ) { if ( a != null ) { Iterator < String > iter = a . iterator ( ) ; while ( iter . has Next ( ) ) { String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; } String key = name + STRING + val ; Change change = new Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } else if ( a == null && b != null ) { String key = name ; Change change = new Change ( key , null , NOT NULL , name ) ; changes . put ( key , change ) ; } }
private void register Heap Variables ( IR ir ) { SSA Dictionary dictionary = ir . HIR Info . dictionary ; for ( Enumeration < Basic Block > bbe = ir . get Basic Blocks ( ) ; bbe . has More Elements ( ) ; ) { Basic Block b = bbe . next Element ( ) ; for ( Enumeration < Instruction > e = b . forward Instr Enumerator ( ) ; e . has More Elements ( ) ; ) { Instruction s = e . next Element ( ) ; if ( s . is Implicit Load ( ) || s . is Implicit Store ( ) || s . is Allocation ( ) || Phi . conforms ( s ) || s . is PEI ( ) || Label . conforms ( s ) || B Bend . conforms ( s ) || s . get Opcode ( ) == UNINT BEGIN opcode || s . get Opcode ( ) == UNINT END opcode ) { dictionary . register Instruction ( s , b ) ; } } } }
private List < Test Package > build Tests To Run ( ) { List < Test Package > test Pkg List = new Linked List < Test Package > ( ) ; try { I Test Package Repo test Repo = create Test Case Repo ( ) ; Collection < I Test Package Def > test Pkg Defs = get Test Packages To Run ( test Repo ) ; for ( I Test Package Def test Pkg Def : test Pkg Defs ) { add Test Package ( test Pkg List , test Pkg Def ) ; } if ( test Pkg List . is Empty ( ) ) { Log . log And Display ( Log Level . WARN , LOG TAG , STRING ) ; } } catch ( File Not Found Exception e ) { throw new Illegal Argument Exception ( STRING , e ) ; } catch ( Parse Exception e ) { throw new Illegal Argument Exception ( STRING , e ) ; } catch ( Configuration Exception e ) { throw new Illegal Argument Exception ( STRING , e ) ; } return test Pkg List ; }
private void interpret Method Result ( final Method Result method Result , final Class Result class Result ) { if ( method Result . get Sub Resource ( ) != null ) { interpret Class Result ( method Result . get Sub Resource ( ) ) ; return ; } final String path = Path Normalizer . get Path ( method Result ) ; final Resource Method resource Method = interpret Resource Method ( method Result , class Result ) ; resources . add Method ( path , resource Method ) ; }
private boolean check GML Footprint ( String footprint ) { try { Configuration configuration = new GML Configuration ( ) ; Parser parser = new Parser ( configuration ) ; parser . parse ( new Input Source ( new String Reader ( footprint ) ) ) ; return BOOL ; } catch ( Exception e ) { LOGGER . error ( STRING + e . get Message ( ) ) ; return BOOL ; } }
public static double quantile ( double p , double k , double theta , double shift ) { return Math . log ( Gamma Distribution . quantile ( p , k , theta ) ) + shift ; }
public Text Editor Init ( final Text Editor Configuration configuration , final Event Bus general Event Bus , final Code Assistant Factory code Assistant Factory , final Quick Assist Assistant quick Assist , final Text Editor Presenter < T > text Editor ) { this . configuration = configuration ; this . general Event Bus = general Event Bus ; this . code Assistant Factory = code Assistant Factory ; this . quick Assist = quick Assist ; this . text Editor = text Editor ; }
final void put Double ( int offset , double value ) { unsafe . put Double ( offset + address , value ) ; }
public final void add Validation Errors ( Iterable < String > errors ) { for ( String error : errors ) { validation Errors . add ( error ) ; } }
final Dialog Option show Yes No Cancel Message ( String message , Int Setting def Value ) { Dialog Option ret = Dialog Option . parse Int ( def Value . get Value ( ) ) ; if ( ret == Dialog Option . YES || ret == Dialog Option . NO ) return ret ; int option ; try { option = J Option Pane . show Confirm Dialog ( get Parent Component ( ) , always Use This Answer Label ( message , def Value ) , I18 n . tr ( STRING ) , J Option Pane . YES NO CANCEL OPTION ) ; } catch ( Array Index Out Of Bounds Exception aioobe ) { option = J Option Pane . CANCEL OPTION ; } catch ( Internal Error ie ) { option = J Option Pane . CANCEL OPTION ; } if ( option == J Option Pane . YES OPTION ) ret = Dialog Option . YES ; else if ( option == J Option Pane . NO OPTION ) ret = Dialog Option . NO ; else ret = Dialog Option . CANCEL ; if ( def Value . get Value ( ) == REMEMBER ANSWER && ret != Dialog Option . CANCEL ) def Value . set Value ( ret . to Int ( ) ) ; else def Value . set Value ( FORGET ANSWER ) ; return ret ; }
public Big Integer calculate Secret ( Big Integer client A ) throws Crypto Exception { this . A = SRP 6 Util . validate Public Value ( N , client A ) ; this . u = SRP 6 Util . calculate U ( digest , N , A , B ) ; this . S = calculate S ( ) ; return S ; }
public void reload ( Solr Core core , Solr Index Searcher searcher ) throws IO Exception { LOG . info ( STRING + name + STRING ) ; if ( dictionary == null && store Dir != null ) { File lookup File = get Store File ( ) ; if ( lookup File . exists ( ) ) { File Input Stream is = new File Input Stream ( lookup File ) ; try { if ( lookup . load ( is ) ) { return ; } } finally { IO Utils . close While Handling Exception ( is ) ; } } else { LOG . info ( STRING ) ; } } }
protected void cancel ( ) { clear Images ( ) ; if ( callbacks != null ) { for ( Guided Tour Life Cycle guided Tour Life Cycle : callbacks ) { guided Tour Life Cycle . end ( ) ; } } }
private void connect ( ) throws IO Exception { JMX Service URL jmx Url = new JMX Service URL ( String . format ( FMTURL , host , host , port ) ) ; Map < String , Object > env = new Hash Map < String , Object > ( ) ; if ( username != null ) { String [ ] creds = { username , password } ; env . put ( JMX Connector . CREDENTIALS , creds ) ; } jmxc = JMX Connector Factory . connect ( jmx Url , env ) ; mbean Server Conn = jmxc . get M Bean Server Connection ( ) ; try { Object Name name = new Object Name ( SSOBJNAME ) ; ss Proxy = JMX . new M Bean Proxy ( mbean Server Conn , name , Storage Service M Bean . class ) ; snitch Proxy = JMX . new M Bean Proxy ( mbean Server Conn , new Object Name ( STRING ) , Endpoint Snitch Info M Bean . class ) ; internode Auth Proxy = JMX . new M Bean Proxy ( mbean Server Conn , new Object Name ( Geo Internode Authenticator M Bean . MBEAN NAME ) , Geo Internode Authenticator M Bean . class ) ; db Mgr Ops = new Db Manager Ops ( mbean Server Conn ) ; } catch ( Malformed Object Name Exception e ) { throw new Runtime Exception ( STRING , e ) ; } }
private Node search Word ( Node Array children , String word , int depth , Node parent Node ) { final int word Length = word . length ( ) ; final char c = word . char At ( depth ) ; final int children Length = children . length ; Node child Node = null ; boolean found = BOOL ; for ( int i = NUM ; i < children Length ; i ++ ) { child Node = children . data [ i ] ; if ( child Node . code == c ) { found = BOOL ; break ; } } if ( ! found ) { child Node = new Node ( ) ; child Node . code = c ; child Node . parent = parent Node ; children . add ( child Node ) ; } if ( word Length == depth + NUM ) { child Node . terminal = BOOL ; return child Node ; } if ( child Node . children == null ) { child Node . children = new Node Array ( ) ; } return search Word ( child Node . children , word , depth + NUM , child Node ) ; }
private void split Full Name ( ) { int first End = full Name . index Of ( STRING ) ; int second End = full Name . index Of ( STRING , first End + NUM ) ; timestamp = full Name . substring ( NUM , first End ) ; unique String = full Name . substring ( first End + NUM , second End ) ; hostname And Meta = full Name . substring ( second End + NUM , full Name . length ( ) ) ; }
@ Override public void handle Click ( int x , int y , Plot Rendering Info info ) { Rectangle 2 D data Area = info . get Data Area ( ) ; if ( data Area . contains ( x , y ) ) { Value Axis xaxis = get Domain Axis ( ) ; if ( xaxis != null ) { double hvalue = xaxis . java 2 D To Value ( x , info . get Data Area ( ) , get Domain Axis Edge ( ) ) ; set Domain Crosshair Value ( hvalue ) ; } Value Axis yaxis = get Range Axis ( ) ; if ( yaxis != null ) { double vvalue = yaxis . java 2 D To Value ( y , info . get Data Area ( ) , get Range Axis Edge ( ) ) ; set Range Crosshair Value ( vvalue ) ; } } }
public void test park For 2 ( ) throws Exception { Cyclic Barrier barrier = new Cyclic Barrier ( NUM ) ; Parker parker = new Parker ( barrier , BOOL , NUM ) ; Thread parker Thread = new Thread ( parker ) ; Thread waiter Thread = new Thread ( new Wait And Unpark ( barrier , NUM , parker Thread ) ) ; parker Thread . start ( ) ; waiter Thread . start ( ) ; parker . assert Duration Is In Range ( NUM ) ; waiter Thread . join ( ) ; parker Thread . join ( ) ; }
@ Override public String to String ( ) { String Builder risul = new String Builder ( NUM ) ; risul . append ( classname ) ; risul . append ( STRING ) ; return risul . to String ( ) ; }
protected int vector len ( int offset ) { offset += bb pos ; offset += bb . get Int ( offset ) ; return bb . get Int ( offset ) ; }
public Task < Void > handle Registration Intent Async ( Intent intent ) { List < Task < Void > > tasks = new Array List < > ( ) ; String registration Id = intent . get String Extra ( REGISTRATION ID EXTRA ) ; if ( registration Id != null && registration Id . length ( ) > NUM ) { P Log . v ( TAG , STRING + registration Id + STRING ) ; Parse Installation installation = Parse Installation . get Current Installation ( ) ; if ( ! registration Id . equals ( installation . get Device Token ( ) ) ) { installation . set Push Type ( Push Type . GCM ) ; installation . set Device Token ( registration Id ) ; tasks . add ( installation . save In Background ( ) ) ; } tasks . add ( update Local Device Token Last Modified Async ( ) ) ; } synchronized ( lock ) { if ( request != null ) { request . on Receive Response Intent ( intent ) ; } } return Task . when All ( tasks ) ; }
public static Element create Element In Encryption 11 Space ( Document doc , String element Name ) { if ( doc == null ) { throw new Runtime Exception ( STRING ) ; } if ( ( xenc 11 Prefix == null ) || ( xenc 11 Prefix . length ( ) == NUM ) ) { return doc . create Element NS ( Encryption Constants . Encryption Spec 11 NS , element Name ) ; } return doc . create Element NS ( Encryption Constants . Encryption Spec 11 NS , xenc 11 Prefix + STRING + element Name ) ; }
public static final double next Double ( double value ) { if ( value == Double . POSITIVE INFINITY ) { return value ; } long bits ; if ( value == NUM ) { bits = NUM ; } else { bits = Double . double To Long Bits ( value ) ; } return Double . long Bits To Double ( value < NUM ? bits - NUM : bits + NUM ) ; }
public static J File Chooser user File Chooser ( String filter , String suffix 1 , String suffix 2 ) { J File Chooser fc = new J File Chooser ( File Util . get User Files Path ( ) ) ; No Archive File Filter filt = new No Archive File Filter ( filter ) ; if ( suffix 1 != null ) { filt . add Extension ( suffix 1 ) ; } if ( suffix 2 != null ) { filt . add Extension ( suffix 2 ) ; } fc . set File Filter ( filt ) ; return fc ; }
public void add Tele Missile Attack ( Attack Action ea ) { pending Tele Missile Attacks . add Element ( ea ) ; process Game Event ( new Game New Action Event ( this , ea ) ) ; }
public void add Command ( PDF Cmd cmd ) { synchronized ( commands ) { commands . add ( cmd ) ; } update Images ( ) ; }
public String to String ( ) { String Buffer sb = new String Buffer ( ) ; char [ ] separator = { STRING , STRING } ; for ( int i = NUM ; i < components . length ; i ++ ) { sb . append ( separator ) ; sb . append ( components [ i ] ) ; separator [ NUM ] = STRING ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public void add First ( Statement Sequence statements ) { if ( statements != null ) { sequence . add All ( NUM , statements . sequence ) ; } }
private void remove ( int hash Code ) { synchronized ( m Records ) { Iterator < Record > iterator = m Records . iterator ( ) ; while ( iterator . has Next ( ) ) { Record record = ( Record ) iterator . next ( ) ; if ( record . m Hash Code == hash Code ) { iterator . remove ( ) ; } } } }
public double elasticity Forward ( ) { final double val = value ( ) ; final double del = delta Forward ( ) ; if ( val > Constants . QL EPSILON ) return del / val * forward ; else if ( Math . abs ( del ) < Constants . QL EPSILON ) return NUM ; else if ( del > NUM ) return Double . MAX VALUE ; else return Double . MIN VALUE ; }
private byte [ ] entity To Bytes ( Request < ? > request , Http Entity entity ) throws IO Exception , Server Error { Pooling Byte Array Output Stream bytes = new Pooling Byte Array Output Stream ( m Pool , ( int ) entity . get Content Length ( ) ) ; byte [ ] buffer = null ; long total Size = ( int ) entity . get Content Length ( ) ; try { Progress Listener progress Listener = null ; if ( request instanceof Progress Listener ) { progress Listener = ( Progress Listener ) request ; } Input Stream in = entity . get Content ( ) ; if ( in == null ) { throw new Server Error ( ) ; } buffer = m Pool . get Buf ( NUM ) ; int count ; int transferred Bytes = NUM ; while ( ( count = in . read ( buffer ) ) != - NUM ) { bytes . write ( buffer , NUM , count ) ; transferred Bytes += count ; if ( null != progress Listener ) { progress Listener . on Progress ( transferred Bytes , total Size ) ; } } return bytes . to Byte Array ( ) ; } finally { try { entity . consume Content ( ) ; } catch ( IO Exception e ) { Volley Log . v ( STRING ) ; } m Pool . return Buf ( buffer ) ; bytes . close ( ) ; } }
public static float round Float ( float value , int after Decimal Point ) { float mask = ( float ) Math . pow ( NUM , ( float ) after Decimal Point ) ; return ( float ) ( Math . round ( value * mask ) ) / mask ; }
@ Not Null public Runner add Runner ( @ Not Null Application Process Descriptor process Descriptor ) { Run Options run Options = dto Factory . create Dto ( Run Options . class ) ; Runner runner = models Factory . create Runner ( run Options ) ; String environment Id = process Descriptor . get Environment Id ( ) ; if ( environment Id != null && environment Id . starts With ( PROJECT PREFIX ) ) { runner . set Scope ( PROJECT ) ; } runners Id . add ( process Descriptor . get Process Id ( ) ) ; runner . set Process Descriptor ( process Descriptor ) ; runner . set RAM ( process Descriptor . get Memory Size ( ) ) ; runner . set Status ( Runner . Status . DONE ) ; runner . reset Creation Time ( ) ; history . add Runner ( runner ) ; on Selection Changed ( RUNNER ) ; runner Timer . schedule ( ONE SEC . get Value ( ) ) ; Launch Action launch Action = action Factory . create Launch ( ) ; runner Actions . put ( runner , launch Action ) ; launch Action . perform ( runner ) ; select History Tab ( ) ; return runner ; }
public static boolean is Windows 7 ( ) { return os Name . index Of ( STRING ) > - NUM && os Version . equals ( STRING ) ; }
private String boolean To String ( Boolean input ) { if ( input == null ) { return null ; } else { return input . to String ( ) ; } }
private static int [ ] maximum Sizes ( Container container , List form Specs , List [ ] component Lists , Measure min Measure , Measure pref Measure , Measure default Measure ) { Form Spec form Spec ; int size = form Specs . size ( ) ; int [ ] result = new int [ size ] ; for ( int i = NUM ; i < size ; i ++ ) { form Spec = ( Form Spec ) form Specs . get ( i ) ; result [ i ] = form Spec . maximum Size ( container , component Lists [ i ] , min Measure , pref Measure , default Measure ) ; } return result ; }

public static boolean is Node After ( Node node 1 , Node node 2 ) { if ( node 1 == node 2 || is Node The Same ( node 1 , node 2 ) ) return BOOL ; boolean is Node After = BOOL ; Node parent 1 = get Parent Of Node ( node 1 ) ; Node parent 2 = get Parent Of Node ( node 2 ) ; if ( parent 1 == parent 2 || is Node The Same ( parent 1 , parent 2 ) ) { if ( null != parent 1 ) is Node After = is Node After Sibling ( parent 1 , node 1 , node 2 ) ; else { } } else { int n Parents 1 = NUM , n Parents 2 = NUM ; while ( parent 1 != null ) { n Parents 1 ++ ; parent 1 = get Parent Of Node ( parent 1 ) ; } while ( parent 2 != null ) { n Parents 2 ++ ; parent 2 = get Parent Of Node ( parent 2 ) ; } Node start Node 1 = node 1 , start Node 2 = node 2 ; if ( n Parents 1 < n Parents 2 ) { int adjust = n Parents 2 - n Parents 1 ; for ( int i = NUM ; i < adjust ; i ++ ) { start Node 2 = get Parent Of Node ( start Node 2 ) ; } } else if ( n Parents 1 > n Parents 2 ) { int adjust = n Parents 1 - n Parents 2 ; for ( int i = NUM ; i < adjust ; i ++ ) { start Node 1 = get Parent Of Node ( start Node 1 ) ; } } Node prev Child 1 = null , prev Child 2 = null ; while ( null != start Node 1 ) { if ( start Node 1 == start Node 2 || is Node The Same ( start Node 1 , start Node 2 ) ) { if ( null == prev Child 1 ) { is Node After = ( n Parents 1 < n Parents 2 ) ? BOOL : BOOL ; break ; } else { is Node After = is Node After Sibling ( start Node 1 , prev Child 1 , prev Child 2 ) ; break ; } } prev Child 1 = start Node 1 ; start Node 1 = get Parent Of Node ( start Node 1 ) ; prev Child 2 = start Node 2 ; start Node 2 = get Parent Of Node ( start Node 2 ) ; } } return is Node After ; }
@ Override public Log Message read Next Log Message ( ) { while ( BOOL ) { if ( file Counter . get ( ) >= log Paths . size ( ) ) { break ; } if ( reader == null ) { String file Path = log Paths . get ( file Counter . get ( ) ) ; try { reader = new Log Reader ( file Path , request , status , basename ) ; } catch ( Exception e ) { status . append ( String . format ( STRING , e . get Message ( ) ) ) ; logger . error ( STRING , e . get Message ( ) ) ; return null ; } logger . debug ( STRING + file Path ) ; File f = new File ( file Path ) ; size Counter . add And Get ( f . length ( ) ) ; } if ( current Log != null ) { prev Log Time = current Log . get Time ( ) ; } current Log = reader . read Next Log Message ( ) ; if ( current Log != null ) { log Counter . increment And Get ( ) ; current Log . set Service ( Log Util . service To Bytes ( basename ) ) ; if ( ! Log Util . permit Current Log ( request . get Max Count ( ) , log Counter . get ( ) , current Log . get Time ( ) , prev Log Time ) ) { break ; } return current Log ; } else { reader = null ; file Counter . increment And Get ( ) ; } } return null ; }
private void load Binary ( Byte Buffer bb ) throws IO Exception { if ( bb . get Int ( ) != MAGIC ) { throw new Error ( STRING ) ; } if ( bb . get Int ( ) != VERSION ) { throw new Error ( STRING ) ; } continuity Weight = bb . get Int ( ) ; optimal Coupling = bb . get Int ( ) ; extend Selections = bb . get Int ( ) ; join Method = bb . get Int ( ) ; join Weight Shift = bb . get Int ( ) ; int weight Length = bb . get Int ( ) ; join Weights = new int [ weight Length ] ; for ( int i = NUM ; i < join Weights . length ; i ++ ) { join Weights [ i ] = bb . get Int ( ) ; } int units Length = bb . get Int ( ) ; units = new Database Cluster Unit [ units Length ] ; for ( int i = NUM ; i < units . length ; i ++ ) { units [ i ] = new Database Cluster Unit ( bb ) ; } int unit Types Length = bb . get Int ( ) ; unit Types = new Unit Type [ unit Types Length ] ; for ( int i = NUM ; i < unit Types . length ; i ++ ) { unit Types [ i ] = new Unit Type ( bb ) ; } sts = new Sample Set ( bb ) ; mcep = new Sample Set ( bb ) ; int num Carts = bb . get Int ( ) ; cart Map = new Hash Map ( ) ; for ( int i = NUM ; i < num Carts ; i ++ ) { String name = Utilities . get String ( bb ) ; CART cart = CART Impl . load Binary ( bb ) ; cart Map . put ( name , cart ) ; if ( default Cart == null ) { default Cart = cart ; } } }
public static String to String ( int i ) { if ( i < NUMBERS MIN || i > NUMBERS MAX ) return Integer . to String ( i , NUM ) ; return NUMBERS [ i ] ; }
public static void update Provider Key Info ( String realm , String entity ID , String cert Alias , boolean is Signing , boolean is IDP , String enc Algo , int key Size ) throws IDFF Meta Exception { IDFF Meta Manager meta Manager = FS Utils . get IDFF Meta Manager ( ) ; Entity Config Element config = meta Manager . get Entity Config ( realm , entity ID ) ; if ( ! config . is Hosted ( ) ) { String [ ] args = { entity ID , realm } ; throw new IDFF Meta Exception ( STRING , args ) ; } Entity Descriptor Element desp = meta Manager . get Entity Descriptor ( realm , entity ID ) ; if ( is IDP ) { IDP Descriptor Config Element idp Config = IDFF Meta Utils . get IDP Descriptor Config ( config ) ; IDP Descriptor Type idp Desp = IDFF Meta Utils . get IDP Descriptor ( desp ) ; if ( ( idp Config == null ) || ( idp Desp == null ) ) { String [ ] args = { entity ID , realm } ; throw new IDFF Meta Exception ( STRING , args ) ; } if ( ( cert Alias == null ) || ( cert Alias . length ( ) == NUM ) ) { remove Key Descriptor ( idp Desp , is Signing ) ; if ( is Signing ) { set Extended Attribute Value ( idp Config , IFS Constants . SIGNING CERT ALIAS , null ) ; } else { set Extended Attribute Value ( idp Config , IFS Constants . ENCRYPTION CERT ALIAS , null ) ; } } else { Key Descriptor Element kde = get Key Descriptor ( cert Alias , is Signing , enc Algo , key Size ) ; update Key Descriptor ( idp Desp , kde ) ; Set value = new Hash Set ( ) ; value . add ( cert Alias ) ; if ( is Signing ) { set Extended Attribute Value ( idp Config , IFS Constants . SIGNING CERT ALIAS , value ) ; } else { set Extended Attribute Value ( idp Config , IFS Constants . ENCRYPTION CERT ALIAS , value ) ; } } meta Manager . set Entity Descriptor ( realm , desp ) ; meta Manager . set Entity Config ( realm , config ) ; } else { SP Descriptor Config Element sp Config = IDFF Meta Utils . get SP Descriptor Config ( config ) ; SP Descriptor Type sp Desp = IDFF Meta Utils . get SP Descriptor ( desp ) ; if ( ( sp Config == null ) || ( sp Desp == null ) ) { String [ ] args = { entity ID , realm } ; throw new IDFF Meta Exception ( STRING , args ) ; } if ( ( cert Alias == null ) || ( cert Alias . length ( ) == NUM ) ) { remove Key Descriptor ( sp Desp , is Signing ) ; if ( is Signing ) { set Extended Attribute Value ( sp Config , IFS Constants . SIGNING CERT ALIAS , null ) ; } else { set Extended Attribute Value ( sp Config , IFS Constants . ENCRYPTION CERT ALIAS , null ) ; } } else { Key Descriptor Element kde = get Key Descriptor ( cert Alias , is Signing , enc Algo , key Size ) ; update Key Descriptor ( sp Desp , kde ) ; Set value = new Hash Set ( ) ; value . add ( cert Alias ) ; if ( is Signing ) { set Extended Attribute Value ( sp Config , IFS Constants . SIGNING CERT ALIAS , value ) ; } else { set Extended Attribute Value ( sp Config , IFS Constants . ENCRYPTION CERT ALIAS , value ) ; } } meta Manager . set Entity Descriptor ( realm , desp ) ; meta Manager . set Entity Config ( realm , config ) ; } }
public static Path create Temp File ( Path temp Dir Path , String prefix , String suffix ) throws IO Exception { if ( ! Files . exists ( temp Dir Path ) ) { Files . create Directory ( temp Dir Path ) ; } return Files . create Temp File ( temp Dir Path , prefix , suffix , permissions ) ; }
public Selection Input Dialog ( Window owner , String key , boolean editable , Collection < T > selection Values , T initial Selection Value , Input Validator < T > input Validator , Object ... key Arguments ) { this ( owner , key , selection Values , initial Selection Value , input Validator , key Arguments ) ; combo Box . set Editable ( editable ) ; }
public void reload ( Solr Core core , Solr Index Searcher searcher ) throws IO Exception { LOG . info ( STRING + name + STRING ) ; if ( dictionary == null && store Dir != null ) { File lookup File = get Store File ( ) ; if ( lookup File . exists ( ) ) { File Input Stream is = new File Input Stream ( lookup File ) ; try { if ( lookup . load ( is ) ) { return ; } } finally { IO Utils . close While Handling Exception ( is ) ; } } else { LOG . info ( STRING ) ; } } }
public synchronized byte to Byte Array ( ) [ ] { return Arrays . copy Of ( buf , count ) ; }
public void create Vm Async ( final String project Id , final Vm Create Spec vm Create Spec , final Future Callback < Task > response Callback ) throws IO Exception { final String path = String . format ( STRING , get Base Path ( ) , project Id ) ; create Object Async ( path , serialize Object As Json ( vm Create Spec ) , response Callback ) ; }
@ Override public boolean domain Match ( final String host , final String domain ) { final boolean match = host . equals ( domain ) || ( domain . starts With ( STRING ) && host . ends With ( domain ) ) ; return match ; }
public synchronized void enable Attribute ( String name ) throws java . lang . Illegal Argument Exception { if ( name == null ) { throw new java . lang . Illegal Argument Exception ( STRING ) ; } if ( ! enabled Attributes . contains ( name ) ) { enabled Attributes . add Element ( name ) ; } }
public void push ( final long value ) { if ( value == NUM || value == NUM ) { mv . visit Insn ( Opcodes . LCONST 0 + ( int ) value ) ; } else { mv . visit Ldc Insn ( value ) ; } }
public static String [ ] split ( final Char Sequence char Sequence , final char separator ) { if ( is Empty ( char Sequence ) ) { return EMPTY ARRAY ; } final int original Separators Count = count Separated Char Appearances ( char Sequence , separator ) ; int separators Count = original Separators Count ; if ( starts With ( char Sequence , separator ) ) { separators Count -- ; } if ( char Sequence . length ( ) > NUM && ends With ( char Sequence , separator ) ) { separators Count -- ; } if ( separators Count <= NUM ) { if ( original Separators Count == NUM ) { return new String [ ] { char Sequence . to String ( ) } ; } else if ( is Same Char ( char Sequence ) ) { return EMPTY ARRAY ; } return new String [ ] { remove Character ( char Sequence . to String ( ) , separator ) } ; } final String [ ] result = new String [ separators Count + NUM ] ; int current Result Index = NUM ; final String Builder builder = new String Builder ( ) ; for ( int index = NUM , length = char Sequence . length ( ) ; index < length ; index ++ ) { final char character = char Sequence . char At ( index ) ; if ( character == separator ) { if ( is Not Empty ( builder ) ) { result [ current Result Index ++ ] = builder . to String ( ) ; clear Builder ( builder ) ; } } else { builder . append ( character ) ; } } if ( is Not Empty ( builder ) ) { result [ current Result Index ++ ] = builder . to String ( ) ; } return result ; }
private static void assert Change Events ( Collection < Port Change Event > early Events , Collection < Port Change Event > late Events , Collection < Port Change Event > anytime Events , Collection < Port Change Event > actual Events ) { String input Desc = String . format ( STRING + STRING , early Events . to String ( ) , late Events . to String ( ) , anytime Events . to String ( ) , actual Events . to String ( ) ) ; Collection < Port Change Event > early = new Array List < Port Change Event > ( early Events ) ; Collection < Port Change Event > late = new Array List < Port Change Event > ( late Events ) ; Collection < Port Change Event > any = new Array List < Port Change Event > ( anytime Events ) ; for ( Port Change Event ev : early ) { assert False ( STRING , late . contains ( ev ) ) ; assert False ( STRING , any . contains ( ev ) ) ; } for ( Port Change Event ev : late ) { assert False ( STRING , early . contains ( ev ) ) ; assert False ( STRING , any . contains ( ev ) ) ; } for ( Port Change Event ev : any ) { assert False ( STRING , early . contains ( ev ) ) ; assert False ( STRING , late . contains ( ev ) ) ; } for ( Port Change Event a : actual Events ) { if ( early . remove ( a ) ) { continue ; } if ( any . remove ( a ) ) { continue ; } if ( late . remove ( a ) ) { if ( ! early . is Empty ( ) ) { fail ( a + STRING + STRING + input Desc ) ; } else { continue ; } } fail ( a + STRING + input Desc ) ; } if ( ! early . is Empty ( ) ) fail ( STRING + early + STRING + input Desc ) ; if ( ! late . is Empty ( ) ) fail ( STRING + late + STRING + input Desc ) ; if ( ! any . is Empty ( ) ) fail ( STRING + any + STRING + input Desc ) ; }
public static void write String Fixed Size ( final Data Output out , String s , int size ) throws IO Exception { byte [ ] b = to Bytes ( s ) ; if ( b . length > size ) { throw new IO Exception ( STRING + b . length + STRING + to String Binary ( b ) + STRING + size ) ; } out . write Bytes ( s ) ; for ( int i = NUM ; i < size - s . length ( ) ; ++ i ) out . write Byte ( NUM ) ; }
public void toggle Expanded ( ) { Simple Boolean Property expanded = expanded Property ( ) ; expanded . set Value ( ! expanded . get Value ( ) ) ; }
private static Byte Buffer decode Percent Encoded Octets ( String s , int i , Byte Buffer bb ) { if ( bb == null ) { bb = Byte Buffer . allocate ( NUM ) ; } else { bb . clear ( ) ; } while ( BOOL ) { bb . put ( ( byte ) ( decode Hex ( s , i ++ ) << NUM | decode Hex ( s , i ++ ) ) ) ; if ( i == s . length ( ) ) { break ; } if ( s . char At ( i ++ ) != STRING ) { break ; } if ( bb . position ( ) == bb . capacity ( ) ) { bb . flip ( ) ; Byte Buffer bb new = Byte Buffer . allocate ( s . length ( ) / NUM ) ; bb new . put ( bb ) ; bb = bb new ; } } bb . flip ( ) ; return bb ; }
public Array Field Vector ( T [ ] v1 , Field Vector < T > v2 ) throws Null Argument Exception { Math Utils . check Not Null ( v1 ) ; Math Utils . check Not Null ( v2 ) ; field = v2 . get Field ( ) ; final T [ ] v2 Data = ( v2 instanceof Array Field Vector ) ? ( ( Array Field Vector < T > ) v2 ) . data : v2 . to Array ( ) ; data = Math Arrays . build Array ( field , v1 . length + v2 Data . length ) ; System . arraycopy ( v1 , NUM , data , NUM , v1 . length ) ; System . arraycopy ( v2 Data , NUM , data , v1 . length , v2 Data . length ) ; }
public void stop ( ) { if ( s Logger . is Activated ( ) ) { s Logger . info ( STRING ) ; } m Check Handler . remove Messages ( CHECK MESSAGE ) ; if ( m Observer Is Registered ) { m Contacts Contract Cursor . unregister Content Observer ( m Contacts Contract Observer ) ; m Observer Is Registered = BOOL ; m Contacts Contract Cursor . close ( ) ; } m Cleanup Executor . shutdown Now ( ) ; }
protected final void fire Vetoable Change ( String property Name , float old Value , float new Value ) throws Property Veto Exception { fire Vetoable Change ( property Name , Float . value Of ( old Value ) , Float . value Of ( new Value ) ) ; }
public void test LM Jelinek Mercer ( ) throws IO Exception { float p = ( NUM - NUM ) * FREQ / DOC LEN + NUM * ( TOTAL TERM FREQ + NUM ) / ( NUMBER OF FIELD TOKENS + NUM ) ; float gold = ( float ) ( Math . log ( p / ( NUM * ( TOTAL TERM FREQ + NUM ) / ( NUMBER OF FIELD TOKENS + NUM ) ) ) ) ; correctness Test Core ( new LM Jelinek Mercer Similarity ( NUM ) , gold ) ; }
public void calculate Sources Sinks Entrypoints ( String source Sink File ) throws IO Exception , Xml Pull Parser Exception { I Source Sink Definition Provider parser = null ; String file Extension = source Sink File . substring ( source Sink File . last Index Of ( STRING ) ) ; file Extension = file Extension . to Lower Case ( ) ; if ( file Extension . equals ( STRING ) ) parser = XML Source Sink Parser . from File ( source Sink File ) ; else if ( file Extension . equals ( STRING ) ) parser = Permission Method Parser . from File ( source Sink File ) ; else throw new Unsupported Data Type Exception ( STRING ) ; calculate Sources Sinks Entrypoints ( parser ) ; }
@ Transactional public Role DTO save ( Role DTO dto ) { if ( dto == null ) { return null ; } Role role ; if ( dto . is Id Set ( ) ) { role = role Repository . find One ( dto . id ) ; } else { role = new Role ( ) ; } role . set Role Name ( dto . role Name ) ; return to DTO ( role Repository . save ( role ) ) ; }
protected void write External Primary Keys Create Stmt ( Table table , Column [ ] primary Key Columns , String Builder ddl ) { if ( ( primary Key Columns . length > NUM ) && should Generate Primary Keys ( primary Key Columns ) ) { ddl . append ( STRING ) ; ddl . append ( get Fully Qualified Table Name Shorten ( table ) ) ; println ( ddl ) ; print Indent ( ddl ) ; ddl . append ( STRING ) ; print Identifier ( get Constraint Name ( null , table , STRING , null ) , ddl ) ; ddl . append ( STRING ) ; write Primary Key Stmt ( table , primary Key Columns , ddl ) ; print End Of Statement ( ddl ) ; } }
public void wait For Id To Unlock ( final Vault ID id , final long timeout ) { if ( timeout <= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } final long start Time = System . current Time Millis ( ) ; long left To Wait = timeout ; while ( left To Wait > NUM && ! is Unlocked ( id ) ) { synchronized ( m wait For Lock ) { if ( is Unlocked ( id ) ) { return ; } try { m wait For Lock . wait ( left To Wait ) ; } catch ( final Interrupted Exception e ) { } left To Wait = start Time + timeout - System . current Time Millis ( ) ; } } }
@ Override public void delete Rows ( int start , int len ) throws Fits Exception { try { if ( this . n Rows == NUM || start < NUM || start >= this . n Rows || len <= NUM ) { return ; } if ( start + len > this . n Rows ) { len = this . n Rows - start ; } ensure Data ( ) ; for ( int i = NUM ; i < this . n Fields ; i += NUM ) { Object o = Array Funcs . new Instance ( this . types [ i ] , this . n Rows - len ) ; System . arraycopy ( this . data [ i ] , NUM , o , NUM , start ) ; System . arraycopy ( this . data [ i ] , start + len , o , start , this . n Rows - len - start ) ; this . data [ i ] = o ; } this . n Rows -= len ; } catch ( Fits Exception e ) { throw e ; } catch ( Exception e ) { throw new Fits Exception ( STRING + e . get Message ( ) , e ) ; } }
public static boolean open Editors ( @ Not Null Project project , @ Not Null Collection < File > files , boolean select ) { if ( files . size ( ) > NUM ) { boolean result = BOOL ; Virtual File last = null ; for ( File file : files ) { if ( file . exists ( ) ) { Virtual File v File = Vfs Util . find File By Io File ( file , BOOL ) ; if ( v File != null ) { result &= open Editor ( project , v File ) ; last = v File ; } else { result = BOOL ; } } } if ( select && last != null ) { select Editor ( project , last ) ; } return result ; } return BOOL ; }
private void update Tick Visibility ( ) { tick Visibilities . clear ( ) ; for ( int i = NUM ; i < tick Label Positions . size ( ) ; i ++ ) { tick Visibilities . add ( Boolean . TRUE ) ; } if ( tick Label Positions . size ( ) == NUM ) { return ; } int previous Position = NUM ; String previous Label = null ; for ( int i = NUM ; i < tick Label Positions . size ( ) ; i ++ ) { boolean has Space To Draw = BOOL ; if ( i != NUM ) { has Space To Draw = has Space To Draw ( previous Position , tick Label Positions . get ( i ) , previous Label , tick Labels . get ( i ) ) ; } String current Label = tick Labels . get ( i ) ; boolean is Repeat Same Tick And Not End = current Label . equals ( previous Label ) && ( i != NUM && i != tick Label Positions . size ( ) - NUM ) ; boolean is Major Tick Or End = BOOL ; if ( scale . is Log Scale Enabled ( ) ) { is Major Tick Or End = is Major Tick ( tick Label Values . get ( i ) ) || i == NUM || i == tick Label Positions . size ( ) - NUM ; } if ( ! has Space To Draw || is Repeat Same Tick And Not End || ! is Major Tick Or End ) { tick Visibilities . set ( i , Boolean . FALSE ) ; } else { previous Position = tick Label Positions . get ( i ) ; previous Label = current Label ; } } }
private void finish String Section ( List < String Section > sections , String Section current Section , String Builder template Expressions , Position last Source Position , Position target Position ) { if ( current Section . last Source Position != null ) { return ; } current Section . last Source Position = new Position ( last Source Position ) ; sections . add ( current Section ) ; append ( template Expressions , target Position , STRING + index ++ + STRING ) ; current Section . last Target Position = new Position ( target Position . row , target Position . column ) ; }
static private B Op Filter Base new Distinct Filter ( final AST 2 B Op Context ctx , final Predicate < ? > pred , final Data Set Summary summary , final boolean hash Join ) { boolean native Distinct = hash Join && ctx . native Distinct SPO ; if ( native Distinct ) { final Long range Count = ( Long ) pred . get Property ( Annotations . ESTIMATED CARDINALITY ) ; if ( range Count != null ) { if ( range Count . long Value ( ) < ctx . native Distinct SPO Threshold ) { native Distinct = BOOL ; } } else { log . warn ( STRING + pred ) ; } } if ( BOOL && native Distinct && summary != null ) { if ( summary . nknown < ctx . native Distinct SPO Threshold ) { native Distinct = BOOL ; } } if ( native Distinct ) { @ Suppress Warnings ( { STRING , STRING } ) final SPO Key Order index Key Order = SPO Key Order . get Key Order ( ( I Predicate ) pred , NUM ) ; return Native Distinct Filter . new Instance ( index Key Order ) ; } else { return Distinct Filter . new Instance ( ) ; } }
public boolean has Badge ( @ Id Res final int item Id ) { return map . contains ( item Id ) ; }
public Options put ( String option , Boolean value ) { if ( value == null ) { return remove ( option ) ; } options . put ( option , Boolean . to String ( value ) ) ; return this ; }
private boolean page Scrolled ( int x Pos ) { if ( items . size ( ) == NUM ) { return BOOL ; } final int delta Scroll = x Pos - last Scroll ; virtual Pos = reverse Pos ? virtual Pos + delta Scroll : virtual Pos - delta Scroll ; last Scroll = x Pos ; final int width = get Client Width ( ) ; final float page Offset = virtual Pos / width ; if ( on Card Change Listener != null ) { on Card Change Listener . on Card Scrolled ( current Item , page Offset , ( int ) virtual Pos ) ; } on Page Scrolled ( ) ; return BOOL ; }
protected String form ( Double Matrix 1 D matrix , int index , Former formatter ) { return formatter . form ( matrix . get ( index ) ) ; }
public void enable ( Bluetooth Adapter adapter ) { int mask = ( Bluetooth Receiver . STATE TURNING ON FLAG | Bluetooth Receiver . STATE ON FLAG | Bluetooth Receiver . SCAN MODE CONNECTABLE FLAG ) ; long start = - NUM ; Bluetooth Receiver receiver = get Bluetooth Receiver ( mask ) ; int state = adapter . get State ( ) ; switch ( state ) { case Bluetooth Adapter . STATE ON : assert True ( adapter . is Enabled ( ) ) ; remove Receiver ( receiver ) ; return ; case Bluetooth Adapter . STATE TURNING ON : assert False ( adapter . is Enabled ( ) ) ; mask = NUM ; break ; case Bluetooth Adapter . STATE OFF : assert False ( adapter . is Enabled ( ) ) ; start = System . current Time Millis ( ) ; assert True ( adapter . enable ( ) ) ; break ; case Bluetooth Adapter . STATE TURNING OFF : start = System . current Time Millis ( ) ; assert True ( adapter . enable ( ) ) ; break ; default : remove Receiver ( receiver ) ; fail ( String . format ( STRING , state ) ) ; } long s = System . current Time Millis ( ) ; while ( System . current Time Millis ( ) - s < ENABLE DISABLE TIMEOUT ) { state = adapter . get State ( ) ; if ( state == Bluetooth Adapter . STATE ON && ( receiver . get Fired Flags ( ) & mask ) == mask ) { assert True ( adapter . is Enabled ( ) ) ; long finish = receiver . get Completed Time ( ) ; if ( start != - NUM && finish != - NUM ) { write Output ( String . format ( STRING , ( finish - start ) ) ) ; } else { write Output ( STRING ) ; } remove Receiver ( receiver ) ; return ; } sleep ( POLL TIME ) ; } int fired Flags = receiver . get Fired Flags ( ) ; remove Receiver ( receiver ) ; fail ( String . format ( STRING , state , Bluetooth Adapter . STATE ON , fired Flags , mask ) ) ; }
private String parse String ( final String s , final char separator , final Atomic Reference < String > value ) { final String Builder sb = new String Builder ( s . length ( ) ) ; int separator Index = - NUM ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { if ( s . char At ( i ) == separator && i + NUM < s . length ( ) && s . char At ( i + NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . char At ( i ) == separator ) { separator Index = i ; break ; } sb . append ( s . char At ( i ) ) ; } value . set ( sb . to String ( ) ) ; if ( separator Index != - NUM && separator Index != s . length ( ) - NUM ) { return s . substring ( separator Index + NUM ) ; } else { return STRING ; } }
private boolean dismiss No Antenna Dialog ( ) { No Antenna Dialog new Fragment = ( No Antenna Dialog ) m Fragment Manager . find Fragment By Tag ( TAG NO ANTENNA ) ; if ( null != new Fragment ) { new Fragment . dismiss Allowing State Loss ( ) ; return BOOL ; } return BOOL ; }
static int [ ] find Nanp Phone Numbers ( Char Sequence text ) { Array List < Integer > list = new Array List < Integer > ( ) ; int start Pos = NUM ; int end Pos = text . length ( ) - NANP MIN DIGITS + NUM ; if ( end Pos < NUM ) { return new int [ ] { } ; } while ( start Pos < end Pos ) { while ( Character . is Whitespace ( text . char At ( start Pos ) ) && start Pos < end Pos ) { start Pos ++ ; } if ( start Pos == end Pos ) { break ; } int match End = find Nanp Match End ( text , start Pos ) ; if ( match End > start Pos ) { list . add ( start Pos ) ; list . add ( match End ) ; start Pos = match End ; } else { while ( ! Character . is Whitespace ( text . char At ( start Pos ) ) && start Pos < end Pos ) { start Pos ++ ; } } } int [ ] result = new int [ list . size ( ) ] ; for ( int i = list . size ( ) - NUM ; i >= NUM ; i -- ) { result [ i ] = list . get ( i ) ; } return result ; }
private static void add Entries For Infrequent Blocks ( IR ir , Live Analysis live , Hash Map < Basic Block Pair , Hash Set < Register > > result ) { for ( Enumeration < Basic Block > e = ir . get Basic Blocks ( ) ; e . has More Elements ( ) ; ) { Basic Block bb = e . next Element ( ) ; boolean bb Infrequent = bb . get Infrequent ( ) ; for ( Enumeration < Basic Block > out = bb . get Normal Out ( ) ; out . has More Elements ( ) ; ) { Basic Block dest = out . next Element ( ) ; boolean dest Infrequent = dest . get Infrequent ( ) ; if ( bb Infrequent ^ dest Infrequent ) { Hash Set < Register > live Registers = live . get Live Registers On Edge ( bb , dest ) ; for ( Register r : live Registers ) { if ( r . is Symbolic ( ) ) { Hash Set < Register > s = find Or Create Split Set ( result , bb , dest ) ; s . add ( r ) ; } } } } } }
public void test Split And Join Multiple Properties On Semicolon ( ) { Properties inner = Property Utils . split Properties On Delimiter ( ONE SEMI TWO , STRING ) ; assert Equals ( STRING , inner . get Property ( STRING ) ) ; assert Equals ( STRING , inner . get Property ( STRING ) ) ; assert Equals ( NUM , inner . size ( ) ) ; try { assert Equals ( ONE SEMI TWO , Property Utils . join On Semicolon ( Property Utils . to Map ( inner ) ) ) ; } catch ( Comparison Failure e ) { assert Equals ( TWO SEMI ONE , Property Utils . join On Semicolon ( Property Utils . to Map ( inner ) ) ) ; } }
public static void insert Object At Offset ( Object [ ] source Array , Object [ ] destination Array , int offset , Object o ) { if ( offset == NUM ) { destination Array [ NUM ] = o ; System . arraycopy ( source Array , NUM , destination Array , NUM , source Array . length ) ; } else { if ( offset == source Array . length ) { System . arraycopy ( source Array , NUM , destination Array , NUM , source Array . length ) ; destination Array [ source Array . length ] = o ; } else { System . arraycopy ( source Array , NUM , destination Array , NUM , offset ) ; destination Array [ offset ] = o ; System . arraycopy ( source Array , offset , destination Array , offset + NUM , source Array . length - offset ) ; } } }
private void create From Assets ( String db Name , File dbfile , Input Stream asset File Input Stream ) { Output Stream out = null ; try { Log . v ( STRING , STRING ) ; String db Path = dbfile . get Absolute Path ( ) ; db Path = db Path . substring ( NUM , db Path . last Index Of ( STRING ) + NUM ) ; File db Path File = new File ( db Path ) ; if ( ! db Path File . exists ( ) ) db Path File . mkdirs ( ) ; File new Db File = new File ( db Path + db Name ) ; out = new File Output Stream ( new Db File ) ; byte [ ] buf = new byte [ NUM ] ; int len ; while ( ( len = asset File Input Stream . read ( buf ) ) > NUM ) out . write ( buf , NUM , len ) ; Log . v ( STRING , STRING + new Db File . get Absolute Path ( ) ) ; } catch ( IO Exception e ) { Log . v ( STRING , STRING + e . get Message ( ) ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IO Exception ignored ) { } } } }
public Input Stream stream ( ) throws Http Request Exception { Input Stream stream ; if ( code ( ) < HTTP BAD REQUEST ) try { stream = connection . get Input Stream ( ) ; } catch ( IO Exception e ) { throw new Http Request Exception ( e ) ; } else { stream = connection . get Error Stream ( ) ; if ( stream == null ) try { stream = connection . get Input Stream ( ) ; } catch ( IO Exception e ) { throw new Http Request Exception ( e ) ; } } if ( ! uncompress || ! ENCODING GZIP . equals ( content Encoding ( ) ) ) return stream ; else try { return new GZIP Input Stream ( stream ) ; } catch ( IO Exception e ) { throw new Http Request Exception ( e ) ; } }
public void organize ( ) { if ( DEBUG ) { logger . fine ( STRING ) ; } init File Holder ( ) ; Iterator it = filenames . iterator ( ) ; DTED Name Translator dnt = get Translator ( ) ; while ( it . has Next ( ) ) { File file = ( File ) it . next ( ) ; String filename = file . get Absolute Path ( ) ; try { dnt . set ( filename ) ; int l = dnt . get Level ( ) ; int lt = ( int ) ( dnt . get Lat ( ) + NUM ) ; int ln = ( int ) ( dnt . get Lon ( ) + NUM ) ; if ( DEBUG ) { logger . fine ( STRING + filename + STRING + l + STRING + lt + STRING + ln + STRING ) ; } files [ l ] [ lt ] [ ln ] = file ; } catch ( Format Exception fe ) { continue ; } catch ( Array Index Out Of Bounds Exception aioobe ) { continue ; } } }
protected boolean looks Like ISO 8601 ( String date Str ) { if ( date Str . length ( ) >= NUM && Character . is Digit ( date Str . char At ( NUM ) ) && Character . is Digit ( date Str . char At ( NUM ) ) && date Str . char At ( NUM ) == STRING ) { return BOOL ; } return BOOL ; }
public int read Unsigned Short ( ) throws IO Exception { return primitive Types . read Unsigned Short ( ) ; }
public void print ( Object obj ) { print ( String . value Of ( obj ) ) ; }
public static void copy To Clipboard ( final Zy Graph Node < ? > node ) { Preconditions . check Not Null ( node , STRING ) ; final I Zy Node Realizer realizer = node . get Realizer ( ) ; final Zy Label Content content = realizer . get Node Content ( ) ; if ( content . is Selectable ( ) ) { final Zy Label Content zy Content = content ; final String Builder text Builder = new String Builder ( ) ; for ( final Zy Line Content zy Line Content : zy Content ) { text Builder . append ( zy Line Content . get Text ( ) ) ; text Builder . append ( STRING ) ; } Clipboard Helpers . copy To Clipboard ( text Builder . to String ( ) ) ; } }
private RP Recommendation build Source Recommendation ( String associated Storage System , Virtual Array varray , Virtual Pool vpool , Protection System ps , Storage Pool source Pool , Virtual Pool Capability Values Wrapper capabilities , int satisfied Source Vol Count , Placement Status placement Stat , Volume vpool Change Volume , boolean is MP Standby ) { String source Internal Site Name = Protection System . get Associated Storage System Site Name ( associated Storage System ) ; URI source Storage Sytem Uri = Connectivity Util . find Storage System By Serial Number ( Protection System . get Associated Storage System Serial Number ( associated Storage System ) , db Client , Storage System Type . BLOCK ) ; if ( ! is Rp Site Connected To Varray ( source Storage Sytem Uri , ps . get Id ( ) , source Internal Site Name , varray ) ) { log . info ( String . format ( STRING + STRING , source Internal Site Name , varray . get Label ( ) ) ) ; return null ; } URI storage System Uri = Connectivity Util . find Storage System By Serial Number ( Protection System . get Associated Storage System Serial Number ( associated Storage System ) , db Client , Storage System Type . BLOCK ) ; Storage System storage System = db Client . query Object ( Storage System . class , storage System Uri ) ; String type = storage System . get System Type ( ) ; RP Recommendation rp Recommendation = build Rp Recommendation ( associated Storage System , varray , vpool , source Pool , capabilities , satisfied Source Vol Count , source Internal Site Name , source Storage Sytem Uri , type , ps ) ; String rp Placement Type = STRING ; if ( is MP Standby ) { rp Placement Type = STRING ; } log . info ( String . format ( STRING , rp Placement Type , rp Recommendation . to String ( db Client , ps ) ) ) ; return rp Recommendation ; }
public void add Frame ( CC Sprite Frame frame ) { frames . add ( frame ) ; }
private void navigate To Child ( String starts With ) { Tree Path current Path = tree . get Selection Path ( ) ; Default Mutable Tree Node dump Node = ( Default Mutable Tree Node ) current Path . get Last Path Component ( ) ; Enumeration childs = dump Node . children ( ) ; Tree Path search Path = null ; while ( ( search Path == null ) && childs . has More Elements ( ) ) { Default Mutable Tree Node child = ( Default Mutable Tree Node ) childs . next Element ( ) ; String name = child . to String ( ) ; if ( name != null && name . starts With ( starts With ) ) { search Path = new Tree Path ( child . get Path ( ) ) ; } } if ( search Path != null ) { tree . make Visible ( search Path ) ; tree . set Selection Path ( search Path ) ; tree . scroll Path To Visible ( search Path ) ; } }
public synchronized void add Message ( Sms Mms Message new Message ) { messages . add ( new Message ) ; Update Message Count ( ) ; }
public int swap ( ) { if ( ! m Egl . egl Swap Buffers ( m Egl Display , m Egl Surface ) ) { return m Egl . egl Get Error ( ) ; } return EGL 10 . EGL SUCCESS ; }
public static List < Window > windows ( Input Stream words , int window Size ) { Tokenizer tokenizer = new Default Stream Tokenizer ( words ) ; List < String > list = new Array List < > ( ) ; while ( tokenizer . has More Tokens ( ) ) list . add ( tokenizer . next Token ( ) ) ; return windows ( list , window Size ) ; }
protected void draw Center Text ( Canvas c ) { String center Text = m Chart . get Center Text ( ) ; if ( m Chart . is Draw Center Text Enabled ( ) && center Text != null ) { Point F center = m Chart . get Center Circle Box ( ) ; String [ ] lines = center Text . split ( STRING ) ; float maxlineheight = NUM ; for ( String line : lines ) { float cur Height = Utils . calc Text Height ( m Center Text Paint , line ) ; if ( cur Height > maxlineheight ) maxlineheight = cur Height ; } float linespacing = maxlineheight * NUM ; float totalheight = maxlineheight * lines . length - linespacing * ( lines . length - NUM ) ; int cnt = lines . length ; float y = center . y ; for ( int i = NUM ; i < lines . length ; i ++ ) { String line = lines [ lines . length - i - NUM ] ; c . draw Text ( line , center . x , y + maxlineheight * cnt - totalheight / NUM , m Center Text Paint ) ; cnt -- ; y -= linespacing ; } } }
public List < String > ordered Groups ( ) { int group Count = group Count ( ) ; List < String > groups = new Array List < String > ( group Count ) ; for ( int i = NUM ; i <= group Count ; i ++ ) { groups . add ( group ( i ) ) ; } return groups ; }
private static Object add ( final Object array , final int index , final Object element , final Class < ? > clss ) { if ( array == null ) { if ( index != NUM ) { throw new Index Out Of Bounds Exception ( STRING + index + STRING ) ; } final Object joined Array = Array . new Instance ( clss , NUM ) ; Array . set ( joined Array , NUM , element ) ; return joined Array ; } final int length = Array . get Length ( array ) ; if ( index > length || index < NUM ) { throw new Index Out Of Bounds Exception ( STRING + index + STRING + length ) ; } final Object result = Array . new Instance ( clss , length + NUM ) ; System . arraycopy ( array , NUM , result , NUM , index ) ; Array . set ( result , index , element ) ; if ( index < length ) { System . arraycopy ( array , index , result , index + NUM , length - index ) ; } return result ; }
public boolean is Normal ( boolean b Only Value , double dP Value For Rejection ) { double dP Res = NUM ; double dSD = standard Deviation ( b Only Value ) ; double d Skewness = get Central Moment ( b Only Value , NUM ) / Math . pow ( dSD , NUM ) ; double d Kurtosis = get Central Moment ( b Only Value , NUM ) / Math . pow ( dSD , NUM ) ; double dJB = ( observation Count ( b Only Value ) / NUM ) * ( Math . pow ( d Skewness , NUM ) + ( Math . pow ( d Kurtosis - NUM , NUM ) / NUM ) ) ; dP Res = Chi Square Distribution Base . get P Value ( dJB ) ; return dP Res > dP Value For Rejection ; }
public String to Matlab ( ) { String Buffer result ; int i ; int n ; result = new String Buffer ( ) ; result . append ( STRING ) ; for ( i = NUM ; i < m size ; i ++ ) { if ( i > NUM ) { result . append ( STRING ) ; } for ( n = NUM ; n < m size ; n ++ ) { if ( n > NUM ) { result . append ( STRING ) ; } result . append ( get Cell ( i , n ) ) ; } } result . append ( STRING ) ; return result . to String ( ) ; }
public File Input Reader ( String f ) throws IO Exception { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + f ) ; } File file = new File ( f ) ; name = file . get Name ( ) ; absolute Path = file . get Absolute Path ( ) ; input File = init ( file ) ; }
public static Buffered Output Stream new Output Stream ( Path self ) throws IO Exception { return new Buffered Output Stream ( Files . new Output Stream ( self ) ) ; }
public synchronized Set < K > key Set ( ) { Hash Set < K > set = new Hash Set < K > ( ) ; for ( Segment < K , V > s : segments ) { set . add All ( s . key Set ( ) ) ; } return set ; }
private Certificate Token deal Signature ( final Advanced Signature signature , final Xml Signature xml Signature ) { final Advanced Signature master Signature = signature . get Master Signature ( ) ; if ( master Signature != null ) { xml Signature . set Type ( Attribute Value . COUNTERSIGNATURE ) ; xml Signature . set Parent Id ( master Signature . get Id ( ) ) ; } perform Structural Validation ( signature , xml Signature ) ; perform Signature Cryptographic Validation ( signature , xml Signature ) ; xml Signature . set Id ( signature . get Id ( ) ) ; xml Signature . set Date Time ( signature . get Signing Time ( ) ) ; final Signature Level data Found Up To Level = signature . get Data Found Up To Level ( ) ; final String value = data Found Up To Level == null ? STRING : data Found Up To Level . name ( ) ; xml Signature . set Signature Format ( value ) ; deal With Signature Production Place ( signature , xml Signature ) ; deal With Commitment Type Indication ( signature , xml Signature ) ; deal With Claimed Role ( signature , xml Signature ) ; final String content Type = signature . get Content Type ( ) ; xml Signature . set Content Type ( content Type ) ; final String content Identifier = signature . get Content Identifier ( ) ; xml Signature . set Content Identifier ( content Identifier ) ; final String content Hints = signature . get Content Hints ( ) ; xml Signature . set Content Hints ( content Hints ) ; deal With Certified Role ( signature , xml Signature ) ; final Certificate Validity certificate Validity = deal Signing Certificate ( signature , xml Signature ) ; final Xml Basic Signature Type xml Basic Signature = get Xml Basic Signature Type ( xml Signature ) ; final Encryption Algorithm encryption Algorithm = signature . get Encryption Algorithm ( ) ; final String encryption Algorithm String = encryption Algorithm == null ? STRING : encryption Algorithm . get Name ( ) ; xml Basic Signature . set Encryption Algo Used To Sign This Token ( encryption Algorithm String ) ; final Certificate Token signing Certificate Token = certificate Validity == null ? null : certificate Validity . get Certificate Token ( ) ; final int key Length = signing Certificate Token == null ? NUM : DSSPK Utils . get Public Key Size ( signing Certificate Token . get Public Key ( ) ) ; xml Basic Signature . set Key Length Used To Sign This Token ( String . value Of ( key Length ) ) ; final Digest Algorithm digest Algorithm = signature . get Digest Algorithm ( ) ; final String digest Algorithm String = digest Algorithm == null ? STRING : digest Algorithm . get Name ( ) ; xml Basic Signature . set Digest Algo Used To Sign This Token ( digest Algorithm String ) ; xml Signature . set Basic Signature ( xml Basic Signature ) ; deal Signature Scope ( xml Signature , signature ) ; return signing Certificate Token ; }
void add Policy Listener ( Policy Listener policy Listener ) { String listener Service Name = policy Listener . get Service Type Name ( ) ; Set new Listeners = new Hash Set ( ) ; new Listeners . add ( policy Listener ) ; Set old Listeners = ( Set ) policy Listeners Map . get ( listener Service Name ) ; if ( old Listeners != null ) { new Listeners . add All ( old Listeners ) ; } policy Listeners Map . put ( listener Service Name , new Listeners ) ; }
public static int ping ( String url ) throws Exception { URL u = new URL ( url ) ; Http URL Connection c = ( Http URL Connection ) u . open Connection ( ) ; c . connect ( ) ; int code = c . get Response Code ( ) ; log . debug ( STRING + url + STRING + code ) ; c . disconnect ( ) ; return code ; }
List < I Navi Module > initialize Raw Modules ( final List < I Navi Module > modules , final List < I Navi Raw Module > raw Modules ) { final List < I Navi Module > new Modules = new Array List < I Navi Module > ( ) ; for ( final I Navi Raw Module raw Module : raw Modules ) { if ( ! has Module ( modules , raw Module ) ) { try { new Modules . add ( create Module ( raw Module ) ) ; } catch ( Couldnt Load Data Exception | Couldnt Save Data Exception e ) { C Utility Functions . log Exception ( e ) ; } } } return new Modules ; }
public final static < T extends Bean > List < T > load ( String table , String [ ] cols , String where , Object [ ] args , Class < T > clazz ) { return load ( table , cols , where , args , null , - NUM , - NUM , clazz ) ; }
@ Override public Japanese Date date ( int proleptic Year , int month , int day Of Month ) { return new Japanese Date ( Local Date . of ( proleptic Year , month , day Of Month ) ) ; }
private Pair < Key , char [ ] > recover Key ( String alias , char [ ] store Pass , char [ ] key Pass ) throws Exception { Key key = null ; if ( key Store . contains Alias ( alias ) == BOOL ) { Message Format form = new Message Format ( rb . get String ( STRING ) ) ; Object [ ] source = { alias } ; throw new Exception ( form . format ( source ) ) ; } if ( ! key Store . entry Instance Of ( alias , Key Store . Private Key Entry . class ) && ! key Store . entry Instance Of ( alias , Key Store . Secret Key Entry . class ) ) { Message Format form = new Message Format ( rb . get String ( STRING ) ) ; Object [ ] source = { alias } ; throw new Exception ( form . format ( source ) ) ; } if ( key Pass == null ) { try { key = key Store . get Key ( alias , store Pass ) ; key Pass = store Pass ; passwords . add ( key Pass ) ; } catch ( Unrecoverable Key Exception e ) { if ( ! token ) { key Pass = get Key Passwd ( alias , null , null ) ; key = key Store . get Key ( alias , key Pass ) ; } else { throw e ; } } } else { key = key Store . get Key ( alias , key Pass ) ; } return Pair . of ( key , key Pass ) ; }
Class < ? > load Class ( String class Name , URL [ ] urls ) throws Class Not Found Exception { URL Class Loader cl = new URL Class Loader ( urls ) ; Class < ? > test Class = cl . load Class ( class Name ) ; return test Class ; }
public Simple Message Listener Adapter ( Simple Message Listener listener ) { this ( Collections . singleton ( listener ) , DEFAULT DATA DEFERRED SIZE ) ; }
public static < T > T [ ] concat ( @ Nullable T [ ] arr , T ... obj ) { T [ ] new Arr ; if ( arr == null || arr . length == NUM ) new Arr = obj ; else { new Arr = Arrays . copy Of ( arr , arr . length + obj . length ) ; System . arraycopy ( obj , NUM , new Arr , arr . length , obj . length ) ; } return new Arr ; }
public void pedestal Camera ( float size ) { move To Position ( - ( float ) ( target Xoff + ( size * Math . sin ( Math . to Radians ( zrot ) ) ) ) , - ( float ) ( target Yoff + ( size * Math . cos ( Math . to Radians ( zrot ) ) ) ) ) ; }
public static byte [ ] decode ( String encoded ) { if ( encoded == null ) return null ; char [ ] base 64 Data = encoded . to Char Array ( ) ; int len = remove White Space ( base 64 Data ) ; if ( len % FOURBYTE != NUM ) { return null ; } int number Quadruple = ( len / FOURBYTE ) ; if ( number Quadruple == NUM ) return new byte [ NUM ] ; byte decoded Data [ ] = null ; byte b1 = NUM , b2 = NUM , b3 = NUM , b4 = NUM ; char d1 = NUM , d2 = NUM , d3 = NUM , d4 = NUM ; int i = NUM ; int encoded Index = NUM ; int data Index = NUM ; decoded Data = new byte [ ( number Quadruple ) * NUM ] ; for ( ; i < number Quadruple - NUM ; i ++ ) { if ( ! is Data ( ( d1 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d3 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d4 = base 64 Data [ data Index ++ ] ) ) ) return null ; b1 = base 64 Alphabet [ d1 ] ; b2 = base 64 Alphabet [ d2 ] ; b3 = base 64 Alphabet [ d3 ] ; b4 = base 64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << NUM | b4 ) ; } if ( ! is Data ( ( d1 = base 64 Data [ data Index ++ ] ) ) || ! is Data ( ( d2 = base 64 Data [ data Index ++ ] ) ) ) { return null ; } b1 = base 64 Alphabet [ d1 ] ; b2 = base 64 Alphabet [ d2 ] ; d3 = base 64 Data [ data Index ++ ] ; d4 = base 64 Data [ data Index ++ ] ; if ( ! is Data ( ( d3 ) ) || ! is Data ( ( d4 ) ) ) { if ( is Pad ( d3 ) && is Pad ( d4 ) ) { if ( ( b2 & NUM ) != NUM ) return null ; byte [ ] tmp = new byte [ i * NUM + NUM ] ; System . arraycopy ( decoded Data , NUM , tmp , NUM , i * NUM ) ; tmp [ encoded Index ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; return tmp ; } else if ( ! is Pad ( d3 ) && is Pad ( d4 ) ) { b3 = base 64 Alphabet [ d3 ] ; if ( ( b3 & NUM ) != NUM ) return null ; byte [ ] tmp = new byte [ i * NUM + NUM ] ; System . arraycopy ( decoded Data , NUM , tmp , NUM , i * NUM ) ; tmp [ encoded Index ++ ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; tmp [ encoded Index ] = ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; return tmp ; } else { return null ; } } else { b3 = base 64 Alphabet [ d3 ] ; b4 = base 64 Alphabet [ d4 ] ; decoded Data [ encoded Index ++ ] = ( byte ) ( b1 << NUM | b2 > > NUM ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ; decoded Data [ encoded Index ++ ] = ( byte ) ( b3 << NUM | b4 ) ; } return decoded Data ; }
public void stop ( ) { try { scheduled Executor Service . shutdown ( ) ; scheduled Executor Service . await Termination ( termination wait , Time Unit . MILLISECONDS ) ; } catch ( Interrupted Exception ignore ) { } }
public static int deflate ( byte [ ] previous , int previous Length , byte [ ] current , int current Length , byte [ ] result ) { if ( previous == null ) { System . arraycopy ( current , NUM , result , NUM , current Length ) ; return current Length ; } int length = NUM ; int start 1 = NUM ; int start 2 = NUM ; while ( start 1 < previous Length && start 2 < current Length ) { int end 1 = start 1 ; int end 2 = start 2 ; while ( end 1 <= previous Length && end 2 <= current Length ) { byte c1 = ( end 1 < previous Length ? previous [ end 1 ] : ( byte ) STRING ) ; byte c2 = ( end 2 < current Length ? current [ end 2 ] : ( byte ) STRING ) ; if ( c1 == c2 ) { if ( c1 == STRING ) { result [ length ++ ] = STRING ; break ; } else { end 1 ++ ; end 2 ++ ; } } else { while ( end 1 < previous Length && previous [ end 1 ] != STRING ) { end 1 ++ ; } while ( end 2 < current Length && current [ end 2 ] != STRING ) { end 2 ++ ; } for ( int i = start 2 ; i < end 2 ; i ++ ) result [ length ++ ] = current [ i ] ; break ; } } start 1 = end 1 + NUM ; start 2 = end 2 + NUM ; if ( start 2 < current Length ) result [ length ++ ] = STRING ; } return length ; }
protected < S extends Property Source < ? > > S find Property Source ( Class < S > source Class ) { List < S > sources = find Property Sources ( source Class ) ; if ( sources . size ( ) == NUM ) { return null ; } if ( sources . size ( ) > NUM ) { log . warn ( STRING + source Class ) ; } return sources . get ( NUM ) ; }
public void add Property Change Listener ( Property Change Listener l ) { if ( listeners == null ) { listeners = new Array List < Property Change Listener > ( NUM ) ; } if ( ! listeners . contains ( l ) ) { listeners . add ( l ) ; } }
public static boolean delete Recursive ( File path ) throws File Not Found Exception { if ( ! path . exists ( ) ) throw new File Not Found Exception ( path . get Absolute Path ( ) ) ; boolean ret = BOOL ; if ( path . is Directory ( ) ) { for ( File f : path . list Files ( ) ) { ret = ret && Utils . delete Recursive ( f ) ; } } return ret && path . delete ( ) ; }
private void map ( Iterable < Key Cache Object > keys , boolean remap , boolean top Locked ) { try { Affinity Topology Version top Ver = this . top Ver ; assert top Ver != null ; assert top Ver . topology Version ( ) > NUM : top Ver ; if ( CU . affinity Nodes ( cctx , top Ver ) . is Empty ( ) ) { on Done ( new Cluster Topology Server Not Found Exception ( STRING + STRING ) ) ; return ; } boolean client Node = cctx . kernal Context ( ) . client Node ( ) ; assert ! remap || ( client Node && ( tx == null || ! tx . has Remote Locks ( ) ) ) ; synchronized ( this ) { mappings = new Array Deque < > ( ) ; Grid Near Lock Mapping map = null ; for ( Key Cache Object key : keys ) { Grid Near Lock Mapping updated = map ( key , map , top Ver ) ; if ( updated != map ) { mappings . add ( updated ) ; if ( tx != null && updated . node ( ) . is Local ( ) ) tx . near Locally Mapped ( BOOL ) ; } map = updated ; } if ( is Done ( ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + this ) ; return ; } if ( log . is Debug Enabled ( ) ) log . debug ( STRING + mappings + STRING + this + STRING ) ; boolean first = BOOL ; for ( Iterator < Grid Near Lock Mapping > iter = mappings . iterator ( ) ; iter . has Next ( ) ; ) { Grid Near Lock Mapping mapping = iter . next ( ) ; Cluster Node node = mapping . node ( ) ; Collection < Key Cache Object > mapped Keys = mapping . mapped Keys ( ) ; assert ! mapped Keys . is Empty ( ) ; Grid Near Lock Request req = null ; Collection < Key Cache Object > distributed Keys = new Array List < > ( mapped Keys . size ( ) ) ; boolean explicit = BOOL ; for ( Key Cache Object key : mapped Keys ) { Ignite Tx Key tx Key = cctx . tx Key ( key ) ; while ( BOOL ) { Grid Near Cache Entry entry = null ; try { entry = cctx . near ( ) . entry Exx ( key , top Ver ) ; if ( ! cctx . is All ( entry , filter ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + entry ) ; on Complete ( BOOL , BOOL ) ; return ; } Grid Cache Mvcc Candidate cand = add Entry ( top Ver , entry , node . id ( ) ) ; if ( is Done ( ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + STRING + this + STRING + entry + STRING ) ; return ; } if ( cand != null ) { if ( tx == null && ! cand . reentry ( ) ) cctx . mvcc ( ) . add Explicit Lock ( thread Id , cand , top Ver ) ; Ignite Bi Tuple < Grid Cache Version , Cache Object > val = entry . versioned Value ( ) ; if ( val == null ) { Grid Dht Cache Entry dht Entry = dht ( ) . peek Exx ( key ) ; try { if ( dht Entry != null ) val = dht Entry . versioned Value ( top Ver ) ; } catch ( Grid Cache Entry Removed Exception ignored ) { assert dht Entry . obsolete ( ) : dht Entry ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + dht Entry ) ; } } Grid Cache Version dht Ver = null ; if ( val != null ) { dht Ver = val . get 1 ( ) ; val Map . put ( key , val ) ; } if ( ! cand . reentry ( ) ) { if ( req == null ) { boolean client First = BOOL ; if ( first ) { client First = client Node && ! top Locked && ( tx == null || ! tx . has Remote Locks ( ) ) ; first = BOOL ; } req = new Grid Near Lock Request ( cctx . cache Id ( ) , top Ver , cctx . node Id ( ) , thread Id , fut Id , lock Ver , in Tx ( ) , implicit Tx ( ) , implicit Single Tx ( ) , read , retval , isolation ( ) , is Invalidate ( ) , timeout , mapped Keys . size ( ) , in Tx ( ) ? tx . size ( ) : mapped Keys . size ( ) , in Tx ( ) && tx . sync Mode ( ) == FULL SYNC , in Tx ( ) ? tx . subject Id ( ) : null , in Tx ( ) ? tx . task Name Hash ( ) : NUM , read ? access Ttl : - NUM , skip Store , keep Binary , client First , cctx . deployment Enabled ( ) ) ; mapping . request ( req ) ; } distributed Keys . add ( key ) ; if ( tx != null ) tx . add Key Mapping ( tx Key , mapping . node ( ) ) ; req . add Key Bytes ( key , retval && dht Ver == null , dht Ver , cctx ) ; } if ( cand . reentry ( ) ) explicit = tx != null && ! entry . has Lock Candidate ( tx . xid Version ( ) ) ; } else explicit = tx != null && ! entry . has Lock Candidate ( tx . xid Version ( ) ) ; if ( explicit ) tx . add Key Mapping ( tx Key , mapping . node ( ) ) ; break ; } catch ( Grid Cache Entry Removed Exception ignored ) { assert entry . obsolete ( ) : STRING + entry ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + entry ) ; } } if ( explicit ) { boolean marked = tx != null && tx . mark Explicit ( node . id ( ) ) ; assert tx == null || marked ; } } if ( ! distributed Keys . is Empty ( ) ) mapping . distributed Keys ( distributed Keys ) ; else { assert mapping . request ( ) == null ; iter . remove ( ) ; } } } cctx . mvcc ( ) . recheck Pending Locks ( ) ; proceed Mapping ( ) ; } catch ( Ignite Checked Exception ex ) { on Error ( ex ) ; } }
private String next ( Pattern pattern ) throws Decode Exception { Matcher matcher = pattern . matcher ( gser Value . substring ( pos , length ) ) ; if ( matcher . find ( ) && matcher . group Count ( ) >= NUM ) { pos += matcher . end ( NUM ) ; return matcher . group ( NUM ) ; } else { final Localizable Message msg = WARN GSER PATTERN NO MATCH . get ( pattern . pattern ( ) , gser Value . substring ( pos , length ) ) ; throw Decode Exception . error ( msg ) ; } }
public void characters ( char ch [ ] , int start , int length ) throws SAX Exception { m cur PD Evalue . append ( ch , start , length ) ; }
public LU Decomposition ( Matrix A ) { LU = A . get Array Copy ( ) ; m = A . get Row Dimension ( ) ; n = A . get Column Dimension ( ) ; piv = new int [ m ] ; for ( int i = NUM ; i < m ; i ++ ) { piv [ i ] = i ; } pivsign = NUM ; double [ ] L Urowi ; double [ ] L Ucolj = new double [ m ] ; for ( int j = NUM ; j < n ; j ++ ) { for ( int i = NUM ; i < m ; i ++ ) { L Ucolj [ i ] = LU [ i ] [ j ] ; } for ( int i = NUM ; i < m ; i ++ ) { L Urowi = LU [ i ] ; int kmax = Math . min ( i , j ) ; double s = NUM ; for ( int k = NUM ; k < kmax ; k ++ ) { s += L Urowi [ k ] * L Ucolj [ k ] ; } L Urowi [ j ] = L Ucolj [ i ] -= s ; } int p = j ; for ( int i = j + NUM ; i < m ; i ++ ) { if ( Math . abs ( L Ucolj [ i ] ) > Math . abs ( L Ucolj [ p ] ) ) { p = i ; } } if ( p != j ) { for ( int k = NUM ; k < n ; k ++ ) { double t = LU [ p ] [ k ] ; LU [ p ] [ k ] = LU [ j ] [ k ] ; LU [ j ] [ k ] = t ; } int k = piv [ p ] ; piv [ p ] = piv [ j ] ; piv [ j ] = k ; pivsign = - pivsign ; } if ( j < m & LU [ j ] [ j ] != NUM ) { for ( int i = j + NUM ; i < m ; i ++ ) { LU [ i ] [ j ] /= LU [ j ] [ j ] ; } } } }
public static void initialize Properties ( Properties properties ) { if ( system Properties != null ) { system Properties . initialize Properties ( properties ) ; } }
public int remove ( int index ) { check Range ( index ) ; int oldval = array [ index ] ; int numtomove = size - index - NUM ; if ( numtomove > NUM ) { System . arraycopy ( array , index + NUM , array , index , numtomove ) ; } size -- ; return oldval ; }
public TLC Chained Preference Store ( I Preference Store [ ] preference Stores ) { Assert . is True ( preference Stores != null && preference Stores . length > NUM ) ; f Preference Stores = new I Preference Store [ preference Stores . length ] ; System . arraycopy ( preference Stores , NUM , f Preference Stores , NUM , preference Stores . length ) ; for ( int i = NUM , length = f Preference Stores . length ; i < length ; i ++ ) { Property Change Listener listener = new Property Change Listener ( f Preference Stores [ i ] ) ; f Child Listeners . add ( listener ) ; } }
final public boolean starts With Ignore Case ( final String prefix ) { final int l = prefix . length ( ) ; if ( l > length ( ) ) return BOOL ; int i = l ; final char [ ] a = array ; char c , d ; while ( i -- != NUM ) { c = Character . to Lower Case ( Character . to Upper Case ( a [ i ] ) ) ; d = Character . to Lower Case ( Character . to Upper Case ( prefix . char At ( i ) ) ) ; if ( c != d ) return BOOL ; } return BOOL ; }
public < T > T as Class ( Class < T > clazz , T default Value ) { if ( value == null ) return default Value ; try { return clazz . cast ( value ) ; } catch ( Class Cast Exception e ) { return default Value ; } }
public Key Value Table View ( Observable List < Pair < K , V > > items ) { this ( items , FX Collections . observable Array List ( new Array List < K > ( ) ) , null , null ) ; }
private void parse Menu ( Xml Pull Parser parser , Attribute Set attrs , Icon Data menu ) throws Xml Pull Parser Exception , IO Exception { Menu State menu State = new Menu State ( menu ) ; int event Type = parser . get Event Type ( ) ; String tag Name ; boolean looking For End Of Unknown Tag = BOOL ; String unknown Tag Name = null ; do { if ( event Type == Xml Pull Parser . START TAG ) { tag Name = parser . get Name ( ) ; if ( tag Name . equals ( XML MENU ) ) { event Type = parser . next ( ) ; break ; } throw new Runtime Exception ( STRING + tag Name ) ; } event Type = parser . next ( ) ; } while ( event Type != Xml Pull Parser . END DOCUMENT ) ; boolean reached End Of Menu = BOOL ; while ( ! reached End Of Menu ) { switch ( event Type ) { case Xml Pull Parser . START TAG : if ( looking For End Of Unknown Tag ) { break ; } tag Name = parser . get Name ( ) ; if ( tag Name . equals ( XML GROUP ) ) { menu State . read Group ( attrs ) ; } else if ( tag Name . equals ( XML ITEM ) ) { menu State . read Item ( attrs ) ; } else if ( tag Name . equals ( XML MENU ) ) { Icon Data sub Menu = menu State . add Sub Menu Item ( ) ; parse Menu ( parser , attrs , sub Menu ) ; } else { looking For End Of Unknown Tag = BOOL ; unknown Tag Name = tag Name ; } break ; case Xml Pull Parser . END TAG : tag Name = parser . get Name ( ) ; if ( looking For End Of Unknown Tag && tag Name . equals ( unknown Tag Name ) ) { looking For End Of Unknown Tag = BOOL ; unknown Tag Name = null ; } else if ( tag Name . equals ( XML GROUP ) ) { menu State . reset Group ( ) ; } else if ( tag Name . equals ( XML ITEM ) ) { if ( ! menu State . has Added Item ( ) ) { menu State . add Item ( ) ; } } else if ( tag Name . equals ( XML MENU ) ) { reached End Of Menu = BOOL ; } break ; case Xml Pull Parser . END DOCUMENT : throw new Runtime Exception ( STRING ) ; } event Type = parser . next ( ) ; } }
public static double cross Track Distance Rad ( double lat 1 , double lon 1 , double lat 2 , double lon 2 , double lat Q , double lon Q , double dist 1 Q ) { final double dlon 12 = lon 2 - lon 1 ; final double dlon 1 Q = lon Q - lon 1 ; final double slat 1 = Math . sin ( lat 1 ) , clat 1 = Math Util . sin To Cos ( lat 1 , slat 1 ) ; final double slat Q = Math . sin ( lat Q ) , clat Q = Math Util . sin To Cos ( lat Q , slat Q ) ; final double slat 2 = Math . sin ( lat 2 ) , clat 2 = Math Util . sin To Cos ( lat 2 , slat 2 ) ; final double sdlon 12 = Math . sin ( dlon 12 ) , cdlon 12 = Math Util . sin To Cos ( dlon 12 , sdlon 12 ) ; final double sdlon 1 Q = Math . sin ( dlon 1 Q ) , cdlon 1 Q = Math Util . sin To Cos ( dlon 1 Q , sdlon 1 Q ) ; final double yE = sdlon 12 * clat 2 ; final double yQ = sdlon 1 Q * clat Q ; final double xE = clat 1 * slat 2 - slat 1 * clat 2 * cdlon 12 ; final double xQ = clat 1 * slat Q - slat 1 * clat Q * cdlon 1 Q ; final double crs 12 = Math . atan 2 ( yE , xE ) ; final double crs 1 Q = Math . atan 2 ( yQ , xQ ) ; return Math . asin ( Math . sin ( dist 1 Q ) * Math . sin ( crs 1 Q - crs 12 ) ) ; }
@ Override public String choose Server Alias ( final String key Type , final Principal [ ] issuers , final Socket socket ) { if ( key Manager != null ) { return key Manager . choose Server Alias ( key Type , issuers , socket ) ; } return null ; }
public static double log Pdf ( double x , double shape , double scale , double factor ) { if ( x <= NUM ) return Double . NEGATIVE INFINITY ; return factor + shape * Math . log ( scale ) - ( shape + NUM ) * Math . log ( x ) - ( scale / x ) - Gamma Function . ln Gamma ( shape ) ; }
public String charge ( Properties ctx , int Window No , Grid Tab m Tab , Grid Field m Field , Object value ) { Integer C Charge ID = ( Integer ) value ; if ( C Charge ID == null || C Charge ID . int Value ( ) == NUM ) return STRING ; if ( m Tab . get Value ( STRING ) != null ) { m Tab . set Value ( STRING , null ) ; return STRING ; } m Tab . set Value ( STRING , null ) ; m Tab . set Value ( STRING , null ) ; m Tab . set Value ( STRING , new Integer ( NUM ) ) ; Env . set Context ( ctx , Window No , STRING , STRING ) ; String sql = STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , C Charge ID . int Value ( ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { m Tab . set Value ( STRING , rs . get Big Decimal ( NUM ) ) ; m Tab . set Value ( STRING , rs . get Big Decimal ( NUM ) ) ; m Tab . set Value ( STRING , Env . ZERO ) ; m Tab . set Value ( STRING , Env . ZERO ) ; m Tab . set Value ( STRING , Env . ZERO ) ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; return e . get Localized Message ( ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return tax ( ctx , Window No , m Tab , m Field , value ) ; }
private void process Tag ( final String Builder builder ) { boolean started = BOOL ; while ( template Reader . has Next Character ( ) ) { final char tag Character = template Reader . next Character ( ) ; if ( ! started && Strings . is Whitespace ( tag Character ) ) { continue ; } started = BOOL ; if ( tag Character == syntax . get Argument Opening ( ) ) { process Argument ( ) ; } else if ( tag Character == syntax . get Tag Opening ( ) && is Next Character Comment Opening ( ) ) { process Comment ( ) ; } else if ( tag Character == syntax . get Tag Closing ( ) ) { process Tag Entity ( builder ) ; return ; } else { builder . append ( tag Character ) ; } } throw Error ( STRING + builder . to String ( ) ) ; }
public void test B Aand B Cbroker Network ( ) throws Exception { bridge Brokers ( STRING , STRING ) ; bridge Brokers ( STRING , STRING ) ; start All Brokers ( ) ; Destination dest = create Destination ( STRING , BOOL ) ; Message Consumer client A = create Consumer ( STRING , dest ) ; Message Consumer client B = create Consumer ( STRING , dest ) ; Message Consumer client C = create Consumer ( STRING , dest ) ; Thread . sleep ( NUM ) ; send Messages ( STRING , dest , MESSAGE COUNT ) ; send Messages ( STRING , dest , MESSAGE COUNT ) ; send Messages ( STRING , dest , MESSAGE COUNT ) ; Message Id List msgs A = get Consumer Messages ( STRING , client A ) ; Message Id List msgs B = get Consumer Messages ( STRING , client B ) ; Message Id List msgs C = get Consumer Messages ( STRING , client C ) ; msgs A . wait For Messages To Arrive ( MESSAGE COUNT * NUM ) ; msgs B . wait For Messages To Arrive ( MESSAGE COUNT ) ; msgs C . wait For Messages To Arrive ( MESSAGE COUNT * NUM ) ; assert Equals ( MESSAGE COUNT * NUM , msgs A . get Message Count ( ) ) ; assert Equals ( MESSAGE COUNT , msgs B . get Message Count ( ) ) ; assert Equals ( MESSAGE COUNT * NUM , msgs C . get Message Count ( ) ) ; }
public boolean write Header ( Output Stream os ) { try { write Int ( os , CACHE MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? STRING : etag ) ; write Long ( os , server Date ) ; write Long ( os , last Modified ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return BOOL ; } catch ( IO Exception e ) { Volley Log . d ( STRING , e . to String ( ) ) ; return BOOL ; } }
private Drag Lock compute Drag Lock ( float scroll Drag , float discard Drag ) { scroll Drag = Math . abs ( scroll Drag ) ; discard Drag = Math . abs ( discard Drag ) ; Drag Lock hint Lock = ( discard Drag * DRAG ANGLE THRESHOLD ) > scroll Drag ? Drag Lock . DISCARD : Drag Lock . SCROLL ; long time Millisecond = System . current Time Millis ( ) ; if ( ( time Millisecond - m Last Scroll Update ) > DRAG TIME THRESHOLD ) { m Drag Lock = Drag Lock . NONE ; } if ( ( m Drag Lock == Drag Lock . NONE && Math . abs ( scroll Drag - discard Drag ) > m Min Scroll Motion ) || ( m Drag Lock == Drag Lock . DISCARD && discard Drag > m Min Scroll Motion ) || ( m Drag Lock == Drag Lock . SCROLL && scroll Drag > m Min Scroll Motion ) ) { m Last Scroll Update = time Millisecond ; if ( m Drag Lock == Drag Lock . NONE ) { m Drag Lock = hint Lock ; } } return m Drag Lock == Drag Lock . NONE ? hint Lock : m Drag Lock ; }
public static synchronized Token Info create Token ( Token Type token Type ) { Token token = new Token ( token Type . get Module Type ( ) , token Type . get Id ( ) ) ; token . set Module Id ( token Type . get Module Type ( ) ) ; token . set Read Only ( token Type . is Read Only ( ) ) ; token . set Serial Number ( token Type . get Serial Number ( ) ) ; token . set Label ( token Type . get Label ( ) ) ; token . set Slot Index ( token Type . get Slot Index ( ) ) ; token . set Friendly Name ( get Default Friendly Name ( token Type ) ) ; token . set Batch Signing Enabled ( token Type . is Batch Signing Enabled ( ) ) ; token . set Available ( BOOL ) ; current Tokens . add ( token ) ; return token . to DTO ( ) ; }
private final boolean validate Client Packet ( Byte Buffer buf ) { return buf . get Short ( NUM ) == ~ buf . get Short ( NUM ) && buf . get ( NUM ) == static Client Packet Code ; }
public static Mime Type from File Name ( final String file Name ) { final String in Lower Case Name = file Name . to Lower Case ( ) ; final String file Extension = get File Extension ( in Lower Case Name ) ; final Mime Type mime Type = file Extensions . get ( file Extension ) ; if ( mime Type != null ) { return mime Type ; } return BINARY ; }
protected int convert Text ( String text , Locale locale ) { try { return Integer . parse Int ( text ) ; } catch ( Number Format Exception ex ) { throw new Illegal Field Value Exception ( get Type ( ) , text ) ; } }
public static Request Security Token Response parse XML ( Input Stream is ) throws WS Federation Exception { Document doc = XML Utils . to DOM Document ( is , debug ) ; Element root = doc . get Document Element ( ) ; return new Request Security Token Response ( root ) ; }
@ Override public void cancel Resource Request ( Samza Resource Request request ) { log . info ( STRING , request ) ; synchronized ( lock ) { AMRM Client . Container Request container Request = requests Map . get ( request ) ; if ( container Request == null ) { log . info ( STRING , container Request ) ; return ; } requests Map . remove ( request ) ; am Client . remove Container Request ( container Request ) ; } }
public void reset ( Collection < E > collection , @ Nullable Diff Util . Callback callback ) { items . clear ( ) ; items . add All ( collection ) ; if ( callback != null ) { update Items Task = new Update Items Task ( ) ; update Items Task . execute ( callback ) ; } else { notify Data Set Changed ( ) ; } }
private String print D Format ( String sx ) { int n Leading Zeros = NUM ; int n Blanks = NUM , n = NUM ; int i = NUM , j First = NUM ; boolean neg = sx . char At ( NUM ) == STRING ; if ( sx . equals ( STRING ) && precision Set && precision == NUM ) sx = STRING ; if ( ! neg ) { if ( precision Set && sx . length ( ) < precision ) n Leading Zeros = precision - sx . length ( ) ; } else { if ( precision Set && ( sx . length ( ) - NUM ) < precision ) n Leading Zeros = precision - sx . length ( ) + NUM ; } if ( n Leading Zeros < NUM ) n Leading Zeros = NUM ; if ( field Width Set ) { n Blanks = field Width - n Leading Zeros - sx . length ( ) ; if ( ! neg && ( leading Sign || leading Space ) ) n Blanks -- ; } if ( n Blanks < NUM ) n Blanks = NUM ; if ( leading Sign ) n ++ ; else if ( leading Space ) n ++ ; n += n Blanks ; n += n Leading Zeros ; n += sx . length ( ) ; char [ ] ca = new char [ n ] ; if ( left Justify ) { if ( neg ) ca [ i ++ ] = STRING ; else if ( leading Sign ) ca [ i ++ ] = STRING ; else if ( leading Space ) ca [ i ++ ] = STRING ; char [ ] csx = sx . to Char Array ( ) ; j First = neg ? NUM : NUM ; for ( int j = NUM ; j < n Leading Zeros ; i ++ , j ++ ) ca [ i ] = STRING ; for ( int j = j First ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; for ( int j = NUM ; j < n Blanks ; i ++ , j ++ ) ca [ i ] = STRING ; } else { if ( ! leading Zeros ) { for ( i = NUM ; i < n Blanks ; i ++ ) ca [ i ] = STRING ; if ( neg ) ca [ i ++ ] = STRING ; else if ( leading Sign ) ca [ i ++ ] = STRING ; else if ( leading Space ) ca [ i ++ ] = STRING ; } else { if ( neg ) ca [ i ++ ] = STRING ; else if ( leading Sign ) ca [ i ++ ] = STRING ; else if ( leading Space ) ca [ i ++ ] = STRING ; for ( int j = NUM ; j < n Blanks ; j ++ , i ++ ) ca [ i ] = STRING ; } for ( int j = NUM ; j < n Leading Zeros ; j ++ , i ++ ) ca [ i ] = STRING ; char [ ] csx = sx . to Char Array ( ) ; j First = neg ? NUM : NUM ; for ( int j = j First ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; } return new String ( ca ) ; }
public Buffered Image create Buffered Image ( int image Width , int image Height , double draw Width , double draw Height , Chart Rendering Info info ) { Buffered Image image = new Buffered Image ( image Width , image Height , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g2 = image . create Graphics ( ) ; double scale X = image Width / draw Width ; double scale Y = image Height / draw Height ; Affine Transform st = Affine Transform . get Scale Instance ( scale X , scale Y ) ; g2 . transform ( st ) ; draw ( g2 , new Rectangle 2 D . Double ( NUM , NUM , draw Width , draw Height ) , null , info ) ; g2 . dispose ( ) ; return image ; }
public void remove ( symbol sym ) throws internal error { not null ( sym ) ; all . remove ( sym . name ( ) ) ; }
public final V remove ( int index ) { if ( GWT . is Script ( ) ) { V ret = js Array . get ( index ) ; js Array . remove ( index ) ; return ret ; } else { return java Array . remove ( index ) ; } }

public void reduce ( Text key , Iterator < Object Writable > values , Output Collector < Text , Node > output , Reporter reporter ) throws IO Exception { String url = key . to String ( ) ; Set < String > domains = new Hash Set < String > ( ) ; Set < String > pages = new Hash Set < String > ( ) ; Node node = null ; int num Inlinks = NUM ; float total Inlink Score = rank One ; while ( values . has Next ( ) ) { Object Writable next = values . next ( ) ; Object value = next . get ( ) ; if ( value instanceof Node ) { node = ( Node ) value ; } else if ( value instanceof Link Datum ) { Link Datum link Datum = ( Link Datum ) value ; float score From Inlink = link Datum . get Score ( ) ; String inlink Url = link Datum . get Url ( ) ; String in Link Domain = URL Util . get Domain Name ( inlink Url ) ; String in Link Page = URL Util . get Page ( inlink Url ) ; if ( ( limit Pages && pages . contains ( in Link Page ) ) || ( limit Domains && domains . contains ( in Link Domain ) ) ) { LOG . debug ( url + STRING + score From Inlink + STRING + inlink Url + STRING ) ; continue ; } num Inlinks ++ ; total Inlink Score += score From Inlink ; domains . add ( in Link Domain ) ; pages . add ( in Link Page ) ; LOG . debug ( url + STRING + score From Inlink + STRING + inlink Url + STRING + total Inlink Score ) ; } } float link Rank Score = ( NUM - this . damping Factor ) + ( this . damping Factor * total Inlink Score ) ; LOG . debug ( url + STRING + link Rank Score + STRING + num Inlinks + STRING + it Num ) ; Node out Node = ( Node ) Writable Utils . clone ( node , conf ) ; out Node . set Inlink Score ( link Rank Score ) ; output . collect ( key , out Node ) ; }
protected void stop Job Acquisition Thread ( ) { if ( async Job Acquisition Thread != null ) { try { async Job Acquisition Thread . join ( ) ; } catch ( Interrupted Exception e ) { log . warn ( STRING , e ) ; } async Job Acquisition Thread = null ; } }
protected void restore Blob Into Memory ( ) throws Cache Exception { String cache File Path And Name = get Cache File Path And Name ( ) ; long begin = LOG . is Trace Enabled ( ) ? System . current Time Millis ( ) : NUM ; if ( LOG . is Trace Enabled ( ) ) LOG . trace ( STRING + get Var Name ( ) + STRING + ( hdfs File Name == null ? STRING : hdfs File Name ) + STRING + cache File Path And Name ) ; if ( data != null ) throw new Cache Exception ( cache File Path And Name + STRING ) ; try { data = read Blob From Cache ( cache File Path And Name ) ; } catch ( IO Exception e ) { throw new Cache Exception ( cache File Path And Name + STRING , e ) ; } if ( data == null ) throw new Cache Exception ( cache File Path And Name + STRING ) ; if ( LOG . is Trace Enabled ( ) ) LOG . trace ( STRING + ( System . current Time Millis ( ) - begin ) + STRING ) ; }
public static String determine Initial Check Out Page ( Shopping Cart cart ) { String page = DEFAULT INIT CHECKOUT PAGE ; if ( cart == null ) return page ; if ( ! cart . shipping Applies ( ) ) { cart . set All Shipment Method Type Id ( STRING ) ; cart . set All Carrier Party Id ( STRING ) ; page = STRING ; } return page ; }
private void unwrap Data ( ) throws Ignite Checked Exception , SSL Exception { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + ses ) ; in Net Buf . flip ( ) ; SSL Engine Result res = unwrap 0 ( ) ; in Net Buf . compact ( ) ; check Status ( res ) ; renegotiate If Needed ( res ) ; }
private void check Alter Partial Converters ( ) throws Security Exception { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( new Joda Time Permission ( STRING ) ) ; } }
public void store Username ( String username ) { if ( is Store && shared State != null ) { shared State . put ( get User Key ( ) , username ) ; } }
public static Summary Tree Node create Node ( Android Version version , Set < Updater Tree Node > children ) { Set < Updater Tree Node > included Children = Sets . new Hash Set ( ) ; Updater Tree Node primary Child = null ; for ( Updater Tree Node child : children ) { if ( child . include In Summary ( ) ) { included Children . add ( child ) ; } if ( child . is Primary ( ) ) { primary Child = child ; } } if ( ! included Children . is Empty ( ) ) { return new Summary Tree Node ( version , children , included Children , primary Child ) ; } return null ; }
boolean await Termination ( long timeout , Time Unit unit ) throws Interrupted Exception { return scheduler Service . await Termination ( timeout , unit ) ; }
public void move ( Task what , Task where ) { Node sub Node = my Node Map . get ( what ) ; if ( sub Node == null ) { return ; } boolean removed Any = remove Implicit Dependencies ( sub Node ) ; Node super Node = my Node Map . get ( where ) ; if ( super Node == null ) { if ( removed Any ) { fire Graph Changed ( ) ; } return ; } for ( Dependency Edge incoming Edge : Lists . new Array List ( super Node . get Incoming ( ) ) ) { if ( incoming Edge instanceof Implicit Sub Super Task Dependency == BOOL ) { if ( incoming Edge instanceof Implicit Inherited Dependency ) { incoming Edge = ( ( Implicit Inherited Dependency ) incoming Edge ) . my Explicit Dep ; } Implicit Inherited Dependency implicit Incoming = new Implicit Inherited Dependency ( incoming Edge , super Node , sub Node ) ; add Edge ( implicit Incoming ) ; add Inherited Dependencies ( incoming Edge , sub Node ) ; } } add Edge ( new Implicit Sub Super Task Dependency ( sub Node , super Node ) ) ; fire Graph Changed ( ) ; }
public static Collection < Message Fragment Style > colorize Regex ( Style style , String text , Pattern regex , int group ) { Array List < Message Fragment Style > list = new Array List < > ( ) ; Matcher matcher = regex . matcher ( text ) ; while ( matcher . find ( ) ) { int start = matcher . start ( group ) ; int end = matcher . end ( group ) ; if ( end - start > NUM ) { Message Fragment Style message Fragment Style = new Message Fragment Style ( start , end - start , style , BOOL ) ; list . add ( message Fragment Style ) ; } } return list ; }
protected void apply Patch ( State current , State patch ) { if ( patch . task Info != null ) { Service Utils . log Info ( this , STRING , current . task Info . stage , patch . task Info . stage ) ; current . task Info = patch . task Info ; } if ( patch . data Store Count != null ) { current . data Store Count = patch . data Store Count ; } if ( patch . finished Deletes != null ) { current . finished Deletes = patch . finished Deletes ; } if ( patch . failed Or Canceled Deletes != null ) { current . failed Or Canceled Deletes = patch . failed Or Canceled Deletes ; } }
private void do Post Helper ( Http Servlet Request request , Http Servlet Response response ) throws Servlet Exception , IO Exception { logger . log ( Level . INFO , STRING + request . get Request URI ( ) ) ; final Request And Response request And Response = new Request And Response ( request , response ) ; standard Response Stuff ( request And Response ) ; final String uri = request . get Request URI ( ) ; request And Response . set Override Uri ( uri ) ; if ( uri . equals ( STRING ) ) { handle Json Create Quotation ( request And Response ) ; } else if ( uri . equals ( STRING ) ) { handle Html Make Notebook ( request And Response ) ; } else if ( uri . equals ( STRING ) ) { handle Json Move Notes ( request And Response ) ; } else if ( uri . equals ( STRING ) ) { handle Json Note Op ( request And Response ) ; } else if ( uri . equals ( STRING ) ) { handle Json Get Notebook Path ( request And Response ) ; } else if ( uri . equals ( STRING ) ) { handle Json Make Children ( request And Response ) ; } else if ( uri . equals ( STRING ) ) { handle Json Make Siblings ( request And Response ) ; } else if ( uri . equals ( STRING ) ) { handle Json Sign In ( request And Response ) ; } else if ( uri . equals ( STRING ) ) { handle Json Sign Out ( request And Response ) ; } else if ( uri . equals ( STRING ) ) { handle Json Create Account ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Do User Restore ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Do Offline Db Backup ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Do Online Db Backup ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Do Clear ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Do User Backup ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Do Shutdown ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Do Check For Errors ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Change Password ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Change Account ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Close Account ( request And Response ) ; } else if ( uri . equals ( STRING ) ) { handle Json Save Options ( request And Response ) ; } else if ( uri . starts With ( STRING ) ) { handle Html Do Export ( request And Response ) ; } else { return Html 404 ( request And Response ) ; } }
public static void add Other Feature To Predict Document ( Mira Template a Template , Repository Service a Repository , Annotation Service a Annotation Service , Automation Service a Automation Service , User Dao a User Dao ) throws UIMA Exception , Class Not Found Exception , IO Exception , Brat Annotation Exception , Automation Exception { Annotation Feature layer Feature = a Template . get Train Feature ( ) ; File mira Dir = a Automation Service . get Mira Dir ( layer Feature ) ; for ( Source Document document : a Repository . list Source Documents ( layer Feature . get Project ( ) ) ) { List < List < String > > predictions = new Array List < List < String > > ( ) ; if ( ! document . is Processed ( ) && ! document . is Training Document ( ) ) { File pred Ft File = new File ( mira Dir , document . get Id ( ) + STRING ) ; Mira mira = new Mira ( ) ; int beam Size = NUM ; boolean max Posteriors = BOOL ; File predcited File = new File ( pred Ft File . get Absolute Path ( ) + STRING ) ; get Feature Other Layer ( a Template , a Repository , a Annotation Service , a Automation Service , a User Dao , beam Size , max Posteriors , predictions , mira , pred Ft File , predcited File , document ) ; get Features Tab Sep ( a Template , a Repository , a Automation Service , beam Size , max Posteriors , layer Feature , predictions , mira , pred Ft File , predcited File ) ; File base Pred File = new File ( mira Dir , document . get Id ( ) + STRING ) ; if ( predictions . size ( ) == NUM ) { create Template ( a Template . get Train Feature ( ) , get Mira Template File ( layer Feature , a Automation Service ) , NUM ) ; File Utils . copy File ( pred Ft File , base Pred File ) ; } else { create Template ( a Template . get Train Feature ( ) , get Mira Template File ( layer Feature , a Automation Service ) , predictions . size ( ) ) ; build Predict File ( pred Ft File , base Pred File , predictions , a Template . get Train Feature ( ) ) ; } } } }
public Iterator < Edge > removed Edge Iterator ( ) { return removed Edge List != null ? removed Edge List . iterator ( ) : new Null Iterator < Edge > ( ) ; }
private void type Unknown ( char c ) { int converted = Key Event . get Extended Key Code For Char ( c ) ; controller . key Press ( converted ) ; controller . key Release ( converted ) ; }
public boolean has Descendant ( Set < String > variables ) { Queue < B Node > nodes To Process = new Linked List < B Node > ( ) ; nodes To Process . add ( this ) ; while ( ! nodes To Process . is Empty ( ) ) { B Node current Node = nodes To Process . poll ( ) ; for ( B Node descendant Node : current Node . get Output Nodes ( ) ) { if ( variables . contains ( descendant Node . get Id ( ) ) ) { return BOOL ; } if ( ! nodes To Process . contains ( descendant Node ) ) { nodes To Process . add ( descendant Node ) ; } } } return BOOL ; }
public void add Rule ( Rule rule ) throws Name Already Exists Exception , Invalid Name Exception { if ( rule . get Name ( ) == null ) { rule . set Name ( STRING + Service Type Manager . generate Random Name ( ) ) ; } if ( rules . contains Key ( rule . get Name ( ) ) ) { throw ( new Name Already Exists Exception ( Res Bundle Utils . rb Name , STRING , null , rule . get Name ( ) , Policy Exception . RULE ) ) ; } else if ( rules . contains Value ( rule ) ) { throw ( new Name Already Exists Exception ( Res Bundle Utils . rb Name , STRING , null , rule . get Name ( ) , Policy Exception . RULE ) ) ; } rules . put ( rule . get Name ( ) , rule ) ; }
public static boolean is Cglib Proxy Class ( Class < ? > clazz ) { return ( clazz != null && is Cglib Proxy Class Name ( clazz . get Name ( ) ) ) ; }
public void test Bug 27412 ( ) throws Exception { Properties props = new Properties ( ) ; props . put ( STRING , STRING ) ; props . put ( STRING , STRING ) ; props . put ( STRING , STRING ) ; Connection conn 2 = get Connection With Props ( props ) ; Prepared Statement pstm = conn 2 . prepare Statement ( STRING ) ; try { assert True ( pstm . execute ( ) ) ; } finally { pstm . close ( ) ; conn 2 . close ( ) ; } }
public static boolean equals ( float [ ] field 1 , float [ ] field 2 ) { if ( field 1 == null || field 1 . length == NUM ) { return field 2 == null || field 2 . length == NUM ; } else { return Arrays . equals ( field 1 , field 2 ) ; } }
public void to Back ( final Workflow Annotation anno ) { if ( anno == null ) { throw new Illegal Argument Exception ( STRING ) ; } synchronized ( lock ) { if ( annotations Draw Order . remove ( anno ) ) { annotations Draw Order . add ( NUM , anno ) ; } if ( annotations Event Order . remove ( anno ) ) { annotations Event Order . add ( annotations Event Order . size ( ) , anno ) ; } } }
public synchronized void update ( ) { if ( frames . size ( ) > NUM ) { anim Time += NUM ; if ( anim Time >= total Duration ) { anim Time = anim Time % total Duration ; curr Frame Index = NUM ; } while ( anim Time > get Frame ( curr Frame Index ) . end Time ) { curr Frame Index ++ ; } } }
public static String randomly Recase Code Points ( Random random , String str ) { String Builder builder = new String Builder ( ) ; int pos = NUM ; while ( pos < str . length ( ) ) { int code Point = str . code Point At ( pos ) ; pos += Character . char Count ( code Point ) ; switch ( next Int ( random , NUM , NUM ) ) { case NUM : builder . append Code Point ( Character . to Upper Case ( code Point ) ) ; break ; case NUM : builder . append Code Point ( Character . to Lower Case ( code Point ) ) ; break ; case NUM : builder . append Code Point ( code Point ) ; } } return builder . to String ( ) ; }
private Boolean handle Execution Response ( Http URL Connection connection ) throws IO Exception { int response Code = connection . get Response Code ( ) ; if ( is Successful ( response Code ) ) { String response Content = get Response Content As String ( connection ) ; String id = response Content != null ? response Content : STRING ; Log . i ( TAG , STRING + m File To Upload . get Name ( ) + STRING + id ) ; cleanup Minidump File ( ) ; try { append Uploaded Entry To Log ( id ) ; } catch ( IO Exception ioe ) { Log . e ( TAG , STRING ) ; } return BOOL ; } else { String msg = String . format ( Locale . US , STRING , m File To Upload . get Name ( ) , response Code , connection . get Response Message ( ) ) ; Log . i ( TAG , msg ) ; return BOOL ; } }
boolean close Outbound ( ) throws SSL Exception { if ( ssl Engine == null || ssl Engine . is Outbound Done ( ) ) { return BOOL ; } ssl Engine . close Outbound ( ) ; create Out Net Buffer ( NUM ) ; SSL Engine Result result ; for ( ; ; ) { result = ssl Engine . wrap ( empty Buffer . buf ( ) , out Net Buffer . buf ( ) ) ; if ( result . get Status ( ) == Status . BUFFER OVERFLOW ) { out Net Buffer . capacity ( out Net Buffer . capacity ( ) << NUM ) ; out Net Buffer . limit ( out Net Buffer . capacity ( ) ) ; } else { break ; } } if ( result . get Status ( ) != Status . CLOSED ) { throw new SSL Exception ( STRING + result ) ; } out Net Buffer . flip ( ) ; return BOOL ; }
public static Bitmap create Video Thumbnail ( String file Path , int kind , long time Us ) { Log . i ( TAG , STRING ) ; Bitmap bitmap = null ; Media Metadata Retriever retriever = new Media Metadata Retriever ( ) ; try { Log . i ( TAG , STRING ) ; retriever . set Data Source ( file Path ) ; bitmap = retriever . get Frame At Time ( time Us ) ; } catch ( Illegal Argument Exception ex ) { } catch ( Runtime Exception ex ) { } finally { Log . i ( TAG , STRING ) ; try { Log . i ( TAG , STRING ) ; retriever . release ( ) ; } catch ( Runtime Exception ex ) { } } if ( bitmap == null ) { Log . i ( TAG , STRING ) ; return null ; } if ( kind == Images . Thumbnails . MINI KIND ) { int width = bitmap . get Width ( ) ; int height = bitmap . get Height ( ) ; int max = Math . max ( width , height ) ; if ( max > NUM ) { float scale = NUM / max ; int w = Math . round ( scale * width ) ; int h = Math . round ( scale * height ) ; bitmap = Bitmap . create Scaled Bitmap ( bitmap , width , height , BOOL ) ; } } else if ( kind == Images . Thumbnails . MICRO KIND ) { Log . i ( TAG , STRING ) ; bitmap = extract Thumbnail ( bitmap , TARGET SIZE MICRO THUMBNAIL , TARGET SIZE MICRO THUMBNAIL , NUM ) ; } return bitmap ; }
File write Hockey App Crash Log ( String stack Trace ) { File log File = null ; Buffered Writer writer ; try { File output Dir = context . get Cache Dir ( ) ; log File = File . create Temp File ( STRING , STRING , output Dir ) ; writer = new Buffered Writer ( new File Writer ( log File ) ) ; writer . write ( STRING + utils . get Application Package Name ( context ) + STRING ) ; writer . write ( STRING + utils . get Version Code ( context ) + STRING ) ; writer . write ( STRING + utils . get Version Name ( context ) + STRING ) ; writer . write ( STRING + Build . VERSION . RELEASE + STRING ) ; writer . write ( STRING + Build . MANUFACTURER + STRING ) ; writer . write ( STRING + Build . MODEL + STRING ) ; writer . write ( STRING + get Timestamp ( ) + STRING ) ; writer . write ( STRING ) ; writer . write ( stack Trace ) ; writer . close ( ) ; } catch ( Exception ex ) { utils . log Issue ( STRING , ex ) ; } return log File ; }
public void add ( Event Bean the Event ) { if ( the Event == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( first Event == null ) { first Event = the Event ; return ; } if ( additional Events == null ) { additional Events = new Array Deque < Event Bean > ( ) ; } additional Events . add ( the Event ) ; }
public Oid ( Input Stream der Oid ) throws GSS Exception { try { Der Value der Val = new Der Value ( der Oid ) ; der Encoding = der Val . to Byte Array ( ) ; oid = der Val . get OID ( ) ; } catch ( IO Exception e ) { throw new GSS Exception ( GSS Exception . FAILURE , STRING ) ; } }
public void inc Prob ( int cat , double prob ) { if ( cat > probabilities . length ) throw new Index Out Of Bounds Exception ( STRING + probabilities . length + STRING + cat + STRING ) ; else if ( prob < NUM || Double . is Infinite ( prob ) || Double . is Na N ( prob ) ) throw new Arithmetic Exception ( STRING + prob ) ; probabilities [ cat ] += prob ; }
private void type Alphabetic ( char c ) { if ( Character . is Upper Case ( c ) ) { controller . key Press ( Key Event . VK SHIFT ) ; } controller . key Press ( Character . to Upper Case ( c ) ) ; controller . key Release ( Character . to Upper Case ( c ) ) ; if ( Character . is Upper Case ( c ) ) { controller . key Release ( Key Event . VK SHIFT ) ; } }
private static boolean eq ( Object o1 , Object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; }
public static Optional < Notification > try Find ( @ Nonnull final Iterable < Notification > notifications , final long id ) { final com . google . common . base . Optional < Notification > result = Iterables . try Find ( notifications , null ) ; if ( result . is Present ( ) ) { return Optional . of ( result . get ( ) ) ; } return Optional . empty ( ) ; }
@ Override public void write ( Output Stream output Stream , Storable obj ) throws IO Exception { Writer writer = new Output Stream Writer ( output Stream ) ; gson . to Json ( obj , obj . get Class ( ) , writer ) ; writer . close ( ) ; }
protected final void write H ( Byte Buffer buf , int value ) { buf . put Short ( ( short ) value ) ; }
protected void draw Item Label ( Graphics 2 D g2 , Plot Orientation orientation , XY Dataset dataset , int series , int item , double x , double y , boolean negative ) { XY Item Label Generator generator = get Item Label Generator ( series , item ) ; if ( generator != null ) { Font label Font = get Item Label Font ( series , item ) ; Paint paint = get Item Label Paint ( series , item ) ; g2 . set Font ( label Font ) ; g2 . set Paint ( paint ) ; String label = generator . generate Label ( dataset , series , item ) ; Item Label Position position ; if ( ! negative ) { position = get Positive Item Label Position ( series , item ) ; } else { position = get Negative Item Label Position ( series , item ) ; } Point 2 D anchor Point = calculate Label Anchor Point ( position . get Item Label Anchor ( ) , x , y , orientation ) ; Text Utilities . draw Rotated String ( label , g2 , ( float ) anchor Point . get X ( ) , ( float ) anchor Point . get Y ( ) , position . get Text Anchor ( ) , position . get Angle ( ) , position . get Rotation Anchor ( ) ) ; } }
protected void paint Content Border Right Edge ( Graphics g , int x , int y , int w , int h , boolean draw Broken , Rectangle sel Rect , boolean is Content Border Painted ) { if ( is Content Border Painted ) { g . set Color ( dark Shadow ) ; g . fill Rect ( x + w - NUM , y , NUM , h ) ; } }
public static byte [ ] convert DER Encoded Signature To JWS Concatenated ( final byte [ ] der Encoded Signature Value ) throws IO Exception { final ASN 1 Input Stream asn 1 Input Stream = new ASN 1 Input Stream ( der Encoded Signature Value ) ; final ASN 1 Primitive asn 1 Primitive = asn 1 Input Stream . read Object ( ) ; asn 1 Input Stream . close ( ) ; final ASN 1 Sequence asn 1 Sequence = ( ASN 1 Sequence . get Instance ( asn 1 Primitive ) ) ; final ASN 1 Integer rASN 1 = ( ASN 1 Integer ) asn 1 Sequence . get Object At ( NUM ) ; final ASN 1 Integer sASN 1 = ( ASN 1 Integer ) asn 1 Sequence . get Object At ( NUM ) ; final X9 Integer Converter x9 Integer Converter = new X9 Integer Converter ( ) ; final byte [ ] r = x9 Integer Converter . integer To Bytes ( rASN 1 . get Value ( ) , NUM ) ; final byte [ ] s = x9 Integer Converter . integer To Bytes ( sASN 1 . get Value ( ) , NUM ) ; final byte [ ] concatenated Signature Value = new byte [ NUM ] ; System . arraycopy ( r , NUM , concatenated Signature Value , NUM , NUM ) ; System . arraycopy ( s , NUM , concatenated Signature Value , NUM , NUM ) ; return concatenated Signature Value ; }
public static < T > Parallel Flowable < T > from ( Publisher < ? extends T > source , int parallelism ) { return from ( source , parallelism , Flowable . buffer Size ( ) ) ; }
public final void add To Tiers By Var Names ( List < String > var Names ) { if ( ! variables . contains All ( var Names ) ) { for ( String var Name : var Names ) { add Variable ( var Name ) ; } } for ( Object var Name : var Names ) { String node = ( String ) var Name ; int index = node . last Index Of ( STRING ) ; if ( index != - NUM ) { String substring = node . substring ( index + NUM ) ; add To Tier ( new Integer ( substring ) , node ) ; } } }
public boolean match ( String requested URL , Collection < String > patterns , boolean wildcard ) throws Malformed URL Exception { boolean result = BOOL ; String pattern Lower ; for ( String pattern : patterns ) { pattern Lower = pattern . to Lower Case ( ) ; requested URL = resource Name . canonicalize ( requested URL ) ; if ( pattern Lower . starts With ( STRING ) ) { pattern = resource Name . canonicalize ( pattern ) ; } if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STRING + requested URL + STRING + pattern ) ; } Resource Match res = resource Name . compare ( requested URL , pattern , wildcard ) ; if ( res == Resource Match . WILDCARD MATCH || res == Resource Match . EXACT MATCH ) { if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STRING + requested URL + STRING + pattern + STRING + res ) ; } result = BOOL ; break ; } } return result ; }
@ Request Processing ( value = STRING , method = HTTP Request Method . GET ) @ Before ( advice Class = { Stopwatch Start Advice . class , Anonymous View Check . class , User Block Check . class } ) @ After ( advice Class = Stopwatch End Advice . class ) public void show Home Following Users ( final HTTP Request Context context , final Http Servlet Request request , final Http Servlet Response response , final String user Name ) throws Exception { final JSON Object user = ( JSON Object ) request . get Attribute ( User . USER ) ; request . set Attribute ( Keys . TEMAPLTE DIR NAME , Symphonys . get ( STRING ) ) ; final Abstract Free Marker Renderer renderer = new Skin Renderer ( ) ; context . set Renderer ( renderer ) ; renderer . set Template Name ( STRING ) ; final Map < String , Object > data Model = renderer . get Data Model ( ) ; filler . fill Header And Footer ( request , response , data Model ) ; String page Num Str = request . get Parameter ( STRING ) ; if ( Strings . is Empty Or Null ( page Num Str ) || ! Strings . is Numeric ( page Num Str ) ) { page Num Str = STRING ; } final int page Num = Integer . value Of ( page Num Str ) ; final int page Size = Symphonys . get Int ( STRING ) ; final int window Size = Symphonys . get Int ( STRING ) ; fill Home User ( data Model , user ) ; final String following Id = user . opt String ( Keys . OBJECT ID ) ; data Model . put ( Follow . FOLLOWING ID , following Id ) ; avatar Query Service . fill User Avatar URL ( user ) ; final JSON Object following Users Result = follow Query Service . get Following Users ( following Id , page Num , page Size ) ; final List < JSON Object > following Users = ( List < JSON Object > ) following Users Result . opt ( Keys . RESULTS ) ; data Model . put ( Common . USER HOME FOLLOWING USERS , following Users ) ; final boolean is Logged In = ( Boolean ) data Model . get ( Common . IS LOGGED IN ) ; if ( is Logged In ) { final JSON Object current User = ( JSON Object ) data Model . get ( Common . CURRENT USER ) ; final String follower Id = current User . opt String ( Keys . OBJECT ID ) ; final boolean is Following = follow Query Service . is Following ( follower Id , following Id ) ; data Model . put ( Common . IS FOLLOWING , is Following ) ; for ( final JSON Object following User : following Users ) { final String home User Following User Id = following User . opt String ( Keys . OBJECT ID ) ; following User . put ( Common . IS FOLLOWING , follow Query Service . is Following ( follower Id , home User Following User Id ) ) ; } } user . put ( User Ext . USER T CREATE TIME , new Date ( user . get Long ( Keys . OBJECT ID ) ) ) ; final int following User Cnt = following Users Result . opt Int ( Pagination . PAGINATION RECORD COUNT ) ; final int page Count = ( int ) Math . ceil ( ( double ) following User Cnt / ( double ) page Size ) ; final List < Integer > page Nums = Paginator . paginate ( page Num , page Size , page Count , window Size ) ; if ( ! page Nums . is Empty ( ) ) { data Model . put ( Pagination . PAGINATION FIRST PAGE NUM , page Nums . get ( NUM ) ) ; data Model . put ( Pagination . PAGINATION LAST PAGE NUM , page Nums . get ( page Nums . size ( ) - NUM ) ) ; } data Model . put ( Pagination . PAGINATION CURRENT PAGE NUM , page Num ) ; data Model . put ( Pagination . PAGINATION PAGE COUNT , page Count ) ; data Model . put ( Pagination . PAGINATION PAGE NUMS , page Nums ) ; }
private final double pre Norm ( Number Vector v , final int start , final int end ) { double agg = NUM ; for ( int d = start ; d < end ; d ++ ) { final double xd = v . double Value ( d ) ; final double delta = xd >= NUM ? xd : - xd ; agg += Math . pow ( delta , p ) ; } return agg ; }
private int measure Height ( int measure Spec ) { float result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = m Paint Selected . get Stroke Width ( ) + get Padding Top ( ) + get Padding Bottom ( ) ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return ( int ) Math . ceil ( result ) ; }
public void layout ( Container container ) { Map < Location , Drawable > comps = get Components By Location ( container ) ; Drawable north = comps . get ( Location . NORTH ) ; Drawable north East = comps . get ( Location . NORTH EAST ) ; Drawable east = comps . get ( Location . EAST ) ; Drawable south East = comps . get ( Location . SOUTH EAST ) ; Drawable south = comps . get ( Location . SOUTH ) ; Drawable south West = comps . get ( Location . SOUTH WEST ) ; Drawable west = comps . get ( Location . WEST ) ; Drawable north West = comps . get ( Location . NORTH WEST ) ; Drawable center = comps . get ( Location . CENTER ) ; double width West = get Max Width ( north West , west , south West ) ; double width East = get Max Width ( north East , east , south East ) ; double height North = get Max Height ( north West , north , north East ) ; double height South = get Max Height ( south West , south , south East ) ; double gap West = ( width West > NUM && center != null ) ? get Gap X ( ) : NUM ; double gap East = ( width East > NUM && center != null ) ? get Gap X ( ) : NUM ; double gap North = ( height North > NUM && center != null ) ? get Gap Y ( ) : NUM ; double gap South = ( height South > NUM && center != null ) ? get Gap Y ( ) : NUM ; Rectangle 2 D bounds = container . get Bounds ( ) ; Insets 2 D insets = container . get Insets ( ) ; if ( insets == null ) { insets = new Insets 2 D . Double ( ) ; } double x West = bounds . get Min X ( ) + insets . get Left ( ) ; double x Center = x West + width West + gap West ; double x East = bounds . get Max X ( ) - insets . get Right ( ) - width East ; double y North = bounds . get Min Y ( ) + insets . get Top ( ) ; double y Center = y North + height North + gap North ; double y South = bounds . get Max Y ( ) - insets . get Bottom ( ) - height South ; double width All = width West + width East ; double height All = height North + height South ; double gap H All = gap West + gap East ; double gap V All = gap North - gap South ; layout Component ( north West , x West , y North , width West , height North ) ; layout Component ( north , x Center , y North , bounds . get Width ( ) - insets . get Horizontal ( ) - width All - gap H All , height North ) ; layout Component ( north East , x East , y North , width East , height North ) ; layout Component ( east , x East , y Center , width East , bounds . get Height ( ) - insets . get Vertical ( ) - height All - gap V All ) ; layout Component ( south East , x East , y South , width East , height South ) ; layout Component ( south , x Center , y South , bounds . get Width ( ) - insets . get Horizontal ( ) - width All - gap H All , height South ) ; layout Component ( south West , x West , y South , width West , height South ) ; layout Component ( west , x West , y Center , width West , bounds . get Height ( ) - insets . get Vertical ( ) - height All - gap V All ) ; layout Component ( center , x Center , y Center , bounds . get Width ( ) - insets . get Left ( ) - width All - insets . get Right ( ) - gap H All , bounds . get Height ( ) - insets . get Top ( ) - height All - insets . get Bottom ( ) - gap V All ) ; }
public void put ( byte [ ] data ) { if ( data == null ) return ; if ( data . length + position >= get Capacity ( ) ) { byte [ ] [ ] newbuf = new byte [ ( data . length + position ) / SIZE + NUM ] [ ] ; for ( int i = NUM ; i < buffer . length ; i ++ ) newbuf [ i ] = buffer [ i ] ; for ( int i = buffer . length ; i < newbuf . length ; i ++ ) newbuf [ i ] = new byte [ SIZE ] ; buffer = newbuf ; } for ( int i = NUM ; i < data . length ; i ++ ) { buffer [ position / SIZE ] [ position % SIZE ] = data [ i ] ; last = Math . max ( last , ( position ++ ) ) ; } }
public static double sum Of Mean Differences One Point ( double [ ] vector ) { double mean = sum ( vector ) / vector . length ; double ret = NUM ; for ( int i = NUM ; i < vector . length ; i ++ ) { double vec 1 Diff = Math . pow ( vector [ i ] - mean , NUM ) ; ret += vec 1 Diff ; } return ret ; }
@ Deprecated public static float [ ] combine ( float [ ] x , float [ ] y ) { int len = NUM ; if ( x != null ) len += x . length ; if ( y != null ) len += y . length ; float [ ] z = null ; if ( len > NUM ) { z = new float [ len ] ; int current Pos = NUM ; if ( x != null ) { System . arraycopy ( x , NUM , z , current Pos , x . length ) ; current Pos = x . length ; } if ( y != null ) System . arraycopy ( y , NUM , z , current Pos , y . length ) ; } return z ; }
public static Calendar string To Calendar ( String s ) { Date date = null ; try { date = TIME FORMAT . parse ( s ) ; } catch ( Parse Exception e ) { try { date = DATE FORMAT . parse ( s ) ; } catch ( Parse Exception e1 ) { return null ; } } if ( date == null ) { return null ; } Calendar output = Calendar . get Instance ( ) ; output . set Time ( date ) ; return output ; }
private static boolean equals Handles Nulls ( Local Item a , Local Item b ) { return ( a == b ) || ( ( a != null ) && a . equals ( b ) ) ; }
private Etcd Keys Response handle Etcd Watch Errors ( Etcd Exception exception ) { if ( exception . error Code == ETCD EVENT INDEX CLEARED CODE ) { initial Set All Flagz ( ) ; return null ; } else if ( exception . error Code == ETCD WATCHER CLEARED CODE ) { try { Thread . sleep ( reelection Backoff Ms . get ( ) ) ; } catch ( Interrupted Exception e1 ) { } return null ; } else { throw new Etcd Flag Field Updater Exception . Etcd Fetching Failed ( exception ) ; } }
public final static void close EL ( final Input Stream is ) { try { if ( is != null ) is . close ( ) ; } catch ( final Throwable e ) { } }
public final void search Pattern ( I Progress Monitor monitor ) throws Java Model Exception { Assert . is Not Null ( f Pattern ) ; if ( monitor == null ) monitor = new Null Progress Monitor ( ) ; try { monitor . begin Task ( STRING , NUM ) ; monitor . set Task Name ( Refactoring Core Messages . Refactoring Search Engine searching occurrences ) ; try { Search Engine engine = null ; if ( f Owner != null ) engine = new Search Engine ( f Owner ) ; else engine = new Search Engine ( f Working Copies ) ; engine . search ( f Pattern , Search Utils . get Default Search Participants ( ) , f Scope , get Collector ( ) , new Sub Progress Monitor ( monitor , NUM , Sub Progress Monitor . SUPPRESS SUBTASK LABEL ) ) ; } catch ( Core Exception exception ) { throw new Java Model Exception ( exception ) ; } } finally { monitor . done ( ) ; } }
public static String htmlentities ( final String str ) { if ( str == null ) { return STRING ; } if ( htmlentities map . is Empty ( ) ) { initialize Entities Tables ( ) ; } final String Builder buf = new String Builder ( ) ; for ( int i = NUM ; i < str . length ( ) ; ++ i ) { final char ch = str . char At ( i ) ; final String entity = htmlentities map . get ( new Integer ( ch ) ) ; if ( entity == null ) { if ( ch > NUM ) { buf . append ( STRING + ( int ) ch + STRING ) ; } else { buf . append ( ch ) ; } } else { buf . append ( entity ) ; } } return buf . to String ( ) ; }
@ Transactional public void update ( ) throws SQL Exception , Task Failed Exception { try { final Simple Date Format sdf = new Simple Date Format ( STRING ) ; final Simple Date Format formatter = new Simple Date Format ( STRING ) ; created = formatter . format ( sdf . parse ( created ) ) ; new Update ( ) ; } catch ( final Exception e ) { LOGGER . error ( e . get Message ( ) , e ) ; throw task Exc ; } }
boolean is Disjoint ( Type Declaration td ) { if ( this instanceof Union Type ) { return BOOL ; } if ( this instanceof Class Or Interface && td instanceof Class Or Interface && equals ( td ) ) { return BOOL ; } if ( this instanceof Type Parameter && td instanceof Type Parameter && equals ( td ) ) { return BOOL ; } List < Type > sts = get Satisfied Types ( ) ; for ( int i = NUM , s = sts . size ( ) ; i < s ; i ++ ) { Type st = sts . get ( i ) ; if ( is Disjoint ( td , st ) ) { return BOOL ; } } Type et = get Extended Type ( ) ; if ( et != null ) { if ( is Disjoint ( td , et ) ) { return BOOL ; } } return BOOL ; }
public static void open Imdb For Person ( Context context , String name ) { if ( context == null || Text Utils . is Empty ( name ) ) { return ; } Intent intent = new Intent ( Intent . ACTION VIEW , Uri . parse ( String . format ( IMDB APP PERSON SEARCH URI , name ) ) ) ; intent . add Flags ( Intent . FLAG ACTIVITY CLEAR WHEN TASK RESET ) ; if ( ! Utils . try Start Activity ( context , intent ) ) { intent = new Intent ( Intent . ACTION VIEW , Uri . parse ( String . format ( IMDB PERSON SEARCH URL , name ) ) ) ; intent . add Flags ( Intent . FLAG ACTIVITY CLEAR WHEN TASK RESET ) ; context . start Activity ( intent ) ; } }
public static void wait For Bridge And UI Idle ( React Bridge Idle Signaler idle Signaler , final React Context react Context , long timeout Ms ) { Ui Thread Util . assert Not On Ui Thread ( ) ; long start Time = System Clock . uptime Millis ( ) ; wait Inner ( idle Signaler , timeout Ms ) ; long time To Wait = Math . max ( NUM , timeout Ms - ( System Clock . uptime Millis ( ) - start Time ) ) ; wait For Choreographer ( time To Wait ) ; wait For JS Idle ( react Context ) ; time To Wait = Math . max ( NUM , timeout Ms - ( System Clock . uptime Millis ( ) - start Time ) ) ; wait Inner ( idle Signaler , time To Wait ) ; time To Wait = Math . max ( NUM , timeout Ms - ( System Clock . uptime Millis ( ) - start Time ) ) ; wait For Choreographer ( time To Wait ) ; }
public static boolean check CG Created On Back End Array ( Volume volume ) { return ( volume != null && Null Column Value Getter . is Not Null Value ( volume . get Replication Group Instance ( ) ) ) ; }
public static Process execute ( Process Builder pb , Line Consumer consumer ) throws IO Exception { pb . redirect Error Stream ( BOOL ) ; Process process = pb . start ( ) ; process ( process , consumer ) ; return process ; }
private void emit Trigger If All Blocks Received ( File Metadata file Metadata , Map < Long , Block Metadata . File Block Metadata > received Blocks Metadata ) { String file Path = file Metadata . get File Path ( ) ; if ( received Blocks Metadata . size ( ) != file Metadata . get Number Of Blocks ( ) ) { file Metadata Map . put ( file Path , file Metadata ) ; } else { Set < Long > received Blocks = received Blocks Metadata . key Set ( ) ; boolean block Missing = BOOL ; if ( ! file Metadata . is Directory ( ) ) { for ( long block Id : file Metadata . get Block Ids ( ) ) { if ( ! received Blocks . contains ( block Id ) ) { block Missing = BOOL ; } } } if ( ! block Missing ) { long file Processing Time = System . current Time Millis ( ) - file Metadata . get Discover Time ( ) ; List < Stitch Block > output Blocks = construct Output Block Metadata List ( file Metadata ) ; Output File Metadata output File Metadata = new Output File Metadata ( file Metadata , output Blocks ) ; trigger . emit ( output File Metadata ) ; LOG . debug ( STRING , file Metadata . get File Path ( ) , file Processing Time ) ; file Metadata Map . remove ( file Path ) ; } } }
private static int find Esds Position ( Parsable Byte Array parent , int position , int size ) { int child Atom Position = parent . get Position ( ) ; while ( child Atom Position - position < size ) { parent . set Position ( child Atom Position ) ; int child Atom Size = parent . read Int ( ) ; Assertions . check Argument ( child Atom Size > NUM , STRING ) ; int child Type = parent . read Int ( ) ; if ( child Type == Atom . TYPE esds ) { return child Atom Position ; } child Atom Position += child Atom Size ; } return - NUM ; }
public boolean contains Any ( Taxon List taxon List ) { for ( int i = NUM ; i < taxon List . get Taxon Count ( ) ; i ++ ) { Taxon taxon = taxon List . get Taxon ( i ) ; if ( taxa . contains ( taxon ) ) { return BOOL ; } } return BOOL ; }
protected int draw Label Text ( Android Graphics underlying , int text Decoration , boolean rtl , boolean is Ticker Running , boolean ends With 3 Points , Codename One Text Paint native Font , int txt W , int text Space W , int shift Text , String text , int x , int y , int font Height , Bitmap text Cache ) { if ( ( ! is Ticker Running ) || rtl ) { if ( txt W > text Space W && text Space W > NUM ) { if ( rtl ) { if ( ( ! is Ticker Running ) && ends With 3 Points ) { String points = STRING ; int points W = impl . string Width ( native Font , points ) ; draw String ( underlying , native Font , points , shift Text + x , y , text Decoration , font Height , text Cache ) ; clip Rect ( points W + shift Text + x , y , text Space W - points W , font Height ) ; } x = x - txt W + text Space W ; } else if ( ends With 3 Points ) { String points = STRING ; int index = NUM ; int widest = impl . char Width ( native Font , STRING ) ; int points W = impl . string Width ( native Font , points ) ; while ( fast Char Width Check ( text , index , text Space W - points W , widest , native Font ) && index < text . length ( ) ) { index ++ ; } text = text . substring ( NUM , Math . min ( text . length ( ) , Math . max ( NUM , index - NUM ) ) ) + points ; txt W = impl . string Width ( native Font , text ) ; } } } draw String ( underlying , native Font , text , shift Text + x , y , text Decoration , font Height , text Cache ) ; return Math . min ( txt W , text Space W ) ; }
public void apply Interpolated Radii ( ) { Assert . is True ( map Objects != null ) ; Assert . is True ( map Objects . size ( ) > NUM ) ; Internal Map Object min = null , max = null ; for ( Internal Map Object map Object : map Objects ) { if ( min == null || map Object . get Value ( ) < min . get Value ( ) ) { min = map Object ; } if ( max == null || map Object . get Value ( ) > max . get Value ( ) ) { max = map Object ; } } for ( Internal Map Object map Object : map Objects ) { double factor = ( map Object . get Value ( ) - min . get Value ( ) ) / ( max . get Value ( ) - min . get Value ( ) ) ; int radius = Map Utils . lerp ( radius Low , radius High , factor ) ; map Object . set Radius ( radius ) ; } }
void add No Result Action ( No Result Action action ) { No Result Action [ ] actions = new No Result Action [ no Result Actions . length + NUM ] ; System . arraycopy ( no Result Actions , NUM , actions , NUM , no Result Actions . length ) ; actions [ no Result Actions . length ] = action ; no Result Actions = actions ; }
public void compile All Projects ( List < File > p Project Roots , Issue Acceptor issue Acceptor ) throws N4 JS Compile Exception { List < File > abs Project Roots = Headless Helper . to Absolute File List ( p Project Roots ) ; Array List < File > p Dir = Headless Helper . collect All Project Paths ( abs Project Roots ) ; compile Projects ( p Project Roots , p Dir , Collections . empty List ( ) , issue Acceptor ) ; }
@ Override public Template Druid Query update Outer Query ( Template Druid Query outer Query , Map < String , String > old Field Name To New Field Name Map ) { Map < String , Aggregation > old Name To New Aggregation Mapping = new Hash Map < > ( ) ; Set < Aggregation > updated Outer Aggs = update Query Aggs ( outer Query . get Aggregations ( ) , old Field Name To New Field Name Map , old Name To New Aggregation Mapping ) ; Set < Post Aggregation > update Outer Post Aggs = new Hash Set < > ( ) ; for ( Post Aggregation post Aggregation : outer Query . get Post Aggregations ( ) ) { update Outer Post Aggs . add ( replace Post Agg With Post Agg From Map ( post Aggregation , old Name To New Aggregation Mapping ) ) ; } return new Template Druid Query ( updated Outer Aggs , update Outer Post Aggs , outer Query . get Inner Query ( ) , outer Query . get Time Grain ( ) ) ; }
public Dimension preferred Layout Size ( Container target ) { synchronized ( target . get Tree Lock ( ) ) { Dimension dim = new Dimension ( NUM , NUM ) ; if ( ( chart != null ) && chart . is Visible ( ) ) { Dimension d = chart . get Preferred Size ( ) ; dim . width = d . width ; dim . height = d . height ; } if ( ( x Label != null ) && x Label . is Visible ( ) ) { Dimension d = x Label . get Preferred Size ( ) ; dim . width = Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } if ( ( y Label != null ) && y Label . is Visible ( ) ) { Dimension d = y Label . get Preferred Size ( ) ; dim . width += d . width + hgap ; dim . height = Math . max ( d . height , dim . height ) ; } if ( ( title != null ) && title . is Visible ( ) ) { Dimension d = title . get Preferred Size ( ) ; dim . width = Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } Insets insets = target . get Insets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } }
Resource Handle new Resource Handle ( K key , final Callable < ? extends R > loader , Elimination Stack < Resource Key < K > > stack ) { try { final Resource Key < K > resource Key = time To Idle Policy . is Present ( ) ? new Linked Resource Key < K > ( stack , Status . IN FLIGHT , key , time To Idle Policy . get ( ) . idle Queue ) : new Unlinked Resource Key < K > ( stack , Status . IN FLIGHT , key ) ; R resource = loader . call ( ) ; try { lifecycle . on Create ( resource Key . get Key ( ) , resource ) ; cache . put ( resource Key , resource ) ; } catch ( Exception e ) { lifecycle . on Removal ( resource Key . get Key ( ) , resource ) ; throw e ; } Resource Handle handle = new Resource Handle ( resource Key , resource ) ; resource Key . handle = handle ; return handle ; } catch ( Exception e ) { throw Throwables . propagate ( e . get Cause ( ) ) ; } }
public javax . sip . address . Tel URL create Tel URL ( String uri ) throws Parse Exception { if ( uri == null ) throw new Null Pointer Exception ( STRING ) ; String tel Url = null ; if ( uri . starts With ( STRING ) ) { tel Url = uri ; } else { tel Url = STRING + uri ; } try { String Msg Parser smp = new String Msg Parser ( ) ; Tel URL Impl timp = ( Tel URL Impl ) smp . parse Url ( tel Url ) ; return ( Tel URL ) timp ; } catch ( Parse Exception ex ) { throw new Parse Exception ( ex . get Message ( ) , NUM ) ; } }
public Kernel Logistic Regression Model ( Example Set example Set , List < Support Vector > support Vectors , Kernel kernel , double bias ) { super ( example Set , Example Set Utilities . Sets Compare Option . ALLOW SUPERSET , Example Set Utilities . Types Compare Option . ALLOW SAME PARENTS ) ; this . support Vectors = support Vectors ; if ( support Vectors == null || support Vectors . size ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } this . kernel = kernel ; this . bias = bias ; }
public boolean remove Update ( final Password password ) throws IO Exception , Servlet Exception { if ( ! singelton . can ( CFML Engine . CAN UPDATE , password ) ) throw new IO Exception ( STRING ) ; return remove Update ( ) ; }
public C Abstract Operator Panel ( ) { super ( new Border Layout ( ) ) ; final J Panel main Panel = new J Panel ( new Border Layout ( ) ) ; main Panel . set Border ( new Titled Border ( get Border Title ( ) ) ) ; final J Panel info Panel = new J Panel ( new Border Layout ( ) ) ; info Panel . set Border ( new Empty Border ( NUM , NUM , NUM , NUM ) ) ; m info Field . set Background ( info Panel . get Background ( ) ) ; m info Field . set Line Wrap ( BOOL ) ; m info Field . set Wrap Style Word ( BOOL ) ; m info Field . set Editable ( BOOL ) ; info Panel . add ( m info Field , Border Layout . CENTER ) ; main Panel . add ( info Panel , Border Layout . CENTER ) ; add ( main Panel , Border Layout . CENTER ) ; }
public static double logpdf ( double x , double mu , double sigma , double k ) { if ( x == Double . POSITIVE INFINITY || x == Double . NEGATIVE INFINITY ) { return Double . NEGATIVE INFINITY ; } x = ( x - mu ) / sigma ; if ( k > NUM || k < NUM ) { if ( k * x > NUM ) { return Double . NEGATIVE INFINITY ; } double t = Math . log ( NUM - k * x ) ; return t == Double . NEGATIVE INFINITY ? - Math . log ( sigma ) : t == Double . POSITIVE INFINITY ? Double . NEGATIVE INFINITY : ( NUM - k ) * t / k - Math . exp ( t / k ) - Math . log ( sigma ) ; } else { return - x - Math . exp ( - x ) - Math . log ( sigma ) ; } }
public static Format generate Format ( String codec ) { return s Supported Codexs . get ( codec . to Lower Case ( ) ) ; }
public Optional Int min By Int ( Int Unary Operator key Extractor ) { int [ ] result = collect ( null , null , null ) ; return result [ NUM ] == NUM ? Optional Int . of ( result [ NUM ] ) : Optional Int . empty ( ) ; }
public void test one Prefix ( ) { final B Tree btree ; { Index Metadata md = new Index Metadata ( UUID . random UUID ( ) ) ; md . set Tuple Serializer ( tuple Ser ) ; btree = B Tree . create ( new Simple Memory Raw Store ( ) , md ) ; } btree . insert ( STRING , STRING ) ; btree . insert ( STRING , STRING ) ; btree . insert ( STRING , STRING ) ; btree . insert ( STRING , STRING ) ; btree . insert ( STRING , STRING ) ; btree . insert ( STRING , STRING ) ; btree . dump ( Level . DEBUG , System . err ) ; { final I Tuple Iterator < String > itr = btree . range Iterator ( null , null , NUM , I Range Query . DEFAULT | I Range Query . CURSOR , new Prefix Filter < String > ( as Prefix Key ( STRING ) ) ) ; assert True ( itr . has Next ( ) ) ; Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( STRING ) , itr . next ( ) ) ; assert True ( itr . has Next ( ) ) ; Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( STRING ) , itr . next ( ) ) ; assert False ( itr . has Next ( ) ) ; } { final I Tuple Iterator < String > itr = btree . range Iterator ( null , null , NUM , I Range Query . DEFAULT | I Range Query . CURSOR , new Prefix Filter < String > ( as Prefix Key ( STRING ) ) ) ; assert True ( itr . has Next ( ) ) ; Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( STRING ) , itr . next ( ) ) ; assert True ( itr . has Next ( ) ) ; Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( STRING ) , itr . next ( ) ) ; assert False ( itr . has Next ( ) ) ; } { final I Tuple Iterator < String > itr = btree . range Iterator ( null , null , NUM , I Range Query . DEFAULT | I Range Query . CURSOR , new Prefix Filter < String > ( as Prefix Key ( STRING ) ) ) ; assert True ( itr . has Next ( ) ) ; Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( STRING ) , itr . next ( ) ) ; assert True ( itr . has Next ( ) ) ; Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( STRING ) , itr . next ( ) ) ; assert True ( itr . has Next ( ) ) ; Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( STRING ) , itr . next ( ) ) ; assert True ( itr . has Next ( ) ) ; Abstract Tuple Cursor Test Case . assert Equals ( new Test Tuple ( STRING ) , itr . next ( ) ) ; assert False ( itr . has Next ( ) ) ; } { final I Tuple Iterator < String > itr = btree . range Iterator ( null , null , NUM , I Range Query . DEFAULT | I Range Query . CURSOR , new Prefix Filter < String > ( as Prefix Key ( STRING ) ) ) ; assert False ( itr . has Next ( ) ) ; } }
protected static String print Stack Trace ( final Throwable t ) { final String Writer stack Trace Writer = new String Writer ( ) ; t . print Stack Trace ( new Print Writer ( stack Trace Writer ) ) ; return stack Trace Writer . to String ( ) ; }
protected static String [ ] parse Host Port Pair ( String host Port Pair ) throws SQL Exception { String [ ] split Values = new String [ NUM ] ; if ( String Utils . starts With Ignore Case And Ws ( host Port Pair , STRING ) ) { split Values [ HOST NAME INDEX ] = host Port Pair . trim ( ) ; split Values [ PORT NUMBER INDEX ] = null ; return split Values ; } int port Index = host Port Pair . index Of ( STRING ) ; String hostname = null ; if ( port Index != - NUM ) { if ( ( port Index + NUM ) < host Port Pair . length ( ) ) { String port As String = host Port Pair . substring ( port Index + NUM ) ; hostname = host Port Pair . substring ( NUM , port Index ) ; split Values [ HOST NAME INDEX ] = hostname ; split Values [ PORT NUMBER INDEX ] = port As String ; } else { throw SQL Error . create SQL Exception ( Messages . get String ( STRING ) , SQL Error . SQL STATE INVALID CONNECTION ATTRIBUTE , null ) ; } } else { split Values [ HOST NAME INDEX ] = host Port Pair ; split Values [ PORT NUMBER INDEX ] = null ; } return split Values ; }
public void on Child Thread Resume End ( ) { int thread Max = thread Count . get And Decrement ( ) ; if ( thread Max <= thread Max ) { wake ( ) ; } wake If Low Idle ( ) ; }
public static void register Local Time M Bean ( String container Name ) { M Bean Server m Bean Server = get M Bean Server ( container Name ) ; if ( m Bean Server == null ) return ; Local Time M Bean local Time M Bean = new Local Time ( ) ; Object Name obj Name = Local Time Constants . MBEAN NAME ; if ( ! m Bean Server . is Registered ( obj Name ) ) { try { m Bean Server . register M Bean ( local Time M Bean , obj Name ) ; } catch ( Instance Already Exists Exception e ) { } catch ( Not Compliant M Bean Exception e ) { if ( logger . is Loggable ( Level . WARNING ) ) { logger . log ( Level . SEVERE , failed Local Time M Bean Registration Message Prefix + container Name + STRING , e ) ; } } catch ( M Bean Registration Exception e ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , failed Local Time M Bean Registration Message Prefix + container Name + STRING , e ) ; } } if ( logger . is Loggable ( Level . CONFIG ) ) { logger . config ( successful Transport M Bean Registration Message + container Name + STRING ) ; } } }
final public static int insert Table ( V sets , Class < ? extends Bean > t ) { Table mapping = ( Table ) t . get Annotation ( Table . class ) ; if ( mapping == null ) { if ( log . is Error Enabled ( ) ) log . error ( STRING + t + STRING ) ; return - NUM ; } if ( ! X . is Empty ( mapping . name ( ) ) ) { return insert Table ( mapping . name ( ) , sets ) ; } return - NUM ; }
public void stop Auto Cycle ( ) { if ( m Cycle Task != null ) { m Cycle Task . cancel ( ) ; } if ( m Cycle Timer != null ) { m Cycle Timer . cancel ( ) ; } if ( m Resuming Timer != null ) { m Resuming Timer . cancel ( ) ; } if ( m Resuming Task != null ) { m Resuming Task . cancel ( ) ; } m Auto Cycle = BOOL ; m Cycling = BOOL ; }
public void remove Rtcp Listener ( Rtcp Event Listener listener ) { listeners . remove Element ( listener ) ; }
public static synchronized void add From Properties ( Input Stream props Stream ) throws Exception { Properties exp Props = new Properties ( ) ; exp Props . load ( props Stream ) ; props Stream . close ( ) ; props Stream = null ; add From Properties ( exp Props ) ; }
public void clear ( Absolute Table Identifier absolute Table Identifier ) { table Lock Map . remove ( absolute Table Identifier ) ; table Segment Map . remove ( absolute Table Identifier ) ; }
private static Set < Annotation Mirror > find All Supers ( Annotation Mirror anno , Map < Annotation Mirror , Set < Annotation Mirror > > supertypes , Map < Annotation Mirror , Set < Annotation Mirror > > all Supers So Far ) { Set < Annotation Mirror > supers = Annotation Utils . create Annotation Set ( ) ; for ( Annotation Mirror super Anno : supertypes . get ( anno ) ) { supers . add ( super Anno ) ; supers . add All ( find All Supers ( super Anno , supertypes , all Supers So Far ) ) ; } all Supers So Far . put ( anno , Collections . unmodifiable Set ( supers ) ) ; return supers ; }
public static void complete Background Tasks ( long timeout Millis ) { boolean fifo Empty = BOOL ; boolean async Threads Completed = BOOL ; long abs Timeout = System . current Time Millis ( ) + timeout Millis ; while ( System . current Time Millis ( ) < abs Timeout ) { synchronized ( fifo ) { fifo Empty = fifo . size ( ) == NUM ; } synchronized ( J Google Analytics Tracker . class ) { async Threads Completed = async Threads Running == NUM ; } if ( fifo Empty && async Threads Completed ) break ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { break ; } } }
void remove phi ( Method m ) { Deque < Block > code = dfs ( m . entry . to ) ; Set Map < Block , Edge > pred = preds ( code ) ; Map < Integer , Integer > locals = new Tree Map < Integer , Integer > ( ) ; Map < Block , Deque < Expr > > exprs = new Tree Map < Block , Deque < Expr > > ( ) ; Conflict Graph conflicts = new Conflict Graph ( ) ; print Method ( m , STRING ) ; add Trace Attr ( m ) ; restused : if ( m . needs Arguments ( ) || m . needs Rest ( ) ) { int rest = m . get Params ( ) . length ; for ( Expr e : m . entry . to ) if ( e . op == OP arg && e . imm [ NUM ] == rest ) break restused ; m . flags &= ~ ( METHOD Arguments | METHOD Needrest ) ; m . flags |= METHOD Ignore Rest ; verbose Status ( STRING + m . get Name ( ) ) ; } int max local = m . get Params ( ) . length - NUM ; sched greedy ( m , code , locals , pred , exprs , conflicts ) ; alloc locals ( code , locals , conflicts , m . fixed Locals ) ; Set < Edge > splits = new Tree Set < Edge > ( ) ; for ( Block b : code ) { for ( Expr e : b ) { if ( e . op != OP phi ) break ; if ( ! locals . contains Key ( e . id ) ) continue ; add Trace Attr ( e ) ; int lhs = locals . get ( e . id ) ; for ( int i = e . args . length - NUM ; i >= NUM ; i -- ) { trace Entry ( STRING ) ; add Trace Attr ( STRING , i ) ; add Trace Attr ( e . args [ i ] ) ; int rhs = locals . get ( e . args [ i ] . id ) ; if ( lhs != rhs ) { Edge p = e . pred [ i ] ; if ( ! splits . contains ( p ) ) { split ( p , m , pred ) ; splits . add ( p = e . pred [ i ] ) ; } trace Entry ( STRING ) ; add Trace Attr ( STRING , lhs ) ; add Trace Attr ( STRING , rhs ) ; Expr get = getlocal ( m , rhs ) ; prepend ( p , get ) ; append ( p , setlocal ( m , lhs , get ) ) ; } } } b . exprs = exprs . get ( b ) ; for ( Expr e : b . exprs ) { int loc = max local ; if ( e . op == OP getlocal || e . op == OP setlocal ) { loc = e . imm [ NUM ] = locals . get ( e . imm [ NUM ] ) ; } else if ( e . op == OP hasnext 2 ) { int loc 0 = locals . get ( e . locals [ NUM ] . id ) ; int loc 1 = locals . get ( e . locals [ NUM ] . id ) ; e . imm = new int [ ] { loc 0 , loc 1 } ; loc = loc 0 > loc 1 ? loc 0 : loc 1 ; } if ( loc > max local ) max local = loc ; } } m . local count = max local + NUM ; cfgopt ( m ) ; print Method ( m , STRING ) ; }
private Connection open Connection ( boolean autocommit ) throws SQL Exception { Connection conn = data Src != null ? data Src . get Connection ( ) : Driver Manager . get Connection ( conn Url , user , passwd ) ; if ( test Mode ) opened . increment ( ) ; conn . set Auto Commit ( autocommit ) ; return conn ; }
public void mouse Pressed ( Mouse Event e ) { if ( Swing Utilities 2 . should Ignore ( e , tree ) ) { return ; } if ( is Editing ( tree ) && tree . get Invokes Stop Cell Editing ( ) && ! stop Editing ( tree ) ) { return ; } complete Editing ( ) ; pressed Path = get Closest Path For Location ( tree , e . get X ( ) , e . get Y ( ) ) ; if ( tree . get Drag Enabled ( ) ) { mouse Pressed DND ( e ) ; } else { Swing Utilities 2 . adjust Focus ( tree ) ; handle Selection ( e ) ; } }
public Object apply ( String source , int line No , int column No , Object func Body , Vector names Vec , Vector args Vec ) throws BSF Exception { if ( names Vec . size ( ) != args Vec . size ( ) ) throw new BSF Exception ( STRING ) ; if ( ! ( func Body instanceof String ) ) throw new BSF Exception ( STRING ) ; String [ ] names = new String [ names Vec . size ( ) ] ; names Vec . copy Into ( names ) ; Object [ ] args = new Object [ args Vec . size ( ) ] ; args Vec . copy Into ( args ) ; try { if ( ! installed Apply Method ) { interpreter . eval ( bsf Apply Method ) ; installed Apply Method = BOOL ; } bsh . This global = ( bsh . This ) interpreter . get ( STRING ) ; Object value = global . invoke Method ( STRING , new Object [ ] { names , args , ( String ) func Body } ) ; return Primitive . unwrap ( value ) ; } catch ( Interpreter Error e ) { throw new BSF Exception ( STRING + e + source Info ( source , line No , column No ) ) ; } catch ( Target Error e2 ) { throw new BSF Exception ( STRING + e2 . get Target ( ) + source Info ( source , line No , column No ) ) ; } catch ( Eval Error e3 ) { throw new BSF Exception ( STRING + e3 + source Info ( source , line No , column No ) ) ; } }
public Set key Set ( ) { if ( key Set == null ) key Set = new Synchronized Set ( new Key Set ( ) , this ) ; return key Set ; }
public void print Member Report ( Print Writer out , int member , Set < Integer > cluster ) throws Ade Exception { out . printf ( STRING , member Str ( member ) ) ; final List Sorted By Key < Double , String > list = new List Sorted By Key < Double , String > ( ) ; list . set Value Natural Order ( ) ; for ( int i : cluster ) { double info ; info = m Co Occurrences And Mi Matrix . get ( member , i ) ; list . add ( info , member Str ( i ) ) ; } list . invert Key Ordering ( ) ; out . printf ( STRING ) ; for ( int i = NUM ; i < list . size ( ) ; ++ i ) { out . printf ( STRING , list . get Key ( i ) , list . get Value ( i ) ) ; } out . println ( ) ; list . clear ( ) ; for ( int i = NUM ; i < m Co Occurrences And Mi Matrix . get Row Num ( ) ; ++ i ) { if ( cluster . contains ( i ) ) { continue ; } double info ; info = m Co Occurrences And Mi Matrix . get ( member , i ) ; list . add ( info , member Str ( i ) ) ; } out . printf ( STRING ) ; for ( int i = NUM ; i < Math . min ( NUM , list . size ( ) ) ; ++ i ) { out . printf ( STRING , list . get Key ( i ) , list . get Value ( i ) ) ; } out . println ( ) ; }
public void form List Downloading Complete ( Hash Map < String , Form Details > result ) { dismiss Dialog ( PROGRESS DIALOG ) ; m Download Form List Task . set Downloader Listener ( null ) ; m Download Form List Task = null ; if ( result == null ) { Log . e ( t , STRING ) ; create Alert Dialog ( get String ( R . string . load remote form error ) , get String ( R . string . error occured ) , EXIT ) ; return ; } if ( result . contains Key ( Download Form List Task . DL AUTH REQUIRED ) ) { show Dialog ( AUTH DIALOG ) ; } else if ( result . contains Key ( Download Form List Task . DL ERROR MSG ) ) { String dialog Message = get String ( R . string . list failed with error , result . get ( Download Form List Task . DL ERROR MSG ) . error Str ) ; String dialog Title = get String ( R . string . load remote form error ) ; create Alert Dialog ( dialog Title , dialog Message , DO NOT EXIT ) ; } else { m Form Names And UR Ls = result ; m Form List . clear ( ) ; Array List < String > ids = new Array List < String > ( m Form Names And UR Ls . key Set ( ) ) ; for ( int i = NUM ; i < result . size ( ) ; i ++ ) { String form Details Key = ids . get ( i ) ; Form Details details = m Form Names And UR Ls . get ( form Details Key ) ; Hash Map < String , String > item = new Hash Map < String , String > ( ) ; item . put ( FORMNAME , details . form Name ) ; item . put ( FORMID DISPLAY , ( ( details . form Version == null ) ? STRING : ( get String ( R . string . version ) + STRING + details . form Version + STRING ) ) + STRING + details . form ID ) ; item . put ( FORMDETAIL KEY , form Details Key ) ; item . put ( FORM ID KEY , details . form ID ) ; item . put ( FORM VERSION KEY , details . form Version ) ; if ( m Form List . size ( ) == NUM ) { m Form List . add ( item ) ; } else { int j ; for ( j = NUM ; j < m Form List . size ( ) ; j ++ ) { Hash Map < String , String > compare Me = m Form List . get ( j ) ; String name = compare Me . get ( FORMNAME ) ; if ( name . compare To ( m Form Names And UR Ls . get ( ids . get ( i ) ) . form Name ) > NUM ) { break ; } } m Form List . add ( j , item ) ; } } select Superseded Forms ( ) ; m Form List Adapter . notify Data Set Changed ( ) ; m Download Button . set Enabled ( ! ( selected Item Count ( ) == NUM ) ) ; } }
private static int [ ] mult With Monomial ( int [ ] a , int k ) { int d = compute Degree ( a ) ; if ( d == - NUM ) { return new int [ NUM ] ; } int [ ] result = new int [ d + k + NUM ] ; System . arraycopy ( a , NUM , result , k , d + NUM ) ; return result ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Min Inst Num ( ) + STRING + default Max Inst Num ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
private String extract Context ( String s , int position ) { String Builder sb = new String Builder ( ) ; int j = position - NUM ; char c = s . char At ( j ) ; while ( j > NUM && c != STRING && c != STRING ) { c = s . char At ( -- j ) ; } String ps = j > NUM ? s . substring ( j + NUM , position ) : s . substring ( NUM , position ) ; ps = convert ( ps ) ; sb . append ( STRING ) ; sb . append ( ps ) ; sb . append ( STRING ) ; sb . append ( lexicon . has Word ( ps ) ? NUM : NUM ) ; j = position + NUM ; c = s . char At ( j ) ; while ( j < s . length ( ) && c != STRING && c != STRING ) { c = s . char At ( j ++ ) ; } String ns = j < s . length ( ) ? s . substring ( position + NUM , j - NUM ) : s . substring ( position + NUM ) ; ns = convert ( ns ) ; sb . append ( STRING ) ; sb . append ( ns ) ; sb . append ( STRING ) ; sb . append ( lexicon . has Word ( ns ) ? NUM : NUM ) ; sb . append ( STRING ) ; sb . append ( ps ) ; sb . append ( STRING ) ; sb . append ( ns ) ; return sb . to String ( ) ; }
public Crl Client Online ( Certificate [ ] chain ) { for ( int i = NUM ; i < chain . length ; i ++ ) { X509 Certificate cert = ( X509 Certificate ) chain [ i ] ; LOGGER . info ( STRING + cert . get Subject DN ( ) ) ; try { add Url ( Certificate Util . get CRLURL ( cert ) ) ; } catch ( Certificate Parsing Exception e ) { LOGGER . info ( STRING ) ; } } }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
private void handle Local Associated Other ( ) { for ( Array List < Register Spec > specs : local Variables . values ( ) ) { int rop Reg = param Range End ; boolean done = BOOL ; do { int max Category = NUM ; int sz = specs . size ( ) ; for ( int i = NUM ; i < sz ; i ++ ) { Register Spec ssa Spec = specs . get ( i ) ; int category = ssa Spec . get Category ( ) ; if ( ! ssa Regs Mapped . get ( ssa Spec . get Reg ( ) ) && category > max Category ) { max Category = category ; } } rop Reg = find Rop Reg For Local ( rop Reg , max Category ) ; if ( can Map Regs ( specs , rop Reg ) ) { done = try Map Regs ( specs , rop Reg , max Category , BOOL ) ; } rop Reg ++ ; } while ( ! done ) ; } }
private void load Data From Service ( ) { List < Invocation Sequence Data > invoc Data ; if ( ! auto Update ) { if ( template . get Method Ident ( ) != Id Definition . ID NOT USED ) { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , template . get Method Ident ( ) , limit , from Date , to Date , result Comparator ) ; } else { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , limit , from Date , to Date , result Comparator ) ; } } else { if ( template . get Method Ident ( ) != Id Definition . ID NOT USED ) { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , template . get Method Ident ( ) , limit , result Comparator ) ; } else { invoc Data = data Access Service . get Invocation Sequence Overview ( template . get Platform Ident ( ) , limit , result Comparator ) ; } } invocation Sequence Data . clear ( ) ; if ( ! invoc Data . is Empty ( ) ) { invocation Sequence Data . add All ( invoc Data ) ; } }
@ Override public int compare ( final String string 1 , final String string 2 ) { String string 1 Copy = string 1 . to Lower Case ( ) ; String string 2 Copy = string 2 . to Lower Case ( ) ; int len 1 = string 1 . length ( ) ; int len 2 = string 2 . length ( ) ; String liczba 1 = STRING ; String liczba 2 = STRING ; for ( int i = NUM ; i < ( ( len 1 > len 2 ) ? len 1 : len 2 ) ; i ++ ) { if ( i == len 1 && len 2 > len 1 ) { return - NUM ; } if ( i == len 2 && len 1 > len 2 ) { return NUM ; } Character c1 = string 1 Copy . char At ( i ) ; Character c2 = string 2 Copy . char At ( i ) ; if ( is Digit ( c1 ) && is Digit ( c2 ) ) { liczba 1 += c1 ; liczba 2 += c2 ; } else if ( is Digit ( c1 ) && liczba 1 . length ( ) > NUM ) { return NUM ; } else if ( is Digit ( c2 ) && liczba 1 . length ( ) > NUM ) { return - NUM ; } else { if ( ! liczba 1 . equals ( liczba 2 ) ) { return liczba 1 . compare To ( liczba 2 ) ; } liczba 1 = STRING ; liczba 2 = STRING ; if ( ! c1 . equals ( c2 ) ) { return c1 . compare To ( c2 ) ; } } } return string 1 Copy . compare To ( string 2 Copy ) ; }
private static void load Package Data ( Context context ) { if ( context != null ) { try { Package Manager package Manager = context . get Package Manager ( ) ; Package Info package Info = package Manager . get Package Info ( context . get Package Name ( ) , NUM ) ; Crash Constants . APP PACKAGE = package Info . package Name ; Crash Constants . APP VERSION = STRING + package Info . version Code ; Crash Constants . APP VERSION NAME = package Info . version Name ; int build Number = load Build Number ( context , package Manager ) ; if ( ( build Number != NUM ) && ( build Number > package Info . version Code ) ) { Crash Constants . APP VERSION = STRING + build Number ; } } catch ( Package Manager . Name Not Found Exception e ) { L . e ( STRING ) ; e . print Stack Trace ( ) ; } } }
public static Left Indexed Power Law Multi Segment Bipartite Graph build Random Multi Segment Bipartite Graph ( int max Num Segments , int max Num Edges Per Segment , int left Size , int right Size , double edge Probability , Random random ) { Left Indexed Power Law Multi Segment Bipartite Graph multi Segment Left Indexed Power Law Bipartite Graph = new Left Indexed Power Law Multi Segment Bipartite Graph ( max Num Segments , max Num Edges Per Segment , left Size / NUM , ( int ) ( right Size * edge Probability / NUM ) , NUM , right Size / NUM , new Identity Edge Type Mask ( ) , new Null Stats Receiver ( ) ) ; for ( int i = NUM ; i < left Size ; i ++ ) { for ( int j = NUM ; j < right Size ; j ++ ) { if ( random . next Double ( ) < edge Probability ) { multi Segment Left Indexed Power Law Bipartite Graph . add Edge ( i , j , ( byte ) NUM ) ; } } } return multi Segment Left Indexed Power Law Bipartite Graph ; }
private void forward Post ( Http URL Connection connection , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { connection . set Do Output ( BOOL ) ; connection . set Do Input ( BOOL ) ; connection . set Use Caches ( BOOL ) ; connection . set Request Method ( STRING ) ; connection . set Request Property ( STRING , request . get Content Type ( ) ) ; handle Http Request ( connection , request , response ) ; handle Http Response ( connection , request , response ) ; }
private String title Of ( Search Result Mediator rp ) { int total = rp . total Results ( ) ; String title = rp . get Title ( ) ; if ( title . length ( ) > NUM ) { title = title . substring ( NUM , NUM ) + STRING ; } return title + STRING + total + STRING + I18 n . tr ( STRING ) + STRING ; }
public Array List < Entry > process ( File input File Or Dir , File output Root ) throws Exception { if ( ! input File Or Dir . exists ( ) ) throw new Illegal Argument Exception ( STRING + input File Or Dir . get Absolute Path ( ) ) ; if ( input File Or Dir . is File ( ) ) return process ( new File [ ] { input File Or Dir } , output Root ) ; else return process ( input File Or Dir . list Files ( ) , output Root ) ; }
public static File locate Replicator Conf Dir ( ) { if ( replicator Conf Dir == null ) { String replicator Conf = System . get Property ( CONF DIR ) ; if ( replicator Conf == null ) replicator Conf Dir = new File ( locate Replicator Home Dir ( ) , STRING ) ; else replicator Conf Dir = new File ( replicator Conf ) ; if ( ! replicator Conf Dir . is Directory ( ) ) { throw new Server Runtime Exception ( STRING + replicator Conf Dir ) ; } } return replicator Conf Dir ; }
public static byte [ ] as Byte Array ( final List < Byte > l ) { final byte [ ] a = new byte [ l . size ( ) ] ; for ( int i = NUM ; i < a . length ; i ++ ) { a [ i ] = l . get ( i ) ; } return a ; }
public C Node Menu Builder ( final J Criterium Tree Node node , final C Criterium Tree ctree , final List < I Criterium Creator > criteria ) { m criterium Node = node ; final C Criterium Tree Node clicked Criterium = C Criterium Functions . find Node ( ctree . get Root ( ) , node . get Criterium ( ) ) ; m append And = new J Menu Item ( new C Append And Operator Action ( ctree , clicked Criterium ) ) ; m append Or = new J Menu Item ( new C Append Or Operator Action ( ctree , clicked Criterium ) ) ; m append Not = new J Menu Item ( new C Append Not Operator Action ( ctree , clicked Criterium ) ) ; m popup . add ( m append And ) ; m popup . add ( m append Or ) ; m popup . add ( m append Not ) ; m popup . add ( new J Separator ( ) ) ; m insert And = new J Menu Item ( new C Insert And Operator Action ( ctree , clicked Criterium ) ) ; m insert Or = new J Menu Item ( new C Insert Or Operator Action ( ctree , clicked Criterium ) ) ; m insert Not = new J Menu Item ( new C Insert Not Operator Action ( ctree , clicked Criterium ) ) ; m popup . add ( m insert And ) ; m popup . add ( m insert Or ) ; m popup . add ( m insert Not ) ; m popup . add ( new J Separator ( ) ) ; m condition Submenu = new J Menu ( STRING ) ; for ( final I Criterium Creator condition : criteria ) { m condition Submenu . add ( new J Menu Item ( new C Add Condition Action ( ctree , clicked Criterium , condition ) ) ) ; } m popup . add ( m condition Submenu ) ; m popup . add ( new J Separator ( ) ) ; m remove = new J Menu Item ( new C Remove Action ( ctree , clicked Criterium ) ) ; m popup . add ( m remove ) ; m popup . add ( new J Separator ( ) ) ; m remove All = new J Menu Item ( new C Remove All Action ( ctree ) ) ; m popup . add ( m remove All ) ; }
public void test Store Failure ( ) throws Exception { delegate . set Should Fail ( BOOL ) ; init Store ( NUM ) ; Set < Integer > exp ; try { exp = run Put Get Remove Multithreaded ( NUM , NUM ) ; U . sleep ( FLUSH FREQUENCY ) ; info ( STRING + store . get Write Behind Error Retry Count ( ) + STRING ) ; delegate . set Should Fail ( BOOL ) ; U . sleep ( NUM ) ; } finally { shutdown Store ( ) ; } Map < Integer , String > map = delegate . get Map ( ) ; Collection < Integer > extra = new Hash Set < > ( map . key Set ( ) ) ; extra . remove All ( exp ) ; assert True ( STRING + extra , extra . is Empty ( ) ) ; Collection < Integer > missing = new Hash Set < > ( exp ) ; missing . remove All ( map . key Set ( ) ) ; assert True ( STRING + missing , missing . is Empty ( ) ) ; for ( Integer key : exp ) assert Equals ( STRING + key , STRING + key , map . get ( key ) ) ; }
private List < String > list To Lower Case ( List < String > l ) { List < String > result = new Array List < String > ( ) ; for ( String s : l ) { result . add ( s . to Lower Case ( ) ) ; } return result ; }
private Snmp Message make Response Message ( Snmp Message req Msg ) { Snmp Message resp Msg = null ; Snmp Pdu Packet req Pdu ; Object user Data = null ; try { req Pdu = ( Snmp Pdu Packet ) pdu Factory . decode Snmp Pdu ( req Msg ) ; if ( req Pdu != null && user Data Factory != null ) user Data = user Data Factory . allocate User Data ( req Pdu ) ; } catch ( Snmp Status Exception x ) { req Pdu = null ; Snmp Adaptor Server snmp Server = ( Snmp Adaptor Server ) adaptor Server ; snmp Server . inc Snmp In ASN Parse Errs ( NUM ) ; if ( x . get Status ( ) == Snmp Definitions . snmp Wrong Snmp Version ) snmp Server . inc Snmp In Bad Versions ( NUM ) ; if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING , x ) ; } } Snmp Pdu Packet resp Pdu = null ; if ( req Pdu != null ) { resp Pdu = make Response Pdu ( req Pdu , user Data ) ; try { if ( user Data Factory != null ) user Data Factory . release User Data ( user Data , resp Pdu ) ; } catch ( Snmp Status Exception x ) { resp Pdu = null ; } } if ( resp Pdu != null ) { try { resp Msg = ( Snmp Message ) pdu Factory . encode Snmp Pdu ( resp Pdu , packet . get Data ( ) . length ) ; } catch ( Snmp Status Exception x ) { resp Msg = null ; if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING , x ) ; } } catch ( Snmp Too Big Exception x ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING ) ; } try { if ( packet . get Data ( ) . length <= NUM ) throw x ; int pos = x . get Var Bind Count ( ) ; if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING + pos ) ; } int old ; while ( BOOL ) { try { resp Pdu = reduce Response Pdu ( req Pdu , resp Pdu , pos ) ; resp Msg = ( Snmp Message ) pdu Factory . encode Snmp Pdu ( resp Pdu , packet . get Data ( ) . length - NUM ) ; break ; } catch ( Snmp Too Big Exception xx ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING ) ; } old = pos ; pos = xx . get Var Bind Count ( ) ; if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING + pos ) ; } if ( pos == old ) { throw xx ; } } } } catch ( Snmp Status Exception xx ) { resp Msg = null ; if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING , xx ) ; } } catch ( Snmp Too Big Exception xx ) { try { resp Pdu = new Too Big Pdu ( req Pdu ) ; resp Msg = ( Snmp Message ) pdu Factory . encode Snmp Pdu ( resp Pdu , packet . get Data ( ) . length ) ; } catch ( Snmp Too Big Exception xxx ) { resp Msg = null ; if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING ) ; } adaptor . inc Snmp Silent Drops ( NUM ) ; } catch ( Exception xxx ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING , xxx ) ; } resp Msg = null ; } } catch ( Exception xx ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINEST ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINEST , dbg Tag , STRING , STRING , xx ) ; } resp Msg = null ; } } } return resp Msg ; }
public void commit Random ( final Randomizer rand ) { rand . set Pdf ( pdf ) ; if ( pdf == Prob Distribution . NULL ) { return ; } double param 1 = Utils . double Parsable ( tf Param 1 ) ; if ( tf Param 1 . is Enabled ( ) && ! Double . is Na N ( param 1 ) ) { rand . set Param 1 Consistent ( pdf . get Param 1 Name ( ) , param 1 ) ; } double param 2 = Utils . double Parsable ( tf Param 2 ) ; if ( tf Param 2 . is Enabled ( ) && ! Double . is Na N ( param 2 ) ) { rand . set Param 2 Consistent ( pdf . get Param 2 Name ( ) , param 2 ) ; } if ( ! ts Clipping . is Null ( ) ) { rand . set Clipping ( ts Clipping . is Selected ( ) ) ; if ( ts Clipping . is Selected ( ) ) { double upper Bound = Utils . double Parsable ( tf Up Bound ) ; if ( ! Double . is Na N ( upper Bound ) ) { rand . set Upper Bound ( upper Bound ) ; } double lower Bound = Utils . double Parsable ( tf Low Bound ) ; if ( ! Double . is Na N ( lower Bound ) ) { rand . set Lower Bound ( lower Bound ) ; } } } }
private static void d ucummxx ( double [ ] a , double [ ] agg , double [ ] c , int m , int n , double init , Builtin builtin , int rl , int ru ) { double [ ] cmxx = ( agg != null ) ? agg : new double [ n ] ; if ( agg == null ) Arrays . fill ( cmxx , init ) ; for ( int i = rl , aix = rl * n ; i < ru ; i ++ , aix += n ) { builtin Agg ( a , cmxx , aix , n , builtin ) ; System . arraycopy ( cmxx , NUM , c , aix , n ) ; } }
public static List < Module Spec > expand Spec Wildcards ( List < File > dirs , List < Module Spec > modules , Backend for Backend ) { List < Module Spec > result = new Array List < Module Spec > ( modules . size ( ) ) ; for ( Module Spec spec : modules ) { List < String > names = new Array List < String > ( ) ; expand Wildcard ( names , dirs , spec . get Name ( ) , for Backend ) ; for ( String name : names ) { result . add ( new Module Spec ( name , spec . get Version ( ) ) ) ; } } return result ; }
private void $$$setup UI$$$ ( ) { my Content Panel = new J Panel ( ) ; my Content Panel . set Layout ( new Grid Layout Manager ( NUM , NUM , new Insets ( NUM , NUM , NUM , NUM ) , - NUM , - NUM ) ) ; final J Panel panel 1 = new J Panel ( ) ; panel 1 . set Layout ( new Grid Layout Manager ( NUM , NUM , new Insets ( NUM , NUM , NUM , NUM ) , - NUM , - NUM ) ) ; my Content Panel . add ( panel 1 , new Grid Constraints ( NUM , NUM , NUM , NUM , Grid Constraints . ANCHOR CENTER , Grid Constraints . FILL BOTH , Grid Constraints . SIZEPOLICY CAN SHRINK | Grid Constraints . SIZEPOLICY CAN GROW , Grid Constraints . SIZEPOLICY CAN SHRINK | Grid Constraints . SIZEPOLICY CAN GROW , null , null , null , NUM , BOOL ) ) ; my Accept Yours Button = new J Button ( ) ; my Accept Yours Button . set Enabled ( BOOL ) ; my Accept Yours Button . set Text ( STRING ) ; my Accept Yours Button . set Mnemonic ( STRING ) ; my Accept Yours Button . set Displayed Mnemonic Index ( NUM ) ; panel 1 . add ( my Accept Yours Button , new Grid Constraints ( NUM , NUM , NUM , NUM , Grid Constraints . ANCHOR CENTER , Grid Constraints . FILL HORIZONTAL , Grid Constraints . SIZEPOLICY CAN SHRINK | Grid Constraints . SIZEPOLICY CAN GROW , Grid Constraints . SIZEPOLICY FIXED , null , null , null , NUM , BOOL ) ) ; final Spacer spacer 1 = new Spacer ( ) ; panel 1 . add ( spacer 1 , new Grid Constraints ( NUM , NUM , NUM , NUM , Grid Constraints . ANCHOR CENTER , Grid Constraints . FILL VERTICAL , NUM , Grid Constraints . SIZEPOLICY WANT GROW , null , null , null , NUM , BOOL ) ) ; my Accept Theirs Button = new J Button ( ) ; my Accept Theirs Button . set Enabled ( BOOL ) ; my Accept Theirs Button . set Text ( STRING ) ; my Accept Theirs Button . set Mnemonic ( STRING ) ; my Accept Theirs Button . set Displayed Mnemonic Index ( NUM ) ; panel 1 . add ( my Accept Theirs Button , new Grid Constraints ( NUM , NUM , NUM , NUM , Grid Constraints . ANCHOR CENTER , Grid Constraints . FILL HORIZONTAL , Grid Constraints . SIZEPOLICY CAN SHRINK | Grid Constraints . SIZEPOLICY CAN GROW , Grid Constraints . SIZEPOLICY FIXED , null , null , null , NUM , BOOL ) ) ; my Merge Button = new J Button ( ) ; my Merge Button . set Enabled ( BOOL ) ; my Merge Button . set Text ( STRING ) ; my Merge Button . set Mnemonic ( STRING ) ; my Merge Button . set Displayed Mnemonic Index ( NUM ) ; panel 1 . add ( my Merge Button , new Grid Constraints ( NUM , NUM , NUM , NUM , Grid Constraints . ANCHOR CENTER , Grid Constraints . FILL HORIZONTAL , Grid Constraints . SIZEPOLICY CAN SHRINK | Grid Constraints . SIZEPOLICY CAN GROW , Grid Constraints . SIZEPOLICY FIXED , null , null , null , NUM , BOOL ) ) ; final JB Scroll Pane jB Scroll Pane 1 = new JB Scroll Pane ( ) ; my Content Panel . add ( jB Scroll Pane 1 , new Grid Constraints ( NUM , NUM , NUM , NUM , Grid Constraints . ANCHOR CENTER , Grid Constraints . FILL BOTH , Grid Constraints . SIZEPOLICY CAN SHRINK | Grid Constraints . SIZEPOLICY WANT GROW , Grid Constraints . SIZEPOLICY CAN SHRINK | Grid Constraints . SIZEPOLICY WANT GROW , null , null , null , NUM , BOOL ) ) ; my Items Table = new JB Table ( ) ; my Items Table . put Client Property ( STRING , Boolean . FALSE ) ; jB Scroll Pane 1 . set Viewport View ( my Items Table ) ; }
public void test Run All Activities ( ) throws Exception { final Set < Process Error > err Set = new Linked Hash Set < Process Error > ( ) ; for ( Resolve Info app : get Launcher Activities ( m Package Manager ) ) { final Collection < Process Error > err Procs = run One Activity ( app ) ; if ( err Procs != null ) { err Set . add All ( err Procs ) ; } } if ( ! err Set . is Empty ( ) ) { fail ( String . format ( STRING , err Set . size ( ) , report Wrapped List Contents ( err Set ) ) ) ; } }

public Executor with Checkpoint File ( File checkpoint File ) { this . checkpoint File = checkpoint File ; return this ; }
@ Override public Connection Pool Data Source create Connection Pool Data Source ( Properties properties ) throws SQL Exception { Properties properties Copy = new Properties ( ) ; if ( properties != null ) { properties Copy . put All ( properties ) ; } reject Unsupported Options ( properties Copy ) ; reject Pooling Options ( properties Copy ) ; Jdbc Data Source data Source = new Jdbc Data Source ( ) ; setup H 2 Data Source ( data Source , properties Copy ) ; return data Source ; }
public static double to Radians ( double x ) { if ( Double . is Infinite ( x ) || x == NUM ) { return x ; } final double facta = NUM ; final double factb = NUM ; double xa = double High Part ( x ) ; double xb = x - xa ; double result = xb * factb + xb * facta + xa * factb + xa * facta ; if ( result == NUM ) { result *= x ; } return result ; }
private Map < String , Big Decimal > init Reasons Map ( final Map < String , Big Decimal > tax Sum ) { tax Sum . put ( DEMANDRSN CODE GENERAL TAX , Big Decimal . ZERO ) ; tax Sum . put ( DEMANDRSN CODE LIBRARY CESS , Big Decimal . ZERO ) ; tax Sum . put ( DEMANDRSN CODE EDUCATIONAL CESS , Big Decimal . ZERO ) ; tax Sum . put ( DEMANDRSN CODE UNAUTHORIZED PENALTY , Big Decimal . ZERO ) ; tax Sum . put ( DEMANDRSN CODE PENALTY FINES , Big Decimal . ZERO ) ; tax Sum . put ( DEMANDRSN CODE CHQ BOUNCE PENALTY , Big Decimal . ZERO ) ; return tax Sum ; }
protected void add ( Instance inst ) { for ( int i = NUM ; i < m Specifiers . size ( ) ; i ++ ) { Instance specifier = m Specifiers . get ( i ) ; boolean found = BOOL ; for ( int m Dataset Key Column : m Dataset Key Columns ) { if ( inst . value ( m Dataset Key Column ) != specifier . value ( m Dataset Key Column ) ) { found = BOOL ; } } if ( found ) { return ; } } m Specifiers . add ( inst ) ; }
public Shaped Recipe shape ( final String ... shape ) { Validate . not Null ( shape , STRING ) ; Validate . is True ( shape . length > NUM && shape . length < NUM , STRING , shape . length ) ; for ( String row : shape ) { Validate . not Null ( row , STRING ) ; Validate . is True ( row . length ( ) > NUM && row . length ( ) < NUM , STRING , row . length ( ) ) ; } this . rows = new String [ shape . length ] ; for ( int i = NUM ; i < shape . length ; i ++ ) { this . rows [ i ] = shape [ i ] ; } Hash Map < Character , Item Stack > new Ingredients = new Hash Map < Character , Item Stack > ( ) ; for ( String row : shape ) { for ( Character c : row . to Char Array ( ) ) { new Ingredients . put ( c , ingredients . get ( c ) ) ; } } this . ingredients = new Ingredients ; return this ; }
protected void write Non HTML Attributes ( Attribute Set attr ) throws IO Exception { String style = STRING ; String separator = STRING ; if ( in Font Tag ( ) && font Attributes . is Equal ( attr ) ) { return ; } boolean first = BOOL ; Color color = ( Color ) attr . get Attribute ( Style Constants . Foreground ) ; if ( color != null ) { style += STRING + css . style Constants Value To CSS Value ( ( Style Constants ) Style Constants . Foreground , color ) ; first = BOOL ; } Integer size = ( Integer ) attr . get Attribute ( Style Constants . Font Size ) ; if ( size != null ) { if ( ! first ) { style += separator ; } style += STRING + size . int Value ( ) + STRING ; first = BOOL ; } String family = ( String ) attr . get Attribute ( Style Constants . Font Family ) ; if ( family != null ) { if ( ! first ) { style += separator ; } style += STRING + family ; first = BOOL ; } if ( style . length ( ) > NUM ) { if ( font Mask != NUM ) { write End Mask ( font Mask ) ; font Mask = NUM ; } start Span Tag ( style ) ; font Attributes = attr ; } else if ( font Attributes != null ) { write End Mask ( font Mask ) ; font Mask = NUM ; end Span Tag ( ) ; } }
public Socket create Socket ( Inet Address address , int port , Inet Address my Address , int my Port ) throws IO Exception { if ( my Address != null ) { Socket sock = new Socket ( ) ; sock . bind ( new Inet Socket Address ( my Address , NUM ) ) ; try { sock . connect ( new Inet Socket Address ( address , port ) , NUM ) ; } catch ( Socket Timeout Exception e ) { throw new Connect Exception ( STRING + address + STRING + port ) ; } return sock ; } else { Socket sock = new Socket ( ) ; if ( my Port != NUM ) { sock . bind ( new Inet Socket Address ( port ) ) ; } try { sock . connect ( new Inet Socket Address ( address , port ) , NUM ) ; } catch ( Socket Timeout Exception e ) { throw new Connect Exception ( STRING + address + STRING + port ) ; } return sock ; } }
@ Override public boolean input ( Instance instance ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STRING ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = BOOL ; } Instances output Format = output Format Peek ( ) ; double [ ] vals = new double [ output Format . num Attributes ( ) ] ; boolean in Range = BOOL ; double last Val = Utils . missing Value ( ) ; int i , j ; for ( i = NUM , j = NUM ; j < output Format . num Attributes ( ) ; i ++ ) { if ( m Delta Cols . is In Range ( i ) && ( i != instance . class Index ( ) ) ) { if ( in Range ) { if ( Utils . is Missing Value ( last Val ) || instance . is Missing ( i ) ) { vals [ j ++ ] = Utils . missing Value ( ) ; } else { vals [ j ++ ] = instance . value ( i ) - last Val ; } } else { in Range = BOOL ; } last Val = instance . value ( i ) ; } else { vals [ j ++ ] = instance . value ( i ) ; } } Instance inst = null ; if ( instance instanceof Sparse Instance ) { inst = new Sparse Instance ( instance . weight ( ) , vals ) ; } else { inst = new Dense Instance ( instance . weight ( ) , vals ) ; } inst . set Dataset ( get Output Format ( ) ) ; copy Values ( inst , BOOL , instance . dataset ( ) , get Output Format ( ) ) ; inst . set Dataset ( get Output Format ( ) ) ; push ( inst ) ; return BOOL ; }
public void paint Circle ( Point 2 D pt 1 , Point 2 D pt 2 ) { if ( display Circle ) { if ( pt 1 != null && pt 2 != null ) { double radphi 1 = Proj Math . deg To Rad ( pt 1 . get Y ( ) ) ; double radlambda 0 = Proj Math . deg To Rad ( pt 1 . get X ( ) ) ; double radphi = Proj Math . deg To Rad ( pt 2 . get Y ( ) ) ; double radlambda = Proj Math . deg To Rad ( pt 2 . get X ( ) ) ; double d Rad = Great Circle . spherical Distance ( radphi 1 , radlambda 0 , radphi , radlambda ) ; double rad = Proj Math . rad To Deg ( d Rad ) ; OM Circle circle = new OM Circle ( pt 1 . get Y ( ) , pt 1 . get X ( ) , rad ) ; Projection proj = the Map . get Projection ( ) ; circle . generate ( proj ) ; distance List . add ( circle ) ; } } }
private Ok Http Client copy With Defaults ( ) { Ok Http Client result = new Ok Http Client ( this ) ; result . proxy = proxy ; result . proxy Selector = proxy Selector != null ? proxy Selector : Proxy Selector . get Default ( ) ; result . cookie Handler = cookie Handler != null ? cookie Handler : Cookie Handler . get Default ( ) ; result . response Cache = response Cache != null ? response Cache : Response Cache . get Default ( ) ; result . ssl Socket Factory = ssl Socket Factory != null ? ssl Socket Factory : Https URL Connection . get Default SSL Socket Factory ( ) ; result . hostname Verifier = hostname Verifier != null ? hostname Verifier : Ok Hostname Verifier . INSTANCE ; result . authenticator = authenticator != null ? authenticator : Http Authenticator . SYSTEM DEFAULT ; result . connection Pool = connection Pool != null ? connection Pool : Connection Pool . get Default ( ) ; result . follow Protocol Redirects = follow Protocol Redirects ; result . transports = transports != null ? transports : DEFAULT TRANSPORTS ; result . connect Timeout = connect Timeout ; result . read Timeout = read Timeout ; return result ; }
private Der Value read RFC 1421 Cert ( Input Stream in ) throws IO Exception { Der Value der = null ; String line = null ; Buffered Reader cert Buffered Reader = new Buffered Reader ( new Input Stream Reader ( in , STRING ) ) ; try { line = cert Buffered Reader . read Line ( ) ; } catch ( IO Exception ioe 1 ) { throw new IO Exception ( STRING + ioe 1 . get Message ( ) ) ; } if ( line . equals ( X509 Factory . BEGIN CERT ) ) { Byte Array Output Stream decstream = new Byte Array Output Stream ( ) ; try { while ( ( line = cert Buffered Reader . read Line ( ) ) != null ) { if ( line . equals ( X509 Factory . END CERT ) ) { der = new Der Value ( decstream . to Byte Array ( ) ) ; break ; } else { decstream . write ( Pem . decode ( line ) ) ; } } } catch ( IO Exception ioe 2 ) { throw new IO Exception ( STRING + ioe 2 . get Message ( ) ) ; } } else { throw new IO Exception ( STRING + STRING ) ; } return der ; }
public static Test suite ( ) { return suite ( Test Mode . triples ) ; }
private void report Exception Throw ( Element element , Throwable t ) { if ( element != null ) { log Message ( STRING , element ) ; } log Exception ( t ) ; error Message ( element , STRING , t , Arrays . to String ( Arrays . copy Of ( t . get Stack Trace ( ) , NUM ) ) ) ; }
public static void write ( float lt , float ln , int offset x1 , int offset y1 , Image Icon ii , Link Properties properties , Data Output Stream dos ) throws IO Exception , Interrupted Exception { int image width , image height ; Image image ; image width = ii . get Icon Width ( ) ; image height = ii . get Icon Height ( ) ; image = ii . get Image ( ) ; Link Raster . write ( lt , ln , offset x1 , offset y1 , image , image width , image height , properties , dos ) ; }
synchronized void discard Queue ( ) { queue . remove All Elements ( ) ; for ( Enumeration e = running . elements ( ) ; e . has More Elements ( ) ; ) { Resource Thread t = ( Resource Thread ) e . next Element ( ) ; t . cancel ( ) ; } running . remove All Elements ( ) ; bg Image Comps Selected . remove All Elements ( ) ; bg Image Comps Unselected . remove All Elements ( ) ; bg Image Comps Pressed . remove All Elements ( ) ; thread Count = NUM ; css Count = - NUM ; started = BOOL ; }
@ Override protected void property Change ( Property Change Event evt ) { super . property Change ( evt ) ; String name = evt . get Property Name ( ) ; if ( name . equals ( STRING ) ) { update Foreground ( ( Color ) evt . get New Value ( ) ) ; } else if ( name . equals ( STRING ) ) { update Font ( ( Font ) evt . get New Value ( ) ) ; } else if ( name . equals ( STRING ) ) { J Component comp = get Component ( ) ; update Foreground ( comp . get Foreground ( ) ) ; update Font ( comp . get Font ( ) ) ; } }
public static int object Equals ( Object obj 1 , Object obj 2 ) { return obj 1 . equals ( obj 2 ) ? TRUE : FALSE ; }
public static int execute Update ( String sql , Object [ ] params , boolean ignore Error , String trx Name , int time Out ) { if ( sql == null || sql . length ( ) == NUM ) throw new Illegal Argument Exception ( STRING + sql ) ; verify Trx ( trx Name , sql ) ; int no = - NUM ; C Prepared Statement cs = Proxy Factory . new C Prepared Statement ( Result Set . TYPE FORWARD ONLY , Result Set . CONCUR UPDATABLE , sql , trx Name ) ; try { set Parameters ( cs , params ) ; if ( time Out > NUM ) cs . set Query Timeout ( time Out ) ; no = cs . execute Update ( ) ; if ( trx Name == null ) { cs . commit ( ) ; } } catch ( Exception e ) { e = get SQL Exception ( e ) ; if ( ignore Error ) log . log ( Level . SEVERE , cs . get Sql ( ) + STRING + trx Name + STRING + e . get Message ( ) ) ; else { log . log ( Level . SEVERE , cs . get Sql ( ) + STRING + trx Name + STRING , e ) ; log . save Error ( STRING , e ) ; } } finally { try { cs . close ( ) ; } catch ( SQL Exception e2 ) { log . log ( Level . SEVERE , STRING ) ; } } return no ; }
static int measure Child For Cells ( View child , int cell Size , int cells Remaining , int parent Height Measure Spec , int parent Height Padding ) { final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; final int child Height Size = Measure Spec . get Size ( parent Height Measure Spec ) - parent Height Padding ; final int child Height Mode = Measure Spec . get Mode ( parent Height Measure Spec ) ; final int child Height Spec = Measure Spec . make Measure Spec ( child Height Size , child Height Mode ) ; int cells Used = NUM ; if ( cells Remaining > NUM ) { final int child Width Spec = Measure Spec . make Measure Spec ( cell Size * cells Remaining , Measure Spec . AT MOST ) ; child . measure ( child Width Spec , child Height Spec ) ; final int measured Width = child . get Measured Width ( ) ; cells Used = measured Width / cell Size ; if ( measured Width % cell Size != NUM ) cells Used ++ ; } final Action Menu Item View item View = child instanceof Action Menu Item View ? ( Action Menu Item View ) child : null ; final boolean expandable = ! lp . is Overflow Button && item View != null && item View . has Text ( ) ; lp . expandable = expandable ; lp . cells Used = cells Used ; final int target Width = cells Used * cell Size ; child . measure ( Measure Spec . make Measure Spec ( target Width , Measure Spec . EXACTLY ) , child Height Spec ) ; return cells Used ; }
public void compile Projects ( List < File > projects ) throws N4 JS Compile Exception { compile Projects ( Arrays . as List ( new File ( STRING ) ) , projects , Collections . empty List ( ) , new Dismissing Issue Acceptor ( ) ) ; }
protected final void print clearance violation info ( Object Info Panel p window , java . util . Locale p locale ) { Collection < Brd Item Violation > clearance violations = clearance violations ( ) ; if ( clearance violations . is Empty ( ) ) return ; Gui Resources resources = r board . new Gui Resources ( STRING ) ; p window . append ( STRING ) ; Integer violation count = clearance violations . size ( ) ; Collection < Printable Info > violations = new java . util . Linked List < Printable Info > ( ) ; violations . add All ( clearance violations ) ; p window . append objects ( violation count . to String ( ) , resources . get String ( STRING ) , violations ) ; if ( violation count == NUM ) { p window . append ( STRING + resources . get String ( STRING ) ) ; } else { p window . append ( STRING + resources . get String ( STRING ) ) ; } }
@ Suppress Warnings ( STRING ) public Promise < Result , Progress > reject ( Exception ex ) { List < Fail Callback > fail Callbacks ; List < Always Callback > always Callbacks ; synchronized ( this ) { validate In Pending State ( ) ; m State = STATE REJECTED ; print State Changed ( STRING ) ; m Exception = ex ; fail Callbacks = m Callbacks . clone Fail Callbacks ( ) ; always Callbacks = m Callbacks . clone Always Callbacks ( ) ; clear Callbacks ( ) ; } if ( fail Callbacks . size ( ) > NUM || always Callbacks . size ( ) > NUM ) { trigger All Fails ( fail Callbacks ) ; trigger All Always ( always Callbacks ) ; } return this ; }
public static Block Snapshot check Snap Shot Exists In DB ( String native Guid , Db Client db Client ) { List < Block Snapshot > active Snapshots = Custom Query Utility . get Active Block Snapshot By Native Guid ( db Client , native Guid ) ; Iterator < Block Snapshot > snapshot Itr = active Snapshots . iterator ( ) ; return snapshot Itr . has Next ( ) ? snapshot Itr . next ( ) : null ; }
public void load ( ) throws IO Exception { Properties proxy Config = Configuration Util . load Configuration Properties ( PROXY SETTINGS FILENAME , null ) ; props File = new File ( conf Dir , PROXY SETTINGS FILENAME ) ; props = Configuration Util . load Configuration Properties ( props File , proxy Config ) ; }
public static String list Insert At ( String list , int pos , String value , String delimiter , boolean ignore Empty ) throws Expression Exception { if ( pos < NUM ) throw new Expression Exception ( STRING + ( pos ) + STRING ) ; char [ ] del = delimiter . to Char Array ( ) ; char c ; String Builder result = new String Builder ( ) ; String end = STRING ; int len ; if ( ignore Empty ) { outer : while ( list . length ( ) > NUM ) { c = list . char At ( NUM ) ; for ( int i = NUM ; i < del . length ; i ++ ) { if ( c == del [ i ] ) { list = list . substring ( NUM ) ; result . append ( c ) ; continue outer ; } } break ; } } if ( ignore Empty ) { outer : while ( list . length ( ) > NUM ) { c = list . char At ( list . length ( ) - NUM ) ; for ( int i = NUM ; i < del . length ; i ++ ) { if ( c == del [ i ] ) { len = list . length ( ) ; list = list . substring ( NUM , len - NUM < NUM ? NUM : len - NUM ) ; end = c + end ; continue outer ; } } break ; } } len = list . length ( ) ; int last = NUM ; int count = NUM ; outer : for ( int i = NUM ; i < len ; i ++ ) { c = list . char At ( i ) ; for ( int y = NUM ; y < del . length ; y ++ ) { if ( c == del [ y ] ) { if ( ! ignore Empty || last < i ) { if ( pos == ++ count ) { result . append ( value ) ; result . append ( del [ NUM ] ) ; } } result . append ( list . substring ( last , i ) ) ; result . append ( c ) ; last = i + NUM ; continue outer ; } } } count ++ ; if ( last <= len ) { if ( pos == count ) { result . append ( value ) ; result . append ( del [ NUM ] ) ; } result . append ( list . substring ( last ) ) ; } if ( pos > count ) { throw new Expression Exception ( STRING + ( pos ) + STRING + ( count ) ) ; } return result + end ; }
static void dispose ( long p Data ) { D3 D Render Queue rq = D3 D Render Queue . get Instance ( ) ; rq . lock ( ) ; try { Render Buffer buf = rq . get Buffer ( ) ; rq . ensure Capacity And Alignment ( NUM , NUM ) ; buf . put Int ( DISPOSE SURFACE ) ; buf . put Long ( p Data ) ; rq . flush Now ( ) ; } finally { rq . unlock ( ) ; } }
void render Normal ( ) { gl Enable ( GL DEPTH TEST ) ; gl Use Program ( this . normal Program ) ; gl Uniform Matrix 4 fv ( view Matrix Uniform , BOOL , view Matrix . get ( matrix Buffer ) ) ; gl Uniform Matrix 4 fv ( proj Matrix Uniform , BOOL , proj Matrix . get ( matrix Buffer ) ) ; gl Uniform Matrix 3 fv ( normal Matrix Uniform , BOOL , normal Matrix . get ( matrix Buffer ) ) ; gl Bind Framebuffer EXT ( GL FRAMEBUFFER EXT , fbo ) ; gl Clear ( GL COLOR BUFFER BIT | GL DEPTH BUFFER BIT ) ; gl Bind Buffer ( GL ARRAY BUFFER , this . cube Vbo ) ; gl Enable Vertex Attrib Array ( NUM ) ; gl Vertex Attrib Pointer ( NUM , NUM , GL FLOAT , BOOL , NUM , NUM ) ; gl Enable Vertex Attrib Array ( NUM ) ; gl Vertex Attrib Pointer ( NUM , NUM , GL FLOAT , BOOL , NUM , this . normals Offset ) ; gl Draw Arrays ( GL TRIANGLES , NUM , this . num Vertices ) ; gl Disable Vertex Attrib Array ( NUM ) ; gl Disable Vertex Attrib Array ( NUM ) ; gl Bind Buffer ( GL ARRAY BUFFER , NUM ) ; gl Bind Framebuffer EXT ( GL FRAMEBUFFER EXT , NUM ) ; gl Use Program ( NUM ) ; }
private < T extends CWL Resource > T look For Resource ( CWL Resource Type type , Class < T > clazz ) { List < T > resources = look For Resources ( type , clazz ) ; return resources != null && resources . size ( ) > NUM ? resources . get ( NUM ) : null ; }
public boolean dec Ref Count ( ) { int rc = ref Count Updater . decrement And Get ( this ) ; if ( rc < NUM ) { throw new Illegal State Exception ( STRING + rc ) ; } return rc == NUM ; }
public void add Tight Source Node ( AST Node reference ) { f Tight Source Range Nodes . add ( reference ) ; List < Structural Property Descriptor > properties = reference . structural Properties For Type ( ) ; for ( Iterator < Structural Property Descriptor > iterator = properties . iterator ( ) ; iterator . has Next ( ) ; ) { Structural Property Descriptor descriptor = iterator . next ( ) ; if ( descriptor . is Child Property ( ) ) { AST Node child = ( AST Node ) reference . get Structural Property ( descriptor ) ; if ( child != null && is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } else if ( descriptor . is Child List Property ( ) ) { List < ? extends AST Node > children = AST Nodes . get Child List Property ( reference , ( Child List Property Descriptor ) descriptor ) ; for ( Iterator < ? extends AST Node > iterator 2 = children . iterator ( ) ; iterator 2 . has Next ( ) ; ) { AST Node child = iterator 2 . next ( ) ; if ( is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } } } }
public Uniform Distribution estimate ( Double Min Max mm ) { return new Uniform Distribution ( Math . max ( mm . get Min ( ) , - Double . MAX VALUE ) , Math . min ( mm . get Max ( ) , Double . MAX VALUE ) ) ; }
private String load Settings ( Input Stream in ) { String Builder settings = new String Builder ( ) ; Buffered Reader reader = null ; try { reader = new Buffered Reader ( new Input Stream Reader ( in ) ) ; String line = reader . read Line ( ) ; while ( line != null ) { if ( settings . length ( ) != NUM ) settings . append ( System Helper . LINE SEPARATOR ) ; settings . append ( line ) ; line = reader . read Line ( ) ; } } catch ( Throwable e ) { throw new Ignite Exception ( STRING , e ) ; } finally { U . close Quiet ( reader ) ; U . close Quiet ( in ) ; } return settings . to String ( ) ; }
@ Nullable public static XML Gregorian Calendar create XML Gregorian Calendar ( ) { XML Gregorian Calendar result = null ; try { Datatype Factory datatype Factory = Datatype Factory . new Instance ( ) ; Time Zone utc = Time Zone . get Time Zone ( STRING ) ; Gregorian Calendar now = new Gregorian Calendar ( utc ) ; result = datatype Factory . new XML Gregorian Calendar ( now ) ; } catch ( Datatype Configuration Exception e ) { throw new IMF Exception ( STRING ) ; } return result ; }
private void add Separator ( J Component container , Grid Bag Constraints c ) { c . gridy = NUM ; c . gridx ++ ; c . gridheight = Grid Bag Constraints . REMAINDER ; J Component separator = new J Separator ( Swing Constants . VERTICAL ) ; Insets tmp Insets = c . insets ; c . insets = new Insets ( SEPARATOR MARGIN , NUM , SEPARATOR MARGIN , NUM ) ; container . add ( separator , c ) ; c . gridheight = NUM ; c . insets = tmp Insets ; }
public < FT , FID > Base Foreign Collection < FT , FID > build Foreign Collection ( Object parent , FID id ) throws SQL Exception { if ( foreign Field Type == null ) { return null ; } @ Suppress Warnings ( STRING ) Dao < FT , FID > cast Dao = ( Dao < FT , FID > ) foreign Dao ; if ( ! field Config . is Foreign Collection Eager ( ) ) { return new Lazy Foreign Collection < FT , FID > ( cast Dao , parent , id , foreign Field Type , field Config . get Foreign Collection Order Column Name ( ) , field Config . is Foreign Collection Order Ascending ( ) ) ; } Level Counters level Counters = thread Level Counters . get ( ) ; if ( level Counters . foreign Collection Level == NUM ) { level Counters . foreign Collection Level Max = field Config . get Foreign Collection Max Eager Level ( ) ; } if ( level Counters . foreign Collection Level >= level Counters . foreign Collection Level Max ) { return new Lazy Foreign Collection < FT , FID > ( cast Dao , parent , id , foreign Field Type , field Config . get Foreign Collection Order Column Name ( ) , field Config . is Foreign Collection Order Ascending ( ) ) ; } level Counters . foreign Collection Level ++ ; try { return new Eager Foreign Collection < FT , FID > ( cast Dao , parent , id , foreign Field Type , field Config . get Foreign Collection Order Column Name ( ) , field Config . is Foreign Collection Order Ascending ( ) ) ; } finally { level Counters . foreign Collection Level -- ; } }
public boolean save As KML ( File file ) { try { Log . d ( Bonus Pack Helper . LOG TAG , STRING + file . get Absolute Path ( ) ) ; Output Stream Writer out = new Output Stream Writer ( new File Output Stream ( file ) , STRING ) ; Buffered Writer writer = new Buffered Writer ( out , NUM ) ; boolean result = save As KML ( writer ) ; writer . close ( ) ; Log . d ( Bonus Pack Helper . LOG TAG , STRING ) ; return result ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } }
public void remove Written ( byte [ ] value ) { write Set Lock . lock ( ) ; Set < Timestamp Value Pair > temp = ( Hash Set < Timestamp Value Pair > ) write Set . clone ( ) ; for ( Timestamp Value Pair rv : temp ) { if ( Arrays . equals ( rv . get Value ( ) , value ) ) write Set . remove ( rv ) ; } write Set Lock . unlock ( ) ; }
@ Override public void load ( Entity unit , boolean check False ) throws Illegal Argument Exception { if ( ! can Load ( unit ) ) { throw new Illegal Argument Exception ( STRING + unit . get Short Name ( ) + STRING ) ; } if ( unit instanceof Fighter Squadron ) { fighters . add All ( ( ( Fighter Squadron ) unit ) . fighters ) ; } else { fighters . add Element ( unit . get Id ( ) ) ; } if ( game . get Phase ( ) != Phase . PHASE LOUNGE ) { compute Squadron Bomb Loadout ( ) ; } else { update Weapon Groups ( ) ; load All Weapons ( ) ; } update Skills ( ) ; }
public void finish ( ) throws IO Exception { if ( ! def . finished ( ) ) { def . finish ( ) ; while ( ! def . finished ( ) ) { int len = def . deflate ( buf , NUM , buf . length ) ; if ( def . finished ( ) && len <= buf . length - TRAILER SIZE ) { write Trailer ( buf , len ) ; len = len + TRAILER SIZE ; total Length += TRAILER SIZE ; out . write ( buf , NUM , len ) ; return ; } if ( len > NUM ) { out . write ( buf , NUM , len ) ; } } byte [ ] trailer = new byte [ TRAILER SIZE ] ; write Trailer ( trailer , NUM ) ; out . write ( trailer ) ; total Length += TRAILER SIZE ; } }
public boolean free ( T obj ) { int top = top . get ( ) ; if ( top < free Stack . length ( ) ) { boolean is Free = free Stack . compare And Set ( top , null , obj ) ; top . compare And Set ( top , top + NUM ) ; return is Free ; } else return BOOL ; }
private < T > Binding Amp < T > find Binding ( Key < T > key ) { Binding Set < T > set = ( Binding Set ) binding Set Map . get ( key . raw Class ( ) ) ; if ( set != null ) { Binding Amp < T > binding = set . find ( key ) ; if ( binding != null ) { return binding ; } } return null ; }
private void start Replication Service ( Tungsten Properties repl Props ) throws Replicator Exception { String service Name = repl Props . get String ( Replicator Conf . SERVICE NAME ) ; String service Type = repl Props . get String ( Replicator Conf . SERVICE TYPE ) ; boolean is Detached = repl Props . get Boolean ( Replicator Conf . DETACHED ) ; Open Replicator Manager M Bean orm = null ; try { if ( is Detached ) { throw new Replicator Exception ( STRING ) ; } else { orm = create Internal Service ( service Name ) ; } replicators . put ( service Name , orm ) ; orm . start ( repl Props . get Boolean ( Replicator Conf . FORCE OFFLINE ) ) ; int listen Port = orm . get Master Listen Port ( ) ; if ( listen Port > master Listen Port Max ) master Listen Port Max = listen Port ; logger . info ( String . format ( STRING , ( is Detached ? STRING : STRING ) , service Type , service Name ) ) ; } catch ( Exception e ) { logger . error ( String . format ( STRING , service Name ) , e ) ; } }
private static boolean check File Parent Exists ( final String file ) { String file Name = Path Utils . remove Slash From End ( file ) ; File dir = new File ( file Name . substring ( NUM , file Name . last Index Of ( STRING ) + NUM ) ) ; return dir . exists ( ) && dir . is Directory ( ) ; }
void add Policy To Resource Tree ( Policy policy ) throws Policy Exception , SSO Exception { Set rule Names = policy . get Rule Names ( ) ; Iterator i = rule Names . iterator ( ) ; String rule Name = null ; Rule rule = null ; while ( i . has Next ( ) ) { rule Name = ( String ) i . next ( ) ; rule = policy . get Rule ( rule Name ) ; add Rule To Resource Tree ( policy . get Name ( ) , rule ) ; } Referrals referrals = policy . get Referrals ( ) ; if ( referrals != null ) { Set referral Names = referrals . get Referral Names ( ) ; if ( ( referral Names != null ) && ( ! referral Names . is Empty ( ) ) ) { Iterator referral Iter = referral Names . iterator ( ) ; while ( referral Iter . has Next ( ) ) { String referral Name = ( String ) referral Iter . next ( ) ; Referral referral = referrals . get Referral ( referral Name ) ; if ( referral instanceof Org Referral ) { Set values = referral . get Values ( ) ; if ( ( values != null ) && ( ! values . is Empty ( ) ) ) { Iterator value Iter = values . iterator ( ) ; while ( value Iter . has Next ( ) ) { String value = ( String ) value Iter . next ( ) ; Policy Manager pm = new Policy Manager ( token , value ) ; Resource Manager rm = pm . get Resource Manager ( ) ; Set rule Names 1 = policy . get Rule Names ( ) ; Iterator rule Iter = rule Names 1 . iterator ( ) ; while ( rule Iter . has Next ( ) ) { String rule Name 1 = ( String ) rule Iter . next ( ) ; Rule rule 1 = policy . get Rule ( rule Name 1 ) ; String resource Name = rule 1 . get Resource Name ( ) ; if ( resource Name != null ) { String service Type Name = rule 1 . get Service Type Name ( ) ; Set resource Names = new Hash Set ( ) ; resource Names . add ( resource Name ) ; rm . add Resource Prefixes ( service Type Name , resource Names ) ; } } } } } } } } }
private synchronized void determine Lines ( ) { if ( m line Map != null ) return ; int count = line Count For ( m text ) + NUM ; m line Map = new int [ ( NUM * count ) + NUM ] ; int i = NUM ; int line Num = NUM ; int start At = NUM ; int end At = NUM ; int length = m text . length ( ) ; char c = STRING ; while ( i < length ) { c = m text . char At ( i ++ ) ; if ( c == STRING || c == STRING ) { m line Map [ NUM * line Num ] = start At ; m line Map [ ( NUM * line Num ) + NUM ] = end At ; line Num ++ ; if ( c == STRING && i < length && m text . char At ( i ) == STRING ) i ++ ; start At = i ; end At = i ; } else end At ++ ; } if ( start At != end At ) { m line Map [ NUM * line Num ] = start At ; m line Map [ ( NUM * line Num ) + NUM ] = end At ; } }
public static void put Short LE ( long addr , short val ) { if ( UNALIGNED ) UNSAFE . put Short ( addr , Short . reverse Bytes ( val ) ) ; else put Short By Byte ( addr , val , BOOL ) ; }
public static byte [ ] hash ( byte [ ] input , int offset , int length ) { Message Digest digest = new Digest ( ) ; digest . update ( input , offset , length ) ; return digest . digest ( ) ; }
public static String read String From Url Generic ( String url ) throws IO Exception { Input Stream is = null ; URL url Obj = null ; String response String = Pc Constants . NA ; try { url Obj = new URL ( url ) ; URL Connection con = url Obj . open Connection ( ) ; con . set Connect Timeout ( Parallec Global Config . url Connection Connect Timeout Millis ) ; con . set Read Timeout ( Parallec Global Config . url Connection Read Timeout Millis ) ; is = con . get Input Stream ( ) ; Buffered Reader rd = new Buffered Reader ( new Input Stream Reader ( is , Charset . for Name ( STRING ) ) ) ; response String = Pc File Network Io Utils . read All ( rd ) ; } finally { if ( is != null ) { is . close ( ) ; } } return response String ; }
private char [ ] apply Float Padding ( char [ ] ca 4 , boolean no Digits ) { char [ ] ca 5 = ca 4 ; if ( field Width Set ) { int i , j , n Blanks ; if ( left Justify ) { n Blanks = field Width - ca 4 . length ; if ( n Blanks > NUM ) { ca 5 = new char [ ca 4 . length + n Blanks ] ; for ( i = NUM ; i < ca 4 . length ; i ++ ) ca 5 [ i ] = ca 4 [ i ] ; for ( j = NUM ; j < n Blanks ; j ++ , i ++ ) ca 5 [ i ] = STRING ; } } else if ( ! leading Zeros || no Digits ) { n Blanks = field Width - ca 4 . length ; if ( n Blanks > NUM ) { ca 5 = new char [ ca 4 . length + n Blanks ] ; for ( i = NUM ; i < n Blanks ; i ++ ) ca 5 [ i ] = STRING ; for ( j = NUM ; j < ca 4 . length ; i ++ , j ++ ) ca 5 [ i ] = ca 4 [ j ] ; } } else if ( leading Zeros ) { n Blanks = field Width - ca 4 . length ; if ( n Blanks > NUM ) { ca 5 = new char [ ca 4 . length + n Blanks ] ; i = NUM ; j = NUM ; if ( ca 4 [ NUM ] == STRING ) { ca 5 [ NUM ] = STRING ; i ++ ; j ++ ; } for ( int k = NUM ; k < n Blanks ; i ++ , k ++ ) ca 5 [ i ] = STRING ; for ( ; j < ca 4 . length ; i ++ , j ++ ) ca 5 [ i ] = ca 4 [ j ] ; } } } return ca 5 ; }
public void make Immutable ( ) { if ( is Mutable ) { if ( conditions != null ) { int length = conditions . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Condition condition = ( Condition ) conditions . get ( i ) ; condition . make Immutable ( ) ; } conditions = Collections . unmodifiable List ( conditions ) ; } if ( audience Restrictions != null ) { int length = audience Restrictions . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Audience Restriction ar = ( Audience Restriction ) audience Restrictions . get ( i ) ; ar . make Immutable ( ) ; } audience Restrictions = Collections . unmodifiable List ( audience Restrictions ) ; } if ( one Time Uses != null ) { int length = one Time Uses . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { One Time Use one Time Use = ( One Time Use ) one Time Uses . get ( i ) ; one Time Use . make Immutable ( ) ; } one Time Uses = Collections . unmodifiable List ( one Time Uses ) ; } if ( proxy Restrictions != null ) { int length = proxy Restrictions . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Proxy Restriction pr = ( Proxy Restriction ) proxy Restrictions . get ( i ) ; pr . make Immutable ( ) ; } proxy Restrictions = Collections . unmodifiable List ( proxy Restrictions ) ; } is Mutable = BOOL ; } }
public String lookup Relative Native Path ( Path Impl path ) { String this Native = get Native Path ( ) ; String path Native = path . get Native Path ( ) ; if ( path Native . starts With ( this Native ) ) { int i = this Native . length ( ) ; while ( i < path Native . length ( ) ) { if ( path Native . char At ( i ) != get File Separator Char ( ) ) break ; i ++ ; } return i == path Native . length ( ) ? STRING : path Native . substring ( i ) ; } else return path Native ; }
public void add Component Listener ( final Component Update Listener listener ) { component Listeners . add ( listener ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return SEQUENCE ID ; case NUM : return STATUS ; case NUM : return MESSAGE ; default : return null ; } }
public boolean validate ( ) { if ( validators == null || validators . size ( ) == NUM ) { return BOOL ; } Char Sequence text = get Text ( ) ; boolean is Empty = text . length ( ) == NUM ; boolean is Valid = BOOL ; for ( MET Validator validator : validators ) { is Valid = is Valid && validator . is Valid ( text , is Empty ) ; if ( ! is Valid ) { set Error ( validator . get Error Message ( ) ) ; break ; } } post Invalidate ( ) ; return is Valid ; }
public void test metric heartbeat uint 32 ( ) { final I Ganglia Metadata Message decl = new Ganglia Metadata Message ( STRING , STRING , BOOL , Ganglia Message Type Enum . UINT 32 , STRING , STRING , Ganglia Slope Enum . unspecified , NUM , NUM , Abstract Metrics . get Map ( I Ganglia Attributes . GROUP CORE , STRING , STRING ) ) ; assert Encode Decode ( null , decl ) ; final I Ganglia Metric Message expected = new Ganglia Metric Message ( Ganglia Message Type Enum . UINT 32 , STRING , STRING , BOOL , STRING , Long . value Of ( NUM ) ) ; final byte [ ] actual Data = assert Encode Decode ( decl , expected ) ; final byte [ ] expected Data = new byte [ ] { NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , - NUM } ; if ( ! Arrays . equals ( expected Data , actual Data ) ) { fail ( STRING + Arrays . to String ( expected Data ) + STRING + Arrays . to String ( actual Data ) ) ; } }
private boolean is Stemmable ( String term ) { for ( int c = NUM ; c < term . length ( ) ; c ++ ) { if ( ! Character . is Letter ( term . char At ( c ) ) ) return BOOL ; } return BOOL ; }
private void send Response ( String status , String mime , Properties header , Input Stream data ) { try { if ( status == null ) throw new Error ( STRING ) ; Output Stream out = my Socket . get Output Stream ( ) ; Print Writer pw = new Print Writer ( out ) ; pw . print ( STRING + status + STRING ) ; if ( mime != null ) pw . print ( STRING + mime + STRING ) ; if ( header == null || header . get Property ( STRING ) == null ) pw . print ( STRING + gmt Frmt . format ( new Date ( ) ) + STRING ) ; if ( header != null ) { Enumeration < ? > e = header . keys ( ) ; while ( e . has More Elements ( ) ) { String key = ( String ) e . next Element ( ) ; String value = header . get Property ( key ) ; pw . print ( key + STRING + value + STRING ) ; } } pw . print ( STRING ) ; pw . flush ( ) ; if ( data != null ) { int pending = data . available ( ) ; byte [ ] buff = new byte [ the Buffer Size ] ; while ( pending > NUM ) { int read = data . read ( buff , NUM , ( ( pending > the Buffer Size ) ? the Buffer Size : pending ) ) ; if ( read <= NUM ) break ; out . write ( buff , NUM , read ) ; pending -= read ; } } out . flush ( ) ; out . close ( ) ; if ( data != null ) data . close ( ) ; } catch ( IO Exception ioe ) { try { my Socket . close ( ) ; } catch ( Exception t ) { } } }
private static boolean is Access Permitted ( ) { try { IS Security Permission isp = new IS Security Permission ( STRING , STRING ) ; if ( security Manager != null ) { security Manager . check Permission ( isp ) ; } return BOOL ; } catch ( Security Exception e ) { Debug debug = Debug . get Instance ( STRING ) ; debug . error ( STRING + STRING , e ) ; } return BOOL ; }
protected void wait For Shutdown Signal ( ) throws Interrupted Exception { if ( mutex Waiting == null ) { mutex Waiting = new Object ( ) ; } try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch ( Interrupted Exception e ) { if ( ! shutdown ) { throw e ; } } }
public void remove Connection ( Connection connection ) { if ( connection == null ) throw new Illegal Argument Exception ( STRING ) ; connection . remove Listener ( invoke Listener ) ; synchronized ( connections Lock ) { Array List < Connection > temp = new Array List ( Arrays . as List ( connections ) ) ; temp . remove ( connection ) ; connections = temp . to Array ( new Connection [ temp . size ( ) ] ) ; } if ( TRACE ) trace ( STRING , STRING + connection ) ; }
public double calc Max Distance ( final double x , final double y ) { double distance X = Math . max ( Math . abs ( this . min X - x ) , Math . abs ( this . max X - x ) ) ; double distance Y = Math . max ( Math . abs ( this . min Y - y ) , Math . abs ( this . max Y - y ) ) ; return Math . sqrt ( distance X * distance X + distance Y * distance Y ) ; }
public static int int From Properties ( Properties p , String prop Name , int default Value ) { int ret = default Value ; String int String = p . get Property ( prop Name ) ; if ( int String != null ) { try { ret = Integer . parse Int ( int String . trim ( ) ) ; } catch ( Number Format Exception e ) { ret = default Value ; } } return ret ; }
public Repeat Iterable ( @ Not Null T single ) { master = new Array List < T > ( NUM ) ; master . add ( single ) ; }
private void update State View ( Object state ) { Platform . run Later ( null ) ; sim Pane Ctrl . wait After Step ( ) ; }
Poller ( Unix File System fs , Solaris Watch Service watcher , int port ) { this . watcher = watcher ; this . port = port ; this . buffer Address = unsafe . allocate Memory ( SIZEOF PORT EVENT * MAX EVENT COUNT ) ; this . file Key 2 Watch Key = new Hash Map < Unix File Key , Solaris Watch Key > ( ) ; this . object 2 Node = new Hash Map < Long , Node > ( ) ; }
public static List < String > find Childrens List ( final File dir , final boolean search Dirs ) { List < String > files = new Array List < > ( ) ; for ( String sub Files : dir . list ( ) ) { File file = new File ( dir + STRING + sub Files ) ; if ( ( search Dirs && file . is Directory ( ) ) || ( ! search Dirs && ! file . is Directory ( ) ) ) { files . add ( file . get Name ( ) ) ; } } return files ; }
public Dialogue Importer ( Dialogue System system , List < Dialogue State > turns ) { this . system = system ; this . turns = turns ; }
private void backup Screens ( Backup Data Output data ) throws IO Exception { Content Resolver cr = m Context . get Content Resolver ( ) ; Cursor cursor = cr . query ( Launcher Settings . Workspace Screens . CONTENT URI , SCREEN PROJECTION , null , null , null ) ; try { cursor . move To Position ( - NUM ) ; if ( DEBUG ) Log . d ( TAG , STRING + m Last Backup Restore Time ) ; while ( cursor . move To Next ( ) ) { final long id = cursor . get Long ( ID INDEX ) ; final long update Time = cursor . get Long ( ID MODIFIED ) ; Key key = get Key ( Key . SCREEN , id ) ; m Keys . add ( key ) ; final String backup Key = key To Backup Key ( key ) ; if ( ! m Existing Keys . contains ( backup Key ) || update Time >= m Last Backup Restore Time ) { write Row To Backup ( key , pack Screen ( cursor ) , data ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + id ) ; } } } finally { cursor . close ( ) ; } }
@ Override default Completable Future < Optional Double > max Double ( final To Double Function < ? super T > fn ) { return Completable Future . supply Async ( null , get Exec ( ) ) ; }
private boolean to Next State ( Lifecycle State new State ) { Lifecycle State state ; synchronized ( this ) { state = state ; if ( new State . ordinal ( ) <= state . ordinal ( ) ) { return BOOL ; } state = new State ; last Change Time = Current Time . current Time ( ) ; } if ( log != null && log . is Loggable ( low Level ) ) { log . log ( low Level , new State + STRING + name ) ; } notify Listeners ( state , new State ) ; return BOOL ; }
public boolean init ( ) { if ( MODE == MODE HORIZONTAL ) { center Panel . set Layout ( new A Layout ( ) ) ; } if ( MODE == MODE VERTICAL ) { gbc . anchor = Grid Bag Constraints . NORTHWEST ; gbc . weightx = NUM ; gbc . weighty = NUM ; gbc . gridy = m line ++ ; gbc . gridx = NUM ; gbc . gridwidth = NUM ; gbc . insets = null Inset ; gbc . fill = Grid Bag Constraints . HORIZONTAL ; center Panel . add ( Box . create Vertical Strut ( NUM ) , gbc ) ; } log . config ( STRING ) ; M Client client = M Client . get ( Env . get Ctx ( ) ) ; String ASP Filter = STRING ; if ( client . is Use ASP ( ) ) ASP Filter = STRING + STRING + STRING + STRING + STRING + client . get AD Client ID ( ) + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + client . get AD Client ID ( ) + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + client . get AD Client ID ( ) + STRING + STRING + STRING + STRING + STRING ; String sql = null ; if ( Env . is Base Language ( Env . get Ctx ( ) , STRING ) ) sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + ASP Filter + STRING ; else sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + Env . get AD Language ( Env . get Ctx ( ) ) + STRING + STRING + ASP Filter + STRING ; int cols = NUM ; int col = NUM ; int row = NUM ; boolean has Fields = BOOL ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , m process Info . get AD Process ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { has Fields = BOOL ; if ( MODE == MODE HORIZONTAL ) { create Field ( rs , row , cols ) ; cols = cols + col ; if ( cols >= NUM ) { cols = NUM ; row ++ ; } } if ( MODE == MODE VERTICAL ) { create Field ( rs ) ; } } } catch ( SQL Exception e ) { throw new DB Exception ( e , sql ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( m m Fields . size ( ) != m m Fields 2 . size ( ) || m m Fields . size ( ) != m v Editors . size ( ) || m m Fields 2 . size ( ) != m v Editors 2 . size ( ) ) log . log ( Level . SEVERE , STRING ) ; if ( has Fields ) { if ( MODE == MODE VERTICAL ) { gbc . gridy = m line ++ ; center Panel . add ( Box . create Vertical Strut ( NUM ) , gbc ) ; gbc . gridx = NUM ; center Panel . add ( Box . create Horizontal Strut ( NUM ) , gbc ) ; } dynamic Display ( ) ; } else dispose ( ) ; return has Fields ; }
@ Override protected String date To String ( Date Time Data date ) { String Buffer message = new String Buffer ( NUM ) ; message . append ( STRING ) ; message . append ( STRING ) ; append ( message , date . month , NUM ) ; message . append ( STRING ) ; append ( message , date . day , NUM ) ; append ( message , ( char ) date . utc , NUM ) ; return message . to String ( ) ; }
private Instance update Decision List ( Random random , Instance example ) throws Exception { Array List < Test > Test List ; Instances format = get Dataset Format ( ) ; if ( format == null ) { throw new Exception ( STRING ) ; } Test List = generate Test List ( random , example ) ; int max Size = get Max Rule Size ( ) < Test List . size ( ) ? get Max Rule Size ( ) : Test List . size ( ) ; int rule Size = ( ( int ) ( random . next Double ( ) * ( max Size - get Min Rule Size ( ) ) ) ) + get Min Rule Size ( ) ; Rule List new Rule = new Rule List ( ) ; for ( int i = NUM ; i < rule Size ; i ++ ) { int test Index = ( int ) ( random . next Double ( ) * Test List . size ( ) ) ; Test test = Test List . get ( test Index ) ; new Rule . add Test ( test ) ; Test List . remove ( test Index ) ; } double new Class Value = NUM ; if ( m Decision List . size ( ) > NUM ) { Rule List r = ( m Decision List . get ( m Decision List . size ( ) - NUM ) ) ; double old Class Value = ( r . get Class Value ( ) ) ; new Class Value = ( double ) ( ( int ) old Class Value + NUM ) % get Num Classes ( ) ; } new Rule . set Class Value ( new Class Value ) ; m Decision List . add ( new Rule ) ; example = ( Instance ) example . copy ( ) ; example . set Dataset ( format ) ; example . set Class Value ( new Class Value ) ; return example ; }

public static void swap ( List list , int i , int j ) { Object tmp = list . get ( i ) ; list . set ( i , list . get ( j ) ) ; list . set ( j , tmp ) ; }
public static Http Response create Post ( String server , String username , String password , String token , boolean learning Opt Out , String content , String voice , String codec ) throws Exception { String url = server ; Http Client http Client = new Default Http Client ( ) ; List < Basic Name Value Pair > params = new Linked List < Basic Name Value Pair > ( ) ; params . add ( new Basic Name Value Pair ( STRING , content ) ) ; params . add ( new Basic Name Value Pair ( STRING , voice ) ) ; params . add ( new Basic Name Value Pair ( STRING , codec ) ) ; Http Get http Get = new Http Get ( url + STRING + URL Encoded Utils . format ( params , STRING ) ) ; if ( token != null ) { Log . d ( TAG , STRING ) ; http Get . set Header ( STRING , token ) ; } else { Log . d ( TAG , STRING ) ; http Get . set Header ( Basic Scheme . authenticate ( new Username Password Credentials ( username , password ) , STRING , BOOL ) ) ; } if ( learning Opt Out ) { Log . d ( TAG , STRING ) ; http Get . set Header ( STRING , STRING ) ; } Http Response executed = http Client . execute ( http Get ) ; return executed ; }
public static < T , U extends Auto Closeable > T with Auto Closeable ( U self , @ Closure Params ( value = First Param . class ) Closure < T > action ) throws Exception { try { T result = action . call ( self ) ; Auto Closeable temp = self ; self = null ; temp . close ( ) ; return result ; } finally { close With Warning ( self ) ; } }
private boolean string Match ( String str , Ocr Result Iterator iter ) { Ocr Result Iterator iter Copy = new Ocr Result Iterator ( iter ) ; for ( int pos = NUM ; pos < str . length ( ) ; ++ pos ) { if ( ! char Match ( str . char At ( pos ) , iter Copy . get Current Char ( ) ) ) return BOOL ; if ( pos != str . length ( ) - NUM && ! iter Copy . has Next ( ) ) return BOOL ; iter Copy . move To Next ( ) ; } return BOOL ; }
public synchronized void update Load ( Server Location location , Server Load new Load , List client Ids ) { String [ ] groups = ( String [ ] ) server Group Map . get ( location ) ; if ( groups == null ) { return ; } if ( client Ids != null ) { for ( Iterator itr = client Ids . iterator ( ) ; itr . has Next ( ) ; ) { cancel Client Estimate ( ( Client Proxy Membership ID ) itr . next ( ) , location ) ; } } update Map ( connection Load Map , location , new Load . get Connection Load ( ) , new Load . get Load Per Connection ( ) ) ; update Map ( queue Load Map , location , new Load . get Subscription Connection Load ( ) , new Load . get Load Per Subscription Connection ( ) ) ; }
public void add Leaf ( String name , String path ) { Named Icon icon = Named Icon . get Icon By Name ( path ) ; if ( icon == null ) { log . warn ( STRING + path + STRING ) ; return ; } int h = icon . get Icon Height ( ) ; for ( int i = NUM ; i < leaves . size ( ) ; i ++ ) { Catalog Tree Leaf leaf = leaves . get ( i ) ; if ( h < leaf . get Size ( ) ) { leaves . add ( i + NUM , new Catalog Tree Leaf ( name , path , h ) ) ; return ; } } leaves . add ( new Catalog Tree Leaf ( name , path , h ) ) ; }
public static long plus ( long tstamp , long microseconds ) { long microsmask = ( long ) UMASK ; long newmicros = tstamp & microsmask ; if ( ( newmicros + microseconds ) <= MAX MICROS ) { tstamp += microseconds ; } else { int [ ] pieces = new int [ NUMIDX ] ; Component Time . unpack Bits ( tstamp , pieces ) ; int year = pieces [ YIDX ] ; int month = pieces [ MIDX ] ; int day = pieces [ DIDX ] ; int hour = pieces [ HIDX ] ; int minute = pieces [ IIDX ] ; int second = pieces [ SIDX ] ; newmicros += microseconds ; int overseconds = ( int ) ( newmicros / NUM ) ; newmicros = ( newmicros % NUM ) ; Gregorian Calendar cal = new Gregorian Calendar ( year , month - NUM , day , hour , minute , second ) ; cal . add ( Calendar . SECOND , overseconds ) ; second = cal . get ( Calendar . SECOND ) ; minute = cal . get ( Calendar . MINUTE ) ; hour = cal . get ( Calendar . HOUR OF DAY ) ; day = cal . get ( Calendar . DAY OF MONTH ) ; month = cal . get ( Calendar . MONTH ) + NUM ; year = cal . get ( Calendar . YEAR ) ; tstamp = newmicros ; tstamp |= ( ( long ) year ) << YPOS ; tstamp |= ( ( long ) month ) << MPOS ; tstamp |= ( ( long ) day ) << DPOS ; tstamp |= ( ( long ) hour ) << HPOS ; tstamp |= ( ( long ) minute ) << IPOS ; tstamp |= ( ( long ) second ) << SPOS ; } return ( tstamp ) ; }
public Http Request content Length ( final String content Length ) { return content Length ( Integer . parse Int ( content Length ) ) ; }
public VN Xe Command Result modify Lun Sync ( Lun Modify Param param , String resource Id ) { String Builder url Bld = new String Builder ( URL RESOURCE ) ; url Bld . append ( resource Id ) ; url Bld . append ( URL LUN MODIFY ACTION ) ; url = url Bld . to String ( ) ; VN Xe Command Result result = post Request Sync ( param ) ; result . set Success ( BOOL ) ; return result ; }
public String replace ( Char Sequence target , Char Sequence replacement ) { if ( target == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( replacement == null ) { throw new Null Pointer Exception ( STRING ) ; } String target String = target . to String ( ) ; int match Start = index Of ( target String , NUM ) ; if ( match Start == - NUM ) { return this ; } String replacement String = replacement . to String ( ) ; int target Length = target String . length ( ) ; if ( target Length == NUM ) { int result Length = count + ( count + NUM ) * replacement String . length ( ) ; String Builder result = new String Builder ( result Length ) ; result . append ( replacement String ) ; int end = offset + count ; for ( int i = offset ; i != end ; ++ i ) { result . append ( value [ i ] ) ; result . append ( replacement String ) ; } return result . to String ( ) ; } String Builder result = new String Builder ( count ) ; int search Start = NUM ; do { result . append ( value , offset + search Start , match Start - search Start ) ; result . append ( replacement String ) ; search Start = match Start + target Length ; } while ( ( match Start = index Of ( target String , search Start ) ) != - NUM ) ; result . append ( value , offset + search Start , count - search Start ) ; return result . to String ( ) ; }
boolean on Sub Property ( Owl Class other ) { Set < URI > other Prop = other . get On Property ( ) ; for ( Owl Property prop : this . properties ) { Set < URI > intersection = prop . get Super Properties ( ) ; intersection . retain All ( other Prop ) ; if ( ! intersection . is Empty ( ) ) { return BOOL ; } } return BOOL ; }
public static Google Analytics initialise Google Analytics ( Context context , String tracker Id , final Exception Parser callback ) { m Analytics = Google Analytics . get Instance ( context ) ; m Analytics . set Local Dispatch Period ( NUM ) ; m Tracker = m Analytics . new Tracker ( tracker Id ) ; m Tracker . enable Exception Reporting ( BOOL ) ; m Tracker . enable Auto Activity Tracking ( BOOL ) ; Thread . Uncaught Exception Handler handler = Thread . get Default Uncaught Exception Handler ( ) ; if ( handler != null && handler instanceof Exception Reporter ) { Exception Reporter exception Reporter = ( Exception Reporter ) handler ; exception Reporter . set Exception Parser ( callback ) ; Thread . set Default Uncaught Exception Handler ( exception Reporter ) ; Log . d ( LOG TAG , STRING ) ; } else { Log . e ( LOG TAG , STRING ) ; } return m Analytics ; }
public void append Results ( List < Search Result > search Results ) { m Search Results . add All ( search Results ) ; for ( Search Result search Result : search Results ) { final Provider Identifier id = search Result . get Identifier ( ) ; final List < String > songs = search Result . get Songs List ( ) ; final List < String > artists = search Result . get Artist List ( ) ; final List < String > playlists = search Result . get Playlist List ( ) ; final List < String > albums = search Result . get Albums List ( ) ; for ( String song : songs ) { Search Entry entry = new Search Entry ( song , id ) ; if ( ! m All Songs . contains ( entry ) ) { m All Songs . add ( entry ) ; } } for ( String artist : artists ) { Search Entry entry = new Search Entry ( artist , id ) ; if ( ! m All Artists . contains ( entry ) ) { m All Artists . add ( entry ) ; } } for ( String playlist : playlists ) { Search Entry entry = new Search Entry ( playlist , id ) ; if ( ! m All Playlists . contains ( entry ) ) { m All Playlists . add ( entry ) ; } } for ( String album : albums ) { Search Entry entry = new Search Entry ( album , id ) ; if ( ! m All Albums . contains ( entry ) ) { m All Albums . add ( entry ) ; } } } compute Results List ( ) ; }
@ Not Null public Psi Query siblings ( @ Not Null final Class < ? extends Psi Named Element > clazz , @ Not Null final String name ) { final List < Psi Element > result = new Array List < Psi Element > ( ) ; for ( final Psi Element element : my Psi Elements ) { final Psi Element parent = element . get Parent ( ) ; for ( final Psi Named Element named Sibling : Psi Tree Util . find Children Of Type ( parent , clazz ) ) { if ( ( ! named Sibling . equals ( element ) ) && ( name . equals ( named Sibling . get Name ( ) ) ) ) { result . add ( named Sibling ) ; } } } return new Psi Query ( result . to Array ( new Psi Element [ result . size ( ) ] ) ) ; }
@ Override public int compare To ( Value o ) { return hash Code ( ) - o . hash Code ( ) ; }
protected String limit Text ( String text ) { int start Index = NUM ; int search Start = NUM ; if ( start Pattern != null ) { Matcher start Matcher = start Pattern . matcher ( text ) ; if ( start Matcher . find ( ) ) { start Index = start Matcher . start ( ) ; search Start = start Matcher . end ( ) ; } else if ( ! start Match Optional ) { return null ; } } int end Index = text . length ( ) ; if ( end Pattern != null ) { Matcher end Matcher = end Pattern . matcher ( text ) ; if ( end Matcher . find ( search Start ) ) { end Index = end Matcher . start ( ) ; } else if ( ! end Match Optional ) { return null ; } } if ( ( start Index > NUM ) || ( end Index < text . length ( ) ) ) { return String Utils . substring ( text , start Index , end Index ) ; } else { return text ; } }
private void replace Impl ( int start Index , int end Index , int remove Len , String insert Str , int insert Len ) { int new Size = size - remove Len + insert Len ; if ( insert Len != remove Len ) { ensure Capacity ( new Size ) ; System . arraycopy ( buffer , end Index , buffer , start Index + insert Len , size - end Index ) ; size = new Size ; } if ( insert Len > NUM ) { insert Str . get Chars ( NUM , insert Len , buffer , start Index ) ; } }
public static void remove Permission Recursive ( Path path , Posix File Permission permission ) throws IO Exception { change Permissions Recursive ( path , Permission Change . REMOVE , Collections . singleton ( permission ) ) ; }
public static void collect Garbage ( long timeout ) { try { System . gc ( ) ; Thread . sleep ( timeout ) ; System . run Finalization ( ) ; Thread . sleep ( timeout ) ; } catch ( Interrupted Exception ex ) { ex . print Stack Trace ( ) ; } }
public void test Case 7 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
private Action Button create Toolbar Button ( Action action ) { return new Action Button ( action , action Manager , presentation Factory . get Presentation ( action ) , manager Provider . get ( ) , toolbar Resources ) ; }
private static String [ ] pre Process Args ( String [ ] unprocessed Args ) { List < String > args = new Linked List < > ( ) ; Collections . add All ( args , unprocessed Args ) ; args . remove ( NUM ) ; Pattern arg Pattern = Pattern . compile ( STRING ) ; Pattern quotes Pattern = Pattern . compile ( STRING ) ; List < String > processed Args = new Array List < > ( args . size ( ) ) ; for ( String arg : args ) { Matcher matcher = arg Pattern . matcher ( arg ) ; if ( matcher . matches ( ) ) { processed Args . add ( matcher . group ( NUM ) ) ; String value = matcher . group ( NUM ) ; Matcher quotes Matcher = quotes Pattern . matcher ( value ) ; if ( quotes Matcher . matches ( ) ) { processed Args . add ( quotes Matcher . group ( NUM ) ) ; } else { processed Args . add ( value ) ; } } else { processed Args . add ( arg ) ; } } return processed Args . to Array ( new String [ args . size ( ) ] ) ; }
private static Counter < String > load Weights ( String wts Initial File , boolean uniform Start Weights , boolean randomize Start Weights , Translation Model < I String , String > translation Model ) { Counter < String > weights = IO Tools . read Weights ( wts Initial File ) ; if ( weights == null ) weights = new Classic Counter < > ( ) ; if ( uniform Start Weights ) { Set < String > feature Names = new Hash Set < > ( weights . key Set ( ) ) ; feature Names . add All ( Feature Utils . get Baseline Features ( translation Model ) ) ; for ( String key : feature Names ) { if ( key . starts With ( N Gram Language Model Featurizer . DEFAULT FEATURE NAME ) ) { weights . set Count ( key , NUM ) ; } else if ( key . starts With ( Word Penalty Featurizer . FEATURE NAME ) ) { weights . set Count ( key , - NUM ) ; } else { weights . set Count ( key , NUM ) ; } } } if ( randomize Start Weights ) { double scale = NUM ; Optimizer Utils . randomize Weights In Place ( weights , scale ) ; } return weights ; }
public static void build Network Topology ( String file Name ) { Log . print Concat Line ( STRING , file Name ) ; Graph Reader Brite reader = new Graph Reader Brite ( ) ; try { graph = reader . read Graph File ( file Name ) ; map = new Hash Map < Integer , Integer > ( ) ; generate Matrices ( ) ; } catch ( IO Exception e ) { Log . print Line ( STRING + e . get Message ( ) ) ; } }
public static String to Hex ( byte [ ] bytes , int bytes Per Row ) { if ( bytes == null ) return STRING ; String Buffer sb = new String Buffer ( ) ; sb . append ( STRING + bytes . length + STRING ) ; int i = NUM ; while ( i < bytes . length ) { if ( bytes Per Row > NUM && i % bytes Per Row == NUM ) sb . append ( STRING ) ; sb . append ( HEX CHARS [ ( bytes [ i ] > > NUM ) & NUM ] ) ; sb . append ( HEX CHARS [ bytes [ i ] & NUM ] ) ; i ++ ; } return sb . to String ( ) ; }
public static boolean enough Space On Sd Card ( long update Size ) { String status = Environment . get External Storage State ( ) ; if ( ! status . equals ( Environment . MEDIA MOUNTED ) ) return BOOL ; return ( update Size < get Real Size On Sdcard ( ) ) ; }
private String value To String ( Object value ) throws Replicator Exception { if ( value instanceof String ) { return value . to String ( ) ; } else if ( value instanceof Integer ) { return value . to String ( ) ; } else if ( value instanceof Serial Blob ) { try { Serial Blob blob = ( Serial Blob ) value ; return new String ( blob . get Bytes ( NUM , ( int ) blob . length ( ) ) ) ; } catch ( Serial Exception e ) { throw new Replicator Exception ( STRING + e , e ) ; } } else { return ( String ) value ; } }
public void add Nodes In Doc Order ( Node Iterator iterator , X Path Context support ) { if ( ! m mutable ) throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NODESET NOT MUTABLE , null ) ) ; Node node ; while ( null != ( node = iterator . next Node ( ) ) ) { add Node In Doc Order ( node , support ) ; } }
protected static String read Stream ( Input Stream stream ) throws One Drive API Exception { if ( stream == null ) { return null ; } Input Stream Reader reader = new Input Stream Reader ( stream , Standard Charsets . UTF 8 ) ; String Builder builder = new String Builder ( ) ; char [ ] buffer = new char [ BUFFER SIZE ] ; try { int read ; while ( ( read = reader . read ( buffer , NUM , BUFFER SIZE ) ) != - NUM ) { builder . append ( buffer , NUM , read ) ; } stream . close ( ) ; } catch ( IO Exception e ) { throw new One Drive API Exception ( STRING , e ) ; } return builder . to String ( ) ; }
@ Override public Trie reduce ( Reduce by ) { List < Trie > h = new Array List < > ( ) ; for ( Trie trie : tries ) h . add ( trie . reduce ( by ) ) ; Multi Trie m = new Multi Trie ( forward ) ; m . tries = h ; return m ; }
public void reset ( Dialogue State state ) { record State ( state , CURRENT ) ; list Box . set Selected Index ( NUM ) ; while ( list Model . size ( ) > NUM ) { String name = list Model . remove ( NUM ) ; states . remove ( name ) ; } visualisation . show Bayesian Network ( state ) ; }
public void write Bytes ( final byte [ ] bytes , final int off , final int len ) { if ( len > remaining ( ) ) { write Bytes Slow ( bytes , off , len ) ; return ; } final Block block = current ; System . arraycopy ( bytes , off , block . data , block . limit , len ) ; block . limit += len ; }
private void populate Connection Combo Box ( ) { connection Combo Box . remove All Items ( ) ; if ( geo Server Connection Manager != null ) { List < Geo Server Connection > connection List = geo Server Connection Manager . get Connection List ( ) ; for ( Geo Server Connection connection : connection List ) { connection Combo Box . add Item ( connection . get Connection Name ( ) ) ; connection Map . put ( connection . get Connection Name ( ) , connection ) ; } } }

long cleanup ( long now ) { int in Use Connection Count = NUM ; int idle Connection Count = NUM ; Real Connection longest Idle Connection = null ; long longest Idle Duration Ns = Long . MIN VALUE ; synchronized ( this ) { for ( Iterator < Real Connection > i = connections . iterator ( ) ; i . has Next ( ) ; ) { Real Connection connection = i . next ( ) ; if ( prune And Get Allocation Count ( connection , now ) > NUM ) { in Use Connection Count ++ ; continue ; } idle Connection Count ++ ; long idle Duration Ns = now - connection . idle At Nanos ; if ( idle Duration Ns > longest Idle Duration Ns ) { longest Idle Duration Ns = idle Duration Ns ; longest Idle Connection = connection ; } } if ( longest Idle Duration Ns >= this . keep Alive Duration Ns || idle Connection Count > this . max Idle Connections ) { connections . remove ( longest Idle Connection ) ; } else if ( idle Connection Count > NUM ) { return keep Alive Duration Ns - longest Idle Duration Ns ; } else if ( in Use Connection Count > NUM ) { return keep Alive Duration Ns ; } else { return - NUM ; } } Util . close Quietly ( longest Idle Connection . get Socket ( ) ) ; return NUM ; }
private State build Patch ( final Task State . Task Stage stage , final Task State . Sub Stage sub Satge , final Throwable e ) { State s = new State ( ) ; s . task Info = new Task State ( ) ; s . task Info . stage = stage ; s . task Info . sub Stage = sub Satge ; if ( e != null ) { s . task Info . failure = Utils . to Service Error Response ( e ) ; } return s ; }
protected static boolean version Compatible ( String current Version , String expected Version ) { if ( Character . is Digit ( expected Version . char At ( expected Version . length ( ) - NUM ) ) ) { if ( ! current Version . starts With ( expected Version ) ) { return BOOL ; } } else { boolean backward Com = BOOL ; int compare Length = Math . min ( expected Version . length ( ) - NUM , current Version . length ( ) ) ; if ( expected Version . ends With ( STRING ) ) { backward Com = BOOL ; } for ( int i = NUM ; i < compare Length ; i ++ ) { if ( backward Com ) { if ( expected Version . char At ( i ) < current Version . char At ( i ) ) { return BOOL ; } } else { if ( current Version . char At ( i ) > expected Version . char At ( i ) ) { break ; } if ( current Version . char At ( i ) < expected Version . char At ( i ) ) { return BOOL ; } } } } return BOOL ; }
public static byte [ ] hex String 2 Byte Array ( String hex ) throws Illegal Argument Exception { if ( hex . length ( ) % NUM != NUM ) hex = STRING + hex ; char [ ] chars = hex . to Char Array ( ) ; byte [ ] bytes = new byte [ chars . length / NUM ] ; int byte Cnt = NUM ; for ( int i = NUM ; i < chars . length ; i += NUM ) { int new Byte = NUM ; new Byte |= hex Char To Byte ( chars [ i ] ) ; new Byte <<= NUM ; new Byte |= hex Char To Byte ( chars [ i + NUM ] ) ; bytes [ byte Cnt ] = ( byte ) new Byte ; byte Cnt ++ ; } return bytes ; }
private boolean is Authorized ( Application User application User , String namespace , Namespace Permission Enum ... permissions ) { if ( application User != null && application User . get Namespace Authorizations ( ) != null ) { for ( Namespace Authorization current User Authorization : application User . get Namespace Authorizations ( ) ) { List < Namespace Permission Enum > current User Namespace Permissions = current User Authorization . get Namespace Permissions ( ) ; if ( current User Namespace Permissions == null ) { current User Namespace Permissions = Collections . empty List ( ) ; } if ( String Utils . equals Ignore Case ( current User Authorization . get Namespace ( ) , namespace ) && current User Namespace Permissions . contains All ( Arrays . as List ( permissions ) ) ) { return BOOL ; } } } return BOOL ; }
public byte [ ] embed Data ( byte [ ] msg , String msg File Name , byte [ ] cover , String cover File Name , String stego File Name ) throws Open Stego Exception { Buffered Image image = null ; Dct LSB Output Stream os = null ; int img Type = NUM ; try { if ( cover == null ) { image = Image Util . generate Random Image ( ( DCT Data Header . get Max Header Size ( ) + msg . length ) * NUM * DCT . NJPEG * DCT . NJPEG ) ; } else { image = Image Util . byte Array To Image ( cover , cover File Name ) ; } img Type = image . get Type ( ) ; os = new Dct LSB Output Stream ( image , msg . length , msg File Name , this . config ) ; os . write ( msg ) ; os . close ( ) ; return Image Util . image To Byte Array ( os . get Image ( img Type ) , stego File Name , this ) ; } catch ( IO Exception io Ex ) { throw new Open Stego Exception ( io Ex ) ; } }
private void calculate Grid Sizes ( float numbers Radius , float x Center , float y Center , float text Size , float [ ] text Grid Heights , float [ ] text Grid Widths ) { float offset 1 = numbers Radius ; float offset 2 = numbers Radius * ( ( float ) Math . sqrt ( NUM ) ) / NUM ; float offset 3 = numbers Radius / NUM ; m Paint . set Text Size ( text Size ) ; m Selected Paint . set Text Size ( text Size ) ; m Inactive Paint . set Text Size ( text Size ) ; y Center -= ( m Paint . descent ( ) + m Paint . ascent ( ) ) / NUM ; text Grid Heights [ NUM ] = y Center - offset 1 ; text Grid Widths [ NUM ] = x Center - offset 1 ; text Grid Heights [ NUM ] = y Center - offset 2 ; text Grid Widths [ NUM ] = x Center - offset 2 ; text Grid Heights [ NUM ] = y Center - offset 3 ; text Grid Widths [ NUM ] = x Center - offset 3 ; text Grid Heights [ NUM ] = y Center ; text Grid Widths [ NUM ] = x Center ; text Grid Heights [ NUM ] = y Center + offset 3 ; text Grid Widths [ NUM ] = x Center + offset 3 ; text Grid Heights [ NUM ] = y Center + offset 2 ; text Grid Widths [ NUM ] = x Center + offset 2 ; text Grid Heights [ NUM ] = y Center + offset 1 ; text Grid Widths [ NUM ] = x Center + offset 1 ; }
public boolean is Greater Then Or Equal To ( Percent Percent ) { assert Defined ( ) ; Big Decimal this Value = not Null ( this ) ; Big Decimal parameter = not Null ( Percent ) ; return ( this Value . compare To ( parameter ) >= NUM ) ; }
protected void paint Cell ( Graphics g , int row , Rectangle row Bounds , List Cell Renderer cell Renderer , List Model data Model , List Selection Model sel Model , int lead Index ) { Object value = data Model . get Element At ( row ) ; boolean cell Has Focus = list . has Focus ( ) && ( row == lead Index ) ; boolean is Selected = sel Model . is Selected Index ( row ) ; Component renderer Component = cell Renderer . get List Cell Renderer Component ( list , value , row , is Selected , cell Has Focus ) ; int cx = row Bounds . x ; int cy = row Bounds . y ; int cw = row Bounds . width ; int ch = row Bounds . height ; if ( is File List ) { int w = Math . min ( cw , renderer Component . get Preferred Size ( ) . width + NUM ) ; if ( ! is Left To Right ) { cx += ( cw - w ) ; } cw = w ; } renderer Pane . paint Component ( g , renderer Component , list , cx , cy , cw , ch , BOOL ) ; }
void add And Keep Dirty Status ( Set < File > folders To Share , Set < File > folders To Exclude ) { for ( File folder : folders To Share ) { directory Panel . add Root ( folder ) ; } directory Panel . add Folders To Exclude ( folders To Exclude ) ; }
private String create Non CG Srdf Pair Steps On Populated Group ( List < Volume Descriptor > source Descriptors , List < Volume Descriptor > target Descriptors , Remote Director Group group , Map < URI , Volume > uri Volume Map , String wait For , Workflow workflow ) { Storage System system = db Client . query Object ( Storage System . class , group . get Source Storage System Uri ( ) ) ; URI vpool Change Uri = get Virtual Pool Change Volume ( source Descriptors ) ; log . info ( STRING , vpool Change Uri ) ; List < URI > source UR Is = Volume Descriptor . get Volume UR Is ( source Descriptors ) ; List < URI > target UR Is = new Array List < > ( ) ; for ( URI source URI : source UR Is ) { Volume source = uri Volume Map . get ( source URI ) ; String Set srdf Targets = source . get Srdf Targets ( ) ; for ( String target Str : srdf Targets ) { URI target URI = URI . create ( target Str ) ; target UR Is . add ( target URI ) ; } } Method suspend Group Method = suspend SRDF Group Method ( system . get Id ( ) , group , source UR Is , target UR Is ) ; Method resume Rollback Method = resume SRDF Group Method ( system . get Id ( ) , group , source UR Is , target UR Is ) ; String suspend Group Step = workflow . create Step ( CREATE SRDF ACTIVE VOLUME PAIR STEP GROUP , SUSPEND SRDF MIRRORS STEP DESC , wait For , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , suspend Group Method , resume Rollback Method , null ) ; Method create List Method = create List Replicas Method ( system . get Id ( ) , source UR Is , target UR Is , vpool Change Uri , BOOL ) ; Method rollback Method = rollback SRDF Links Method ( system . get Id ( ) , source UR Is , target UR Is , BOOL ) ; String create List Replica Step = workflow . create Step ( CREATE SRDF ACTIVE VOLUME PAIR STEP GROUP , CREATE SRDF ACTIVE VOLUME PAIR STEP DESC , suspend Group Step , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , create List Method , rollback Method , null ) ; Method resume Group Method = resume SRDF Group Method ( system . get Id ( ) , group , source UR Is , target UR Is ) ; String resume Group Step = workflow . create Step ( CREATE SRDF ACTIVE VOLUME PAIR STEP GROUP , RESUME SRDF MIRRORS STEP DESC , create List Replica Step , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , resume Group Method , rollback Method Null Method ( ) , null ) ; return resume Group Step ; }
private void kick Off ( Team offense ) { if ( game Time <= NUM ) return ; else { if ( game Time < NUM && ( ( game Poss && ( away Score - home Score ) <= NUM && ( away Score - home Score ) > NUM ) || ( ! game Poss && ( home Score - away Score ) <= NUM && ( home Score - away Score ) > NUM ) ) ) { if ( offense . get K ( NUM ) . rat Kick Fum * Math . random ( ) > NUM || Math . random ( ) < NUM ) { game Event Log += get Event Prefix ( ) + offense . abbr + STRING + offense . get K ( NUM ) . name + STRING + offense . abbr + STRING ; } else { game Event Log += get Event Prefix ( ) + offense . abbr + STRING + offense . get K ( NUM ) . name + STRING ; game Poss = ! game Poss ; } game Yard Line = NUM ; game Down = NUM ; game Yards Need = NUM ; game Time -= NUM + NUM * Math . random ( ) ; } else { game Yard Line = ( int ) ( NUM - ( offense . get K ( NUM ) . rat Kick Pow + NUM - NUM * Math . random ( ) ) ) ; if ( game Yard Line <= NUM ) game Yard Line = NUM ; game Down = NUM ; game Yards Need = NUM ; game Poss = ! game Poss ; } game Time -= NUM * Math . random ( ) ; } }
public static final byte [ ] inflate ( byte [ ] in ) throws IO Exception { Byte Array Output Stream out Stream = new Byte Array Output Stream ( EXPECTED COMPRESSION RATIO * in . length ) ; Inflater Input Stream in Stream = new Inflater Input Stream ( new Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [ BUF SIZE ] ; while ( BOOL ) { int size = in Stream . read ( buf ) ; if ( size <= NUM ) break ; out Stream . write ( buf , NUM , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
private void process ( double [ ] data , double min , double max , Kernel Density Function kernel , int window , double epsilon ) { dens = new double [ data . length ] ; var = new double [ data . length ] ; double halfwidth = ( ( max - min ) / window ) * NUM ; for ( int current = NUM ; current < data . length ; current ++ ) { double value = NUM ; for ( int i = current ; i >= NUM ; i -- ) { double delta = Math . abs ( data [ i ] - data [ current ] ) / halfwidth ; final double contrib = kernel . density ( delta ) ; value += contrib ; if ( contrib < epsilon ) { break ; } } for ( int i = current + NUM ; i < data . length ; i ++ ) { double delta = Math . abs ( data [ i ] - data [ current ] ) / halfwidth ; final double contrib = kernel . density ( delta ) ; value += contrib ; if ( contrib < epsilon ) { break ; } } double realwidth = ( Math . min ( data [ current ] + halfwidth , max ) - Math . max ( min , data [ current ] - halfwidth ) ) ; double weight = realwidth / ( NUM * halfwidth ) ; dens [ current ] = value / ( data . length * realwidth * NUM ) ; var [ current ] = NUM / weight ; } }
public static Socket create Socket ( Inet Address address , int port ) throws IO Exception { Socket socket = null ; set Keystore ( ) ; SSL Socket Factory f = ( SSL Socket Factory ) SSL Socket Factory . get Default ( ) ; SSL Socket secure Socket = ( SSL Socket ) f . create Socket ( ) ; secure Socket . connect ( new Inet Socket Address ( address , port ) , Sys Properties . SOCKET CONNECT TIMEOUT ) ; secure Socket . set Enabled Protocols ( disable SSL ( secure Socket . get Enabled Protocols ( ) ) ) ; if ( Sys Properties . ENABLE ANONYMOUS TLS ) { String [ ] list = enable Anonymous ( secure Socket . get Enabled Cipher Suites ( ) , secure Socket . get Supported Cipher Suites ( ) ) ; secure Socket . set Enabled Cipher Suites ( list ) ; } socket = secure Socket ; return socket ; }
public static final void decode ( Input Stream is , Output Stream os ) throws Base 64 Decoding Exception , IO Exception { byte b1 = NUM , b2 = NUM , b3 = NUM , b4 = NUM ; int index = NUM ; byte [ ] data = new byte [ NUM ] ; int read ; while ( ( read = is . read ( ) ) > NUM ) { byte readed = ( byte ) read ; if ( is White Space ( readed ) ) { continue ; } if ( is Pad ( readed ) ) { data [ index ++ ] = readed ; if ( index == NUM ) { data [ index ++ ] = ( byte ) is . read ( ) ; } break ; } if ( ( data [ index ++ ] = readed ) == - NUM ) { throw new Base 64 Decoding Exception ( STRING ) ; } if ( index != NUM ) { continue ; } index = NUM ; b1 = base 64 Alphabet [ data [ NUM ] ] ; b2 = base 64 Alphabet [ data [ NUM ] ] ; b3 = base 64 Alphabet [ data [ NUM ] ] ; b4 = base 64 Alphabet [ data [ NUM ] ] ; os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ) ; os . write ( ( byte ) ( b3 << NUM | b4 ) ) ; } byte d1 = data [ NUM ] , d2 = data [ NUM ] , d3 = data [ NUM ] , d4 = data [ NUM ] ; b1 = base 64 Alphabet [ d1 ] ; b2 = base 64 Alphabet [ d2 ] ; b3 = base 64 Alphabet [ d3 ] ; b4 = base 64 Alphabet [ d4 ] ; if ( ( b3 == - NUM ) || ( b4 == - NUM ) ) { if ( is Pad ( d3 ) && is Pad ( d4 ) ) { if ( ( b2 & NUM ) != NUM ) { throw new Base 64 Decoding Exception ( STRING ) ; } os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; } else if ( ! is Pad ( d3 ) && is Pad ( d4 ) ) { b3 = base 64 Alphabet [ d3 ] ; if ( ( b3 & NUM ) != NUM ) { throw new Base 64 Decoding Exception ( STRING ) ; } os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ) ; } else { throw new Base 64 Decoding Exception ( STRING ) ; } } else { os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ) ; os . write ( ( byte ) ( b3 << NUM | b4 ) ) ; } }
public void update V Vset ( String volume CG Name , String vol Name , int action Value ) throws Exception { log . info ( STRING ) ; Client Response client Resp = null ; final String path = Message Format . format ( URI UPDATE CG , volume CG Name ) ; String payload = STRING + action Value + STRING + vol Name + STRING ; log . info ( STRING , path , payload ) ; try { client Resp = put ( path , payload ) ; if ( client Resp == null ) { log . error ( STRING ) ; throw new HP 3 PAR Exception ( STRING ) ; } else if ( client Resp . get Status ( ) != NUM ) { String err Resp = get Response Details ( client Resp ) ; throw new HP 3 PAR Exception ( err Resp ) ; } else { log . info ( STRING ) ; } } catch ( Exception e ) { throw e ; } finally { if ( client Resp != null ) { client Resp . close ( ) ; } log . info ( STRING ) ; } }
private boolean is Valid State ( String key ) { if ( key == null ) { return BOOL ; } if ( key . equals ( rbean . get String ( STRING ) ) || key . equals ( rbean . get String ( STRING ) ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( key + STRING ) ; } return BOOL ; } for ( int i = NUM ; i < valid Key . length ; i ++ ) { if ( key . equals ( valid Key [ i ] ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( key + STRING ) ; } return BOOL ; } } if ( log . is Debug Enabled ( ) ) { log . debug ( key + STRING ) ; } return BOOL ; }
public boolean is Expired ( final Date now ) { return ( cookie Expiry Date != null && cookie Expiry Date . get Time ( ) <= now . get Time ( ) ) ; }
private int add Labels Internal ( GL 10 gl , Paint text Paint , boolean draw To Canvas , Label Data [ ] labels ) { int u = NUM ; int v = NUM ; int line Height = NUM ; for ( Label Data label : labels ) { int ascent = NUM ; int descent = NUM ; int measured Text Width = NUM ; int height = NUM ; int width = NUM ; int font Size = label . get Font Size ( ) ; do { text Paint . set Color ( NUM | label . get Color ( ) ) ; text Paint . set Text Size ( font Size * m Res . get Display Metrics ( ) . density ) ; ascent = ( int ) Math . ceil ( - text Paint . ascent ( ) ) ; descent = ( int ) Math . ceil ( text Paint . descent ( ) ) ; measured Text Width = ( int ) Math . ceil ( text Paint . measure Text ( label . get Text ( ) ) ) ; height = ascent + descent ; width = measured Text Width ; font Size -- ; } while ( font Size > NUM && width > m Res . get Display Metrics ( ) . width Pixels ) ; int next U ; if ( u + width > m Strike Width ) { u = NUM ; next U = width ; v += line Height ; line Height = NUM ; } else { next U = u + width ; } line Height = Math . max ( line Height , height ) ; if ( v + line Height > m Strike Height && draw To Canvas ) { throw new Illegal Argument Exception ( STRING ) ; } int v Base = v + ascent ; if ( draw To Canvas ) { m Canvas . draw Text ( label . get Text ( ) , u , v Base , text Paint ) ; label . set Texture Data ( width , height , u , v + height , width , - height , m Texel Width , m Texel Height ) ; } u = next U ; } return v + line Height ; }
private void create Map When Needed ( ) { if ( is Map Initialized ) { return ; } if ( resource Bundle != null ) { Set < String > set = resource Bundle . key Set ( ) ; top Level Map = new Hash Map < String , Object > ( set . size ( ) ) ; for ( String key : set ) { Object value = resource Bundle . get Object ( key ) ; top Level Map . put ( key , value ) ; } } else { top Level Map = new Hash Map < String , Object > ( NUM ) ; } top Level Map . put ( STRING , resource Bundle ) ; is Map Initialized = BOOL ; }
public void put All ( Tungsten Properties props ) { properties . put All ( props . map ( ) ) ; }
public int next Int ( ) { int ret = counter . get And Increment ( ) ; set Last Int ( ret ) ; return ret ; }
private Bitmap process Bitmap ( String data ) { if ( Build Config . DEBUG ) { Log . d ( TAG , STRING + data ) ; } final String key = Image Cache . hash Key For Disk ( data ) ; File Descriptor file Descriptor = null ; File Input Stream file Input Stream = null ; Disk Lru Cache . Snapshot snapshot ; synchronized ( m Http Disk Cache Lock ) { while ( m Http Disk Cache Starting ) { try { m Http Disk Cache Lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } if ( m Http Disk Cache != null ) { try { snapshot = m Http Disk Cache . get ( key ) ; if ( snapshot == null ) { if ( Build Config . DEBUG ) { Log . d ( TAG , STRING ) ; } Disk Lru Cache . Editor editor = m Http Disk Cache . edit ( key ) ; if ( editor != null ) { if ( download Url To Stream ( data , editor . new Output Stream ( DISK CACHE INDEX ) ) ) { editor . commit ( ) ; } else { editor . abort ( ) ; } } snapshot = m Http Disk Cache . get ( key ) ; } if ( snapshot != null ) { file Input Stream = ( File Input Stream ) snapshot . get Input Stream ( DISK CACHE INDEX ) ; file Descriptor = file Input Stream . get FD ( ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STRING + e ) ; } catch ( Illegal State Exception e ) { Log . e ( TAG , STRING + e ) ; } finally { if ( file Descriptor == null && file Input Stream != null ) { try { file Input Stream . close ( ) ; } catch ( IO Exception e ) { } } } } } Bitmap bitmap = null ; if ( file Descriptor != null ) { bitmap = decode Sampled Bitmap From Descriptor ( file Descriptor , m Image Width , m Image Height , get Image Cache ( ) ) ; } if ( file Input Stream != null ) { try { file Input Stream . close ( ) ; } catch ( IO Exception e ) { } } return bitmap ; }
public static Pair < String , String > parse Title And Date In Brackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( NUM ) , m . group ( NUM ) ) ; } return new Pair < > ( title , null ) ; }
private View fill From Selection ( int selected Left , int children Left , int children Right ) { int fading Edge Length = get Horizontal Fading Edge Length ( ) ; final int selected Position = m Selected Position ; View sel ; final int left Selection Pixel = get Left Selection Pixel ( children Left , fading Edge Length , selected Position ) ; final int right Selection Pixel = get Right Selection Pixel ( children Right , fading Edge Length , selected Position ) ; sel = make And Add View ( selected Position , selected Left , BOOL , m List Padding . top , BOOL ) ; if ( sel . get Right ( ) > right Selection Pixel ) { final int space Before = sel . get Left ( ) - left Selection Pixel ; final int space After = sel . get Right ( ) - right Selection Pixel ; final int offset = Math . min ( space Before , space After ) ; sel . offset Left And Right ( - offset ) ; } else if ( sel . get Left ( ) < left Selection Pixel ) { final int space Before = left Selection Pixel - sel . get Left ( ) ; final int space After = right Selection Pixel - sel . get Right ( ) ; final int offset = Math . min ( space Before , space After ) ; sel . offset Left And Right ( offset ) ; } fill Before And After ( sel , selected Position ) ; if ( ! m Stack From Right ) { correct Too Wide ( get Child Count ( ) ) ; } else { correct Too Small ( get Child Count ( ) ) ; } return sel ; }
public void commit Changes ( Synapse Group synapse Group ) { double percent Excitatory = Utils . double Parsable ( e Ratio ) / NUM ; if ( ! Double . is Na N ( percent Excitatory ) ) synapse Group . set Excitatory Ratio ( percent Excitatory ) ; excitatory Randomizer Panel . commit Changes ( ) ; inhibitory Randomizer Panel . commit Changes ( ) ; synapse Group . set Excitatory Randomizer ( ex Randomizer ) ; synapse Group . set Inhibitory Randomizer ( in Randomizer ) ; }
public void root Added ( ISVN Repository Location root ) { Iterator it = listeners . iterator ( ) ; while ( it . has Next ( ) ) { I Repository Listener listener = ( I Repository Listener ) it . next ( ) ; listener . repository Added ( root ) ; } }
private double [ ] compute Shortest Path Lenghts ( int p Start Node , double p Shortest Path Length Sum , double p Max Path Length , Set < Integer > p Was Source ) { Set < Integer > already Expanded = new Hash Set < Integer > ( ) ; List < int [ ] > queue = new Array List < int [ ] > ( ) ; int [ ] inner List = new int [ NUM ] ; inner List [ NUM ] = p Start Node ; inner List [ NUM ] = NUM ; queue . add ( inner List ) ; while ( ! queue . is Empty ( ) ) { int [ ] queue Element = queue . get ( NUM ) ; int current Node = queue Element [ NUM ] ; int distance = queue Element [ NUM ] ; queue . remove ( NUM ) ; if ( ! already Expanded . contains ( current Node ) ) { already Expanded . add ( current Node ) ; if ( ! p Was Source . contains ( current Node ) ) { p Shortest Path Length Sum += distance ; if ( distance > p Max Path Length ) { p Max Path Length = distance ; } } Set < Integer > neighbors = get Neighbors ( current Node ) ; for ( int neighbor : neighbors ) { if ( ! already Expanded . contains ( neighbor ) ) { int [ ] tmp List = new int [ NUM ] ; tmp List [ NUM ] = neighbor ; tmp List [ NUM ] = ( distance + NUM ) ; queue . add ( tmp List ) ; } } } } double return Array [ ] = { p Shortest Path Length Sum , p Max Path Length } ; return return Array ; }
protected void add Message Processor ( Message Processor new Message Processor ) throws IO Exception { synchronized ( message Processors ) { message Processors . add ( new Message Processor ) ; } }
public void action Performed ( Action Event e ) { Object source = e . get Source ( ) ; String command = e . get Action Command ( ) ; String inter String ; Paint tmp Paint ; if ( command == Line Color Command && line Paint instanceof Color ) { inter String = i18 n . get ( Drawing Attributes . class , STRING , STRING ) ; tmp Paint = get New Paint ( ( Component ) source , inter String , ( Color ) line Paint ) ; if ( tmp Paint != null ) { set Line Paint ( tmp Paint ) ; } } else if ( command == Fill Color Command && fill Paint instanceof Color ) { inter String = i18 n . get ( Drawing Attributes . class , STRING , STRING ) ; tmp Paint = get New Paint ( ( Component ) source , inter String , ( Color ) fill Paint ) ; if ( tmp Paint != null ) { set Fill Paint ( tmp Paint ) ; } } else if ( command == Select Color Command && select Paint instanceof Color ) { inter String = i18 n . get ( Drawing Attributes . class , STRING , STRING ) ; tmp Paint = get New Paint ( ( Component ) source , inter String , ( Color ) select Paint ) ; if ( tmp Paint != null ) { set Select Paint ( tmp Paint ) ; } } else if ( command == Matting Color Command && matting Paint instanceof Color ) { inter String = i18 n . get ( Drawing Attributes . class , STRING , STRING ) ; tmp Paint = get New Paint ( ( Component ) source , inter String , ( Color ) matting Paint ) ; if ( tmp Paint != null ) { set Matting Paint ( tmp Paint ) ; } } else if ( command == Matted Command ) { set Matted ( matted Enabled Item . get State ( ) ) ; } else { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + command ) ; } } }
private void prefetch Statement Data ( Statement Data data ) throws Replicator Exception { statements ++ ; String sql Query = null ; try { if ( data . get Query ( ) != null ) sql Query = data . get Query ( ) ; else { try { sql Query = new String ( data . get Query As Bytes ( ) , data . get Charset ( ) ) ; } catch ( Unsupported Encoding Exception e ) { sql Query = new String ( data . get Query As Bytes ( ) ) ; } } statement . clear Batch ( ) ; boolean has Transform = BOOL ; boolean fetch Secondary Indexes = BOOL ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + sql Query ) ; } Sql Operation parsing = ( Sql Operation ) data . get Parsing Metadata ( ) ; if ( parsing . get Operation ( ) == Sql Operation . INSERT ) { Matcher m = insert . matcher ( sql Query ) ; if ( m . matches ( ) ) { if ( m . group ( NUM ) != null ) sql Query = m . group ( NUM ) ; else sql Query = m . group ( NUM ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; transformed ++ ; has Transform = BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; } } else if ( parsing . get Operation ( ) == Sql Operation . DELETE ) { Matcher m = delete . matcher ( sql Query ) ; if ( m . matches ( ) ) { sql Query = STRING + m . group ( NUM ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; transformed ++ ; has Transform = BOOL ; fetch Secondary Indexes = BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; } } else if ( parsing . get Operation ( ) == Sql Operation . UPDATE ) { Matcher m = update . matcher ( sql Query ) ; if ( m . matches ( ) ) { sql Query = STRING + m . group ( NUM ) + STRING + m . group ( NUM ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; transformed ++ ; has Transform = BOOL ; fetch Secondary Indexes = BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; } } else if ( parsing . get Operation ( ) == Sql Operation . SET ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; has Transform = BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; } String schema = data . get Default Schema ( ) ; Long timestamp = data . get Timestamp ( ) ; List < Repl Option > options = data . get Options ( ) ; apply Use Schema ( schema ) ; apply Set Timestamp ( timestamp ) ; apply Session Variables ( options ) ; try { statement . execute Batch ( ) ; } catch ( SQL Warning e ) { String msg = STRING + data . to String ( ) + STRING + e . get Message ( ) ; logger . warn ( msg ) ; } catch ( SQL Exception e ) { if ( data . get Error Code ( ) == NUM ) { String msg = STRING + data . to String ( ) ; SQL Exception sql Exception = new SQL Exception ( msg ) ; sql Exception . init Cause ( e ) ; throw sql Exception ; } } finally { statement . clear Batch ( ) ; } Result Set rs = null ; if ( has Transform ) { if ( prefetch Row Limit > NUM ) sql Query = prefetch Transformer . add Limit To Query ( sql Query , prefetch Row Limit ) ; try { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; rs = statement . execute Query ( sql Query ) ; prefetched Queries ++ ; if ( fetch Secondary Indexes ) { prefetch Indexes For Statement ( data , parsing , rs ) ; } } finally { close Result Set ( rs ) ; } } } catch ( SQL Exception e ) { log Failed Statement SQL ( data . get Query ( ) , e ) ; throw new Applier Exception ( e ) ; } }
private void remove Gaps ( int nodes Level [ ] ) { int temp = m nodes . size ( ) ; int temp 2 = graph Matrix [ NUM ] . length , temp Cnt = NUM ; for ( int n = NUM ; n < temp ; n ++ ) { for ( int i = NUM ; i < temp 2 ; i ++ ) { int len = graph Matrix . length ; if ( graph Matrix [ n ] [ i ] > NUM ) { if ( nodes Level [ i ] > nodes Level [ n ] + NUM ) { int temp Matrix [ ] [ ] = new int [ graph Matrix . length + ( nodes Level [ i ] - nodes Level [ n ] - NUM ) ] [ graph Matrix . length + ( nodes Level [ i ] - nodes Level [ n ] - NUM ) ] ; int level = nodes Level [ n ] + NUM ; copy Matrix ( graph Matrix , temp Matrix ) ; String s1 = new String ( STRING + temp Cnt ++ ) ; m nodes . add ( new Graph Node ( s1 , s1 , SINGULAR DUMMY ) ) ; int temp 3 [ ] = new int [ node Levels [ level ] . length + NUM ] ; System . arraycopy ( node Levels [ level ] , NUM , temp 3 , NUM , node Levels [ level ] . length ) ; temp 3 [ temp 3 . length - NUM ] = m nodes . size ( ) - NUM ; node Levels [ level ] = temp 3 ; level ++ ; int k ; for ( k = len ; k < len + nodes Level [ i ] - nodes Level [ n ] - NUM - NUM ; k ++ ) { String s2 = new String ( STRING + temp Cnt ) ; m nodes . add ( new Graph Node ( s2 , s2 , SINGULAR DUMMY ) ) ; temp 3 = new int [ node Levels [ level ] . length + NUM ] ; System . arraycopy ( node Levels [ level ] , NUM , temp 3 , NUM , node Levels [ level ] . length ) ; temp 3 [ temp 3 . length - NUM ] = m nodes . size ( ) - NUM ; node Levels [ level ++ ] = temp 3 ; temp Matrix [ k ] [ k + NUM ] = temp Matrix [ n ] [ i ] ; temp Cnt ++ ; if ( k > len ) { temp Matrix [ k ] [ k - NUM ] = - NUM * temp Matrix [ n ] [ i ] ; } } temp Matrix [ k ] [ i ] = temp Matrix [ n ] [ i ] ; temp Matrix [ n ] [ len ] = temp Matrix [ n ] [ i ] ; temp Matrix [ len ] [ n ] = - NUM * temp Matrix [ n ] [ i ] ; temp Matrix [ i ] [ k ] = - NUM * temp Matrix [ n ] [ i ] ; if ( k > len ) { temp Matrix [ k ] [ k - NUM ] = - NUM * temp Matrix [ n ] [ i ] ; } temp Matrix [ n ] [ i ] = NUM ; temp Matrix [ i ] [ n ] = NUM ; graph Matrix = temp Matrix ; } else { graph Matrix [ i ] [ n ] = - NUM * graph Matrix [ n ] [ i ] ; } } } } }
public Attr Set ( Attr [ ] attrs ) { int size = attrs . length ; attrs = new Array List ( size ) ; for ( int i = NUM ; i < size ; i ++ ) { attrs . add ( attrs [ i ] ) ; } }
public void load Tree ( Input Stream tree Stream ) throws IO Exception , Mary Configuration Exception { Mary CART Reader cart Reader = new Mary CART Reader ( ) ; this . tree = cart Reader . load From Stream ( tree Stream ) ; this . feature Definition = tree . get Feature Definition ( ) ; this . index Predicted Feature = feature Definition . get Feature Index ( PREDICTED STRING FEATURENAME ) ; this . convert To Lowercase = BOOL ; Properties props = tree . get Properties ( ) ; if ( props == null ) throw new Illegal Argument Exception ( STRING ) ; convert To Lowercase = Boolean . parse Boolean ( props . get Property ( STRING ) ) ; context = Integer . parse Int ( props . get Property ( STRING ) ) ; }
public void remove All Listeners ( ) { listeners . clear ( ) ; }
public String decrypt String ( String s Cipher Text ) { int n Len = ( s Cipher Text . length ( ) > > NUM ) & ~ NUM ; if ( n Len < Blowfish ECB . BLOCKSIZE ) return null ; byte [ ] cbciv = new byte [ Blowfish ECB . BLOCKSIZE ] ; int n Num Of Bytes = Bin Converter . bin Hex To Bytes ( s Cipher Text , cbciv , NUM , NUM , Blowfish ECB . BLOCKSIZE ) ; if ( n Num Of Bytes < Blowfish ECB . BLOCKSIZE ) return null ; m bfish . set CBCIV ( cbciv ) ; n Len -= Blowfish ECB . BLOCKSIZE ; if ( n Len == NUM ) return STRING ; byte [ ] buf = new byte [ n Len ] ; n Num Of Bytes = Bin Converter . bin Hex To Bytes ( s Cipher Text , buf , Blowfish ECB . BLOCKSIZE * NUM , NUM , n Len ) ; if ( n Num Of Bytes < n Len ) return null ; m bfish . decrypt ( buf ) ; int n Pad Byte = buf [ buf . length - NUM ] & NUM ; if ( ( n Pad Byte > NUM ) || ( n Pad Byte < NUM ) ) n Pad Byte = NUM ; n Num Of Bytes -= n Pad Byte ; if ( n Num Of Bytes < NUM ) return STRING ; return Bin Converter . byte Array To UNC String ( buf , NUM , n Num Of Bytes ) ; }
public static Trellis order Trellis ( Trellis trel , double I [ ] [ ] , Random rand ) { int L = I . length ; int Y [ ] = new int [ L ] ; Array List < Integer > list = new Array List < Integer > ( ) ; for ( int i : trel . indices ) { list . add ( new Integer ( i ) ) ; } Y [ NUM ] = list . remove ( rand . next Int ( L ) ) ; for ( int j = NUM ; j < L ; j ++ ) { double max w = - NUM ; int j = - NUM ; for ( int j prop : list ) { double w = trel . weight ( Y , j , j prop , I ) ; if ( w >= max w ) { max w = w ; j = j prop ; } } list . remove ( new Integer ( j ) ) ; Y [ j ] = j ; } trel = new Trellis ( Y , trel . WIDTH , trel . TYPE ) ; return trel ; }
@ Override public double [ ] [ ] process Ids ( DBI Ds ids , Relation < ? extends Number Vector > relation ) { final int dim = Relation Util . dimensionality ( relation ) ; final Covariance Matrix cmat = new Covariance Matrix ( dim ) ; final Centroid centroid = Centroid . make ( relation , ids ) ; double maxdist = NUM ; double stddev = NUM ; { for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; stddev += distance * distance ; if ( distance > maxdist ) { maxdist = distance ; } } if ( maxdist == NUM ) { maxdist = NUM ; } stddev = Math . sqrt ( stddev / ids . size ( ) ) ; } for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; double weight = weightfunction . get Weight ( distance , maxdist , stddev ) ; cmat . put ( obj , weight ) ; } return cmat . destroy To Naive Matrix ( ) ; }
public Print Service Attribute Event ( Print Service source , Print Service Attribute Set attributes ) { super ( source ) ; this . attributes = Attribute Set Utilities . unmodifiable View ( attributes ) ; }
public static void wait For Bridge And UI Idle ( React Bridge Idle Signaler idle Signaler , final React Context react Context , long timeout Ms ) { Ui Thread Util . assert Not On Ui Thread ( ) ; long start Time = System Clock . uptime Millis ( ) ; wait Inner ( idle Signaler , timeout Ms ) ; long time To Wait = Math . max ( NUM , timeout Ms - ( System Clock . uptime Millis ( ) - start Time ) ) ; wait For Choreographer ( time To Wait ) ; wait For JS Idle ( react Context ) ; time To Wait = Math . max ( NUM , timeout Ms - ( System Clock . uptime Millis ( ) - start Time ) ) ; wait Inner ( idle Signaler , time To Wait ) ; time To Wait = Math . max ( NUM , timeout Ms - ( System Clock . uptime Millis ( ) - start Time ) ) ; wait For Choreographer ( time To Wait ) ; }
protected void calculate Fitness And Sort Population ( ) { logger . debug ( STRING + population . size ( ) + STRING ) ; Iterator < T > iterator = population . iterator ( ) ; while ( iterator . has Next ( ) ) { T c = iterator . next ( ) ; if ( is Finished ( ) ) { if ( c . is Changed ( ) ) iterator . remove ( ) ; } else { for ( Fitness Function < T > fitness Function : fitness Functions ) { fitness Function . get Fitness ( c ) ; notify Evaluation ( c ) ; } } } sort Population ( ) ; }
public Session ( ) { long uptime = System . current Time Millis ( ) ; Handler Thread thread = new Handler Thread ( STRING ) ; thread . start ( ) ; m Handler = new Handler ( thread . get Looper ( ) ) ; m Main Handler = new Handler ( Looper . get Main Looper ( ) ) ; m Timestamp = ( uptime / NUM ) << NUM & ( ( ( uptime - ( ( uptime / NUM ) * NUM ) ) > > NUM ) / NUM ) ; m Origin = STRING ; }
public List < Estratigrafia > listar ( ) { List < Estratigrafia > dados Estratigrafia = new Array List < > ( ) ; try { String sql = STRING ; stm = conector . prepare Statement ( sql ) ; rs = stm . execute Query ( sql ) ; while ( rs . next ( ) ) { Estratigrafia estratigrafia = new Estratigrafia ( rs . get Int ( NUM ) , rs . get String ( NUM ) , rs . get String ( NUM ) , rs . get String ( NUM ) ) ; dados Estratigrafia . add ( estratigrafia ) ; } stm . close ( ) ; rs . close ( ) ; } catch ( SQL Exception ex ) { Mensagem . erro ( STRING + ex ) ; } return dados Estratigrafia ; }
private static void remove Branches After Gotos ( Basic Block bb ) { Instruction first Goto = null ; Instruction end = bb . last Real Instruction ( ) ; for ( Enumeration < Instruction > branches = bb . enumerate Branch Instructions ( ) ; branches . has More Elements ( ) ; ) { Instruction s = branches . next Element ( ) ; if ( Goto . conforms ( s ) ) { first Goto = s ; break ; } } if ( first Goto != null ) { Enumeration < Instruction > ie = IR Enumeration . forward Intra Block IE ( first Goto , end ) ; ie . next Element ( ) ; while ( ie . has More Elements ( ) ) { Instruction s = ie . next Element ( ) ; if ( Guard Result Carrier . conforms ( s ) ) { insert True Guard ( s , Guard Result Carrier . get Guard Result ( s ) ) ; } s . remove ( ) ; } } }
public int [ ] value Array ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; } System . arraycopy ( values , NUM , array , NUM , count ) ; return array ; }
private void prepare Directories ( File file , Boolean create Path If Missing , Boolean remove Old Output ) { File output Directory ; if ( file . is Directory ( ) ) { output Directory = file ; } else { output Directory = file . get Parent File ( ) ; } if ( ! output Directory . exists ( ) && create Path If Missing ) { if ( ! output Directory . mkdirs ( ) ) { logger . info ( STRING + output Directory ) ; } } if ( remove Old Output ) { try { File Utils . clean Directory ( output Directory ) ; } catch ( IO Exception ioe ) { logger . error ( STRING + output Directory , ioe ) ; } } }
public static List < Shape Record > cubic To Quadratic ( final double start X , final double start Y , final double control 1 X , final double control 1 Y , final double control 2 X , final double control 2 Y , final double anchor X , final double anchor Y ) { double ratio = NUM / NUM ; double pax = start X + ( ( control 1 X - start X ) * ratio ) ; double pay = start Y + ( ( control 1 Y - start Y ) * ratio ) ; double pbx = anchor X + ( ( control 2 X - anchor X ) * ratio ) ; double pby = anchor Y + ( ( control 2 Y - anchor Y ) * ratio ) ; double dx = ( anchor X - start X ) / NUM ; double dy = ( anchor Y - start Y ) / NUM ; ratio = NUM / NUM ; double c1 x = start X + ( ( control 1 X - start X ) * ratio ) ; double c1 y = start Y + ( ( control 1 Y - start Y ) * ratio ) ; double c2 x = pax + ( ( pbx - pax ) * ratio ) ; double c2 y = pay + ( ( pby - pay ) * ratio ) ; c2 x = c2 x - dx ; c2 y = c2 y - dy ; double c3 x = pbx + ( ( pax - pbx ) * ratio ) ; double c3 y = pby + ( ( pay - pby ) * ratio ) ; c3 x = c3 x + dx ; c3 y = c3 y + dy ; double c4 x = anchor X + ( ( control 2 X - anchor X ) * ratio ) ; double c4 y = anchor Y + ( ( control 2 Y - anchor Y ) * ratio ) ; double a1 x = ( c1 x + c2 x ) / NUM ; double a1 y = ( c1 y + c2 y ) / NUM ; double a2 x = ( pax + pbx ) / NUM ; double a2 y = ( pay + pby ) / NUM ; double a3 x = ( c3 x + c4 x ) / NUM ; double a3 y = ( c3 y + c4 y ) / NUM ; List < Shape Record > shape Records = new Array List < Shape Record > ( NUM ) ; shape Records . add ( curved Edge ( start X , start Y , c1 x , c1 y , a1 x , a1 y ) ) ; shape Records . add ( curved Edge ( a1 x , a1 y , c2 x , c2 y , a2 x , a2 y ) ) ; shape Records . add ( curved Edge ( a2 x , a2 y , c3 x , c3 y , a3 x , a3 y ) ) ; shape Records . add ( curved Edge ( a3 x , a3 y , c4 x , c4 y , anchor X , anchor Y ) ) ; return shape Records ; }
public void wait For Frame ( int frame Number , String jump Label ) throws IO Exception { print ( STRING , new String [ ] { Integer . to String ( frame Number ) , STRING + jump Label + STRING } ) ; }
public void delete ( String name ) throws IO Exception { if ( name . equals Ignore Case ( ISSUER NAME ) ) { names = null ; } else { throw new IO Exception ( STRING + STRING ) ; } encode This ( ) ; }
public Geo Distance Builder add Range ( String key , double from , double to ) { ranges . add ( new Range ( key , from , to ) ) ; return this ; }
public static SOAP Message Document To SOAP Message ( Document doc ) throws SOAP Binding Exception { SOAP Message msg = null ; try { Mime Headers mime Headers = new Mime Headers ( ) ; mime Headers . add Header ( STRING , STRING ) ; String xmlstr = XML Utils . print ( doc ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + xmlstr ) ; } msg = message Factory . create Message ( mime Headers , new Byte Array Input Stream ( xmlstr . get Bytes ( SOAP Binding Constants . DEFAULT ENCODING ) ) ) ; } catch ( Exception e ) { debug . error ( STRING , e ) ; throw new SOAP Binding Exception ( e . get Message ( ) ) ; } return msg ; }
public static String unescape HTML ( String str ) { String Builder rtn = new String Builder ( ) ; int pos Start = - NUM ; int pos Finish = - NUM ; while ( ( pos Start = str . index Of ( STRING , pos Start ) ) != - NUM ) { int last = pos Finish + NUM ; pos Finish = str . index Of ( STRING , pos Start ) ; if ( pos Finish == - NUM ) break ; rtn . append ( str . substring ( last , pos Start ) ) ; if ( pos Start + NUM < pos Finish ) { rtn . append ( unescape HTML Entity ( str . substring ( pos Start + NUM , pos Finish ) ) ) ; } else { rtn . append ( STRING ) ; } pos Start = pos Finish + NUM ; } rtn . append ( str . substring ( pos Finish + NUM ) ) ; return rtn . to String ( ) ; }
public Base Matcher ( final Network Config config ) { if ( config == null ) { throw new Null Pointer Exception ( STRING ) ; } else { this . config = config ; } }
public static void update Media Notification For Tab ( Context context , int tab Id , boolean audio Capture , boolean video Capture , boolean audio Playback , String full Url ) { int media Type = get Media Type ( audio Capture , video Capture , audio Playback ) ; if ( ! should Start Service ( context , media Type , tab Id ) ) return ; Intent intent = new Intent ( context , Media Notification Service . class ) ; intent . put Extra ( NOTIFICATION ID EXTRA , tab Id ) ; String base Url = full Url ; try { URL url = new URL ( full Url ) ; base Url = url . get Protocol ( ) + STRING + url . get Host ( ) ; } catch ( Malformed URL Exception e ) { Log . w ( LOG TAG , STRING + full Url ) ; } intent . put Extra ( NOTIFICATION MEDIA URL EXTRA , base Url ) ; intent . put Extra ( NOTIFICATION MEDIA TYPE EXTRA , media Type ) ; context . start Service ( intent ) ; }
public long nswap ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public void draw Bitmap With Circle On Canvas ( Bitmap bitmap , Canvas canvas , Rect F source , @ Non Null Rect F dest ) { if ( bitmap == null ) { if ( get Style ( ) == SHAPE CIRCLE ) { canvas . draw Circle ( dest . center X ( ) , dest . center Y ( ) , Math . min ( dest . width ( ) , dest . height ( ) ) / NUM , m Solid Color Paint ) ; } else { final float corner Radius = get Calculated Corner Radius ( ) ; canvas . draw Round Rect ( dest , corner Radius , corner Radius , m Solid Color Paint ) ; } return ; } final Bitmap Shader shader = new Bitmap Shader ( bitmap , Shader . Tile Mode . CLAMP , Shader . Tile Mode . CLAMP ) ; m Matrix . reset ( ) ; switch ( get Scale Type ( ) ) { case CENTER CROP : { final float src Ratio = source . width ( ) / source . height ( ) ; final float dst Ratio = dest . width ( ) / dest . height ( ) ; if ( src Ratio > dst Ratio ) { m Temp Destination . top = dest . top ; m Temp Destination . bottom = dest . bottom ; final float dst Width = dest . height ( ) * src Ratio ; m Temp Destination . left = dest . center X ( ) - dst Width / NUM ; m Temp Destination . right = dest . center X ( ) + dst Width / NUM ; } else if ( src Ratio < dst Ratio ) { m Temp Destination . left = dest . left ; m Temp Destination . right = dest . right ; final float dst Height = dest . width ( ) / src Ratio ; m Temp Destination . top = dest . center Y ( ) - dst Height / NUM ; m Temp Destination . bottom = dest . center Y ( ) + dst Height / NUM ; } else { m Temp Destination . set ( dest ) ; } break ; } default : { m Temp Destination . set ( dest ) ; break ; } } m Matrix . set Rect To Rect ( source , m Temp Destination , Scale To Fit . CENTER ) ; shader . set Local Matrix ( m Matrix ) ; m Bitmap Paint . set Shader ( shader ) ; if ( m Border Enabled ) { final float inset = m Border Paint . get Stroke Width ( ) / NUM ; if ( get Style ( ) == SHAPE CIRCLE ) { final float circle Radius = Math . min ( dest . width ( ) , dest . height ( ) ) / NUM - inset / NUM ; canvas . draw Circle ( dest . center X ( ) , dest . center Y ( ) , circle Radius , m Bitmap Paint ) ; } else { final float corner Radius = get Calculated Corner Radius ( ) ; dest . inset ( inset , inset ) ; canvas . draw Round Rect ( dest , corner Radius , corner Radius , m Bitmap Paint ) ; dest . inset ( - inset , - inset ) ; } } else { if ( get Style ( ) == SHAPE CIRCLE ) { final float circle Radius = Math . min ( dest . width ( ) , dest . height ( ) ) / NUM ; canvas . draw Circle ( dest . center X ( ) , dest . center Y ( ) , circle Radius , m Bitmap Paint ) ; } else { final float corner Radius = get Calculated Corner Radius ( ) ; canvas . draw Round Rect ( dest , corner Radius , corner Radius , m Bitmap Paint ) ; } } }
public static List < Base Mqtt Message > process Message Log ( final List < Logged Mqtt Message > list , final Progress Updater progress , final long current , final long max ) { final List < Base Mqtt Message > mqtt Message List = new Array List < Base Mqtt Message > ( ) ; long item = NUM ; for ( final Logged Mqtt Message logged Message : list ) { if ( progress != null ) { if ( progress . is Cancelled ( ) ) { logger . info ( STRING ) ; return null ; } item ++ ; if ( item % NUM == NUM ) { progress . update ( current + item , max ) ; } } mqtt Message List . add ( convert To Base Mqtt Message ( logged Message ) ) ; } logger . info ( STRING , list . size ( ) ) ; return mqtt Message List ; }
public Profiler start Collecting ( ) { thread = new Thread ( this , STRING ) ; thread . set Daemon ( BOOL ) ; thread . start ( ) ; return this ; }
public static void write ( float lt , float ln , Image image , int image width , int image height , Link Properties properties , Data Output Stream dos ) throws IO Exception , Interrupted Exception { int [ ] pixels = new int [ image width * image height ] ; Pixel Grabber pixelgrabber = new Pixel Grabber ( image , NUM , NUM , image width , image height , pixels , NUM , image width ) ; pixelgrabber . grab Pixels ( ) ; Link Raster . write ( lt , ln , image width , image height , pixels , properties , dos ) ; }
public static String compress Chars ( String s , char c ) { int len = s . length ( ) ; String Builder sb = new String Builder ( len ) ; boolean was Char = BOOL ; for ( int i = NUM ; i < len ; i ++ ) { char c1 = s . char At ( i ) ; if ( c1 == c ) { if ( was Char ) { continue ; } was Char = BOOL ; } else { was Char = BOOL ; } sb . append ( c1 ) ; } if ( sb . length ( ) == len ) { return s ; } return sb . to String ( ) ; }
public static double magnitude ( final double x , final double y , final double z ) { return Math . sqrt ( x * x + y * y + z * z ) ; }
static Object send ( Object object , String method Name , Object [ ] parameters , Class < ? > object Class , Class < ? > [ ] parameter Types ) throws Security Exception , Illegal Argument Exception , Illegal Access Exception , Invocation Target Exception { try { if ( parameters == null ) { parameters = new Object [ ] { } ; } if ( parameter Types == null ) { parameter Types = new Class [ ] { } ; } Method method = object Class . get Declared Method ( method Name , parameter Types ) ; method . set Accessible ( BOOL ) ; return method . invoke ( object , parameters ) ; } catch ( No Such Method Exception e ) { throw new Data Support Exception ( Data Support Exception . no Such Method Exception ( object Class . get Simple Name ( ) , method Name ) ) ; } }
private static Properties create Properties 1 ( ) { Properties props = new Properties ( ) ; props . set Property ( MCAST PORT , STRING ) ; props . set Property ( LOCATORS , STRING ) ; return props ; }
public C Process List Panel ( final Process List process List ) { super ( new Border Layout ( ) ) ; m process List = process List ; final C Process List Model model = new C Process List Model ( process List ) ; m sorter = new Table Row Sorter < C Process List Model > ( model ) ; m table = new J Table ( model ) ; m table . set Selection Mode ( List Selection Model . SINGLE SELECTION ) ; m table . set Row Sorter ( m sorter ) ; final J Scroll Pane scroll Pane = new J Scroll Pane ( m table ) ; scroll Pane . set Border ( new Titled Border ( STRING ) ) ; add ( scroll Pane ) ; set Preferred Size ( new Dimension ( NUM , NUM ) ) ; }

private void add Pokemon To Favs ( Poke Model poke Model , Array List < Integer > list Of Fav Pokemon ) { if ( poke Model != null && list Of Fav Pokemon != null ) { int poke Num = poke Model . get Pokedex Num ( ) ; if ( list Of Fav Pokemon . contains ( poke Num ) ) { Typeface Utils . display Toast ( m Context , get String ( R . string . redundant fav pokemon msg ) , Typeface Utils . TOAST SHORT DURATION ) ; } else { Poke Cursor Manager . insert Pokemon In Db ( m Context , poke Num , Poke DB Contract . Favorite Pokemon Entry . TABLE NAME , Poke DB Contract . Favorite Pokemon Entry . COLUMN NUMBER ) ; Typeface Utils . display Toast ( m Context , get String ( R . string . add pokemon to favs msg ) , Typeface Utils . TOAST SHORT DURATION ) ; } } }
public void add Photo ( Photo Entity photo ) { photos . add ( photo ) ; }
public int compute Id ( Bit Set active Matches , I Read Block read Block ) { if ( name 2 id != null ) { final String name = read Block . get Read Name ( ) ; final Integer id = name 2 id . get ( name ) ; if ( id != null && id > NUM ) return id ; } if ( active Matches . cardinality ( ) == NUM ) return Id Mapper . NOHITS ID ; for ( int i = active Matches . next Set Bit ( NUM ) ; i != - NUM ; i = active Matches . next Set Bit ( i + NUM ) ) { I Match Block match = read Block . get Match Block ( i ) ; int id = match . get Id ( c Name ) ; if ( id > NUM ) return id ; } return Id Mapper . UNASSIGNED ID ; }
private int extract ( final int index , final byte a [ ] , final int offset , final int length ) { final Backing Buffer bb = this . bb ; final int delta = index % ratio ; final int start Pos = p [ index / ratio ] ; int pos , prev Array Pos , curr Len = NUM , actual Common ; int array Length = bb . read Int ( pos = start Pos ) ; if ( delta == NUM ) { pos = p [ index / ratio ] + count ( array Length ) ; bb . arraycopy ( pos , a , offset , Math . min ( length , array Length ) ) ; return array Length ; } int common = NUM ; for ( int i = NUM ; i < delta ; i ++ ) { prev Array Pos = pos + count ( array Length ) + ( i != NUM ? count ( common ) : NUM ) ; pos = prev Array Pos + array Length ; array Length = bb . read Int ( pos ) ; common = bb . read Int ( pos + count ( array Length ) ) ; actual Common = Math . min ( common , length ) ; if ( actual Common <= curr Len ) curr Len = actual Common ; else { bb . arraycopy ( prev Array Pos , a , curr Len + offset , actual Common - curr Len ) ; curr Len = actual Common ; } } if ( curr Len < length ) bb . arraycopy ( pos + count ( array Length ) + count ( common ) , a , curr Len + offset , Math . min ( array Length , length - curr Len ) ) ; return array Length + common ; }
public void fetch Entries ( Hash Map < Integer , Hash Set > bucket Keys , Versioned Object List values , Server Connection serv Conn ) throws IO Exception { int retry Attempts = calc Retry ( ) ; Retry Time Keeper retry Time = null ; Hash Map < Integer , Hash Set > failures = new Hash Map < Integer , Hash Set > ( bucket Keys ) ; Hash Map < Internal Distributed Member , Hash Map < Integer , Hash Set > > node To Buckets = new Hash Map < Internal Distributed Member , Hash Map < Integer , Hash Set > > ( ) ; while ( -- retry Attempts >= NUM && ! failures . is Empty ( ) ) { node To Buckets . clear ( ) ; update Node To Bucket Map ( node To Buckets , failures ) ; failures . clear ( ) ; Hash Map < Integer , Hash Set > local Buckets = node To Buckets . remove ( get My Id ( ) ) ; if ( local Buckets != null && ! local Buckets . is Empty ( ) ) { Set keys = new Hash Set ( ) ; for ( Integer id : local Buckets . key Set ( ) ) { keys . add All ( local Buckets . get ( id ) ) ; } if ( ! keys . is Empty ( ) ) { Base Command . append New Register Interest Response Chunk From Local ( this , values , STRING , keys , serv Conn ) ; } } Set < Integer > failed Set = handle Old Nodes ( node To Buckets , values , serv Conn ) ; if ( ! failed Set . is Empty ( ) ) { for ( Integer b Id : failed Set ) { failures . put ( b Id , bucket Keys . get ( b Id ) ) ; } update Node To Bucket Map ( node To Buckets , failures ) ; failures . clear ( ) ; } fetch Remote Entries ( node To Buckets , failures , values , serv Conn ) ; if ( ! failures . is Empty ( ) ) { if ( retry Time == null ) { retry Time = new Retry Time Keeper ( this . retry Timeout ) ; } if ( ! wait For Fetch Remote Entries Retry ( retry Time ) ) { break ; } } } if ( ! failures . is Empty ( ) ) { throw new Internal Gem Fire Exception ( STRING + failures . size ( ) + STRING + get Name ( ) + STRING ) ; } }
public void dump stack ( ) { if ( stack == null ) { debug message ( STRING ) ; return ; } debug message ( STRING ) ; for ( int i = NUM ; i < stack . size ( ) ; i ++ ) { debug message ( STRING + ( ( Symbol ) stack . element At ( i ) ) . sym + STRING + ( ( Symbol ) stack . element At ( i ) ) . parse state ) ; } debug message ( STRING ) ; }
@ Override protected List < Double > compute Relatedness ( Page page 1 , Page page 2 ) throws Wiki Api Exception { List < Double > relatedness Values = new Array List < Double > ( ) ; Set < Category > categories 1 = relatedness Utilities . get Categories ( page 1 ) ; Set < Category > categories 2 = relatedness Utilities . get Categories ( page 2 ) ; if ( categories 1 == null || categories 2 == null ) { return null ; } double depth Of Hierarchy = cat Graph . get Depth ( ) ; if ( depth Of Hierarchy == NUM ) { logger . info ( STRING ) ; return null ; } for ( Category cat 1 : categories 1 ) { for ( Category cat 2 : categories 2 ) { int path Length = cat Graph . get Taxonomically Bound Path Length In Edges ( cat 1 , cat 2 ) ; if ( path Length < NUM ) { continue ; } double relatedness = Math . log ( ( NUM * depth Of Hierarchy ) / ( path Length + NUM ) ) ; relatedness Values . add ( relatedness ) ; } } return relatedness Values ; }
public void download ( String remote File Name , File local File , long restart At , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { Output Stream output Stream = null ; try { output Stream = new File Output Stream ( local File , restart At > NUM ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { download ( remote File Name , output Stream , restart At , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public static Socket create Socket ( Inet Address address , int port ) throws IO Exception { Socket socket = null ; set Keystore ( ) ; SSL Socket Factory f = ( SSL Socket Factory ) SSL Socket Factory . get Default ( ) ; SSL Socket secure Socket = ( SSL Socket ) f . create Socket ( ) ; secure Socket . connect ( new Inet Socket Address ( address , port ) , Sys Properties . SOCKET CONNECT TIMEOUT ) ; secure Socket . set Enabled Protocols ( disable SSL ( secure Socket . get Enabled Protocols ( ) ) ) ; if ( Sys Properties . ENABLE ANONYMOUS TLS ) { String [ ] list = enable Anonymous ( secure Socket . get Enabled Cipher Suites ( ) , secure Socket . get Supported Cipher Suites ( ) ) ; secure Socket . set Enabled Cipher Suites ( list ) ; } socket = secure Socket ; return socket ; }
private String format Node ( Binary Node < T > node ) { Binary Node < T > n ; String Builder response = new String Builder ( STRING ) ; if ( ( n = node . get Left Son ( ) ) != null ) { response . append ( format Node ( n ) ) ; } response . append ( node . to String ( ) ) ; if ( ( n = node . get Right Son ( ) ) != null ) { response . append ( format Node ( n ) ) ; } response . append ( STRING ) ; return response . to String ( ) ; }
public static void unregister M Bean ( Class < ? > mbean Interface , String mbean Name ) { M Bean Server mbs = Management Factory . get Platform M Bean Server ( ) ; try { Object Name name = generate M Bean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; if ( mbs . is Registered ( name ) ) { logger . info ( STRING + name . to String ( ) ) ; mbs . unregister M Bean ( name ) ; } else { logger . warn ( STRING + name . to String ( ) ) ; } } catch ( Exception e ) { throw new Server Runtime Exception ( STRING + mbean Interface + STRING + mbean Name , e ) ; } }
protected void halt ( final Throwable cause ) { halt = BOOL ; final boolean is First Cause = first Cause . compare And Set ( null , cause ) ; if ( WARN ) try { if ( ! Inner Cause . is Inner Cause ( cause , Interrupted Exception . class ) && ! Inner Cause . is Inner Cause ( cause , Cancellation Exception . class ) && ! Inner Cause . is Inner Cause ( cause , Closed By Interrupt Exception . class ) && ! Inner Cause . is Inner Cause ( cause , Rejected Execution Exception . class ) && ! Inner Cause . is Inner Cause ( cause , Buffer Closed Exception . class ) ) { log . warn ( STRING + order Index + STRING + partition Id + STRING + is First Cause + STRING + cause . get Localized Message ( ) , cause ) ; } } catch ( Throwable ex ) { } }
public Json Array add ( String value ) { values . add ( value Of ( value ) ) ; return this ; }
public Rhythm Spec Layer inflate Layer ( String config String , @ Non Null Map < String , String > vars ) { return inflate Layer Internal ( parse Config Internal ( config String , vars , NUM ) , NUM ) ; }
@ HLE Unimplemented @ HLE Function ( nid = NUM , version = NUM ) public int sce Usb Cam Setup Video ( psp Usb Cam Setup Video Param usb Cam Setup Video Param , T Pointer work Area , int work Area Size ) { this . work Area = work Area . get Address ( ) ; this . work Area Size = work Area Size ; resolution = usb Cam Setup Video Param . resolution ; frame Rate = usb Cam Setup Video Param . framerate ; white Balance = usb Cam Setup Video Param . wb ; saturation = usb Cam Setup Video Param . saturation ; brightness = usb Cam Setup Video Param . brightness ; contrast = usb Cam Setup Video Param . contrast ; sharpness = usb Cam Setup Video Param . sharpness ; image Effect Mode = usb Cam Setup Video Param . effectmode ; frame Size = usb Cam Setup Video Param . framesize ; ev Level = usb Cam Setup Video Param . evlevel ; if ( ! setup Video ( ) ) { log . warn ( String . format ( STRING ) ) ; return Sce Kernel Errors . ERROR USBCAM NOT READY ; } return NUM ; }
public List < Statistics > load All Deep From Cursor ( Cursor cursor ) { int count = cursor . get Count ( ) ; List < Statistics > list = new Array List < Statistics > ( count ) ; if ( cursor . move To First ( ) ) { if ( identity Scope != null ) { identity Scope . lock ( ) ; identity Scope . reserve Room ( count ) ; } try { do { list . add ( load Current Deep ( cursor , BOOL ) ) ; } while ( cursor . move To Next ( ) ) ; } finally { if ( identity Scope != null ) { identity Scope . unlock ( ) ; } } } return list ; }
public static String convert Date To ISO 8601 ( Date date ) { Date Format date Format = new Simple Date Format ( STRING ) ; return date Format . format ( date ) ; }
public static Document create DOM ( String str XML ) throws Parser Configuration Exception , SAX Exception , IO Exception { Document Builder Factory dbf = Document Builder Factory . new Instance ( ) ; dbf . set Validating ( BOOL ) ; dbf . set Ignoring Comments ( BOOL ) ; dbf . set Ignoring Element Content Whitespace ( BOOL ) ; dbf . set Namespace Aware ( BOOL ) ; dbf . set Feature ( XML Constants . FEATURE SECURE PROCESSING , BOOL ) ; dbf . set Feature ( DISALLOW DOCTYPE DECL , BOOL ) ; dbf . set Feature ( EXTERNAL GENERAL ENTITIES , BOOL ) ; dbf . set Feature ( EXTERNAL PARAMETER ENTITIES , BOOL ) ; dbf . set Feature ( LOAD EXTERNAL DTD , BOOL ) ; Document Builder db = null ; db = dbf . new Document Builder ( ) ; db . set Entity Resolver ( new Null Resolver ( ) ) ; db . set Error Handler ( new Saml Parser Error Handler ( ) ) ; Input Source source XML = new Input Source ( new String Reader ( str XML ) ) ; Document xml Doc = db . parse ( source XML ) ; return xml Doc ; }
public void reset ( ) { last Mtd = null ; map . clear ( ) ; put Cnt . set ( NUM ) ; put All Cnt . set ( NUM ) ; rmv Cnt . set ( NUM ) ; rmv All Cnt . set ( NUM ) ; ts = System . current Time Millis ( ) ; }
void decode Attribute Body ( byte [ ] attribute Value , char offset , char length ) throws Stun Exception { this . attribute Value = new byte [ length ] ; System . arraycopy ( attribute Value , offset , this . attribute Value , NUM , length ) ; }
public static void copy Assets ( Context context , String assets Filename , File file , String mode ) throws IO Exception , Interrupted Exception { Asset Manager manager = context . get Assets ( ) ; final Input Stream is = manager . open ( assets Filename ) ; copy File ( file , is , mode ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return BOOL ; if ( obj == null ) return BOOL ; if ( get Class ( ) != obj . get Class ( ) ) return BOOL ; Typed Set other = ( Typed Set ) obj ; if ( type == null ) { if ( other . type != null ) return BOOL ; } else if ( ! type . equals ( other . type ) ) return BOOL ; if ( ! Arrays . equals ( values , other . values ) ) return BOOL ; return BOOL ; }
@ Suppress Warnings ( STRING ) static void murmurhash 3 x64 128 ( byte [ ] key , int offset , int len , int seed , Long Pair out ) { long h1 = seed & NUM ; long h2 = seed & NUM ; final long c1 = NUM ; final long c2 = NUM ; int rounded End = offset + ( len & NUM ) ; for ( int i = offset ; i < rounded End ; i += NUM ) { long k1 = get Long Little Endian ( key , i ) ; long k2 = get Long Little Endian ( key , i + NUM ) ; k1 *= c1 ; k1 = Long . rotate Left ( k1 , NUM ) ; k1 *= c2 ; h1 ^= k1 ; h1 = Long . rotate Left ( h1 , NUM ) ; h1 += h2 ; h1 = h1 * NUM + NUM ; k2 *= c2 ; k2 = Long . rotate Left ( k2 , NUM ) ; k2 *= c1 ; h2 ^= k2 ; h2 = Long . rotate Left ( h2 , NUM ) ; h2 += h1 ; h2 = h2 * NUM + NUM ; } long k1 = NUM ; long k2 = NUM ; switch ( len & NUM ) { case NUM : k2 = ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) ; k2 *= c2 ; k2 = Long . rotate Left ( k2 , NUM ) ; k2 *= c1 ; h2 ^= k2 ; case NUM : k1 = ( ( long ) key [ rounded End + NUM ] ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End ] & NUM ) ; k1 *= c1 ; k1 = Long . rotate Left ( k1 , NUM ) ; k1 *= c2 ; h1 ^= k1 ; } h1 ^= len ; h2 ^= len ; h1 += h2 ; h2 += h1 ; h1 = fmix 64 ( h1 ) ; h2 = fmix 64 ( h2 ) ; h1 += h2 ; h2 += h1 ; out . val 1 = h1 ; out . val 2 = h2 ; }
public Listenable Server Socket Channel ( Server Socket Channel channel , Executor event Executor ) throws IO Exception { this ( channel , event Executor , new Async Selector ( Selector . open ( ) ) ) ; owns Selector = BOOL ; }
public void replace Child ( Element old Child , Element new Child ) { if ( children != null ) { set Child Parent ( new Child ) ; int index = children . index Of ( old Child ) ; if ( index != - NUM ) { children . add ( index , new Child ) ; remove Child At ( index + NUM ) ; return ; } } throw new Illegal Argument Exception ( STRING ) ; }
private void paint ( Sea Glass Painter p , Synth Context ctx , Graphics g , int x , int y , int w , int h , Affine Transform transform ) { if ( p != null ) { if ( g instanceof Graphics 2 D ) { Graphics 2 D gfx = ( Graphics 2 D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . create Inverse ( ) ) ; } catch ( Noninvertible Transform Exception e ) { e . print Stack Trace ( ) ; } } } else { Buffered Image img = new Buffered Image ( w , h , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D gfx = img . create Graphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . get Component ( ) , w , h ) ; gfx . dispose ( ) ; g . draw Image ( img , x , y , null ) ; img = null ; } } }
public static long file Length ( File file ) { long length = NUM ; if ( file . is File ( ) ) length = file . length ( ) ; else if ( file . is Directory ( ) ) { File [ ] files = file . list Files ( ) ; if ( files != null ) { for ( File f : files ) length += file Length ( f ) ; } } return length ; }
public static < T extends Throwable > void throw If Instance Of ( Throwable t , Class < T > cls ) throws T { if ( cls . is Instance ( t ) ) { throw cls . cast ( t ) ; } }
public static void write Var Long ( Output Stream out , long x ) throws IO Exception { while ( ( x & ~ NUM ) != NUM ) { out . write ( ( byte ) ( NUM | ( x & NUM ) ) ) ; x >>>= NUM ; } out . write ( ( byte ) x ) ; }
protected void engine Update ( byte [ ] b , int off , int len ) throws Signature Exception { message Digest . update ( b , off , len ) ; needs Reset = BOOL ; }
public static boolean check If Initiators For RP ( Db Client db Client , String Set initiator List ) { if ( db Client == null || initiator List == null ) { return BOOL ; } List < Initiator > initiators = new Array List < Initiator > ( ) ; for ( String initiator Id : initiator List ) { Initiator initiator = db Client . query Object ( Initiator . class , URI . create ( initiator Id ) ) ; if ( initiator != null ) { initiators . add ( initiator ) ; } } return check If Initiators For RP ( initiators ) ; }
protected static List < String > check Os Requirements ( final String os Name , final String os Version ) { final Array List < String > result = new Array List < String > ( ) ; if ( Provider . is Mac ( os Name ) ) { final Version version = Version . parse Version ( os Version ) ; final String bad Version Message = STRING + version . get Major ( ) + STRING + version . get Minor ( ) + STRING + version . get Patch ( ) + STRING ; if ( version . get Major ( ) < NUM ) { result . add ( bad Version Message ) ; } else if ( version . get Major ( ) == NUM ) { if ( version . get Minor ( ) < NUM ) { result . add ( bad Version Message ) ; } else if ( version . get Minor ( ) == NUM ) { if ( version . get Patch ( ) < NUM ) { result . add ( bad Version Message ) ; } } } } else if ( Provider . is Linux ( os Name ) ) { } else if ( Provider . is Windows ( os Name ) ) { result . add ( STRING ) ; } else { result . add ( STRING + os Name + STRING ) ; } return result ; }
private Execution Context execute Using Simplified Compilation Chain ( String dml Script File Path , boolean is File , Map < String , String > arg Vals , boolean parse Py DML , String [ ] inputs , String [ ] outputs , Local Variable Map input Symbol Table , String config File Path ) throws IO Exception , DML Exception { DML Config config = ( config File Path == null ) ? new DML Config ( ) : new DML Config ( config File Path ) ; for ( Entry < String , String > param : additional Configs . entry Set ( ) ) { config . set Text Value ( param . get Key ( ) , param . get Value ( ) ) ; } Configuration Manager . set Global Config ( config ) ; Compiler Config cconf = new Compiler Config ( ) ; cconf . set ( Config Type . IGNORE UNSPECIFIED ARGS , BOOL ) ; cconf . set ( Config Type . REJECT READ WRITE UNKNOWNS , BOOL ) ; cconf . set ( Config Type . ALLOW CSE PERSISTENT READS , BOOL ) ; Configuration Manager . set Global Config ( cconf ) ; String dml Script Str = DML Script . read DML Script ( is File ? STRING : STRING , dml Script File Path ) ; if ( monitor Utils != null ) { monitor Utils . set DML String ( dml Script Str ) ; } rtprog = null ; A Parser Wrapper parser = A Parser Wrapper . create Parser ( parse Py DML ) ; DML Program prog ; if ( is File ) { prog = parser . parse ( dml Script File Path , null , arg Vals ) ; } else { prog = parser . parse ( null , dml Script Str , arg Vals ) ; } DML Translator dmlt = new DML Translator ( prog ) ; dmlt . live Variable Analysis ( prog ) ; dmlt . validate Parse Tree ( prog ) ; dmlt . construct Hops ( prog ) ; dmlt . rewrite Hops DAG ( prog ) ; Explain . explain ( prog ) ; if ( input Symbol Table != null ) { Rewrite Remove Persistent Read Write rewrite = new Rewrite Remove Persistent Read Write ( inputs , outputs , input Symbol Table ) ; Program Rewriter rewriter 2 = new Program Rewriter ( rewrite ) ; rewriter 2 . rewrite Program Hop DA Gs ( prog ) ; } dmlt . construct Lops ( prog ) ; rtprog = prog . get Runtime Program ( config ) ; if ( Optimizer Utils . is Opt Level ( Optimization Level . O4 GLOBAL TIME MEMORY ) ) { rtprog = Global Optimizer Wrapper . optimize Program ( prog , rtprog ) ; } Explain Counts counts = Explain . count Distributed Operations ( rtprog ) ; Statistics . reset No Of Compiled Jobs ( counts . num Jobs ) ; DML Script . init Hadoop Execution ( config ) ; JMLC Utils . cleanup Runtime Program ( rtprog , outputs ) ; Execution Context ec = Execution Context Factory . create Context ( rtprog ) ; if ( input Symbol Table != null ) { ec . set Variables ( input Symbol Table ) ; } rtprog . execute ( ec ) ; if ( monitor Utils != null ) monitor Utils . set Explain Output ( Explain . explain ( rtprog ) ) ; return ec ; }
default B with Default ( String key , long value ) { return with Default ( key , Long . to String ( value ) ) ; }
private boolean yy refill ( ) throws java . io . IO Exception { if ( yy start Read > NUM ) { System . arraycopy ( yy buffer , yy start Read , yy buffer , NUM , yy end Read - yy start Read ) ; yy end Read -= yy start Read ; yy current Pos -= yy start Read ; yy marked Pos -= yy start Read ; yy pushback Pos -= yy start Read ; yy start Read = NUM ; } if ( yy current Pos >= yy buffer . length ) { char new Buffer [ ] = new char [ yy current Pos * NUM ] ; System . arraycopy ( yy buffer , NUM , new Buffer , NUM , yy buffer . length ) ; yy buffer = new Buffer ; } int num Read = yy reader . read ( yy buffer , yy end Read , yy buffer . length - yy end Read ) ; if ( num Read < NUM ) { return BOOL ; } else { yy end Read += num Read ; return BOOL ; } }
protected static Buffered Image create Buffered Image ( int width , int height , boolean has Alpha ) { Buffered Image bimage = null ; Graphics Environment ge = Graphics Environment . get Local Graphics Environment ( ) ; try { int transparency = Transparency . OPAQUE ; if ( has Alpha ) { transparency = Transparency . TRANSLUCENT ; } Graphics Device gs = ge . get Default Screen Device ( ) ; Graphics Configuration gc = gs . get Default Configuration ( ) ; bimage = gc . create Compatible Image ( width , height , transparency ) ; } catch ( Headless Exception e ) { } if ( bimage == null ) { int type = Buffered Image . TYPE INT RGB ; if ( has Alpha ) { type = Buffered Image . TYPE INT ARGB ; } bimage = new Buffered Image ( width , height , type ) ; } return bimage ; }
public final void search Pattern ( I Progress Monitor monitor ) throws Java Model Exception { Assert . is Not Null ( f Pattern ) ; if ( monitor == null ) monitor = new Null Progress Monitor ( ) ; try { monitor . begin Task ( STRING , NUM ) ; monitor . set Task Name ( Refactoring Core Messages . Refactoring Search Engine searching occurrences ) ; try { Search Engine engine = null ; if ( f Owner != null ) engine = new Search Engine ( f Owner ) ; else engine = new Search Engine ( f Working Copies ) ; engine . search ( f Pattern , Search Utils . get Default Search Participants ( ) , f Scope , get Collector ( ) , new Sub Progress Monitor ( monitor , NUM , Sub Progress Monitor . SUPPRESS SUBTASK LABEL ) ) ; } catch ( Core Exception exception ) { throw new Java Model Exception ( exception ) ; } } finally { monitor . done ( ) ; } }
private void draw Arrows ( final Graphics 2 D g2 d , final int x , final int y , final int width , final int height , final Enum Set < Direction > directions , final Color line Color ) { int arrow Height = NUM + NUM * ( height / NUM - NUM ) ; int arrow Width = NUM + ( width / NUM - NUM ) ; if ( directions . contains ( Direction . LEFT ) ) { g2 d . set Color ( Color . RED ) ; g2 d . fill Polygon ( new int [ ] { x + NUM , x - arrow Width , x + NUM } , new int [ ] { y + ( height / NUM ) - ( arrow Height / NUM ) , y + ( height / NUM ) , y + ( height / NUM ) + ( arrow Height / NUM ) } , NUM ) ; g2 d . set Color ( line Color ) ; g2 d . draw Polyline ( new int [ ] { x , x - arrow Width , x } , new int [ ] { y + ( height / NUM ) - ( arrow Height / NUM ) , y + ( height / NUM ) , y + ( height / NUM ) + ( arrow Height / NUM ) } , NUM ) ; } if ( directions . contains ( Direction . RIGHT ) ) { g2 d . set Color ( Color . RED ) ; g2 d . fill Polygon ( new int [ ] { x + width , x + width + arrow Width , x + width } , new int [ ] { y + ( height / NUM ) - ( arrow Height / NUM ) , y + ( height / NUM ) , y + ( height / NUM ) + ( arrow Height / NUM ) } , NUM ) ; g2 d . set Color ( line Color ) ; g2 d . draw Polyline ( new int [ ] { x + width , x + width + arrow Width , x + width } , new int [ ] { y + ( height / NUM ) - ( arrow Height / NUM ) , y + ( height / NUM ) , y + ( height / NUM ) + ( arrow Height / NUM ) } , NUM ) ; } if ( directions . contains ( Direction . UP ) ) { g2 d . set Color ( Color . RED ) ; g2 d . fill Polygon ( new int [ ] { x + ( width / NUM ) - ( arrow Height / NUM ) , x + ( width / NUM ) , x + ( width / NUM ) + ( arrow Height / NUM ) } , new int [ ] { y + NUM , y - arrow Width , y + NUM } , NUM ) ; g2 d . set Color ( line Color ) ; g2 d . draw Polyline ( new int [ ] { x + ( width / NUM ) - ( arrow Height / NUM ) , x + ( width / NUM ) , x + ( width / NUM ) + ( arrow Height / NUM ) } , new int [ ] { y , y - arrow Width , y } , NUM ) ; } if ( directions . contains ( Direction . DOWN ) ) { g2 d . set Color ( Color . RED ) ; g2 d . fill Polygon ( new int [ ] { x + ( width / NUM ) - ( arrow Height / NUM ) , x + ( width / NUM ) , x + ( width / NUM ) + ( arrow Height / NUM ) } , new int [ ] { y + height , y + height + arrow Width , y + height } , NUM ) ; g2 d . set Color ( line Color ) ; g2 d . draw Polyline ( new int [ ] { x + ( width / NUM ) - ( arrow Height / NUM ) , x + ( width / NUM ) , x + ( width / NUM ) + ( arrow Height / NUM ) } , new int [ ] { y + height , y + height + arrow Width , y + height } , NUM ) ; } }
@ Override public boolean is Component Enabled ( Resolve Info resolve Info ) { if ( resolve Info != null && resolve Info . service Info != null && ! Text Utils . is Empty ( resolve Info . service Info . package Name ) ) { if ( m Permitted Package Names == null || is System App ( resolve Info . service Info . application Info ) ) { return BOOL ; } else { return m Permitted Package Names . contains ( resolve Info . service Info . package Name ) ; } } return BOOL ; }
private static Pair < String , String > pre Indexed LSR ( final long offset , final I Translation Environment environment , final List < Reil Instruction > instructions , final String register Node Value 1 , final String register Node Value 2 , final String immediate Node Value ) { final String address = environment . get Next Variable String ( ) ; final String tmp Var 1 = environment . get Next Variable String ( ) ; final String tmp Var 2 = environment . get Next Variable String ( ) ; final String index = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value 2 , dw , STRING + immediate Node Value , qw , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , qw , tmp Var 1 , dw , d Word Bit Mask , dw , index ) ) ; instructions . add ( Reil Helpers . create Add ( base Offset ++ , dw , register Node Value 1 , dw , index , dw , tmp Var 2 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , dw , tmp Var 2 , dw , d Word Bit Mask , dw , address ) ) ; instructions . add ( Reil Helpers . create Str ( base Offset ++ , dw , address , dw , register Node Value 1 ) ) ; return new Pair < String , String > ( address , register Node Value 1 ) ; }
public void initialize Reference ( Object conc ref , Reference Expression symb ref ) { if ( conc ref != null ) { if ( ! symb ref . is Initialized ( ) ) { symb ref . initialize Reference ( conc ref ) ; int identity Hash Code = System . identity Hash Code ( conc ref ) ; non Null Refs . put ( identity Hash Code , symb ref ) ; } } }
protected void add Reference Properties ( Deserialization Config config , Basic Bean Description bean Desc , Bean Deserializer Builder builder ) throws Json Mapping Exception { Map < String , Annotated Member > refs = bean Desc . find Back Reference Properties ( ) ; if ( refs != null ) { for ( Map . Entry < String , Annotated Member > en : refs . entry Set ( ) ) { String name = en . get Key ( ) ; Annotated Member m = en . get Value ( ) ; if ( m instanceof Annotated Method ) { builder . add Back Reference Property ( name , construct Settable Property ( config , bean Desc , m . get Name ( ) , ( Annotated Method ) m ) ) ; } else { builder . add Back Reference Property ( name , construct Settable Property ( config , bean Desc , m . get Name ( ) , ( Annotated Field ) m ) ) ; } } } }
public Head Rule Map ( Input Stream in ) { Buffered Reader reader = IO Utils . create Buffered Reader ( in ) ; String line , p Tag , dir , rule ; String [ ] tmp ; try { while ( ( line = reader . read Line ( ) ) != null ) { tmp = P COLUMN . split ( line ) ; p Tag = tmp [ NUM ] ; dir = tmp [ NUM ] ; rule = tmp [ NUM ] ; put ( p Tag , new Head Rule ( dir , rule ) ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public void test Case 7 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
< T > void check Timed Get ( Future < T > f , T expected Value , long timeout Millis ) { long start Time = System . nano Time ( ) ; try { assert Equals ( expected Value , f . get ( timeout Millis , MILLISECONDS ) ) ; } catch ( Throwable fail ) { thread Unexpected Exception ( fail ) ; } if ( millis Elapsed Since ( start Time ) > timeout Millis / NUM ) throw new Assertion Failed Error ( STRING ) ; }
public void test Subtract Math Context Diff Scale Neg Pos ( ) { String a = STRING ; int a Scale = - NUM ; String b = STRING ; int b Scale = NUM ; String c = STRING ; int c Scale = - NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; Math Context mc = new Math Context ( NUM , Rounding Mode . HALF DOWN ) ; Big Decimal result = a Number . subtract ( b Number , mc ) ; assert Equals ( STRING , c , result . to String ( ) ) ; assert Equals ( STRING , c Scale , result . scale ( ) ) ; }
public static Result List expand Sql Result Set ( Sql sql , Result Set rs ) throws SQL Exception { Result List res List = new Result List ( ) ; if ( rs == null ) return res List ; Column Descriptor desc = new Column Descriptor ( ) ; desc . add Column ( STRING , BOOL , NUM ) ; desc . add Column ( STRING , BOOL , NUM ) ; res List . set Column Descriptor ( desc ) ; java . sql . Result Set Meta Data meta = rs . get Meta Data ( ) ; int col Cnt = meta . get Column Count ( ) ; int row Cnt = NUM ; while ( rs . next ( ) ) { if ( row Cnt > NUM ) { Result Row row = new Result Row ( ) ; row . add Column ( STRING + ( row Cnt + NUM ) + STRING ) ; row . add Column ( STRING ) ; res List . add Row ( row ) ; } for ( int i = NUM ; i <= col Cnt ; i ++ ) { Result Row row = new Result Row ( ) ; if ( row Cnt > NUM ) row . add Column ( meta . get Column Name ( i ) + STRING + ( row Cnt + NUM ) + STRING ) ; else row . add Column ( meta . get Column Name ( i ) ) ; row . add Column ( rs . get String ( i ) ) ; res List . add Row ( row ) ; } row Cnt ++ ; } return res List ; }
private int decode Spectrum And Dequant ( float coef [ ] , float sf [ ] , boolean pulse Present , Pulse pulse , Individual Channel Stream ics , int band Type [ ] ) { int idx = NUM ; final int c = NUM / ics . num Windows ; final int offsets [ ] = ics . swb Offset ; for ( int g = NUM ; g < ics . num Windows ; g ++ ) { Arrays . fill ( coef , g * NUM + offsets [ ics . max Sfb ] , g * NUM + c , NUM ) ; } int coef Offset = NUM ; for ( int g = NUM ; g < ics . num Window Groups ; g ++ ) { int g Len = ics . group Len [ g ] ; for ( int i = NUM ; i < ics . max Sfb ; i ++ , idx ++ ) { final int cbt M 1 = band Type [ idx ] == NUM ? Integer . MAX VALUE : band Type [ idx ] - NUM ; int cfo = coef Offset + offsets [ i ] ; int off Len = offsets [ i + NUM ] - offsets [ i ] ; if ( cbt M 1 >= INTENSITY BT 2 - NUM ) { for ( int group = NUM ; group < g Len ; group ++ , cfo += NUM ) { Arrays . fill ( coef , cfo , cfo + off Len , NUM ) ; } } else if ( cbt M 1 == NOISE BT - NUM ) { for ( int group = NUM ; group < g Len ; group ++ , cfo += NUM ) { for ( int k = NUM ; k < off Len ; k ++ ) { ac . random State = lcg Random ( ac . random State ) ; coef [ cfo + k ] = ac . random State ; } float band Energy = Float DSP . scalarproduct ( coef , cfo , coef , cfo , off Len ) ; float scale = sf [ idx ] / ( float ) sqrt ( band Energy ) ; Float DSP . vector Fmul Scalar ( coef , cfo , coef , cfo , scale , off Len ) ; } } else { final float vq [ ] = ff aac codebook vector vals [ cbt M 1 ] ; final int cb Vertex Idx [ ] = ff aac codebook vector idx [ cbt M 1 ] ; VLC vlc = vlc spectral [ cbt M 1 ] ; switch ( cbt M 1 > > NUM ) { case NUM : for ( int group = NUM ; group < g Len ; group ++ , cfo += NUM ) { int cf = cfo ; for ( int len = off Len ; len != NUM ; len -= NUM ) { int code = vlc . get VLC 2 ( br , NUM ) ; int cb Idx = cb Vertex Idx [ code ] ; cf = VMUL 4 ( coef , cf , vq , NUM , cb Idx , sf [ idx ] ) ; } } break ; case NUM : for ( int group = NUM ; group < g Len ; group ++ , cfo += NUM ) { int cf = cfo ; for ( int len = off Len ; len != NUM ; len -= NUM ) { int code = vlc . get VLC 2 ( br , NUM ) ; int cb Idx = cb Vertex Idx [ code ] ; int nnz = ( cb Idx > > NUM ) & NUM ; int bits = nnz != NUM ? br . peek ( NUM ) : NUM ; br . skip ( nnz ) ; cf = VMUL 4 S ( coef , cf , vq , NUM , cb Idx , bits , sf [ idx ] ) ; } } break ; case NUM : for ( int group = NUM ; group < g Len ; group ++ , cfo += NUM ) { int cf = cfo ; for ( int len = off Len ; len != NUM ; len -= NUM ) { int code = vlc . get VLC 2 ( br , NUM ) ; int cb Idx = cb Vertex Idx [ code ] ; cf = VMUL 2 ( coef , cf , vq , NUM , cb Idx , sf [ idx ] ) ; } } break ; case NUM : case NUM : for ( int group = NUM ; group < g Len ; group ++ , cfo += NUM ) { int cf = cfo ; for ( int len = off Len ; len != NUM ; len -= NUM ) { int code = vlc . get VLC 2 ( br , NUM ) ; int cb Idx = cb Vertex Idx [ code ] ; int nnz = ( cb Idx > > NUM ) & NUM ; int sign = nnz != NUM ? ( br . peek ( nnz ) << ( cb Idx > > NUM ) ) : NUM ; br . skip ( nnz ) ; cf = VMUL 2 S ( coef , cf , vq , NUM , cb Idx , sign , sf [ idx ] ) ; } } break ; default : for ( int group = NUM ; group < g Len ; group ++ , cfo += NUM ) { int icf = cfo ; for ( int len = off Len ; len != NUM ; len -= NUM ) { int code = vlc . get VLC 2 ( br , NUM ) ; if ( code == NUM ) { coef [ icf ++ ] = NUM ; coef [ icf ++ ] = NUM ; continue ; } int cb Idx = cb Vertex Idx [ code ] ; int nnz = cb Idx > > NUM ; int nzt = cb Idx > > NUM ; int bits = br . read ( nnz ) << ( NUM - nnz ) ; for ( int j = NUM ; j < NUM ; j ++ ) { if ( ( nzt & ( NUM << j ) ) != NUM ) { int b = br . peek ( NUM ) ; b = NUM - av Log 2 ( ~ b ) ; if ( b > NUM ) { log . error ( String . format ( STRING ) ) ; return AAC ERROR ; } br . skip ( b + NUM ) ; b += NUM ; int n = ( NUM << b ) + br . read ( b ) ; coef [ icf ++ ] = Float . int Bits To Float ( cbrt tab [ n ] | ( bits & ( NUM << NUM ) ) ) ; bits <<= NUM ; } else { float v = vq [ cb Idx & NUM ] ; if ( v == NUM ) { coef [ icf ++ ] = NUM ; } else { if ( ( bits & ( NUM << NUM ) ) != NUM ) { v = - v ; } coef [ icf ++ ] = v ; bits <<= NUM ; } } cb Idx >>= NUM ; } } Float DSP . vector Fmul Scalar ( coef , cfo , coef , cfo , sf [ idx ] , off Len ) ; } break ; } } } coef Offset += g Len << NUM ; } if ( pulse Present ) { idx = NUM ; for ( int i = NUM ; i < pulse . num Pulse ; i ++ ) { float co = coef [ pulse . pos [ i ] ] ; while ( offsets [ idx + NUM ] <= pulse . pos [ i ] ) { idx ++ ; } if ( band Type [ idx ] != NOISE BT && sf [ idx ] != NUM ) { float ico = - pulse . amp [ i ] ; if ( co != NUM ) { co /= sf [ idx ] ; ico = co / ( float ) Math . sqrt ( Math . sqrt ( Math . abs ( co ) ) ) + ( co > NUM ? - ico : ico ) ; } coef [ pulse . pos [ i ] ] = ( float ) Math . cbrt ( Math . abs ( ico ) ) * ico * sf [ idx ] ; } } } return NUM ; }
public static String null To Empty ( @ Nullable Char Sequence string ) { return string == null ? EMPTY : string . to String ( ) ; }
public boolean memory Is Low ( ) { m Memory Usage = m Memory MX Bean . get Heap Memory Usage ( ) ; if ( is Enabled ( ) ) { long low Threshold = ( long ) ( NUM * m Memory Usage . get Max ( ) ) ; if ( low Threshold < LOW MEMORY MINIMUM ) { low Threshold = LOW MEMORY MINIMUM ; } long avail = m Memory Usage . get Max ( ) - m Memory Usage . get Used ( ) ; return ( avail < low Threshold ) ; } else { return BOOL ; } }
public Point translate Java 2 D To Screen ( Point 2 D java 2 D Point ) { Insets insets = get Insets ( ) ; int x = ( int ) ( java 2 D Point . get X ( ) * this . scale X + insets . left ) ; int y = ( int ) ( java 2 D Point . get Y ( ) * this . scale Y + insets . top ) ; return new Point ( x , y ) ; }
public static Map < String , Object > test Processor ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Locale locale = ( Locale ) context . get ( STRING ) ; Map < String , Object > result = Fast Map . new Instance ( ) ; Big Decimal process Amount = ( Big Decimal ) context . get ( STRING ) ; if ( process Amount != null && process Amount . compare To ( new Big Decimal ( STRING ) ) >= NUM ) result . put ( STRING , Boolean . TRUE ) ; if ( process Amount != null && process Amount . compare To ( new Big Decimal ( STRING ) ) < NUM ) result . put ( STRING , Boolean . FALSE ) ; result . put ( STRING , Util Misc . to List ( Util Properties . get Message ( resource , STRING , locale ) ) ) ; if ( process Amount == null ) result . put ( STRING , null ) ; String ref Num = Util Date Time . now As String ( ) ; result . put ( STRING , context . get ( STRING ) ) ; result . put ( STRING , ref Num ) ; result . put ( STRING , ref Num ) ; result . put ( STRING , STRING ) ; result . put ( STRING , Util Properties . get Message ( resource , STRING , locale ) ) ; result . put ( STRING , Util Misc . to List ( Util Properties . get Message ( resource , STRING , locale ) ) ) ; return result ; }
private void clear Old Traffic ( ) { List < Air Map Traffic > old All Traffic = new Array List < > ( ) ; for ( Air Map Traffic traffic : all Traffic ) { if ( traffic Expired ( traffic ) ) { old All Traffic . add ( traffic ) ; all Traffic . remove ( traffic ) ; } } notify Removed ( old All Traffic ) ; }
public void log Error ( final Level level , final String message , final Error e ) { try { Logger errors = Logging Factory . get Logger ( Logging Factory . NAME ERROR LOGGER ) ; errors . log Throwable ( level , message , e ) ; } catch ( Logging Exception ex ) { ex . print Stack Trace ( ) ; } if ( log Level . int Value ( ) > level . int Value ( ) ) { return ; } log Throwable ( level , message , e ) ; }
public static float compute Contrast ( int background , int foreground ) { Pair < Integer , Integer > key = new Pair < > ( background , foreground ) ; if ( contrast Cache == null ) { contrast Cache = new Lru Cache < > ( NUM ) ; } else { Float contrast = contrast Cache . get ( key ) ; if ( contrast != null ) { return contrast ; } } float bg R = Color . red ( background ) / NUM ; float bg G = Color . green ( background ) / NUM ; float bg B = Color . blue ( background ) / NUM ; bg R = ( bg R < NUM ) ? bg R / NUM : ( float ) Math . pow ( ( bg R + NUM ) / NUM , NUM ) ; bg G = ( bg G < NUM ) ? bg G / NUM : ( float ) Math . pow ( ( bg G + NUM ) / NUM , NUM ) ; bg B = ( bg B < NUM ) ? bg B / NUM : ( float ) Math . pow ( ( bg B + NUM ) / NUM , NUM ) ; float bg L = NUM * bg R + NUM * bg G + NUM * bg B ; float fg R = Color . red ( foreground ) / NUM ; float fg G = Color . green ( foreground ) / NUM ; float fg B = Color . blue ( foreground ) / NUM ; fg R = ( fg R < NUM ) ? fg R / NUM : ( float ) Math . pow ( ( fg R + NUM ) / NUM , NUM ) ; fg G = ( fg G < NUM ) ? fg G / NUM : ( float ) Math . pow ( ( fg G + NUM ) / NUM , NUM ) ; fg B = ( fg B < NUM ) ? fg B / NUM : ( float ) Math . pow ( ( fg B + NUM ) / NUM , NUM ) ; float fg L = NUM * fg R + NUM * fg G + NUM * fg B ; float value = Math . abs ( ( fg L + NUM ) / ( bg L + NUM ) ) ; contrast Cache . put ( key , value ) ; return value ; }
private Menu Item add Internal ( int group , int id , int category Order , Char Sequence title ) { final Menu Item Impl item = create New Menu Item ( group , id , category Order , title ) ; m Items . add ( find Insert Index ( m Items , category Order ) , item ) ; on Items Changed ( BOOL ) ; return item ; }
public static String dump ( final Device Descriptor descriptor , final String manufacturer , final String product , final String serial ) { return String . format ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , descriptor . b Length ( ) , descriptor . b Descriptor Type ( ) , decode BCD ( descriptor . bcd USB ( ) ) , descriptor . b Device Class ( ) & NUM , get USB Class Name ( descriptor . b Device Class ( ) ) , descriptor . b Device Sub Class ( ) & NUM , descriptor . b Device Protocol ( ) & NUM , descriptor . b Max Packet Size 0 ( ) & NUM , String . format ( STRING , descriptor . id Vendor ( ) & NUM ) , String . format ( STRING , descriptor . id Product ( ) & NUM ) , decode BCD ( descriptor . bcd Device ( ) ) , descriptor . i Manufacturer ( ) & NUM , ( manufacturer == null ) ? STRING : ( STRING + manufacturer ) , descriptor . i Product ( ) & NUM , ( product == null ) ? STRING : ( STRING + product ) , descriptor . i Serial Number ( ) & NUM , ( serial == null ) ? STRING : ( STRING + serial ) , descriptor . b Num Configurations ( ) & NUM ) ; }
public boolean check Signals ( Jmri J Frame frame , Layout Editor panel ) { if ( panel == null ) { log . error ( STRING ) ; return BOOL ; } if ( initialization Needed ) { initialize Blocks ( ) ; } Block e Block = get Entry Block ( ) ; Array List < Entry Point > ep List = get List Of Forward Block Entry Points ( e Block ) ; if ( ep List . size ( ) > NUM ) { } return BOOL ; }
public void initialize ( Map config Params ) { String delimiter Config = ( String ) config Params . get ( Resource Match . RESOURCE COMPARATOR DELIMITER ) ; if ( delimiter Config != null ) { this . delimiter = delimiter Config ; } String case Config = ( String ) config Params . get ( Resource Match . RESOURCE COMPARATOR CASE SENSITIVE ) ; if ( case Config != null ) { if ( case Config . equals ( STRING ) ) { this . case Sensitive = BOOL ; } else if ( case Config . equals ( STRING ) ) { this . case Sensitive = BOOL ; } else { this . case Sensitive = BOOL ; } } String wildcard Config = ( String ) config Params . get ( Resource Match . RESOURCE COMPARATOR WILDCARD ) ; if ( wildcard Config != null ) { this . wildcard = wildcard Config ; } String one Level Wildcard Config = ( String ) config Params . get ( Resource Match . RESOURCE COMPARATOR ONE LEVEL WILDCARD ) ; if ( one Level Wildcard Config != null ) { this . one Level Wildcard = one Level Wildcard Config ; } if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + delimiter + STRING + wildcard + STRING + one Level Wildcard + STRING + case Config ) ; } one Level Wildcard Length = one Level Wildcard . length ( ) ; wildcard Length = wildcard . length ( ) ; if ( one Level Wildcard . index Of ( wildcard ) != - NUM ) { wildcard Embedded = BOOL ; } else { wildcard Embedded = BOOL ; } if ( wildcard . index Of ( one Level Wildcard ) != - NUM ) { one Level Wildcard Embedded = BOOL ; } else { one Level Wildcard Embedded = BOOL ; } if ( debug . message Enabled ( ) ) { debug . message ( STRING + wildcard Embedded + STRING + one Level Wildcard Embedded ) ; } return ; }
@ PUT @ Path ( STRING ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Check Permission ( roles = { Role . TENANT ADMIN } ) public Ip Interface Rest Rep update Ip Interface ( @ Path Param ( STRING ) URI id , Ip Interface Update Param update Param ) throws Database Exception { Ip Interface ip Interface = query Object ( Ip Interface . class , id , BOOL ) ; host Service . validate Ip Interface Data ( update Param , ip Interface ) ; host Service . populate Ip Interface ( update Param , ip Interface ) ; db Client . persist Object ( ip Interface ) ; audit Op ( Operation Type Enum . UPDATE HOST IPINTERFACE , BOOL , null , ip Interface . audit Parameters ( ) ) ; return map ( query Object ( Ip Interface . class , id , BOOL ) ) ; }
protected I Content Proposal [ ] content Proposals From ( List < I Edit Proposal > edit Proposals ) { I Content Proposal [ ] content Proposals = new I Content Proposal [ edit Proposals . size ( ) ] ; for ( int i = NUM ; i < edit Proposals . size ( ) ; i ++ ) { content Proposals [ i ] = new Edit Proposal Wrapper ( edit Proposals . get ( i ) ) ; } return content Proposals ; }
public Extension Query ( String extension Point Name , String attribute Name ) { Preconditions . check Argument ( extension Point Name . contains ( STRING ) , STRING ) ; this . plugin Id = null ; this . extension Point Name = extension Point Name ; this . attribute Name = attribute Name ; }
public void inline Image ( Rendered Image image , Color bkg , String encode ) throws IO Exception { Image Bytes bytes = new Image Bytes ( image , bkg , Image Constants . JPG , Image Constants . COLOR MODEL RGB ) ; println ( STRING ) ; image Info ( STRING , image . get Width ( ) ) ; image Info ( STRING , image . get Height ( ) ) ; image Info ( STRING , pdf . name ( STRING ) ) ; image Info ( STRING , NUM ) ; image Info ( STRING , get Filter Name ( bytes . get Format ( ) ) ) ; print ( STRING ) ; write ( bytes . get Bytes ( ) ) ; println ( STRING ) ; }
public String to String ( ) { if ( m Filtered Instances == null ) { return STRING ; } String result = STRING + get Classifier Spec ( ) + STRING + get Filter Spec ( ) + STRING + m Filtered Instances . to String ( ) + STRING + m Classifier . to String ( ) ; return result ; }
public double pruned Wide ( Prior prior , Likelihood likelihood ) throws Operator Failed Exception { final int node Count = tree . get Node Count ( ) ; final Node Ref root = tree . get Root ( ) ; Node Ref i ; int index I ; do { index I = Math Utils . next Int ( node Count ) ; i = tree . get Node ( index I ) ; } while ( root == i || ( tree . get Parent ( i ) == root && tree . get Node Height ( i ) > tree . get Node Height ( get Other Child ( tree , tree . get Parent ( i ) , i ) ) ) ) ; List < Integer > second Node Indices = new Array List < Integer > ( ) ; List < Double > probabilities = new Array List < Double > ( ) ; Node Ref j , jP ; Node Ref iP = tree . get Parent ( i ) ; double height IP = tree . get Node Height ( iP ) ; double height I = tree . get Node Height ( i ) ; double sum = NUM ; double backward = calculate Tree Likelihood ( prior , likelihood , tree ) ; int offset = ( int ) - backward ; backward = Math . exp ( backward + offset ) ; for ( int n = NUM ; n < node Count ; n ++ ) { j = tree . get Node ( n ) ; if ( j != root ) { jP = tree . get Parent ( j ) ; if ( ( iP != jP ) && ( tree . get Node Height ( j ) < height IP ) && ( height I < tree . get Node Height ( jP ) ) && get Node Distance ( iP , jP ) <= MAX DISTANCE ) { second Node Indices . add ( n ) ; swap ( tree , i , j , iP , jP ) ; double prob = Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; probabilities . add ( prob ) ; swap ( tree , i , j , jP , iP ) ; sum += prob ; } } } if ( sum <= NUM ) { throw new Operator Failed Exception ( STRING ) ; } double ran = Math . random ( ) * sum ; int index = NUM ; while ( ran > NUM ) { ran -= probabilities . get ( index ) ; index ++ ; } index -- ; j = tree . get Node ( second Node Indices . get ( index ) ) ; jP = tree . get Parent ( j ) ; double height JP = tree . get Node Height ( jP ) ; double height J = tree . get Node Height ( j ) ; double sum Forward 2 = NUM ; Node Ref k , kP ; for ( int n = NUM ; n < node Count ; n ++ ) { k = tree . get Node ( n ) ; if ( k != root ) { kP = tree . get Parent ( k ) ; if ( ( jP != kP ) && ( tree . get Node Height ( k ) < height JP ) && ( height J < tree . get Node Height ( kP ) ) && get Node Distance ( kP , jP ) <= MAX DISTANCE ) { swap ( tree , j , k , jP , kP ) ; double prob = Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Forward 2 += prob ; swap ( tree , j , k , kP , jP ) ; } } } swap ( tree , i , j , iP , jP ) ; double forward = probabilities . get ( index ) ; iP = jP ; height IP = height JP ; double sum Backward = NUM ; for ( int n = NUM ; n < node Count ; n ++ ) { j = tree . get Node ( n ) ; if ( j != root ) { jP = tree . get Parent ( j ) ; if ( ( iP != jP ) && ( tree . get Node Height ( j ) < height IP ) && ( height I < tree . get Node Height ( jP ) ) && get Node Distance ( iP , jP ) <= MAX DISTANCE ) { swap ( tree , i , j , iP , jP ) ; double prob = Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Backward += prob ; swap ( tree , i , j , jP , iP ) ; } } } double sum Backward 2 = NUM ; j = tree . get Node ( second Node Indices . get ( index ) ) ; jP = tree . get Parent ( j ) ; height JP = tree . get Node Height ( jP ) ; height J = tree . get Node Height ( j ) ; for ( int n = NUM ; n < node Count ; n ++ ) { k = tree . get Node ( n ) ; if ( k != root ) { kP = tree . get Parent ( k ) ; if ( ( jP != kP ) && ( tree . get Node Height ( k ) < height JP ) && ( height J < tree . get Node Height ( kP ) ) && get Node Distance ( kP , jP ) <= MAX DISTANCE ) { swap ( tree , j , k , jP , kP ) ; double prob = Math . exp ( calculate Tree Likelihood ( prior , likelihood , tree ) + offset ) ; sum Backward 2 += prob ; swap ( tree , j , k , kP , jP ) ; } } } double forward Prob = ( forward / sum ) + ( forward / sum Forward 2 ) ; double backward Prob = ( backward / sum Backward ) + ( backward / sum Backward 2 ) ; double hastings Ratio = Math . log ( backward Prob / forward Prob ) ; return hastings Ratio ; }
public static boolean clip Line ( Line 2 D line , Rectangle 2 D rect ) { double x1 = line . get X 1 ( ) ; double y1 = line . get Y 1 ( ) ; double x2 = line . get X 2 ( ) ; double y2 = line . get Y 2 ( ) ; double min X = rect . get Min X ( ) ; double max X = rect . get Max X ( ) ; double min Y = rect . get Min Y ( ) ; double max Y = rect . get Max Y ( ) ; int f1 = rect . outcode ( x1 , y1 ) ; int f2 = rect . outcode ( x2 , y2 ) ; while ( ( f1 | f2 ) != NUM ) { if ( ( f1 & f2 ) != NUM ) { return BOOL ; } double dx = ( x2 - x1 ) ; double dy = ( y2 - y1 ) ; if ( f1 != NUM ) { if ( ( f1 & Rectangle 2 D . OUT LEFT ) == Rectangle 2 D . OUT LEFT && dx != NUM ) { y1 = y1 + ( min X - x1 ) * dy / dx ; x1 = min X ; } else if ( ( f1 & Rectangle 2 D . OUT RIGHT ) == Rectangle 2 D . OUT RIGHT && dx != NUM ) { y1 = y1 + ( max X - x1 ) * dy / dx ; x1 = max X ; } else if ( ( f1 & Rectangle 2 D . OUT BOTTOM ) == Rectangle 2 D . OUT BOTTOM && dy != NUM ) { x1 = x1 + ( max Y - y1 ) * dx / dy ; y1 = max Y ; } else if ( ( f1 & Rectangle 2 D . OUT TOP ) == Rectangle 2 D . OUT TOP && dy != NUM ) { x1 = x1 + ( min Y - y1 ) * dx / dy ; y1 = min Y ; } f1 = rect . outcode ( x1 , y1 ) ; } else if ( f2 != NUM ) { if ( ( f2 & Rectangle 2 D . OUT LEFT ) == Rectangle 2 D . OUT LEFT && dx != NUM ) { y2 = y2 + ( min X - x2 ) * dy / dx ; x2 = min X ; } else if ( ( f2 & Rectangle 2 D . OUT RIGHT ) == Rectangle 2 D . OUT RIGHT && dx != NUM ) { y2 = y2 + ( max X - x2 ) * dy / dx ; x2 = max X ; } else if ( ( f2 & Rectangle 2 D . OUT BOTTOM ) == Rectangle 2 D . OUT BOTTOM && dy != NUM ) { x2 = x2 + ( max Y - y2 ) * dx / dy ; y2 = max Y ; } else if ( ( f2 & Rectangle 2 D . OUT TOP ) == Rectangle 2 D . OUT TOP && dy != NUM ) { x2 = x2 + ( min Y - y2 ) * dx / dy ; y2 = min Y ; } f2 = rect . outcode ( x2 , y2 ) ; } } line . set Line ( x1 , y1 , x2 , y2 ) ; return BOOL ; }
public synchronized Panel remove All Components ( ) { for ( Component component : new Array List < Component > ( components ) ) { remove Component ( component ) ; } return this ; }
private int tailing Non Newline ( String str , int off , int len ) { for ( int cnt = NUM ; cnt < len ; cnt ++ ) { final int pos = off + ( len - NUM ) - cnt ; if ( str . char At ( pos ) == Output Stream Logger . UNIX NEWLINE ) { return cnt ; } } return len ; }
@ Override public String to String ( ) { if ( m Iterative Classifier == null ) { return STRING ; } else { String Buffer sb = new String Buffer ( ) ; sb . append ( STRING + m best Result + STRING ) ; sb . append ( STRING + m best Num Its + STRING ) ; if ( m thresholds != null ) { sb . append ( STRING ) ; for ( int i = NUM ; i < m thresholds . length ; i ++ ) { sb . append ( m thresholds [ i ] + STRING ) ; } } sb . append ( STRING ) ; sb . append ( m Iterative Classifier . to String ( ) ) ; return sb . to String ( ) ; } }
public void test Signer String ( ) throws Exception { Signer s = new Signer Stub ( STRING ) ; assert Not Null ( s ) ; assert Equals ( STRING , s . get Name ( ) ) ; assert Null ( s . get Private Key ( ) ) ; Signer s2 = new Signer Stub ( null ) ; assert Null ( s2 . get Name ( ) ) ; }
public static < K , V > Multi Value Map < K , V > unmodifiable Multi Value Map ( Multi Value Map < ? extends K , ? extends V > map ) { Assert . not Null ( map , STRING ) ; Map < K , List < V > > result = new Linked Hash Map < K , List < V > > ( map . size ( ) ) ; for ( Map . Entry < ? extends K , ? extends List < ? extends V > > entry : map . entry Set ( ) ) { List < V > values = Collections . unmodifiable List ( entry . get Value ( ) ) ; result . put ( entry . get Key ( ) , values ) ; } Map < K , List < V > > unmodifiable Map = Collections . unmodifiable Map ( result ) ; return to Multi Value Map ( unmodifiable Map ) ; }
public static long pause ( final long sleep Time MS ) { final long start Time = System . current Time Millis ( ) ; do { try { final long sleep Time = sleep Time MS - ( System . current Time Millis ( ) - start Time ) ; Thread . sleep ( sleep Time > NUM ? sleep Time : NUM ) ; } catch ( Interrupted Exception e ) { } } while ( ( System . current Time Millis ( ) - start Time ) < sleep Time MS ) ; return System . current Time Millis ( ) - start Time ; }
public static void mute Current Out And Err Stream ( ) { if ( already Muted ) { return ; } Byte Array Output Stream byte Stream = new Byte Array Output Stream ( ) ; Print Stream out Stream = new Print Stream ( byte Stream ) ; latest Out = System . out ; latest Err = System . err ; System . set Out ( out Stream ) ; System . set Err ( out Stream ) ; already Muted = BOOL ; }
public static Big Integer [ ] convert List To Array ( List < Big Integer > list ) { Big Integer [ ] result = new Big Integer [ list . size ( ) ] ; for ( int i = NUM ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
private int measure Height ( int measure Spec ) { int result ; int spec Mode = Measure Spec . get Mode ( measure Spec ) ; int spec Size = Measure Spec . get Size ( measure Spec ) ; m Ascent = ( int ) m Text Paint . ascent ( ) ; if ( spec Mode == Measure Spec . EXACTLY ) { result = spec Size ; } else { result = ( int ) ( - m Ascent + m Text Paint . descent ( ) ) + m Padding Top + m Padding Bottom ; if ( spec Mode == Measure Spec . AT MOST ) { result = Math . min ( result , spec Size ) ; } } return result ; }
public void test Case 17 ( ) { byte a Bytes [ ] = { NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte r Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . add ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
protected < T > T wait For Property Value ( String document Self Link , Class < T > type , String prop Name , Object prop Value ) throws Throwable { return wait For Property Value ( document Self Link , type , prop Name , Arrays . as List ( prop Value ) , BOOL , wait For Stage Change Count ( ) ) ; }
public void add Image ( Buffered Image img , Buffered Image height , int x , int y ) { Chunk Image chunk = new Chunk Image ( ) ; chunk . image = img ; chunk . height map = height ; chunk . x = x ; chunk . y = y ; synchronized ( chunks ) { chunks . add ( chunk ) ; } redraw Chunk ( chunk ) ; }
void insert Function 3 ( Byte Buffer bb ) { int base Sec = ( int ) ( window Id > > NUM ) ; bb . put Int ( base Sec ) ; short win Id = ( short ) ( window Id & NUM ) ; bb . put Short ( win Id ) ; Integer oper Id = operator Id ; for ( int i = NUM ; i < NUM ; i ++ ) { byte num = ( byte ) ( oper Id > > NUM * ( NUM - i ) ) ; bb . put ( num ) ; } for ( int i = NUM ; i < NUM ; i ++ ) { byte num = ( byte ) ( tuple Id > > NUM * ( NUM - i ) ) ; bb . put ( num ) ; } }
static float distance ( Rectangle a , Rectangle b ) { float ax 1 , ax 2 , ay 1 , ay 2 ; float bx 1 , bx 2 , by 1 , by 2 ; ax 1 = a . x ; ax 2 = a . x + a . width ; ay 1 = a . y ; ay 2 = a . y + a . height ; bx 1 = b . x ; bx 2 = b . x + b . width ; by 1 = b . y ; by 2 = b . y + b . height ; float xdiff 11 = Math . abs ( ax 1 - bx 1 ) ; float xdiff 12 = Math . abs ( ax 1 - bx 2 ) ; float xdiff 21 = Math . abs ( ax 2 - bx 1 ) ; float xdiff 22 = Math . abs ( ax 2 - bx 2 ) ; float ydiff 11 = Math . abs ( ay 1 - by 1 ) ; float ydiff 12 = Math . abs ( ay 1 - by 2 ) ; float ydiff 21 = Math . abs ( ay 2 - by 1 ) ; float ydiff 22 = Math . abs ( ay 2 - by 2 ) ; float xmin = Math . min ( Math . min ( xdiff 11 , xdiff 12 ) , Math . min ( xdiff 21 , xdiff 22 ) ) ; float ymin = Math . min ( Math . min ( ydiff 11 , ydiff 12 ) , Math . min ( ydiff 21 , ydiff 22 ) ) ; boolean y Overlap = ay 1 <= by 2 && by 1 <= ay 2 ; boolean x Overlap = ax 1 <= bx 2 && bx 1 <= ax 2 ; float x Return = ( y Overlap ) ? xmin : ( float ) Math . hypot ( xmin , ymin ) ; float y Return = ( x Overlap ) ? ymin : ( float ) Math . hypot ( xmin , ymin ) ; return Math . min ( x Return , y Return ) ; }
public boolean next Tile ( ) throws Model Control Exception { boolean moved To Row = super . next Tile ( ) ; if ( moved To Row ) { cur Tile = get Tile Index ( ) ; set Display Field Value ( TXT INDEX , Integer . to String ( cur Tile ) ) ; set Display Field Value ( TXT BUTTON , buttons [ cur Tile ] ) ; set Display Field Value ( TXT CLASS , cur Tile == NUM ? STRING : STRING ) ; } return moved To Row ; }
private void toggle Stealth ( ) { initialize ( ) ; int total bv , known bv , known range , known count , trigger range ; int new stealth ; for ( Entity check ent : game . get Entities Vector ( ) ) { if ( ( check ent . get Owner Id ( ) == local Player Number ) && ( check ent instanceof Mech ) ) { if ( check ent . has Stealth ( ) && ( check ent . get Position ( ) != null ) ) { for ( Mounted m Equip : check ent . get Misc ( ) ) { Misc Type mtype = ( Misc Type ) m Equip . get Type ( ) ; if ( mtype . has Flag ( Misc Type . F STEALTH ) ) { trigger range = NUM + Compute . random Int ( NUM ) ; if ( check ent . heat > trigger range ) { new stealth = NUM ; } else { total bv = NUM ; known bv = NUM ; known range = NUM ; known count = NUM ; for ( Entity test ent : game . get Entities Vector ( ) ) { if ( check ent . is Enemy Of ( test ent ) ) { total bv += test ent . calculate Battle Value ( ) ; if ( test ent . is Visible To Enemy ( ) ) { known count ++ ; known bv += test ent . calculate Battle Value ( ) ; known range += Compute . effective Distance ( game , check ent , test ent ) ; } } } if ( ( known count == NUM ) || ( known bv < ( total bv / NUM ) ) ) { new stealth = NUM ; } else { if ( ( known range / known count ) <= ( NUM + Compute . random Int ( NUM ) ) ) { new stealth = NUM ; } else { new stealth = NUM ; } } } m Equip . set Mode ( new stealth ) ; send Mode Change ( check ent . get Id ( ) , check ent . get Equipment Num ( m Equip ) , new stealth ) ; break ; } } } } } }
public static Intent create Take Picture Intent ( Activity ctx , Uri saving Uri ) { if ( saving Uri == null ) { throw new Null Pointer Exception ( STRING ) ; } final List < Intent > camera Intents = new Array List < Intent > ( ) ; final Intent capture Intent = new Intent ( Media Store . ACTION IMAGE CAPTURE ) ; final Package Manager package Manager = ctx . get Package Manager ( ) ; final List < Resolve Info > list Cam = package Manager . query Intent Activities ( capture Intent , NUM ) ; for ( Resolve Info res : list Cam ) { final String package Name = res . activity Info . package Name ; final Intent intent = new Intent ( capture Intent ) ; intent . set Component ( new Component Name ( res . activity Info . package Name , res . activity Info . name ) ) ; intent . set Package ( package Name ) ; intent . put Extra ( Media Store . EXTRA OUTPUT , saving Uri ) ; camera Intents . add ( intent ) ; } final Intent gallery Intent = new Intent ( ) ; gallery Intent . set Type ( STRING ) ; gallery Intent . set Action ( Intent . ACTION GET CONTENT ) ; final Intent chooser Intent = Intent . create Chooser ( gallery Intent , STRING ) ; chooser Intent . put Extra ( Intent . EXTRA INITIAL INTENTS , camera Intents . to Array ( new Parcelable [ ] { } ) ) ; return chooser Intent ; }
public static List < Response > execute Connection And Wait ( Http URL Connection connection , Request Batch requests ) { List < Response > responses = Response . from Http Connection ( connection , requests ) ; Utility . disconnect Quietly ( connection ) ; int num Requests = requests . size ( ) ; if ( num Requests != responses . size ( ) ) { throw new Facebook Exception ( String . format ( STRING , responses . size ( ) , num Requests ) ) ; } run Callbacks ( requests , responses ) ; Hash Set < Session > sessions = new Hash Set < Session > ( ) ; for ( Request request : requests ) { if ( request . session != null ) { sessions . add ( request . session ) ; } } for ( Session session : sessions ) { session . extend Access Token If Needed ( ) ; } return responses ; }
private boolean build Chain ( X509 Certificate cert To Verify , Vector < Certificate > chain , Hashtable < Principal , Vector < Certificate > > certs ) { Principal issuer = cert To Verify . get Issuer DN ( ) ; if ( is Self Signed ( cert To Verify ) ) { chain . add Element ( cert To Verify ) ; return BOOL ; } Vector < Certificate > vec = certs . get ( issuer ) ; if ( vec == null ) { return BOOL ; } for ( Enumeration < Certificate > issuer Certs = vec . elements ( ) ; issuer Certs . has More Elements ( ) ; ) { X509 Certificate issuer Cert = ( X509 Certificate ) issuer Certs . next Element ( ) ; Public Key issuer Pub Key = issuer Cert . get Public Key ( ) ; try { cert To Verify . verify ( issuer Pub Key ) ; } catch ( Exception e ) { continue ; } if ( build Chain ( issuer Cert , chain , certs ) ) { chain . add Element ( cert To Verify ) ; return BOOL ; } } return BOOL ; }
@ Request Mapping ( value = { STRING , STRING } , method = Request Method . POST ) @ Response Body public Rest Wrapper update ( @ Model Attribute ( STRING ) @ Valid Users users , Binding Result binding Result , Principal principal ) { Rest Wrapper rest Wrapper = null ; if ( binding Result . has Errors ( ) ) { Binding Result Error binding Result Error = new Binding Result Error ( ) ; return binding Result Error . error Message ( binding Result ) ; } try { String hashed Password = Digest Utils . sha 1 Hex ( users . get Password ( ) ) ; users . set Password ( hashed Password ) ; com . wipro . ats . bdre . md . dao . jpa . Users jpa Users = new com . wipro . ats . bdre . md . dao . jpa . Users ( ) ; jpa Users . set Password ( hashed Password ) ; jpa Users . set Username ( users . get Username ( ) ) ; jpa Users . set Enabled ( ( users . get Enabled ( ) == NUM ) ? BOOL : BOOL ) ; users DAO . update ( jpa Users ) ; rest Wrapper = new Rest Wrapper ( users , Rest Wrapper . OK ) ; LOGGER . info ( STRING + users . get Username ( ) + STRING + principal . get Name ( ) + users ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; rest Wrapper = new Rest Wrapper ( e . get Message ( ) , Rest Wrapper . ERROR ) ; } return rest Wrapper ; }
public Set < Word Token > nearest Words ( final int distance , Predicate < Dependency > predicate , final Word Token ... start ) { return nearest Words ( distance , predicate , Arrays . as List ( start ) ) ; }
public void put ( String key , Array List < String > value ) { Iterator < Pair < String , Array List < String > > > it = store . iterator ( ) ; while ( it . has Next ( ) ) { Pair < String , Array List < String > > pair = it . next ( ) ; if ( key . equals ( pair . first ) ) { pair . second = value ; return ; } } store . add ( new Pair < > ( key , value ) ) ; }
public List < Interval > insert ( List < Interval > intervals , Interval new Interval ) { List < Interval > res = new Array List < > ( ) ; res . add ( new Interval ) ; if ( intervals == null || intervals . size ( ) == NUM ) { return res ; } for ( Interval i : intervals ) { int start = res . get ( res . size ( ) - NUM ) . start ; int end = res . get ( res . size ( ) - NUM ) . end ; if ( i . end < start ) { res . add ( res . size ( ) - NUM , i ) ; } else if ( end < i . start ) { res . add ( i ) ; } else { start = Math . min ( start , i . start ) ; end = Math . max ( end , i . end ) ; res . set ( res . size ( ) - NUM , new Interval ( start , end ) ) ; } } return res ; }
private String extract Human Readable Realm String ( String realm ) { if ( realm == null || ! realm . contains ( STRING ) ) { return STRING ; } List < String > tokens = new Array List < String > ( ) ; String Tokenizer tokenizer = new String Tokenizer ( realm , STRING ) ; while ( tokenizer . has More Tokens ( ) ) { tokens . add ( tokenizer . next Token ( ) ) ; } String extracted Realm String = STRING ; for ( String token : tokens ) { if ( token . contains ( STRING ) ) { extracted Realm String += STRING + token . substring ( token . index Of ( STRING ) + NUM ) ; } } extracted Realm String += STRING ; return extracted Realm String ; }
private void check Parameters ( ) throws SSL Exception { assert key Store Type != null ; assert proto != null ; check Null Parameter ( key Store File Path , STRING ) ; check Null Parameter ( key Store Pwd , STRING ) ; if ( trust Mgrs == null ) { if ( trust Store File Path == null ) throw new SSL Exception ( STRING + STRING ) ; else check Null Parameter ( trust Store Pwd , STRING ) ; } }
private XY Plot initialize Lower Plot ( ) { daemon Threads = new Y Interval Series Improved ( STRING ) ; Y Interval Series Collection y Interval Series Collection = new Y Interval Series Collection ( ) ; y Interval Series Collection . add Series ( daemon Threads ) ; Deviation Renderer renderer = new Deviation Renderer ( BOOL , BOOL ) ; renderer . set Base Shapes Visible ( BOOL ) ; renderer . set Series Stroke ( NUM , new Basic Stroke ( NUM ) ) ; renderer . set Series Outline Stroke ( NUM , new Basic Stroke ( NUM ) ) ; renderer . set Series Shape ( NUM , new Ellipse 2 D . Double ( - NUM , - NUM , NUM , NUM ) ) ; renderer . set Base Tool Tip Generator ( new Standard XY Tool Tip Generator ( Standard XY Tool Tip Generator . DEFAULT TOOL TIP FORMAT , Date Format . get Date Time Instance ( ) , Number Format . get Number Instance ( ) ) ) ; final Number Axis range Axis = new Number Axis ( STRING ) ; range Axis . set Standard Tick Units ( Number Axis . create Integer Tick Units ( ) ) ; range Axis . set Auto Range Minimum Size ( NUM , BOOL ) ; range Axis . set Range Type ( Range Type . POSITIVE ) ; final XY Plot subplot = new XY Plot ( y Interval Series Collection , null , range Axis , renderer ) ; subplot . set Axis Offset ( new Rectangle Insets ( NUM , NUM , NUM , NUM ) ) ; subplot . set Range Axis Location ( Axis Location . TOP OR LEFT ) ; subplot . set Range Crosshair Visible ( BOOL ) ; return subplot ; }
@ Not Null private Flutter Daemon Controller controller For ( String project Dir , String device Id ) { synchronized ( my Lock ) { Flutter Daemon Controller new Controller = new Flutter Daemon Controller ( project Dir ) ; my Controllers . add ( new Controller ) ; new Controller . add Listener ( my Listener ) ; return new Controller ; } }
private static J Check Box configure Check Box ( J Check Box check Box ) { check Box . set Horizontal Alignment ( J Check Box . LEFT ) ; check Box . set Font ( UI Manager . get Font ( STRING ) ) ; check Box . set Border Painted ( BOOL ) ; check Box . set Focus Painted ( BOOL ) ; check Box . set Focusable ( BOOL ) ; check Box . set Opaque ( BOOL ) ; return check Box ; }
protected void process Window Event ( Window Event e ) { if ( e . get ID ( ) == Window Event . WINDOW CLOSING ) dispose ( ) ; super . process Window Event ( e ) ; }
public static void do Deactivate Vcenter Data Center ( Db Client db Client , Vcenter Data Center data Center ) { List < Named Element Query Result List . Named Element > host Uris = list Children ( db Client , data Center . get Id ( ) , Host . class , STRING , STRING ) ; Set < URI > do Not Deleteclusters = new Hash Set < URI > ( ) ; for ( Named Element Query Result List . Named Element host Uri : host Uris ) { Host host = db Client . query Object ( Host . class , host Uri . get Id ( ) ) ; if ( host != null && ! host . get Inactive ( ) ) { if ( Null Column Value Getter . is Null URI ( host . get Compute Element ( ) ) ) { do Deactivate Host ( db Client , host ) ; } else { host . set Vcenter Data Center ( Null Column Value Getter . get Null URI ( ) ) ; db Client . persist Object ( host ) ; if ( ! Null Column Value Getter . is Null URI ( host . get Cluster ( ) ) ) { do Not Deleteclusters . add ( host . get Cluster ( ) ) ; } } } } List < Named Element Query Result List . Named Element > clusters Uris = list Children ( db Client , data Center . get Id ( ) , Cluster . class , STRING , STRING ) ; for ( Named Element Query Result List . Named Element cluster Uri : clusters Uris ) { Cluster cluster = db Client . query Object ( Cluster . class , cluster Uri . get Id ( ) ) ; if ( cluster != null && ! cluster . get Inactive ( ) ) { if ( do Not Deleteclusters . contains ( cluster . get Id ( ) ) ) { cluster . set Vcenter Data Center ( Null Column Value Getter . get Null URI ( ) ) ; cluster . set External Id ( Null Column Value Getter . get Null Str ( ) ) ; db Client . persist Object ( cluster ) ; } else { db Client . mark For Deletion ( cluster ) ; Event Utils . delete Resource Events ( db Client , cluster . get Id ( ) ) ; } } } log . info ( STRING , data Center . get Label ( ) , data Center . get Id ( ) ) ; db Client . mark For Deletion ( data Center ) ; Event Utils . delete Resource Events ( db Client , data Center . get Id ( ) ) ; }
@ Nullable public static String merge Xml ( @ Not Null Rendering Context context , String source Xml , String target Xml , File target File ) { boolean ok ; String file Name = target File . get Name ( ) ; String contents ; if ( file Name . equals ( Sdk Constants . FN ANDROID MANIFEST XML ) ) { Document current Document = Xml Utils . parse Document Silently ( target Xml , BOOL ) ; assert current Document != null : target Xml + STRING ; Document fragment = Xml Utils . parse Document Silently ( source Xml , BOOL ) ; assert fragment != null : source Xml + STRING ; contents = merge Manifest ( target File , target Xml , source Xml ) ; ok = contents != null ; } else { String parent Folder Name = target File . get Parent File ( ) . get Name ( ) ; Resource Folder Type folder Type = Resource Folder Type . get Folder Type ( parent Folder Name ) ; contents = merge Resource File ( context , target Xml , source Xml , file Name , folder Type ) ; ok = contents != null ; } if ( ! ok ) { contents = wrap With Merge Conflict ( target Xml , source Xml ) ; context . get Warnings ( ) . add ( String . format ( STRING , target File . get Name ( ) ) ) ; } return contents ; }
public synchronized void engine Delete Entry ( String alias ) throws Key Store Exception { if ( debug != null ) { debug . println ( STRING + alias + STRING ) ; } Entry entry = entries . get ( alias . to Lower Case ( Locale . ENGLISH ) ) ; if ( entry instanceof Private Key Entry ) { Private Key Entry key Entry = ( Private Key Entry ) entry ; if ( key Entry . chain != null ) { certificate Count -= key Entry . chain . length ; } private Key Count -- ; } else if ( entry instanceof Cert Entry ) { certificate Count -- ; } else if ( entry instanceof Secret Key Entry ) { secret Key Count -- ; } entries . remove ( alias . to Lower Case ( Locale . ENGLISH ) ) ; }
public void remove Smaller ( int value ) { int target Position = Arrays . binary Search ( backing Array , NUM , num Elements , value ) ; if ( target Position < NUM ) { target Position = - target Position - NUM ; } num Elements -= target Position ; if ( target Position != NUM && num Elements > NUM ) { System . arraycopy ( backing Array , target Position , backing Array , NUM , num Elements ) ; } }
public final void print Initial Clustering Changes ( File file , List < Cluster Data > cluster Data , int [ ] mat Index To Msg Internal Id ) throws Ade Usage Exception { if ( m initial Clusters == null ) { return ; } final Print Writer out = File Utils . open Print Writer To File ( file , BOOL ) ; if ( m final Clusters == null ) { update Clusters ( cluster Data , mat Index To Msg Internal Id ) ; } int count No Change = NUM ; int count Contained = NUM ; for ( Map . Entry < String , Array List < Integer > > entry : m initial Clusters . entry Set ( ) ) { final String name = entry . get Key ( ) ; final Array List < Integer > members = entry . get Value ( ) ; out . printf ( STRING , name , members ) ; int count C = NUM ; boolean split Flag = BOOL ; final Array List < String > names = new Array List < String > ( ) ; for ( Map . Entry < String , Collection < Integer > > new Entry : m final Clusters . entry Set ( ) ) { final Collection < Integer > new Members = new Entry . get Value ( ) ; final String new Name = new Entry . get Key ( ) ; int count M = NUM ; boolean update C = BOOL ; for ( int m : new Members ) { if ( members . contains ( mat Index To Msg Internal Id [ m ] ) ) { if ( update C ) { count C ++ ; update C = BOOL ; names . add ( new Name ) ; } count M ++ ; } } if ( count M == members . size ( ) ) { split Flag = BOOL ; if ( members . size ( ) == new Members . size ( ) ) { out . printf ( STRING ) ; count No Change ++ ; } else { out . printf ( STRING , new Name ) ; count Contained ++ ; } break ; } } if ( split Flag ) { out . printf ( STRING , count C , names ) ; } } out . printf ( STRING , count No Change , count Contained , m initial Clusters . size ( ) - count No Change - count Contained ) ; out . close ( ) ; }
protected void add To GUI ( J Panel gui , Abstract Button b , String cmd ) { b . set Action Command ( cmd ) ; b . add Action Listener ( this ) ; gui . add ( b ) ; }
public static Array List < String > tokenize Query ( Analyzer lucene Analyzer , String query ) { Array List < String > result = new Array List < String > ( ) ; Token Stream token Stream = lucene Analyzer . token Stream ( null , new String Reader ( query ) ) ; Char Term Attribute term = token Stream . add Attribute ( Char Term Attribute . class ) ; try { token Stream . reset ( ) ; while ( token Stream . increment Token ( ) ) { result . add ( term . to String ( ) ) ; } token Stream . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return result ; }
public boolean check trace ( Shape Tile p shape , int p layer , Net Nos List p net no arr , int p cl class , Set < Brd Abit Pin > p contact pins ) { if ( ! p shape . is contained in ( bounding box ) ) return BOOL ; Awtree Shape Search default tree = search tree manager . get default tree ( ) ; Collection < Awtree Find Entry > tree entries = default tree . find overlap tree entries with clearance ( p shape , p layer , Net Nos List . EMPTY , p cl class ) ; for ( Awtree Find Entry curr tree entry : tree entries ) { if ( ! ( curr tree entry . object instanceof Brd Item ) ) continue ; Brd Item curr item = ( Brd Item ) curr tree entry . object ; if ( p contact pins != null ) { if ( p contact pins . contains ( curr item ) ) continue ; if ( curr item instanceof Brd Abit Pin ) { return BOOL ; } } boolean is obstacle = p net no arr . is trace obstacle ( curr item ) ; if ( is obstacle && ( curr item instanceof Brd Tracep ) && p contact pins != null ) { Shape Tile intersection = null ; for ( Brd Abit Pin curr contact pin : p contact pins ) { if ( curr contact pin . net count ( ) <= NUM || ! curr contact pin . shares net ( curr item ) ) continue ; if ( intersection == null ) { Shape Tile obstacle trace shape = curr item . tile shape get ( curr tree entry . shape index in object ) ; intersection = p shape . intersection ( obstacle trace shape ) ; } Shape Tile pin shape = curr contact pin . get tile shape on layer ( p layer ) ; if ( pin shape . contains approx ( intersection ) ) { is obstacle = BOOL ; break ; } } } if ( is obstacle ) return BOOL ; } return BOOL ; }
public static void delete ( File file Or Folder ) { if ( file Or Folder != null ) delete ( file Or Folder . to Path ( ) ) ; }
public static Iterator create Shape 3 D ( Shape shape , double baseline Height , Color color , boolean filled ) { int buffer Size = DEFAULT NPOINTS BUFFER SIZE ; double [ ] data = expand Array D ( buffer Size , null ) ; int data Index = NUM ; int refresh Counter = buffer Size ; int [ ] strip Count = new int [ NUM ] ; strip Count [ NUM ] = NUM ; Path Iterator pi 2 = shape . get Path Iterator ( null ) ; float flatness = NUM ; Flattening Path Iterator pi = new Flattening Path Iterator ( pi 2 , flatness ) ; double [ ] coords = new double [ NUM ] ; double pntx = NUM ; double pnty = NUM ; double pntz = baseline Height ; Hash Set set = new Hash Set ( ) ; Shape 3 D shape 3 D = null ; Debug . message ( STRING , STRING ) ; while ( ! pi . is Done ( ) ) { int type = pi . current Segment ( coords ) ; switch ( type ) { case Path Iterator . SEG MOVETO : if ( data Index != NUM ) { shape 3 D = create Shape 3 D ( data , data Index , strip Count , color , filled ) ; if ( shape 3 D != null ) { set . add ( shape 3 D ) ; } data = expand Array D ( buffer Size , null ) ; data Index = NUM ; } case Path Iterator . SEG LINETO : pntx = coords [ NUM ] ; pnty = coords [ NUM ] ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + pntx + STRING + pnty ) ; } if ( data Index >= data . length ) { data = expand Array D ( buffer Size , data ) ; refresh Counter = buffer Size ; } data [ data Index ++ ] = pntx ; data [ data Index ++ ] = pntz ; data [ data Index ++ ] = pnty ; strip Count [ NUM ] ++ ; refresh Counter -= NUM ; break ; default : Debug . message ( STRING , STRING + coords [ NUM ] + STRING + coords [ NUM ] + STRING ) ; } pi . next ( ) ; } if ( data Index != NUM ) { shape 3 D = create Shape 3 D ( data , data Index , strip Count , color , filled ) ; if ( shape 3 D != null ) { set . add ( shape 3 D ) ; } } return set . iterator ( ) ; }
public void take Values From ( Bean < T > bean ) { for ( Property Descriptor property : get Properties ( ) ) { set Value ( property , bean . get Value ( property . get Name ( ) ) ) ; } }
protected double decode ( int value , double lower , double upper , int nbits ) { int maxval = ( int ) ( Math . pow ( NUM , nbits ) - NUM ) ; return value * ( ( upper - lower ) / ( maxval - NUM ) ) + lower ; }
public int read ( byte b [ ] , int off , int len ) throws IO Exception { if ( input Stream == null ) { throw new IO Exception ( STRING ) ; } int gotsofar = NUM ; while ( gotsofar < len ) { int read = input Stream . read ( b , off + gotsofar , len - gotsofar ) ; if ( read == - NUM ) { if ( gotsofar > NUM ) { count ( gotsofar ) ; return gotsofar ; } else { return read ; } } else { gotsofar += read ; } } count ( gotsofar ) ; return gotsofar ; }
public void handle Tbl DS Attribute Map List Button Add Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; WSPP Service DS Attribute Map List Add View Bean vb = ( WSPP Service DS Attribute Map List Add View Bean ) get View Bean ( WSPP Service DS Attribute Map List Add View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; forward To ( ) ; } }
final V do Remove ( Object key , Object value ) { if ( key == null ) throw new Null Pointer Exception ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) < NUM ) break outer ; if ( c > NUM ) { b = n ; n = f ; continue ; } if ( value != null && ! value . equals ( v ) ) break outer ; if ( ! n . cas Value ( v , null ) ) break ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find Node ( key ) ; else { find Predecessor ( key , cmp ) ; if ( head . right == null ) try Reduce Level ( ) ; } @ Suppress Warnings ( STRING ) V vv = ( V ) v ; return vv ; } } return null ; }
void handle Swf Unloaded Event ( Swf Unloaded Event e ) { dump Swf Unloaded Line ( e ) ; }
private void update Quick Reply View ( String edit Text ) { if ( Build Config . DEBUG ) Log . v ( STRING + edit Text + STRING ) ; if ( qr Edit Text != null && edit Text != null ) { qr Edit Text . set Text ( edit Text + signature Text ) ; qr Edit Text . set Selection ( edit Text . length ( ) ) ; } if ( quickreply Text View != null && quick Reply Sms Message != null ) { quickreply Text View . set Text ( get String ( R . string . quickreply from text , quick Reply Sms Message . get Contact Name ( ) ) ) ; } }
@ Override protected synchronized void read ( long offset , byte [ ] b ) throws IO Exception { if ( byte Buffer != null ) { byte Buffer . position ( ( int ) offset ) ; byte Buffer . get ( b ) ; } else { throw new IO Exception ( STRING + get Path ( ) + STRING ) ; } }
public static int hash 3 ( int hash , Object x , Object y , Object z ) { return NUM | ( hash + NUM * System . identity Hash Code ( x ) + NUM * System . identity Hash Code ( y ) + NUM * System . identity Hash Code ( z ) ) ; }
public void fill ( View view ) { validate Not Nullable View ( view ) ; try { if ( view instanceof View Group ) { View Group view Group = ( View Group ) view ; for ( int i = NUM ; i < view Group . get Child Count ( ) ; i ++ ) { View child = view Group . get Child At ( i ) ; fill ( child ) ; } } else { if ( m Ids == null ) { fill View ( view ) ; } else if ( m Ids . contains ( view . get Id ( ) ) ) { fill View ( view ) ; } } } catch ( Exception e ) { e . print Stack Trace ( ) ; } finally { m Faker = null ; } }
public void replace Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( last State != state ) { already Replaced = BOOL ; } last State = state ; if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state , BOOL ) ; if ( ext . length <= NUM ) { throw new Auth Login Exception ( bundle Name , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM ) ) [ NUM ] ; if ( ! ( already Replaced ) ) { header With Replace Tag = pc . get Header ( ) ; } int idx = header With Replace Tag . index Of ( STRING ) ; if ( idx != - NUM ) { String new Header = header With Replace Tag . substring ( NUM , idx ) + header ; pc . set Header ( new Header ) ; already Replaced = BOOL ; } else { String new Header = header With Replace Tag . substring ( NUM , header With Replace Tag . index Of ( STRING ) ) + STRING + header ; pc . set Header ( new Header ) ; } } }
public static String format As Generalized Time ( final long date ) { final String Builder sb = new String Builder ( NUM ) ; final Gregorian Calendar calendar = new Gregorian Calendar ( TIME ZONE UTC OBJ ) ; calendar . set Lenient ( BOOL ) ; calendar . set Time In Millis ( date ) ; int n = calendar . get ( Calendar . YEAR ) ; if ( n < NUM ) { final Illegal Argument Exception e = new Illegal Argument Exception ( STRING + n ) ; throw e ; } else if ( n < NUM ) { sb . append ( STRING ) ; } else if ( n < NUM ) { sb . append ( STRING ) ; } else if ( n < NUM ) { sb . append ( STRING ) ; } sb . append ( n ) ; n = calendar . get ( Calendar . MONTH ) + NUM ; if ( n < NUM ) { sb . append ( STRING ) ; } sb . append ( n ) ; n = calendar . get ( Calendar . DAY OF MONTH ) ; if ( n < NUM ) { sb . append ( STRING ) ; } sb . append ( n ) ; n = calendar . get ( Calendar . HOUR OF DAY ) ; if ( n < NUM ) { sb . append ( STRING ) ; } sb . append ( n ) ; n = calendar . get ( Calendar . MINUTE ) ; if ( n < NUM ) { sb . append ( STRING ) ; } sb . append ( n ) ; n = calendar . get ( Calendar . SECOND ) ; if ( n < NUM ) { sb . append ( STRING ) ; } sb . append ( n ) ; sb . append ( STRING ) ; n = calendar . get ( Calendar . MILLISECOND ) ; if ( n < NUM ) { sb . append ( STRING ) ; } else if ( n < NUM ) { sb . append ( STRING ) ; } sb . append ( n ) ; sb . append ( STRING ) ; return sb . to String ( ) ; }
public boolean remove ( int location , Image Info object ) { final boolean removed = data . remove ( object ) ; notify Item Range Removed ( location , data . size ( ) ) ; return removed ; }
protected List < String > list User Names ( ) throws Users Repository Exception { Collection < User > users = get All Users ( ) ; List < String > user Names = new Array List < String > ( users . size ( ) ) ; for ( User user : users ) { user Names . add ( user . get User Name ( ) ) ; } users . clear ( ) ; return user Names ; }
void delete Local Device ( Volume Info device Info ) throws V Plex Api Exception { String device Name = V Plex Api Constants . DEVICE PREFIX + device Info . get Volume Name ( ) ; delete Local Device ( device Name ) ; }
public T File Index ( int entry Count , Data Input in , Bytes Comparator comparator ) throws IO Exception { index = new Array List < T File Index Entry > ( entry Count ) ; record Num Index = new Array List < Long > ( entry Count ) ; int size = Utils . read V Int ( in ) ; if ( size > NUM ) { byte [ ] buffer = new byte [ size ] ; in . read Fully ( buffer ) ; Data Input Stream first Key Input Stream = new Data Input Stream ( new Byte Array Input Stream ( buffer , NUM , size ) ) ; int first Key Length = Utils . read V Int ( first Key Input Stream ) ; first Key = new Byte Array ( new byte [ first Key Length ] ) ; first Key Input Stream . read Fully ( first Key . buffer ( ) ) ; for ( int i = NUM ; i < entry Count ; i ++ ) { size = Utils . read V Int ( in ) ; if ( buffer . length < size ) { buffer = new byte [ size ] ; } in . read Fully ( buffer , NUM , size ) ; T File Index Entry idx = new T File Index Entry ( new Data Input Stream ( new Byte Array Input Stream ( buffer , NUM , size ) ) ) ; index . add ( idx ) ; sum += idx . entries ( ) ; record Num Index . add ( sum ) ; } } else { if ( entry Count != NUM ) { throw new Runtime Exception ( STRING ) ; } } this . comparator = comparator ; }
public void interrupt ( ) { Thread t = thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } thread Var . clear ( ) ; }
private int show Has Changed Dialog ( ) { Object [ ] options = { STRING , STRING , STRING } ; return J Option Pane . show Option Dialog ( frame , STRING + STRING , STRING , J Option Pane . YES NO OPTION , J Option Pane . WARNING MESSAGE , null , options , options [ NUM ] ) ; }
public Tv Show Update Datasource Task 2 ( String datasource ) { super ( BUNDLE . get String ( STRING ) + STRING + datasource + STRING ) ; tv Show List = Tv Show List . get Instance ( ) ; data Sources = new Array List < > ( NUM ) ; data Sources . add ( datasource ) ; }
public void line Starts At ( int char In File ) { if ( immutable ) { throw new Unsupported Operation Exception ( ) ; } if ( n Lines == line Nums . length ) { int [ ] new Line Nums = new int [ n Lines * NUM ] ; System . arraycopy ( line Nums , NUM , new Line Nums , NUM , n Lines ) ; line Nums = new Line Nums ; } line Nums [ n Lines ++ ] = char In File ; cached Char In File = - NUM ; }
public void add ( final Sensor sensor ) { Set < Sensor > old Selection = new Hash Set < Sensor > ( selection ) ; boolean rv = selection . add ( sensor ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
protected boolean include ( Iterable < String > path , String name ) throws IO Exception , Lexer Exception { for ( String dir : path ) { Virtual File file = filesystem . get File ( dir , name ) ; if ( include ( file ) ) return BOOL ; } Virtual File file = filesystem . get File ( name ) ; if ( include ( file ) ) return BOOL ; return BOOL ; }
public boolean is Alive ( ) { return ! socket . is Closed ( ) && ! socket . is Input Shutdown ( ) && ! socket . is Output Shutdown ( ) ; }
@ Override public void on Message ( Message message ) { synchronized ( messages ) { messages . add ( message ) ; if ( verbose ) { LOG . info ( STRING + message ) ; } messages . notify All ( ) ; } }
public Hash ( byte [ ] hash ) { if ( hash . length != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } this . bytes = new byte [ NUM ] ; System . arraycopy ( hash , NUM , this . bytes , NUM , NUM ) ; }
private void apply Opposite Bicycle Permissions ( Way way , Enum Set < Edge Store . Edge Flag > backward ) { String cycleway Left Tag Value = way . get Tag ( STRING ) ; String cycleway Right Tag Value = way . get Tag ( STRING ) ; String cycleway Tag Value = way . get Tag ( STRING ) ; boolean added Bike Permissions = BOOL ; if ( cycleway Tag Value != null && cycleway Tag Value . starts With ( STRING ) ) { backward . add ( Edge Store . Edge Flag . ALLOWS BIKE ) ; added Bike Permissions = BOOL ; } else if ( cycleway Right Tag Value != null ) { if ( cycleway Right Tag Value . starts With ( STRING ) ) { backward . add ( Edge Store . Edge Flag . ALLOWS BIKE ) ; added Bike Permissions = BOOL ; } } if ( ! added Bike Permissions && cycleway Left Tag Value != null ) { if ( cycleway Left Tag Value . starts With ( STRING ) ) { backward . add ( Edge Store . Edge Flag . ALLOWS BIKE ) ; } } }
public void handle Button 1 Request ( Request Invocation Event event ) throws Model Control Exception { FS Auth Domains Model model = ( FS Auth Domains Model ) get Model ( ) ; String name = ( String ) get Display Field Value ( model . TF NAME ) ; AM Property Sheet ps = ( AM Property Sheet ) get Child ( PROPERTY ATTRIBUTE ) ; try { String realm = model . get Realm ( name ) ; Map values = ps . get Attribute Values ( model . get Data Map ( ) , BOOL , model ) ; model . set Attribute Values ( realm , name , values ) ; Serialized Field sz Cache = ( Serialized Field ) get Child ( SZ CACHE ) ; Federation View Bean vb = ( Federation View Bean ) get View Bean ( Federation View Bean . class ) ; CC Add Remove add Remove List = ( CC Add Remove ) get Child ( ADD REMOVE PROVIDERS ) ; add Remove List . restore State Data ( ) ; CC Add Remove Model add Remove Model = ( CC Add Remove Model ) add Remove List . get Model ( ) ; List list = new Array List ( get Selected Values ( add Remove Model ) ) ; model . add Providers ( realm , name , list ) ; set Inline Alert Message ( CC Alert . TYPE INFO , STRING , STRING ) ; forward To ( ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; forward To ( ) ; } }
public static byte [ ] read Byte Array ( final Data Input in ) throws IO Exception { int len = Writable Utils . read V Int ( in ) ; if ( len < NUM ) { throw new Negative Array Size Exception ( Integer . to String ( len ) ) ; } byte [ ] result = new byte [ len ] ; in . read Fully ( result , NUM , len ) ; return result ; }
@ Deprecated public void write ( String output File , boolean use Relative Paths , String relative Base ) throws IO Exception { Print Writer writer = UTF 8 . print Writer ( output File ) ; try { writer . println ( JAR FILES KEY ) ; for ( String jar File : analysis Targets ) { if ( use Relative Paths ) { jar File = convert To Relative ( jar File , relative Base ) ; } writer . println ( jar File ) ; } writer . println ( SRC DIRS KEY ) ; for ( String src Dir : src Dir List ) { if ( use Relative Paths ) { src Dir = convert To Relative ( src Dir , relative Base ) ; } writer . println ( src Dir ) ; } writer . println ( AUX CLASSPATH ENTRIES KEY ) ; for ( String aux Classpath Entry : aux Classpath Entry List ) { if ( use Relative Paths ) { aux Classpath Entry = convert To Relative ( aux Classpath Entry , relative Base ) ; } writer . println ( aux Classpath Entry ) ; } if ( use Relative Paths ) { writer . println ( OPTIONS KEY ) ; writer . println ( RELATIVE PATHS + STRING ) ; } } finally { writer . close ( ) ; } is Modified = BOOL ; }
public Joiner join ( Class < ? extends Data Object > clazz , String alias , Data Object ... objs ) { return join ( clazz , alias , new Array List < Data Object > ( Arrays . as List ( objs ) ) ) ; }
public void test Search ( ) throws Exception { String Writer sw = new String Writer ( ) ; Print Writer pw = new Print Writer ( sw , BOOL ) ; do Test Search ( random ( ) , pw , BOOL ) ; pw . close ( ) ; sw . close ( ) ; String multi File Output = sw . to String ( ) ; sw = new String Writer ( ) ; pw = new Print Writer ( sw , BOOL ) ; do Test Search ( random ( ) , pw , BOOL ) ; pw . close ( ) ; sw . close ( ) ; String single File Output = sw . to String ( ) ; assert Equals ( multi File Output , single File Output ) ; }
public String show Switch Wwn ( ) throws Network Device Controller Exception { SSH Prompt [ ] prompts = { SSH Prompt . POUND , SSH Prompt . GREATER THAN , SSH Prompt . MDS CONFIG , SSH Prompt . MDS CONFIG IVR ZONE , SSH Prompt . MDS CONFIG IVR ZONESET } ; String Builder buf = new String Builder ( ) ; send Wait For ( MDS Dialog Properties . get String ( STRING ) , default Timeout , prompts , buf ) ; String [ ] lines = get Lines ( buf ) ; String [ ] regex = { MDS Dialog Properties . get String ( STRING ) } ; String switch Wwn = null ; String [ ] groups = new String [ NUM ] ; for ( String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case NUM : switch Wwn = groups [ NUM ] ; break ; } if ( switch Wwn != null ) { break ; } } return switch Wwn ; }
public void reset ( ) { set Service ( OBD SVC NONE , BOOL ) ; cmd Queue . clear ( ) ; pid Supported . clear ( ) ; reset Fixed Pid ( ) ; Pid Pvs . clear ( ) ; t Codes . clear ( ) ; Vid Pvs . clear ( ) ; }
public Quad Edge locate From Edge ( Vertex v , Quad Edge start Edge ) { int iter = NUM ; int max Iter = quad Edges . size ( ) ; Quad Edge e = start Edge ; while ( BOOL ) { iter ++ ; if ( iter > max Iter ) { throw new Locate Failure Exception ( e . to Line Segment ( ) ) ; } if ( ( v . equals ( e . orig ( ) ) ) || ( v . equals ( e . dest ( ) ) ) ) { break ; } else if ( v . right Of ( e ) ) { e = e . sym ( ) ; } else if ( ! v . right Of ( e . o Next ( ) ) ) { e = e . o Next ( ) ; } else if ( ! v . right Of ( e . d Prev ( ) ) ) { e = e . d Prev ( ) ; } else { break ; } } return e ; }
static void remove Duplicate Affix ( List < String > str List , boolean is Suffix ) { Hash Set < String > str Set = new Hash Set < String > ( str List ) ; str List . clear ( ) ; str List . add All ( str Set ) ; if ( is Suffix ) { Collections . sort ( str List , null ) ; } else { Collections . sort ( str List , null ) ; } }
default B with Default ( String key , long value ) { return with Default ( key , Long . to String ( value ) ) ; }
private void list Directory ( File directory , Relative Directory subdirectory , Set < Java File Object . Kind > file Kinds , boolean recurse , List Buffer < Java File Object > result List ) { File d = subdirectory . get File ( directory ) ; if ( ! case Map Check ( d , subdirectory ) ) return ; File [ ] files = d . list Files ( ) ; if ( files == null ) return ; if ( sort Files != null ) Arrays . sort ( files , sort Files ) ; for ( File f : files ) { String fname = f . get Name ( ) ; if ( f . is Directory ( ) ) { if ( recurse && is Valid Directory ( fname ) ) { list Directory ( directory , new Relative Directory ( subdirectory , fname ) , file Kinds , recurse , result List ) ; } } else { if ( is Valid File ( fname , file Kinds ) ) { Java File Object fe = new Regular File Object ( this , fname , new File ( d , fname ) ) ; result List . append ( fe ) ; } } } }
private Shape decode Shadow ( int width , int height ) { path . reset ( ) ; path . move To ( width - NUM , NUM ) ; path . line To ( width - NUM , height - NUM ) ; path . line To ( width - NUM , height - NUM ) ; path . line To ( NUM , height - NUM ) ; path . line To ( NUM , height - NUM ) ; return path ; }
public static I Method Binding find Overridden Method ( I Method Binding overriding , boolean test Visibility ) { List < I Method Binding > find Overridden Methods = find Overridden Methods ( overriding , test Visibility , BOOL ) ; if ( find Overridden Methods . is Empty ( ) ) { return null ; } return find Overridden Methods . get ( NUM ) ; }
boolean add Index Entry ( Service Type resource Type , String resource Name , String policy Name ) { boolean processed = BOOL ; Resource Match resource Match = resource Type . compare ( this . resource Name , resource Name , BOOL ) ; if ( resource Match . equals ( Resource Match . EXACT MATCH ) ) { policy Names . add ( policy Name ) ; processed = BOOL ; } else if ( resource Match . equals ( Resource Match . SUB RESOURCE MATCH ) ) { Iterator iter = child Entries . iterator ( ) ; while ( ! processed && ( iter . has Next ( ) ) ) { Resource Index Entry resource Index Entry = ( Resource Index Entry ) iter . next ( ) ; if ( resource Index Entry . add Index Entry ( resource Type , resource Name , policy Name ) ) { processed = BOOL ; } } if ( ! processed ) { Resource Index Entry resource Index Entry = new Resource Index Entry ( resource Name , policy Name ) ; Set children = new Hash Set ( ) ; children . add All ( child Entries ) ; Iterator iter 1 = children . iterator ( ) ; while ( iter 1 . has Next ( ) ) { Resource Index Entry rie = ( Resource Index Entry ) iter 1 . next ( ) ; Resource Match rm = resource Type . compare ( resource Name , rie . resource Name , BOOL ) ; if ( rm . equals ( Resource Match . SUB RESOURCE MATCH ) ) { rie . set Parent ( resource Index Entry ) ; } } child Entries . add ( resource Index Entry ) ; processed = BOOL ; } } return processed ; }
@ Override public void read External ( Object Input in ) throws IO Exception , Class Not Found Exception { super . read External ( in ) ; this . knn Distance = in . read Double ( ) ; }
public Obj Id Map ( Obj Id Map old Map ) { this . table = new Entry [ old Map . table . length ] ; System . arraycopy ( old Map . table , NUM , this . table , NUM , this . table . length ) ; this . count = old Map . count ; this . threshold = old Map . threshold ; this . load Factor = old Map . load Factor ; }
public static Connection Factory new Failover Connection Factory ( Set < LDAPURL > servers , String username , char [ ] password , int heart Beat Interval , String heart Beat Time Unit , Options ldap Options ) { List < Connection Factory > factories = new Array List < Connection Factory > ( servers . size ( ) ) ; for ( LDAPURL ldapurl : servers ) { factories . add ( new Connection Factory ( ldapurl , username , password , heart Beat Interval , heart Beat Time Unit , ldap Options ) ) ; } return load Balance Factories ( factories ) ; }
public void add Arg ( final int index , final B Op new Arg ) { if ( new Arg == null ) throw new Illegal Argument Exception ( ) ; if ( new Arg == this ) throw new Illegal Argument Exception ( ) ; args . add ( index , new Arg ) ; mutation ( ) ; }
boolean is Any State ( Element element , State ... states ) { String ordinal Str = element . get Attribute ( ATTR STATE ) ; if ( ordinal Str == null ) { return BOOL ; } int ordinal = - NUM ; try { ordinal = Integer . parse Int ( ordinal Str ) ; } catch ( Number Format Exception e ) { return BOOL ; } for ( State state : states ) { if ( ordinal == state . ordinal ( ) ) { return BOOL ; } } return BOOL ; }
protected void paint Double Buffered ( J Component c , Image image , Graphics g , int clip X , int clip Y , int clip W , int clip H ) { Graphics osg = image . get Graphics ( ) ; int bw = Math . min ( clip W , image . get Width ( null ) ) ; int bh = Math . min ( clip H , image . get Height ( null ) ) ; int x , y , maxx , maxy ; try { for ( x = clip X , maxx = clip X + clip W ; x < maxx ; x += bw ) { for ( y = clip Y , maxy = clip Y + clip H ; y < maxy ; y += bh ) { osg . translate ( - x , - y ) ; osg . set Clip ( x , y , bw , bh ) ; if ( volatile Buffer Type != Transparency . OPAQUE && osg instanceof Graphics 2 D ) { final Graphics 2 D g2 d = ( Graphics 2 D ) osg ; final Color old Bg = g2 d . get Background ( ) ; g2 d . set Background ( c . get Background ( ) ) ; g2 d . clear Rect ( x , y , bw , bh ) ; g2 d . set Background ( old Bg ) ; } c . paint To Offscreen ( osg , x , y , bw , bh , maxx , maxy ) ; g . set Clip ( x , y , bw , bh ) ; if ( volatile Buffer Type != Transparency . OPAQUE && g instanceof Graphics 2 D ) { final Graphics 2 D g2 d = ( Graphics 2 D ) g ; final Composite old Composite = g2 d . get Composite ( ) ; g2 d . set Composite ( Alpha Composite . Src ) ; g2 d . draw Image ( image , x , y , c ) ; g2 d . set Composite ( old Composite ) ; } else { g . draw Image ( image , x , y , c ) ; } osg . translate ( x , y ) ; } } } finally { osg . dispose ( ) ; } }
public static Abstract File Output Operator checkpoint ( Abstract File Output Operator writer , long window Id ) { if ( window Id >= Stateless . WINDOW ID ) { writer . before Checkpoint ( window Id ) ; } Kryo kryo = new Kryo ( ) ; Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; Output loutput = new Output ( bos ) ; kryo . write Object ( loutput , writer ) ; loutput . close ( ) ; Input l Input = new Input ( bos . to Byte Array ( ) ) ; @ Suppress Warnings ( STRING ) Abstract File Output Operator check Pointed Writer = kryo . read Object ( l Input , writer . get Class ( ) ) ; l Input . close ( ) ; return check Pointed Writer ; }
private byte [ ] first Token ( ) throws IO Exception { negotiator = null ; if ( cache != null ) { synchronized ( cache ) { negotiator = cache . get ( get Host ( ) ) ; if ( negotiator != null ) { cache . remove ( get Host ( ) ) ; } } } if ( negotiator == null ) { negotiator = Negotiator . get Negotiator ( hci ) ; if ( negotiator == null ) { IO Exception ioe = new IO Exception ( STRING ) ; throw ioe ; } } return negotiator . first Token ( ) ; }
public C Module Configuration ( final I Navi Module module , final SQL Provider provider , final Listener Provider < I Module Listener > listeners , final int module Id , final String name , final String comment , final Date creation Date , final Date modification Date , final String md 5 , final String sha 1 , final I Address file Base , final I Address image Base , final Debugger Template debugger Template , final boolean is Stared , final I Navi Raw Module raw Module ) { m module = module ; m provider = provider ; m listeners = listeners ; m id = module Id ; m name = name ; m description = comment ; m creation Date = new Date ( creation Date . get Time ( ) ) ; m modification Date = new Date ( modification Date . get Time ( ) ) ; m md 5 = md 5 ; m sha 1 = sha 1 ; m file Base = file Base ; m image Base = image Base ; m debugger Template = debugger Template ; m is Stared = is Stared ; m raw Module = raw Module ; update Debugger ( debugger Template ) ; }
public Shape screen To Chart Shape ( Shape s ) { General Path p = new General Path ( ) ; Transform t = Transform . make Identity ( ) ; if ( current Transform != null ) { t . concatenate ( current Transform . get Inverse ( ) ) ; } t . translate ( - get Absolute X ( ) , - get Absolute Y ( ) ) ; p . append ( s . get Path Iterator ( t ) , BOOL ) ; return p ; }
public void register ( final C Graph Window window ) { Preconditions . check Not Null ( window , STRING ) ; if ( m graphs . contains ( window ) ) { throw new Illegal State Exception ( STRING ) ; } m graphs . add ( window ) ; window . add Window Listener ( m listener ) ; for ( final I Window Manager Listener listener : m listeners ) { try { listener . window Opened ( this , window ) ; } catch ( final Exception e ) { C Utility Functions . log Exception ( e ) ; } } }
public Performance Logger ( String title ) { time 1 = System . current Time Millis ( ) ; }
protected Rewritten Outbound Url process Encode URL ( Http Servlet Response hs Response , Http Servlet Request hs Request , boolean encode Url Has Been Run , String outbound Url ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + outbound Url ) ; } if ( outbound Url == null ) { return new Rewritten Outbound Url ( null , BOOL ) ; } boolean final Encode Outbound Url = BOOL ; String final To Url = outbound Url ; final List outbound Rules = conf . get Outbound Rules ( ) ; try { for ( int i = NUM ; i < outbound Rules . size ( ) ; i ++ ) { final Outbound Rule outbound Rule = ( Outbound Rule ) outbound Rules . get ( i ) ; if ( ! encode Url Has Been Run && outbound Rule . is Encode First ( ) ) { continue ; } if ( encode Url Has Been Run && ! outbound Rule . is Encode First ( ) ) { continue ; } final Rewritten Outbound Url rewritten Url = outbound Rule . execute ( final To Url , hs Request , hs Response ) ; if ( rewritten Url != null ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + outbound Rule . get Display Name ( ) + STRING ) ; } final To Url = rewritten Url . get Target ( ) ; final Encode Outbound Url = rewritten Url . is Encode ( ) ; if ( outbound Rule . is Last ( ) ) { log . debug ( STRING ) ; break ; } } } } catch ( Invocation Target Exception e ) { try { handle Invocation Target Exception ( hs Request , hs Response , e ) ; } catch ( Servlet Exception e1 ) { log . error ( e1 ) ; } catch ( IO Exception e1 ) { log . error ( e1 ) ; } } return new Rewritten Outbound Url ( final To Url , final Encode Outbound Url ) ; }
private static final String Probability To String ( double val , int significant Digits ) { if ( val == NUM ) { return STRING ; } String val String = Double . to String ( val ) ; int val String Len = val String . length ( ) ; String result = STRING ; int next = NUM ; int significant Digits Found = NUM ; while ( ( next < val String Len ) && ( val String . char At ( next ) == STRING ) ) { next ++ ; } while ( ( next < val String Len ) && Character . is Digit ( val String . char At ( next ) ) ) { result = result + val String . char At ( next ) ; significant Digits Found ++ ; next ++ ; } if ( next == val String Len ) { return result ; } else if ( val String . char At ( next ) != STRING ) { return val String ; } if ( significant Digits Found >= significant Digits ) { next ++ ; while ( ( next < val String Len ) && Character . is Digit ( val String . char At ( next ) ) ) { next ++ ; } } else { next ++ ; result = result + STRING ; if ( significant Digits Found == NUM ) { while ( ( next < val String Len ) && ( val String . char At ( next ) == STRING ) ) { next ++ ; result = result + STRING ; } } while ( ( next < val String Len ) && Character . is Digit ( val String . char At ( next ) ) && significant Digits Found < significant Digits ) { result = result + val String . char At ( next ) ; next ++ ; significant Digits Found ++ ; } if ( ( next < val String Len ) && Character . is Digit ( val String . char At ( next ) ) && Character . digit ( val String . char At ( next ) , NUM ) >= NUM ) { int prev = result . length ( ) - NUM ; boolean done = BOOL ; while ( ! done ) { if ( prev < NUM ) { result = STRING + result ; done = BOOL ; } else { char prev Char = result . char At ( prev ) ; String front = result . substring ( NUM , prev ) ; String back = result . substring ( prev + NUM ) ; if ( Character . is Digit ( prev Char ) ) { if ( prev Char == STRING ) { result = front + STRING + back ; } else { result = front + Character . for Digit ( Character . digit ( prev Char , NUM ) + NUM , NUM ) + back ; done = BOOL ; } } else { } } prev -- ; } } while ( ( next < val String Len ) && Character . is Digit ( val String . char At ( next ) ) ) { next ++ ; } } if ( next >= val String Len ) { return result ; } if ( val String . char At ( next ) == STRING ) { next ++ ; result = result + STRING ; while ( next < val String Len ) { result = result + val String . char At ( next ) ; next ++ ; } return result ; } return val String ; }
private URI canonicalize ( String uri String ) throws URI Syntax Exception { if ( ( uri String == null ) || ( uri String . compare To ( STRING ) == NUM ) ) { uri String = STRING ; return new URI ( uri String ) ; } URI u = new URI ( uri String ) ; if ( u . is Absolute ( ) ) { if ( u . is Opaque ( ) ) { String scheme = u . get Scheme ( ) ; String ssp = u . get Scheme Specific Part ( ) ; String frag = u . get Fragment ( ) ; URI u2 = null ; int c1 index = uri String . index Of ( STRING ) ; int c2 index = uri String . last Index Of ( STRING ) ; if ( c2 index != c1 index ) { if ( frag == null ) { u2 = new URI ( scheme + STRING + ssp ) ; } else { u2 = new URI ( scheme + STRING + ssp + STRING + frag ) ; } return u2 ; } u2 = new URI ( STRING + uri String ) ; return u2 ; } else { return u ; } } else { String ssp = u . get Scheme Specific Part ( ) ; if ( ssp . starts With ( STRING ) ) { return u ; } else { return new URI ( STRING + uri String ) ; } } }
public static int count Tokens CSV ( String str , String delim ) { if ( str == null || str . is Empty ( ) ) return NUM ; int num Tokens = NUM ; int from = NUM , to = NUM ; int len = str . length ( ) ; while ( from < len ) { if ( str . char At ( from ) == CSV QUOTE CHAR && str . index Of ( CSV QUOTE CHAR , from + NUM ) > NUM ) { to = str . index Of ( CSV QUOTE CHAR , from + NUM ) ; while ( to + NUM < len && str . char At ( to + NUM ) == CSV QUOTE CHAR ) to = str . index Of ( CSV QUOTE CHAR , to + NUM ) ; to += NUM ; } else if ( str . region Matches ( from , delim , NUM , delim . length ( ) ) ) { to = from ; } else { to = str . index Of ( delim , from + NUM ) ; } to = ( to >= NUM ) ? to : len ; from = to + delim . length ( ) ; num Tokens ++ ; } if ( from == len ) num Tokens ++ ; return num Tokens ; }
public boolean enter ( ) throws Keeper Exception , Interrupted Exception { zoo Keeper . create ( root Path + STRING + name , new byte [ NUM ] , Ids . OPEN ACL UNSAFE , Create Mode . EPHEMERAL ) ; while ( BOOL ) { synchronized ( mutex ) { List < String > list = zoo Keeper . get Children ( root Path , BOOL ) ; if ( list . size ( ) < size ) { mutex . wait ( ) ; } else { return BOOL ; } } } }
public Select Clause add ( Expression expression , String as Name ) { select List . add ( new Select Clause Expression ( expression , as Name ) ) ; return this ; }
public void add Interface ( Soot Class interface Class ) { check Level ( HIERARCHY ) ; if ( implements Interface ( interface Class . get Name ( ) ) ) throw new Runtime Exception ( STRING + interface Class . get Name ( ) ) ; interfaces . add ( interface Class ) ; }
public static String cut To Index Of ( String string , String substring ) { int i = string . index Of ( substring ) ; if ( i != - NUM ) { string = string . substring ( NUM , i ) ; } return string ; }
public static Process Registry locate Registry ( int port ) throws Registry Exception { try { Registry registry = Locate Registry . get Registry ( port ) ; Process Registry process Registry = new Process Registry ( port , registry ) ; return process Registry ; } catch ( Remote Exception e ) { throw new Registry Exception ( STRING + port + STRING , e ) ; } }
public void test Iterator Remove ( ) { final Linked Blocking Queue q = new Linked Blocking Queue ( NUM ) ; q . add ( two ) ; q . add ( one ) ; q . add ( three ) ; Iterator it = q . iterator ( ) ; it . next ( ) ; it . remove ( ) ; it = q . iterator ( ) ; assert Same ( it . next ( ) , one ) ; assert Same ( it . next ( ) , three ) ; assert False ( it . has Next ( ) ) ; }
public Guacamole Session ( Environment environment , Authenticated User authenticated User , List < User Context > user Contexts ) throws Guacamole Exception { this . last Accessed Time = System . current Time Millis ( ) ; this . authenticated User = authenticated User ; this . user Contexts = user Contexts ; }
private void add Tv Show Episode ( Tv Show Episode episode , Tv Show Season season ) { synchronized ( root ) { Tv Show Season Tree Node parent = ( Tv Show Season Tree Node ) node Map . get ( season ) ; if ( parent == null ) { add Tv Show Season ( season , episode . get Tv Show ( ) ) ; parent = ( Tv Show Season Tree Node ) node Map . get ( season ) ; } Tv Show Episode Tree Node child = new Tv Show Episode Tree Node ( episode ) ; if ( parent != null ) { parent . add ( child ) ; node Map . put ( episode , child ) ; int index = get Index Of Child ( parent , child ) ; if ( index > - NUM ) { Tree Model Event event = new Tree Model Event ( this , parent . get Path ( ) , new int [ ] { index } , new Object [ ] { child } ) ; for ( Tree Model Listener listener : listeners ) { try { listener . tree Nodes Inserted ( event ) ; } catch ( Null Pointer Exception | Array Index Out Of Bounds Exception ignored ) { } } } Tree Model Event event = new Tree Model Event ( this , root . get Path ( ) , null , null ) ; for ( Tree Model Listener listener : listeners ) { try { listener . tree Nodes Changed ( event ) ; } catch ( Null Pointer Exception | Array Index Out Of Bounds Exception ignored ) { } } } } episode . add Property Change Listener ( property Change Listener ) ; }
public Compliance Feature check Policy State ( org . wso 2 . emm . agent . beans . Operation operation ) throws Android Agent Exception { policy = new Compliance Feature ( ) ; policy . set Feature Code ( operation . get Code ( ) ) ; switch ( operation . get Code ( ) ) { case Constants . Operation . CAMERA : return check Camera Policy ( operation ) ; case Constants . Operation . INSTALL APPLICATION : return check Install App Policy ( operation ) ; case Constants . Operation . UNINSTALL APPLICATION : return check Uninstall App Policy ( operation ) ; case Constants . Operation . ENCRYPT STORAGE : return check Encrypt Policy ( operation ) ; case Constants . Operation . PASSCODE POLICY : return check Password Policy ( ) ; case Constants . Operation . WIFI : return check Wifi Policy ( operation ) ; case Constants . Operation . WORK PROFILE : return check Work Profile Policy ( operation ) ; case Constants . Operation . DISALLOW ADJUST VOLUME : case Constants . Operation . DISALLOW CONFIG BLUETOOTH : case Constants . Operation . DISALLOW CONFIG CELL BROADCASTS : case Constants . Operation . DISALLOW CONFIG CREDENTIALS : case Constants . Operation . DISALLOW CONFIG MOBILE NETWORKS : case Constants . Operation . DISALLOW CONFIG TETHERING : case Constants . Operation . DISALLOW CONFIG VPN : case Constants . Operation . DISALLOW CONFIG WIFI : case Constants . Operation . DISALLOW APPS CONTROL : case Constants . Operation . DISALLOW CREATE WINDOWS : case Constants . Operation . DISALLOW CROSS PROFILE COPY PASTE : case Constants . Operation . DISALLOW DEBUGGING FEATURES : ; case Constants . Operation . DISALLOW FACTORY RESET : case Constants . Operation . DISALLOW ADD USER : case Constants . Operation . DISALLOW INSTALL APPS : case Constants . Operation . DISALLOW INSTALL UNKNOWN SOURCES : case Constants . Operation . DISALLOW MODIFY ACCOUNTS : case Constants . Operation . DISALLOW MOUNT PHYSICAL MEDIA : case Constants . Operation . DISALLOW NETWORK RESET : case Constants . Operation . DISALLOW OUTGOING BEAM : case Constants . Operation . DISALLOW OUTGOING CALLS : case Constants . Operation . DISALLOW REMOVE USER : case Constants . Operation . DISALLOW SAFE BOOT : case Constants . Operation . DISALLOW SHARE LOCATION : case Constants . Operation . DISALLOW SMS : case Constants . Operation . DISALLOW UNINSTALL APPS : case Constants . Operation . DISALLOW UNMUTE MICROPHONE : case Constants . Operation . DISALLOW USB FILE TRANSFER : case Constants . Operation . ALLOW PARENT PROFILE APP LINKING : case Constants . Operation . ENSURE VERIFY APPS : case Constants . Operation . AUTO TIME : case Constants . Operation . ENABLE ADMIN : case Constants . Operation . SET SCREEN CAPTURE DISABLED : case Constants . Operation . SET STATUS BAR DISABLED : if ( application Manager . is Package Installed ( Constants . SERVICE PACKAGE NAME ) ) { Common Utils . call System App ( context , operation . get Code ( ) , Boolean . to String ( operation . is Enabled ( ) ) , null ) ; policy . set Compliance ( BOOL ) ; return policy ; } else { throw new Android Agent Exception ( STRING ) ; } case Constants . Operation . APP RESTRICTION : return check App Restriction Policy ( operation ) ; default : throw new Android Agent Exception ( STRING ) ; } }
public static boolean is Uniform Collection ( Collection < ? > c , Class < ? > e ) { if ( e == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( c == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( c . is Empty ( ) ) { return BOOL ; } for ( Object o : c ) { if ( o == null || ! e . is Assignable From ( o . get Class ( ) ) ) { return BOOL ; } } return BOOL ; }
public Inet Address discover Host ( int udp Port , int timeout Millis ) { Datagram Socket socket = null ; try { socket = new Datagram Socket ( ) ; broadcast ( udp Port , socket ) ; socket . set So Timeout ( timeout Millis ) ; Datagram Packet packet = new Datagram Packet ( new byte [ NUM ] , NUM ) ; try { socket . receive ( packet ) ; } catch ( Socket Timeout Exception ex ) { if ( INFO ) info ( STRING , STRING ) ; return null ; } if ( INFO ) info ( STRING , STRING + packet . get Address ( ) ) ; return packet . get Address ( ) ; } catch ( IO Exception ex ) { if ( ERROR ) error ( STRING , STRING , ex ) ; return null ; } finally { if ( socket != null ) socket . close ( ) ; } }
public boolean is Valid Attachment Point ( long switch DPID , int switch Port ) { if ( topology . is Attachment Point Port ( switch DPID , ( short ) switch Port ) == BOOL ) return BOOL ; if ( suppress A Ps . contains ( new Switch Port ( switch DPID , switch Port ) ) ) return BOOL ; return BOOL ; }
private boolean is Lead Vdc For Geo Upgrade ( ) { String local Id = dr Util . get Local Vdc Short Id ( ) ; String str Vdc Ids = target Vdc Prop Info . get Property ( Vdc Config Util . VDC IDS ) ; String [ ] vdc Ids = str Vdc Ids . split ( STRING ) ; for ( String id : vdc Ids ) { if ( local Id . compare To Ignore Case ( id ) > NUM ) { log . info ( STRING , local Id , id ) ; return BOOL ; } } log . info ( STRING , local Id , str Vdc Ids ) ; return BOOL ; }
@ Override public Object invoke ( final Object proxy , final Method method , final Object [ ] parameters ) throws Throwable { if ( event Types . is Empty ( ) || event Types . contains ( method . get Name ( ) ) ) { if ( has Matching Parameters Method ( method ) ) { return Method Utils . invoke Method ( target , method Name , parameters ) ; } return Method Utils . invoke Method ( target , method Name ) ; } return null ; }
private double touch To Tumb Distance ( double touch X , double normalized Thumb Value ) { return Math . abs ( touch X - normalized To Screen ( normalized Thumb Value ) ) ; }
private void cleanup Any Backup Snapshots ( final Storage System storage , final Volume volume ) throws Exception { log . info ( String . format ( STRING , volume . get Label ( ) , volume . get Id ( ) ) ) ; CIM Object Path volume Path = cim Path . get Block Object Path ( storage , volume ) ; if ( helper . check Exists ( storage , volume Path , BOOL , BOOL ) == null ) { log . info ( String . format ( STRING , storage . get Serial Number ( ) , volume . get Label ( ) ) ) ; return ; } Closeable Iterator < CIM Object Path > settings Iterator = null ; try { settings Iterator = helper . get Reference ( storage , volume Path , Smis Constants . CIM SETTINGS DEFINE STATE , null ) ; if ( settings Iterator != null ) { while ( settings Iterator . has Next ( ) ) { CIM Object Path settings Path = settings Iterator . next ( ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; helper . call Modify Settings Define State ( storage , helper . get Delete Settings For Snapshot Input Arguments ( settings Path , BOOL ) , out Args ) ; } } } finally { if ( settings Iterator != null ) { settings Iterator . close ( ) ; } } }
public void process Game Event ( Game Event event ) { if ( game Listeners == null ) { game Listeners = new Vector < Game Listener > ( ) ; } for ( Enumeration < Game Listener > e = game Listeners . elements ( ) ; e . has More Elements ( ) ; ) { event . fire Event ( e . next Element ( ) ) ; } }
public int pixel For ( int rgb ) { return surface Type . pixel For ( rgb , color Model ) ; }
private boolean check For Carry ( char [ ] ca 1 , int icarry ) { boolean carry = BOOL ; if ( icarry < ca 1 . length ) { if ( ca 1 [ icarry ] == STRING || ca 1 [ icarry ] == STRING || ca 1 [ icarry ] == STRING || ca 1 [ icarry ] == STRING ) carry = BOOL ; else if ( ca 1 [ icarry ] == STRING ) { int ii = icarry + NUM ; for ( ; ii < ca 1 . length ; ii ++ ) if ( ca 1 [ ii ] != STRING ) break ; carry = ii < ca 1 . length ; if ( ! carry && icarry > NUM ) { carry = ( ca 1 [ icarry - NUM ] == STRING || ca 1 [ icarry - NUM ] == STRING || ca 1 [ icarry - NUM ] == STRING || ca 1 [ icarry - NUM ] == STRING || ca 1 [ icarry - NUM ] == STRING ) ; } } } return carry ; }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) protected void add To Bottom Box ( Component comp , String c ) { bottom Box . add ( Box . create Horizontal Strut ( bottom Strut Width ) , bottom Box Index ) ; ++ bottom Box Index ; bottom Box . add ( comp , bottom Box Index ) ; ++ bottom Box Index ; }
public static boolean does File Exist ( String file Path And Name ) { if ( ( file Path And Name == null ) || file Path And Name . is Empty ( ) ) { return BOOL ; } File file = new File ( file Path And Name ) ; boolean does File Exist ; try { does File Exist = file . exists ( ) ; } catch ( Exception e ) { logger . debug ( e . to String ( ) + System . line Separator ( ) + Stack Trace . get String From Stack Trace ( e ) ) ; does File Exist = BOOL ; } return does File Exist ; }
public static File create Temp Dir ( final String prefix , final String suffix , final File directory ) throws IO Exception { final File dir = File . create Temp File ( prefix , suffix , directory ) ; if ( ! dir . delete ( ) ) { throw new IO Exception ( STRING + dir . to String ( ) ) ; } if ( ! dir . mkdir ( ) ) { throw new IO Exception ( STRING + dir . to String ( ) ) ; } return dir ; }
public boolean add All ( int index , Collection < ? extends E > c ) { Object [ ] cs = c . to Array ( ) ; final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( index > len || index < NUM ) throw new Index Out Of Bounds Exception ( STRING + index + STRING + len ) ; if ( cs . length == NUM ) return BOOL ; int num Moved = len - index ; Object [ ] new Elements ; if ( num Moved == NUM ) new Elements = Arrays . copy Of ( elements , len + cs . length ) ; else { new Elements = new Object [ len + cs . length ] ; System . arraycopy ( elements , NUM , new Elements , NUM , index ) ; System . arraycopy ( elements , index , new Elements , index + cs . length , num Moved ) ; } System . arraycopy ( cs , NUM , new Elements , index , cs . length ) ; set Array ( new Elements ) ; return BOOL ; } finally { lock . unlock ( ) ; } }
protected boolean check Or Are Equal ( final Annotated Type Mirror type 1 , final Annotated Type Mirror type 2 , final Visit History visited ) { if ( visited . contains ( type 1 , type 2 ) ) { return BOOL ; } final Boolean result = are Equal ( type 1 , type 2 , visited ) ; visited . add ( type 1 , type 2 ) ; return result ; }
public void register Text Flavor Properties ( String nat , String charset , String eoln , String terminators ) { Long format = get Format For Native As Long ( nat ) ; text Natives . add ( format ) ; native Charsets . put ( format , ( charset != null && charset . length ( ) != NUM ) ? charset : get Default Text Charset ( ) ) ; if ( eoln != null && eoln . length ( ) != NUM && ! eoln . equals ( STRING ) ) { native EOL Ns . put ( format , eoln ) ; } if ( terminators != null && terminators . length ( ) != NUM ) { Integer i Terminators = Integer . value Of ( terminators ) ; if ( i Terminators . int Value ( ) > NUM ) { native Terminators . put ( format , i Terminators ) ; } } }
final int find Mark Adjust Index ( int search Index ) { search . index = Math . max ( search Index , NUM ) ; int index = find Sort Index ( search ) ; for ( int i = index - NUM ; i >= NUM ; i -- ) { Mark Data d = marks . element At ( i ) ; if ( d . index != search . index ) { break ; } index -= NUM ; } return index ; }
public static String indent ( String s , int spaces , boolean newline ) { String Builder buff = new String Builder ( s . length ( ) + spaces ) ; for ( int i = NUM ; i < s . length ( ) ; ) { for ( int j = NUM ; j < spaces ; j ++ ) { buff . append ( STRING ) ; } int n = s . index Of ( STRING , i ) ; n = n < NUM ? s . length ( ) : n + NUM ; buff . append ( s . substring ( i , n ) ) ; i = n ; } if ( newline && ! s . ends With ( STRING ) ) { buff . append ( STRING ) ; } return buff . to String ( ) ; }
public void shear ( double shx , double shy , Point 2 D from ) { inverse = null ; Affine Transform at = Affine Transform . get Translate Instance ( from . get X ( ) , from . get Y ( ) ) ; at . shear ( shx , shy ) ; at . translate ( - from . get X ( ) , - from . get Y ( ) ) ; transform . pre Concatenate ( at ) ; fire State Changed ( ) ; }
public static void remove Activity Listener ( Activity Listener listener ) { listeners . remove ( listener ) ; }
public void add Muted Mac ( final String mac , final Date mute Till ) { if ( is Mac Muted ( mac ) ) { remove Muted Mac ( mac ) ; } Timestamp mute Till Ts = null ; if ( mute Till != null ) { mute Till Ts = new Timestamp ( mute Till . get Time ( ) ) ; } s logger . fine ( STRING + mac ) ; final Connection con = Database . get Connection ( ) ; try { final Prepared Statement ps = con . prepare Statement ( STRING ) ; ps . set String ( NUM , mac ) ; ps . set Timestamp ( NUM , mute Till Ts ) ; ps . execute ( ) ; ps . close ( ) ; con . commit ( ) ; } catch ( final SQL Exception sqle ) { if ( sqle . get Error Code ( ) == NUM ) { s logger . info ( STRING + mac + STRING + sqle . get Message ( ) ) ; return ; } s logger . log ( Level . SEVERE , STRING + mac , sqle ) ; throw new Illegal State Exception ( sqle . get Message ( ) ) ; } finally { Db Util . close Connection ( con ) ; } }
private Response < Bitmap > do Parse ( Network Response response ) { byte [ ] data = response . data ; Bitmap Factory . Options decode Options = new Bitmap Factory . Options ( ) ; Bitmap bitmap = null ; if ( m Max Width == NUM && m Max Height == NUM ) { decode Options . in Preferred Config = m Decode Config ; bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = BOOL ; Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height , m Scale Type ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width , m Scale Type ) ; decode Options . in Just Decode Bounds = BOOL ; decode Options . in Sample Size = find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ; Bitmap temp Bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap = Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap == null ) { return Response . error ( new Parse Error ( response ) ) ; } else { return Response . success ( bitmap , Http Header Parser . parse Cache Headers ( response ) ) ; } }
@ Override boolean is Decoder Selected ( ) { return ! m Decoder List . is Selection Empty ( ) ; }
@ Override public void close ( ) throws IO Exception { if ( ! closed ) { finish ( ) ; inf . end ( ) ; out . close ( ) ; closed = BOOL ; } }
protected abstract List < String > create Command ( Step Instance step Instance , String temporary File Directory ) ;
public void next Bytes ( byte [ ] bytes ) { final int length = bytes . length ; for ( int i = NUM ; i < length ; ) { for ( int rnd = next Int ( ) , n = Math . min ( length - i , INTEGER SIZE / BYTE SIZE ) ; n -- > NUM ; rnd >>= BYTE SIZE ) { bytes [ i ++ ] = ( byte ) rnd ; } } }
private void draw Low Far Out ( double a Radius , Graphics 2 D g2 , double xx , double m ) { double side = a Radius * NUM ; g2 . draw ( new Line 2 D . Double ( xx - side , m - side , xx + side , m - side ) ) ; g2 . draw ( new Line 2 D . Double ( xx - side , m - side , xx , m ) ) ; g2 . draw ( new Line 2 D . Double ( xx + side , m - side , xx , m ) ) ; }
private Set < Object Instance > object Instances From Filtered Named Objects ( Set < Named Object > list , Query Exp query ) { Set < Object Instance > result = new Hash Set < Object Instance > ( ) ; if ( query == null ) { for ( Named Object no : list ) { final Dynamic M Bean obj = no . get Object ( ) ; final String class Name = safe Get Class Name ( obj ) ; result . add ( new Object Instance ( no . get Name ( ) , class Name ) ) ; } } else { M Bean Server old Server = Query Eval . get M Bean Server ( ) ; query . set M Bean Server ( server ) ; try { for ( Named Object no : list ) { final Dynamic M Bean obj = no . get Object ( ) ; boolean res ; try { res = query . apply ( no . get Name ( ) ) ; } catch ( Exception e ) { res = BOOL ; } if ( res ) { String class Name = safe Get Class Name ( obj ) ; result . add ( new Object Instance ( no . get Name ( ) , class Name ) ) ; } } } finally { query . set M Bean Server ( old Server ) ; } } return result ; }
private Element create Indexed End Point ( String name , String attr Binding , String attr Location , String attr Response Location , int index , Boolean is Default ) throws DOM Exception { if ( name == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( attr Binding == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( attr Location == null ) { throw new Illegal Argument Exception ( STRING ) ; } Element indexed End Pt = doc . create Element ( name ) ; indexed End Pt . set Attribute ( SAML Names . BINDING , attr Binding ) ; indexed End Pt . set Attribute ( SAML Names . LOCATION , attr Location ) ; if ( attr Response Location != null ) { indexed End Pt . set Attribute ( SAML Names . RESPLOC , attr Response Location ) ; } indexed End Pt . set Attribute ( SAML Names . INDEX , String . value Of ( index ) ) ; if ( is Default != null ) { indexed End Pt . set Attribute ( SAML Names . ISDEFAULT , is Default . to String ( ) ) ; } return indexed End Pt ; }
public static void copy Files ( final File src , final File dest ) throws IO Exception { if ( ! src . exists ( ) ) { throw new IO Exception ( STRING + src . get Absolute Path ( ) ) ; } else if ( ! src . can Read ( ) ) { throw new IO Exception ( STRING + src . get Absolute Path ( ) + STRING ) ; } final List < String > no Copy = Arrays . as List ( STRING , STRING , STRING , STRING , STRING ) ; if ( src . is Directory ( ) ) { if ( no Copy . contains ( src . get Name ( ) ) ) return ; if ( ! dest . exists ( ) ) { if ( ! dest . mkdirs ( ) ) { throw new IO Exception ( STRING + dest . get Absolute Path ( ) ) ; } } final String list [ ] = src . list ( ) ; if ( list != null ) for ( int i = NUM ; i < list . length ; i ++ ) { final File dest 1 = new File ( dest , list [ i ] ) ; final File src 1 = new File ( src , list [ i ] ) ; copy Files ( src 1 , dest 1 ) ; } } else { final byte [ ] buffer = new byte [ NUM ] ; int bytes Read ; try ( File Input Stream fin = new File Input Stream ( src ) ; File Output Stream fout = new File Output Stream ( dest ) ) { while ( ( bytes Read = fin . read ( buffer ) ) >= NUM ) { fout . write ( buffer , NUM , bytes Read ) ; } } catch ( final IO Exception e ) { final IO Exception wrapper = new IO Exception ( STRING + src . get Absolute Path ( ) + STRING + dest . get Absolute Path ( ) ) ; wrapper . init Cause ( e ) ; wrapper . set Stack Trace ( e . get Stack Trace ( ) ) ; throw wrapper ; } } }
public String to String ( ) { String Buffer buffer = new String Buffer ( ) ; buffer . append ( to String ( get Class ( ) ) ) ; buffer . append ( STRING ) ; buffer . append ( is Use Default ( ) ) ; buffer . append ( STRING ) ; buffer . append ( use Locale Format ) ; if ( display Patterns != null ) { buffer . append ( STRING ) ; buffer . append ( display Patterns ) ; buffer . append ( STRING ) ; } if ( locale != null ) { buffer . append ( STRING ) ; buffer . append ( locale ) ; } if ( time Zone != null ) { buffer . append ( STRING ) ; buffer . append ( time Zone ) ; } buffer . append ( STRING ) ; return buffer . to String ( ) ; }
public void test multiple Resource Locking resources 10 locktries 10 predeclare Locks ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCK TRIES , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; Result result = do Comparison Test ( properties ) ; assert Equals ( STRING , STRING , result . get ( STRING ) ) ; }
public static byte [ ] flatten Bitmap ( Bitmap bitmap ) { int size = bitmap . get Width ( ) * bitmap . get Height ( ) * NUM ; Byte Array Output Stream out = new Byte Array Output Stream ( size ) ; try { bitmap . compress ( Bitmap . Compress Format . PNG , NUM , out ) ; out . flush ( ) ; out . close ( ) ; return out . to Byte Array ( ) ; } catch ( IO Exception e ) { Log . w ( TAG , STRING ) ; return null ; } }
public void write Jar From Content ( final String class Name , final String content , final File output File ) throws IO Exception { File Output Stream file Output Stream = new File Output Stream ( output File ) ; write Jar From Content ( class Name , content , file Output Stream ) ; file Output Stream . close ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public void visit ( Pipeline Visitor visitor , Set < P Value > visited Values ) { if ( ! finished Specifying ) { finish Specifying ( ) ; } for ( Map . Entry < P Value , Transform Tree Node > entry : inputs . entry Set ( ) ) { if ( visited Values . add ( entry . get Key ( ) ) ) { visitor . visit Value ( entry . get Key ( ) , entry . get Value ( ) ) ; } } if ( is Composite Node ( ) ) { Pipeline Visitor . Composite Behavior recurse = visitor . enter Composite Transform ( this ) ; if ( recurse . equals ( Composite Behavior . ENTER TRANSFORM ) ) { for ( Transform Tree Node child : parts ) { child . visit ( visitor , visited Values ) ; } } visitor . leave Composite Transform ( this ) ; } else { visitor . visit Primitive Transform ( this ) ; } for ( P Value p Value : get Expanded Outputs ( ) ) { if ( visited Values . add ( p Value ) ) { visitor . visit Value ( p Value , this ) ; } } }
protected static void place Some Terrain ( I Board board , int terrain Type , int prob More , int min Hexes , int max Hexes , Hash Map < I Hex , Point > reverse Hex , boolean exclusive ) { Point p = new Point ( Compute . random Int ( board . get Width ( ) ) , Compute . random Int ( board . get Height ( ) ) ) ; int count = min Hexes ; if ( ( max Hexes - min Hexes ) > NUM ) { count += Compute . random Int ( max Hexes - min Hexes ) ; } I Hex field ; Hash Set < I Hex > already Used = new Hash Set < I Hex > ( ) ; Hash Set < I Hex > un Used = new Hash Set < I Hex > ( ) ; field = board . get Hex ( p . x , p . y ) ; if ( ! field . contains Terrain ( terrain Type ) ) { un Used . add ( field ) ; } else { find All Unused ( board , terrain Type , already Used , un Used , field , reverse Hex ) ; } I Terrain Factory f = Terrains . get Terrain Factory ( ) ; for ( int i = NUM ; i < count ; i ++ ) { if ( un Used . is Empty ( ) ) { return ; } int which = Compute . random Int ( un Used . size ( ) ) ; Iterator < I Hex > iter = un Used . iterator ( ) ; for ( int n = NUM ; n < ( which - NUM ) ; n ++ ) { iter . next ( ) ; } field = iter . next ( ) ; if ( exclusive ) { field . remove All Terrains ( ) ; } int temp Int = ( Compute . random Int ( NUM ) < prob More ) ? NUM : NUM ; I Terrain temp Terrain = f . create Terrain ( terrain Type , temp Int ) ; field . add Terrain ( temp Terrain ) ; un Used . remove ( field ) ; find All Unused ( board , terrain Type , already Used , un Used , field , reverse Hex ) ; } if ( terrain Type == Terrains . WATER ) { int min = Integer . MAX VALUE ; Iterator < I Hex > iter = un Used . iterator ( ) ; while ( iter . has Next ( ) ) { field = iter . next ( ) ; if ( field . get Level ( ) < min ) { min = field . get Level ( ) ; } } iter = already Used . iterator ( ) ; while ( iter . has Next ( ) ) { field = iter . next ( ) ; field . set Level ( min ) ; } } }
public boolean remove Module ( Module Handle module Handle ) { boolean no Loaded Modules = BOOL ; boolean was Module Removed = BOOL ; synchronized ( private Instance Lock ) { if ( modules . remove ( module Handle ) ) { was Module Removed = BOOL ; no Loaded Modules = ( modules . size ( ) == NUM ) ; } } if ( no Loaded Modules ) { set Terminated ( BOOL ) ; } return was Module Removed ; }
private static void expand 2 Digit Number ( String number String , Word Relation word Relation ) { if ( number String . char At ( NUM ) == STRING ) { if ( number String . char At ( NUM ) == STRING ) { } else { String number = digit 2 num [ number String . char At ( NUM ) - STRING ] ; word Relation . add Word ( number ) ; } } else if ( number String . char At ( NUM ) == STRING ) { String number = digit 2 enty [ number String . char At ( NUM ) - STRING ] ; word Relation . add Word ( number ) ; } else if ( number String . char At ( NUM ) == STRING ) { String number = digit 2 teen [ number String . char At ( NUM ) - STRING ] ; word Relation . add Word ( number ) ; } else { String enty = digit 2 enty [ number String . char At ( NUM ) - STRING ] ; word Relation . add Word ( enty ) ; expand Digits ( number String . substring ( NUM , number String . length ( ) ) , word Relation ) ; } }
protected int find UTC Sign ( String buffer , int start , int end ) { int c ; for ( int i = start ; i < end ; i ++ ) { c = buffer . char At ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { return i ; } } return - NUM ; }
@ Override public boolean is Enabled ( ) { if ( ( attribute Selection Panel != null ) && ! is Value Only ( ) ) { return attribute Selection Panel . is Enabled ( ) ; } else { if ( this . check Box != null ) { return check Box . is Enabled ( ) ; } } return BOOL ; }
static private int [ ] worst Indices ( double [ ] x , double prop Kept ) { if ( prop Kept == NUM ) return null ; int n = x . length ; int num Neg = NUM ; for ( double aX 1 : x ) if ( aX 1 < NUM ) num Neg ++ ; if ( num Neg == NUM ) return null ; double [ ] xcopy = new double [ num Neg ] ; int j = NUM ; for ( double aX : x ) if ( aX < NUM ) xcopy [ j ++ ] = aX ; Arrays . sort ( xcopy ) ; int nkept = ( int ) Math . ceil ( prop Kept * num Neg ) ; double cutoff = xcopy [ nkept - NUM ] ; int [ ] result = new int [ nkept ] ; int front = NUM , back = nkept - NUM ; for ( int i = NUM ; i < n ; i ++ ) { if ( x [ i ] < cutoff ) result [ front ++ ] = i ; else if ( x [ i ] == cutoff ) { if ( back >= front ) result [ back -- ] = i ; } } return result ; }
private void handle Json Create Quotation ( Request And Response request And Response ) throws IO Exception , Servlet Exception { request And Response . set Response Content Type Json ( ) ; String url ; String title ; String quotation ; String note ; String session Id ; try { final Json Node Helper json = get Json Node ( request And Response ) ; url = json . get String ( Db Logic . Constants . url ) ; title = json . get String ( Db Logic . Constants . title ) ; quotation = json . get String ( Db Logic . Constants . quotation ) ; note = json . get String ( Db Logic . Constants . note ) ; session Id = json . get String ( STRING ) ; } catch ( final IO Exception e ) { return Json 400 ( request And Response , servlet Text . error Json ( ) ) ; return ; } if ( ! Entry Attribute Validator . is Note Valid ( note ) ) { return Json 400 ( request And Response , servlet Text . error Note Is Invalid ( ) ) ; return ; } if ( ! Entry Attribute Validator . is Quotation Valid ( quotation ) ) { return Json 400 ( request And Response , servlet Text . error Quotation Is Invalid ( ) ) ; return ; } if ( ! Entry Attribute Validator . is Url Valid ( url ) ) { return Json 400 ( request And Response , servlet Text . error Url Is Invalid ( ) ) ; return ; } if ( ! Entry Attribute Validator . is Source Title Valid ( title ) ) { return Json 400 ( request And Response , servlet Text . error Title Is Invalid ( ) ) ; return ; } final Errors errors = new Errors ( ) ; try { final Long time = new Long ( System . current Time Millis ( ) ) ; String user Id = null ; if ( session Manager != null ) { final Http Session session = session Manager . get Session ( session Id ) ; if ( session != null && session . get Attribute ( session User Id Attribute ) != null ) { user Id = ( String ) session . get Attribute ( session User Id Attribute ) ; } } final User user = db Logic . get User By Id ( user Id ) ; if ( user == null ) { return Json 400 ( request And Response , servlet Text . error No Account Found ( ) ) ; return ; } if ( user . get Is Account Closed ( ) ) { return Json 400 ( request And Response , servlet Text . error Account Is Closed ( ) ) ; return ; } final Entry source = db Logic . update Or Create Source ( user , null , url , title , time , time , is User An Admin ( request And Response ) , errors ) ; if ( source == null ) { return Json 400 ( request And Response , errors ) ; return ; } final Entry entry = db Logic . create Entry Quotation ( user , source , quotation , note , time , is User An Admin ( request And Response ) , errors ) ; if ( entry == null ) { return Json 400 ( request And Response , errors ) ; return ; } request And Response . print ( STRING + STRING + entry . get Id ( ) + STRING + STRING + source . get Id ( ) + STRING ) ; db Logic . commit ( ) ; } catch ( final Persistence Exception e ) { logger . log ( Level . INFO , STRING , e ) ; return Json 500 ( request And Response , servlet Text . error Internal Database ( ) ) ; } }
@ Suppress Warnings ( STRING ) public static List < String > parse Get Bucket Replication Location ( Input Stream response Body ) throws Response Parse Exception { try { Element root = get Xml Root Element ( response Body ) ; List < String > location List = new Array List < String > ( ) ; List < Element > loc Elements = root . get Children ( STRING ) ; for ( Element loc Elem : loc Elements ) { location List . add ( loc Elem . get Text ( ) ) ; } return location List ; } catch ( Exception e ) { throw new Response Parse Exception ( e . get Message ( ) , e ) ; } }
public boolean add Soft Wrap Change Listener ( @ Not Null Soft Wrap Change Listener listener ) { return my Listeners . add ( listener ) ; }
static public Input Stream find Cluster XSL Schema ( String cluster XSL Schema ) throws Cluster Configuration Exception { String schema Name To Be Used = cluster XSL Schema ; if ( schema Name To Be Used . equals Ignore Case ( Cluster XML . CLUSTER SCHEMA NAME PARTITIONED SYNC 2 BACKUP ) ) schema Name To Be Used = Cluster XML . CLUSTER SCHEMA NAME PARTITIONED ; Input Stream schema Input Stream ; String schema File Path = Constants . Container . CONTAINER CONFIG DIRECTORY + STRING + Constants . Schemas . SCHEMAS FOLDER + STRING + schema Name To Be Used + Cluster XML . CLUSTER SCHEMA XSL FILE SUFFIX ; schema Input Stream = get Resource Stream ( schema File Path ) ; if ( schema Input Stream != null ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + get Resource URL ( schema File Path ) + STRING ) ; } return schema Input Stream ; } else { String missing Schema Msg = STRING + cluster XSL Schema ; throw new Cluster Configuration Exception ( missing Schema Msg ) ; } }
private static Path rename To Vanilla Nether Or End ( Path world Container , Path old World Path , Path world Path ) { final String new Name = get Vanilla Nether Or End Name ( old World Path ) ; final Path new World Path = world Container . resolve ( new Name ) ; if ( is Valid Bukkit Nether Or End ( world Container , old World Path ) ) { if ( Files . not Exists ( world Container . resolve ( new Name ) ) ) { return new World Path ; } } return world Path ; }
public void clear ( ) { Arrays . fill ( ritems , NUM , rsize , null ) ; Arrays . fill ( pitems , NUM , psize , null ) ; rsize = NUM ; psize = NUM ; psorted = BOOL ; }
private String parse Format Description ( final String pattern , final Parse Position pos ) { final int start = pos . get Index ( ) ; seek Non Ws ( pattern , pos ) ; final int text = pos . get Index ( ) ; int depth = NUM ; for ( ; pos . get Index ( ) < pattern . length ( ) ; next ( pos ) ) { switch ( pattern . char At ( pos . get Index ( ) ) ) { case START FE : depth ++ ; break ; case END FE : depth -- ; if ( depth == NUM ) { return pattern . substring ( text , pos . get Index ( ) ) ; } break ; case QUOTE : get Quoted String ( pattern , pos ) ; break ; default : break ; } } throw new Illegal Argument Exception ( STRING + start ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int length ) { try { Output Stream os = os ; if ( os != null ) { os . write ( buffer , offset , length ) ; } } catch ( Exception e ) { log . log ( Level . FINER , e . to String ( ) , e ) ; } }
protected String generate Label String ( Category Dataset dataset , int row , int column ) { Param Checks . null Not Permitted ( dataset , STRING ) ; String result ; Object [ ] items = create Item Array ( dataset , row , column ) ; result = Message Format . format ( this . label Format , items ) ; return result ; }
abstract protected void do Fade Out ( ) ;
public static Command Result exec Command ( List < String > commands , boolean is Root , String path ) { return exec Command ( commands == null ? null : commands . to Array ( new String [ ] { } ) , is Root , BOOL , path ) ; }
public void load ( Path properties Path ) { if ( properties Path != null ) { m Properties Path = properties Path ; Input Stream in = null ; try { in = new File Input Stream ( properties Path . to String ( ) ) ; } catch ( File Not Found Exception e ) { m Log . error ( STRING + STRING , e ) ; } if ( in != null ) { try { m Properties . load ( in ) ; } catch ( IO Exception e ) { m Log . error ( STRING + STRING , e ) ; } finally { try { in . close ( ) ; } catch ( IO Exception e ) { } } } } m Log . info ( STRING + properties Path . to String ( ) + STRING ) ; }
public void initialize Document ( Document doc ) { Map < String , Double > d = new Hashtable < String , Double > ( ) ; double num Docs = wordlex == null ? NUM : wordlex . get Num Docs ( ) ; for ( int i = NUM ; i < doc . tags . length ; i ++ ) { if ( wordlex == null ) { int rindex = random . next Int ( doc . words . length + NUM ) ; if ( rindex < doc . words . length ) { doc . reason [ i ] = doc . words [ rindex ] ; } else { doc . reason [ i ] = Tag Allocation Model . NOISE ; } } else { d . clear ( ) ; double sample Weight = NUM ; for ( int j = NUM ; j < doc . words . length ; j ++ ) { Word w = wordlex . get Word ( doc . words [ j ] ) ; if ( w != null ) { double idf = num Docs / w . get Document Frequency ( ) ; d . put ( doc . words [ j ] , idf ) ; sample Weight += idf ; } } d . put ( Tag Allocation Model . NOISE , sample Weight / d . size ( ) ) ; doc . reason [ i ] = sample ( d ) ; } if ( ! locked ) { ntw . inc ( doc . tags [ i ] , doc . reason [ i ] , NUM ) ; } } for ( String word : doc . words ) { nw . inc ( word , doc . tags . length ) ; } }
public static void register Context Menu Action ( Class < ? > associated Class , Selection Dependent Action action ) { List < Selection Dependent Action > actions = context Menu Actions . get ( associated Class ) ; if ( actions == null ) { actions = new Linked List < Selection Dependent Action > ( ) ; context Menu Actions . put ( associated Class , actions ) ; } actions . add ( action ) ; }
public Dictionary ( final String dict Info ) { this . dict File Version = CURRENT DICT VERSION ; this . creation Millis = System . current Time Millis ( ) ; this . dict Info = dict Info ; pair Entries = new Array List < Pair Entry > ( ) ; text Entries = new Array List < Text Entry > ( ) ; html Entries = new Array List < Html Entry > ( ) ; html Data = null ; sources = new Array List < Entry Source > ( ) ; indices = new Array List < Index > ( ) ; }
public int do Final ( byte [ ] out , int out Off ) { byte padding Byte = ( byte ) ( M . length - m Off ) ; for ( int i = m Off ; i < M . length ; i ++ ) { M [ i ] = padding Byte ; } process Check Sum ( M ) ; process Block ( M ) ; process Block ( C ) ; System . arraycopy ( X , x Off , out , out Off , NUM ) ; reset ( ) ; return DIGEST LENGTH ; }
protected void wait For Messages To Be Delivered ( ) { long max Wait Time = NUM ; long wait Time = max Wait Time ; long start = ( max Wait Time <= NUM ) ? NUM : System . current Time Millis ( ) ; synchronized ( lock ) { while ( messages . size ( ) < data . length && wait Time >= NUM ) { try { lock . wait ( NUM ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } wait Time = max Wait Time - ( System . current Time Millis ( ) - start ) ; } } }
public static long parse Date Value ( String s , int start , int end ) { if ( s . char At ( start ) == STRING ) { start ++ ; } int s1 = s . index Of ( STRING , start + NUM ) ; int s2 = s . index Of ( STRING , s1 + NUM ) ; if ( s1 <= NUM || s2 <= s1 ) { throw new Illegal Argument Exception ( s ) ; } int year = Integer . parse Int ( s . substring ( start , s1 ) ) ; int month = Integer . parse Int ( s . substring ( s1 + NUM , s2 ) ) ; int day = Integer . parse Int ( s . substring ( s2 + NUM , end ) ) ; if ( ! is Valid Date ( year , month , day ) ) { throw new Illegal Argument Exception ( year + STRING + month + STRING + day ) ; } return date Value ( year , month , day ) ; }
private static void do Copy Directory ( File src Dir , File dest Dir , File Filter filter , boolean preserve File Date , List < String > exclusion List ) throws IO Exception { File [ ] src Files = filter == null ? src Dir . list Files ( ) : src Dir . list Files ( filter ) ; if ( src Files == null ) { throw new IO Exception ( STRING + src Dir ) ; } if ( dest Dir . exists ( ) ) { if ( dest Dir . is Directory ( ) == BOOL ) { throw new IO Exception ( STRING + dest Dir + STRING ) ; } } else { if ( ! dest Dir . mkdirs ( ) && ! dest Dir . is Directory ( ) ) { throw new IO Exception ( STRING + dest Dir + STRING ) ; } } if ( dest Dir . can Write ( ) == BOOL ) { throw new IO Exception ( STRING + dest Dir + STRING ) ; } for ( File src File : src Files ) { File dst File = new File ( dest Dir , src File . get Name ( ) ) ; if ( exclusion List == null || ! exclusion List . contains ( src File . get Canonical Path ( ) ) ) { if ( src File . is Directory ( ) ) { do Copy Directory ( src File , dst File , filter , preserve File Date , exclusion List ) ; } else { do Copy File ( src File , dst File , preserve File Date ) ; } } } if ( preserve File Date ) { dest Dir . set Last Modified ( src Dir . last Modified ( ) ) ; } }
public Map ( Pokemon Go api ) { this . api = api ; cached Map Objects = new Map Objects ( api ) ; last Map Update = NUM ; }
public void test Sorts According Number Of Children ( ) throws Exception { Xpp Dom dom 1 = Xpp Factory . build Dom ( STRING ) ; Xpp Dom dom 2 = Xpp Factory . build Dom ( STRING ) ; assert Equals ( - NUM , comparator . compare ( dom 1 , dom 2 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; assert Equals ( NUM , comparator . compare ( dom 2 , dom 1 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; }
public static Endpoint Entry lookup ( Endpoint ep ) { synchronized ( endpoint Table ) { Endpoint Entry entry = endpoint Table . get ( ep ) ; if ( entry == null ) { entry = new Endpoint Entry ( ep ) ; endpoint Table . put ( ep , entry ) ; if ( gc Latency Request == null ) { gc Latency Request = GC . request Latency ( gc Interval ) ; } } return entry ; } }
private Op Arg Node generate Op Arg ( Symbol Node target Symbol , Tree Node op Arg Syntax Node , Module Node mn ) throws Abort Exception { if ( op Arg Syntax Node . is Kind ( N Lambda ) ) { return new Op Arg Node ( generate Lambda ( op Arg Syntax Node , mn ) , op Arg Syntax Node , mn ) ; } ; if ( ! ( op Arg Syntax Node . is Kind ( N General Id ) || op Arg Syntax Node . is Kind ( N Gen Infix Op ) || op Arg Syntax Node . is Kind ( N Gen Prefix Op ) || op Arg Syntax Node . is Kind ( N Gen Non Exp Prefix Op ) || op Arg Syntax Node . is Kind ( N Gen Postfix Op ) ) ) { errors . add Error ( op Arg Syntax Node . get Location ( ) , STRING + target Symbol . get Arity ( ) + STRING + STRING + target Symbol . get Name ( ) + STRING ) ; return null Op Arg ; } if ( op Arg Syntax Node . get Kind ( ) == N General Id ) { if ( target Symbol . get Arity ( ) <= NUM ) { errors . add Abort ( op Arg Syntax Node . get Location ( ) , STRING , BOOL ) ; } ; Level Node ln = selector To Node ( gen Id To Selector ( ( Syntax Tree Node ) op Arg Syntax Node ) , target Symbol . get Arity ( ) , BOOL , BOOL , mn ) ; if ( ! ( ln instanceof Op Arg Node ) ) { if ( errors . get Num Errors ( ) > NUM ) { return null Op Arg ; } errors . add Abort ( op Arg Syntax Node . get Location ( ) , STRING + STRING + STRING ) ; } ; return ( Op Arg Node ) ln ; } ; Gen ID gen ID = generate Gen ID ( op Arg Syntax Node , mn ) ; if ( gen ID . get Fully Qualified Op ( ) != null && gen ID . get Args ( ) . length == NUM ) { return new Op Arg Node ( gen ID . get Fully Qualified Op ( ) , op Arg Syntax Node , mn ) ; } else if ( gen ID . get Args ( ) . length > NUM ) { errors . add Error ( op Arg Syntax Node . get Location ( ) , STRING + target Symbol . get Arity ( ) + STRING + STRING + target Symbol . get Name ( ) + STRING ) ; return null Op Arg ; } else { return null Op Arg ; } }
private static void merge ( Map < String , Object > merged , Map < String , Object > attributes ) { for ( Hash Map . Entry < String , Object > new Entry : attributes . entry Set ( ) ) { String key = new Entry . get Key ( ) ; if ( key . equals ( Chronix Query Params . SOLR VERSION FIELD ) ) { continue ; } if ( ! merged . contains Key ( key ) ) { merged . put ( key , new Linked Hash Set ( ) ) ; } Linked Hash Set values = ( Linked Hash Set ) merged . get ( key ) ; Object value = new Entry . get Value ( ) ; if ( value instanceof Collection && ! values . contains ( value ) ) { values . add All ( ( Collection ) value ) ; } else if ( ! values . contains ( value ) ) { values . add ( value ) ; } } }
private void sort ( int column Index , int sort Count ) { Sort Order order = Sort Order . values ( ) [ sort Count % NUM ] ; List < Row Sorter . Sort Key > sort Keys = new Array List < > ( ) ; if ( column Index != NUM ) { sort Keys . add ( new Row Sorter . Sort Key ( NUM , Sort Order . DESCENDING ) ) ; } sort Keys . add ( new Row Sorter . Sort Key ( column Index , order ) ) ; sorter . set Sort Keys ( sort Keys ) ; this . sort Count = sort Count ; sorted Column = column Index ; }
private void upload ( ) throws Exception { final String zookeeper Url = topology Properties . get Property ( Kafka With ZK Component . ZOOKEEPER PROPERTY ) ; try ( Curator Framework client = get Client ( zookeeper Url ) ) { client . start ( ) ; upload Global Config ( client ) ; upload Profiler Config ( client ) ; } }
public void add Cell ( final String cell Content ) { tool Tip . append ( STRING ) ; tool Tip . append ( cell Content ) ; tool Tip . append ( STRING ) ; }
protected void write Embedded Tags ( Attribute Set attr ) throws IO Exception { attr = convert To HTML ( attr , o Conv Attr ) ; Enumeration names = attr . get Attribute Names ( ) ; while ( names . has More Elements ( ) ) { Object name = names . next Element ( ) ; if ( name instanceof HTML . Tag ) { HTML . Tag tag = ( HTML . Tag ) name ; if ( tag == HTML . Tag . FORM || tags . contains ( tag ) ) { continue ; } write ( STRING ) ; write ( tag . to String ( ) ) ; Object o = attr . get Attribute ( tag ) ; if ( o != null && o instanceof Attribute Set ) { write Attributes ( ( Attribute Set ) o ) ; } write ( STRING ) ; tags . add Element ( tag ) ; tag Values . add Element ( o ) ; } } }
@ Override public void close ( ) throws IO Exception { if ( in != null ) { in . close ( ) ; in = null ; buf = null ; } }
private static SSL Socket Factory trust All Hosts ( Https URL Connection connection ) { SSL Socket Factory old Factory = connection . get SSL Socket Factory ( ) ; try { SSL Context sc = SSL Context . get Instance ( STRING ) ; sc . init ( null , trust All Certs , new java . security . Secure Random ( ) ) ; SSL Socket Factory new Factory = sc . get Socket Factory ( ) ; connection . set SSL Socket Factory ( new Factory ) ; } catch ( Exception e ) { Log . e ( LOG TAG , e . get Message ( ) , e ) ; } return old Factory ; }
private static Big Decimal determine Billing Account Amount ( String billing Account Id , String billing Account Amount , Local Dispatcher dispatcher ) { Big Decimal billing Account Amt = null ; if ( Util Validate . is Not Empty ( billing Account Id ) ) { if ( Util Validate . is Not Empty ( billing Account Amount ) ) { try { billing Account Amt = new Big Decimal ( billing Account Amount ) ; } catch ( Number Format Exception e ) { return null ; } } if ( billing Account Amt == null ) { billing Account Amt = Big Decimal . ZERO ; } Big Decimal available Balance = Check Out Helper . available Account Balance ( billing Account Id , dispatcher ) ; Big Decimal charge Amount = Big Decimal . ZERO ; if ( billing Account Amt . compare To ( available Balance ) < NUM ) { charge Amount = billing Account Amt ; } else { charge Amount = available Balance ; } if ( charge Amount . compare To ( Big Decimal . ZERO ) < NUM ) { charge Amount = Big Decimal . ZERO ; } return charge Amount ; } else { return null ; } }
public void test Creation Ambiguous ( ) { Instances data ; Array List < Attribute > atts ; String rel Name ; rel Name = STRING ; atts = new Array List < Attribute > ( ) ; atts . add ( new Attribute ( STRING ) ) ; atts . add ( new Attribute ( STRING ) ) ; atts . add ( new Attribute ( STRING , STRING ) ) ; atts . add ( new Attribute ( STRING , new Array List < String > ( Arrays . as List ( new String [ ] { STRING , STRING , STRING } ) ) ) ) ; atts . add ( new Attribute ( STRING , new Array List < String > ( Arrays . as List ( new String [ ] { STRING , STRING } ) ) ) ) ; atts . add ( new Attribute ( STRING , ( Array List < String > ) null ) ) ; try { data = new Instances ( rel Name , atts , NUM ) ; } catch ( Illegal Argument Exception e ) { data = null ; } assert Null ( STRING , data ) ; }
public Host List Panel ( ) { m List = new J List ( ) ; m List . set Model ( new Default List Model ( ) ) ; m Delete But . set Enabled ( BOOL ) ; m Delete But . add Action Listener ( this ) ; m Host Field . add Action Listener ( this ) ; set Layout ( new Border Layout ( ) ) ; set Border ( Border Factory . create Titled Border ( STRING ) ) ; J Panel top Lab = new J Panel ( ) ; Grid Bag Layout gb = new Grid Bag Layout ( ) ; Grid Bag Constraints constraints = new Grid Bag Constraints ( ) ; top Lab . set Border ( Border Factory . create Empty Border ( NUM , NUM , NUM , NUM ) ) ; top Lab . set Layout ( gb ) ; constraints . gridx = NUM ; constraints . gridy = NUM ; constraints . weightx = NUM ; constraints . fill = Grid Bag Constraints . HORIZONTAL ; constraints . gridwidth = NUM ; constraints . gridheight = NUM ; constraints . insets = new Insets ( NUM , NUM , NUM , NUM ) ; top Lab . add ( m Delete But , constraints ) ; constraints . gridx = NUM ; constraints . gridy = NUM ; constraints . weightx = NUM ; constraints . gridwidth = NUM ; constraints . gridheight = NUM ; top Lab . add ( m Host Field , constraints ) ; add ( top Lab , Border Layout . NORTH ) ; add ( new J Scroll Pane ( m List ) , Border Layout . CENTER ) ; }
public static boolean verify Dex File Md 5 ( File file , String md 5 ) { if ( file == null || md 5 == null ) { return BOOL ; } String file Md 5 ; if ( is Raw Dex File ( file . get Name ( ) ) ) { file Md 5 = get MD 5 ( file ) ; } else { Zip File dex Jar = null ; try { dex Jar = new Zip File ( file ) ; Zip Entry classes Dex = dex Jar . get Entry ( Share Constants . DEX IN JAR ) ; if ( null == classes Dex ) { return BOOL ; } file Md 5 = get MD 5 ( dex Jar . get Input Stream ( classes Dex ) ) ; } catch ( IO Exception e ) { return BOOL ; } finally { Share Patch File Util . close Zip ( dex Jar ) ; } } return md 5 . equals ( file Md 5 ) ; }
public String add Highlight ( String channel , String comment ) { if ( channel == null || channel . is Empty ( ) || ! Helper . is Regular Channel ( channel ) ) { return STRING ; } Stream Info stream Info = api . get Stream Info ( Helper . to Stream ( channel ) , null ) ; String stream Time = STRING ; if ( stream Info . is Valid ( ) && stream Info . get Online ( ) ) { stream Time = Date Time . ago ( stream Info . get Time Started ( ) ) ; } if ( comment == null ) { comment = STRING ; } String line = String . format ( STRING , Date Time . full Date Time ( ) , channel , stream Time , comment ) ; synchronized ( this ) { if ( stream Info . get Time Started ( ) != last Stream Start Written ) { add To File ( STRING ) ; } boolean success = add To File ( line ) ; if ( success ) { last Stream Start Written = stream Info . get Time Started ( ) ; String short Comment = STRING ; if ( ! comment . is Empty ( ) ) { short Comment = STRING + String Util . shorten To ( comment , NUM ) + STRING ; } return STRING + channel + STRING + stream Time + STRING + short Comment ; } return STRING ; } }
public void test service 005 ( ) throws Exception { final Bigdata URI service URI = value Factory . create URI ( STRING ) ; final Graph Pattern Group < I Group Member Node > group Node = new Join Group Node ( ) ; { group Node . add Child ( new Statement Pattern Node ( new Var Node ( STRING ) , new Var Node ( STRING ) , new Var Node ( STRING ) ) ) ; } final String expr Image = STRING + service URI + STRING ; final Map < String , String > prefix Decls = new Linked Hash Map < String , String > ( Prefix Decl Processor . default Decls ) ; final Service Node service Node = new Service Node ( new Constant Node ( make IV ( service URI ) ) , group Node ) ; { final Set < I Variable < ? > > projected Vars = new Linked Hash Set < I Variable < ? > > ( ) ; { projected Vars . add ( Var . var ( STRING ) ) ; projected Vars . add ( Var . var ( STRING ) ) ; projected Vars . add ( Var . var ( STRING ) ) ; } service Node . set Expr Image ( expr Image ) ; service Node . set Prefix Decls ( prefix Decls ) ; service Node . set Projected Vars ( projected Vars ) ; } final List < Binding Set > binding Sets = new Linked List < Binding Set > ( ) ; { final Map Binding Set bset = new Map Binding Set ( ) ; final B Node tmp = new B Node Impl ( STRING ) ; bset . add Binding ( STRING , tmp ) ; bset . add Binding ( STRING , tmp ) ; binding Sets . add ( bset ) ; } final Binding Set [ ] a = binding Sets . to Array ( new Binding Set [ binding Sets . size ( ) ] ) ; final I Remote Sparql Query Builder fixture = new Fixture ( service Node , a ) ; final String query Str = fixture . get Sparql Query ( a ) ; final Query Root expected = new Query Root ( Query Type . SELECT ) ; { expected . set Prefix Decls ( prefix Decls ) ; final Projection Node projection = new Projection Node ( ) ; projection . add Projection Var ( new Var Node ( STRING ) ) ; projection . add Projection Var ( new Var Node ( STRING ) ) ; projection . add Projection Var ( new Var Node ( STRING ) ) ; expected . set Projection ( projection ) ; final Join Group Node where Clause = new Join Group Node ( ) ; where Clause . add Child ( new Filter Node ( Function Node . same Term ( new Var Node ( STRING ) , new Var Node ( STRING ) ) ) ) ; where Clause . add Child ( new Statement Pattern Node ( new Var Node ( STRING ) , new Var Node ( STRING ) , new Var Node ( STRING ) , null , Scope . DEFAULT CONTEXTS ) ) ; expected . set Where Clause ( where Clause ) ; { final Linked Hash Set < I Variable < ? > > vars = new Linked Hash Set < I Variable < ? > > ( ) ; final List < I Binding Set > solutions In = new Linked List < I Binding Set > ( ) ; final Bindings Clause bindings Clause = new Bindings Clause ( vars , solutions In ) ; expected . set Bindings Clause ( bindings Clause ) ; { vars . add ( Var . var ( STRING ) ) ; vars . add ( Var . var ( STRING ) ) ; } { final List Binding Set bset = new List Binding Set ( ) ; solutions In . add ( bset ) ; } } } final Query Root actual = parse ( query Str , base URI ) ; assert Same AST ( query Str , expected , actual ) ; }
public double evaluate ( Vector Instance x , double [ ] y ) throws Exception { double dot Prod = x . dot Product ( y ) ; double z = m gamma * dot Prod + m coef 0 ; double a = Math . exp ( z ) ; double b = Math . exp ( - z ) ; return ( ( a - b ) / ( a + b ) ) ; }
protected boolean is Active Slot ( String slot ) { if ( logger . is Debug Enabled ( ) || Testing . DEBUG ) { String active Slot List String = null ; for ( String slot Name : this . active Slots List ) { if ( active Slot List String == null ) { active Slot List String = slot Name ; } else { active Slot List String += STRING + slot Name ; } } logger . info ( STRING + slot ) ; logger . info ( STRING + active Slot List String ) ; } if ( ( active Slots List != null ) && ! active Slots List . is Empty ( ) && slot != null ) { return active Slots List . contains ( slot ) ; } return BOOL ; }
private void update Action Status ( final Message message ) { final Action Update Status action Update Status = convert Message ( message , Action Update Status . class ) ; final Action action = check Action Exist ( message , action Update Status ) ; final Action Status action Status = create Action Status ( message , action Update Status , action ) ; update Last Poll Time ( action . get Target ( ) ) ; switch ( action Update Status . get Action Status ( ) ) { case DOWNLOAD : action Status . set Status ( Status . DOWNLOAD ) ; break ; case RETRIEVED : action Status . set Status ( Status . RETRIEVED ) ; break ; case RUNNING : action Status . set Status ( Status . RUNNING ) ; break ; case CANCELED : action Status . set Status ( Status . CANCELED ) ; break ; case FINISHED : action Status . set Status ( Status . FINISHED ) ; break ; case ERROR : action Status . set Status ( Status . ERROR ) ; break ; case WARNING : action Status . set Status ( Status . WARNING ) ; break ; case CANCEL REJECTED : handle Cancel Rejected ( message , action , action Status ) ; break ; default : log And Throw Message Error ( message , STRING ) ; } final Action add Update Action Status = get Update Action Status ( action Status ) ; if ( ! add Update Action Status . is Active ( ) ) { look If Update Available ( action . get Target ( ) ) ; } }
public static String un Hide ( final String key ) { return is Hidden ( key ) ? key . substring ( HIDDEN PREFIX LENGTH ) : key ; }
public void delivery Complete ( final I Mqtt Delivery Token token ) { logger . trace ( STRING , token . get Message Id ( ) ) ; }
private Type < ? > find Interface ( final Class < ? > the Interface ) { Type < ? > the Interface Type = null ; Linked List < Type < ? > > types = new Linked List < Type < ? > > ( ) ; types . add ( this ) ; while ( the Interface Type == null && ! types . is Empty ( ) ) { Type < ? > current Type = types . remove First ( ) ; if ( the Interface . equals ( current Type . get Raw Type ( ) ) ) { the Interface Type = current Type ; } else if ( ! current Type . equals ( Type Factory . TYPE OF OBJECT ) ) { types . add All ( Arrays . as List ( current Type . get Interfaces ( ) ) ) ; types . add ( current Type . get Super Type ( ) ) ; } } return the Interface Type ; }
public static double incomplete Beta Fraction 2 ( double a , double b , double x ) { double xk , pk , pkm 1 , pkm 2 , qk , qkm 1 , qkm 2 ; double k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 ; double r , t , ans , z , thresh ; int n ; k1 = a ; k2 = b - NUM ; k3 = a ; k4 = a + NUM ; k5 = NUM ; k6 = a + b ; k7 = a + NUM ; ; k8 = a + NUM ; pkm 2 = NUM ; qkm 2 = NUM ; pkm 1 = NUM ; qkm 1 = NUM ; z = x / ( NUM - x ) ; ans = NUM ; r = NUM ; n = NUM ; thresh = NUM * MACHEP ; do { xk = - ( z * k1 * k2 ) / ( k3 * k4 ) ; pk = pkm 1 + pkm 2 * xk ; qk = qkm 1 + qkm 2 * xk ; pkm 2 = pkm 1 ; pkm 1 = pk ; qkm 2 = qkm 1 ; qkm 1 = qk ; xk = ( z * k5 * k6 ) / ( k7 * k8 ) ; pk = pkm 1 + pkm 2 * xk ; qk = qkm 1 + qkm 2 * xk ; pkm 2 = pkm 1 ; pkm 1 = pk ; qkm 2 = qkm 1 ; qkm 1 = qk ; if ( qk != NUM ) r = pk / qk ; if ( r != NUM ) { t = Math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = NUM ; if ( t < thresh ) return ans ; k1 += NUM ; k2 -= NUM ; k3 += NUM ; k4 += NUM ; k5 += NUM ; k6 += NUM ; k7 += NUM ; k8 += NUM ; if ( ( Math . abs ( qk ) + Math . abs ( pk ) ) > big ) { pkm 2 *= biginv ; pkm 1 *= biginv ; qkm 2 *= biginv ; qkm 1 *= biginv ; } if ( ( Math . abs ( qk ) < biginv ) || ( Math . abs ( pk ) < biginv ) ) { pkm 2 *= big ; pkm 1 *= big ; qkm 2 *= big ; qkm 1 *= big ; } } while ( ++ n < NUM ) ; return ans ; }
private String read Value ( char delimiter , boolean resolve Entities , boolean throw On Resolve Failure , Value Context value Context ) throws IO Exception , Xml Pull Parser Exception { int start = position ; String Builder result = null ; if ( value Context == Value Context . TEXT && text != null ) { result = new String Builder ( ) ; result . append ( text ) ; } while ( BOOL ) { if ( position >= limit ) { if ( start < position ) { if ( result == null ) { result = new String Builder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fill Buffer ( NUM ) ) { return result != null ? result . to String ( ) : STRING ; } start = position ; } char c = buffer [ position ] ; if ( c == delimiter || ( delimiter == STRING && ( c <= STRING || c == STRING ) ) || c == STRING && ! resolve Entities ) { break ; } if ( c != STRING && ( c != STRING || value Context != Value Context . ATTRIBUTE ) && c != STRING && c != STRING && ( c != STRING || value Context != Value Context . TEXT ) && ( c != STRING || value Context != Value Context . ENTITY DECLARATION ) ) { is Whitespace &= ( c <= STRING ) ; position ++ ; continue ; } if ( result == null ) { result = new String Builder ( ) ; } result . append ( buffer , start , position - start ) ; if ( c == STRING ) { if ( ( position + NUM < limit || fill Buffer ( NUM ) ) && buffer [ position + NUM ] == STRING ) { position ++ ; } c = ( value Context == Value Context . ATTRIBUTE ) ? STRING : STRING ; } else if ( c == STRING ) { c = STRING ; } else if ( c == STRING ) { is Whitespace = BOOL ; read Entity ( result , BOOL , throw On Resolve Failure , value Context ) ; start = position ; continue ; } else if ( c == STRING ) { if ( value Context == Value Context . ATTRIBUTE ) { check Relaxed ( STRING ) ; } is Whitespace = BOOL ; } else if ( c == STRING ) { if ( ( position + NUM < limit || fill Buffer ( NUM ) ) && buffer [ position + NUM ] == STRING && buffer [ position + NUM ] == STRING ) { check Relaxed ( STRING ) ; } is Whitespace = BOOL ; } else if ( c == STRING ) { throw new Xml Pull Parser Exception ( STRING , this , null ) ; } else { throw new Assertion Error ( ) ; } position ++ ; result . append ( c ) ; start = position ; } if ( result == null ) { return string Pool . get ( buffer , start , position - start ) ; } else { result . append ( buffer , start , position - start ) ; return result . to String ( ) ; } }
private Boot Util ( ) { throw new Assertion Error ( STRING ) ; }
public boolean is Empty ( ) { return children == null || children . is Empty ( ) ; }
@ Override public void draw Background ( Graphics 2 D g2 , Category Plot plot , Rectangle 2 D data Area ) { float x0 = ( float ) data Area . get X ( ) ; float x1 = x0 + ( float ) Math . abs ( this . x Offset ) ; float x3 = ( float ) data Area . get Max X ( ) ; float x2 = x3 - ( float ) Math . abs ( this . x Offset ) ; float y0 = ( float ) data Area . get Max Y ( ) ; float y1 = y0 - ( float ) Math . abs ( this . y Offset ) ; float y3 = ( float ) data Area . get Min Y ( ) ; float y2 = y3 + ( float ) Math . abs ( this . y Offset ) ; General Path clip = new General Path ( ) ; clip . move To ( x0 , y0 ) ; clip . line To ( x0 , y2 ) ; clip . line To ( x1 , y3 ) ; clip . line To ( x3 , y3 ) ; clip . line To ( x3 , y1 ) ; clip . line To ( x2 , y0 ) ; clip . close Path ( ) ; Composite original Composite = g2 . get Composite ( ) ; g2 . set Composite ( Alpha Composite . get Instance ( Alpha Composite . SRC OVER , plot . get Background Alpha ( ) ) ) ; Paint background Paint = plot . get Background Paint ( ) ; if ( background Paint != null ) { g2 . set Paint ( background Paint ) ; g2 . fill ( clip ) ; } General Path left Wall = new General Path ( ) ; left Wall . move To ( x0 , y0 ) ; left Wall . line To ( x0 , y2 ) ; left Wall . line To ( x1 , y3 ) ; left Wall . line To ( x1 , y1 ) ; left Wall . close Path ( ) ; g2 . set Paint ( get Wall Paint ( ) ) ; g2 . fill ( left Wall ) ; General Path bottom Wall = new General Path ( ) ; bottom Wall . move To ( x0 , y0 ) ; bottom Wall . line To ( x1 , y1 ) ; bottom Wall . line To ( x3 , y1 ) ; bottom Wall . line To ( x2 , y0 ) ; bottom Wall . close Path ( ) ; g2 . set Paint ( get Wall Paint ( ) ) ; g2 . fill ( bottom Wall ) ; g2 . set Paint ( Color . light Gray ) ; Line 2 D corner = new Line 2 D . Double ( x0 , y0 , x1 , y1 ) ; g2 . draw ( corner ) ; corner . set Line ( x1 , y1 , x1 , y3 ) ; g2 . draw ( corner ) ; corner . set Line ( x1 , y1 , x3 , y1 ) ; g2 . draw ( corner ) ; Image background Image = plot . get Background Image ( ) ; if ( background Image != null ) { Rectangle 2 D adjusted = new Rectangle 2 D . Double ( data Area . get X ( ) + get X Offset ( ) , data Area . get Y ( ) , data Area . get Width ( ) - get X Offset ( ) , data Area . get Height ( ) - get Y Offset ( ) ) ; plot . draw Background Image ( g2 , adjusted ) ; } g2 . set Composite ( original Composite ) ; }
public static void stop ( Thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { s . write Int ( size ( ) ) ; Enumeration < String > comps = get All ( ) ; while ( comps . has More Elements ( ) ) { s . write Object ( comps . next Element ( ) ) ; } }
public static Container center ( Component center ) { return Container . enclose In ( new Border Layout ( ) , center , Border Layout . CENTER ) ; }
public static Object [ ] put All ( ) { try { Region region = cache . get Region ( Region . SEPARATOR + REGION NAME ) ; assert Not Null ( region ) ; Map map = new Linked Hash Map ( ) ; map . put ( PUTALL KEY 1 , STRING ) ; map . put ( PUTALL KEY 2 , STRING ) ; map . put ( PUTALL KEY 3 , STRING ) ; map . put ( PUTALL KEY 4 , STRING ) ; map . put ( PUTALL KEY 5 , STRING ) ; region . put All ( map ) ; Thread . sleep ( NUM ) ; Event ID [ ] evids = new Event ID [ NUM ] ; evids [ NUM ] = put Allevent Id 1 ; evids [ NUM ] = put Allevent Id 2 ; evids [ NUM ] = put Allevent Id 3 ; evids [ NUM ] = put Allevent Id 4 ; evids [ NUM ] = put Allevent Id 5 ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; assert Not Null ( evids [ NUM ] ) ; return evids ; } catch ( Exception e ) { fail ( STRING , e ) ; } return null ; }
public void load Layout ( Input Stream is , boolean new Tab , String flow Name ) throws Exception { Input Stream Reader isr = new Input Stream Reader ( is ) ; load Layout ( isr , new Tab , flow Name ) ; }
private synchronized void add Tracker ( String path , Object marker , File Delete Strategy delete Strategy ) { if ( exit When Finished ) { throw new Illegal State Exception ( STRING ) ; } if ( reaper == null ) { reaper = new Reaper ( ) ; reaper . start ( ) ; } trackers . add ( new Tracker ( path , delete Strategy , marker , q ) ) ; }
public static void parameters To Attributes ( Http Servlet Request request ) { java . util . Enumeration < String > e = Util Generics . cast ( request . get Parameter Names ( ) ) ; while ( e . has More Elements ( ) ) { String name = e . next Element ( ) ; request . set Attribute ( name , request . get Parameter ( name ) ) ; } }
protected long release Memory ( ) { long memory Freed = NUM ; while ( ! windows For Free Memory . is Empty ( ) ) { long window Id = windows For Free Memory . poll ( ) ; long origin Size = key Stream . size ( ) + value Stream . size ( ) ; key Stream . complete Window ( window Id ) ; value Stream . complete Window ( window Id ) ; memory Freed += origin Size - ( key Stream . size ( ) + value Stream . size ( ) ) ; } if ( memory Freed > NUM ) { LOG . debug ( STRING , memory Freed ) ; size In Bytes . get And Add ( - memory Freed ) ; } return memory Freed ; }
public static boolean is SQL 99 Reserved Keyword ( String identifier ) { if ( identifier == null ) { throw new Null Pointer Exception ( STRING ) ; } return Arrays . binary Search ( SQL 99 RESERVED , identifier . to Upper Case ( ) ) >= NUM ; }
@ Suppress Warnings ( STRING ) public void test Simple RW Writer Reader ( ) throws File Not Found Exception , IO Exception { final Checksum Utility checker = Checksum Utility . get CHK ( ) ; final HA Log Manager manager = new HA Log Manager ( m logdir ) ; final I Root Block View rbv = open RBV ( Store Type Enum . RW ) ; assert True ( rbv . get Store Type ( ) == Store Type Enum . RW ) ; final HA Log File logfile = manager . create Log ( rbv ) ; final IHA Log Writer writer = logfile . get Writer ( ) ; int sequence = NUM ; final Byte Buffer data = random Data ( NUM ) ; final UUID store UUID = UUID . random UUID ( ) ; final IHA Write Message msg = new HA Write Message ( store UUID , rbv . get Commit Counter ( ) , rbv . get First Commit Time ( ) , sequence , data . limit ( ) , checker . checksum ( data ) , rbv . get Store Type ( ) , rbv . get Quorum Token ( ) , NUM , NUM ) ; writer . write ( msg , data ) ; final IHA Log Reader reader = logfile . get Reader ( ) ; assert True ( reader . has More Buffers ( ) ) ; Byte Buffer rbuf = Byte Buffer . allocate ( NUM * NUM * NUM ) ; IHA Write Message rmsg = reader . process Next Buffer ( rbuf ) ; assert True ( rmsg . get Size ( ) == msg . get Size ( ) ) ; writer . close ( close RBV ( rbv ) ) ; assert False ( reader . has More Buffers ( ) ) ; assert True ( logfile . is Open ( ) ) ; reader . close ( ) ; assert False ( logfile . is Open ( ) ) ; try { HA Log Manager . main ( new String [ ] { m logdir . get Absolute Path ( ) } ) ; } catch ( Interrupted Exception e ) { } }
@ Override protected void before Execute ( Thread t , Runnable r ) { if ( is Append Task Name ( ) ) { Named Thread Pool Helper . change Name Before Execute ( t , r ) ; } super . before Execute ( t , r ) ; }
public static byte [ ] compress ( String str ) throws IO Exception { if ( str == null || str . length ( ) == NUM ) { return null ; } Byte Array Output Stream out = new Byte Array Output Stream ( ) ; GZIP Output Stream gzip = new GZIP Output Stream ( out ) ; gzip . write ( str . get Bytes ( STRING ) ) ; gzip . close ( ) ; byte [ ] out Bytes = out . to Byte Array ( ) ; return out Bytes ; }
public static int find Global Peak Location ( double [ ] data ) { double max = Double . Na N ; int imax = - NUM ; for ( int i = NUM ; i < data . length ; i ++ ) { if ( Double . is Na N ( data [ i ] ) ) continue ; if ( Double . is Na N ( max ) || data [ i ] > max ) { max = data [ i ] ; imax = i ; } } return imax ; }
void update Blocks ( int start Line , int end Line , int new Line Count ) { if ( m Block End Lines == null ) { create Blocks ( ) ; return ; } int first Block = - NUM ; int last Block = - NUM ; for ( int i = NUM ; i < m Number Of Blocks ; i ++ ) { if ( m Block End Lines [ i ] >= start Line ) { first Block = i ; break ; } } for ( int i = first Block ; i < m Number Of Blocks ; i ++ ) { if ( m Block End Lines [ i ] >= end Line ) { last Block = i ; break ; } } final int last Block End Line = m Block End Lines [ last Block ] ; boolean create Block Before = start Line > ( first Block == NUM ? NUM : m Block End Lines [ first Block - NUM ] + NUM ) ; boolean create Block = new Line Count > NUM ; boolean create Block After = end Line < m Block End Lines [ last Block ] ; int num Added Blocks = NUM ; if ( create Block Before ) num Added Blocks ++ ; if ( create Block ) num Added Blocks ++ ; if ( create Block After ) num Added Blocks ++ ; final int num Removed Blocks = last Block - first Block + NUM ; final int new Number Of Blocks = m Number Of Blocks + num Added Blocks - num Removed Blocks ; if ( new Number Of Blocks == NUM ) { m Block End Lines [ NUM ] = NUM ; m Block Indices [ NUM ] = INVALID BLOCK INDEX ; m Number Of Blocks = NUM ; return ; } if ( new Number Of Blocks > m Block End Lines . length ) { int [ ] block End Lines = Array Utils . new Unpadded Int Array ( Math . max ( m Block End Lines . length * NUM , new Number Of Blocks ) ) ; int [ ] block Indices = new int [ block End Lines . length ] ; System . arraycopy ( m Block End Lines , NUM , block End Lines , NUM , first Block ) ; System . arraycopy ( m Block Indices , NUM , block Indices , NUM , first Block ) ; System . arraycopy ( m Block End Lines , last Block + NUM , block End Lines , first Block + num Added Blocks , m Number Of Blocks - last Block - NUM ) ; System . arraycopy ( m Block Indices , last Block + NUM , block Indices , first Block + num Added Blocks , m Number Of Blocks - last Block - NUM ) ; m Block End Lines = block End Lines ; m Block Indices = block Indices ; } else { System . arraycopy ( m Block End Lines , last Block + NUM , m Block End Lines , first Block + num Added Blocks , m Number Of Blocks - last Block - NUM ) ; System . arraycopy ( m Block Indices , last Block + NUM , m Block Indices , first Block + num Added Blocks , m Number Of Blocks - last Block - NUM ) ; } m Number Of Blocks = new Number Of Blocks ; int new First Changed Block ; final int delta Lines = new Line Count - ( end Line - start Line + NUM ) ; if ( delta Lines != NUM ) { new First Changed Block = first Block + num Added Blocks ; for ( int i = new First Changed Block ; i < m Number Of Blocks ; i ++ ) { m Block End Lines [ i ] += delta Lines ; } } else { new First Changed Block = m Number Of Blocks ; } m Index First Changed Block = Math . min ( m Index First Changed Block , new First Changed Block ) ; int block Index = first Block ; if ( create Block Before ) { m Block End Lines [ block Index ] = start Line - NUM ; m Block Indices [ block Index ] = INVALID BLOCK INDEX ; block Index ++ ; } if ( create Block ) { m Block End Lines [ block Index ] = start Line + new Line Count - NUM ; m Block Indices [ block Index ] = INVALID BLOCK INDEX ; block Index ++ ; } if ( create Block After ) { m Block End Lines [ block Index ] = last Block End Line + delta Lines ; m Block Indices [ block Index ] = INVALID BLOCK INDEX ; } }
public Object read Object ( Class expected Class ) throws IO Exception { int tag = is . read ( ) ; switch ( tag ) { case STRING : return null ; case STRING : return new Boolean ( BOOL ) ; case STRING : return new Boolean ( BOOL ) ; case STRING : { int b32 = is . read ( ) ; int b24 = is . read ( ) ; int b16 = is . read ( ) ; int b8 = is . read ( ) ; return new Integer ( ( b32 << NUM ) + ( b24 << NUM ) + ( b16 << NUM ) + b8 ) ; } case STRING : { long b64 = is . read ( ) ; long b56 = is . read ( ) ; long b48 = is . read ( ) ; long b40 = is . read ( ) ; long b32 = is . read ( ) ; long b24 = is . read ( ) ; long b16 = is . read ( ) ; long b8 = is . read ( ) ; return new Long ( ( b64 << NUM ) + ( b56 << NUM ) + ( b48 << NUM ) + ( b40 << NUM ) + ( b32 << NUM ) + ( b24 << NUM ) + ( b16 << NUM ) + b8 ) ; } case STRING : { long b64 = is . read ( ) ; long b56 = is . read ( ) ; long b48 = is . read ( ) ; long b40 = is . read ( ) ; long b32 = is . read ( ) ; long b24 = is . read ( ) ; long b16 = is . read ( ) ; long b8 = is . read ( ) ; return new Date ( ( b64 << NUM ) + ( b56 << NUM ) + ( b48 << NUM ) + ( b40 << NUM ) + ( b32 << NUM ) + ( b24 << NUM ) + ( b16 << NUM ) + b8 ) ; } case STRING : case STRING : { int b16 = is . read ( ) ; int b8 = is . read ( ) ; int len = ( b16 << NUM ) + b8 ; return read String Impl ( len ) ; } case STRING : { if ( tag != STRING ) throw expect ( STRING , tag ) ; int b16 = is . read ( ) ; int b8 = is . read ( ) ; int len = ( b16 << NUM ) + b8 ; Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; for ( int i = NUM ; i < len ; i ++ ) bos . write ( is . read ( ) ) ; return bos . to Byte Array ( ) ; } default : throw new IO Exception ( STRING + ( char ) tag ) ; } }
@ Override public void add ( int index , Instance instance ) { Instance new Instance = ( Instance ) instance . copy ( ) ; new Instance . set Dataset ( this ) ; m Instances . add ( index , new Instance ) ; }
protected static String extract Bucket ( String s3 uri ) { return s3 uri . substring ( s3 uri . index Of ( STRING ) + NUM , s3 uri . index Of ( STRING , s3 uri . index Of ( STRING ) ) ) ; }
public boolean do Transaction ( DB db , Object threadstate ) throws Workload Exception { boolean ret = BOOL ; long st = System . nano Time ( ) ; String op = operationchooser . next String ( ) ; if ( op . compare To ( STRING ) == NUM ) { ret = do Transaction Read ( db ) ; } else if ( op . compare To ( STRING ) == NUM ) { ret = do Transaction Update ( db ) ; } else if ( op . compare To ( STRING ) == NUM ) { ret = do Transaction Insert ( db ) ; } else if ( op . compare To ( STRING ) == NUM ) { ret = do Transaction Scan ( db ) ; } else { ret = do Transaction Read Modify Write ( db ) ; } long en = System . nano Time ( ) ; measurements . measure ( operations . get ( op ) , ( int ) ( ( en - st ) / NUM ) ) ; if ( ret ) measurements . report Return Code ( operations . get ( op ) , - NUM ) ; else { measurements . report Return Code ( operations . get ( op ) , NUM ) ; } return ret ; }
public static void copy With Gap ( Object src , Object dst , int old Size , int gap Index ) { if ( gap Index > NUM ) { System . arraycopy ( src , NUM , dst , NUM , gap Index ) ; } if ( gap Index < old Size ) { System . arraycopy ( src , gap Index , dst , gap Index + NUM , old Size - gap Index ) ; } }
protected void add Url Into Sitemap ( String url Str , Site Map site Map , String last Mod , String change Freq , String priority , int url Index ) { try { URL url = new URL ( url Str ) ; boolean valid = url Is Valid ( site Map . get Base Url ( ) , url . to String ( ) ) ; if ( valid || ! strict ) { Site Map URL s Url = new Site Map URL ( url . to String ( ) , last Mod , change Freq , priority , valid ) ; site Map . add Site Map Url ( s Url ) ; LOG . debug ( STRING , url Index + NUM , s Url ) ; } else { LOG . warn ( STRING , url . to External Form ( ) , site Map . get Base Url ( ) ) ; } } catch ( Malformed URL Exception e ) { LOG . warn ( STRING , url Str ) ; LOG . trace ( STRING , e ) ; } }
public Optional < Blaze Edge > edge ( final Object edge Id ) { try ( Closeable Iterator < Edge > it = edges ( edge Id ) ) { final Optional < Blaze Edge > e = it . has Next ( ) ? Optional . of ( ( Blaze Edge ) it . next ( ) ) : Optional . empty ( ) ; if ( it . has Next ( ) ) { throw new Illegal State Exception ( STRING + edge Id ) ; } return e ; } }
static void add Cap ( Ring Buffer . Sequence sequence , long to Add ) { long u , r ; do { r = sequence . get As Long ( ) ; if ( r == Long . MAX VALUE ) { return ; } u = Operators . add Cap ( r , to Add ) ; } while ( ! sequence . compare And Set ( r , u ) ) ; }
private void add ( Http Servlet Request request , Http Servlet Response response ) throws IO Exception { Print Writer out = response . get Writer ( ) ; String label = request . get Parameter ( STRING ) ; String units = request . get Parameter ( STRING ) ; String value = request . get Parameter ( STRING ) ; String detail = request . get Parameter ( STRING ) ; Double val = to Double ( value ) ; if ( is Empty ( label ) || is Empty ( units ) || is Empty ( val ) ) { out . println ( ERROR + STRING ) ; out . println ( STRING ) ; } else { Mon Key key = get Mon Key ( label , detail , units ) ; Monitor mon = Monitor Factory . add ( key , val ) ; out . println ( OK + STRING + label + STRING + mon ) ; } }
public double norm ( ) { if ( m Elements != null ) { int n = m Elements . length ; double sum = NUM ; for ( int i = NUM ; i < n ; i ++ ) { sum += m Elements [ i ] * m Elements [ i ] ; } return Math . pow ( sum , NUM ) ; } else return NUM ; }
public static double P Recall Macro ( int Y [ ] [ ] , int Ypred [ ] [ ] ) { int L = Y [ NUM ] . length ; double m = NUM ; for ( int j = NUM ; j < L ; j ++ ) { int [ ] y j = Matrix Utils . get Col ( Y , j ) ; int [ ] p j = Matrix Utils . get Col ( Ypred , j ) ; if ( all Missing ( y j ) ) { L -- ; continue ; } int [ ] [ ] aligned = align ( y j , p j ) ; int [ ] y j Aligned = aligned [ NUM ] ; int [ ] p j Aligned = aligned [ NUM ] ; double cur Recall = P Recall ( y j Aligned , p j Aligned ) ; if ( Double . is Na N ( cur Recall ) ) { continue ; } m += cur Recall ; } return m / L ; }
public int translate Source Index To Wrapper Position ( int source Pos , int fetched Ads Count ) { int ad Spaces Count = NUM ; if ( source Pos >= get Offset Value ( ) && get No Of Data Between Ads ( ) > NUM ) ad Spaces Count = ( source Pos - get Offset Value ( ) ) / get No Of Data Between Ads ( ) + NUM ; ad Spaces Count = Math . min ( fetched Ads Count , ad Spaces Count ) ; ad Spaces Count = Math . max ( NUM , ad Spaces Count ) ; ad Spaces Count = Math . min ( ad Spaces Count , get Limit Of Ads ( ) ) ; int wrapped Position = source Pos + ad Spaces Count ; return wrapped Position ; }
public Closeable Animated Bitmap ( List < Bitmap > bitmaps , List < Integer > durations , Resource Releaser < Bitmap > resource Releaser ) { Preconditions . check Not Null ( bitmaps ) ; Preconditions . check State ( bitmaps . size ( ) >= NUM , STRING ) ; m Bitmaps = new Array List < > ( bitmaps . size ( ) ) ; m Bitmap References = new Array List < > ( bitmaps . size ( ) ) ; for ( Bitmap bitmap : bitmaps ) { m Bitmap References . add ( Closeable Reference . of ( bitmap , resource Releaser ) ) ; m Bitmaps . add ( bitmap ) ; } m Durations = Preconditions . check Not Null ( durations ) ; Preconditions . check State ( m Durations . size ( ) == m Bitmaps . size ( ) , STRING ) ; }
public static Vector < String > read File Into Vector ( String file Path ) throws Exception { Vector < String > result = new Vector < String > ( ) ; File f = new File ( file Path ) ; if ( ! f . exists ( ) ) throw new Exception ( STRING + file Path + STRING ) ; Buffered Reader br = new Buffered Reader ( new File Reader ( f ) ) ; String line = STRING ; while ( ( line = br . read Line ( ) ) != null ) { result . add ( line ) ; } br . close ( ) ; return result ; }
public void test The Matrix ( ) { String matrix String = STRING ; int [ ] [ ] expected = new int [ ] [ ] { new int [ ] { NUM , NUM , NUM } , new int [ ] { NUM , NUM , NUM } , new int [ ] { NUM , NUM , NUM } , new int [ ] { NUM , NUM , NUM } } ; Integer Converter integer Converter = new Integer Converter ( ) ; Array Converter array Converter = new Array Converter ( int [ ] . class , integer Converter ) ; Array Converter matrix Converter = new Array Converter ( int [ ] [ ] . class , array Converter ) ; matrix Converter . set Delimiter ( STRING ) ; matrix Converter . set Allowed Chars ( new char [ ] { STRING } ) ; try { Object result = matrix Converter . convert ( int [ ] [ ] . class , matrix String ) ; assert Equals ( STRING , int [ ] [ ] . class , result . get Class ( ) ) ; int [ ] [ ] matrix = ( int [ ] [ ] ) result ; assert Equals ( STRING , expected . length , matrix . length ) ; for ( int i = NUM ; i < expected . length ; i ++ ) { assert Equals ( STRING + i + STRING , expected [ i ] . length , matrix [ i ] . length ) ; for ( int j = NUM ; j < expected [ i ] . length ; j ++ ) { String label = STRING + i + STRING + j + STRING ; assert Equals ( label , expected [ i ] [ j ] , matrix [ i ] [ j ] ) ; } } } catch ( Exception e ) { fail ( STRING + e ) ; } }
public String to XML ( final X Stream xstream , final Object obj ) throws Object Stream Exception { final Writer writer = new String Writer ( ) ; try { to XML ( xstream , obj , writer ) ; } catch ( final Object Stream Exception e ) { throw e ; } catch ( final IO Exception e ) { throw new Stream Exception ( STRING , e ) ; } return writer . to String ( ) ; }
protected void respond Vanished ( Mailbox Session session , Message Manager mailbox , List < Message Range > ranges , long changed Since , Meta Data meta Data , Responder responder ) throws Mailbox Exception { if ( meta Data . get Highest Mod Seq ( ) > changed Since ) { Search Query search Query = new Search Query ( ) ; Search Query . Uid Range [ ] n Ranges = new Search Query . Uid Range [ ranges . size ( ) ] ; Set < Message Uid > vanished Uids = new Hash Set < Message Uid > ( ) ; for ( int i = NUM ; i < ranges . size ( ) ; i ++ ) { Message Range r = ranges . get ( i ) ; Search Query . Uid Range nr ; if ( r . get Type ( ) == Type . ONE ) { nr = new Search Query . Uid Range ( r . get Uid From ( ) ) ; } else { nr = new Search Query . Uid Range ( r . get Uid From ( ) , r . get Uid To ( ) ) ; } Message Uid from = nr . get Low Value ( ) ; Message Uid to = nr . get High Value ( ) ; while ( from . compare To ( to ) <= NUM ) { vanished Uids . add ( from ) ; from = from . next ( ) ; } n Ranges [ i ] = nr ; } search Query . and Criteria ( Search Query . uid ( n Ranges ) ) ; search Query . and Criteria ( Search Query . mod Seq Greater Than ( changed Since ) ) ; Iterator < Message Uid > uids = mailbox . search ( search Query , session ) ; while ( uids . has Next ( ) ) { vanished Uids . remove ( uids . next ( ) ) ; } Uid Range [ ] vanished Id Ranges = uid Ranges ( Message Range . to Ranges ( vanished Uids ) ) ; responder . respond ( new Vanished Response ( vanished Id Ranges , BOOL ) ) ; } }
public ESRI Record [ ] locate Records ( double xmin , double ymin , double xmax , double ymax ) throws IO Exception , Format Exception { boolean gather Bounds = BOOL ; if ( bounds == null ) { bounds = new ESRI Bounding Box ( ) ; gather Bounds = BOOL ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + xmin + STRING + ymin + STRING + xmax + STRING + ymax ) ; } byte ix Record [ ] = new byte [ SPATIAL INDEX RECORD LENGTH ] ; int rec Num = NUM ; Vector < ESRI Record > v = new Vector < ESRI Record > ( ) ; int s Record Size = DEFAULT SHAPE RECORD SIZE ; byte s Record [ ] = new byte [ s Record Size ] ; if ( shp File Name == null ) { return null ; } Binary Buffered File ssx = new Binary Buffered File ( ssx ( shp File Name ) ) ; if ( shp == null ) { shp = get Shp File ( shp File Name ) ; } ssx . seek ( NUM ) ; ssx . byte Order ( BOOL ) ; int shape Type = ssx . read Integer ( ) ; ssx . seek ( NUM ) ; while ( BOOL ) { int result = ssx . read ( ix Record , NUM , SPATIAL INDEX RECORD LENGTH ) ; if ( result <= NUM ) { break ; } else { rec Num ++ ; double xmin 2 = read LE Double ( ix Record , NUM ) ; double ymin 2 = read LE Double ( ix Record , NUM ) ; double xmax 2 = read LE Double ( ix Record , NUM ) ; double ymax 2 = read LE Double ( ix Record , NUM ) ; if ( logger . is Loggable ( Level . FINER ) ) { logger . finer ( STRING + rec Num ) ; logger . finer ( STRING + xmin 2 + STRING + ymin 2 + STRING + xmax 2 + STRING + ymax 2 ) ; } if ( gather Bounds ) { bounds . add Point ( xmin 2 , ymin 2 ) ; bounds . add Point ( xmax 2 , ymax 2 ) ; } if ( intersects ( xmin , ymin , xmax , ymax , xmin 2 , ymin 2 , xmax 2 , ymax 2 ) ) { int offset = read BE Int ( ix Record , NUM ) ; int byte Offset = offset * NUM ; int content Length = read BE Int ( ix Record , NUM ) ; int record Size = ( content Length * NUM ) + NUM ; if ( record Size < NUM ) { logger . warning ( STRING + record Size ) ; break ; } if ( record Size > s Record Size ) { s Record Size = record Size ; if ( logger . is Loggable ( Level . FINER ) ) { logger . finer ( STRING + s Record Size ) ; } s Record = new byte [ s Record Size ] ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + byte Offset + STRING + record Size + STRING + offset + STRING + shape Type ) ; } try { shp . seek ( byte Offset ) ; int n Bytes = shp . read ( s Record , NUM , record Size ) ; if ( n Bytes < record Size ) { logger . warning ( STRING + record Size + STRING + n Bytes + STRING ) ; } ESRI Record record = make ESRI Record ( shape Type , s Record , NUM ) ; v . add Element ( record ) ; } catch ( IO Exception ioe ) { logger . warning ( STRING ) ; ioe . print Stack Trace ( ) ; break ; } } } } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + rec Num + STRING ) ; logger . fine ( STRING + v . size ( ) + STRING ) ; } int n Records = v . size ( ) ; ssx . close ( ) ; shp . close ( ) ; shp = null ; ESRI Record result [ ] = new ESRI Record [ n Records ] ; v . copy Into ( result ) ; return result ; }
protected String [ ] create Options ( ) { String [ ] options = new String [ m Classifier Options . length + NUM * m CV Params . size ( ) ] ; int start = NUM , end = options . length ; for ( int i = NUM ; i < m CV Params . size ( ) ; i ++ ) { CV Parameter cv Param = ( CV Parameter ) m CV Params . element At ( i ) ; double param Value = cv Param . m Param Value ; if ( cv Param . m Round Param ) { param Value = Math . rint ( param Value ) ; } boolean is Int = ( ( param Value - ( int ) param Value ) == NUM ) ; if ( cv Param . m Add At End ) { options [ -- end ] = STRING + ( ( cv Param . m Round Param || is Int ) ? Utils . double To String ( param Value , NUM ) : cv Param . m Param Value ) ; options [ -- end ] = STRING + cv Param . m Param Char ; } else { options [ start ++ ] = STRING + cv Param . m Param Char ; options [ start ++ ] = STRING + ( ( cv Param . m Round Param || is Int ) ? Utils . double To String ( param Value , NUM ) : cv Param . m Param Value ) ; } } System . arraycopy ( m Classifier Options , NUM , options , start , m Classifier Options . length ) ; return options ; }
private void add Source Code Remark ( Test Solution test Solution , Element element , String message , String default Lang , String current Lang , String detected Lang , String tested Text ) { if ( test Solution . equals ( Test Solution . PASSED ) || String Utils . is Blank ( message ) ) { return ; } List < Evidence Element > evidence Element List = new Array List < > ( ) ; if ( String Utils . is Not Blank ( current Lang ) ) { evidence Element List . add ( get Evidence Element ( DEFAULT LANGUAGE EE , default Lang ) ) ; evidence Element List . add ( get Evidence Element ( CURRENT LANGUAGE EE , current Lang ) ) ; } else { evidence Element List . add ( get Evidence Element ( LANGUAGE EE , default Lang ) ) ; } evidence Element List . add ( get Evidence Element ( DETECTED LANGUAGE EE , detected Lang ) ) ; if ( tested Text . length ( ) > DISPLAYABLE TEXT SIZE ) { tested Text = tested Text . substring ( NUM , DISPLAYABLE TEXT SIZE ) ; } evidence Element List . add ( get Evidence Element ( EXTRACTED TEXT EE , tested Text ) ) ; add Source Code Remark ( test Solution , element , message , evidence Element List ) ; }
public void mouse Pressed ( Mouse Event e ) { Visualization Viewer < ? , ? > vv = ( Visualization Viewer < ? , ? > ) e . get Source ( ) ; boolean accepted = check Modifiers ( e ) ; down = e . get Point ( ) ; if ( accepted ) { vv . set Cursor ( cursor ) ; } }
public File create New Folder ( File containing Dir ) throws IO Exception { if ( containing Dir == null ) { throw new IO Exception ( STRING ) ; } File new Folder ; new Folder = create File Object ( containing Dir , new Folder String ) ; int i = NUM ; while ( new Folder . exists ( ) && i < NUM ) { new Folder = create File Object ( containing Dir , Message Format . format ( new Folder Next String , new Integer ( i ) ) ) ; i ++ ; } if ( new Folder . exists ( ) ) { throw new IO Exception ( STRING + new Folder . get Absolute Path ( ) ) ; } else { new Folder . mkdirs ( ) ; } return new Folder ; }
private void parse ( XML Stream Reader parser , Handler handler , Map < String , Object > values , Stack < Set < String > > stack , boolean record Started ) throws IO Exception , XML Stream Exception { Set < String > values Addedin This Frame = null ; if ( is Record ) { record Started = BOOL ; values Addedin This Frame = new Hash Set < > ( ) ; stack . push ( values Addedin This Frame ) ; } else if ( record Started ) { values Addedin This Frame = stack . peek ( ) ; } try { if ( attributes != null ) { for ( Node node : attributes ) { String value = parser . get Attribute Value ( null , node . name ) ; if ( value != null || ( record Started && ! is Record ) ) { put Text ( values , value , node . field Name , node . multi Valued ) ; values Addedin This Frame . add ( node . field Name ) ; } } } Set < Node > children Found = new Hash Set < > ( ) ; int event = - NUM ; int flattened Starts = NUM ; String Builder text = new String Builder ( ) ; while ( BOOL ) { event = parser . next ( ) ; if ( event == END ELEMENT ) { if ( flattened Starts > NUM ) flattened Starts -- ; else { if ( has Text && values Addedin This Frame != null ) { values Addedin This Frame . add ( field Name ) ; put Text ( values , text . to String ( ) , field Name , multi Valued ) ; } if ( is Record ) handler . handle ( get Deep Copy ( values ) , for Each Path ) ; if ( child Nodes != null && record Started && ! is Record && ! children Found . contains All ( child Nodes ) ) { for ( Node n : child Nodes ) { if ( ! children Found . contains ( n ) ) n . put Nulls ( values , values Addedin This Frame ) ; } } return ; } } else if ( has Text && ( event == CDATA || event == CHARACTERS || event == SPACE ) ) { text . append ( parser . get Text ( ) ) ; } else if ( event == START ELEMENT ) { if ( flatten ) flattened Starts ++ ; else handle Start Element ( parser , children Found , handler , values , stack , record Started ) ; } else if ( event == END DOCUMENT ) return ; } } finally { if ( ( is Record || ! record Started ) && ! stack . empty ( ) ) { Set < String > clean This = stack . pop ( ) ; if ( clean This != null ) { for ( String fld : clean This ) values . remove ( fld ) ; } } } }
@ Override public boolean equals ( Object object ) { if ( object == this ) { return BOOL ; } if ( object instanceof Resizable Double Array == BOOL ) { return BOOL ; } boolean result = BOOL ; final Resizable Double Array other = ( Resizable Double Array ) object ; result = result && ( other . contraction Criterion == contraction Criterion ) ; result = result && ( other . expansion Factor == expansion Factor ) ; result = result && ( other . expansion Mode == expansion Mode ) ; result = result && ( other . num Elements == num Elements ) ; result = result && ( other . start Index == start Index ) ; if ( ! result ) { return BOOL ; } else { return Arrays . equals ( internal Array , other . internal Array ) ; } }
public Ind Test Probabilistic Verbose ( Data Set data Set , Print Writer out , Ind Test D Sep dsep Test ) { this . out = out ; this . dsep Test = dsep Test ; if ( ! data Set . is Discrete ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } this . data = data Set ; int [ ] node Dimensions = new int [ data Set . get Num Columns ( ) + NUM ] ; for ( int j = NUM ; j < data Set . get Num Columns ( ) ; j ++ ) { Discrete Variable variable = ( Discrete Variable ) ( data Set . get Variable ( j ) ) ; int num Categories = variable . get Num Categories ( ) ; node Dimensions [ j + NUM ] = num Categories ; } int [ ] [ ] cases = new int [ data Set . get Num Rows ( ) + NUM ] [ data Set . get Num Columns ( ) + NUM ] ; for ( int i = NUM ; i < data Set . get Num Rows ( ) ; i ++ ) { for ( int j = NUM ; j < data Set . get Num Columns ( ) ; j ++ ) { cases [ i + NUM ] [ j + NUM ] = data Set . get Int ( i , j ) + NUM ; } } bci = new BC Inference ( cases , node Dimensions ) ; nodes = data Set . get Variables ( ) ; indices = new Hash Map < > ( ) ; for ( int i = NUM ; i < nodes . size ( ) ; i ++ ) { indices . put ( nodes . get ( i ) , i ) ; } this . H = new Hash Map < > ( ) ; }
public static Array List < Long > load Workspace Screens Db ( Context context ) { final Content Resolver content Resolver = context . get Content Resolver ( ) ; final Uri screens Uri = Launcher Settings . Workspace Screens . CONTENT URI ; final Cursor sc = content Resolver . query ( screens Uri , null , null , null , Launcher Settings . Workspace Screens . SCREEN RANK ) ; Array List < Long > screen Ids = new Array List < Long > ( ) ; try { final int id Index = sc . get Column Index Or Throw ( Launcher Settings . Workspace Screens . ID ) ; while ( sc . move To Next ( ) ) { try { screen Ids . add ( sc . get Long ( id Index ) ) ; } catch ( Exception e ) { Launcher . add Dump Log ( TAG , STRING + STRING + e , BOOL ) ; } } } finally { sc . close ( ) ; } return screen Ids ; }
public boolean render ( Internal Context Adapter context , Writer writer ) throws IO Exception , Method Invocation Exception { if ( reference Type == RUNT ) { writer . write ( root String ) ; return BOOL ; } Object value = execute ( null , context ) ; if ( escaped ) { if ( value == null ) { writer . write ( esc Prefix ) ; writer . write ( STRING ) ; writer . write ( null String ) ; } else { writer . write ( esc Prefix ) ; writer . write ( null String ) ; } return BOOL ; } Event Cartridge ec = context . get Event Cartridge ( ) ; if ( ec != null ) { value = ec . reference Insert ( literal , value ) ; } if ( value == null ) { writer . write ( esc Prefix ) ; writer . write ( esc Prefix ) ; writer . write ( more Prefix ) ; writer . write ( null String ) ; if ( reference Type != QUIET REFERENCE && rsvc . get Boolean ( Runtime Constants . RUNTIME LOG REFERENCE LOG INVALID , BOOL ) ) { rsvc . warn ( new Reference Exception ( STRING + context . get Current Template Name ( ) , this ) ) ; } return BOOL ; } else { writer . write ( esc Prefix ) ; writer . write ( more Prefix ) ; writer . write ( value . to String ( ) ) ; return BOOL ; } }
protected String e ( String s ) throws Exception { return fmt . format ( parser . parse ( s ) ) ; }
public static boolean equals ( float [ ] field 1 , float [ ] field 2 ) { if ( field 1 == null || field 1 . length == NUM ) { return field 2 == null || field 2 . length == NUM ; } else { return Arrays . equals ( field 1 , field 2 ) ; } }
public void accept Data Point ( double [ ] data Point ) { if ( m output Frame != null && ( m x Count % m refresh Frequency == NUM ) ) { double [ ] dp = new double [ data Point . length + NUM ] ; dp [ dp . length - NUM ] = m x Count ; System . arraycopy ( data Point , NUM , dp , NUM , data Point . length ) ; for ( double element : data Point ) { if ( element < m min ) { m old Min = m min ; m min = element ; m y Scale Update = BOOL ; } if ( element > m max ) { m old Max = m max ; m max = element ; m y Scale Update = BOOL ; } } if ( m y Scale Update ) { m scale Panel . repaint ( ) ; m y Scale Update = BOOL ; } synchronized ( m data List ) { m data List . add ( m data List . size ( ) , dp ) ; m data List . notify All ( ) ; } } }
public Link Icon ( boolean linked ) { this . linked = linked ; link = linked ? linked Im Ic . get Image ( ) : unlinked Im Ic . get Image ( ) ; add Mouse Listener ( this ) ; Dimension dim = new Dimension ( ( int ) link . get Width ( null ) , link . get Height ( null ) ) ; set Preferred Size ( dim ) ; set Minimum Size ( dim ) ; set Maximum Size ( dim ) ; set Size ( dim ) ; set Layout ( null ) ; repaint ( ) ; }
private Geometry union Using Envelope Intersection ( Geometry g0 , Geometry g1 , Envelope common ) { List disjoint Polys = new Array List ( ) ; Geometry g0 Int = extract By Envelope ( common , g0 , disjoint Polys ) ; Geometry g1 Int = extract By Envelope ( common , g1 , disjoint Polys ) ; Geometry union = union Actual ( g0 Int , g1 Int ) ; disjoint Polys . add ( union ) ; Geometry overall Union = Geometry Combiner . combine ( disjoint Polys ) ; return overall Union ; }
public void stop And Wait For Client On Thread ( long ms ) { if ( client Running On Thread != null && client Running On Thread . is Alive ( ) ) { client Running On Thread . interrupt ( ) ; } long start = System . current Time Millis ( ) ; while ( ( System . current Time Millis ( ) - start ) < ms ) { if ( client Running On Thread != null && client Running On Thread . is Alive ( ) ) { try { client Running On Thread . join ( ms - ( System . current Time Millis ( ) - start ) ) ; break ; } catch ( Interrupted Exception e ) { } } else { break ; } } if ( client Running On Thread != null && client Running On Thread . is Alive ( ) ) { throw new Assertion Error ( STRING + ms + STRING ) ; } }
private boolean is Accessible User Filter ( Set < String > filters , String request Path ) { String index = normalize Url Path ( request Path ) ; String [ ] array = filters . to Array ( new String [ NUM ] ) ; for ( String filter : array ) { if ( index . matches ( filter ) ) { return BOOL ; } } return BOOL ; }
public boolean add Row ( Table Entry entry ) { try { int row = list . size ( ) ; list . add ( entry ) ; fire Table Rows Inserted ( row , row ) ; } catch ( Exception e ) { return BOOL ; } return BOOL ; }
protected boolean write Fields ( Data Output Stream dd ) throws IO Exception { field info fi ; int i ; for ( i = NUM ; i < fields count ; i ++ ) { fi = fields [ i ] ; dd . write Short ( fi . access flags ) ; dd . write Short ( fi . name index ) ; dd . write Short ( fi . descriptor index ) ; dd . write Short ( fi . attributes count ) ; if ( fi . attributes count > NUM ) { write Attributes ( dd , fi . attributes count , fi . attributes ) ; } } return BOOL ; }
public void test Close ( ) throws SQL Exception { Prepared Statement ps 1 = null ; Prepared Statement ps 2 = null ; try { Statement s = conn . create Statement ( ) ; s . add Batch ( STRING ) ; s . add Batch ( STRING ) ; s . add Batch ( STRING ) ; s . add Batch ( STRING ) ; s . execute Batch ( ) ; s . close ( ) ; conn . commit ( ) ; ps 1 = conn . prepare Statement ( STRING ) ; ps 2 = conn . prepare Statement ( STRING ) ; Result Set rs 1 = ps 1 . execute Query ( ) ; try { Result Set rs 2 = ps 2 . execute Query ( ) ; while ( rs 2 . next ( ) ) { } fail ( STRING ) ; } catch ( SQL Exception sqle ) { } while ( rs 1 . next ( ) ) { } conn . commit ( ) ; rs 1 . close ( ) ; ps 1 . close ( ) ; ps 2 . close ( ) ; } finally { try { if ( ps 1 != null ) ps 1 . close ( ) ; if ( ps 2 != null ) ps 2 . close ( ) ; conn . rollback ( ) ; } catch ( SQL Exception e ) { e . print Stack Trace ( ) ; } } }
public Request add Request Header ( String header , String value ) { if ( header == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( header . contains ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } if ( value == null ) { value = STRING ; } request Headers . add ( Pair . create ( header , value ) ) ; return this ; }
Server Member update ( Member . Type type , Instant time ) { if ( this . type != type ) { this . type = Assert . not Null ( type , STRING ) ; if ( time . is After ( updated ) ) { this . updated = Assert . not Null ( time , STRING ) ; } if ( type Change Listeners != null ) { type Change Listeners . accept ( type ) ; } } return this ; }
public static boolean is Client Level Only ( int AD Client ID , int AD Table ID ) { Boolean share = is Shared ( AD Client ID , AD Table ID ) ; if ( share != null ) return share . boolean Value ( ) ; return BOOL ; }
@ Override public void action Performed ( Action Event event ) { String command = event . get Action Command ( ) ; if ( command . equals ( STRING ) ) { attempt Background Paint Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Outline Stroke Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Outline Paint Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Orientation Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Draw Lines Selection ( ) ; } else if ( command . equals ( STRING ) ) { attempt Draw Shapes Selection ( ) ; } }
public static byte [ ] serialize Jdk ( Object obj ) throws IO Exception { Byte Array Output Stream byte Out = null ; Object Output Stream obj Out = null ; try { byte Out = new Byte Array Output Stream ( NUM ) ; obj Out = new Object Output Stream ( byte Out ) ; obj Out . write Object ( obj ) ; obj Out . flush ( ) ; return byte Out . to Byte Array ( ) ; } finally { close ( obj Out ) ; close ( byte Out ) ; } }
void bind If Not Bound ( String mod Name , Module Pointer mod Pointer ) { if ( context . get ( mod Name ) == null ) context . put ( mod Name , mod Pointer ) ; }
private static File unpack Nar ( final File nar , final File base Working Directory ) throws IO Exception { final File nar Working Directory = new File ( base Working Directory , nar . get Name ( ) + STRING ) ; if ( ! nar Working Directory . exists ( ) ) { unpack ( nar , nar Working Directory , calculate Md 5 sum ( nar ) ) ; } else { final byte [ ] nar Md 5 = calculate Md 5 sum ( nar ) ; final File working Hash File = new File ( nar Working Directory , HASH FILENAME ) ; if ( ! working Hash File . exists ( ) ) { File Utils . delete File ( nar Working Directory , BOOL ) ; unpack ( nar , nar Working Directory , nar Md 5 ) ; } else { final byte [ ] hash File Contents = Files . read All Bytes ( working Hash File . to Path ( ) ) ; if ( ! Arrays . equals ( hash File Contents , nar Md 5 ) ) { logger . info ( STRING , new Object [ ] { nar . get Absolute Path ( ) } ) ; File Utils . delete File ( nar Working Directory , BOOL ) ; unpack ( nar , nar Working Directory , nar Md 5 ) ; } } } return nar Working Directory ; }
@ Suppress Warnings ( STRING ) public Enumerated Data ( Data Source original , double offset , double steps ) { this . original = original ; this . offset = offset ; this . steps = steps ; Class < ? extends Comparable < ? > > [ ] types Orig = original . get Column Types ( ) ; Class < ? extends Comparable < ? > > [ ] types = new Class [ types Orig . length + NUM ] ; System . arraycopy ( types Orig , NUM , types , NUM , types Orig . length ) ; types [ NUM ] = Double . class ; set Column Types ( types ) ; original . add Data Listener ( this ) ; }
public boolean clicked On Marker ( float x , float y , float point Click Radius , Over Scroller scroller , int duration ) { for ( int i = NUM ; i < points Count Within X Range * NUM ; i += NUM ) { float point X = get Draw X ( x Range Points [ i ] ) ; float point Y = get Draw Y ( x Range Points [ i + NUM ] ) ; float x Diff = Math . abs ( x - point X ) ; float y Diff = Math . abs ( y - point Y ) ; if ( x Diff < point Click Radius && y Diff < point Click Radius ) { scroll X To ( scroller , point X , duration ) ; return BOOL ; } } return BOOL ; }
public void test Merge One Filter Into Document With Another Filter ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; assert True ( Web Xml Utils . has Filter ( src Web Xml , STRING ) ) ; assert True ( Web Xml Utils . has Filter ( src Web Xml , STRING ) ) ; }
@ Override public String to String ( ) { final String Builder sb = new String Builder ( ) ; for ( Edge < S > edge : edges ) { final S src = edge . get Src ( ) ; sb . append ( print Items ( src . get Items ( ) ) ) ; sb . append ( STRING + edge . get Symbol ( ) + STRING ) ; final S dest = edge . get Dest ( ) ; sb . append ( print Items ( dest . get Items ( ) ) ) ; if ( is End State ( dest ) ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; } return sb . to String ( ) ; }
public void if Cmp ( final Type type , final int mode , final Label label ) { switch ( type . get Sort ( ) ) { case Type . LONG : mv . visit Insn ( Opcodes . LCMP ) ; break ; case Type . DOUBLE : mv . visit Insn ( mode == GE || mode == GT ? Opcodes . DCMPL : Opcodes . DCMPG ) ; break ; case Type . FLOAT : mv . visit Insn ( mode == GE || mode == GT ? Opcodes . FCMPL : Opcodes . FCMPG ) ; break ; case Type . ARRAY : case Type . OBJECT : switch ( mode ) { case EQ : mv . visit Jump Insn ( Opcodes . IF ACMPEQ , label ) ; return ; case NE : mv . visit Jump Insn ( Opcodes . IF ACMPNE , label ) ; return ; } throw new Illegal Argument Exception ( STRING + type ) ; default : int int Op = - NUM ; switch ( mode ) { case EQ : int Op = Opcodes . IF ICMPEQ ; break ; case NE : int Op = Opcodes . IF ICMPNE ; break ; case GE : int Op = Opcodes . IF ICMPGE ; break ; case LT : int Op = Opcodes . IF ICMPLT ; break ; case LE : int Op = Opcodes . IF ICMPLE ; break ; case GT : int Op = Opcodes . IF ICMPGT ; break ; } mv . visit Jump Insn ( int Op , label ) ; return ; } mv . visit Jump Insn ( mode , label ) ; }
public static Text Line Component [ ] create Components On Run ( int run Start , int run Limit , char [ ] chars , int [ ] chars Lto V , byte [ ] levels , Text Label Factory factory , Font font , Core Metrics cm , Font Render Context frc , Decoration decorator , Text Line Component [ ] components , int num Components ) { int pos = run Start ; do { int chunk Limit = first Visual Chunk ( chars Lto V , levels , pos , run Limit ) ; do { int start Pos = pos ; int lm Count ; if ( cm == null ) { Line Metrics line Metrics = font . get Line Metrics ( chars , start Pos , chunk Limit , frc ) ; cm = Core Metrics . get ( line Metrics ) ; lm Count = line Metrics . get Num Chars ( ) ; } else { lm Count = ( chunk Limit - start Pos ) ; } Text Line Component next Component = factory . create Extended ( font , cm , decorator , start Pos , start Pos + lm Count ) ; ++ num Components ; if ( num Components >= components . length ) { components = expand Array ( components ) ; } components [ num Components - NUM ] = next Component ; pos += lm Count ; } while ( pos < chunk Limit ) ; } while ( pos < run Limit ) ; return components ; }
public static String left Pad ( String s , int min Length , char filling ) { int ln = s . length ( ) ; if ( min Length <= ln ) { return s ; } String Builder res = new String Builder ( min Length ) ; int dif = min Length - ln ; for ( int i = NUM ; i < dif ; i ++ ) { res . append ( filling ) ; } res . append ( s ) ; return res . to String ( ) ; }
static String [ ] decode Auth Password ( final String auth Password Value ) throws Decode Exception { final int length = auth Password Value . length ( ) ; int pos = NUM ; pos = read Spaces ( auth Password Value , pos ) ; final String Builder scheme = new String Builder ( ) ; pos = read Scheme ( auth Password Value , scheme , pos ) ; if ( scheme . length ( ) == NUM ) { throw Decode Exception . error ( ERR ATTR SYNTAX AUTHPW NO SCHEME . get ( ) ) ; } pos = read Spaces ( auth Password Value , pos ) ; throw If End Reached ( auth Password Value , length , pos , ERR ATTR SYNTAX AUTHPW NO SCHEME SEPARATOR ) ; pos ++ ; pos = read Spaces ( auth Password Value , pos ) ; final String Builder auth Info = new String Builder ( ) ; pos = read Auth Info ( auth Password Value , auth Info , pos ) ; if ( auth Info . length ( ) == NUM ) { throw Decode Exception . error ( ERR ATTR SYNTAX AUTHPW NO AUTH INFO . get ( ) ) ; } pos = read Spaces ( auth Password Value , pos ) ; throw If End Reached ( auth Password Value , length , pos , ERR ATTR SYNTAX AUTHPW NO AUTH INFO SEPARATOR ) ; pos ++ ; pos = read Spaces ( auth Password Value , pos ) ; final String Builder auth Value = new String Builder ( ) ; pos = read Auth Value ( auth Password Value , length , pos , auth Value ) ; if ( auth Value . length ( ) == NUM ) { throw Decode Exception . error ( ERR ATTR SYNTAX AUTHPW NO AUTH VALUE . get ( ) ) ; } while ( pos < length ) { final char c = auth Password Value . char At ( pos ) ; if ( c == STRING ) { pos ++ ; } else { throw Decode Exception . error ( ERR ATTR SYNTAX AUTHPW INVALID TRAILING CHAR . get ( pos ) ) ; } } return new String [ ] { scheme . to String ( ) , auth Info . to String ( ) , auth Value . to String ( ) } ; }
public String to HTML ( ) { String Builder builder = new String Builder ( ) ; int num Classes = classes . size ( ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( String . format ( STRING , num Classes + NUM ) ) ; builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( predicted ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; String first Column Label = String . format ( STRING , num Classes + NUM ) ; for ( T actual : classes ) { builder . append ( first Column Label ) ; first Column Label = STRING ; builder . append ( String . format ( STRING , actual ) ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( get Count ( actual , predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( get Actual Total ( actual ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; for ( T predicted : classes ) { builder . append ( STRING ) ; builder . append ( get Predicted Total ( predicted ) ) ; builder . append ( STRING ) ; } builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; return builder . to String ( ) ; }
@ Override public final Data Tag Update configure Cache Object ( final T data Tag , final Properties properties ) throws Configuration Exception , Illegal Argument Exception , Illegal Access Exception { Data Tag Cache Object data Tag Cache Object = ( Data Tag Cache Object ) data Tag ; Data Tag Update data Tag Update = set Common Properties ( data Tag Cache Object , properties ) ; String tmp Str ; if ( equipment Facade != null && ! ( data Tag Cache Object instanceof Control Tag ) ) { if ( ( tmp Str = properties . get Property ( STRING ) ) != null ) { try { data Tag Cache Object . set Equipment Id ( Long . value Of ( tmp Str ) ) ; data Tag Cache Object . set Process Id ( equipment Facade . get Process Id For Abstract Equipment ( data Tag Cache Object . get Equipment Id ( ) ) ) ; } catch ( Number Format Exception e ) { throw new Configuration Exception ( Configuration Exception . INVALID PARAMETER VALUE , STRING + STRING + tmp Str ) ; } } else if ( ( tmp Str = properties . get Property ( STRING ) ) != null ) { try { data Tag Cache Object . set Sub Equipment Id ( Long . value Of ( tmp Str ) ) ; data Tag Cache Object . set Process Id ( sub Equipment Facade . get Process Id For Abstract Equipment ( data Tag Cache Object . get Sub Equipment Id ( ) ) ) ; } catch ( Number Format Exception e ) { throw new Configuration Exception ( Configuration Exception . INVALID PARAMETER VALUE , STRING + STRING + tmp Str ) ; } } } if ( ( tmp Str = properties . get Property ( STRING ) ) != null ) { if ( tmp Str . equals ( STRING ) ) { data Tag Cache Object . set Min Value ( null ) ; data Tag Update . set Min Value ( null ) ; } else { Comparable comparable Min = ( Comparable ) Type Converter . cast ( tmp Str , data Tag Cache Object . get Data Type ( ) ) ; data Tag Cache Object . set Min Value ( comparable Min ) ; data Tag Update . set Min Value ( ( Number ) comparable Min ) ; } } if ( ( tmp Str = properties . get Property ( STRING ) ) != null ) { if ( tmp Str . equals ( STRING ) ) { data Tag Cache Object . set Max Value ( null ) ; data Tag Update . set Max Value ( null ) ; } else { Comparable comparable Max = ( Comparable ) Type Converter . cast ( tmp Str , data Tag Cache Object . get Data Type ( ) ) ; data Tag Cache Object . set Max Value ( comparable Max ) ; data Tag Update . set Max Value ( ( Number ) comparable Max ) ; } } tmp Str = properties . get Property ( STRING ) ; if ( tmp Str != null ) { Data Tag Address data Tag Address = Data Tag Address . from Config XML ( tmp Str ) ; data Tag Cache Object . set Address ( data Tag Address ) ; set Update Data Tag Address ( data Tag Address , data Tag Update ) ; } if ( data Tag . get Equipment Id ( ) != null ) data Tag Update . set Equipment Id ( data Tag . get Equipment Id ( ) ) ; return data Tag Update ; }
public final boolean is Closed ( ) { return closed . get ( ) ; }
public static Map < String , Object > perform Find List ( Dispatch Context dctx , Map < String , Object > context ) { Integer view Size = ( Integer ) context . get ( STRING ) ; if ( view Size == null ) view Size = Integer . value Of ( NUM ) ; context . put ( STRING , view Size ) ; Integer view Index = ( Integer ) context . get ( STRING ) ; if ( view Index == null ) view Index = Integer . value Of ( NUM ) ; context . put ( STRING , view Index ) ; Map < String , Object > result = perform Find ( dctx , context ) ; int start = view Index . int Value ( ) * view Size . int Value ( ) ; List < Generic Value > list = null ; Integer list Size = null ; try { Entity List Iterator it = ( Entity List Iterator ) result . get ( STRING ) ; list = it . get Partial List ( start + NUM , view Size ) ; list Size = it . get Results Size After Partial List ( ) ; it . close ( ) ; } catch ( Exception e ) { Debug . log Info ( STRING + e , module ) ; } result . put ( STRING , list Size ) ; result . put ( STRING , list ) ; result . remove ( STRING ) ; return result ; }
protected OM Node create Next OM Element ( ) { OM Node new Element = null ; if ( element Level == NUM && custom Builder For Payload != null ) { OM Node parent = last Node ; if ( parent != null && parent . is Complete ( ) ) { parent = ( OM Node ) last Node . get Parent ( ) ; } if ( parent instanceof SOAP Body ) { new Element = create With Custom Builder ( custom Builder For Payload , soap Factory ) ; } } if ( new Element == null && custom Builders != null && element Level <= max Depth For Custom Builders ) { String namespace = parser . get Namespace URI ( ) ; String local Part = parser . get Local Name ( ) ; Custom Builder custom Builder = get Custom Builder ( namespace , local Part ) ; if ( custom Builder != null ) { new Element = create With Custom Builder ( custom Builder , soap Factory ) ; } } if ( new Element == null ) { new Element = create OM Element ( ) ; } else { element Level -- ; } return new Element ; }
@ Override public void close ( ) { super . close ( ) ; all Locks . remove ( file Name ) ; try { File Channel channel = lock . channel ( ) ; lock . release ( ) ; channel . close ( ) ; File file = new File ( file Name + LCK EXT ) ; file . delete ( ) ; } catch ( IO Exception e ) { } }
protected boolean eq ( Object x , Object y ) { return x == y || x . equals ( y ) ; }
@ Override public final void write Char ( int v ) throws IO Exception { work [ NUM ] = ( byte ) v ; work [ NUM ] = ( byte ) ( v > > NUM ) ; dis . write ( work , NUM , NUM ) ; }
public grammaticality Estimator ( Set File Names , int i Min Char , int i Max Char , int i Min Word , int i Max Word , int i Neighbourhood Window ) { i Min Char N Gram = i Min Char ; i Max Char N Gram = i Max Char ; i Min Word N Gram = i Min Word ; i Max Word N Gram = i Max Word ; Distro Docs = new Tree Map < Integer , Distribution Document > ( ) ; Distro Word Docs = new Tree Map < Integer , Distribution Word Document > ( ) ; String Buffer sb = new String Buffer ( ) ; Iterator i Texts = File Names . iterator ( ) ; while ( i Texts . has Next ( ) ) { String s File = ( String ) i Texts . next ( ) ; try { Buffered Reader bf = new Buffered Reader ( new File Reader ( s File ) ) ; String s Tmp ; while ( ( s Tmp = bf . read Line ( ) ) != null ) sb . append ( s Tmp ) ; bf . close ( ) ; } catch ( File Not Found Exception ex ) { ex . print Stack Trace ( System . err ) ; } catch ( IO Exception ex ) { ex . print Stack Trace ( System . err ) ; } sb . append ( ( char ) NUM ) ; } Full Text Data String = sb . to String ( ) ; for ( int i Cnt = i Min Char N Gram ; i Cnt <= i Max Char N Gram ; i Cnt ++ ) { Distro Docs . put ( i Cnt , new Distribution Document ( i Neighbourhood Window , i Cnt ) ) ; } for ( int i Cnt = i Min Word N Gram ; i Cnt <= i Max Word N Gram ; i Cnt ++ ) { Distro Word Docs . put ( i Cnt , new Distribution Word Document ( i Neighbourhood Window , i Cnt ) ) ; } }
public void test Find Spring Attributes Open Ldap ( ) { Ldap Proxy proxy = get Ldap Open Ldap ( ) ; List result = null ; try { result = proxy . find ( get Ldap Search VO ( STRING , Ldap Constants . NO SEARCH LIMIT , null , null , new String [ ] { STRING } , Ldap Scope Constants . SCOPE SUBTREE ) ) ; } catch ( Exception e ) { } assert Not Null ( result ) ; assert Equals ( NUM , result . size ( ) ) ; }
public static String date To Header String ( Date dat ) { Simple Date Format fmt = new Simple Date Format ( HTTP FORMAT , Locale . US ) ; fmt . set Time Zone ( GMT ZONE ) ; return ( fmt . format ( dat ) ) ; }
public boolean extract Eigenvectors ( Vec 3 result 1 , Vec 3 result 2 , Vec 3 result 3 ) { if ( result 1 == null || result 2 == null || result 3 == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } if ( this . m [ NUM ] != this . m [ NUM ] || this . m [ NUM ] != this . m [ NUM ] || this . m [ NUM ] != this . m [ NUM ] ) { return BOOL ; } final double EPSILON = NUM ; final int MAX SWEEPS = NUM ; double m11 = this . m [ NUM ] ; double m12 = this . m [ NUM ] ; double m13 = this . m [ NUM ] ; double m22 = this . m [ NUM ] ; double m23 = this . m [ NUM ] ; double m33 = this . m [ NUM ] ; double [ ] [ ] r = new double [ NUM ] [ NUM ] ; r [ NUM ] [ NUM ] = r [ NUM ] [ NUM ] = r [ NUM ] [ NUM ] = NUM ; for ( int a = NUM ; a < MAX SWEEPS ; a ++ ) { if ( Math . abs ( m12 ) < EPSILON && Math . abs ( m13 ) < EPSILON && Math . abs ( m23 ) < EPSILON ) { break ; } if ( m12 != NUM ) { double u = ( m22 - m11 ) * NUM / m12 ; double u2 = u * u ; double u2 p 1 = u2 + NUM ; double t = ( u2 p 1 != u2 ) ? ( ( u < NUM ) ? - NUM : NUM ) * ( Math . sqrt ( u2 p 1 ) - Math . abs ( u ) ) : NUM / u ; double c = NUM / Math . sqrt ( t * t + NUM ) ; double s = c * t ; m11 -= t * m12 ; m22 += t * m12 ; m12 = NUM ; double temp = c * m13 - s * m23 ; m23 = s * m13 + c * m23 ; m13 = temp ; for ( int i = NUM ; i < NUM ; i ++ ) { temp = c * r [ i ] [ NUM ] - s * r [ i ] [ NUM ] ; r [ i ] [ NUM ] = s * r [ i ] [ NUM ] + c * r [ i ] [ NUM ] ; r [ i ] [ NUM ] = temp ; } } if ( m13 != NUM ) { double u = ( m33 - m11 ) * NUM / m13 ; double u2 = u * u ; double u2 p 1 = u2 + NUM ; double t = ( u2 p 1 != u2 ) ? ( ( u < NUM ) ? - NUM : NUM ) * ( Math . sqrt ( u2 p 1 ) - Math . abs ( u ) ) : NUM / u ; double c = NUM / Math . sqrt ( t * t + NUM ) ; double s = c * t ; m11 -= t * m13 ; m33 += t * m13 ; m13 = NUM ; double temp = c * m12 - s * m23 ; m23 = s * m12 + c * m23 ; m12 = temp ; for ( int i = NUM ; i < NUM ; i ++ ) { temp = c * r [ i ] [ NUM ] - s * r [ i ] [ NUM ] ; r [ i ] [ NUM ] = s * r [ i ] [ NUM ] + c * r [ i ] [ NUM ] ; r [ i ] [ NUM ] = temp ; } } if ( m23 != NUM ) { double u = ( m33 - m22 ) * NUM / m23 ; double u2 = u * u ; double u2 p 1 = u2 + NUM ; double t = ( u2 p 1 != u2 ) ? ( ( u < NUM ) ? - NUM : NUM ) * ( Math . sqrt ( u2 p 1 ) - Math . abs ( u ) ) : NUM / u ; double c = NUM / Math . sqrt ( t * t + NUM ) ; double s = c * t ; m22 -= t * m23 ; m33 += t * m23 ; m23 = NUM ; double temp = c * m12 - s * m13 ; m13 = s * m12 + c * m13 ; m12 = temp ; for ( int i = NUM ; i < NUM ; i ++ ) { temp = c * r [ i ] [ NUM ] - s * r [ i ] [ NUM ] ; r [ i ] [ NUM ] = s * r [ i ] [ NUM ] + c * r [ i ] [ NUM ] ; r [ i ] [ NUM ] = temp ; } } } int i1 = NUM ; int i2 = NUM ; int i3 = NUM ; int itemp ; double temp ; if ( m11 < m22 ) { temp = m11 ; m11 = m22 ; m22 = temp ; itemp = i1 ; i1 = i2 ; i2 = itemp ; } if ( m22 < m33 ) { temp = m22 ; m22 = m33 ; m33 = temp ; itemp = i2 ; i2 = i3 ; i3 = itemp ; } if ( m11 < m22 ) { temp = m11 ; m11 = m22 ; m22 = temp ; itemp = i1 ; i1 = i2 ; i2 = itemp ; } result 1 . set ( r [ NUM ] [ i1 ] , r [ NUM ] [ i1 ] , r [ NUM ] [ i1 ] ) ; result 2 . set ( r [ NUM ] [ i2 ] , r [ NUM ] [ i2 ] , r [ NUM ] [ i2 ] ) ; result 3 . set ( r [ NUM ] [ i3 ] , r [ NUM ] [ i3 ] , r [ NUM ] [ i3 ] ) ; result 1 . normalize ( ) ; result 2 . normalize ( ) ; result 3 . normalize ( ) ; result 1 . multiply ( m11 ) ; result 2 . multiply ( m22 ) ; result 3 . multiply ( m33 ) ; return BOOL ; }
public static void write Swapped Integer ( Output Stream output , int value ) throws IO Exception { output . write ( ( byte ) ( ( value > > NUM ) & NUM ) ) ; output . write ( ( byte ) ( ( value > > NUM ) & NUM ) ) ; output . write ( ( byte ) ( ( value > > NUM ) & NUM ) ) ; output . write ( ( byte ) ( ( value > > NUM ) & NUM ) ) ; }
public static void queue Column Load ( I Cubic World world , Cube IO loader , int x , int z , Consumer < Column > runnable ) { Queued Column key = new Queued Column ( x , z , world ) ; Async Column IO Provider task = column Tasks . get ( key ) ; if ( task == null ) { task = new Async Column IO Provider ( key , loader ) ; task . add Callback ( runnable ) ; column Tasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . add Callback ( runnable ) ; } }
public double availability ( ) { if ( ! honor Lease ) { return connection . availability ( ) ; } final long now = System . current Time Millis ( ) ; double available = NUM ; if ( number Of Remaining Requests > NUM && ( now < ttl Expiration ) ) { available = NUM ; } return available * connection . availability ( ) ; }
public void start Button Change ( Action Event e ) { fire Property Change Event ( new Property Change Event ( this , STRING , engine started , start button . is Selected ( ) ) ) ; engine started = start button . is Selected ( ) ; }
private synchronized void release Message Id ( int msg Id ) { in Use Msg Ids . remove ( new Integer ( msg Id ) ) ; }
public static synchronized void remove Property Change Listener ( Property Change Listener l ) { if ( listeners . contains ( l ) ) { listeners . remove ( l ) ; } }
public static Request Log copy ( ) { Request Log current = RLOG . get ( ) ; return new Request Log ( current ) ; }
public static String html Decode ( String str ) { if ( str == null ) { return null ; } try { str = URL Decoder . decode ( str , STRING ) ; } catch ( final Throwable e ) { e . print Stack Trace ( ) ; } return Encoding . html Only Decode ( str ) ; }
public void test Then Accept Both source Cancelled ( ) throws Throwable { for ( Execution Mode m : Execution Mode . values ( ) ) for ( boolean may Interrupt If Running : new boolean [ ] { BOOL , BOOL } ) for ( boolean f First : new boolean [ ] { BOOL , BOOL } ) for ( boolean fail First : new boolean [ ] { BOOL , BOOL } ) for ( Integer v1 : new Integer [ ] { NUM , null } ) { final Completable Future < Integer > f = new Completable Future < > ( ) ; final Completable Future < Integer > g = new Completable Future < > ( ) ; final Subtract Action r1 = new Subtract Action ( m ) ; final Subtract Action r2 = new Subtract Action ( m ) ; final Subtract Action r3 = new Subtract Action ( m ) ; final Completable Future < Integer > fst = f First ? f : g ; final Completable Future < Integer > snd = ! f First ? f : g ; final Callable < Boolean > complete 1 = fail First ? null : null ; final Callable < Boolean > complete 2 = fail First ? null : null ; final Completable Future < Void > h1 = m . then Accept Both ( f , g , r1 ) ; assert True ( complete 1 . call ( ) ) ; final Completable Future < Void > h2 = m . then Accept Both ( f , g , r2 ) ; check Incomplete ( h1 ) ; check Incomplete ( h2 ) ; assert True ( complete 2 . call ( ) ) ; final Completable Future < Void > h3 = m . then Accept Both ( f , g , r3 ) ; check Completed With Wrapped Cancellation Exception ( h1 ) ; check Completed With Wrapped Cancellation Exception ( h2 ) ; check Completed With Wrapped Cancellation Exception ( h3 ) ; r1 . assert Not Invoked ( ) ; r2 . assert Not Invoked ( ) ; r3 . assert Not Invoked ( ) ; check Completed Normally ( fail First ? snd : fst , v1 ) ; check Cancelled ( fail First ? fst : snd ) ; } }
final int parse IP Address ( String ip Address Str ) { int result = NUM ; if ( ip Address Str == null ) { throw new Illegal Argument Exception ( ) ; } try { String tmp = ip Address Str ; int offset = NUM ; for ( int i = NUM ; i < NUM ; i ++ ) { int index = tmp . index Of ( STRING ) ; if ( index != - NUM ) { String number Str = tmp . substring ( NUM , index ) ; int number = Integer . parse Int ( number Str ) ; if ( ( number < NUM ) || ( number > NUM ) ) { throw new Illegal Argument Exception ( STRING + ip Address Str + STRING ) ; } result += number << offset ; offset += NUM ; tmp = tmp . substring ( index + NUM ) ; } else { throw new Illegal Argument Exception ( STRING + ip Address Str + STRING ) ; } } if ( tmp . length ( ) > NUM ) { int number = Integer . parse Int ( tmp ) ; if ( ( number < NUM ) || ( number > NUM ) ) { throw new Illegal Argument Exception ( STRING + ip Address Str + STRING ) ; } result += number << offset ; ip Address = result ; } else { throw new Illegal Argument Exception ( STRING + ip Address Str + STRING ) ; } } catch ( No Such Element Exception ex ) { throw new Illegal Argument Exception ( STRING + ip Address Str + STRING , ex ) ; } catch ( Number Format Exception ex ) { throw new Illegal Argument Exception ( STRING + ip Address Str + STRING , ex ) ; } return result ; }
public boolean table Exists Case Sensitive ( Database Meta Data db Meta Data , String table Name ) throws SQL Exception { Result Set rs Tables = db Meta Data . get Tables ( null , null , table Name , null ) ; try { return rs Tables . next ( ) ; } finally { close JDBC Result Set ( rs Tables ) ; } }
public void add All ( Collection < ? extends T > collection ) { if ( m Event Delegate != null ) m Event Delegate . add Data ( collection == null ? NUM : collection . size ( ) ) ; if ( collection != null && collection . size ( ) != NUM ) { synchronized ( m Lock ) { m Objects . add All ( collection ) ; } } int data Count = collection == null ? NUM : collection . size ( ) ; if ( m Observer != null ) m Observer . on Item Range Inserted ( get Count ( ) - data Count + NUM , data Count ) ; if ( m Notify On Change ) notify Item Range Inserted ( headers . size ( ) + get Count ( ) - data Count + NUM , data Count ) ; log ( STRING + ( headers . size ( ) + get Count ( ) - data Count + NUM ) + STRING + ( data Count ) ) ; }
public static void add To Current File List ( String old File Name , String new File Name , String log Name ) { Array List file List = ( Array List ) current File List . get ( PREFIX + log Name ) ; if ( file List == null ) { file List = new Array List ( ) ; } current File List . remove ( PREFIX + log Name ) ; file List . remove ( PREFIX + old File Name ) ; file List . add ( PREFIX + new File Name ) ; if ( ! old File Name . equals ( new File Name ) ) { file List . add ( PREFIX + old File Name ) ; } current File List . put ( PREFIX + log Name , file List ) ; }
J Menu create View Menu ( ) { J Menu view Menu = new J Menu ( STRING ) ; J Menu toolbar Menu = new J Menu ( STRING ) ; toolbar Menu . add ( action Manager . get Show Main Tool Bar Menu Item ( ) ) ; toolbar Menu . add ( action Manager . get Show Run Tool Bar Menu Item ( ) ) ; toolbar Menu . add ( action Manager . get Show Edit Tool Bar Menu Item ( ) ) ; view Menu . add ( toolbar Menu ) ; view Menu . add Separator ( ) ; view Menu . add ( action Manager . get Show Priorities Action ( ) ) ; view Menu . add ( action Manager . get Show Weights Action ( ) ) ; return view Menu ; }
public static synchronized boolean execute ( String sql Statement ) { boolean execute Ok = BOOL ; logger . trace ( String . format ( STRING , sql Statement ) ) ; final Statement S = get Statement ( ) ; if ( S == null ) { logger . error ( STRING ) ; return BOOL ; } try { execute Ok = S . execute ( sql Statement ) ; } catch ( Throwable t ) { surface Throwable ( String . format ( STRING , sql Statement ) , t ) ; } finally { cleanup ( S ) ; } logger . trace ( STRING + execute Ok ) ; return execute Ok ; }
public void write ( byte [ ] buf , int off , int len ) throws IO Exception { output . write ( buf , off , len ) ; bytes Written += len ; }
@ Suppress Warnings ( STRING ) public static String url Encode ( String s ) { try { return URL Encoder . encode ( s , STRING ) ; } catch ( Unsupported Encoding Exception e ) { return URL Encoder . encode ( s ) ; } }
public static void import Expression Types ( final C Connection connection , final int raw Module Id , final int module Id ) throws SQL Exception { final String query = STRING + C Table Names . EXPRESSION TYPES TABLE + STRING + module Id + STRING + STRING + String . format ( C Table Names . RAW EXPRESSION TYPES TABLE , raw Module Id ) ; connection . execute Update ( query , BOOL ) ; }
public static void assume Currency Support ( String ... codes ) { try { for ( String code : codes ) { Currency obj = Currency . get Instance ( code ) ; assert Not Null ( code , obj ) ; } } catch ( Illegal Argument Exception e ) { Assume . assume No Exception ( e ) ; } }
public static float scalb ( final float f , final int n ) { if ( ( n > - NUM ) && ( n < NUM ) ) { return f * Float . int Bits To Float ( ( n + NUM ) << NUM ) ; } if ( Float . is Na N ( f ) || Float . is Infinite ( f ) || ( f == NUM ) ) { return f ; } if ( n < - NUM ) { return ( f > NUM ) ? NUM : - NUM ; } if ( n > NUM ) { return ( f > NUM ) ? Float . POSITIVE INFINITY : Float . NEGATIVE INFINITY ; } final int bits = Float . float To Int Bits ( f ) ; final int sign = bits & NUM ; int exponent = ( bits > > > NUM ) & NUM ; int mantissa = bits & NUM ; int scaled Exponent = exponent + n ; if ( n < NUM ) { if ( scaled Exponent > NUM ) { return Float . int Bits To Float ( sign | ( scaled Exponent << NUM ) | mantissa ) ; } else if ( scaled Exponent > - NUM ) { mantissa |= NUM << NUM ; final int most Significant Lost Bit = mantissa & ( NUM << ( - scaled Exponent ) ) ; mantissa >>>= NUM - scaled Exponent ; if ( most Significant Lost Bit != NUM ) { mantissa ++ ; } return Float . int Bits To Float ( sign | mantissa ) ; } else { return ( sign == NUM ) ? NUM : - NUM ; } } else { if ( exponent == NUM ) { while ( ( mantissa > > > NUM ) != NUM ) { mantissa <<= NUM ; -- scaled Exponent ; } ++ scaled Exponent ; mantissa &= NUM ; if ( scaled Exponent < NUM ) { return Float . int Bits To Float ( sign | ( scaled Exponent << NUM ) | mantissa ) ; } else { return ( sign == NUM ) ? Float . POSITIVE INFINITY : Float . NEGATIVE INFINITY ; } } else if ( scaled Exponent < NUM ) { return Float . int Bits To Float ( sign | ( scaled Exponent << NUM ) | mantissa ) ; } else { return ( sign == NUM ) ? Float . POSITIVE INFINITY : Float . NEGATIVE INFINITY ; } } }
public void show Untrusted Cert Dialog ( Remote Operation Result result ) { Ssl Untrusted Cert Dialog dialog = Ssl Untrusted Cert Dialog . new Instance For Full Ssl Error ( ( Certificate Combined Exception ) result . get Exception ( ) ) ; Fragment Manager fm = get Support Fragment Manager ( ) ; Fragment Transaction ft = fm . begin Transaction ( ) ; dialog . show ( ft , DIALOG UNTRUSTED CERT ) ; }
private void test Jce Availability ( int key Bit Length ) throws Encryption Unsupported By Platform Exception , PDF Parse Exception { final byte [ ] junk Buffer = new byte [ NUM ] ; Arrays . fill ( junk Buffer , ( byte ) NUM ) ; final byte [ ] junk Key = new byte [ get Salted Content Key Byte Length ( key Bit Length / NUM ) ] ; Arrays . fill ( junk Key , ( byte ) NUM ) ; try { create And Initialise Content Cipher ( Byte Buffer . wrap ( junk Buffer ) , junk Key ) ; } catch ( PDF Parse Exception e ) { throw new PDF Parse Exception ( STRING + STRING + e . get Message ( ) ) ; } catch ( No Such Algorithm Exception e ) { throw new Encryption Unsupported By Platform Exception ( STRING , e ) ; } catch ( No Such Padding Exception e ) { throw new Encryption Unsupported By Platform Exception ( STRING , e ) ; } catch ( Invalid Key Exception e ) { throw new Encryption Unsupported By Platform Exception ( STRING + ( get Salted Content Key Byte Length ( ) * NUM ) + STRING , e ) ; } catch ( Invalid Algorithm Parameter Exception e ) { throw new Encryption Unsupported By Platform Exception ( STRING , e ) ; } try { create MD 5 Digest ( ) ; } catch ( No Such Algorithm Exception e ) { throw new Encryption Unsupported By Platform Exception ( STRING , e ) ; } if ( encryption Algorithm != Encryption Algorithm . RC 4 ) { final Cipher rc 4 ; try { rc 4 = create RC 4 Cipher ( ) ; } catch ( General Security Exception e ) { throw new Encryption Unsupported By Platform Exception ( STRING , e ) ; } final byte [ ] rc 4 Junk Key = new byte [ NUM ] ; Arrays . fill ( junk Key , ( byte ) NUM ) ; try { init Decryption ( rc 4 , create RC 4 Key ( rc 4 Junk Key ) ) ; } catch ( Invalid Key Exception ex ) { throw new Encryption Unsupported By Platform Exception ( STRING + STRING , ex ) ; } } }
public static double enlargement ( Spatial Comparable exist , Spatial Comparable addit ) { final int dim = assert Same Dimensionality ( exist , addit ) ; double v1 = NUM ; double v2 = NUM ; for ( int i = NUM ; i < dim ; i ++ ) { final double emin = exist . get Min ( i ) ; final double emax = exist . get Max ( i ) ; final double amin = addit . get Min ( i ) ; final double amax = addit . get Max ( i ) ; final double min = Math . min ( emin , amin ) ; final double max = Math . max ( emax , amax ) ; v1 *= ( max - min ) ; v2 *= ( emax - emin ) ; } return v2 - v1 ; }
public boolean can Get File ( String path ) { return can Get File ( new File ( path ) ) ; }
@ TCB private static int longest Prefix Of Good Codeunits ( String s ) { int n = s . length ( ) , i ; for ( i = NUM ; i < n ; ++ i ) { char ch = s . char At ( i ) ; if ( ch < NUM ) { if ( IS BANNED ASCII [ ch ] ) { return i ; } } else if ( NUM <= ch ) { if ( ch <= NUM ) { if ( i + NUM < n && Character . is Surrogate Pair ( ch , s . char At ( i + NUM ) ) ) { ++ i ; } else { return i ; } } else if ( ( ch & NUM ) == NUM ) { return i ; } } } return - NUM ; }
public static void assert Equals ( String message , List < IO Object > expected , List < IO Object > actual ) { assert Size ( expected , actual ) ; Iterator < IO Object > expected Iter = expected . iterator ( ) ; Iterator < IO Object > actual Iter = actual . iterator ( ) ; int object Index = NUM ; while ( expected Iter . has Next ( ) && actual Iter . has Next ( ) ) { IO Object expected IOO = expected Iter . next ( ) ; IO Object actual IOO = actual Iter . next ( ) ; String sub Message = message + STRING + actual IOO . get Source ( ) + STRING + object Index + STRING ; assert Equals ( sub Message , expected IOO , actual IOO ) ; object Index ++ ; } }
protected static void print Exception Stack ( Throwable th , Print Writer out , int depth ) { boolean print Stack Depth = depth > NUM ; Throwable wrapped Exception = Exception Util . wrapped Exception ( th ) ; if ( wrapped Exception != null ) { print Stack Depth = BOOL ; print Exception Stack ( wrapped Exception , out , depth + NUM ) ; } if ( print Stack Depth ) { out . write ( STRING + depth + STRING ) ; } th . print Stack Trace ( out ) ; }
static String add Prefix If Not Already There ( final String noun , final String prefix Singular , final String prefix Plural ) { if ( noun . starts With ( prefix Singular ) ) { return noun ; } else if ( noun . starts With ( prefix Plural ) ) { return noun ; } else { return prefix Singular + noun ; } }
public void request Password Expiration Warned Time ( ) { operations . add ( Password Policy State Operation Type . GET PASSWORD EXPIRATION WARNED TIME ) ; }
private static Object run J Unit 3 Test ( Class script Class ) { try { Object test Suite = Invoker Helper . invoke Constructor Of ( STRING , new Object [ ] { script Class } ) ; return Invoker Helper . invoke Static Method ( STRING , STRING , new Object [ ] { test Suite } ) ; } catch ( Class Not Found Exception e ) { throw new Groovy Runtime Exception ( STRING , e ) ; } }
public static String pad ( String str , int total Chars ) { if ( str == null ) str = STRING ; int slen = str . length ( ) ; String Builder sb = new String Builder ( str ) ; for ( int i = NUM ; i < total Chars - slen ; i ++ ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
public final boolean exception Show ( String message , Exception exc ) { if ( exc == null ) return BOOL ; String show Msg = exception Expand ( message , exc ) ; J Text Area msg Area = new J Text Area ( show Msg , NUM , NUM ) ; msg Area . set Line Wrap ( BOOL ) ; J Scroll Pane scroll Pane = new J Scroll Pane ( msg Area ) ; if ( Swing Utilities . is Event Dispatch Thread ( ) ) J Option Pane . show Message Dialog ( log Frame , scroll Pane , STRING , J Option Pane . ERROR MESSAGE ) ; else Swing Utilities . invoke Later ( new Swing Show Message ( scroll Pane , J Option Pane . ERROR MESSAGE ) ) ; return BOOL ; }
protected double kernel ( int n , char [ ] s , int end Index S , char [ ] t , int end Index T ) { if ( Math . min ( end Index S + NUM , end Index T + NUM ) < n ) { return get Return Value ( n ) ; } double result = NUM ; for ( int iS = end Index S ; iS > n - NUM ; iS -- ) { double buf = NUM ; char x = s [ iS ] ; for ( int j = NUM ; j <= end Index T ; j ++ ) { if ( t [ j ] == x ) { buf += kernel Helper ( n - NUM , s , iS - NUM , t , j - NUM ) ; } } result += buf * m powers Oflambda [ NUM ] ; } return result ; }
private Connection open Connection ( boolean autocommit ) throws SQL Exception { Connection conn = data Src != null ? data Src . get Connection ( ) : Driver Manager . get Connection ( conn Url , user , passwd ) ; if ( test Mode ) opened . increment ( ) ; conn . set Auto Commit ( autocommit ) ; return conn ; }
protected void sparse To Dense ( ) { if ( ! is Sparse ) { return ; } coordinates = new float [ dimension ] ; for ( int i = NUM ; i < dimension ; ++ i ) { coordinates [ i ] = NUM ; } for ( int i = NUM ; i < sparse Offsets . length ; ++ i ) { coordinates [ Math . abs ( sparse Offsets [ i ] ) - NUM ] = Math . signum ( sparse Offsets [ i ] ) ; } is Sparse = BOOL ; }
public void add Key Listener ( Key Listener l ) { m text Area . add Key Listener ( l ) ; }
public void add Footer View ( View v , Object data , boolean is Selectable ) { Fixed View Info info = new Fixed View Info ( ) ; info . view = v ; info . data = data ; info . is Selectable = is Selectable ; m Footer View Infos . add ( info ) ; if ( m Data Set Observer != null ) { m Data Set Observer . on Changed ( ) ; } }
public JDBC Category Dataset ( String url , String driver Name , String user , String passwd ) throws Class Not Found Exception , SQL Exception { Class . for Name ( driver Name ) ; this . connection = Driver Manager . get Connection ( url , user , passwd ) ; }
protected void put Option ( final Class option Class , final String [ ] names ) { Check . is True ( names . length > NUM , STRING ) ; options To Canonical Names . put ( option Class , names [ NUM ] ) ; for ( int i = NUM ; i < names . length ; i ++ ) { aliases To Options . put ( names [ i ] , option Class ) ; } }
@ Override protected void write Column Auto Increment Stmt ( Table table , Column column , String Builder ddl ) { ddl . append ( STRING ) ; }
public static void restart App ( Activity activity ) { Shared Preferences preferences = Preference Manager . get Default Shared Preferences ( activity ) ; Shared Preferences . Editor editor = preferences . edit ( ) ; if ( ! preferences . get Boolean ( RESTART IN PROGRESS KEY , BOOL ) ) { Common Activity Utils . display Toast ( activity . get Application Context ( ) , STRING ) ; Log . e ( LOG TAG , STRING ) ; editor . put Boolean ( RESTART IN PROGRESS KEY , BOOL ) ; editor . commit ( ) ; Pending Intent m Pending Intent = Pending Intent . get Activity ( activity , NUM , new Intent ( activity , Login Activity . class ) , Pending Intent . FLAG CANCEL CURRENT ) ; Alarm Manager mgr = ( Alarm Manager ) activity . get System Service ( Context . ALARM SERVICE ) ; mgr . set ( Alarm Manager . RTC , System . current Time Millis ( ) + NUM , m Pending Intent ) ; System . exit ( NUM ) ; } else { Log . e ( LOG TAG , STRING ) ; activity . finish ( ) ; } }
private void paint Background ( Graphics 2 D g , J Component c , int x , int y , int width , int height ) { Color color = c . get Background ( ) ; if ( state == Which . BACKGROUND ENABLED ) { color = ( Color ) component Colors [ NUM ] ; } else if ( type == Common Control State . DISABLED ) { color = new Color ( color . get Red ( ) , color . get Green ( ) , color . get Blue ( ) , NUM ) ; } Shape s = shape Generator . create Round Rectangle ( x + NUM , y + NUM , width - NUM , height - NUM , Corner Size . BORDER ) ; g . set Paint ( color ) ; g . fill ( s ) ; if ( is Paint Line Seperators ( c ) ) { paint Line Separator ( g , c , width , height ) ; } }
public static void remove Attribute Choice Values ( String service Name , String schema Type , String attribute Name , Set choice Values , String sub Schema ) throws Upgrade Exception { try { Service Schema ss = get Service Schema ( service Name , sub Schema , schema Type ) ; Attribute Schema attr Schema = ss . get Attribute Schema ( attribute Name ) ; for ( Iterator i = choice Values . iterator ( ) ; i . has Next ( ) ; ) { String choice Value = ( String ) i . next ( ) ; attr Schema . remove Choice Value ( choice Value ) ; } } catch ( SSO Exception ssoe ) { throw new Upgrade Exception ( STRING ) ; } catch ( SMS Exception sme ) { throw new Upgrade Exception ( STRING ) ; } }
private String Builder encode Product ( String Builder tokens ) { List Iterator it = product Tokens . list Iterator ( ) ; while ( it . has Next ( ) ) { tokens . append ( ( String ) it . next ( ) ) ; } return tokens ; }
private boolean ready To Connect ( ) { long now = System . current Time Millis ( ) ; long last Exchange Millis = m Store . get Long ( LAST EXCHANGE TIME KEY , - NUM ) ; boolean time Since Last OK ; if ( last Exchange Millis == - NUM ) { time Since Last OK = BOOL ; } else if ( now - last Exchange Millis < TIME BETWEEN EXCHANGES MILLIS ) { time Since Last OK = BOOL ; } else { time Since Last OK = BOOL ; } if ( ! USE MINIMAL LOGGING ) { log . info ( STRING + ( time Since Last OK && ( get Connecting ( ) == null ) ) ) ; log . info ( STRING + get Connecting ( ) ) ; log . info ( STRING + time Since Last OK ) ; } return time Since Last OK && ( get Connecting ( ) == null ) ; }
public static List < String > find Childrens List ( final File dir , final boolean search Dirs ) { List < String > files = new Array List < > ( ) ; for ( String sub Files : dir . list ( ) ) { File file = new File ( dir + STRING + sub Files ) ; if ( ( search Dirs && file . is Directory ( ) ) || ( ! search Dirs && ! file . is Directory ( ) ) ) { files . add ( file . get Name ( ) ) ; } } return files ; }
private final String decode Short Unicode Name ( int len ) throws IO Exception { int out Ptr = NUM ; char [ ] out Buf = text Buffer . empty And Get Current Segment ( ) ; int in Ptr = input Ptr ; input Ptr += len ; final int [ ] codes = Smile Constants . s Utf 8 Unit Lengths ; final byte [ ] in Buf = input Buffer ; for ( int end = in Ptr + len ; in Ptr < end ; ) { int i = in Buf [ in Ptr ++ ] & NUM ; int code = codes [ i ] ; if ( code != NUM ) { switch ( code ) { case NUM : i = ( ( i & NUM ) << NUM ) | ( in Buf [ in Ptr ++ ] & NUM ) ; break ; case NUM : i = ( ( i & NUM ) << NUM ) | ( ( in Buf [ in Ptr ++ ] & NUM ) << NUM ) | ( in Buf [ in Ptr ++ ] & NUM ) ; break ; case NUM : i = ( ( i & NUM ) << NUM ) | ( ( in Buf [ in Ptr ++ ] & NUM ) << NUM ) | ( ( in Buf [ in Ptr ++ ] & NUM ) << NUM ) | ( in Buf [ in Ptr ++ ] & NUM ) ; i -= NUM ; out Buf [ out Ptr ++ ] = ( char ) ( NUM | ( i > > NUM ) ) ; i = NUM | ( i & NUM ) ; break ; default : report Error ( STRING + Integer . to Hex String ( i ) + STRING ) ; } } out Buf [ out Ptr ++ ] = ( char ) i ; } text Buffer . set Current Length ( out Ptr ) ; return text Buffer . contents As String ( ) ; }
private static Class Node create Usable Class Node From Generics Type ( final Generics Type generics Type ) { Class Node value = generics Type . get Type ( ) ; if ( generics Type . is Placeholder ( ) ) { value = OBJECT TYPE ; } Class Node lower Bound = generics Type . get Lower Bound ( ) ; if ( lower Bound != null ) { value = lower Bound ; } else { Class Node [ ] upper Bounds = generics Type . get Upper Bounds ( ) ; if ( upper Bounds != null ) { value = Widening Categories . lowest Upper Bound ( Arrays . as List ( upper Bounds ) ) ; } } return value ; }
public static String construct Config Name ( String config Name , String Map scope ) { String Builder builder = new String Builder ( ) ; for ( Map . Entry < String , String > entry : scope . entry Set ( ) ) { builder . append ( entry . get Key ( ) ) ; builder . append ( STRING ) ; builder . append ( entry . get Value ( ) ) ; builder . append ( STRING ) ; } builder . append ( config Name ) ; return builder . to String ( ) ; }
public void sort Children By Node ( Comparator < Tree Node < T > > comparator ) { Collections . sort ( children , comparator ) ; for ( Tree Node < T > child : children ) { child . sort Children By Node ( comparator ) ; } }
public static Event Bean [ ] add To Array ( Event Bean [ ] array , Event Bean event To Add ) { Event Bean [ ] new Array = new Event Bean [ array . length + NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , array . length ) ; new Array [ new Array . length - NUM ] = event To Add ; return new Array ; }
public static String replace ( String a , String b , String c ) { String Buffer result = new String Buffer ( c . length ( ) ) ; int i = NUM ; int j = c . index Of ( a ) ; while ( j >= i ) { result . append ( c . substring ( i , j ) ) ; result . append ( b ) ; i = j + a . length ( ) ; j = c . index Of ( a , i ) ; } result . append ( c . substring ( i , c . length ( ) ) ) ; return result . to String ( ) ; }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM ) { final int scroll Y = get Scroll Y ( ) ; int padding Top = get Padding Top ( ) ; int padding Bottom = get Padding Bottom ( ) ; final int height = get Height ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int vgrav = lp . gravity & Gravity . VERTICAL GRAVITY MASK ; int child Top = NUM ; switch ( vgrav ) { default : child Top = padding Top ; break ; case Gravity . TOP : child Top = padding Top ; padding Top += child . get Height ( ) ; break ; case Gravity . CENTER VERTICAL : child Top = Math . max ( ( height - child . get Measured Height ( ) ) / NUM , padding Top ) ; break ; case Gravity . BOTTOM : child Top = height - padding Bottom - child . get Measured Height ( ) ; padding Bottom += child . get Measured Height ( ) ; break ; } child Top += scroll Y ; final int child Offset = child Top - child . get Top ( ) ; if ( child Offset != NUM ) { child . offset Top And Bottom ( child Offset ) ; } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final int scroll Y = get Scroll Y ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Top ( ) - scroll Y ) / get Client Height ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = BOOL ; }
private void reflect Member Variables In Right Button ( ) { final boolean last Page Reached = ( view Pager . get Current Item ( ) + NUM ) == pages . size ( ) ; final boolean button Should Be Invisible = last Page Reached || right Button Disabled ; final boolean button Is Currently Invisible = right Button . get Visibility ( ) == View . INVISIBLE ; final boolean should Update Button = button Should Be Invisible != button Is Currently Invisible ; if ( should Update Button ) { final Animator button Animator = button Should Be Invisible ? button Animator Factory . new Right Button Disappear Animator ( right Button ) : button Animator Factory . new Right Button Appear Animator ( right Button ) ; if ( button Should Be Invisible ) { disable Button ( button Animator , right Button ) ; } else { enable Button ( button Animator , right Button ) ; } } }
public void test Decoder 5 ( ) { boolean res ; String original App Id Name = m App Id Name ; int original Content Type Value = m Content Type Value ; Random rd = new Random ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { m App Id Value = rd . next Int ( NUM ) ; m Content Type Value = rd . next Int ( NUM ) ; byte [ ] pdu = create PDU ( NUM ) ; Wsp Type Decoder pdu Decoder = new Wsp Type Decoder ( pdu ) ; res = pdu Decoder . seek X Wap Application Id ( m Wsp Header Start , m Wsp Header Start + m Wsp Header Len - NUM ) ; assert True ( res ) ; int index = ( int ) pdu Decoder . get Value 32 ( ) ; res = pdu Decoder . decode X Wap Application Id ( index ) ; assert True ( res ) ; Log . d ( LOG TAG , STRING + m App Id Name + STRING + pdu Decoder . get Value String ( ) + STRING ) ; assert True ( m App Id Name . equals ( pdu Decoder . get Value String ( ) ) ) ; } m App Id Name = original App Id Name ; m Content Type Value = original Content Type Value ; }
public static boolean is Writable ( @ Non Null final File file ) { boolean is Existing = file . exists ( ) ; try { File Output Stream output = new File Output Stream ( file , BOOL ) ; try { output . close ( ) ; } catch ( IO Exception e ) { } } catch ( File Not Found Exception e ) { if ( ! file . is Directory ( ) ) { return BOOL ; } } boolean result = file . can Write ( ) ; if ( ! is Existing ) { file . delete ( ) ; } return result ; }
@ Suppress Warnings ( STRING ) private void refresh Exp Group Metadata List ( boolean force Children Count Refresh , boolean sync Group Positions ) { final Array List < Group Metadata > egml = m Exp Group Metadata List ; int egml Size = egml . size ( ) ; int cur Fl Pos = NUM ; m Total Exp Children Count = NUM ; if ( sync Group Positions ) { boolean positions Changed = BOOL ; for ( int i = egml Size - NUM ; i >= NUM ; i -- ) { Group Metadata cur Gm = egml . get ( i ) ; int new G Pos = find Group Position ( cur Gm . g Id , cur Gm . g Pos ) ; if ( new G Pos != cur Gm . g Pos ) { if ( new G Pos == android . widget . Adapter View . INVALID POSITION ) { egml . remove ( i ) ; egml Size -- ; } cur Gm . g Pos = new G Pos ; if ( ! positions Changed ) positions Changed = BOOL ; } } if ( positions Changed ) { Collections . sort ( egml ) ; } } int g Children Count ; int last G Pos = NUM ; for ( int i = NUM ; i < egml Size ; i ++ ) { Group Metadata cur Gm = egml . get ( i ) ; if ( ( cur Gm . last Child Fl Pos == Group Metadata . REFRESH ) || force Children Count Refresh ) { g Children Count = m Expandable List Adapter . get Children Count ( cur Gm . g Pos ) ; } else { g Children Count = cur Gm . last Child Fl Pos - cur Gm . fl Pos ; } m Total Exp Children Count += g Children Count ; cur Fl Pos += ( cur Gm . g Pos - last G Pos ) ; last G Pos = cur Gm . g Pos ; cur Gm . fl Pos = cur Fl Pos ; cur Fl Pos += g Children Count ; cur Gm . last Child Fl Pos = cur Fl Pos ; } }
public Cas Idm Accessor ( Cas Idm Client idm Client ) { logger . debug ( STRING ) ; Validate . not Null ( idm Client ) ; client = idm Client ; }
public void rotate X ( double theta ) { Matrix 3 D tmp = new Matrix 3 D ( ) ; double c = Math . cos ( theta ) ; double s = Math . sin ( theta ) ; tmp . set ( NUM , NUM , c ) ; tmp . set ( NUM , NUM , - s ) ; tmp . set ( NUM , NUM , s ) ; tmp . set ( NUM , NUM , c ) ; pre Multiply ( tmp ) ; }
public Service Host start Factory ( Class < ? extends Service > inst Service Class , Supplier < Factory Service > factory Creator ) { URI factory Uri = Uri Utils . build Factory Uri ( this , inst Service Class ) ; return start Factory ( factory Creator , factory Uri . get Path ( ) ) ; }
private void wake In ( ) { State In Pipe state Old ; State In Pipe state New ; do { state Old = state In Ref . get ( ) ; if ( state Old . is Active ( ) ) { return ; } state New = state Old . to Wake ( ) ; } while ( ! state In Ref . compare And Set ( state Old , state New ) ) ; if ( state Old == State In Pipe . IDLE ) { try ( Outbox Amp outbox = Outbox Amp . current Or Create ( services ) ) { Objects . require Non Null ( outbox ) ; Pipe Wake In Message < T > msg = new Pipe Wake In Message < > ( outbox , in Ref , this ) ; outbox . offer ( msg ) ; } } }
protected Set < F Is A > create Initial Assignment Constraints ( final Annotated Type Mirror assigned To , final Annotated Type Mirror boxed Return Type , final Annotated Type Factory type Factory , final Set < Type Variable > targets ) { final Set < F Is A > result = new Linked Hash Set < > ( ) ; if ( assigned To != null ) { final Set < AF Constraint > reduced Constraints = new Linked Hash Set < > ( ) ; final Queue < AF Constraint > constraints = new Linked List < > ( ) ; constraints . add ( new F2 A ( boxed Return Type , assigned To ) ) ; reduce Af Constraints ( type Factory , reduced Constraints , constraints , targets ) ; for ( final AF Constraint reduced Constraint : reduced Constraints ) { if ( reduced Constraint instanceof F Is A ) { result . add ( ( F Is A ) reduced Constraint ) ; } } } return result ; }
public synchronized void mark Used ( long pos , int length ) { int start = get Block ( pos ) ; int blocks = get Block Count ( length ) ; Block Range x = new Block Range ( start , blocks ) ; Block Range prev = free Space . floor ( x ) ; if ( prev == null ) { throw Data Utils . new Illegal State Exception ( Data Utils . ERROR INTERNAL , STRING ) ; } if ( prev . start == start ) { if ( prev . blocks == blocks ) { free Space . remove ( prev ) ; } else { prev . start += blocks ; prev . blocks -= blocks ; } } else if ( prev . start + prev . blocks == start + blocks ) { prev . blocks -= blocks ; } else { x . start = start + blocks ; x . blocks = prev . start + prev . blocks - x . start ; free Space . add ( x ) ; prev . blocks = start - prev . start ; } }
private static Topic Partition register Consumer To Specific Partition ( Kafka Consumer < String , String > consumer , String topic , int partition ) { Topic Partition topic Partition = new Topic Partition ( topic , partition ) ; List < Topic Partition > partitions = Arrays . as List ( topic Partition ) ; consumer . assign ( partitions ) ; return topic Partition ; }
private static int parse Or 0 ( Matcher m , String group ) { String matched = m . group ( group ) ; if ( matched == null ) { return NUM ; } return parse Int ( matched ) ; }
private Pla Line Int smoothen corner ( Pla Line Int Alist p line arr , int p start no ) { if ( p line arr . size ( ) - p start no < NUM ) return null ; Pla Line Int cur line = p line arr . get ( p start no ) ; Pla Line Int a line = p line arr . get ( p start no + NUM ) ; Pla Line Int b line = p line arr . get ( p start no + NUM ) ; Pla Line Int d line = p line arr . get ( p start no + NUM ) ; Pla Point Float curr corner = a line . intersection approx ( b line ) ; if ( curr corner . is Na N ( ) ) return null ; double cosinus angle = a line . cos angle ( b line ) ; if ( cosinus angle > COS ANGLE MAX ) return null ; Pla Point Float prev corner = cur line . intersection approx ( a line ) ; if ( prev corner . is Na N ( ) ) return null ; Pla Point Float next corner = b line . intersection approx ( d line ) ; if ( next corner . is Na N ( ) ) return null ; Pla Direction prev dir = a line . direction ( ) ; Pla Direction next dir = b line . direction ( ) ; Pla Direction middle dir = prev dir . middle approx ( next dir ) ; Pla Line Int translate line = new Pla Line Int ( curr corner . round ( ) , middle dir ) ; double prev dist = translate line . distance signed ( prev corner ) ; double next dist = translate line . distance signed ( next corner ) ; Pla Point Float nearest point ; double max translate dist ; if ( Math . abs ( prev dist ) < Math . abs ( next dist ) ) { nearest point = prev corner ; max translate dist = prev dist ; } else { nearest point = next corner ; max translate dist = next dist ; } if ( Math . abs ( max translate dist ) < NUM ) return null ; Pla Line Int Alist curr lines = new Pla Line Int Alist ( p line arr . size ( NUM ) ) ; p line arr . append to ( curr lines , NUM ) ; curr lines . add null ( p start no + NUM ) ; double translate dist = max translate dist ; double delta dist = max translate dist ; Pla Side side of nearest point = translate line . side of ( nearest point ) ; int sign = Signum . as int ( max translate dist ) ; Pla Line Int result = null ; while ( Math . abs ( delta dist ) > min move dist ) { boolean check ok = BOOL ; Pla Line Int new line = translate line . translate ( - translate dist ) ; Pla Side new line side of nearest point = new line . side of ( nearest point ) ; if ( new line side of nearest point == side of nearest point || new line side of nearest point == Pla Side . COLLINEAR ) { curr lines . set ( p start no + NUM , new line ) ; Polyline tmp = new Polyline ( curr lines ) ; if ( tmp . plaline len ( ) == curr lines . size ( ) ) { Shape Tile shape to check = tmp . offset shape ( curr half width , p start no + NUM ) ; check ok = r board . check trace ( shape to check , curr layer , curr net no arr , curr cl type , contact pins ) ; } delta dist /= NUM ; if ( check ok ) { result = new line ; if ( translate dist == max translate dist ) { break ; } translate dist += delta dist ; } else { translate dist -= delta dist ; } } else { double shorten value = sign * NUM ; max translate dist -= shorten value ; translate dist -= shorten value ; delta dist -= shorten value ; } } if ( result == null ) return null ; curr lines . changed area join corner ( r board . changed area , p start no , curr layer ) ; curr lines . changed area join corner ( r board . changed area , p start no + NUM , curr layer ) ; return result ; }
@ Override @ Suppress Warnings ( STRING ) public Object execute Command ( final int command ID , final Object [ ] args ) { if ( ! is Setup ) { throw new Runtime Exception ( STRING ) ; } return current Commands . execute Command ( command ID , args ) ; }
@ Suppress Warnings ( { STRING , STRING } ) public static int calculate Max Bitmap Size ( @ Non Null Context context ) { Window Manager wm = ( Window Manager ) context . get System Service ( Context . WINDOW SERVICE ) ; Display display = wm . get Default Display ( ) ; Point size = new Point ( ) ; int width , height ; if ( Build . VERSION . SDK INT >= Build . VERSION CODES . HONEYCOMB MR 2 ) { display . get Size ( size ) ; width = size . x ; height = size . y ; } else { width = display . get Width ( ) ; height = display . get Height ( ) ; } int screen Diagonal = ( int ) Math . sqrt ( Math . pow ( width , NUM ) + Math . pow ( height , NUM ) ) ; Canvas canvas = new Canvas ( ) ; return Math . min ( screen Diagonal * NUM , Math . min ( canvas . get Maximum Bitmap Width ( ) , canvas . get Maximum Bitmap Height ( ) ) ) ; }
public void add Tele Missile Attack ( Attack Action ea ) { pending Tele Missile Attacks . add Element ( ea ) ; process Game Event ( new Game New Action Event ( this , ea ) ) ; }
public void test Overwrite With Tokens ( ) throws Exception { File config Home = new File ( configuration . get Home ( ) ) ; assert True ( STRING , config Home . exists ( ) && config Home . is Directory ( ) ) ; File existing File = create File ( config Home , STRING , STRING ) ; assert Equals ( STRING , read File ( existing File ) ) ; String file Name = STRING ; String file Contents = STRING ; File file 1 = create File ( config File Directory , file Name , file Contents ) ; File Config config File = new File Config ( ) ; config File . set File ( get Absolute Path ( file 1 ) ) ; config File . set To File ( STRING ) ; config File . set Overwrite ( STRING ) ; config File . set Configfile ( STRING ) ; configuration . set Property ( STRING , STRING ) ; test Copy ( config File , STRING , STRING ) ; assert Equals ( STRING , read File ( existing File ) ) ; }
public void init ( ) { int len = Constants . FILE BLOCK SIZE ; byte [ ] salt ; byte [ ] magic = HEADER . get Bytes ( Constants . UTF 8 ) ; if ( length ( ) < HEADER LENGTH ) { checked Writing = BOOL ; write Direct ( magic , NUM , len ) ; salt = generate Salt ( ) ; write Direct ( salt , NUM , len ) ; init Key ( salt ) ; write ( magic , NUM , len ) ; checked Writing = BOOL ; } else { seek ( NUM ) ; byte [ ] buff = new byte [ len ] ; read Fully Direct ( buff , NUM , len ) ; if ( ! Arrays . equals ( buff , magic ) ) { throw Db Exception . get ( Error Code . FILE VERSION ERROR 1 , name ) ; } salt = new byte [ len ] ; read Fully Direct ( salt , NUM , len ) ; init Key ( salt ) ; read Fully ( buff , NUM , Constants . FILE BLOCK SIZE ) ; if ( ! Arrays . equals ( buff , magic ) ) { throw Db Exception . get ( Error Code . FILE ENCRYPTION ERROR 1 , name ) ; } } }
public void add Listener ( final Trainer Listener trainer Listener ) { if ( listeners == null ) { listeners = new Array List < Trainer Listener > ( ) ; } listeners . add ( trainer Listener ) ; }
private static void replace Tuple Variables ( Hash Map < String , String > var Changes , Tuple Expr tuple , Map < String , Value > val Map ) throws Exception { Tuple Var Renamer visitor = new Tuple Var Renamer ( var Changes , val Map ) ; tuple . visit ( visitor ) ; }
public void test Sub List And Non Structural Changes ( ) { Copy On Write Array List < String > list = new Copy On Write Array List < String > ( ) ; list . add All ( Arrays . as List ( STRING , STRING , STRING , STRING , STRING ) ) ; List < String > bcd = list . sub List ( NUM , NUM ) ; list . set ( NUM , STRING ) ; try { bcd . get ( NUM ) ; fail ( ) ; } catch ( Concurrent Modification Exception expected ) { } }
public void add Message ( Message message ) { messages . add ( message . render Text View ( context ) ) ; if ( messages . size ( ) > history Size ) { messages . remove ( NUM ) ; } notify Data Set Changed ( ) ; }
@ Override public boolean on Schedule ( Packing Plan packing ) { LOG . info ( STRING + Local Context . topology Name ( config ) ) ; synchronized ( process To Container ) { LOG . info ( STRING ) ; start Executor ( NUM ) ; for ( Packing Plan . Container Plan container : packing . get Containers ( ) ) { start Executor ( container . get Id ( ) ) ; } } LOG . info ( STRING ) ; return BOOL ; }
public static Date string To Date ( String strdate , @ Suppress Warnings ( STRING ) String format ) { Date date = null ; Simple Date Format formatter = new Simple Date Format ( format ) ; try { date = formatter . parse ( strdate ) ; } catch ( Parse Exception e ) { e . print Stack Trace ( ) ; } return date ; }
public void load All Images ( Component comp , Media Tracker tracker ) { for ( Iterator < Hex Entry > i = bases . iterator ( ) ; i . has Next ( ) ; ) { Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , NUM ) ; } for ( Iterator < Hex Entry > i = supers . iterator ( ) ; i . has Next ( ) ; ) { Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , NUM ) ; } for ( Iterator < Hex Entry > i = ortho . iterator ( ) ; i . has Next ( ) ; ) { Hex Entry entry = i . next ( ) ; if ( entry . get Image ( ) == null ) { entry . load Image ( comp ) ; } tracker . add Image ( entry . get Image ( ) , NUM ) ; } }
@ Override public synchronized Extension install ( URL url ) throws Invalid Config Exception { Preconditions . check Not Null ( url ) ; try { File tmp File = download ( url ) ; Extension extension = load From File ( tmp File ) ; finish Install ( tmp File , extension ) ; return extension ; } catch ( Invalid Config Exception e ) { throw e ; } catch ( Exception e ) { String msg = base Action . get Text ( STRING , new String [ ] { url . to String ( ) } ) ; log . error ( msg , e ) ; throw new Invalid Config Exception ( TYPE . INVALID EXTENSION , msg , e ) ; } }
public int read ( char [ ] cbuf , int off , int len ) throws IO Exception { int num = NUM ; int val ; if ( bo == STRING ) { while ( num < len ) { if ( ( val = is . read ( ) ) < NUM ) { return ( num != NUM ) ? num : - NUM ; } cbuf [ off ++ ] = ( char ) ( ( val << NUM ) | ( is . read ( ) & NUM ) ) ; num ++ ; } } else { while ( num < len ) { if ( ( val = is . read ( ) ) < NUM ) { return ( num != NUM ) ? num : - NUM ; } cbuf [ off ++ ] = ( char ) ( ( is . read ( ) << NUM ) | ( val & NUM ) ) ; num ++ ; } } return num ; }
Compilation Unit Completion ( I Compilation Unit unit ) { reset ( unit ) ; set Ignored ( Completion Proposal . ANONYMOUS CLASS DECLARATION , BOOL ) ; set Ignored ( Completion Proposal . ANONYMOUS CLASS CONSTRUCTOR INVOCATION , BOOL ) ; set Ignored ( Completion Proposal . KEYWORD , BOOL ) ; set Ignored ( Completion Proposal . LABEL REF , BOOL ) ; set Ignored ( Completion Proposal . METHOD DECLARATION , BOOL ) ; set Ignored ( Completion Proposal . METHOD NAME REFERENCE , BOOL ) ; set Ignored ( Completion Proposal . METHOD REF , BOOL ) ; set Ignored ( Completion Proposal . CONSTRUCTOR INVOCATION , BOOL ) ; set Ignored ( Completion Proposal . METHOD REF WITH CASTED RECEIVER , BOOL ) ; set Ignored ( Completion Proposal . PACKAGE REF , BOOL ) ; set Ignored ( Completion Proposal . POTENTIAL METHOD DECLARATION , BOOL ) ; set Ignored ( Completion Proposal . VARIABLE DECLARATION , BOOL ) ; set Ignored ( Completion Proposal . TYPE REF , BOOL ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private boolean has Proxy Settings ( Properties settings ) { String proxy Host = settings . get Property ( STRING , null ) ; return proxy Host != null && proxy Host . length ( ) > NUM ; }
public static void verify Getter Methods ( Class < ? > clazz , Mapped Field ... fields ) { for ( Mapped Field field : fields ) { String field Name = field . get Name ( ) ; Class < ? > field Type = field . get Type ( ) ; String custom Get = field . get Method ( ) ; if ( ! is Null ( custom Get ) && ! custom Get . equals ( Constants . DEFAULT ACCESSOR VALUE ) ) try { clazz . get Method ( custom Get ) ; continue ; } catch ( Exception e ) { Error . custom Method ( STRING , custom Get , clazz ) ; } String method Name = get Method ( field Type , field Name ) ; try { clazz . get Method ( method Name ) ; } catch ( Exception e ) { if ( ! is Boolean ( field Type ) ) Error . method ( method Name , field Name , clazz ) ; try { method Name = ( m Get ( field Name ) ) ; clazz . get Method ( method Name ) ; } catch ( Exception e1 ) { Error . method ( method Name , field Name , clazz ) ; } } field . get Method ( method Name ) ; } }
public String random Positive Float ( Object owhole , Object odecimal ) { int whole = Function Handler . get Int ( owhole ) ; int decimal = Function Handler . get Int ( odecimal ) ; String Builder output = new String Builder ( ) ; output . append ( rnd . next Int ( NUM ) + NUM ) ; for ( int i = NUM ; i < whole - NUM ; i ++ ) { output . append ( rnd . next Int ( NUM ) ) ; } output . append ( STRING ) ; for ( int i = NUM ; i < decimal ; i ++ ) { output . append ( rnd . next Int ( NUM ) ) ; } return output . to String ( ) ; }
private static Pair < String , byte [ ] > parse Esds From Parent ( Parsable Byte Array parent , int position ) { parent . set Position ( position + Atom . HEADER SIZE + NUM ) ; parent . skip Bytes ( NUM ) ; int var Int Byte = parent . read Unsigned Byte ( ) ; while ( var Int Byte > NUM ) { var Int Byte = parent . read Unsigned Byte ( ) ; } parent . skip Bytes ( NUM ) ; int flags = parent . read Unsigned Byte ( ) ; if ( ( flags & NUM ) != NUM ) { parent . skip Bytes ( NUM ) ; } if ( ( flags & NUM ) != NUM ) { parent . skip Bytes ( parent . read Unsigned Short ( ) ) ; } if ( ( flags & NUM ) != NUM ) { parent . skip Bytes ( NUM ) ; } parent . skip Bytes ( NUM ) ; var Int Byte = parent . read Unsigned Byte ( ) ; while ( var Int Byte > NUM ) { var Int Byte = parent . read Unsigned Byte ( ) ; } int object Type Indication = parent . read Unsigned Byte ( ) ; String mime Type ; switch ( object Type Indication ) { case NUM : mime Type = Mime Types . AUDIO MPEG ; return Pair . create ( mime Type , null ) ; case NUM : mime Type = Mime Types . VIDEO MP 4 V ; break ; case NUM : mime Type = Mime Types . VIDEO H264 ; break ; case NUM : mime Type = Mime Types . VIDEO H265 ; break ; case NUM : case NUM : case NUM : case NUM : mime Type = Mime Types . AUDIO AAC ; break ; case NUM : mime Type = Mime Types . AUDIO AC 3 ; break ; case NUM : mime Type = Mime Types . AUDIO EC 3 ; break ; case NUM : case NUM : mime Type = Mime Types . AUDIO DTS ; return Pair . create ( mime Type , null ) ; case NUM : case NUM : mime Type = Mime Types . AUDIO DTS HD ; return Pair . create ( mime Type , null ) ; default : mime Type = null ; break ; } parent . skip Bytes ( NUM ) ; parent . skip Bytes ( NUM ) ; var Int Byte = parent . read Unsigned Byte ( ) ; int var Int = var Int Byte & NUM ; while ( var Int Byte > NUM ) { var Int Byte = parent . read Unsigned Byte ( ) ; var Int = var Int << NUM ; var Int |= var Int Byte & NUM ; } byte [ ] initialization Data = new byte [ var Int ] ; parent . read Bytes ( initialization Data , NUM , var Int ) ; return Pair . create ( mime Type , initialization Data ) ; }
private void update Field Options ( ) { String current Text = field Box . get Text ( ) ; List < String > fields = influx Service . get Fields ( measurement Box . get Text ( ) ) ; if ( null != fields ) { field Box . set Items ( fields . to Array ( new String [ fields . size ( ) ] ) ) ; } field Box . set Text ( current Text ) ; }
public I Device learn Entity ( long mac Address , Short vlan , Integer ipv 4 Address , Long switch DPID , Integer switch Port , boolean process Updates ) { List < I Device Listener > listeners = device Listeners . get Ordered Listeners ( ) ; if ( ! process Updates ) { device Listeners . clear Listeners ( ) ; } Vlan Vid v ; I Pv 4 Address i ; Datapath Id d ; OF Port p ; if ( vlan != null && vlan . short Value ( ) <= NUM ) vlan = null ; if ( ipv 4 Address != null && ipv 4 Address == NUM ) ipv 4 Address = null ; if ( vlan == null ) { v = Vlan Vid . of Vlan ( - NUM ) ; } else { v = Vlan Vid . of Vlan ( vlan ) ; } if ( ipv 4 Address == null ) { i = I Pv 4 Address . NONE ; } else { i = I Pv 4 Address . of ( ipv 4 Address ) ; } if ( switch DPID == null ) { d = Datapath Id . of ( NUM ) ; } else { d = Datapath Id . of ( switch DPID . long Value ( ) ) ; } if ( switch Port == null ) { p = OF Port . ZERO ; } else { p = OF Port . of ( switch Port ) ; } I Device res = learn Device By Entity ( new Entity ( Mac Address . of ( mac Address ) , v , i , d , p , new Date ( ) ) ) ; if ( listeners != null ) { for ( I Device Listener listener : listeners ) { device Listeners . add Listener ( STRING , listener ) ; } } return res ; }
public static String read String ( Byte Buffer buffer , boolean utf 8 ) { if ( utf 8 ) { read Len ( buffer ) ; int bytes Len = read Len ( buffer ) ; byte [ ] bytes = Buffers . read Bytes ( buffer , bytes Len ) ; String str = new String ( bytes , CHARSET UTF 8 ) ; Buffers . read U Byte ( buffer ) ; return str ; } else { int str Len = read Len 16 ( buffer ) ; String str = Buffers . read String ( buffer , str Len ) ; Buffers . read U Short ( buffer ) ; return str ; } }
public String show Switch Wwn ( ) throws Network Device Controller Exception { SSH Prompt [ ] prompts = { SSH Prompt . POUND , SSH Prompt . GREATER THAN , SSH Prompt . MDS CONFIG , SSH Prompt . MDS CONFIG IVR ZONE , SSH Prompt . MDS CONFIG IVR ZONESET } ; String Builder buf = new String Builder ( ) ; send Wait For ( MDS Dialog Properties . get String ( STRING ) , default Timeout , prompts , buf ) ; String [ ] lines = get Lines ( buf ) ; String [ ] regex = { MDS Dialog Properties . get String ( STRING ) } ; String switch Wwn = null ; String [ ] groups = new String [ NUM ] ; for ( String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case NUM : switch Wwn = groups [ NUM ] ; break ; } if ( switch Wwn != null ) { break ; } } return switch Wwn ; }
public static String [ ] split ( String string , char c ) { if ( count Matches ( string , c ) <= NUM ) return new String [ ] { string } ; String s = string + c ; String [ ] sa = new String [ count Matches ( string , c ) + NUM ] ; String Builder sb = new String Builder ( ) ; char [ ] ca = s . to Char Array ( ) ; int n = NUM , x ; for ( x = NUM ; x < ca . length ; x ++ ) { if ( ca [ x ] == c ) { sa [ n ] = sb . to String ( ) ; sb = new String Builder ( ) ; n ++ ; } else { sb . append ( ca [ x ] ) ; } } return sa ; }
private Image Icon add Space To Icon ( Image Icon icon ) { int width = icon . get Icon Width ( ) ; int height = icon . get Icon Height ( ) ; int hspace = NUM ; Buffered Image res = new Buffered Image ( width + hspace , height , Buffered Image . TYPE INT ARGB ) ; Graphics g = res . get Graphics ( ) ; g . draw Image ( icon . get Image ( ) , NUM , NUM , null ) ; g . dispose ( ) ; return new Image Icon ( res ) ; }
public static byte [ ] read All ( Input Stream in Str ) throws IO Exception { Byte Array Output Stream buf = new Byte Array Output Stream ( ) ; pipe All ( in Str , buf ) ; return buf . to Byte Array ( ) ; }
public static boolean starts With Ignore Case ( String search In , int start At , String search For ) { return search In . region Matches ( BOOL , start At , search For , NUM , search For . length ( ) ) ; }
protected Ignite start Remote Grid ( String grid Name , Ignite Configuration cfg , Grid Spring Resource Context ctx ) throws Exception { if ( ctx != null ) throw new Unsupported Operation Exception ( STRING ) ; if ( cfg == null ) cfg = optimize ( get Configuration ( grid Name ) ) ; return new Ignite Process Proxy ( cfg , log , grid ( NUM ) ) ; }
public void execute Command ( String shell Cmd ) { if ( m Thread != null && m Thread . is Alive ( ) ) { m Shell Thread . stop ( ) ; m Results = new String Builder ( ) ; } m Current Command = shell Cmd ; m Shell Thread = new Shell Thread ( ) ; m Thread = new Thread ( m Shell Thread ) ; m Thread . start ( ) ; }
@ Override public Env Var add New Env Var ( String name , Class < ? > type , String value ) { Env Var env Var = null ; if ( ! exist ( name ) ) { env Var = new Env Var ( name , type , BOOL ) ; env Var . set Value ( value ) ; env Var List . add ( env Var ) ; } return env Var ; }
static private String calc Threshold ( double score Threshold , double lambda ) { final double log Prob Threshold = Math . log ( NUM - score Threshold / NUM ) ; int max Num = NUM ; if ( calc Log Prob ( max Num , BOOL , lambda ) > log Prob Threshold ) { return STRING ; } int min Num = NUM ; while ( min Num < max Num ) { final int mid Num = ( max Num + min Num ) / NUM ; final boolean pass Threshold = calc Log Prob ( mid Num , BOOL , lambda ) <= log Prob Threshold ; if ( pass Threshold ) { max Num = mid Num ; } else { if ( mid Num == min Num ) { break ; } min Num = mid Num ; } } return Integer . to String ( max Num ) ; }
public static int index Of Last Separator ( String filename ) { if ( filename == null ) { return - NUM ; } int last Unix Pos = filename . last Index Of ( UNIX SEPARATOR ) ; int last Windows Pos = filename . last Index Of ( WINDOWS SEPARATOR ) ; return Math . max ( last Unix Pos , last Windows Pos ) ; }
@ Category ( Flaky Test . class ) @ Test public void test Put Validate Data On Member Primary Secondary Datastore ( ) { member 1 . invoke ( null ) ; Fixed Partition Attributes fpa 1 = Fixed Partition Attributes . create Fixed Partition ( Quarter 1 , BOOL , NUM ) ; Fixed Partition Attributes fpa 2 = Fixed Partition Attributes . create Fixed Partition ( Quarter 2 , BOOL , NUM ) ; List < Fixed Partition Attributes > fpa List = new Array List < Fixed Partition Attributes > ( ) ; fpa List . add ( fpa 1 ) ; fpa List . add ( fpa 2 ) ; member 1 . invoke ( null ) ; member 2 . invoke ( null ) ; fpa 1 = Fixed Partition Attributes . create Fixed Partition ( Quarter 2 , BOOL , NUM ) ; fpa 2 = Fixed Partition Attributes . create Fixed Partition ( Quarter 3 , BOOL , NUM ) ; fpa List . clear ( ) ; fpa List . add ( fpa 1 ) ; fpa List . add ( fpa 2 ) ; member 2 . invoke ( null ) ; member 3 . invoke ( null ) ; fpa 1 = Fixed Partition Attributes . create Fixed Partition ( Quarter 3 , BOOL , NUM ) ; fpa 2 = Fixed Partition Attributes . create Fixed Partition ( Quarter 4 , BOOL , NUM ) ; fpa List . clear ( ) ; fpa List . add ( fpa 1 ) ; fpa List . add ( fpa 2 ) ; member 3 . invoke ( null ) ; member 4 . invoke ( null ) ; fpa 1 = Fixed Partition Attributes . create Fixed Partition ( Quarter 4 , BOOL , NUM ) ; fpa 2 = Fixed Partition Attributes . create Fixed Partition ( Quarter 1 , BOOL , NUM ) ; fpa List . clear ( ) ; fpa List . add ( fpa 1 ) ; fpa List . add ( fpa 2 ) ; member 4 . invoke ( null ) ; member 1 . invoke ( null ) ; member 1 . invoke ( null ) ; member 2 . invoke ( null ) ; member 3 . invoke ( null ) ; member 4 . invoke ( null ) ; member 1 . invoke ( null ) ; member 2 . invoke ( null ) ; member 3 . invoke ( null ) ; member 4 . invoke ( null ) ; }
public List < Node > list Available Crossover Nodes ( Node node , Class < ? > type ) { List < Node > result = new Array List < Node > ( ) ; if ( type . is Assignable From ( node . get Return Type ( ) ) ) { result . add ( node ) ; } for ( int i = NUM ; i < node . get Number Of Arguments ( ) ; i ++ ) { result . add All ( list Available Crossover Nodes ( node . get Argument ( i ) , type ) ) ; } return result ; }
public void delete Export ( String id , String zone Name ) throws Isilon Exception { String uri With Zone Name = get URI With Zone Name ( id , zone Name ) ; delete ( base Url . resolve ( URI NFS EXPORTS ) , uri With Zone Name , STRING ) ; }
public static Map < String , String > add Auth Header ( String username , String password , Map < String , String > params ) { String creds = String . format ( STRING , username , password ) ; String encoded = Base 64 . encode To String ( creds . get Bytes ( ) , Base 64 . NO WRAP ) ; params . put ( STRING , STRING + encoded ) ; return params ; }
void update Visibility Model ( ) { Component c = get Container ( ) ; if ( c instanceof J Text Field ) { J Text Field field = ( J Text Field ) c ; Bounded Range Model vis = field . get Horizontal Visibility ( ) ; int hspan = ( int ) get Preferred Span ( X AXIS ) ; int extent = vis . get Extent ( ) ; int maximum = Math . max ( hspan , extent ) ; extent = ( extent == NUM ) ? maximum : extent ; int value = maximum - extent ; int old Value = vis . get Value ( ) ; if ( ( old Value + extent ) > maximum ) { old Value = maximum - extent ; } value = Math . max ( NUM , Math . min ( value , old Value ) ) ; vis . set Range Properties ( value , extent , NUM , maximum , BOOL ) ; } }
protected void restore Blob Into Memory ( ) throws Cache Exception { String cache File Path And Name = get Cache File Path And Name ( ) ; long begin = LOG . is Trace Enabled ( ) ? System . current Time Millis ( ) : NUM ; if ( LOG . is Trace Enabled ( ) ) LOG . trace ( STRING + get Var Name ( ) + STRING + ( hdfs File Name == null ? STRING : hdfs File Name ) + STRING + cache File Path And Name ) ; if ( data != null ) throw new Cache Exception ( cache File Path And Name + STRING ) ; try { data = read Blob From Cache ( cache File Path And Name ) ; } catch ( IO Exception e ) { throw new Cache Exception ( cache File Path And Name + STRING , e ) ; } if ( data == null ) throw new Cache Exception ( cache File Path And Name + STRING ) ; if ( LOG . is Trace Enabled ( ) ) LOG . trace ( STRING + ( System . current Time Millis ( ) - begin ) + STRING ) ; }
public static Web Xml parse Web Xml From File ( File the File , Entity Resolver the Entity Resolver ) throws IO Exception , JDOM Exception { Input Stream in = null ; try { in = new File Input Stream ( the File ) ; return parse Web Xml ( in , the Entity Resolver ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IO Exception ioe ) { } } } }
public boolean has Denied Permission ( ) { for ( int i = NUM ; i < m Perms . size ( ) ; i ++ ) { if ( m Perms . get ( m User Permission . get ( i ) ) == Package Manager . PERMISSION DENIED ) return BOOL ; } return BOOL ; }
protected void handle Grab Action ( Key Event evt ) { Action Listener grab Action = grab Action ; grab Action = null ; execute Action ( grab Action , evt . get Source ( ) , String . value Of ( evt . get Key Char ( ) ) , evt . get Modifiers ( ) ) ; }
public Query String Decoder ( URI uri , Charset charset , int max Params ) { if ( uri == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( charset == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( max Params <= NUM ) { throw new Illegal Argument Exception ( STRING + max Params + STRING ) ; } String raw Path = uri . get Raw Path ( ) ; if ( raw Path != null ) { has Path = BOOL ; } else { raw Path = STRING ; has Path = BOOL ; } this . uri = raw Path + ( uri . get Raw Query ( ) == null ? STRING : STRING + uri . get Raw Query ( ) ) ; this . charset = charset ; this . max Params = max Params ; }
private static List < String > generate Get Method Names ( final Field field ) { final List < String > prefix = new Linked List < String > ( ) ; prefix . add ( STRING + Attribute Helper . get Attribute Name ( field ) ) ; if ( field . get Type ( ) == boolean . class || field . get Type ( ) == Boolean . class ) { prefix . add ( STRING + Attribute Helper . get Attribute Name ( field ) ) ; String field Name = field . get Name ( ) ; if ( field Name . length ( ) > NUM && field Name . starts With ( STRING ) && Character . is Upper Case ( field Name . char At ( NUM ) ) ) prefix . add ( field Name ) ; } return prefix ; }
public boolean is Session Token ( String site , String token ) { if ( ! site . contains ( STRING ) ) { site = site + ( STRING ) ; } Http Session Tokens Set site Tokens = session Tokens . get ( site ) ; if ( site Tokens == null ) return BOOL ; return site Tokens . is Session Token ( token ) ; }
protected void fill Kernel Ordinates ( Complex Array ordinates , double band Width ) { final int length = ordinates . length ; final double a = NUM / ( Math . sqrt ( NUM * Math . PI ) * band Width ) ; final double precision = - NUM / ( band Width * band Width ) ; for ( int i = NUM ; i < length ; i ++ ) { final double x = ordinates . real [ i ] ; ordinates . real [ i ] = a * Math . exp ( x * x * precision ) ; } }
public void load ( Byte Buffer buf ) { seq Id = buf . get Int ( ) ; n Rows = info . is Row Block Enabled ( ) ? buf . get Int ( ) : NUM ; load ( primary Key , buf ) ; for ( int i = NUM ; i < info . col Blocks . length ; i ++ ) { Byte Array cb = cell Blocks [ i ] ; load ( cb , buf ) ; } }
private Hash Map < String , Object > create Header Details ( String index Number , String transaction ) { Simple Date Format sdf = new Simple Date Format ( STRING ) ; String description = STRING + index Number + STRING + transaction + STRING + sdf . format ( new Date ( ) ) ; String source URL = URL FOR DCB + index Number ; Hash Map < String , Object > headerdetails = new Hash Map < String , Object > ( ) ; headerdetails . put ( Voucher Constant . VOUCHERNAME , VOUCHERNAME ) ; headerdetails . put ( Voucher Constant . VOUCHERTYPE , VOUCHERTYPE ) ; headerdetails . put ( Voucher Constant . DESCRIPTION , description ) ; headerdetails . put ( Voucher Constant . VOUCHERNUMBER , VOUCHERNUMBER ) ; headerdetails . put ( Voucher Constant . VOUCHERDATE , new Date ( ) ) ; headerdetails . put ( Voucher Constant . STATUS , NUM ) ; headerdetails . put ( Voucher Constant . MODULEID , PTIS EG MODULES ID ) ; headerdetails . put ( Voucher Constant . DEPARTMENTCODE , DEPT CODE TAX ) ; headerdetails . put ( Voucher Constant . FUNDCODE , get Fund Code ( ) ) ; headerdetails . put ( Voucher Constant . SOURCEPATH , source URL ) ; return headerdetails ; }
private void update Radio Links ( ) { if ( m Exp != null ) { m Exp . set Split By Data Set ( m split By Data Set . is Selected ( ) ) ; } }
public static External App Id determine External Intent Source ( String package Name , Intent intent ) { String app Id = Intent Utils . safe Get String Extra ( intent , Browser . EXTRA APPLICATION ID ) ; External App Id external Id = External App Id . OTHER ; if ( app Id == null ) { String url = get Url From Intent ( intent ) ; if ( url != null && url . starts With ( TWITTER LINK PREFIX ) ) { external Id = External App Id . TWITTER ; } else if ( url != null && url . starts With ( FACEBOOK LINK PREFIX ) ) { external Id = External App Id . FACEBOOK ; } else if ( url != null && url . starts With ( NEWS LINK PREFIX ) ) { external Id = External App Id . NEWS ; } } else { if ( app Id . equals ( PACKAGE PLUS ) ) { external Id = External App Id . PLUS ; } else if ( app Id . equals ( PACKAGE GMAIL ) ) { external Id = External App Id . GMAIL ; } else if ( app Id . equals ( PACKAGE HANGOUTS ) ) { external Id = External App Id . HANGOUTS ; } else if ( app Id . equals ( PACKAGE MESSENGER ) ) { external Id = External App Id . MESSENGER ; } else if ( app Id . equals ( PACKAGE LINE ) ) { external Id = External App Id . LINE ; } else if ( app Id . equals ( PACKAGE WHATSAPP ) ) { external Id = External App Id . WHATSAPP ; } else if ( app Id . equals ( PACKAGE GSA ) ) { external Id = External App Id . GSA ; } else if ( app Id . equals ( package Name ) ) { external Id = External App Id . CHROME ; } } return external Id ; }
public List < Properties > find All Properties ( String uri ) throws IO Exception { String fulluri = path + uri ; List < Properties > properties = new Array List < > ( ) ; Enumeration < URL > resources = get Resources ( fulluri ) ; while ( resources . has More Elements ( ) ) { URL url = resources . next Element ( ) ; Properties props = load Properties ( url ) ; properties . add ( props ) ; } return properties ; }
@ Suppress Warnings ( STRING ) public static void create Project Log ( Zip File zip , Project a Project , Repository Service a Repository ) throws IO Exception { for ( Enumeration zip Enumerate = zip . entries ( ) ; zip Enumerate . has More Elements ( ) ; ) { Zip Entry entry = ( Zip Entry ) zip Enumerate . next Element ( ) ; String entry Name = normalize Entry Name ( entry ) ; if ( entry Name . starts With ( LOG DIR ) ) { File Utils . copy Input Stream To File ( zip . get Input Stream ( entry ) , a Repository . get Project Log File ( a Project ) ) ; LOG . info ( STRING + a Project . get Name ( ) + STRING + a Project . get Id ( ) + STRING ) ; } } }
public static Source from File ( File f , Charset cs ) throws IO Exception { try ( Input Stream is = new File Input Stream ( f ) ) { return from Stream ( is , f . to URI ( ) , cs ) ; } }
public void test Merge One Servlet Into Document With Same Servlet ( ) throws Exception { String src Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge ( merge Web Xml ) ; assert True ( Web Xml Utils . has Servlet ( src Web Xml , STRING ) ) ; }
private RE union R Es ( Set < RE > coll ) throws Interrupted Exception { if ( coll . is Empty ( ) ) { return RE . empty ; } RE acc = RE . empty ; for ( RE re : coll ) { acc = acc . union ( re ) ; } return acc ; }
public void create ( Client client , O Auth 2 Request request ) throws Invalid Client Metadata { Map < String , Set < String > > attrs = create Client Attribute Map ( client ) ; try { final SSO Token token = Access Controller . do Privileged ( Admin Token Action . get Instance ( ) ) ; final String realm = request . get Parameter ( O Auth 2 Constants . Custom . REALM ) ; AM Identity Repository repo = id Repo Factory . create ( realm , token ) ; repo . create Identity ( Id Type . AGENTONLY , client . get Client ID ( ) , attrs ) ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw new Invalid Client Metadata ( ) ; } }
public void register Fix ( @ Not Null Intention Action fix , @ Nullable Text Range range , @ Nullable final Highlight Display Key key ) { if ( range == null ) { range = new Text Range ( my Start Offset , my End Offset ) ; } if ( my Quick Fixes == null ) { my Quick Fixes = new Array List < Quick Fix Info > ( ) ; } my Quick Fixes . add ( new Quick Fix Info ( fix , range , key ) ) ; }
protected void create Container ( I Path pathname ) { if ( directory Entry Cache . contains Key ( pathname ) ) { return ; } Zip Entry parent ; if ( pathname . segment Count ( ) == NUM ) { parent = root ; } else { parent = ( Zip Entry ) directory Entry Cache . get ( pathname . remove Last Segments ( NUM ) ) ; } Zip Entry new Entry = new Zip Entry ( pathname . to String ( ) ) ; directory Entry Cache . put ( pathname , new Entry ) ; add To Children ( parent , new Entry ) ; }
public void test Get Local Name 1 ( ) throws Throwable { Document doc ; Node List element List ; Element test Addr ; Attr addr Attr ; String local Name ; doc = ( Document ) load ( STRING , builder ) ; element List = doc . get Elements By Tag Name ( STRING ) ; test Addr = ( Element ) element List . item ( NUM ) ; assert Not Null ( STRING , test Addr ) ; addr Attr = test Addr . get Attribute Node ( STRING ) ; local Name = addr Attr . get Local Name ( ) ; assert Equals ( STRING , STRING , local Name ) ; }
@ Override public void start Document ( XML Locator locator , String encoding , Namespace Context namespace Context , Augmentations augs ) throws XNI Exception { f Locator = locator ; if ( ! f Defer Node Expansion ) { if ( f Document Class Name . equals ( DEFAULT DOCUMENT CLASS NAME ) ) { f Document = new Document Impl ( ) ; f Document Impl = ( Core Document Impl ) f Document ; f Document Impl . set Strict Error Checking ( BOOL ) ; f Document Impl . set Input Encoding ( encoding ) ; f Document Impl . set Document URI ( locator . get Expanded System Id ( ) ) ; } else if ( f Document Class Name . equals ( PSVI DOCUMENT CLASS NAME ) ) { f Document = new PSVI Document Impl ( ) ; f Document Impl = ( Core Document Impl ) f Document ; f Store PSVI = BOOL ; f Document Impl . set Strict Error Checking ( BOOL ) ; f Document Impl . set Input Encoding ( encoding ) ; f Document Impl . set Document URI ( locator . get Expanded System Id ( ) ) ; } else { try { Class Loader cl = Object Factory . find Class Loader ( ) ; Class document Class = Object Factory . find Provider Class ( f Document Class Name , cl , BOOL ) ; f Document = ( Document ) document Class . new Instance ( ) ; Class default Doc Class = Object Factory . find Provider Class ( CORE DOCUMENT CLASS NAME , cl , BOOL ) ; if ( default Doc Class . is Assignable From ( document Class ) ) { f Document Impl = ( Core Document Impl ) f Document ; Class psvi Doc Class = Object Factory . find Provider Class ( PSVI DOCUMENT CLASS NAME , cl , BOOL ) ; if ( psvi Doc Class . is Assignable From ( document Class ) ) { f Store PSVI = BOOL ; } f Document Impl . set Strict Error Checking ( BOOL ) ; f Document Impl . set Input Encoding ( encoding ) ; if ( locator != null ) { f Document Impl . set Document URI ( locator . get Expanded System Id ( ) ) ; } } } catch ( Class Not Found Exception e ) { } catch ( Exception e ) { throw new Runtime Exception ( DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , new Object [ ] { f Document Class Name } ) ) ; } } f Current Node = f Document ; } else { f Deferred Document Impl = new Deferred Document Impl ( f Namespace Aware ) ; f Document = f Deferred Document Impl ; f Document Index = f Deferred Document Impl . create Deferred Document ( ) ; f Deferred Document Impl . set Input Encoding ( encoding ) ; f Deferred Document Impl . set Document URI ( locator . get Expanded System Id ( ) ) ; f Current Node Index = f Document Index ; } }
protected String encode Cookie ( Serializable Cookie cookie ) { if ( cookie == null ) return null ; Byte Array Output Stream os = new Byte Array Output Stream ( ) ; try { Object Output Stream output Stream = new Object Output Stream ( os ) ; output Stream . write Object ( cookie ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return null ; } return byte Array To Hex String ( os . to Byte Array ( ) ) ; }
public void add Observer ( Notification Observer observer ) { if ( ! observers . contains ( observer ) ) { observers . add ( observer ) ; } }
private Row Map process Heartbeats ( Row Map row ) throws SQL Exception { String hb Client ID = ( String ) row . get Data ( STRING ) ; if ( ! Objects . equals ( hb Client ID , this . client ID ) ) return row ; Object heartbeat at = row . get Data ( STRING ) ; Object old heartbeat at = row . get Old Data ( STRING ) ; if ( heartbeat at != null && old heartbeat at != null ) { Long this Heartbeat = ( Long ) heartbeat at ; if ( ! this Heartbeat . equals ( last Heartbeat Read ) ) { this . last Heartbeat Read = this Heartbeat ; return Heartbeat Row Map . value Of ( row . get Database ( ) , row . get Position ( ) , this Heartbeat ) ; } } return row ; }
@ Override public void serialize ( String name , byte [ ] message , Output Stream out ) throws IO Exception { byte [ ] header = new byte [ NUM + COMMAND LEN + NUM + NUM ] ; uint 32 To Byte Array BE ( params . get Packet Magic ( ) , header , NUM ) ; for ( int i = NUM ; i < name . length ( ) && i < COMMAND LEN ; i ++ ) { header [ NUM + i ] = ( byte ) ( name . code Point At ( i ) & NUM ) ; } Utils . uint 32 To Byte Array LE ( message . length , header , NUM + COMMAND LEN ) ; byte [ ] hash = Sha 256 Hash . hash Twice ( message ) ; System . arraycopy ( hash , NUM , header , NUM + COMMAND LEN + NUM , NUM ) ; out . write ( header ) ; out . write ( message ) ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING , name , HEX . encode ( header ) + HEX . encode ( message ) ) ; }
public SSL Socket Factory build SSL Socket Factory ( ) throws Key Store Exception { SSL Context ssl Context = null ; try { Key Manager Factory key Manager Factory = Key Manager Factory . get Instance ( Key Manager Factory . get Default Algorithm ( ) ) ; key Manager Factory . init ( key Store , SSL KEYSTORE SECRET ) ; Key Manager [ ] key Managers = key Manager Factory . get Key Managers ( ) ; Trust Manager [ ] trust Managers = new Trust Manager [ ] { create Trust Manager From Default JDK Trust Store ( ) } ; ssl Context = SSL Context . get Instance ( STRING ) ; ssl Context . init ( key Managers , trust Managers , null ) ; SSL Context . set Default ( ssl Context ) ; } catch ( General Security Exception | IO Exception e ) { throw new Key Store Exception ( STRING , e ) ; } return ssl Context . get Socket Factory ( ) ; }
public final void add Clinit ( ) { if ( need Class Init Method ( ) ) { int length ; Abstract Method Declaration [ ] method Declarations ; if ( ( method Declarations = this . methods ) == null ) { length = NUM ; method Declarations = new Abstract Method Declaration [ NUM ] ; } else { length = method Declarations . length ; System . arraycopy ( method Declarations , NUM , ( method Declarations = new Abstract Method Declaration [ length + NUM ] ) , NUM , length ) ; } Clinit clinit = new Clinit ( this . compilation Result ) ; method Declarations [ NUM ] = clinit ; clinit . declaration Source Start = clinit . source Start = this . source Start ; clinit . declaration Source End = clinit . source End = this . source End ; clinit . body End = this . source End ; this . methods = method Declarations ; } }
public void add ( String arg Name , String desc , int expected Number Of Arguments , boolean expect Dashed Arguments ) { Arg new Arg = new Arg ( arg Name , desc , expected Number Of Arguments , expect Dashed Arguments ) ; args . add ( new Arg ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + arg Name ) ; } }
public static boolean [ ] convert String To Boolean Arr ( String no Dictionary Col Mapping ) { String [ ] splitted Value = null != no Dictionary Col Mapping ? no Dictionary Col Mapping . split ( Carbon Common Constants . COMA SPC CHARACTER ) : new String [ NUM ] ; boolean [ ] no Dictionary Mapping = new boolean [ splitted Value . length ] ; int index = NUM ; for ( String str : splitted Value ) { no Dictionary Mapping [ index ++ ] = Boolean . parse Boolean ( str ) ; } return no Dictionary Mapping ; }
protected void draw Axis Line ( Graphics 2 D g2 , double cursor , Rectangle 2 D data Area , Rectangle Edge edge ) { Line 2 D axis Line = null ; double x = data Area . get X ( ) ; double y = data Area . get Y ( ) ; if ( edge == Rectangle Edge . TOP ) { axis Line = new Line 2 D . Double ( x , cursor , data Area . get Max X ( ) , cursor ) ; } else if ( edge == Rectangle Edge . BOTTOM ) { axis Line = new Line 2 D . Double ( x , cursor , data Area . get Max X ( ) , cursor ) ; } else if ( edge == Rectangle Edge . LEFT ) { axis Line = new Line 2 D . Double ( cursor , y , cursor , data Area . get Max Y ( ) ) ; } else if ( edge == Rectangle Edge . RIGHT ) { axis Line = new Line 2 D . Double ( cursor , y , cursor , data Area . get Max Y ( ) ) ; } g2 . set Paint ( this . axis Line Paint ) ; g2 . set Stroke ( this . axis Line Stroke ) ; Object saved = g2 . get Rendering Hint ( Rendering Hints . KEY STROKE CONTROL ) ; g2 . set Rendering Hint ( Rendering Hints . KEY STROKE CONTROL , Rendering Hints . VALUE STROKE NORMALIZE ) ; g2 . draw ( axis Line ) ; g2 . set Rendering Hint ( Rendering Hints . KEY STROKE CONTROL , saved ) ; }
public static void save KOML ( File save To , Object model , Instances header ) throws Exception { Vector < Object > v = new Vector < Object > ( ) ; v . add ( model ) ; if ( header != null ) { v . add ( header ) ; } v . trim To Size ( ) ; KOML . write ( save To . get Absolute Path ( ) , v ) ; }
private void add Span ( Cache Span span ) { Tree Set < Cache Span > spans For Key = cached Spans . get ( span . key ) ; if ( spans For Key == null ) { spans For Key = new Tree Set < > ( ) ; cached Spans . put ( span . key , spans For Key ) ; } spans For Key . add ( span ) ; total Space += span . length ; notify Span Added ( span ) ; }
public int split By Distance ( Array Modifiable DBI Ds ind , int begin , int end , Double Data Store tpro , Random rand ) { DBID Array Iter it = ind . iter ( ) ; double rmin = Double . MAX VALUE * NUM , rmax = - Double . MAX VALUE * NUM ; int min Ind = begin , max Ind = end - NUM ; for ( it . seek ( begin ) ; it . get Offset ( ) < end ; it . advance ( ) ) { double curr Ele = tpro . double Value ( it ) ; rmin = Math . min ( curr Ele , rmin ) ; rmax = Math . max ( curr Ele , rmax ) ; } if ( rmin != rmax ) { double rs = rmin + rand . next Double ( ) * ( rmax - rmin ) ; while ( min Ind < max Ind ) { double curr Ele = tpro . double Value ( it . seek ( min Ind ) ) ; if ( curr Ele > rs ) { while ( min Ind < max Ind && tpro . double Value ( it . seek ( max Ind ) ) > rs ) { max Ind -- ; } if ( min Ind == max Ind ) { break ; } ind . swap ( min Ind , max Ind ) ; max Ind -- ; } min Ind ++ ; } } else { min Ind = ( begin + end ) > > > NUM ; } return min Ind ; }
public static String no Prefix ( String path , String prefix ) { return path . starts With ( prefix ) ? path . substring ( prefix . length ( ) ) : path ; }
protected void subscribe ( ) throws IO Exception { if ( sample Client Sub == null ) { try { sample Client Sub = new Sample Async Wait ( url , client Id Sub , clean Session , quiet Mode , user Name , password ) ; } catch ( Mqtt Exception e ) { e . print Stack Trace ( ) ; } } if ( sample Client Sub != null ) { String topic = STRING ; int qos = NUM ; try { sample Client Sub . subscribe ( topic , qos ) ; } catch ( Throwable e ) { e . print Stack Trace ( ) ; } } }
public Adaptable List add ( I Adaptable a ) { children . add ( a ) ; return this ; }
public static Double Stream concat ( Double Stream a , Double Stream b ) { Objects . require Non Null ( a ) ; Objects . require Non Null ( b ) ; Spliterator . Of Double split = new Streams . Concat Spliterator . Of Double ( a . spliterator ( ) , b . spliterator ( ) ) ; Double Stream stream = Stream Support . double Stream ( split , a . is Parallel ( ) || b . is Parallel ( ) ) ; return stream . on Close ( Streams . composed Close ( a , b ) ) ; }
public Auth XML Request parse XML ( ) throws Auth Exception { try { debug . message ( STRING ) ; if ( xml Document == null ) { return null ; } auth XML Request = new Auth XML Request ( ) ; Element doc Elem = xml Document . get Document Element ( ) ; if ( doc Elem != null ) { String temp = doc Elem . get Attribute ( STRING ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + temp ) ; } if ( temp != null ) { auth XML Request . set Request Version ( temp ) ; } Node request Node = XML Utils . get Child Node ( ( Node ) doc Elem , STRING ) ; String auth Identifier = null ; if ( request Node != null ) { auth Identifier = parse Node Attributes ( request Node , STRING ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + auth Identifier ) ; } auth XML Request . set Auth Identifier ( auth Identifier ) ; } Node app SSO Token Node = XML Utils . get Child Node ( ( Node ) request Node , STRING ) ; if ( app SSO Token Node != null ) { debug . message ( STRING ) ; String app SSO Token ID = XML Utils . get Value Of Value Node ( app SSO Token Node ) ; if ( app SSO Token ID != null ) { if ( debug . message Enabled ( ) ) { debug . message ( STRING + app SSO Token ID ) ; } auth XML Request . set App SSO Token ID ( app SSO Token ID ) ; } } Node new Auth Context Node = XML Utils . get Child Node ( request Node , STRING ) ; if ( new Auth Context Node != null ) { String org Name = parse Node Attributes ( new Auth Context Node , STRING ) ; auth XML Request . set Org Name ( org Name ) ; auth XML Request . set Request Type ( Auth XML Request . New Auth Context ) ; Auth Context Local auth Context = Auth Utils . get Auth Context ( org Name , auth Identifier , BOOL , servlet Req , null , null ) ; auth XML Request . set Auth Context ( auth Context ) ; } Node query Info Node = XML Utils . get Child Node ( request Node , STRING ) ; if ( query Info Node != null ) { String query Type = parse Node Attributes ( query Info Node , STRING ) ; auth XML Request . set Request Information ( query Type ) ; auth XML Request . set Request Type ( Auth XML Request . Query Information ) ; String org Name = parse Node Attributes ( query Info Node , STRING ) ; Auth Context Local auth Context = null ; if ( org Name != null ) { auth Context = Auth Utils . get Auth Context ( org Name , servlet Req ) ; } else { auth Context = Auth Utils . get Auth Context ( null , auth Identifier , BOOL ) ; } auth XML Request . set Auth Context ( auth Context ) ; } Node login Node = XML Utils . get Child Node ( request Node , STRING ) ; if ( login Node != null ) { debug . message ( STRING ) ; String org Name = parse Node Attributes ( login Node , STRING ) ; auth XML Request . set Request Type ( Auth XML Request . Login ) ; parse Login Node Elements ( login Node , auth XML Request ) ; Auth Context . Index Type index Type = auth XML Request . get Index Type ( ) ; String index Type Param = convert Index Type ( index Type ) ; String index Name = auth XML Request . get Index Name ( ) ; if ( index Type == Auth Context . Index Type . COMPOSITE ADVICE ) { org Name = Auth Utils . get Realm From Policy Advice ( index Name ) ; } Auth Context Local auth Context = null ; if ( org Name != null ) { auth XML Request . set Org Name ( org Name ) ; } String host Name = parse Node Attributes ( login Node , STRING ) ; if ( host Name != null ) { auth XML Request . set Host Name ( host Name ) ; } String locale Attr = parse Node Attributes ( login Node , Auth XML Tags . LOCALE ) ; if ( locale Attr != null ) { auth XML Request . set Locale ( locale Attr ) ; } String force Auth = parse Node Attributes ( login Node , STRING ) ; if ( force Auth != null ) { auth XML Request . set Force Auth ( force Auth ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + force Auth ) ; } } boolean force Auth Bool = Boolean . parse Boolean ( force Auth ) ; auth Context = Auth Utils . get Auth Context ( org Name , auth Identifier , BOOL , servlet Req , index Type Param , auth XML Request , force Auth Bool ) ; auth XML Request . set Auth Context ( auth Context ) ; if ( locale Attr != null ) { Login State login State = auth Context . get Login State ( ) ; login State . set Remote Locale ( locale Attr ) ; } Http Servlet Request client Request = Auth XML Utils . get Remote Request ( XML Utils . get Child Node ( request Node , Auth XML Tags . REMOTE REQUEST RESPONSE ) ) ; Http Servlet Response client Response = Auth XML Utils . get Remote Response ( XML Utils . get Child Node ( request Node , Auth XML Tags . REMOTE REQUEST RESPONSE ) ) ; auth XML Request . set Client Request ( client Request ) ; auth XML Request . set Client Response ( client Response ) ; } Node submit Req Node = XML Utils . get Child Node ( request Node , STRING ) ; if ( submit Req Node != null ) { auth XML Request . set Request Type ( Auth XML Request . Submit Requirements ) ; Auth Context Local auth Context = Auth Utils . get Auth Context ( servlet Req , auth Identifier ) ; auth XML Request . set Auth Context ( auth Context ) ; Callback [ ] callbacks = Auth Utils . get Recd Callback ( auth Context ) ; parse Submit Req Elements ( submit Req Node , auth XML Request , callbacks ) ; String locale Str = auth XML Request . get Locale ( ) ; Login State login State = auth Context . get Login State ( ) ; login State . set Remote Locale ( locale Str ) ; Http Servlet Request client Request = Auth XML Utils . get Remote Request ( XML Utils . get Child Node ( request Node , Auth XML Tags . REMOTE REQUEST RESPONSE ) ) ; Http Servlet Response client Response = Auth XML Utils . get Remote Response ( XML Utils . get Child Node ( request Node , Auth XML Tags . REMOTE REQUEST RESPONSE ) ) ; auth XML Request . set Client Request ( client Request ) ; auth XML Request . set Client Response ( client Response ) ; } Node logout Node = XML Utils . get Child Node ( request Node , STRING ) ; if ( logout Node != null ) { auth XML Request . set Request Type ( Auth XML Request . Logout ) ; } Node abort Node = XML Utils . get Child Node ( request Node , STRING ) ; if ( abort Node != null ) { auth XML Request . set Request Type ( Auth XML Request . Abort ) ; Auth Context Local auth Context = Auth Utils . get Auth Context ( null , auth Identifier , BOOL ) ; auth XML Request . set Auth Context ( auth Context ) ; } } } catch ( Auth Exception e ) { throw e ; } catch ( Exception e ) { debug . message ( STRING , e ) ; } return auth XML Request ; }
public static < V > V execute Synchronously ( Callable < V > c ) { try { final Atomic Reference < V > result = new Atomic Reference < > ( ) ; final Atomic Reference < Exception > err = new Atomic Reference < > ( ) ; final Count Down Latch done Latch = new Count Down Latch ( NUM ) ; final Authorization Context context = Operation Context . get Authorization Context ( ) ; executor . execute ( null ) ; done Latch . await ( ) ; Exception ex = err . get ( ) ; if ( ex != null ) { throw ex ; } else { return result . get ( ) ; } } catch ( Exception e ) { if ( e instanceof Runtime Exception ) { throw ( Runtime Exception ) e ; } else { throw new Runtime Exception ( e ) ; } } }
public boolean write Characteristic ( String address , String service UUID , String characteristic UUID , String value ) { Bluetooth Gatt bluetooth Gatt = m Bluetooth Gatt Map . get ( address ) ; if ( bluetooth Gatt != null ) { Bluetooth Gatt Service service = bluetooth Gatt . get Service ( UUID . from String ( service UUID ) ) ; Bluetooth Gatt Characteristic characteristic = service . get Characteristic ( UUID . from String ( characteristic UUID ) ) ; characteristic . set Value ( value ) ; return bluetooth Gatt . write Characteristic ( characteristic ) ; } return BOOL ; }
public static void rename Table For Deletion ( int partition Count , String store Path , String database Name , String table Name ) { String table Name With Partition = STRING ; String database Name With Partition = STRING ; String full Path = STRING ; String new File Path = STRING ; String new File Name = STRING ; Callable < Void > c = null ; long time = System . current Time Millis ( ) ; File Factory . File Type file Type = null ; Executor Service executor Service = Executors . new Fixed Thread Pool ( NUM ) ; for ( int i = NUM ; i < partition Count ; i ++ ) { database Name With Partition = database Name + STRING + i ; table Name With Partition = table Name + STRING + i ; new File Name = table Name With Partition + STRING + time ; full Path = store Path + File . separator + database Name With Partition + File . separator + table Name With Partition ; new File Path = store Path + File . separator + database Name With Partition + File . separator + new File Name ; file Type = File Factory . get File Type ( full Path ) ; try { if ( File Factory . is File Exist ( full Path , file Type ) ) { Carbon File file = File Factory . get Carbon File ( full Path , file Type ) ; boolean is Rename Successfull = file . rename To ( new File Path ) ; if ( ! is Rename Successfull ) { LOGGER . error ( STRING + full Path ) ; c = new Delete Folder And Files ( file ) ; executor Service . submit ( c ) ; } else { c = new Delete Folder And Files ( File Factory . get Carbon File ( new File Path , file Type ) ) ; executor Service . submit ( c ) ; } } } catch ( IO Exception e ) { LOGGER . error ( STRING + full Path ) ; } } executor Service . shutdown ( ) ; }
protected Map < String , Double > load Bing Liu ( ) throws File Not Found Exception { Map < String , Double > lexi Map = new Hash Map < String , Double > ( ) ; File file = new File ( STRING ) ; Scanner scanner = new Scanner ( file ) ; while ( scanner . has Next Line ( ) ) { lexi Map . put ( scanner . next Line ( ) , NUM ) ; } scanner . close ( ) ; File file 2 = new File ( STRING ) ; Scanner scanner 2 = new Scanner ( file 2 ) ; while ( scanner 2 . has Next Line ( ) ) { lexi Map . put ( scanner 2 . next Line ( ) , - NUM ) ; } scanner 2 . close ( ) ; return lexi Map ; }
public void add ( Json Element element ) { if ( element == null ) { element = Json Null . INSTANCE ; } elements . add ( element ) ; }
public T Sink < String > send String ( T Stream < String > stream ) { Objects . require Non Null ( stream , STRING ) ; return send Text ( stream , null ) ; }
public static void sort By Type Id Index ( Annotation Item [ ] array ) { Arrays . sort ( array , TYPE ID SORTER ) ; }
public boolean is Authn Context Matching ( List requested AC Class Refs , String ac Class Ref , String comparison , String realm , String host Entity ID ) { Map auth Ref Map = get Auth Ref Map ( realm , host Entity ID ) ; return SAML 2 Utils . is Authn Context Matching ( requested AC Class Refs , ac Class Ref , comparison , auth Ref Map ) ; }
private List < Integer > compute Condition Indexes Not Covered Two Ways ( final Test Chromosome test , final Path Condition collected Path Condition ) { List < Integer > condition Indexes Not Covered Two Ways = new Linked List < Integer > ( ) ; for ( int condition Index = NUM ; condition Index < collected Path Condition . size ( ) ; condition Index ++ ) { Branch Condition b = collected Path Condition . get ( condition Index ) ; if ( ! is Covered Two Ways ( test , b . get Branch Index ( ) ) ) { condition Indexes Not Covered Two Ways . add ( condition Index ) ; } } return condition Indexes Not Covered Two Ways ; }
public void test journal one Index Random Data ( ) throws IO Exception , Interrupted Exception , Execution Exception { final File out = File . create Temp File ( get Name ( ) , Options . JNL ) ; try { final Journal src = get Store ( get Properties ( ) ) ; try { final String NAME = STRING ; src . register Index ( new Index Metadata ( NAME , UUID . random UUID ( ) ) ) ; { B Tree ndx = src . get Index ( NAME ) ; KV [ ] a = Abstract B Tree Test Case . get Random Key Values ( NUM ) ; for ( KV kv : a ) { ndx . insert ( kv . key , kv . val ) ; } } src . commit ( ) ; Future < Journal > f = src . compact ( out ) ; Journal new Journal = f . get ( ) ; try { assert Not Null ( new Journal . get Index ( NAME ) ) ; Abstract B Tree Test Case . assert Same B Tree ( src . get Index ( NAME ) , new Journal . get Index ( NAME ) ) ; } finally { new Journal . destroy ( ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public static void wrap Thread Loader ( Class Loader ldr , Runnable c ) { Thread cur Thread = Thread . current Thread ( ) ; Class Loader ctx Ldr = cur Thread . get Context Class Loader ( ) ; try { cur Thread . set Context Class Loader ( ldr ) ; c . run ( ) ; } finally { cur Thread . set Context Class Loader ( ctx Ldr ) ; } }
private static String remove Subj Leaders ( String subject ) { int sub String = NUM ; while ( subject . char At ( sub String ) == WS ) { sub String ++ ; } if ( sub String > NUM ) { return subject . substring ( sub String ) ; } else { String subj = remove Subject Blob ( subject ) ; String low Case Subj = subj . to Lower Case ( Locale . US ) ; if ( low Case Subj . starts With ( RE ) ) { sub String = RE . length ( ) ; } else if ( low Case Subj . starts With ( FWD ) ) { sub String = FWD . length ( ) ; } else if ( low Case Subj . starts With ( FW ) ) { sub String = FW . length ( ) ; } else { return subject ; } while ( subj . char At ( sub String ) == WS ) { sub String ++ ; } if ( subj . char At ( sub String ) == COLON ) { sub String ++ ; } else { return subject ; } while ( subj . char At ( sub String ) == WS ) { sub String ++ ; } return subj . substring ( sub String ) ; } }
public Gif Drawable ( Input Stream stream ) throws IO Exception { if ( stream == null ) throw new Null Pointer Exception ( STRING ) ; if ( ! stream . mark Supported ( ) ) throw new Illegal Argument Exception ( STRING ) ; m Gif Info Ptr = open Stream ( m Meta Data , stream , BOOL ) ; m Colors = new int [ m Meta Data [ NUM ] * m Meta Data [ NUM ] ] ; m Input Source Length = - NUM ; }
public static String create Base 64 ( Bitmap m Bitmap ) { Byte Array Output Stream baos 1 = new Byte Array Output Stream ( ) ; m Bitmap . compress ( Bitmap . Compress Format . JPEG , NUM , baos 1 ) ; byte [ ] b1 = baos 1 . to Byte Array ( ) ; return Base 64 . encode To String ( b1 , Base 64 . DEFAULT ) ; }
public Rhythm Spec Layer inflate Layer ( String config String , @ Non Null Map < String , String > vars ) { return inflate Layer Internal ( parse Config Internal ( config String , vars , NUM ) , NUM ) ; }
public static void register Fuel Handler ( I Fuel Handler handler , Fuel Type type ) { switch ( type ) { case CRYSTALLIZER : crystallizer Fuel Handlers . add ( handler ) ; break ; case TRANSMUTATOR : transmutator Fuel Handlers . add ( handler ) ; break ; case FURNACE : Game Registry . register Fuel Handler ( handler ) ; } }
protected void write Attributes ( Attribute Set attr ) throws IO Exception { conv Attr . remove Attributes ( conv Attr ) ; convert To HTML 32 ( attr , conv Attr ) ; Enumeration names = conv Attr . get Attribute Names ( ) ; while ( names . has More Elements ( ) ) { Object name = names . next Element ( ) ; if ( name instanceof HTML . Tag || name instanceof Style Constants || name == HTML . Attribute . ENDTAG ) { continue ; } write ( STRING + name + STRING + conv Attr . get Attribute ( name ) + STRING ) ; } }
final private String match Rule Def 2 Match Rule Desc ( Attributes attrs ) throws Naming Exception { String Buffer match Rule Desc = new String Buffer ( STRING ) ; Attribute attr = null ; int count = NUM ; attr = attrs . get ( NUMERICOID ID ) ; if ( attr != null ) { match Rule Desc . append ( write Numeric OID ( attr ) ) ; count ++ ; } else { throw new Configuration Exception ( STRING + STRING ) ; } attr = attrs . get ( NAME ID ) ; if ( attr != null ) { match Rule Desc . append ( write Q Descrs ( attr ) ) ; count ++ ; } attr = attrs . get ( DESC ID ) ; if ( attr != null ) { match Rule Desc . append ( write QD String ( attr ) ) ; count ++ ; } attr = attrs . get ( OBSOLETE ID ) ; if ( attr != null ) { match Rule Desc . append ( write Boolean ( attr ) ) ; count ++ ; } attr = attrs . get ( SYNTAX ID ) ; if ( attr != null ) { match Rule Desc . append ( write WOID ( attr ) ) ; count ++ ; } else { throw new Configuration Exception ( STRING + STRING ) ; } if ( count < attrs . size ( ) ) { String attr Id = null ; for ( Naming Enumeration < ? extends Attribute > ae = attrs . get All ( ) ; ae . has More Elements ( ) ; ) { attr = ae . next ( ) ; attr Id = attr . get ID ( ) ; if ( attr Id . equals ( NUMERICOID ID ) || attr Id . equals ( NAME ID ) || attr Id . equals ( SYNTAX ID ) || attr Id . equals ( DESC ID ) || attr Id . equals ( OBSOLETE ID ) ) { continue ; } else { match Rule Desc . append ( write QD Strings ( attr ) ) ; } } } match Rule Desc . append ( STRING ) ; return match Rule Desc . to String ( ) ; }
@ Override public void write ( byte [ ] buf , int offset , int length , boolean is End ) throws IO Exception { if ( s == null ) { return ; } try { needs Flush = BOOL ; while ( length > NUM ) { write Buffer . clear ( ) ; int sublen = Math . min ( length , write Buffer . remaining ( ) ) ; write Buffer . put ( buf , offset , sublen ) ; write Buffer . flip ( ) ; s . write ( write Buffer ) ; length -= sublen ; offset += sublen ; } total Write Bytes += length ; } catch ( IO Exception e ) { IO Exception exn = Client Disconnect Exception . create ( this + STRING + e , e ) ; try { close ( ) ; } catch ( IO Exception e1 ) { } throw exn ; } }
private static void skip Member Value ( Byte Buffer buf ) { int tag = buf . get ( ) ; skip Member Value ( tag , buf ) ; }
protected static void compute Cartesian ( List < Event Bean [ ] > stream One , int [ ] sub Stream Nums One , List < Event Bean [ ] > stream Two , int [ ] sub Stream Nums Two , List < Event Bean [ ] > result List ) { if ( ( stream Two == null ) || ( stream Two . is Empty ( ) ) ) { if ( ( stream One == null ) || ( stream One . is Empty ( ) ) ) { return ; } result List . add All ( stream One ) ; return ; } if ( ( stream One == null ) || ( stream One . is Empty ( ) ) ) { result List . add All ( stream Two ) ; return ; } int stream One Size = stream One . size ( ) ; int stream Two Size = stream Two . size ( ) ; if ( stream One Size == NUM ) { copy To Each ( sub Stream Nums One , stream One . get ( NUM ) , stream Two ) ; result List . add All ( stream Two ) ; return ; } if ( stream Two Size == NUM ) { copy To Each ( sub Stream Nums Two , stream Two . get ( NUM ) , stream One ) ; result List . add All ( stream One ) ; return ; } if ( stream Two Size > stream One Size ) { List < Event Bean [ ] > hold Rows = stream One ; int hold Size = stream One Size ; stream One = stream Two ; stream One Size = stream Two Size ; stream Two = hold Rows ; stream Two Size = hold Size ; sub Stream Nums Two = sub Stream Nums One ; } int cartesian Total Rows = stream One Size * stream Two Size ; int num Columns = stream One . get ( NUM ) . length ; Event Bean [ ] [ ] results = new Event Bean [ cartesian Total Rows ] [ ] ; int stream One Count = NUM ; for ( Event Bean [ ] row : stream One ) { results [ stream One Count ] = row ; for ( int i = NUM ; i < stream Two Size ; i ++ ) { Event Bean [ ] dup Row = new Event Bean [ num Columns ] ; System . arraycopy ( row , NUM , dup Row , NUM , num Columns ) ; int index = stream One Size * i + stream One Count ; results [ index ] = dup Row ; } stream One Count ++ ; } int stream Two Count = NUM ; for ( Event Bean [ ] row : stream Two ) { for ( int i = NUM ; i < stream One Size ; i ++ ) { int index = stream Two Count * stream One Size + i ; copy ( sub Stream Nums Two , row , results [ index ] ) ; } stream Two Count ++ ; } result List . add All ( Arrays . as List ( results ) ) ; }
public void create Router Configuration ( String cluster Name ) throws Configuration Exception { String router Config File Name = get Module Properties File Name ( Configuration Constants . TR PROPERTIES , get Cluster Home ( ) ) ; File router Config File = new File ( router Config File Name ) ; if ( router Config File . exists ( ) ) { logger . debug ( String . format ( STRING , router Config File Name ) ) ; return ; } Router Configuration config = new Router Configuration ( null ) ; config . set Cluster Home ( get Cluster Home ( ) ) ; config . set Host ( Configuration Constants . TR RMI DEFAULT HOST ) ; Array List < String > al = new Array List < String > ( ) ; al . add ( STRING ) ; config . set Manager List ( al ) ; Tungsten Properties config Props = new Tungsten Properties ( ) ; config Props . extract Properties ( config , BOOL ) ; logger . debug ( STRING + router Config File Name + STRING ) ; logger . debug ( STRING + config Props ) ; config . store ( config Props , router Config File Name ) ; }
protected void layout Minor Axis ( int target Span , int axis , int [ ] offsets , int [ ] spans ) { super . layout Minor Axis ( target Span , axis , offsets , spans ) ; int col = NUM ; int ncells = get View Count ( ) ; for ( int cell = NUM ; cell < ncells ; cell ++ , col ++ ) { View cv = get View ( cell ) ; for ( ; is Filled ( col ) ; col ++ ) ; int col Span = get Columns Occupied ( cv ) ; int row Span = get Rows Occupied ( cv ) ; if ( row Span > NUM ) { int row 0 = row Index ; int row 1 = Math . min ( row Index + row Span - NUM , get Row Count ( ) - NUM ) ; spans [ cell ] = get Multi Row Span ( row 0 , row 1 ) ; } if ( col Span > NUM ) { col += col Span - NUM ; } } }
public static String [ ] ls Files Recursive ( String directory , Filename Filter filter ) throws IO Exception { File dir = new File ( directory ) ; Array List < String > files = new Array List < > ( ) ; for ( File filepath : dir . list Files ( filter ) ) { if ( is File ( filepath . get Absolute Path ( ) ) ) files . add ( filepath . get Absolute Path ( ) ) ; else if ( is Directory ( filepath . get Absolute Path ( ) ) ) files . add All ( Arrays . as List ( ls Files Recursive ( filepath . get Absolute Path ( ) , filter ) ) ) ; } return files . to Array ( new String [ files . size ( ) ] ) ; }
public String generate Create ( String table ) throws Database Exception { String Buffer result = new String Buffer ( ) ; try { String Buffer sql = new String Buffer ( ) ; sql . append ( STRING ) ; sql . append ( table ) ; Result Set rs = execute Query ( sql . to String ( ) ) ; Result Set Meta Data md = rs . get Meta Data ( ) ; result . append ( STRING ) ; result . append ( table ) ; result . append ( STRING ) ; for ( int i = NUM ; i <= md . get Column Count ( ) ; i ++ ) { if ( i != NUM ) { result . append ( STRING ) ; } result . append ( md . get Column Name ( i ) ) ; result . append ( STRING ) ; String type = process Type ( md . get Column Type Name ( i ) , md . get Precision ( i ) ) ; result . append ( type ) ; } result . append ( STRING ) ; rs . close ( ) ; } catch ( SQL Exception e ) { throw ( new Database Exception ( e ) ) ; } return result . to String ( ) ; }
protected void notify Connection Listeners ( int type , Exception ex ) { Iterator < Connection Listener > iter ; Connection Listener l ; iter = m Connection Listeners . iterator ( ) ; while ( iter . has Next ( ) ) { l = iter . next ( ) ; l . connection Change ( new Connection Event ( this , type , m Db Utils , ex ) ) ; } }
public void delete All Dimension Rows ( ) { try { String dim Row Indexes = key Value Store . get ( Dimension Store Key Utils . get All Values Key ( ) ) ; if ( dim Row Indexes == null ) { LOG . debug ( STRING , api Name ) ; return ; } String [ ] keys = object Mapper . read Value ( dim Row Indexes , String [ ] . class ) ; Linked Hash Set < String > dim Row Keys = new Linked Hash Set < > ( Arrays . as List ( keys ) ) ; for ( String dim Row Key : dim Row Keys ) { key Value Store . remove ( dim Row Key ) ; } search Provider . set Key Value Store ( key Value Store ) ; key Value Store . put ( Dimension Store Key Utils . get Cardinality Key ( ) , STRING ) ; String all Values Key = Dimension Store Key Utils . get All Values Key ( ) ; key Value Store . put ( all Values Key , STRING ) ; } catch ( IO Exception e ) { LOG . error ( STRING , e ) ; throw new Runtime Exception ( e ) ; } }
public Element simulate ( final List < Instruction > instructions ) { lock . lock ( ) ; try { return Element = null ; return simulate Internal ( instructions ) ; } finally { lock . unlock ( ) ; } }
public static List < Abstract Insn Node > find Invocations Of ( Insn List insn List , Method expected Method ) { Validate . not Null ( insn List ) ; Validate . not Null ( expected Method ) ; List < Abstract Insn Node > ret = new Array List < > ( ) ; Type expected Method Desc = Type . get Type ( expected Method ) ; Type expected Method Owner = Type . get Type ( expected Method . get Declaring Class ( ) ) ; String expected Method Name = expected Method . get Name ( ) ; Iterator < Abstract Insn Node > it = insn List . iterator ( ) ; while ( it . has Next ( ) ) { Abstract Insn Node instruction Node = it . next ( ) ; Type method Desc ; Type method Owner ; String method Name ; if ( instruction Node instanceof Method Insn Node ) { Method Insn Node method Insn Node = ( Method Insn Node ) instruction Node ; method Desc = Type . get Type ( method Insn Node . desc ) ; method Owner = Type . get Object Type ( method Insn Node . owner ) ; method Name = expected Method . get Name ( ) ; } else { continue ; } if ( method Desc . equals ( expected Method Desc ) && method Owner . equals ( expected Method Owner ) && method Name . equals ( expected Method Name ) ) { ret . add ( instruction Node ) ; } } return ret ; }
public void test Compare To Neg Neg 1 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int a Sign = - NUM ; int b Sign = - NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; assert Equals ( - NUM , a Number . compare To ( b Number ) ) ; }
public int add Point ( Grab Point gp , int position ) { if ( gp == null ) { return - NUM ; } int x = gp . get X ( ) ; int y = gp . get Y ( ) ; int render Type = poly . get Render Type ( ) ; Projection proj = get Projection ( ) ; if ( render Type == OM Graphic . RENDERTYPE LATLON ) { Debug . message ( STRING , STRING ) ; if ( proj != null ) { double [ ] ll = poly . get Lat Lon Array ( ) ; int actual Position = ( position == Integer . MAX VALUE ? ll . length : position * NUM ) ; Lat Lon Point llpnt = proj . inverse ( x , y , new Lat Lon Point . Double ( ) ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + x + STRING + y + STRING + llpnt + STRING ) ; for ( int j = NUM ; j < ll . length ; j += NUM ) { Debug . output ( ll [ j ] + STRING + ll [ j + NUM ] ) ; } } double [ ] newll = new double [ ll . length + NUM ] ; double newlat = llpnt . get Rad Lat ( ) ; double newlon = llpnt . get Rad Lon ( ) ; if ( actual Position >= ll . length ) { if ( ll . length != NUM ) { System . arraycopy ( ll , NUM , newll , NUM , ll . length ) ; } newll [ ll . length ] = newlat ; newll [ ll . length + NUM ] = newlon ; position = ll . length / NUM ; } else if ( actual Position <= NUM ) { System . arraycopy ( ll , NUM , newll , NUM , ll . length ) ; newll [ NUM ] = newlat ; newll [ NUM ] = newlon ; position = NUM ; } else { newll [ actual Position ] = newlat ; newll [ actual Position + NUM ] = newlon ; System . arraycopy ( ll , NUM , newll , NUM , actual Position ) ; System . arraycopy ( ll , actual Position , newll , actual Position + NUM , ll . length - actual Position ) ; } poly . set Location ( newll , OM Graphic . RADIANS ) ; } } else if ( render Type == OM Graphic . RENDERTYPE XY ) { Debug . message ( STRING , STRING ) ; int current Length = poly . xs . length ; int [ ] newxs = new int [ current Length + NUM ] ; int [ ] newys = new int [ current Length + NUM ] ; if ( position >= current Length ) { System . arraycopy ( poly . xs , NUM , newxs , NUM , current Length ) ; System . arraycopy ( poly . ys , NUM , newys , NUM , current Length ) ; newxs [ current Length ] = x ; newys [ current Length ] = y ; position = current Length ; } else if ( position <= NUM ) { System . arraycopy ( poly . xs , NUM , newxs , NUM , current Length ) ; System . arraycopy ( poly . ys , NUM , newys , NUM , current Length ) ; newxs [ NUM ] = x ; newys [ NUM ] = y ; position = NUM ; } else { newxs [ position ] = x ; newys [ position ] = y ; System . arraycopy ( poly . xs , NUM , newxs , NUM , position ) ; System . arraycopy ( poly . xs , position , newxs , position + NUM , current Length - position ) ; System . arraycopy ( poly . ys , NUM , newys , NUM , position ) ; System . arraycopy ( poly . ys , position , newys , position + NUM , current Length - position ) ; } poly . set Location ( newxs , newys ) ; } else { Debug . message ( STRING , STRING ) ; int current Length = poly . xs . length ; int [ ] newxs = new int [ current Length + NUM ] ; int [ ] newys = new int [ current Length + NUM ] ; if ( position >= current Length ) { position = current Length ; System . arraycopy ( poly . xs , NUM , newxs , NUM , current Length ) ; System . arraycopy ( poly . ys , NUM , newys , NUM , current Length ) ; } else if ( position <= NUM ) { position = NUM ; System . arraycopy ( poly . xs , NUM , newxs , NUM , current Length ) ; System . arraycopy ( poly . ys , NUM , newys , NUM , current Length ) ; } else { System . arraycopy ( poly . xs , NUM , newxs , NUM , position ) ; System . arraycopy ( poly . xs , position , newxs , position + NUM , current Length - position ) ; System . arraycopy ( poly . ys , NUM , newys , NUM , position ) ; System . arraycopy ( poly . ys , position , newys , position + NUM , current Length - position ) ; } int offset X ; int offset Y ; if ( gpo . get X ( ) == - NUM && gpo . get Y ( ) == - NUM ) { offset X = proj . get Width ( ) / NUM ; offset Y = proj . get Height ( ) / NUM ; } else { offset X = gpo . get X ( ) ; offset Y = gpo . get Y ( ) ; } if ( poly . coord Mode == OM Poly . COORDMODE ORIGIN || position == NUM ) { newxs [ position ] = x - offset X ; newys [ position ] = y - offset Y ; } else { newxs [ position ] = x - offset X - newxs [ position - NUM ] ; newys [ position ] = y - offset Y - newys [ position - NUM ] ; } if ( position == NUM ) { Lat Lon Point llpnt = proj . inverse ( offset X , offset Y , new Lat Lon Point . Double ( ) ) ; poly . lat = llpnt . get Rad Lat ( ) ; poly . lon = llpnt . get Rad Lon ( ) ; } poly . set Location ( poly . lat , poly . lon , OM Graphic . RADIANS , newxs , newys ) ; } OM Arrow Head omah = poly . get Arrow Head ( ) ; poly . set Arrow Head ( null ) ; poly . set Arrow Head ( omah ) ; poly Grab Points . add ( position , gp ) ; if ( gpo != null ) { gpo . add Grab Point ( gp ) ; } poly . regenerate ( proj ) ; gp . generate ( proj ) ; return position ; }
public static void append Text ( Input Connection connection , String new Text ) { if ( connection == null ) { return ; } connection . finish Composing Text ( ) ; Char Sequence char Before Cursor = connection . get Text Before Cursor ( NUM , NUM ) ; if ( char Before Cursor != null && ! char Before Cursor . equals ( STRING ) && ( char Before Cursor . length ( ) > NUM ) ) { new Text = STRING + new Text ; } connection . set Composing Text ( new Text , NUM ) ; }
public static double cdf ( double val , double rate ) { final double v = NUM * Math . exp ( - rate * val ) ; return ( val < NUM ) ? v : NUM - v ; }
public static Data Set read Discrete ( File file , char delimiter ) throws IO Exception { return read In Discrete Data ( file , delimiter , Collections . singleton ( STRING ) ) ; }
public static String generate Native Guid ( Db Client db Client , Storage Port port ) { Storage System device = db Client . query Object ( Storage System . class , port . get Storage Device ( ) ) ; return String . format ( STRING + PORT + STRING , device Type Map . get ( device . get System Type ( ) ) , device . get Serial Number ( ) , port . get Port Network Id ( ) ) ; }
protected boolean can Paths Be Removed ( Tree Path [ ] paths ) { if ( row Mapper == null || selection == null || selection Mode == Tree Selection Model . DISCONTIGUOUS TREE SELECTION ) return BOOL ; else { Bit Set bit Set = new Bit Set ( ) ; int counter ; int path Count = paths . length ; int an Index ; int min = - NUM ; int valid Count = NUM ; Tree Path [ ] temp Path = new Tree Path [ NUM ] ; int [ ] rows ; last Paths . clear ( ) ; for ( counter = NUM ; counter < path Count ; counter ++ ) { if ( paths [ counter ] != null ) { last Paths . put ( paths [ counter ] , Boolean . TRUE ) ; } } for ( counter = selection . length - NUM ; counter >= NUM ; counter -- ) { if ( last Paths . get ( selection [ counter ] ) == null ) { temp Path [ NUM ] = selection [ counter ] ; rows = row Mapper . get Rows For Paths ( temp Path ) ; if ( rows != null && rows [ NUM ] != - NUM && ! bit Set . get ( rows [ NUM ] ) ) { valid Count ++ ; if ( min == - NUM ) min = rows [ NUM ] ; else min = Math . min ( min , rows [ NUM ] ) ; bit Set . set ( rows [ NUM ] ) ; } } } last Paths . clear ( ) ; if ( valid Count > NUM ) { for ( counter = min + valid Count - NUM ; counter >= min ; counter -- ) if ( ! bit Set . get ( counter ) ) return BOOL ; } } return BOOL ; }
public String Reader ( String s ) { this . str = s ; this . length = s . length ( ) ; }
private void update Search Style ( J Text Component c , Sea Glass Context context , String prefix ) { search Icon Width = NUM ; Object o = style . get ( context , prefix + STRING ) ; if ( o != null && o instanceof Integer ) { search Icon Width = ( Integer ) o ; } popup Icon Width = NUM ; o = style . get ( context , prefix + STRING ) ; if ( o != null && o instanceof Integer ) { popup Icon Width = ( Integer ) o ; } cancel Icon Width = NUM ; o = style . get ( context , prefix + STRING ) ; if ( o != null && o instanceof Integer ) { cancel Icon Width = ( Integer ) o ; } search Left Inner Margin = NUM ; o = style . get ( context , prefix + STRING ) ; if ( o != null && o instanceof Integer ) { search Left Inner Margin = ( Integer ) o ; } search Right Inner Margin = NUM ; o = style . get ( context , prefix + STRING ) ; if ( o != null && o instanceof Integer ) { search Right Inner Margin = ( Integer ) o ; } placeholder Color = Color . GRAY ; o = style . get ( context , STRING ) ; if ( o != null && o instanceof Color ) { placeholder Color = ( Color ) o ; } Border border = c . get Border ( ) ; if ( border == null || border instanceof UI Resource && ! ( border instanceof Text Field Border ) ) { c . set Border ( create Text Field Border ( context ) ) ; } if ( is Search Field . is In State ( c ) ) { o = c . get Client Property ( STRING ) ; if ( o != null && o instanceof String ) { placeholder Text = ( String ) o ; } else if ( placeholder Text != null ) { placeholder Text = null ; } o = c . get Client Property ( STRING ) ; if ( o != null && o instanceof Action Listener ) { if ( find Action == null ) { find Action = ( Action Listener ) o ; } } o = c . get Client Property ( STRING ) ; if ( o != null && o instanceof J Popup Menu ) { if ( find Popup == null ) { find Popup = ( J Popup Menu ) o ; } } o = c . get Client Property ( STRING ) ; if ( o != null && o instanceof Action Listener ) { if ( cancel Action == null ) { cancel Action = ( Action Listener ) o ; } } install Mouse Listeners ( ) ; } else { placeholder Text = null ; if ( find Action != null ) { find Action = null ; } if ( find Popup != null ) { find Popup = null ; } if ( cancel Action != null ) { cancel Action = null ; } uninstall Mouse Listeners ( ) ; } }
private int measure Child Collapse Margins ( View child , int parent Width Measure Spec , int width Used , int parent Height Measure Spec , int height Used , int [ ] collapsing Margins ) { final Margin Layout Params lp = ( Margin Layout Params ) child . get Layout Params ( ) ; final int left Diff = lp . left Margin - collapsing Margins [ NUM ] ; final int right Diff = lp . right Margin - collapsing Margins [ NUM ] ; final int left Margin = Math . max ( NUM , left Diff ) ; final int right Margin = Math . max ( NUM , right Diff ) ; final int h Margins = left Margin + right Margin ; collapsing Margins [ NUM ] = Math . max ( NUM , - left Diff ) ; collapsing Margins [ NUM ] = Math . max ( NUM , - right Diff ) ; final int child Width Measure Spec = get Child Measure Spec ( parent Width Measure Spec , get Padding Left ( ) + get Padding Right ( ) + h Margins + width Used , lp . width ) ; final int child Height Measure Spec = get Child Measure Spec ( parent Height Measure Spec , get Padding Top ( ) + get Padding Bottom ( ) + lp . top Margin + lp . bottom Margin + height Used , lp . height ) ; child . measure ( child Width Measure Spec , child Height Measure Spec ) ; return child . get Measured Width ( ) + h Margins ; }
public final void wait ( long timeout ) throws java . lang . Interrupted Exception { wait ( timeout , NUM ) ; }
public Multi Match Query Builder field ( String field , float boost ) { fields . add ( field ) ; if ( fields Boosts == null ) { fields Boosts = new Object Float Hash Map < > ( ) ; } fields Boosts . put ( field , boost ) ; return this ; }
ASN 1 Output Stream Writer ( final Output Stream stream , final int max Buffer Size ) { this . out = stream ; this . root Stream = stream ; this . max Buffer Size = Math . max ( max Buffer Size , BUFFER INIT SIZE ) ; this . stack Depth = - NUM ; }
public void register Sensor ( Sensor s , int i ) { if ( ( i < NUM ) || ( i > ( input Bytes [ node Type ] * NUM - NUM ) ) || ( i > MAXSENSORS ) ) { log . error ( STRING + Integer . to String ( i + NUM ) ) ; return ; } has Active Sensors = BOOL ; if ( sensor Array [ i ] == null ) { sensor Array [ i ] = s ; if ( last Used Sensor < i ) { last Used Sensor = i ; } } else { log . warn ( STRING + Integer . to String ( ( get Node Address ( ) * Serial Sensor Manager . SENSORSPERNODE ) + i + NUM ) ) ; } }
public static Object parse Primitive Value ( String value , Primitive Type primitive Type ) throws O Data Exception { switch ( primitive Type ) { case BOOLEAN : return Boolean . value Of ( value ) ; case BYTE : try { final Integer v = Integer . value Of ( value ) ; if ( v < NUM || v > PARSE INDEX ) { throw Parse Exception ( value , primitive Type , null ) ; } return v . byte Value ( ) ; } catch ( Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case DATE : try { return Local Date . parse ( value ) ; } catch ( Illegal Argument Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case DATE TIME OFFSET : try { return Zoned Date Time . parse ( value ) ; } catch ( Illegal Argument Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case DURATION : try { return Period . parse ( value ) ; } catch ( Illegal Argument Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case TIME OF DAY : try { return Local Time . parse ( value ) ; } catch ( Illegal Argument Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case DECIMAL : try { return new Big Decimal ( value ) ; } catch ( Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case DOUBLE : try { return Double . parse Double ( value ) ; } catch ( Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case SINGLE : try { return Float . parse Float ( value ) ; } catch ( Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case GUID : try { return UUID . from String ( value ) ; } catch ( Illegal Argument Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case INT 16 : try { return Short . value Of ( value ) ; } catch ( Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case INT 32 : try { return Integer . value Of ( value ) ; } catch ( Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case INT 64 : try { return Long . value Of ( value ) ; } catch ( Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; case STRING : return value ; case SBYTE : try { return Byte . value Of ( value ) ; } catch ( Number Format Exception e ) { throw Parse Exception ( value , primitive Type , e ) ; } break ; default : throw new O Data Not Implemented Exception ( STRING + primitive Type + STRING + value ) ; } return null ; }
public final double sample Sigma ( int n ) { synchronized ( lock ) { long count = count . get ( ) ; long last Count = last Std Count ; last Std Count = count ; double sum = sum . get ( ) ; double last Sum = last Std Sum ; last Std Sum = sum ; double sum Square = sum Square ; sum Square = NUM ; if ( count == last Count ) return NUM ; double avg = ( sum - last Sum ) / ( count - last Count ) ; double part = ( count - last Count ) * sum Square - sum * sum ; if ( part < NUM ) part = NUM ; double std = Math . sqrt ( part ) / ( count - last Count ) ; return scale * ( avg + n * std ) ; } }
@ Suppress Warnings ( STRING ) private boolean is Token Valid For Compression ( byte [ ] blob ) { if ( blob == null ) { return BOOL ; } String contents ; try { contents = blob Utils . to UTF 8 ( blob ) ; } catch ( Unsupported Encoding Exception e ) { return BOOL ; } if ( ! contents . starts With ( STRING ) ) { return BOOL ; } if ( ! contents . ends With ( STRING ) ) { return BOOL ; } Set < String > keys = new Hash Set < String > ( ) ; keys . add All ( replacement . key Set ( ) ) ; keys . add All ( replacement . values ( ) ) ; for ( String key : keys ) { if ( contents . contains ( key ) ) { return BOOL ; } } return BOOL ; }
public static Encryption Key [ ] acquire Secret Keys ( Principal Name princ , String keytab ) { if ( princ == null ) throw new Illegal Argument Exception ( STRING ) ; Key Tab ktab = Key Tab . get Instance ( keytab ) ; return ktab . read Service Keys ( princ ) ; }
void visit And Break Modifiers ( Modifiers Tree modifiers , Direction annotation Direction , Optional < Break Tag > declaration Annotation Break ) { builder . add All ( visit Modifiers ( modifiers , annotation Direction , declaration Annotation Break ) ) ; }
public static List < Vm > create Vm List ( int broker Id , int vms Number ) { List < Vm > vms = new Array List < Vm > ( ) ; for ( int i = NUM ; i < vms Number ; i ++ ) { int vm Type = i / ( int ) Math . ceil ( ( double ) vms Number / Constants . VM TYPES ) ; vms . add ( new Power Vm ( i , broker Id , Constants . VM MIPS [ vm Type ] , Constants . VM PES [ vm Type ] , Constants . VM RAM [ vm Type ] , Constants . VM BW , Constants . VM SIZE , NUM , STRING , new Cloudlet Scheduler Dynamic Workload ( Constants . VM MIPS [ vm Type ] , Constants . VM PES [ vm Type ] ) , Constants . SCHEDULING INTERVAL ) ) ; } return vms ; }
private static boolean has Valid Parent Chain ( Resource Bundle bundle ) { long now = System . current Time Millis ( ) ; while ( bundle != null ) { if ( bundle . expired ) { return BOOL ; } Cache Key key = bundle . cache Key ; if ( key != null ) { long expiration Time = key . expiration Time ; if ( expiration Time >= NUM && expiration Time <= now ) { return BOOL ; } } bundle = bundle . parent ; } return BOOL ; }
private String collapse Slashes ( String path ) { int length = path . length ( ) ; if ( length < NUM ) return path ; if ( path . index Of ( STRING , NUM ) == - NUM ) return path ; char [ ] result = new char [ path . length ( ) ] ; int count = NUM ; boolean has Previous = BOOL ; char [ ] characters = path . to Char Array ( ) ; for ( int index = NUM ; index < characters . length ; index ++ ) { char c = characters [ index ] ; if ( c == SEPARATOR ) { if ( has Previous ) { if ( device == null && index == NUM ) { result [ count ] = c ; count ++ ; } } else { has Previous = BOOL ; result [ count ] = c ; count ++ ; } } else { has Previous = BOOL ; result [ count ] = c ; count ++ ; } } return new String ( result , NUM , count ) ; }
protected byte [ ] read Last Chunk ( long index ) throws IO Exception , Invalid Key Exception , Invalid Algorithm Parameter Exception , Illegal Block Size Exception , Bad Padding Exception , File Encryption Exception , Short Buffer Exception { long n Remaining = backing Random Access File . length ( ) - ( chunk Offset ( index ) ) ; if ( n Remaining > CHUNK ENC SIZE ) { throw new File Encryption Exception ( STRING ) ; } else if ( n Remaining <= CHUNK IV SIZE ) { return new byte [ ] { } ; } long oldpos = backing Random Access File . get File Pointer ( ) ; backing Random Access File . seek ( chunk Offset ( index ) ) ; byte [ ] iv = new byte [ CHUNK IV SIZE ] ; int ret = backing Random Access File . read ( iv ) ; if ( ret != CHUNK IV SIZE ) { throw new File Encryption Exception ( STRING ) ; } Iv Parameter Spec spec = new Iv Parameter Spec ( iv ) ; last Chunk Cipher . init ( Cipher . DECRYPT MODE , get File Key ( ) , spec ) ; n Remaining -= CHUNK IV SIZE ; byte [ ] buf = new byte [ ( int ) n Remaining ] ; byte [ ] res ; ret = backing Random Access File . read ( buf ) ; backing Random Access File . seek ( oldpos ) ; if ( ret != n Remaining ) { throw new File Encryption Exception ( STRING ) ; } res = last Chunk Cipher . do Final ( buf ) ; if ( ( res == null ) || ( res . length != ( n Remaining - CHUNK TLEN ) ) ) { throw new File Encryption Exception ( STRING ) ; } else { return res ; } }
public static boolean is Default Type ( String schema ) { for ( int i = ALL MEDIA TYPES . length ; -- i >= NUM ; ) if ( schema . equals ( ALL MEDIA TYPES [ i ] . schema ) ) return BOOL ; return BOOL ; }
public void update Module ( org . jboss . modules . Module module , Dependency Spec dependency Spec ) throws Module Load Exception { Module Identifier mi = module . get Identifier ( ) ; List < Dependency Spec > deps = dependencies . get ( mi ) ; if ( deps == null ) return ; deps . add ( dependency Spec ) ; set And Relink Dependencies ( module , deps ) ; refresh Resource Loaders ( module ) ; relink ( mi , new Hash Set < Module Identifier > ( ) ) ; }
public static boolean is Network Available ( Context context ) { Connectivity Manager connectivity Manager = ( Connectivity Manager ) context . get System Service ( Context . CONNECTIVITY SERVICE ) ; Network Info info = connectivity Manager . get Active Network Info ( ) ; return ( info != null && info . is Connected ( ) ) ; }
public static String random Regexpish String ( Random r , int max Length ) { final String Builder regexp = new String Builder ( max Length ) ; for ( int i = next Int ( r , NUM , max Length ) ; i > NUM ; i -- ) { if ( r . next Boolean ( ) ) { regexp . append ( ( char ) Random Numbers . random Int Between ( r , STRING , STRING ) ) ; } else { regexp . append ( Random Picks . random From ( r , ops ) ) ; } } return regexp . to String ( ) ; }
@ Override public Expected Partition Values Information create Expected Partition Values ( Expected Partition Values Create Request expected Partition Values Create Request ) { validate Expected Partition Values Create Request ( expected Partition Values Create Request ) ; Partition Key Group Entity partition Key Group Entity = partition Key Group Dao Helper . get Partition Key Group Entity ( expected Partition Values Create Request . get Partition Key Group Key ( ) ) ; Map < String , Expected Partition Value Entity > expected Partition Value Entity Map = get Expected Partition Value Entity Map ( partition Key Group Entity . get Expected Partition Values ( ) ) ; for ( String expected Partition Value : expected Partition Values Create Request . get Expected Partition Values ( ) ) { if ( expected Partition Value Entity Map . contains Key ( expected Partition Value ) ) { throw new Illegal Argument Exception ( String . format ( STRING , expected Partition Value , partition Key Group Entity . get Partition Key Group Name ( ) ) ) ; } } Collection < Expected Partition Value Entity > created Expected Partition Value Entities = new Array List < > ( ) ; for ( String expected Partition Value : expected Partition Values Create Request . get Expected Partition Values ( ) ) { Expected Partition Value Entity expected Partition Value Entity = new Expected Partition Value Entity ( ) ; created Expected Partition Value Entities . add ( expected Partition Value Entity ) ; expected Partition Value Entity . set Partition Key Group ( partition Key Group Entity ) ; expected Partition Value Entity . set Partition Value ( expected Partition Value ) ; expected Partition Value Dao . save And Refresh ( expected Partition Value Entity ) ; } expected Partition Value Dao . save And Refresh ( partition Key Group Entity ) ; return create Expected Partition Values Information From Entities ( partition Key Group Entity , created Expected Partition Value Entities ) ; }
public String to String ( ) { String Buffer text = new String Buffer ( ) ; text . append ( STRING ) ; return text . to String ( ) ; }
public void add Details Loaded Listener ( @ Not Null Runnable runnable ) { my Loading Finished Listeners . add ( runnable ) ; }
public Object extract Hard Ref ( Object o ) { Weak Reference w = ( Weak Reference ) o ; if ( w != null ) { return w . get ( ) ; } return null ; }
public static String format Integer ( int number ) { return int Format . format ( number ) ; }
protected void process Map ( Byte Buffer buffer , int buffer Start Page ) { int byte Count = NUM ; while ( buffer . has Remaining ( ) ) { byte b = buffer . get ( ) ; if ( b != ( byte ) NUM ) { for ( int i = NUM ; i < NUM ; i ++ ) { if ( ( b & ( NUM << i ) ) != NUM ) { int page Number Offset = ( byte Count * NUM + i ) + buffer Start Page ; int page Number = bit Index To Page Number ( page Number Offset , Page Channel . INVALID PAGE NUMBER ) ; if ( ! is Page Within Range ( page Number ) ) { throw new Illegal State Exception ( STRING + page Number + STRING + start Page + STRING + end Page ) ; } page Numbers . set ( page Number Offset ) ; } } } byte Count ++ ; } }
public void write Raw Bytes ( final byte [ ] value , int offset , int length ) throws IO Exception { if ( limit - position >= length ) { System . arraycopy ( value , offset , buffer , position , length ) ; position += length ; } else { final int bytes Written = limit - position ; System . arraycopy ( value , offset , buffer , position , bytes Written ) ; offset += bytes Written ; length -= bytes Written ; position = limit ; refresh Buffer ( ) ; if ( length <= limit ) { System . arraycopy ( value , offset , buffer , NUM , length ) ; position = length ; } else { output . write ( value , offset , length ) ; } } }
private void mark As Incomplete ( VM vm ) throws IO Exception { File backup Dir = get Backup Dir For Member ( get Baseline Dir ( ) , get Member Id ( vm ) ) ; assert True ( backup Dir . exists ( ) ) ; File incomplete = new File ( backup Dir , Backup Manager . INCOMPLETE BACKUP ) ; incomplete . create New File ( ) ; }
@ Request Mapping ( value = STRING ) public void slo Error ( Locale locale , @ Path Variable ( value = STRING ) String tenant , Http Servlet Response response ) throws IO Exception { logger . info ( STRING + locale . to String ( ) + STRING + tenant ) ; slo Default Tenant Binding Error ( locale , response ) ; }
public synchronized void check State ( State required State ) throws Illegal State Exception { if ( required State != current State ) { throw new Illegal State Exception ( String . format ( Locale . US , STRING , required State , current State ) ) ; } }
@ Override public void on Bind View Holder ( Movie View Holder holder , int position ) { Movie movie = movies . get ( position ) ; holder . set Movie ( movie ) ; }
public Version Naming Configuration ( String search Version Regex , String replace Version Regex , Branching Policy ... policies ) { this . branch Policies = new Linked List < > ( Arrays . as List ( policies ) ) ; this . search Pattern = Pattern . compile ( search Version Regex ) ; this . replace Version Regex = replace Version Regex ; }
private boolean poll Stats Broker Topic ( Destination topic ) { stats Message Listener . set Destination ( topic ) ; LOGGER . info ( STRING + get Queue Name ( topic ) ) ; jms Template . execute ( STATS BROKER DESTINATION + get Topic Name ( topic ) , new Producer Callback Impl ( stats Queue ) ) ; try { Thread . sleep ( NUM * NUM ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } return stats Message Listener . get Stats ( ) != null ; }
public static String resolve Pathname ( final String pathname ) { return ( String Utils . is Blank ( pathname ) ? pathname : IO Utils . try Get Canonical Path Else Get Absolute Path ( new File ( pathname ) ) ) ; }
public String ruby Type Name ( Type Ref type Ref ) { switch ( type Ref . get Kind ( ) ) { case TYPE MESSAGE : return ruby Type Name For Proto Element ( type Ref . get Message Type ( ) ) ; case TYPE ENUM : return ruby Type Name For Proto Element ( type Ref . get Enum Type ( ) ) ; default : { String name = PRIMITIVE TYPE NAMES . get ( type Ref . get Kind ( ) ) ; if ( ! Strings . is Null Or Empty ( name ) ) { return name ; } throw new Illegal Argument Exception ( STRING + type Ref . get Kind ( ) ) ; } } }
public Set < State > post Event ( Event Data event Data , Long state Machine Instance Id , String correlation Id ) { State Machine state Machine = null ; if ( state Machine Instance Id != null ) { state Machine = retrieve State Machine ( state Machine Instance Id ) ; } else if ( correlation Id != null ) { state Machine = retrieve State Machine By Correlation Id ( correlation Id ) ; state Machine Instance Id = ( state Machine == null ) ? null : state Machine . get Id ( ) ; } if ( state Machine == null ) throw new Unknown State Machine ( STRING + state Machine Instance Id + STRING + correlation Id + STRING ) ; Event event = events DAO . find By SM Id And Name ( state Machine Instance Id , event Data . get Name ( ) ) ; if ( event == null ) throw new Illegal Event Exception ( STRING + state Machine Instance Id + STRING + event Data . get Name ( ) + STRING ) ; event . set Status ( Event . Event Status . triggered ) ; event . set Event Data ( event Data . get Data ( ) ) ; event . set Event Source ( event Data . get Event Source ( ) ) ; events DAO . update Event ( event ) ; Context context = new RAM Context ( System . current Time Millis ( ) , null , state Machine ) ; final Set < State > dependant States = context . get Dependant States ( event Data . get Name ( ) ) ; logger . debug ( STRING , dependant States , event Data . get Name ( ) ) ; Set < State > executable States = get Executable States ( dependant States , state Machine Instance Id ) ; logger . debug ( STRING , executable States , event Data . get Name ( ) ) ; execute States ( state Machine Instance Id , executable States ) ; return executable States ; }
protected void linear Layout ( Visual Table labels ) { Rectangle 2 D b = get Layout Bounds ( ) ; double breadth = get Breadth ( b ) ; double span = m hi - m lo ; double pspan = m prevhi - m prevlo ; double vlo = NUM ; if ( m lo >= NUM ) { vlo = Math . pow ( NUM , Math . floor ( Math Lib . log 10 ( m lo ) ) ) ; } else { vlo = - Math . pow ( NUM , NUM + Math . floor ( Math Lib . log 10 ( - m lo ) ) ) ; } Iterator iter = labels . tuples ( ) ; while ( iter . has Next ( ) ) { Visual Item item = ( Visual Item ) iter . next ( ) ; reset ( item ) ; double v = item . get Double ( VALUE ) ; double x = span == NUM ? NUM : ( ( v - m lo ) / span ) * breadth ; set ( item , x , b ) ; } Index index = labels . index ( VALUE ) ; double step = get Linear Step ( span , span == NUM ? NUM : breadth / span ) ; if ( step == NUM ) step = NUM ; int r ; for ( double x , v = vlo ; v <= m hi ; v += step ) { x = ( ( v - m lo ) / span ) * breadth ; if ( x < - NUM ) { continue ; } else if ( ( r = index . get ( v ) ) >= NUM ) { Visual Item item = labels . get Item ( r ) ; item . set Visible ( BOOL ) ; item . set End Visible ( BOOL ) ; } else { Visual Item item = labels . add Item ( ) ; item . set ( LABEL , m nf . format ( v ) ) ; item . set Double ( VALUE , v ) ; double f = pspan == NUM ? NUM : ( ( v - m prevlo ) / pspan ) ; if ( f <= NUM || f >= NUM ) item . set Start Visible ( BOOL ) ; set ( item , f * breadth , b ) ; set ( item , x , b ) ; } } }
public Attribute Filler ( Attributes Impl attributes ) { attributes . clear ( ) ; atts = attributes ; po = null ; }
public static non terminal find ( String with name ) { if ( with name == null ) return null ; else return ( non terminal ) all . get ( with name ) ; }
public @ Check For Null Block create New Block ( @ Nonnull String system Name , @ Check For Null String user Name ) throws Illegal Argument Exception { Block r ; if ( user Name != null && ! user Name . equals ( STRING ) ) { r = get By User Name ( user Name ) ; if ( r != null ) { return null ; } } r = get By System Name ( system Name ) ; if ( r != null ) { return null ; } String s Name = system Name . to Upper Case ( ) ; r = new Block ( s Name , user Name ) ; register ( r ) ; if ( system Name . starts With ( STRING ) ) { try { int auto Number = Integer . parse Int ( system Name . substring ( NUM ) ) ; if ( auto Number > last Auto Block Ref ) { last Auto Block Ref = auto Number ; } } catch ( Number Format Exception e ) { log . warn ( STRING + system Name + STRING ) ; } } try { r . set Block Speed ( STRING ) ; } catch ( jmri . Jmri Exception ex ) { log . error ( ex . to String ( ) ) ; } return r ; }
public Object execute Command ( final int ID , Object [ ] args ) { if ( args != null && args . length == NUM && args [ NUM ] == null ) { args = null ; } Object status = null ; current GUI . set Executing Command ( BOOL ) ; final Map jpedal Action Handlers = ( Map ) decode pdf . get External Handler ( Options . J Pedal Action Handlers ) ; if ( jpedal Action Handlers != null ) { final J Pedal Action Handler jpedal Action = ( J Pedal Action Handler ) jpedal Action Handlers . get ( ID ) ; if ( jpedal Action != null ) { jpedal Action . action Performed ( current GUI , this ) ; return null ; } } if ( ! Shared Viewer . is FX ( ) ) { status = execute Swing Command ( ID , args , status ) ; } if ( ! current GUI . is Command In Thread ( ) ) { current GUI . set Executing Command ( BOOL ) ; } return status ; }
private static String substitute Properties ( String str ) { str = str . trim ( ) ; Matcher matcher = PROP REGEX . matcher ( str ) ; String Buffer buf = new String Buffer ( ) ; while ( matcher . find ( ) ) { String match = matcher . group ( ) ; if ( match . length ( ) >= NUM ) { String key = match . substring ( NUM , match . length ( ) - NUM ) ; String val = System . getenv ( key ) ; if ( val == null ) val = System . get Property ( key ) ; if ( val != null ) { match = val . replace All ( STRING , STRING ) ; } else if ( match . starts With ( STRING ) ) match = match . replace ( STRING , STRING ) ; } matcher . append Replacement ( buf , match ) ; } matcher . append Tail ( buf ) ; return buf . to String ( ) ; }
public Char Buffer ( String string , int offset , int length ) { int capacity = Math . max ( length , MIN CAPACITY ) ; init ( new char [ capacity ] , NUM , length ) ; string . get Chars ( offset , length , buffer ( ) , NUM ) ; }
private void update Promo Visibility ( float percentage ) { if ( is Promo Visible ( ) ) { m Promo Visible = BOOL ; m Promo Height Px = Math . round ( Math Utils . clamp ( percentage * m Promo Content Height Px , NUM , m Promo Content Height Px ) ) ; m Promo Opacity = percentage ; } else { m Promo Visible = BOOL ; m Promo Height Px = NUM ; m Promo Opacity = NUM ; } }
public void update Geometry ( int row , Geometry geometry ) { set Value At ( geometry , row , get Geometry Field Index ( ) ) ; }
@ Override public void do after propagation ( ) { for ( Pt Ins Interval Manager pim : pt objs . values ( ) ) { pim . flush ( ) ; } new pts = new Hash Map < Alloc Node , Pt Ins Interval Manager > ( ) ; }
public static List < Statement > random Statements About ( String s , int count ) { List < Statement > statements = new Array List < > ( ) ; for ( int i = NUM ; i < count ; i ++ ) { String p = STRING + random Int ( ) ; Literal Impl o = random Date ( ) ; statements . add ( statement ( s , p , o ) ) ; } return statements ; }
public static String response ( final String c Question , final String c Title , final String c Default , final boolean b Password , final String c Label ) { final Border Layout layout = new Border Layout ( ) ; layout . set Hgap ( NUM ) ; final J Panel panel = new J Panel ( layout ) ; final J Label question = new J Label ( c Question ) ; final J Text Field field ; if ( b Password ) { field = new J Password Field ( ) ; } else { field = new J Text Field ( ) ; } if ( c Default != null ) { field . set Text ( c Default ) ; } final String title ; if ( c Title != null ) { title = c Title ; } else { title = STRING ; } panel . add ( question , Border Layout . NORTH ) ; if ( c Label != null ) { final J Label label = new J Label ( c Label ) ; panel . add ( label , Border Layout . WEST ) ; } panel . add ( field , Border Layout . CENTER ) ; final String [ ] options = { STRING , STRING } ; final int option = J Option Pane . show Option Dialog ( null , panel , title , J Option Pane . NO OPTION , J Option Pane . PLAIN MESSAGE , null , options , options [ NUM ] ) ; if ( option == NUM ) { return field . get Text ( ) ; } else { return null ; } }
public boolean dyn Init ( ) { return m data . load ( ) ; }
static File Channel new File Channel ( int dfd , Unix Path path , String path For Permission Check , Set < ? extends Open Option > options , int mode ) throws Unix Exception { Flags flags = Flags . to Flags ( options ) ; if ( ! flags . read && ! flags . write ) { if ( flags . append ) { flags . write = BOOL ; } else { flags . read = BOOL ; } } if ( flags . read && flags . append ) throw new Illegal Argument Exception ( STRING ) ; if ( flags . append && flags . truncate Existing ) throw new Illegal Argument Exception ( STRING ) ; File Descriptor fd Obj = open ( dfd , path , path For Permission Check , flags , mode ) ; return File Channel Impl . open ( fd Obj , path . to String ( ) , flags . read , flags . write , flags . append , null ) ; }
private void baseline Layout ( int origin , int size ) { int ascent ; int descent ; if ( baseline Anchored To Top ) { ascent = pref Ascent ; descent = size - ascent ; } else { ascent = size - pref Descent ; descent = pref Descent ; } for ( int counter = springs . size ( ) - NUM ; counter >= NUM ; counter -- ) { Spring spring = get Spring ( counter ) ; int alignment = spring . get Alignment ( ) ; if ( alignment == NO ALIGNMENT || alignment == BASELINE ) { int baseline = spring . get Baseline ( ) ; if ( baseline >= NUM ) { int spring Max = spring . get Maximum Size ( VERTICAL ) ; int spring Pref = spring . get Preferred Size ( VERTICAL ) ; int height = spring Pref ; int y ; switch ( spring . get Baseline Resize Behavior ( ) ) { case Component . BRB CONSTANT ASCENT : y = origin + ascent - baseline ; height = Math . min ( descent , spring Max - baseline ) + baseline ; break ; case Component . BRB CONSTANT DESCENT : height = Math . min ( ascent , spring Max - spring Pref + baseline ) + ( spring Pref - baseline ) ; y = origin + ascent + ( spring Pref - baseline ) - height ; break ; default : y = origin + ascent - baseline ; break ; } spring . set Size ( VERTICAL , y , height ) ; } else { set Child Size ( spring , VERTICAL , origin , size ) ; } } else { set Child Size ( spring , VERTICAL , origin , size ) ; } } }
public static double read Double ( final JSON Array json Array , final int index , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Array . get Double ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT ARRAY , index ) ) ; } double value = NUM ; if ( ! json Array . is Null ( index ) ) { value = json Array . get Double ( index ) ; } return value ; }
public Storage Policy Create Request create Storage Policy Create Request ( Storage Policy Key storage Policy Key , String storage Policy Rule Type , Integer storage Policy Rule Value , String business Object Definition Namespace , String business Object Definition Name , String business Object Format Usage , String business Object Format File Type , String storage Name , String destination Storage Name , String storage Policy Status ) { Storage Policy Create Request request = new Storage Policy Create Request ( ) ; request . set Storage Policy Key ( storage Policy Key ) ; Storage Policy Rule storage Policy Rule = new Storage Policy Rule ( ) ; request . set Storage Policy Rule ( storage Policy Rule ) ; storage Policy Rule . set Rule Type ( storage Policy Rule Type ) ; storage Policy Rule . set Rule Value ( storage Policy Rule Value ) ; Storage Policy Filter storage Policy Filter = new Storage Policy Filter ( ) ; request . set Storage Policy Filter ( storage Policy Filter ) ; storage Policy Filter . set Namespace ( business Object Definition Namespace ) ; storage Policy Filter . set Business Object Definition Name ( business Object Definition Name ) ; storage Policy Filter . set Business Object Format Usage ( business Object Format Usage ) ; storage Policy Filter . set Business Object Format File Type ( business Object Format File Type ) ; storage Policy Filter . set Storage Name ( storage Name ) ; Storage Policy Transition storage Policy Transition = new Storage Policy Transition ( ) ; request . set Storage Policy Transition ( storage Policy Transition ) ; storage Policy Transition . set Destination Storage Name ( destination Storage Name ) ; request . set Status ( storage Policy Status ) ; return request ; }
private String tree To String ( ) { String Buffer text = new String Buffer ( ) ; if ( m top Of Tree == null ) { return STRING ; } text . append ( STRING + ( ( m use Unpruned ) ? STRING : STRING ) + ( ( m regression Tree ) ? STRING : STRING ) + STRING ) ; if ( m smooth Predictions == BOOL ) { text . append ( STRING ) ; } text . append ( m top Of Tree . tree To String ( NUM ) ) ; text . append ( m top Of Tree . print Leaf Models ( ) ) ; text . append ( STRING + m top Of Tree . number Of Linear Models ( ) ) ; return text . to String ( ) ; }
public static Object clone ( Object array ) { Class < ? > component Type = get Component Type ( array . get Class ( ) ) ; int dims [ ] = get Array Lengths ( array ) ; Object [ ] elements = ( Object [ ] ) mux Array ( array , dims , component Type ) ; return demux Array ( elements , dims , component Type ) ; }
public static boolean any Misbehave ( Formatter formatter , List < File > problem Files ) { long start = System . current Time Millis ( ) ; for ( File problem : problem Files ) { Padded Cell padded = Padded Cell . check ( formatter , problem ) ; if ( padded . misbehaved ( ) ) { return BOOL ; } if ( System . current Time Millis ( ) - start > MAX MS DETERMINING MISBEHAVIOR ) { return BOOL ; } } return BOOL ; }
public void label Distances ( Hypergraph < V , E > graph , Set < V > root Set ) { initialize ( graph , root Set ) ; int distance = NUM ; while ( BOOL ) { List < V > new List = new Array List < V > ( ) ; for ( V current Vertex : m Current List ) { if ( graph . contains Vertex ( current Vertex ) ) { for ( V next : graph . get Successors ( current Vertex ) ) { visit New Vertex ( current Vertex , next , distance , new List ) ; } } } if ( new List . size ( ) == NUM ) break ; m Current List = new List ; distance ++ ; } for ( V v : m Unvisited Vertices ) { distance Decorator . put ( v , new Integer ( - NUM ) ) ; } }
public static java . lang . String to String ( double d ) { double m = Math . abs ( d ) ; if ( d == POSITIVE INFINITY ) { return STRING ; } else if ( d == NEGATIVE INFINITY ) { return STRING ; } else if ( d == NUM ) { return STRING ; } else if ( m >= NUM && m < NUM ) { String str = to String Impl ( d , BOOL ) ; char [ ] chars = str . to Char Array ( ) ; int i = chars . length - NUM ; char c ; while ( i >= NUM && ( c = chars [ i ] ) == STRING ) { i -- ; } if ( i < NUM || str . index Of ( STRING ) == - NUM ) { return str ; } else if ( chars [ i ] == STRING || chars [ i ] == STRING ) { i ++ ; } return str . substring ( NUM , i + NUM ) ; } else { return to String Impl ( d , BOOL ) ; } }
public Log Stream print ( char c ) { if ( ps != null ) { indent ( ) ; line Buffer . append ( c ) ; if ( c == STRING ) { if ( line Buffer . index Of ( LINE SEPARATOR , line Buffer . length ( ) - LINE SEPARATOR . length ( ) ) != - NUM ) { flush Line ( BOOL ) ; } } } return this ; }
public final static Header Element [ ] parse Elements ( final String value , Header Value Parser parser ) throws Parse Exception { if ( value == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( parser == null ) parser = Save Header Value Parser . DEFAULT ; Char Array Buffer buffer = new Char Array Buffer ( value . length ( ) ) ; buffer . append ( value ) ; Save Parser Cursor cursor = new Save Parser Cursor ( NUM , value . length ( ) ) ; return parser . parse Elements ( buffer , cursor ) ; }
public Interval gap ( Readable Interval interval ) { interval = Date Time Utils . get Readable Interval ( interval ) ; long other Start = interval . get Start Millis ( ) ; long other End = interval . get End Millis ( ) ; long this Start = get Start Millis ( ) ; long this End = get End Millis ( ) ; if ( this Start > other End ) { return new Interval ( other End , this Start , get Chronology ( ) ) ; } else if ( other Start > this End ) { return new Interval ( this End , other Start , get Chronology ( ) ) ; } else { return null ; } }
public void test Get Local Name 1 ( ) throws Throwable { Document doc ; Node List element List ; Element test Addr ; Attr addr Attr ; String local Name ; doc = ( Document ) load ( STRING , builder ) ; element List = doc . get Elements By Tag Name ( STRING ) ; test Addr = ( Element ) element List . item ( NUM ) ; assert Not Null ( STRING , test Addr ) ; addr Attr = test Addr . get Attribute Node ( STRING ) ; local Name = addr Attr . get Local Name ( ) ; assert Equals ( STRING , STRING , local Name ) ; }
public boolean is Verb ( ) { return type String . starts With ( VERB ) ; }
public String encode ( String decoded ) { Json Object object = new Json Object ( decoded ) ; String payload String ; Json Object payload Object = object . get Json Object ( STRING ) ; if ( payload Object != null ) { payload String = payload Object . encode ( ) ; } else { payload String = object . get String ( STRING ) ; } if ( payload String != null ) { object . put ( PAYLOAD , payload String . get Bytes ( Charset . for Name ( UTF 8 ) ) ) ; object . remove ( STRING ) ; object . remove ( STRING ) ; } int length = NUM ; if ( object . contains Key ( PAYLOAD ) ) { length = object . get Binary ( PAYLOAD ) . length ; } Json Array new Headers = new Json Array ( ) ; for ( Object header Obj : object . get Json Array ( STRING ) ) { Json Array header = ( Json Array ) header Obj ; String key = header . get String ( NUM ) ; if ( key . equals Ignore Case ( STRING ) ) { Json Array content Length Header = new Json Array ( ) ; content Length Header . add ( STRING ) ; content Length Header . add ( Integer . to String ( length ) ) ; new Headers . add ( content Length Header ) ; } else { new Headers . add ( header ) ; } } object . put ( STRING , new Headers ) ; return object . to String ( ) ; }
private long download Index Files ( boolean download Complete Index , Directory index Dir , Directory tmp Index Dir , long latest Generation ) throws Exception { if ( LOG . is Debug Enabled ( ) ) { LOG . debug ( STRING + Arrays . as List ( index Dir . list All ( ) ) ) ; } long bytes Downloaded = NUM ; for ( Map < String , Object > file : files To Download ) { String filename = ( String ) file . get ( NAME ) ; long size = ( Long ) file . get ( SIZE ) ; Compare Result compare Result = compare File ( index Dir , filename , size , ( Long ) file . get ( CHECKSUM ) ) ; if ( ! compare Result . equal || download Complete Index || files To Always Download If No Checksums ( filename , size , compare Result ) ) { dir File Fetcher = new Directory File Fetcher ( tmp Index Dir , file , ( String ) file . get ( NAME ) , FILE , latest Generation ) ; current File = file ; dir File Fetcher . fetch File ( ) ; bytes Downloaded += dir File Fetcher . get Bytes Downloaded ( ) ; files Downloaded . add ( new Hash Map < > ( file ) ) ; } else { LOG . info ( STRING + file . get ( NAME ) + STRING ) ; } } return bytes Downloaded ; }
private static Windows File Attributes from File Information ( long address , int reparse Tag ) { int file Attrs = unsafe . get Int ( address + OFFSETOF FILE INFORMATION ATTRIBUTES ) ; long creation Time = unsafe . get Long ( address + OFFSETOF FILE INFORMATION CREATETIME ) ; long last Access Time = unsafe . get Long ( address + OFFSETOF FILE INFORMATION LASTACCESSTIME ) ; long last Write Time = unsafe . get Long ( address + OFFSETOF FILE INFORMATION LASTWRITETIME ) ; long size = ( ( long ) ( unsafe . get Int ( address + OFFSETOF FILE INFORMATION SIZEHIGH ) ) << NUM ) + ( unsafe . get Int ( address + OFFSETOF FILE INFORMATION SIZELOW ) & NUM ) ; int vol Serial Number = unsafe . get Int ( address + OFFSETOF FILE INFORMATION VOLSERIALNUM ) ; int file Index High = unsafe . get Int ( address + OFFSETOF FILE INFORMATION INDEXHIGH ) ; int file Index Low = unsafe . get Int ( address + OFFSETOF FILE INFORMATION INDEXLOW ) ; return new Windows File Attributes ( file Attrs , creation Time , last Access Time , last Write Time , size , reparse Tag , vol Serial Number , file Index High , file Index Low ) ; }
private List do Get Document Setup Participants ( I Content Type [ ] content Types ) { Set result Set = new Hash Set ( ) ; int i = NUM ; while ( i < content Types . length ) { Set set = ( Set ) f Setup Participant Descriptors . get ( new Content Type Adapter ( content Types [ i ++ ] ) ) ; if ( set != null ) result Set . add All ( set ) ; } List participants = new Array List ( ) ; Iterator e = result Set . iterator ( ) ; while ( e . has Next ( ) ) { I Configuration Element entry = ( I Configuration Element ) e . next ( ) ; Object participant = get Extension ( entry , f Setup Participants , I Document Setup Participant . class ) ; if ( participant != null ) participants . add ( participant ) ; } return participants . is Empty ( ) ? null : participants ; }
public static J Panel create Radiobox ( String boxlabel , String [ ] buttons , int initially Selected , Action Listener al ) { J Panel jp = create Palette J Panel ( boxlabel ) ; Button Group buttongroup = new Button Group ( ) ; for ( int j = NUM ; j < buttons . length ; j ++ ) { J Radio Button jrb = new J Radio Button ( buttons [ j ] ) ; jrb . set Action Command ( STRING + j ) ; jp . add ( jrb ) ; buttongroup . add ( jrb ) ; if ( al != null ) { jrb . add Action Listener ( al ) ; } if ( j == initially Selected ) { jrb . set Selected ( BOOL ) ; } else { jrb . set Selected ( BOOL ) ; } } return jp ; }
@ Override public Template Druid Query update Outer Query ( Template Druid Query outer Query , Map < String , String > old Field Name To New Field Name Map ) { Map < String , Aggregation > old Name To New Aggregation Mapping = new Hash Map < > ( ) ; Set < Aggregation > updated Outer Aggs = update Query Aggs ( outer Query . get Aggregations ( ) , old Field Name To New Field Name Map , old Name To New Aggregation Mapping ) ; Set < Post Aggregation > update Outer Post Aggs = new Hash Set < > ( ) ; for ( Post Aggregation post Aggregation : outer Query . get Post Aggregations ( ) ) { update Outer Post Aggs . add ( replace Post Agg With Post Agg From Map ( post Aggregation , old Name To New Aggregation Mapping ) ) ; } return new Template Druid Query ( updated Outer Aggs , update Outer Post Aggs , outer Query . get Inner Query ( ) , outer Query . get Time Grain ( ) ) ; }
public static void recompute Covariance Matrices ( Relation < ? extends Number Vector > relation , Writable Data Store < double [ ] > prob Cluster I Given X , List < ? extends EM Cluster Model < ? > > models ) { for ( EM Cluster Model < ? > m : models ) { m . begin E Step ( ) ; } double [ ] wsum = new double [ models . size ( ) ] ; for ( DBID Iter iditer = relation . iter DBI Ds ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { double [ ] cluster Probabilities = prob Cluster I Given X . get ( iditer ) ; Number Vector instance = relation . get ( iditer ) ; int i = NUM ; for ( EM Cluster Model < ? > m : models ) { final double prior = cluster Probabilities [ i ] ; if ( prior > NUM ) { m . update E ( instance , prior ) ; } wsum [ i ] += prior ; ++ i ; } } int i = NUM ; for ( EM Cluster Model < ? > m : models ) { m . finalize E Step ( ) ; m . set Weight ( wsum [ i ] / relation . size ( ) ) ; i ++ ; } }
public static List < String > as Strings ( Collection < URI > values ) { List < String > results = new Array List < > ( ) ; if ( values != null ) { for ( URI value : values ) { if ( value != null ) { results . add ( value . to String ( ) ) ; } } } return results ; }
private static double [ ] copy Of ( final double [ ] values , final int begin , final int length ) { Math Arrays . verify Values ( values , begin , length ) ; return Arrays . copy Of Range ( values , begin , begin + length ) ; }
private void partition Class ( GV Congruence Class partition ) { Iterator < Value Graph Vertex > i = partition . iterator ( ) ; Value Graph Vertex first = i . next ( ) ; Array List < GV Congruence Class > new Classes = new Array List < GV Congruence Class > ( ) ; Array List < Value Graph Vertex > to Remove = new Array List < Value Graph Vertex > ( ) ; while ( i . has Next ( ) ) { Value Graph Vertex v = i . next ( ) ; if ( ! check Congruence ( first , v ) ) { int index = find Congruence Match ( new Classes , v ) ; if ( index > - NUM ) { GV Congruence Class match = B . get ( index ) ; match . add Vertex ( v ) ; v . set Value Number ( match . get Value Number ( ) ) ; } else { GV Congruence Class c = create Congruence Class ( v ) ; new Classes . add ( c ) ; c . add Vertex ( v ) ; v . set Value Number ( c . get Value Number ( ) ) ; } to Remove . add ( v ) ; } } for ( Value Graph Vertex v : to Remove ) { partition . remove Vertex ( v ) ; } if ( ( ! new Classes . is Empty ( ) ) && ( partition . size ( ) > NUM ) ) { work List . push ( partition ) ; } for ( GV Congruence Class c : new Classes ) { if ( c . size ( ) > NUM ) { work List . push ( c ) ; } add Dependent Classes To Worklist ( c ) ; } }
private void cache Sizes ( ) { m Adapter Sizes . clear ( ) ; int size = NUM ; if ( m Adapters . size ( ) > NUM ) { m Adapter Sizes . put ( NUM , m Adapters . value At ( NUM ) ) ; } for ( I Adapter < Item > adapter : m Adapters . values ( ) ) { if ( adapter . get Adapter Item Count ( ) > NUM ) { m Adapter Sizes . put ( size , adapter ) ; size = size + adapter . get Adapter Item Count ( ) ; } } m Global Size = size ; }
protected abstract List < String > create Command ( Step Instance step Instance , String temporary File Directory ) ;
public void tree Nodes Changed ( Tree Model Event e ) { Tree Path path = e . get Tree Path ( ) ; update Sub Tree Greyness ( path ) ; update Ancestors Greyness ( path ) ; }
private void handle Operand ( String tok ) throws Exception { if ( tok . index Of ( STRING ) != - NUM ) { m post Fix Exp Vector . add Element ( new Attribute Operand ( tok , m sign Mod ) ) ; } else { try { m post Fix Exp Vector . add Element ( new Numeric Operand ( tok , m sign Mod ) ) ; } catch ( Number Format Exception ne ) { throw new Exception ( STRING ) ; } } m sign Mod = BOOL ; }
public void add ( T object ) { int pos ; synchronized ( m Lock ) { pos = get Item Count ( ) ; m Objects . add ( object ) ; } if ( m Notify On Change ) notify Item Inserted ( pos ) ; }
public static boolean compare Cell Value ( Double v1 , Double v2 , double t , boolean ignore Na N ) { if ( v1 == null ) v1 = NUM ; if ( v2 == null ) v2 = NUM ; if ( ignore Na N && ( v1 . is Na N ( ) || v1 . is Infinite ( ) || v2 . is Na N ( ) || v2 . is Infinite ( ) ) ) return BOOL ; if ( v1 . equals ( v2 ) ) return BOOL ; return Math . abs ( v1 - v2 ) <= t ; }
public static boolean is Host Reachable ( String host Url ) { if ( ! host Url . contains ( STRING ) ) host Url = STRING + host Url ; boolean is Reachable = BOOL ; try { final URL url = new URL ( host Url ) ; final Http URL Connection http URL Connection = ( Http URL Connection ) url . open Connection ( ) ; http URL Connection . set Request Property ( STRING , STRING ) ; http URL Connection . set Request Property ( STRING , STRING ) ; http URL Connection . set Connect Timeout ( TIME OUT ) ; http URL Connection . connect ( ) ; final int response Code = http URL Connection . get Response Code ( ) ; is Reachable = response Code > NUM ; } catch ( Malformed URL Exception e ) { Log . e ( e ) ; } catch ( IO Exception e ) { Log . e ( e ) ; } return is Reachable ; }
private void on Datatype Element ( Element xsd Element , Document Factory parent Factory ) { String name = xsd Element . attribute Value ( STRING ) ; String type = xsd Element . attribute Value ( STRING ) ; Q Name qname = get Q Name ( name ) ; Datatype Element Factory factory = get Datatype Element Factory ( qname ) ; if ( type != null ) { XS Datatype data Type = get Type By Name ( type ) ; if ( data Type != null ) { factory . set Child Element XS Datatype ( qname , data Type ) ; } else { Q Name type Q Name = get Q Name ( type ) ; named Type Resolver . register Typed Element ( xsd Element , type Q Name , parent Factory ) ; } return ; } Element xsd Simple Type = xsd Element . element ( XSD SIMPLETYPE ) ; if ( xsd Simple Type != null ) { XS Datatype data Type = load XS Datatype From Simple Type ( xsd Simple Type ) ; if ( data Type != null ) { factory . set Child Element XS Datatype ( qname , data Type ) ; } } Element schema Complex Type = xsd Element . element ( XSD COMPLEXTYPE ) ; if ( schema Complex Type != null ) { on Schema Complex Type ( schema Complex Type , factory ) ; } Iterator < Element > iter = xsd Element . element Iterator ( XSD ATTRIBUTE ) ; if ( iter . has Next ( ) ) { do { on Datatype Attribute ( xsd Element , factory , iter . next ( ) ) ; } while ( iter . has Next ( ) ) ; } }
public void create ( String xliff Path , String skeleton Path , Locale Id src Loc , Locale Id trg Loc , String data Type , String original , String message ) { if ( writer != null ) { close ( ) ; } this . skeleton Path = skeleton Path ; this . original = original ; this . src Loc = src Loc ; this . trg Loc = trg Loc ; this . data Type = data Type ; if ( output Stream == null ) { writer = new XML Writer ( xliff Path ) ; } else if ( output Stream != null ) { writer = new XML Writer ( new Output Stream Writer ( output Stream , Standard Charsets . UTF 8 ) ) ; } writer . write Start Document ( ) ; writer . write Start Element ( STRING ) ; writer . write Attribute String ( STRING , STRING ) ; writer . write Attribute String ( STRING , Namespaces . NS XLIFF 12 ) ; writer . write Attribute String ( STRING , Namespaces . NS XLIFFOKAPI ) ; if ( params . get Include Its ( ) ) { writer . write Attribute String ( STRING + Namespaces . ITS NS PREFIX , Namespaces . ITS NS URI ) ; writer . write Attribute String ( STRING + Namespaces . ITSXLF NS PREFIX , Namespaces . ITSXLF NS URI ) ; writer . write Attribute String ( Namespaces . ITS NS PREFIX + STRING , STRING ) ; } write Annotators Ref If Needed ( ) ; if ( ! Util . is Empty ( message ) ) { writer . write Line Break ( ) ; writer . write Comment ( message , BOOL ) ; } writer . write Line Break ( ) ; its Cont For Unit = new ITS Content ( xliff Cont . get Charset Encoder ( ) , BOOL , BOOL ) ; its Cont For Src Cont = new ITS Content ( xliff Cont . get Charset Encoder ( ) , BOOL , BOOL ) ; its Cont For Trg Cont = new ITS Content ( xliff Cont . get Charset Encoder ( ) , BOOL , BOOL ) ; its Cont For Alt Trg Cont = new ITS Content ( xliff Cont . get Charset Encoder ( ) , BOOL , BOOL ) ; annotators Ref = new Stack < String > ( ) ; annotators Ref . push ( null ) ; need Annotators Ref = BOOL ; }
public String version Qualifier ( ) { return properties . get Property ( STRING ) ; }
private void sequence Bounded Linearizable Query ( Query Entry entry , Server Session Context session , Completable Future < Query Response > future ) { if ( entry . get Sequence ( ) > session . get Command Sequence ( ) ) { session . register Sequence Query ( entry . get Sequence ( ) , null ) ; } else { apply Query ( entry , future ) ; } }
public static < T > T select Randomly From List ( List < T > l ) { return l . get ( r . next Int ( l . size ( ) ) ) ; }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof Map Bean ) { set Map ( ( Map Bean ) some Obj ) ; } }
public static Map < String , Object > quick Run All Production Run Tasks ( Dispatch Context ctx , Map < String , ? extends Object > context ) { Map < String , Object > result = Service Util . return Success ( ) ; Delegator delegator = ctx . get Delegator ( ) ; Local Dispatcher dispatcher = ctx . get Dispatcher ( ) ; Locale locale = ( Locale ) context . get ( STRING ) ; Generic Value user Login = ( Generic Value ) context . get ( STRING ) ; String production Run Id = ( String ) context . get ( STRING ) ; Production Run production Run = new Production Run ( production Run Id , delegator , dispatcher ) ; if ( ! production Run . exist ( ) ) { return Service Util . return Error ( Util Properties . get Message ( resource , STRING , locale ) ) ; } List < Generic Value > tasks = production Run . get Production Run Routing Tasks ( ) ; Generic Value one Task = null ; String task Id = null ; for ( int i = NUM ; i < tasks . size ( ) ; i ++ ) { one Task = tasks . get ( i ) ; task Id = one Task . get String ( STRING ) ; try { Map < String , Object > service Context = Fast Map . new Instance ( ) ; service Context . put ( STRING , production Run Id ) ; service Context . put ( STRING , task Id ) ; service Context . put ( STRING , user Login ) ; dispatcher . run Sync ( STRING , service Context ) ; } catch ( Generic Service Exception e ) { Debug . log Error ( e , STRING , module ) ; return Service Util . return Error ( Util Properties . get Message ( resource , STRING , locale ) ) ; } } return result ; }
public static void value To Document ( Value value , String root Node Name , Document document , XS Type type ) { Element root = document . create Element ( root Node Name ) ; document . append Child ( root ) ; value To Document ( value , root , document , type ) ; }
public void next Token ( ) { previous Line = line ; previous Column = column ; while ( pos < matcher . region Start ( ) ) { if ( text . char At ( pos ) == STRING ) { ++ line ; column = NUM ; } else { ++ column ; } ++ pos ; } if ( matcher . region Start ( ) == matcher . region End ( ) ) { current Token = STRING ; } else { matcher . use Pattern ( TOKEN ) ; if ( matcher . looking At ( ) ) { current Token = matcher . group ( ) ; matcher . region ( matcher . end ( ) , matcher . region End ( ) ) ; } else { current Token = String . value Of ( text . char At ( pos ) ) ; matcher . region ( pos + NUM , matcher . region End ( ) ) ; } skip Whitespace ( ) ; } }
private void perform Frame Tasks ( ) { synchronized ( m Frame Task Queue ) { A Frame Task task = m Frame Task Queue . poll ( ) ; while ( task != null ) { task . run ( ) ; task = m Frame Task Queue . poll ( ) ; } } }
protected Vector < Double > make Test Value List ( int seed , int num Values , Instances data , int attr Index , int attr Type ) throws Exception { double [ ] min Max = get Minimum Maximum ( data , attr Index ) ; double min Value = min Max [ NUM ] ; double max Value = min Max [ NUM ] ; double range = max Value - min Value ; Vector < Double > values = new Vector < Double > ( num Values ) ; Random random = new Random ( seed ) ; if ( attr Type == Attribute . NOMINAL ) { for ( int i = NUM ; i < num Values ; i ++ ) { Double v = new Double ( ( Math . abs ( random . next Int ( ) ) % ( int ) range ) + ( int ) min Value ) ; values . add ( v ) ; } } if ( attr Type == Attribute . NUMERIC ) { for ( int i = NUM ; i < num Values ; i ++ ) { Double v = new Double ( random . next Double ( ) * range + min Value ) ; values . add ( v ) ; } } return values ; }
private void create Parent Directories ( File file ) { if ( ! file . exists ( ) ) { String path = file . get Absolute Path ( ) ; String dirs = path . substring ( NUM , path . last Index Of ( File . separator ) ) ; File dir = new File ( dirs ) ; if ( dir . exists ( ) ) { return ; } if ( ! dir . mkdirs ( ) ) { report Error ( STRING + dir . get Absolute Path ( ) , new IO Exception ( STRING + dir . get Absolute Path ( ) ) , Error Manager . OPEN FAILURE ) ; } } }
private String find Vfiler Name ( File Share fs ) { String port Group = null ; URI port = fs . get Storage Port ( ) ; if ( port == null ) { log . info ( STRING ) ; } else { Storage Port st Port = db Client . query Object ( Storage Port . class , port ) ; if ( st Port != null ) { URI ha Domain Uri = st Port . get Storage HA Domain ( ) ; if ( ha Domain Uri == null ) { log . info ( STRING , port ) ; } else { Storage HA Domain ha Domain = db Client . query Object ( Storage HA Domain . class , ha Domain Uri ) ; if ( ha Domain != null && ha Domain . get Virtual ( ) == BOOL ) { port Group = st Port . get Port Group ( ) ; log . debug ( STRING , st Port . get Port Network Id ( ) , port Group ) ; } } } } return port Group ; }
public static List < Long > read List Of Longs ( Data Input in ) throws IO Exception { int size = in . read Int ( ) ; if ( size < NUM ) { return null ; } else { List result = new Linked List ( ) ; boolean long I Ds = in . read Boolean ( ) ; for ( int i = NUM ; i < size ; i ++ ) { long l = long I Ds ? in . read Long ( ) : in . read Int ( ) ; result . add ( Long . value Of ( l ) ) ; } return result ; } }
private Map replace Map Key ( Map attributes , Set attribute Names ) { if ( attribute Names != null ) { Iterator iter = attribute Names . iterator ( ) ; while ( iter . has Next ( ) ) { String attr Name = ( String ) iter . next ( ) ; String attr Name Lower = attr Name . to Lower Case ( ) ; if ( attributes . contains Key ( attr Name Lower ) ) { Object attr Value = attributes . get ( attr Name Lower ) ; attributes . remove ( attr Name Lower ) ; attributes . put ( attr Name , attr Value ) ; } } } return attributes ; }
public void show Preferences ( ) { if ( preferences Stage == null ) { preferences Stage = init Stage ( PREFERENCES LAYOUT , STRING ) ; Preferences Controller preferences Controller = ( Preferences Controller ) controllers . get ( PREFERENCES LAYOUT ) ; preferences Stage . set On Showing ( null ) ; } show Stage ( preferences Stage ) ; }
public void test copy Stream full Block Plus One ( ) throws IO Exception { final String id = STRING ; final int version = NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK SIZE + NUM ] ; r . next Bytes ( expected ) ; assert Equals ( STRING , expected . length , repo . copy Stream ( id , version , new Byte Array Input Stream ( expected ) ) ) ; assert Equals ( STRING , NUM , repo . get Block Count ( id , version ) ) ; assert Same Iterator ( STRING , new Long [ ] { NUM , NUM } , repo . blocks ( id , version ) ) ; assert Equals ( STRING , expected , read ( repo . input Stream ( id , version ) ) ) ; }
public CIDR ( String cidr Or IP ) { String [ ] parts = cidr Or IP . split ( STRING ) ; if ( ( parts . length < NUM ) || ( parts . length > NUM ) ) throw new Illegal Argument Exception ( cidr Or IP + STRING ) ; bits = ( NUM == parts . length ) ? NUM : Short . parse Short ( parts [ NUM ] ) ; if ( ( bits < NUM ) || ( bits > NUM ) ) throw new Illegal Argument Exception ( cidr Or IP + STRING + bits + STRING ) ; this . first IP = to IP ( parts [ NUM ] ) ; }
protected void request ( Request Context context , String key , String message ) { try { Http Servlet Request request = context . get Request ( ) ; String filename = request . get Remote Addr ( ) ; start ( filename , key , STRING + request . get Method ( ) + STRING + request . get Request URI ( ) + STRING + message ) ; } catch ( Exception e ) { } }
protected Http URL Connection create Undeploy Connection ( WAR war ) throws IO Exception { String undeploy URL = this . deployer Url + STRING + war . get Context ( ) ; URL url = new URL ( undeploy URL ) ; Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Allow User Interaction ( BOOL ) ; connection . set Do Input ( BOOL ) ; connection . set Do Output ( BOOL ) ; connection . set Use Caches ( BOOL ) ; connection . set Do Output ( BOOL ) ; connection . set Request Method ( STRING ) ; if ( this . username != null ) { String authorization = to Authorization ( this . username , this . password ) ; connection . set Request Property ( STRING , authorization ) ; } connection . connect ( ) ; return connection ; }
public void add Listener ( Listener a Listener ) { if ( a Listener == null ) return ; if ( hex Edit Control == null ) { if ( list Of Status Changed Listeners == null ) list Of Status Changed Listeners = new Array List < > ( ) ; list Of Status Changed Listeners . add ( a Listener ) ; } else { hex Edit Control . add Listener ( SWT . Modify , a Listener ) ; } }
public String to String For Quest State ( ) { final String Builder sb = new String Builder ( ) ; boolean first = BOOL ; for ( final Map . Entry < String , Integer > e : entry Set ( ) ) { if ( first ) { first = BOOL ; } else { sb . append ( STRING ) ; } sb . append ( e . get Key ( ) ) ; sb . append ( STRING ) ; sb . append ( e . get Value ( ) ) ; } return sb . to String ( ) ; }
@ Override public void add New Subscription ( final Subscription new Subscription ) { final String client ID = new Subscription . get Client Id ( ) ; List < Client Topic Couple > client Subscriptions = subscriptions . get ( client ID ) ; if ( client Subscriptions == null ) { client Subscriptions = new Array List < > ( ) ; subscriptions . put ( client ID , client Subscriptions ) ; } client Subscriptions . add ( new Subscription . as Client Topic Couple ( ) ) ; }
public static String ensure Left ( final String value , final String prefix , final boolean case Sensitive ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; if ( case Sensitive ) { return value . starts With ( prefix ) ? value : prefix + value ; } String value = value . to Lower Case ( ) ; String prefix = prefix . to Lower Case ( ) ; return value . starts With ( prefix ) ? value : prefix + value ; }
boolean is Missing Required Roles ( ) { return this . is Missing Required Roles ; }
protected Light Icon add Light ( ) { Light Icon l = new Light Icon ( this ) ; Icon Adder editor = get Icon Editor ( STRING ) ; l . set Off Icon ( editor . get Icon ( STRING ) ) ; l . set On Icon ( editor . get Icon ( STRING ) ) ; l . set Inconsistent Icon ( editor . get Icon ( STRING ) ) ; l . set Unknown Icon ( editor . get Icon ( STRING ) ) ; l . set Light ( ( Light ) editor . get Table Selection ( ) ) ; l . set Display Level ( LIGHTS ) ; set Next Location ( l ) ; put Item ( l ) ; return l ; }
private void draw Zoom Rectangle ( Graphics 2 D g2 , boolean xor ) { if ( this . zoom Rectangle != null ) { if ( xor ) { g2 . set XOR Mode ( Color . gray ) ; } if ( this . fill Zoom Rectangle ) { g2 . set Paint ( this . zoom Fill Paint ) ; g2 . fill ( this . zoom Rectangle ) ; } else { g2 . set Paint ( this . zoom Outline Paint ) ; g2 . draw ( this . zoom Rectangle ) ; } if ( xor ) { g2 . set Paint Mode ( ) ; } } }
public Conversion Exception ( Throwable cause ) { super ( cause . get Message ( ) ) ; this . cause = cause ; }
private void validate Initiator Data ( Initiator initiator , Export Group export Group ) { validate Port Connectivity ( export Group , Collections . singleton List ( initiator ) ) ; }
private List < Rich Translation < TK , FV > > standard Nbest ( Beam < Derivation < TK , FV > > beam , Recombination History < Derivation < TK , FV > > recombination History , Input Properties source Input Properties , int source Input Id , List < Sequence < TK > > targets , Output Space < TK , FV > output Space , int size , boolean distinct ) { List < Derivation < TK , FV > > goal States = new Array List < > ( beam . size ( ) ) ; for ( Derivation < TK , FV > derivation : beam ) goal States . add ( derivation ) ; final State Lattice Decoder < Derivation < TK , FV > > lattice Decoder = new State Lattice Decoder < > ( goal States , recombination History ) ; final boolean prefix Decoding = source Input Properties . contains Key ( Input Property . Target Prefix ) ; final boolean prefix Diversity = distinct && prefix Decoding ; final Sequence < TK > prefix = prefix Decoding ? targets . get ( NUM ) : null ; final Set < Sequence < TK > > distinct Surface Translations = distinct ? new Hash Set < > ( size ) : null ; final List < Rich Translation < TK , FV > > translations = new Array List < > ( size ) ; int num Extracted = NUM ; long nbest Id = NUM ; for ( List < Derivation < TK , FV > > lattice Path : lattice Decoder ) { ++ num Extracted ; if ( num Extracted > MAX POPPED ITEMS ) break ; if ( distinct ) { Sequence < TK > path Target = extract Target ( lattice Path ) ; if ( prefix Diversity ) { int start = prefix . size ( ) ; int end = Math . min ( path Target . size ( ) , prefix . size ( ) + PREFIX DIVERSITY SIZE ) ; if ( start < end ) path Target = path Target . subsequence ( start , end ) ; } if ( distinct Surface Translations . contains ( path Target ) ) continue ; distinct Surface Translations . add ( path Target ) ; } boolean with DT Us = BOOL ; final Set < Rule < TK > > seen Options = new Hash Set < > ( ) ; Derivation < TK , FV > goal Hyp = null ; for ( Derivation < TK , FV > node : lattice Path ) { if ( goal Hyp == null ) { goal Hyp = node ; continue ; } with DT Us = with DT Us || node . rule . abstract Rule instanceof DTU Rule ; goal Hyp = with DT Us ? new DTU Hypothesis < > ( source Input Id , node . rule , goal Hyp . length , goal Hyp , node , featurizer , scorer , heuristic , seen Options , output Space ) : new Derivation < > ( source Input Id , node . rule , goal Hyp . length , goal Hyp , featurizer , scorer , heuristic , output Space ) ; } if ( goal Hyp == null || goal Hyp . featurizable == null ) { logger . warn ( STRING , source Input Id ) ; return null ; } if ( with DT Us ) { DTU Hypothesis < TK , FV > dtu Hyp = ( DTU Hypothesis < TK , FV > ) goal Hyp ; if ( ! dtu Hyp . is Done ( ) || dtu Hyp . has Expired ( ) ) logger . warn ( STRING , translations . size ( ) , dtu Hyp . has Expired ( ) , goal Hyp ) ; } Rich Translation < TK , FV > t = new Rich Translation < > ( goal Hyp . featurizable , goal Hyp . score , Feature Values . combine ( goal Hyp ) , nbest Id ++ ) ; translations . add ( t ) ; if ( translations . size ( ) >= size ) break ; } Collections . sort ( translations , translation Comparator ) ; logger . info ( STRING , source Input Id , num Extracted , lattice Decoder . max Agenda Size ) ; return translations ; }
public void test Negate Math Context Positive ( ) { String a = STRING ; int a Scale = NUM ; int precision = NUM ; Rounding Mode rm = Rounding Mode . FLOOR ; Math Context mc = new Math Context ( precision , rm ) ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal res = a Number . negate ( mc ) ; assert Equals ( STRING , c , res . to String ( ) ) ; assert Equals ( STRING , c Scale , res . scale ( ) ) ; }
private static I Abstract Node convert And ( final Common Tree ast ) throws Recognition Exception { final List < I Abstract Node > children = new Array List < I Abstract Node > ( ) ; for ( final Object child Object : ast . get Children ( ) ) { children . add ( convert ( ( Common Tree ) child Object ) ) ; } return new C Abstract And Expression ( children ) ; }
@ Override public void run ( ) { am I Active = BOOL ; panel = new Coordinate Transform Dialog ( my Host ) ; if ( my Host instanceof J Frame ) { J Dialog dialog = new J Dialog ( ( J Frame ) my Host , STRING , BOOL ) ; Container content Pane = dialog . get Content Pane ( ) ; content Pane . add ( panel , Border Layout . CENTER ) ; dialog . set Default Close Operation ( J Frame . DISPOSE ON CLOSE ) ; dialog . pack ( ) ; dialog . set Location Relative To ( null ) ; dialog . set Visible ( BOOL ) ; } else { J Frame frame = new J Frame ( STRING ) ; Container content Pane = frame . get Content Pane ( ) ; content Pane . add ( panel , Border Layout . CENTER ) ; frame . set Default Close Operation ( J Frame . DISPOSE ON CLOSE ) ; frame . pack ( ) ; frame . set Location Relative To ( null ) ; frame . set Visible ( BOOL ) ; } }
public Builder add Token Filter ( Class < ? extends Token Filter Factory > factory , Map < String , String > params ) throws IO Exception { Objects . require Non Null ( factory , STRING ) ; token Filters . add ( apply Resource Loader ( new Factory Class Instance ( factory , apply Default Params ( params ) ) ) ) ; components Added = BOOL ; return this ; }
public void update ( int fps , float angle ) { double speed = ( SPEED / FPS ) * Math . log ( radius ) ; y -= speed ; x += amp * Math . sin ( freq * ( step ++ * speed ) ) + skew ; if ( radius < max Radius ) { radius += max Radius / ( ( ( float ) fps / SPEED ) * radius ) ; if ( radius > max Radius ) radius = max Radius ; } }
public void add Display Changed Listener ( Display Changed Listener client ) { display Changer . add ( client ) ; }
public String to String Rfc 3339 ( ) { String Builder sb = new String Builder ( ) ; Calendar date Time = new Gregorian Calendar ( GMT ) ; long local Time = value + ( tz Shift * NUM ) ; date Time . set Time In Millis ( local Time ) ; append Int ( sb , date Time . get ( Calendar . YEAR ) , NUM ) ; sb . append ( STRING ) ; append Int ( sb , date Time . get ( Calendar . MONTH ) + NUM , NUM ) ; sb . append ( STRING ) ; append Int ( sb , date Time . get ( Calendar . DAY OF MONTH ) , NUM ) ; if ( ! date Only ) { sb . append ( STRING ) ; append Int ( sb , date Time . get ( Calendar . HOUR OF DAY ) , NUM ) ; sb . append ( STRING ) ; append Int ( sb , date Time . get ( Calendar . MINUTE ) , NUM ) ; sb . append ( STRING ) ; append Int ( sb , date Time . get ( Calendar . SECOND ) , NUM ) ; if ( date Time . is Set ( Calendar . MILLISECOND ) ) { sb . append ( STRING ) ; append Int ( sb , date Time . get ( Calendar . MILLISECOND ) , NUM ) ; } if ( tz Shift == NUM ) { sb . append ( STRING ) ; } else { int abs Tz Shift = tz Shift ; if ( tz Shift > NUM ) { sb . append ( STRING ) ; } else { sb . append ( STRING ) ; abs Tz Shift = - abs Tz Shift ; } int tz Hours = abs Tz Shift / NUM ; int tz Minutes = abs Tz Shift % NUM ; append Int ( sb , tz Hours , NUM ) ; sb . append ( STRING ) ; append Int ( sb , tz Minutes , NUM ) ; } } return sb . to String ( ) ; }
@ Nullable public static Psi Method find Method By Name ( Psi Class clazz , String name ) { Psi Method [ ] methods = clazz . get Methods ( ) ; for ( int i = methods . length - NUM ; i >= NUM ; i -- ) { Psi Method method = methods [ i ] ; if ( name . equals ( method . get Name ( ) ) ) { return method ; } } return null ; }
@ Override public void create Redis App Key ( Application application , String docker Manager IP , String server Port , String server Manager Port ) { String suffix Cloud Unit = application . get Suffix Cloud Unit IO ( ) ; Jedis Pool pool = null ; Jedis jedis = null ; try { pool = new Jedis Pool ( new Jedis Pool Config ( ) , redis Ip , Integer . parse Int ( redis Port ) , NUM ) ; jedis = pool . get Resource ( ) ; String sub Name Space = concat Sub Name Space ( application ) ; String key = sub Name Space + suffix Cloud Unit ; String frontend = STRING + key . to Lower Case ( ) ; jedis . rpush ( frontend , key . to Lower Case ( ) ) ; jedis . rpush ( frontend , STRING + docker Manager IP + STRING + server Port ) ; String frontend Server Manager = STRING + key . to Lower Case ( ) ; jedis . rpush ( frontend Server Manager , key . to Lower Case ( ) ) ; jedis . rpush ( frontend Server Manager , STRING + docker Manager IP + STRING + server Manager Port ) ; } catch ( Jedis Connection Exception | Unsupported Encoding Exception e ) { logger . error ( STRING , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }
private void update Item Position ( Model State item , List < Update Op > move Ops ) { int size = move Ops . size ( ) ; for ( int i = item . last Move Op ; i < size ; i ++ ) { Update Op move Op = move Ops . get ( i ) ; int from Position = move Op . position Start ; int to Position = move Op . item Count ; if ( item . position > from Position && item . position <= to Position ) { item . position -- ; } else if ( item . position < from Position && item . position >= to Position ) { item . position ++ ; } } item . last Move Op = size ; }
public static boolean is FFA ( final Game Data data , final Player ID player ) { final Relationship Tracker relationship Tracker = data . get Relationship Tracker ( ) ; final Set < Player ID > enemies = relationship Tracker . get Enemies ( player ) ; for ( final Player ID enemy : enemies ) { if ( relationship Tracker . is At War With Any Of These Players ( enemy , enemies ) ) { return BOOL ; } } return BOOL ; }
protected void ensure Route Consecutivity ( ) { boolean de Allocate Rest Of Route = BOOL ; for ( int i = idx Current Order + NUM ; i < orders . size ( ) ; i ++ ) { log . debug ( train Name + STRING + i ) ; Block Order bo = get Block Order At ( i ) ; O Block block = bo . get Block ( ) ; if ( ! block . is Allocated To ( this ) || ( block . get State ( ) & O Block . OCCUPIED ) != NUM ) { de Allocate Rest Of Route = BOOL ; } if ( de Allocate Rest Of Route ) { if ( block . is Allocated To ( this ) ) { log . info ( train Name + STRING + block . get Display Name ( ) + STRING ) ; block . de Allocate ( this ) ; } } } }
public Storage Pool select Pool ( List < Storage Pool > pool List ) { if ( pool List == null || pool List . is Empty ( ) ) { return null ; } port Metrics Processor . compute Storage Pools Avg Port Metrics ( pool List ) ; Collections . sort ( pool List , storage Pool Comparator ) ; return pool List . get ( NUM ) ; }
public void select Next Overlay ( ) { if ( m Current Overlay Index == NO OVERLAY ) { if ( m Overlays . is Empty ( ) ) { return ; } m Current Overlay Index = NUM ; } else { m Current Overlay Index = ++ m Current Overlay Index % m Overlays . size ( ) ; if ( m Current Overlay Index == NUM ) { m Current Overlay Index = NO OVERLAY ; } } do Set Overlay ( get Current Overlay ( ) ) ; }
public static String create Ignore Pattern For Resource ( final I Resource resource ) { Check . not Null ( resource , STRING ) ; final String path = TP Ignore Cache . create Resource Match String ( resource ) ; String pattern String = Pattern . quote ( path ) ; if ( resource . get Type ( ) == I Resource . FOLDER || resource . get Type ( ) == I Resource . PROJECT ) { pattern String = pattern String + STRING ; } return pattern String ; }
private void process Version ( String version String ) { try { String Tokenizer tokens = new String Tokenizer ( version String , STRING ) ; major Version = Integer . parse Int ( tokens . next Token ( ) ) ; minor Version = Integer . parse Int ( tokens . next Token ( ) ) ; this . version String = version String ; } catch ( Exception e ) { } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static String xml Single Quoted Escape ( String s ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : break ; default : sb . append ( c ) ; } } return sb . to String ( ) ; }
private void convergence Step ( final Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final Vec scratch , final Kernel Function k ) { double denom = NUM ; Vec x Cur = xit [ i ] ; List < ? extends Vec Paired < Vec Paired < Vec , Integer > , Double > > contrib = mkde . get Nearby Raw ( x Cur ) ; if ( contrib . size ( ) == NUM ) { converged [ i ] = BOOL ; designations [ i ] = - NUM ; } else { scratch . zero Out ( ) ; for ( Vec Paired < Vec Paired < Vec , Integer > , Double > v : contrib ) { double g = - k . k Prime ( v . get Pair ( ) ) ; denom += g ; scratch . mutable Add ( g , v ) ; } scratch . mutable Divide ( denom ) ; if ( Math . abs ( scratch . p Norm Dist ( NUM , x Cur ) ) < NUM ) converged [ i ] = BOOL ; scratch . copy To ( x Cur ) ; } }
public Pid File ( final File directory , final String filename ) throws File Not Found Exception { if ( ! directory . is Directory ( ) && directory . exists ( ) ) { throw new Illegal Argument Exception ( STRING + directory + STRING ) ; } final File file = new File ( directory , filename ) ; if ( ! file . exists ( ) || file . is Directory ( ) ) { throw new File Not Found Exception ( STRING + filename + STRING + directory ) ; } this . pid File = file ; }
public static boolean compare Results ( Solr Server control Server , Solr Server cloud Server ) throws Solr Server Exception { return compare Results ( control Server , cloud Server , null , null ) ; }
public String Get Element Attr ( String x Path Expression ) { try { org . jdom . Attribute node = ( Attribute ) X Path . select Single Node ( this . xml Document , x Path Expression ) ; return node . get Value ( ) ; } catch ( Exception ex ) { LOG . error ( STRING + ex . get Message ( ) , ex ) ; return STRING ; } }
public static SSL Context create SSL Context ( Trust Manager trust Manager , Key Manager key Manager ) { try { SSL Context ctx = SSL Context . get Instance ( STRING ) ; ctx . init ( new Key Manager [ ] { key Manager } , new Trust Manager [ ] { trust Manager } , null ) ; return ctx ; } catch ( No Such Algorithm Exception | Key Management Exception e ) { throw new Runtime Exception ( STRING , e ) ; } }
private void expand Tree ( ) { if ( tree Expand . is Selected ( ) ) { for ( int row = NUM ; row < tree . get Row Count ( ) ; row ++ ) tree . expand Row ( row ) ; } else { for ( int row = tree . get Row Count ( ) ; row > NUM ; row -- ) tree . collapse Row ( row ) ; } }
@ Suppress Warnings ( STRING ) private static void replace Player Cape ( Abstract Client Player player ) { final String display Name = player . get Display Name String ( ) ; final Network Player Info player Info ; try { player Info = ( Network Player Info ) GET PLAYER INFO . invoke Exact ( player ) ; } catch ( Throwable throwable ) { Logger . fatal ( throwable , STRING , display Name ) ; return ; } if ( player Info == null ) { Logger . fatal ( STRING , display Name ) ; return ; } final Map < Minecraft Profile Texture . Type , Resource Location > player Textures ; try { player Textures = ( Map < Minecraft Profile Texture . Type , Resource Location > ) GET PLAYER TEXTURES . invoke Exact ( player Info ) ; } catch ( Throwable throwable ) { Logger . fatal ( throwable , STRING , display Name ) ; return ; } player Textures . put ( Minecraft Profile Texture . Type . CAPE , CAPE LOCATION ) ; Logger . info ( STRING , display Name ) ; }
public void remove Vetoable Change Listener ( String property Name , Vetoable Change Listener listener ) { if ( listener != null ) { synchronized ( this ) { if ( vetoable Support != null ) { vetoable Support . remove Vetoable Change Listener ( property Name , listener ) ; } } } }
public String finished ( Logger log ) { if ( m av Insts Per Sec == NUM ) { compute Update ( System . current Time Millis ( ) ) ; } int nS = m num Samples > NUM ? m num Samples : NUM ; String msg = STRING + m instance Count + STRING + m av Insts Per Sec / nS + STRING ; if ( log != null ) { log . status Message ( m status Message Prefix + msg ) ; } return msg ; }
protected void parse Command ( final String ... args ) { if ( args != null ) { for ( String arg : args ) { Command command = Command . value Of Name ( arg ) ; if ( command != null ) { set Command ( command ) ; break ; } } } }
@ Request Mapping ( method = Request Method . POST ) Response Entity < Bookmark > add Bookmark ( @ Path Variable ( value = STRING ) String username , @ Request Body Bookmark bookmark ) throws User Not Found Exception { Optional < User > optional = users Repository . find By Username ( username ) ; if ( optional . is Present ( ) ) { User user = optional . get ( ) ; user . add Bookmark ( bookmark ) ; bookmark . set User ( user ) ; bookmarks Repository . save ( bookmark ) ; return new Response Entity < > ( bookmark , Http Status . CREATED ) ; } else { throw new User Not Found Exception ( username ) ; } }
static int [ ] find Nanp Phone Numbers ( Char Sequence text ) { Array List < Integer > list = new Array List < Integer > ( ) ; int start Pos = NUM ; int end Pos = text . length ( ) - NANP MIN DIGITS + NUM ; if ( end Pos < NUM ) { return new int [ ] { } ; } while ( start Pos < end Pos ) { while ( Character . is Whitespace ( text . char At ( start Pos ) ) && start Pos < end Pos ) { start Pos ++ ; } if ( start Pos == end Pos ) { break ; } int match End = find Nanp Match End ( text , start Pos ) ; if ( match End > start Pos ) { list . add ( start Pos ) ; list . add ( match End ) ; start Pos = match End ; } else { while ( ! Character . is Whitespace ( text . char At ( start Pos ) ) && start Pos < end Pos ) { start Pos ++ ; } } } int [ ] result = new int [ list . size ( ) ] ; for ( int i = list . size ( ) - NUM ; i >= NUM ; i -- ) { result [ i ] = list . get ( i ) ; } return result ; }
private static void draw Table Layout Guidelines ( View Transform transform , Graphics 2 D g , Constraint Table Layout table ) { Graphics 2 D g2 = ( Graphics 2 D ) g . create ( ) ; Array List < Guideline > vertical = table . get Vertical Guidelines ( ) ; Array List < Guideline > horizontal = table . get Horizontal Guidelines ( ) ; g2 . set Stroke ( Snap Draw . s Thin Dashed Stroke ) ; int l = transform . get Swing X ( table . get Draw X ( ) ) ; int t = transform . get Swing Y ( table . get Draw Y ( ) ) ; int r = transform . get Swing X ( table . get Draw X ( ) + table . get Draw Width ( ) ) ; int b = transform . get Swing Y ( table . get Draw Y ( ) + table . get Draw Height ( ) ) ; for ( Constraint Widget v : vertical ) { int x = transform . get Swing X ( v . get X ( ) ) + l ; g2 . draw Line ( x , t , x , b ) ; } for ( Constraint Widget h : horizontal ) { int y = transform . get Swing Y ( h . get Y ( ) ) + t ; g2 . draw Line ( l , y , r , y ) ; } g2 . dispose ( ) ; }
public static void call Method ( Method Operation operation , Method Context method Context , List < Method Object < ? > > parameters , Class < ? > method Class , Object method Object , String method Name , Flexible Map Accessor < Object > ret Field Fma ) throws Mini Lang Runtime Exception { Object [ ] args = null ; Class < ? > [ ] parameter Types = null ; if ( parameters != null ) { args = new Object [ parameters . size ( ) ] ; parameter Types = new Class < ? > [ parameters . size ( ) ] ; int i = NUM ; for ( Method Object < ? > method Object Def : parameters ) { args [ i ] = method Object Def . get Object ( method Context ) ; Class < ? > type Class = null ; try { type Class = method Object Def . get Type Class ( method Context ) ; } catch ( Class Not Found Exception e ) { throw new Mini Lang Runtime Exception ( e , operation ) ; } parameter Types [ i ] = type Class ; i ++ ; } } try { Method method = method Class . get Method ( method Name , parameter Types ) ; Object ret Value = method . invoke ( method Object , args ) ; if ( ! ret Field Fma . is Empty ( ) ) { ret Field Fma . put ( method Context . get Env Map ( ) , ret Value ) ; } } catch ( Exception e ) { throw new Mini Lang Runtime Exception ( e , operation ) ; } }
private static int index Of ( Char Sequence source , Char Sequence target , int from Index ) { int source Offset = NUM , source Count = source . length ( ) , target Offset = NUM , target Count = target . length ( ) ; if ( from Index >= source Count ) { return ( target Count == NUM ? source Count : - NUM ) ; } if ( from Index < NUM ) { from Index = NUM ; } if ( target Count == NUM ) { return from Index ; } char first = target . char At ( target Offset ) ; int max = source Offset + ( source Count - target Count ) ; for ( int i = source Offset + from Index ; i <= max ; i ++ ) { if ( source . char At ( i ) != first ) { while ( ++ i <= max && source . char At ( i ) != first ) ; } if ( i <= max ) { int j = i + NUM ; int end = j + target Count - NUM ; for ( int k = target Offset + NUM ; j < end && source . char At ( j ) == target . char At ( k ) ; j ++ , k ++ ) ; if ( j == end ) { return i - source Offset ; } } } return - NUM ; }
private void process Input ( boolean end Of Input ) throws IO Exception { decoder In . flip ( ) ; Coder Result coder Result ; while ( BOOL ) { coder Result = decoder . decode ( decoder In , decoder Out , end Of Input ) ; if ( coder Result . is Overflow ( ) ) { flush Output ( ) ; } else if ( coder Result . is Underflow ( ) ) { break ; } else { throw new IO Exception ( STRING ) ; } } decoder In . compact ( ) ; }
public static Prototype intern ( String descriptor ) { if ( descriptor == null ) { throw new Null Pointer Exception ( STRING ) ; } Prototype result ; synchronized ( intern Table ) { result = intern Table . get ( descriptor ) ; } if ( result != null ) { return result ; } Type [ ] params = make Parameter Array ( descriptor ) ; int param Count = NUM ; int at = NUM ; for ( ; ; ) { int start At = at ; char c = descriptor . char At ( at ) ; if ( c == STRING ) { at ++ ; break ; } while ( c == STRING ) { at ++ ; c = descriptor . char At ( at ) ; } if ( c == STRING ) { int end At = descriptor . index Of ( STRING , at ) ; if ( end At == - NUM ) { throw new Illegal Argument Exception ( STRING ) ; } at = end At + NUM ; } else { at ++ ; } params [ param Count ] = Type . intern ( descriptor . substring ( start At , at ) ) ; param Count ++ ; } Type return Type = Type . intern Return Type ( descriptor . substring ( at ) ) ; Std Type List parameter Types = new Std Type List ( param Count ) ; for ( int i = NUM ; i < param Count ; i ++ ) { parameter Types . set ( i , params [ i ] ) ; } result = new Prototype ( descriptor , return Type , parameter Types ) ; return put Intern ( result ) ; }
protected void create Entity At ( final String clazz , final int type , final int x , final int y ) { logger . debug ( STRING + clazz + STRING + type + STRING + x + STRING + y ) ; final int ENTRY POINT = NUM ; final int ZONE CHANGE = NUM ; final int DOOR = NUM ; final int PORTAL = NUM ; final int PORTAL STAIRS DOWN = NUM ; final int PORTAL STAIRS UP = NUM ; final int ONE WAY PORTAL DESTINATION = NUM ; try { if ( clazz . contains ( STRING ) ) { switch ( type ) { case ENTRY POINT : case ZONE CHANGE : set Entry Point ( x , y ) ; break ; case ONE WAY PORTAL DESTINATION : case PORTAL STAIRS UP : case PORTAL STAIRS DOWN : create Level Portal At ( type , x , y ) ; break ; case PORTAL : break ; case DOOR : break ; default : logger . error ( STRING + clazz + STRING + type + STRING + x + STRING + y + STRING + get ID ( ) + STRING ) ; break ; } } else if ( clazz . contains ( STRING ) ) { final Sheep sheep = new Sheep ( ) ; sheep . set Position ( x , y ) ; add ( sheep ) ; } else if ( clazz . contains ( STRING ) ) { final Entity Manager manager = Singleton Repository . get Entity Manager ( ) ; if ( manager . is Creature ( clazz , type ) ) { final Creature creature = manager . get Creature ( clazz , type ) ; final Creature Respawn Point point = new Creature Respawn Point ( this , x , y , creature , NUM ) ; add ( point ) ; } else { logger . error ( STRING + clazz + STRING + type + STRING + x + STRING + y + STRING + get ID ( ) + STRING ) ; } } else if ( clazz . contains ( STRING ) ) { final Passive Entity Respawn Point passive Entityrespawn Point = Passive Entity Respawn Point Factory . create ( clazz , type , get ID ( ) , x , y ) ; if ( passive Entityrespawn Point != null ) { passive Entityrespawn Point . set Position ( x , y ) ; add ( passive Entityrespawn Point ) ; passive Entityrespawn Point . set Start State ( ) ; } } } catch ( final Runtime Exception e ) { logger . error ( STRING + type + STRING + x + STRING + y + STRING , e ) ; } }
private void load Org Access Add ( Array List < Org Access > list , Org Access oa ) { if ( list . contains ( oa ) ) return ; list . add ( oa ) ; if ( get AD Tree Org ID ( ) == NUM ) return ; M Org org = M Org . get ( get Ctx ( ) , oa . AD Org ID ) ; if ( ! org . is Summary ( ) ) return ; M Tree Base tree = M Tree Base . get ( get Ctx ( ) , get AD Tree Org ID ( ) , get Trx Name ( ) ) ; String sql = STRING + STRING + tree . get Node Table Name ( ) + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; pstmt . set Int ( NUM , tree . get AD Tree ID ( ) ) ; pstmt . set Int ( NUM , org . get AD Org ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int AD Client ID = rs . get Int ( NUM ) ; int AD Org ID = rs . get Int ( NUM ) ; load Org Access Add ( list , new Org Access ( AD Client ID , AD Org ID , oa . read Only ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
public void test Incremental Pojo Reading ( ) throws IO Exception { Json Factory jf = new Mapping Json Factory ( ) ; final String JSON = STRING ; Json Parser jp = jf . create Json Parser ( new String Reader ( JSON ) ) ; assert Token ( Json Token . START ARRAY , jp . next Token ( ) ) ; assert Token ( Json Token . VALUE NUMBER INT , jp . next Token ( ) ) ; assert Equals ( Integer . value Of ( NUM ) , jp . read Value As ( Integer . class ) ) ; assert Equals ( Boolean . TRUE , jp . read Value As ( Boolean . class ) ) ; assert Null ( jp . read Value As ( Object . class ) ) ; assert Equals ( Json Token . VALUE NULL , jp . get Last Cleared Token ( ) ) ; assert Equals ( STRING , jp . read Value As ( String . class ) ) ; assert Null ( jp . read Value As ( Object . class ) ) ; assert Equals ( Json Token . END ARRAY , jp . get Last Cleared Token ( ) ) ; assert Null ( jp . next Token ( ) ) ; jp . close ( ) ; }
public static String to Pretty String ( Object value ) { if ( value == null ) { return String Pool . NULL ; } Class < ? > type = value . get Class ( ) ; if ( type . is Array ( ) ) { Class component Type = type . get Component Type ( ) ; if ( component Type . is Primitive ( ) ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; if ( component Type == int . class ) { sb . append ( Arrays Util . to String ( ( int [ ] ) value ) ) ; } else if ( component Type == long . class ) { sb . append ( Arrays Util . to String ( ( long [ ] ) value ) ) ; } else if ( component Type == double . class ) { sb . append ( Arrays Util . to String ( ( double [ ] ) value ) ) ; } else if ( component Type == float . class ) { sb . append ( Arrays Util . to String ( ( float [ ] ) value ) ) ; } else if ( component Type == boolean . class ) { sb . append ( Arrays Util . to String ( ( boolean [ ] ) value ) ) ; } else if ( component Type == short . class ) { sb . append ( Arrays Util . to String ( ( short [ ] ) value ) ) ; } else if ( component Type == byte . class ) { sb . append ( Arrays Util . to String ( ( byte [ ] ) value ) ) ; } else { throw new Illegal Argument Exception ( ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; } else { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; Object [ ] array = ( Object [ ] ) value ; for ( int i = NUM ; i < array . length ; i ++ ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( to Pretty String ( array [ i ] ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; } } else if ( value instanceof Iterable ) { Iterable iterable = ( Iterable ) value ; String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; int i = NUM ; for ( Object o : iterable ) { if ( i > NUM ) { sb . append ( STRING ) ; } sb . append ( to Pretty String ( o ) ) ; i ++ ; } sb . append ( STRING ) ; return sb . to String ( ) ; } return value . to String ( ) ; }
@ Override public List < Period > generate Rolling Periods ( Date Time Unit date Time Unit ) { Calendar cal = get Calendar ( ) ; date Time Unit . set Day ( NUM ) ; date Time Unit = cal . minus Months ( date Time Unit , ( date Time Unit . get Month ( ) % NUM ) + NUM ) ; List < Period > periods = Lists . new Array List ( ) ; for ( int i = NUM ; i < NUM ; i ++ ) { periods . add ( create Period ( date Time Unit , cal ) ) ; date Time Unit = cal . plus Months ( date Time Unit , NUM ) ; } return periods ; }
protected static String create Counter Name ( String switch ID , int port ID , String counter Name , String sub Category , Network Layer layer ) { String full Counter Name = STRING ; String group Counter Name = STRING ; if ( port ID < NUM ) { group Counter Name = switch ID + Title Delimitor + counter Name ; full Counter Name = group Counter Name + Title Delimitor + sub Category ; } else { group Counter Name = switch ID + Title Delimitor + port ID + Title Delimitor + counter Name ; full Counter Name = group Counter Name + Title Delimitor + sub Category ; } Map < String , List < String > > counter To Categories ; if ( layered Categories . contains Key ( layer ) ) { counter To Categories = layered Categories . get ( layer ) ; } else { counter To Categories = new Concurrent Hash Map < String , List < String > > ( ) ; layered Categories . put ( layer , counter To Categories ) ; } List < String > categories ; if ( counter To Categories . contains Key ( group Counter Name ) ) { categories = counter To Categories . get ( group Counter Name ) ; } else { categories = new Array List < String > ( ) ; counter To Categories . put ( group Counter Name , categories ) ; } if ( ! categories . contains ( sub Category ) ) { categories . add ( sub Category ) ; } return full Counter Name ; }
public static Uri add Message To Uri ( Content Resolver resolver , Uri uri , String address , String body , String subject , Long date , boolean read , boolean delivery Report ) { return add Message To Uri ( resolver , uri , address , body , subject , date , read , delivery Report , - NUM ) ; }

private synchronized void expunge Stale Entries ( ) { if ( size == NUM ) return ; Object r ; while ( ( r = queue . poll ( ) ) != null ) { Entry e = ( Entry ) r ; unlink ( e ) ; int h = e . hash ; int i = index For ( h , table . length ) ; Entry prev = table [ i ] ; Entry p = prev ; while ( p != null ) { Entry next = p . next ; if ( p == e ) { if ( prev == e ) table [ i ] = next ; else prev . next = next ; e . next = null ; size -- ; break ; } prev = p ; p = next ; } } }
protected void work ( Find Bugs Worker worker , I Java Element element ) throws Core Exception { worker . work ( Collections . singleton List ( new Work Item ( element ) ) ) ; process Ui Events ( Resource Change Listener . SHORT DELAY ) ; join Job Family ( Findbugs Plugin . class ) ; wait For Jobs ( ) ; process Ui Events ( ) ; }
private boolean check External Storage And Notify ( String filename , String full Dir Path , String external Storage Status ) { if ( full Dir Path == null ) { Log . e ( TAG , STRING ) ; alert Download Failure ( filename ) ; return BOOL ; } if ( ! external Storage Status . equals ( Environment . MEDIA MOUNTED ) ) { if ( external Storage Status . equals ( Environment . MEDIA SHARED ) ) { Log . e ( TAG , STRING ) ; } else { Log . e ( TAG , STRING ) ; } alert Download Failure ( filename ) ; return BOOL ; } return BOOL ; }
public static void append Connections ( Vector < Bean Connection > connections , int tab ) { if ( tab < TABBED CONNECTIONS . size ( ) ) { Vector < Bean Connection > cons = TABBED CONNECTIONS . get ( tab ) ; for ( int i = NUM ; i < connections . size ( ) ; i ++ ) { cons . add ( connections . get ( i ) ) ; } } }
protected void paint Origin Point ( Point 2 D origin Pnt , Graphics graphics , Map Bean the Map ) { if ( the Map != null && origin Pnt != null ) { OM Point pt = new OM Point ( origin Pnt . get Y ( ) , origin Pnt . get X ( ) ) ; prepare Point ( pt ) ; pt . generate ( the Map . get Rotated Projection ( ) ) ; pt . render ( graphics ) ; } }
public void to Char Array ( char [ ] b , int offset , int length ) { if ( buffer . length == NUM ) return ; int t = Math . min ( length , len ) ; int to End = Math . min ( t , buffer . length - start ) ; System . arraycopy ( buffer , start , b , offset , to End ) ; if ( to End < t ) System . arraycopy ( buffer , NUM , b , offset + to End , t - to End ) ; }
@ Override public Trie optimize ( Trie orig ) { List < Char Sequence > cmds = orig . cmds ; List < Row > rows = new Array List < > ( ) ; List < Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; Arrays . fill ( remap , NUM ) ; for ( int j = orows . size ( ) - NUM ; j >= NUM ; j -- ) { if ( eat ( orows . get ( j ) , remap ) ) { remap [ j ] = NUM ; } } Arrays . fill ( remap , - NUM ) ; rows = remove Gaps ( orig . root , orows , new Array List < Row > ( ) , remap ) ; return new Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
protected Request Handle send Request ( Default Http Client client , Http Context http Context , Http Uri Request uri Request , String content Type , Response Handler Interface response Handler , Context context ) { if ( content Type != null ) { uri Request . set Header ( STRING , content Type ) ; } response Handler . set Request Headers ( uri Request . get All Headers ( ) ) ; response Handler . set Request URI ( uri Request . get URI ( ) ) ; Future < ? > request = thread Pool . submit ( new Async Http Request ( client , http Context , uri Request , response Handler ) ) ; if ( context != null ) { List < Weak Reference < Future < ? > > > request List = request Map . get ( context ) ; if ( request List == null ) { request List = new Linked List < Weak Reference < Future < ? > > > ( ) ; request Map . put ( context , request List ) ; } request List . add ( new Weak Reference < Future < ? > > ( request ) ) ; } return new Request Handle ( request ) ; }
@ Override public void close Write ( ) throws IO Exception { if ( is Close Write ) { return ; } is Close Write = BOOL ; boolean is Shutdown Output = BOOL ; if ( s != null ) { try { s . shutdown Output ( ) ; is Shutdown Output = BOOL ; } catch ( Unsupported Operation Exception e ) { log . log ( Level . FINEST , e . to String ( ) , e ) ; } catch ( Exception e ) { log . finer ( e . to String ( ) ) ; log . log ( Level . FINEST , e . to String ( ) , e ) ; } } }
@ Override public Storage create Storage ( Storage Create Request storage Create Request ) { validate Storage Create Request ( storage Create Request ) ; Storage Platform Entity storage Platform Entity = storage Platform Helper . get Storage Platform Entity ( storage Create Request . get Storage Platform Name ( ) ) ; Storage Entity storage Entity = storage Dao . get Storage By Name ( storage Create Request . get Name ( ) ) ; if ( storage Entity != null ) { throw new Already Exists Exception ( String . format ( STRING , storage Create Request . get Name ( ) ) ) ; } storage Entity = new Storage Entity ( ) ; storage Entity . set Name ( storage Create Request . get Name ( ) ) ; storage Entity . set Storage Platform ( storage Platform Entity ) ; if ( ! Collection Utils . is Empty ( storage Create Request . get Attributes ( ) ) ) { List < Storage Attribute Entity > attribute Entities = new Array List < > ( ) ; storage Entity . set Attributes ( attribute Entities ) ; for ( Attribute attribute : storage Create Request . get Attributes ( ) ) { Storage Attribute Entity attribute Entity = new Storage Attribute Entity ( ) ; attribute Entities . add ( attribute Entity ) ; attribute Entity . set Storage ( storage Entity ) ; attribute Entity . set Name ( attribute . get Name ( ) ) ; attribute Entity . set Value ( attribute . get Value ( ) ) ; } } storage Entity = storage Dao . save And Refresh ( storage Entity ) ; return create Storage From Entity ( storage Entity ) ; }
public void init Info Widgets ( ) { Debug . message ( STRING , STRING ) ; Grid Bag Layout gridbag = new Grid Bag Layout ( ) ; Grid Bag Constraints c = new Grid Bag Constraints ( ) ; set Font ( new Font ( STRING , Font . PLAIN , NUM ) ) ; set Layout ( gridbag ) ; progress Bar = new J Progress Bar ( ) ; gridbag . set Constraints ( progress Bar , c ) ; add ( progress Bar ) ; progress Bar . set Visible ( BOOL ) ; J Panel info Line Panel = new J Panel ( ) ; c . weightx = NUM ; c . anchor = Grid Bag Constraints . WEST ; c . fill = Grid Bag Constraints . HORIZONTAL ; gridbag . set Constraints ( info Line Panel , c ) ; Grid Bag Layout gridbag 2 = new Grid Bag Layout ( ) ; Grid Bag Constraints c2 = new Grid Bag Constraints ( ) ; info Line Panel . set Layout ( gridbag 2 ) ; info Line Holder = new J Label ( fudge String ) ; c2 . weightx = NUM ; c2 . fill = Grid Bag Constraints . HORIZONTAL ; c2 . anchor = Grid Bag Constraints . WEST ; c2 . insets = new Insets ( NUM , NUM , NUM , NUM ) ; gridbag 2 . set Constraints ( info Line Holder , c2 ) ; info Line Panel . add ( info Line Holder ) ; info Line Holder 2 = new J Label ( fudge String , Swing Constants . RIGHT ) ; c2 . weightx = NUM ; c2 . anchor = Grid Bag Constraints . EAST ; gridbag 2 . set Constraints ( info Line Holder 2 , c2 ) ; info Line Panel . add ( info Line Holder 2 ) ; add Info Line ( COORDINATE INFO LINE , info Line Holder ) ; add Info Line ( MAP OBJECT INFO LINE , info Line Holder 2 ) ; add ( info Line Panel ) ; c . weightx = NUM ; c . anchor = Grid Bag Constraints . EAST ; status Bar = new Status Light Panel ( ) ; gridbag . set Constraints ( status Bar , c ) ; add ( status Bar ) ; status Bar . set Visible ( show Lights ) ; }
public void test Signer String ( ) throws Exception { Signer s = new Signer Stub ( STRING ) ; assert Not Null ( s ) ; assert Equals ( STRING , s . get Name ( ) ) ; assert Null ( s . get Private Key ( ) ) ; Signer s2 = new Signer Stub ( null ) ; assert Null ( s2 . get Name ( ) ) ; }
public T Sink < String > send String ( T Stream < String > stream ) { Objects . require Non Null ( stream , STRING ) ; return send Text ( stream , null ) ; }
protected static Method resolve Java Method ( Bsh Class Manager bcm , Class clas , String name , Class [ ] types , boolean static Only ) throws Util Eval Error { if ( clas == null ) throw new Interpreter Error ( STRING ) ; Method method = null ; if ( bcm == null ) Interpreter . debug ( STRING ) ; else method = bcm . get Resolved Method ( clas , name , types , static Only ) ; if ( method == null ) { boolean public Only = ! Capabilities . have Accessibility ( ) ; try { method = find Overloaded Method ( clas , name , types , public Only ) ; } catch ( Security Exception e ) { throw new Util Target Error ( STRING + clas , e ) ; } check Found Static Method ( method , static Only , clas ) ; if ( method != null && ! public Only ) { try { Reflect Manager . RM Set Accessible ( method ) ; } catch ( Util Eval Error e ) { } } if ( method != null && bcm != null ) bcm . cache Resolved Method ( clas , types , method ) ; } return method ; }
protected Abstract Regex NP Annotator ( String pattern , int matcher Group , boolean case Sensitive , double confidence ) { this ( Pattern . compile ( pattern , case Sensitive ? NUM : Pattern . CASE INSENSITIVE ) , matcher Group , confidence ) ; }
private void compute Multiplier ( LST Node n ) { n . initialize Loop Exits ( ) ; compute Node Weights ( n ) ; float loop Exit Weight = compute Loop Exit Weight ( n ) ; n . loop Multiplier = NUM / loop Exit Weight ; }
@ Override public void on Bind View Holder ( K holder , int position ) { holder . bind Item ( items . get ( position ) ) ; }
public static Date days After ( Date date Inst , int num Days ) { if ( ( num Days <= NUM ) || ( date Inst == null ) ) { throw new Illegal Argument Exception ( ) ; } final Calendar cal = new Gregorian Calendar ( ) ; cal . set Time ( date Inst ) ; cal . add ( Calendar . DAY OF YEAR , num Days ) ; return cal . get Time ( ) ; }
public void assure Buffer Capacity ( final int len ) { while ( len > buffer . remaining ( ) ) { int new Capacity = Math . max ( ( int ) ( len + buffer . position ( ) * BIG SIZE INCREASE ) , ( int ) ( ( buffer . capacity ( ) > NUM ) ? buffer . capacity ( ) * BIG SIZE INCREASE : buffer . capacity ( ) * NORMAL INCREASE ) ) ; increase ( new Capacity ) ; } }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Object ( conservative Approximation ) ; out . write Object ( progressive Approximation ) ; }
public void write ( Array List < Key Value > metadata , long image Start , Raster raster , Data Type data Type ) throws IO Exception { Output Stream o Stream = new File Output Stream ( file Path ) ; if ( o Stream != null ) { output Stream = new Buffered Output Stream ( o Stream ) ; } Label Parser parser = new Label Parser ( ) ; Buffered Writer writer = new Buffered Writer ( new Output Stream Writer ( output Stream ) ) ; long size = parser . write Object ( writer , metadata , STRING ) ; long pad = image Start - size ; for ( int i = NUM ; i < pad ; ++ i ) { writer . write ( STRING ) ; } writer . flush ( ) ; data Stream = new Data Output Stream ( output Stream ) ; write Raster ( raster , data Type ) ; }
private void paint Drop Lines ( Sea Glass Context context , Graphics g ) { J Table . Drop Location loc = table . get Drop Location ( ) ; if ( loc == null ) { return ; } Color color = ( Color ) style . get ( context , STRING ) ; Color short Color = ( Color ) style . get ( context , STRING ) ; if ( color == null && short Color == null ) { return ; } Rectangle rect ; rect = get H Drop Line Rect ( loc ) ; if ( rect != null ) { int x = rect . x ; int w = rect . width ; if ( color != null ) { extend Rect ( rect , BOOL ) ; g . set Color ( color ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } if ( ! loc . is Insert Column ( ) && short Color != null ) { g . set Color ( short Color ) ; g . fill Rect ( x , rect . y , w , rect . height ) ; } } rect = get V Drop Line Rect ( loc ) ; if ( rect != null ) { int y = rect . y ; int h = rect . height ; if ( color != null ) { extend Rect ( rect , BOOL ) ; g . set Color ( color ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } if ( ! loc . is Insert Row ( ) && short Color != null ) { g . set Color ( short Color ) ; g . fill Rect ( rect . x , y , rect . width , h ) ; } } }
public static String response ( final String c Question , final String c Title , final String c Default , final boolean b Password , final String c Label ) { final Border Layout layout = new Border Layout ( ) ; layout . set Hgap ( NUM ) ; final J Panel panel = new J Panel ( layout ) ; final J Label question = new J Label ( c Question ) ; final J Text Field field ; if ( b Password ) { field = new J Password Field ( ) ; } else { field = new J Text Field ( ) ; } if ( c Default != null ) { field . set Text ( c Default ) ; } final String title ; if ( c Title != null ) { title = c Title ; } else { title = STRING ; } panel . add ( question , Border Layout . NORTH ) ; if ( c Label != null ) { final J Label label = new J Label ( c Label ) ; panel . add ( label , Border Layout . WEST ) ; } panel . add ( field , Border Layout . CENTER ) ; final String [ ] options = { STRING , STRING } ; final int option = J Option Pane . show Option Dialog ( null , panel , title , J Option Pane . NO OPTION , J Option Pane . PLAIN MESSAGE , null , options , options [ NUM ] ) ; if ( option == NUM ) { return field . get Text ( ) ; } else { return null ; } }
private void on Sensor Data Start ( Attributes attributes ) { sensor Name = attributes . get Value ( ATTRIBUTE NAME ) ; }
public static byte [ ] read Input Stream ( Input Stream in ) throws IO Exception { try { class Part { byte [ ] part Data ; int len ; } Linked List < Part > parts = new Linked List < > ( ) ; int len = NUM ; while ( len > NUM ) { byte [ ] data = new byte [ NUM ] ; len = in . read ( data ) ; if ( len > NUM ) { Part part = new Part ( ) ; part . part Data = data ; part . len = len ; parts . add ( part ) ; } } int length = NUM ; for ( Part part : parts ) { length += part . len ; } byte [ ] result = new byte [ length ] ; int pos = NUM ; for ( Part part : parts ) { System . arraycopy ( part . part Data , NUM , result , pos , part . len ) ; pos += part . len ; } return result ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IO Exception e ) { } } } }
public void add ( I Resource [ ] resources , I Progress Monitor monitor ) throws Team Exception { if ( monitor == null ) { monitor = new Null Progress Monitor ( ) ; } Map table = get Provider Mapping ( resources ) ; if ( table . get ( null ) != null ) { throw new SVN Exception ( Policy . bind ( STRING ) ) ; } Set key Set = table . key Set ( ) ; monitor . begin Task ( STRING , key Set . size ( ) * NUM ) ; monitor . set Task Name ( Policy . bind ( STRING ) ) ; Iterator iterator = key Set . iterator ( ) ; while ( iterator . has Next ( ) ) { I Progress Monitor sub Monitor = new Sub Progress Monitor ( monitor , NUM ) ; SVN Team Provider provider = ( SVN Team Provider ) iterator . next ( ) ; List list = ( List ) table . get ( provider ) ; I Resource [ ] provider Resources = ( I Resource [ ] ) list . to Array ( new I Resource [ list . size ( ) ] ) ; provider . add ( provider Resources , I Resource . DEPTH ZERO , sub Monitor ) ; } }
private boolean is New Workers Required ( ) { stats Util . poll Stats Broker Job Queue ( ) ; final Stats Message Listener stats Message Listener = stats Util . get Stats Message Listener ( ) ; if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + stats Message Listener . get Stats ( ) ) ; } boolean quick Spawn Mode = BOOL ; int total Remote Worker Spawned = get Number Of Workers ( ) ; int consumer Count = stats Message Listener . get Consumers ( ) ; int remote Worker Count = consumer Count - max Concurrent In Vm Worker Count ; int queue Size = stats Message Listener . get Queue Size ( ) ; if ( verbose Log Level > NUM ) { Utilities . verbose Log ( STRING + max Consumer Size + STRING + consumer Count + STRING + queue Size + STRING + total Remote Worker Spawned + STRING + remote Worker Count + STRING + queue Consumer Ratio + STRING + life Remaining ( ) ) ; } if ( consumer Count < queue Size ) { if ( remote Worker Count > NUM ) { quick Spawn Mode = ( queue Size / remote Worker Count ) > max Concurrent In Vm Worker Count ; } else { quick Spawn Mode = queue Size > max Concurrent In Vm Worker Count ; } if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STRING + quick Spawn Mode ) ; } if ( verbose Log Level > NUM ) { Utilities . verbose Log ( STRING + max Consumer Size + STRING + remote Worker Count + STRING + queue Consumer Ratio + STRING + quick Spawn Mode + STRING + life Remaining ( ) / completion Factor ) ; } return ( stats Message Listener . new Workers Required ( ( int ) ( life Remaining ( ) / completion Factor ) ) && ( consumer Count < max Consumer Size ) && ( consumer Count < queue Size / queue Consumer Ratio ) ) || ( quick Spawn Mode ) ; } return BOOL ; }
public boolean equals ( Object object ) { if ( this == object ) { return BOOL ; } else if ( object == null || get Class ( ) != object . get Class ( ) ) { return BOOL ; } return SSO Session ID . equals ( object ) ; }
public static boolean request Mana Exact For Tool ( Item Stack stack , Entity Player player , int mana To Get , boolean remove ) { float multiplier = Math . max ( NUM , NUM - get Full Discount For Tools ( player ) ) ; int cost = ( int ) ( mana To Get * multiplier ) ; return request Mana Exact ( stack , player , cost , remove ) ; }
protected String use Kernel ( Instances data ) throws Exception { Kernel kernel = null ; String Buffer text = new String Buffer ( ) ; try { kernel = Kernel . make Copy ( m Kernel ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + e ) ; } kernel . build Kernel ( data ) ; for ( int n = NUM ; n < data . num Instances ( ) ; n ++ ) { for ( int i = n ; i < data . num Instances ( ) ; i ++ ) { text . append ( ( n + NUM ) + STRING + ( i + NUM ) + STRING + kernel . eval ( n , i , data . instance ( i ) ) + STRING ) ; } } return text . to String ( ) ; }
public void remove ( List < ? > list , int position ) { if ( list . size ( ) > NUM ) { list . remove ( custom Header View != null ? position - NUM : position ) ; notify Item Removed ( position ) ; } }
public AM View Bean Base ( String name ) { super ( name ) ; }
public boolean fire Map Mouse Moved ( Mouse Event evt ) { if ( DEBUG DETAIL ) { logger . fine ( STRING ) ; } boolean consumed = BOOL ; if ( proxy == null || evt . is Shift Down ( ) || ( proxy Distribution Mask & PROXY DISTRIB MOUSE MOVED ) > NUM ) { evt = new Map Mouse Event ( get Parent Mode ( ) , evt ) ; Iterator < Map Mouse Listener > it = iterator ( ) ; while ( it . has Next ( ) ) { Map Mouse Listener target = it . next ( ) ; if ( consumed ) { target . mouse Moved ( ) ; } else { consumed = target . mouse Moved ( evt ) ; } } } consumed &= consume Events ; boolean ignore Consumed = ! consumed || ( consumed && ( ( proxy Distribution Mask & PROXY ACK CONSUMED MOUSE MOVED ) == NUM ) ) ; if ( proxy != null && ignore Consumed && ! evt . is Shift Down ( ) ) { proxy . mouse Moved ( evt ) ; consumed = BOOL ; } return consumed ; }
private Array List < Neuron > initialize Layer ( Neuron Update Rule node Type , int nodes ) { Array List < Neuron > layer = new Array List < Neuron > ( nodes ) ; for ( int i = NUM ; i < nodes ; i ++ ) { Neuron node = new Neuron ( get Parent Network ( ) , node Type ) ; node Type . set Increment ( NUM ) ; layer . add ( node ) ; } return layer ; }
private void add Fillet ( Coordinate p , Coordinate p0 , Coordinate p1 , int direction , double radius ) { double dx 0 = p0 . x - p . x ; double dy 0 = p0 . y - p . y ; double start Angle = Math . atan 2 ( dy 0 , dx 0 ) ; double dx 1 = p1 . x - p . x ; double dy 1 = p1 . y - p . y ; double end Angle = Math . atan 2 ( dy 1 , dx 1 ) ; if ( direction == CG Algorithms . CLOCKWISE ) { if ( start Angle <= end Angle ) start Angle += NUM * Math . PI ; } else { if ( start Angle >= end Angle ) start Angle -= NUM * Math . PI ; } seg List . add Pt ( p0 ) ; add Fillet ( p , start Angle , end Angle , direction , radius ) ; seg List . add Pt ( p1 ) ; }
public void add Neuron Listener ( final Neuron Listener listener ) { neuron Listeners . add ( listener ) ; }
public void import Certs ( String [ ] cert File Names , String alias Prefix ) throws Certificate Exception , IO Exception , Key Store Exception , No Such Algorithm Exception { if ( cert File Names == null ) { return ; } Certificate Factory cert Factory = Certificate Factory . get Instance ( STRING ) ; for ( String fn : cert File Names ) { Input Stream in Stream = new File Input Stream ( fn ) ; X509 Certificate cert = ( X509 Certificate ) cert Factory . generate Certificate ( in Stream ) ; in Stream . close ( ) ; String alias = alias Prefix == null ? fn : alias Prefix + fn ; key Store . set Certificate Entry ( alias , cert ) ; } }
void handle Selection Changed ( String selection ) { if ( m Did Expand Selection ) { m Selected Text = selection ; m Did Expand Selection = BOOL ; return ; } if ( selection == null || selection . is Empty ( ) ) { schedule Invalid Tap Notification ( ) ; if ( m Selection Type == Selection Type . TAP ) { reset Selection States ( ) ; return ; } } if ( ! selection . is Empty ( ) ) { unschedule Invalid Tap Notification ( ) ; } m Selected Text = selection ; if ( m Was Tap Gesture Detected ) { m Selection Type = Selection Type . TAP ; handle Selection ( selection , m Selection Type ) ; m Was Tap Gesture Detected = BOOL ; } else { m Handler . handle Selection Modification ( selection , is Valid Selection ( selection ) , mX , mY ) ; } }
public Terms Request Parser parse ( ) throws Parser Configuration Exception , SAX Exception , Parse Failure Exception { try { SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; SAX Parser parser = factory . new SAX Parser ( ) ; parser . parse ( m Input Source , this ) ; return this ; } catch ( IO Exception e ) { throw new Parse Failure Exception ( STRING , e ) ; } }
private boolean parse Html ( String html ) { Pattern p = Pattern . compile ( STRING ) ; Matcher m = p . matcher ( html ) ; if ( ! m . find ( ) ) { p = Pattern . compile ( STRING ) ; m = p . matcher ( html ) ; } if ( ! m . find ( ) ) { return BOOL ; } delay = Integer . parse Int ( m . group ( NUM ) ) ; url = m . group ( NUM ) ; return BOOL ; }
public static boolean validate Ip Port List ( String ip Port List ) { if ( ip Port List == null || ip Port List . is Empty ( ) ) { return BOOL ; } String [ ] server Port List = ip Port List . split ( STRING ) ; for ( String server Port : server Port List ) { String ip = server Port . substring ( NUM , server Port . last Index Of ( STRING ) ) ; String port = server Port . substring ( server Port . last Index Of ( STRING ) + NUM ) ; if ( ip . starts With ( STRING ) && ip . ends With ( STRING ) ) { ip = ip . substring ( NUM , ip . length ( ) - NUM ) ; if ( ! validate Ipv 6 Addr ( ip ) ) return BOOL ; } else if ( validate Ipv 6 Addr ( ip ) ) { return BOOL ; } else if ( ! validate Host Name ( ip ) ) { return BOOL ; } if ( ! validate Uint 16 ( port ) ) return BOOL ; } return BOOL ; }
private Response Packet execute Delete ( Query Template Packet template , I Space Proxy space , Transaction txn ) throws Remote Exception , Transaction Exception , Unusable Entry Exception , Interrupted Exception { Response Packet packet = new Response Packet ( ) ; template . set Operation ID ( get Operation ID ( ) ) ; template . set Explain Plan ( get Explain Plan ( ) ) ; if ( is Return Result ( ) ) { int max = get Rownum Limit ( ) ; Array List < I Entry Packet > entries = template . take ( space , get Routing ( ) , get Projection Template ( ) , txn , get Timeout ( ) , get Read Modifier ( ) , get If Exists ( ) , max , get Min Entries To Wait For ( ) , get Query Result Type ( ) ) ; packet . set Result Set ( entries ) ; packet . set Int Result ( entries . size ( ) ) ; } else { template . set Routing ( get Routing ( ) ) ; int cleared = executor . clear ( template , space , txn , get Read Modifier ( ) ) ; packet . set Int Result ( cleared ) ; } return packet ; }
public static Range find Stacked Range Bounds ( Table XY Dataset dataset , double base ) { Param Checks . null Not Permitted ( dataset , STRING ) ; double minimum = base ; double maximum = base ; for ( int item No = NUM ; item No < dataset . get Item Count ( ) ; item No ++ ) { double positive = base ; double negative = base ; int series Count = dataset . get Series Count ( ) ; for ( int series No = NUM ; series No < series Count ; series No ++ ) { double y = dataset . get Y Value ( series No , item No ) ; if ( ! Double . is Na N ( y ) ) { if ( y > NUM ) { positive += y ; } else { negative += y ; } } } if ( positive > maximum ) { maximum = positive ; } if ( negative < minimum ) { minimum = negative ; } } if ( minimum <= maximum ) { return new Range ( minimum , maximum ) ; } else { return null ; } }
public void put ( Unique String key , Object val ) { int loc = key . get Defn Loc ( ) ; if ( loc == - NUM ) { loc = defn Idx ++ ; key . set Loc ( loc ) ; } if ( loc >= this . table . length ) { int old Size = this . table . length ; int new Size = Math . max ( NUM * old Size , loc + NUM ) ; Object [ ] old = this . table ; this . table = new Object [ new Size ] ; System . arraycopy ( old , NUM , this . table , NUM , old . length ) ; } this . table [ loc ] = val ; }
public void action Performed ( Action Event e ) { J File Chooser fc = new J File Chooser ( STRING ) ; fc . set Multi Selection Enabled ( BOOL ) ; fc . set File Selection Mode ( J File Chooser . FILES ONLY ) ; boolean save = BOOL ; int option = NUM ; if ( e . get Source ( ) == m Open Button ) { log . fine ( STRING ) ; option = fc . show Open Dialog ( this ) ; save = BOOL ; } if ( e . get Source ( ) == m Save Button ) { log . fine ( STRING ) ; option = fc . show Save Dialog ( this ) ; save = BOOL ; } if ( option != J File Chooser . APPROVE OPTION ) return ; File file = fc . get Selected File ( ) ; if ( file == null ) return ; log . info ( file . to String ( ) ) ; try { if ( save ) { File Output Stream os = new File Output Stream ( file ) ; byte [ ] buffer = ( byte [ ] ) m data ; os . write ( buffer ) ; os . flush ( ) ; os . close ( ) ; log . config ( STRING + file + STRING + buffer . length ) ; } else { File Input Stream is = new File Input Stream ( file ) ; Byte Array Output Stream os = new Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ NUM * NUM ] ; int length = - NUM ; while ( ( length = is . read ( buffer ) ) != - NUM ) os . write ( buffer , NUM , length ) ; is . close ( ) ; byte [ ] data = os . to Byte Array ( ) ; m data = data ; log . config ( STRING + file + STRING + data . length ) ; os . close ( ) ; } } catch ( Exception ex ) { log . log ( Level . WARNING , STRING + save , ex ) ; } try { fire Vetoable Change ( m column Name , null , m data ) ; } catch ( Property Veto Exception pve ) { } }
public static int deflate ( byte [ ] previous , int previous Length , byte [ ] current , int current Length , byte [ ] result ) { if ( previous == null ) { System . arraycopy ( current , NUM , result , NUM , current Length ) ; return current Length ; } int length = NUM ; int start 1 = NUM ; int start 2 = NUM ; while ( start 1 < previous Length && start 2 < current Length ) { int end 1 = start 1 ; int end 2 = start 2 ; while ( end 1 <= previous Length && end 2 <= current Length ) { byte c1 = ( end 1 < previous Length ? previous [ end 1 ] : ( byte ) STRING ) ; byte c2 = ( end 2 < current Length ? current [ end 2 ] : ( byte ) STRING ) ; if ( c1 == c2 ) { if ( c1 == STRING ) { result [ length ++ ] = STRING ; break ; } else { end 1 ++ ; end 2 ++ ; } } else { while ( end 1 < previous Length && previous [ end 1 ] != STRING ) { end 1 ++ ; } while ( end 2 < current Length && current [ end 2 ] != STRING ) { end 2 ++ ; } for ( int i = start 2 ; i < end 2 ; i ++ ) result [ length ++ ] = current [ i ] ; break ; } } start 1 = end 1 + NUM ; start 2 = end 2 + NUM ; if ( start 2 < current Length ) result [ length ++ ] = STRING ; } return length ; }
public Buffered Image create Graph From Scores ( int [ ] scores , int [ ] chart Slices ) { Buffered Image bi = new Buffered Image ( WIDTH , HEIGHT , Buffered Image . TYPE INT RGB ) ; Graphics 2 D g2 d = bi . create Graphics ( ) ; Rendering Hints render Hints = new Rendering Hints ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g2 d . set Rendering Hints ( render Hints ) ; g2 d . set Color ( Color . white ) ; g2 d . fill ( graph Rect ) ; g2 d . set Color ( Color . black ) ; border Rect . set Location ( NUM , NUM ) ; g2 d . draw ( border Rect ) ; border Rect . set Location ( ( WIDTH / NUM ) + NUM , NUM ) ; g2 d . draw ( border Rect ) ; int x pie = inner Offset ; int y pie = inner Offset ; int border = NUM ; Ellipse 2 D . Double elb = new Ellipse 2 D . Double ( x pie - border / NUM , y pie - border / NUM , pie Width + border , pie Height + border ) ; g2 d . set Color ( drop Shadow ) ; g2 d . fill ( elb ) ; g2 d . set Color ( Color . black ) ; g2 d . draw ( elb ) ; int start Angle = NUM ; int legend Width = NUM ; int x legend Text = half Width + inner Offset / NUM + legend Width + NUM ; int x legend Bar = half Width + inner Offset / NUM ; int text Height = NUM ; int cur Element = NUM ; int y legend = NUM ; Dimension legend Dim = new Dimension ( legend Width , text Height / NUM ) ; Rectangle legend Rect = new Rectangle ( legend Dim ) ; int last Element = chart Slices . length ; float number Of Scores = NUM ; for ( int i = NUM ; i < scores . length ; i ++ ) { number Of Scores += NUM ; } if ( scores == null || number Of Scores == NUM ) { int sweep Angle = NUM ; g2 d . set Color ( Color . GRAY ) ; g2 d . fill Arc ( x pie , y pie , pie Width , pie Height , start Angle , sweep Angle ) ; y legend = cur Element * text Height + inner Offset ; String display = STRING ; g2 d . set Color ( Color . black ) ; g2 d . draw String ( display , x legend Text , y legend ) ; cur Element ++ ; y legend = cur Element * text Height + inner Offset ; display = STRING ; g2 d . set Color ( Color . black ) ; g2 d . draw String ( display , x legend Text , y legend ) ; return bi ; } else { float [ ] float Scores = convert Int To Float Array ( scores ) ; float [ ] scores Per Slice = calc Score Per Slice ( chart Slices , float Scores ) ; for ( int i = NUM ; i < chart Slices . length ; i ++ ) { float perc = ( scores Per Slice [ i ] / number Of Scores ) ; int sweep Angle = ( int ) ( perc * NUM ) ; if ( i == last Element ) { sweep Angle = NUM - start Angle ; } g2 d . set Color ( get Pie Color ( ) ) ; g2 d . fill Arc ( x pie , y pie , pie Width , pie Height , start Angle , sweep Angle ) ; start Angle += sweep Angle ; y legend = cur Element * text Height + inner Offset ; String display = null ; if ( i == NUM ) { display = STRING + chart Slices [ NUM ] ; } else { display = chart Slices [ i - NUM ] - NUM + STRING + chart Slices [ i ] ; } g2 d . set Color ( Color . black ) ; g2 d . draw String ( display , x legend Text , y legend ) ; display = STRING + ( int ) scores Per Slice [ i ] ; g2 d . set Color ( Color . black ) ; g2 d . draw String ( display , x legend Text + NUM , y legend ) ; display = STRING + ( int ) ( perc * NUM ) + STRING ; g2 d . set Color ( Color . black ) ; g2 d . draw String ( display , x legend Text + NUM , y legend ) ; g2 d . set Color ( get Pie Color ( ) ) ; legend Rect . set Location ( x legend Bar , y legend - text Height / NUM ) ; g2 d . fill ( legend Rect ) ; set New Color ( ) ; cur Element ++ ; } return bi ; } }
private static Binlog Event V 4 form Bin Log Table Map Event ( String db Name , String table Name , long table Id ) { Binlog Event V 4 Header Impl table Map Event Header = new Binlog Event V 4 Header Impl ( ) ; table Map Event Header . set Timestamp ( System . current Time Millis ( ) ) ; table Map Event Header . set Event Type ( My SQL Constants . TABLE MAP EVENT ) ; table Map Event Header . set Server Id ( NUM ) ; Table Map Event table Map Event = new Table Map Event ( table Map Event Header ) ; table Map Event . set Table Id ( table Id ) ; table Map Event . set Database Name Length ( db Name . length ( ) ) ; table Map Event . set Database Name ( String Column . value Of ( db Name . get Bytes ( ) ) ) ; table Map Event . set Table Name Length ( table Name . length ( ) ) ; table Map Event . set Table Name ( String Column . value Of ( table Name . get Bytes ( ) ) ) ; return table Map Event ; }
private static String create Bcrypt String ( byte [ ] password , byte [ ] salt , int cost ) { String Buffer sb = new String Buffer ( NUM ) ; sb . append ( STRING ) ; sb . append ( version ) ; sb . append ( STRING ) ; sb . append ( cost < NUM ? ( STRING + cost ) : Integer . to String ( cost ) ) ; sb . append ( STRING ) ; sb . append ( encode Data ( salt ) ) ; byte [ ] key = B Crypt . generate ( password , salt , cost ) ; sb . append ( encode Data ( key ) ) ; return sb . to String ( ) ; }
protected int read Application Data ( byte [ ] buf , int offset , int len ) throws IO Exception { if ( len < NUM ) { return NUM ; } while ( application Data Queue . available ( ) == NUM ) { if ( this . closed ) { if ( this . failed With Error ) { throw new IO Exception ( TLS ERROR MESSAGE ) ; } return - NUM ; } safe Read Record ( ) ; } len = Math . min ( len , application Data Queue . available ( ) ) ; application Data Queue . remove Data ( buf , offset , len , NUM ) ; return len ; }
private void assign Tasks To Containers ( int [ ] task Count Per Container , List < String > task Names To Assign , List < Task Group > containers ) { for ( Task Group task Group : containers ) { for ( int j = task Group . size ( ) ; j < task Count Per Container [ task Group . get Container Id ( ) ] ; j ++ ) { String task Name = task Names To Assign . remove ( NUM ) ; task Group . add Task Name ( task Name ) ; log . info ( STRING , task Name , task Group . get Container Id ( ) ) ; } } }
protected void process Pages ( List < PD Page > pages ) throws IO Exception { max Page = pages . size ( ) ; for ( final PD Page page : pages ) { current Page No ++ ; final PD Stream content Stream = page . get Contents ( ) ; if ( content Stream != null ) { final COS Stream contents = content Stream . get Stream ( ) ; process Page ( page , contents ) ; } } }
@ Override protected List < String > create New Export Mask Workflow For Initiators ( List < URI > initiator UR Is , Export Group export Group , Workflow workflow , Map < URI , Integer > volume Map , Storage System storage , String token , String previous Step ) throws Exception { List < String > new Steps = new Array List < > ( ) ; if ( ! initiator UR Is . is Empty ( ) ) { Map < String , List < URI > > compute Resource To Initiators = map Initiators To Compute Resource ( export Group , initiator UR Is ) ; for ( Map . Entry < String , List < URI > > resource Entry : compute Resource To Initiators . entry Set ( ) ) { String compute Key = resource Entry . get Key ( ) ; List < URI > compute Initiator UR Is = resource Entry . get Value ( ) ; log . info ( String . format ( STRING , compute Key ) ) ; Gen Export Mask Create Workflow Result result = generate Device Specific Export Mask Create Work Flow ( workflow , previous Step , storage , export Group , compute Initiator UR Is , volume Map , token ) ; previous Step = result . get Step Id ( ) ; } } new Steps . add ( previous Step ) ; return new Steps ; }
public boolean is Greater Then ( Percent Percent ) { assert Defined ( ) ; Big Decimal this Value = not Null ( this ) ; Big Decimal parameter = not Null ( Percent ) ; return ( this Value . compare To ( parameter ) > NUM ) ; }
@ Override public URI to Vertex URI ( final Object key ) { return to URI ( key . to String ( ) ) ; }
public static List < I Navi Module > load Modules ( final Abstract SQL Provider provider , final List < I Navi Raw Module > raw Modules , final Debugger Template Manager debugger Manager ) throws Couldnt Load Data Exception { Preconditions . check Not Null ( raw Modules , STRING ) ; Postgre SQL Database Functions . check Arguments ( provider , debugger Manager ) ; final List < C Module > modules = new Array List < > ( ) ; final C Connection connection = provider . get Connection ( ) ; if ( ! Postgre SQL Helpers . has Table ( connection , C Table Names . MODULES TABLE ) ) { return new Array List < I Navi Module > ( modules ) ; } final String query = STRING + C Table Names . MODULES TABLE + STRING + STRING + STRING + STRING + C Table Names . FUNCTIONS TABLE + STRING + STRING + C Table Names . FUNCTIONS TABLE + STRING + STRING + STRING + C Table Names . MODULE VIEWS TABLE + STRING + C Table Names . VIEWS TABLE + STRING + STRING + C Table Names . MODULES TABLE + STRING + STRING + C Table Names . MODULES TABLE + STRING + STRING ; try ( Result Set result Set = connection . execute Query ( query , BOOL ) ) { while ( result Set . next ( ) ) { final int module Id = result Set . get Int ( STRING ) ; final String name = Postgre SQL Helpers . read String ( result Set , STRING ) ; final String md 5 = Postgre SQL Helpers . read String ( result Set , STRING ) ; final String sha 1 = Postgre SQL Helpers . read String ( result Set , STRING ) ; final String comment = Postgre SQL Helpers . read String ( result Set , STRING ) ; final Timestamp timestamp = result Set . get Timestamp ( STRING ) ; final Timestamp modification Date = result Set . get Timestamp ( STRING ) ; int function Count = result Set . get Int ( STRING ) ; final int view Count = result Set . get Int ( STRING ) ; final I Address image Base = Postgre SQL Helpers . load Address ( result Set , STRING ) ; final I Address file Base = Postgre SQL Helpers . load Address ( result Set , STRING ) ; final int debugger Id = result Set . get Int ( STRING ) ; final boolean is Stared = result Set . get Boolean ( STRING ) ; final int initialization State = result Set . get Int ( STRING ) ; final Debugger Template description = debugger Manager . find Debugger ( debugger Id ) ; final int raw Module Id = result Set . get Int ( STRING ) ; final I Navi Raw Module raw Module = Postgre SQL Database Functions . find Raw Module ( raw Module Id , raw Modules ) ; if ( ( function Count == NUM ) && ( raw Module != null ) ) { function Count = raw Module . get Function Count ( ) ; } modules . add ( new C Module ( module Id , name , comment , timestamp , modification Date , md 5 , sha 1 , function Count , view Count , file Base , image Base , description , raw Module , initialization State , is Stared , provider ) ) ; } } catch ( final SQL Exception e ) { throw new Couldnt Load Data Exception ( e ) ; } return new Array List < I Navi Module > ( modules ) ; }
private String normalize Number ( String phone Number ) { if ( Text Utils . is Empty ( phone Number ) ) { return STRING ; } final String Builder sb = new String Builder ( ) ; final int len = phone Number . length ( ) ; for ( int i = NUM ; i < len ; i ++ ) { final char c = phone Number . char At ( i ) ; final int digit = Character . digit ( c , NUM ) ; if ( digit != - NUM ) { sb . append ( digit ) ; } else if ( i == NUM && c == STRING ) { sb . append ( c ) ; } else if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) ) { return normalize Number ( Phone Number Utils . convert Keypad Letters To Digits ( phone Number ) ) ; } } return sb . to String ( ) ; }
@ Override protected Node remove From Frontier ( ) { clean Up Frontier ( ) ; Node result = frontier . remove ( ) ; explored . add ( result . get State ( ) ) ; update Metrics ( frontier . size ( ) ) ; return result ; }
public static boolean is Directory ( String path ) { File f = new File ( path ) ; return f . is Directory ( ) ; }
public boolean equals ( Object object ) { if ( ! ( object instanceof Attribute ) ) { return BOOL ; } Attribute val = ( Attribute ) object ; if ( value == null ) { if ( val . get Value ( ) == null ) { return name . equals ( val . get Name ( ) ) ; } else { return BOOL ; } } return ( ( name . equals ( val . get Name ( ) ) ) && ( value . equals ( val . get Value ( ) ) ) ) ; }
public Usage Server ( int port , File usage Dir , int threads ) throws IO Exception { if ( ! Charset . is Supported ( UTF 8 ) ) { throw new IO Exception ( STRING ) ; } System . set Property ( STRING , STRING ) ; System . set Property ( STRING , STRING ) ; m Usage Dir = usage Dir ; m Port = port ; m Thread Pool Executor = new Thread Pool Executor ( threads , threads , NUM , Time Unit . SECONDS , new Linked Blocking Queue < Runnable > ( ) , new Usage Server Thread Factory ( ) ) ; }
private boolean put Internal ( String variable , Object value ) { Object old Value = values . get ( variable ) ; values . put ( variable , value ) ; if ( old Value == null ) { return value != null ; } else { return ! old Value . equals ( value ) ; } }
public static < T > FST < T > read ( Path path , Outputs < T > outputs ) throws IO Exception { try ( Input Stream is = Files . new Input Stream ( path ) ) { return new FST < > ( new Input Stream Data Input ( new Buffered Input Stream ( is ) ) , outputs ) ; } }
@ Override public final String to String ( ) { if ( string Rep == null ) { String Builder buffer = new String Builder ( ) ; buffer . append ( this . name ) ; buffer . append ( STRING ) ; buffer . append ( Integer . to String ( this . default Port ) ) ; string Rep = buffer . to String ( ) ; } return string Rep ; }
public Sip Transaction Context send Sip Message ( Sip Message message , Sip Transaction Context . I Notify Sip Provisional Response callback ) throws Network Exception , Payload Exception { return m Sip Interface . send Sip Message And Wait ( message , callback ) ; }
public static < T extends Throwable > T read Stack Trace ( T throwable , Stream Input in ) throws IO Exception { final int stack Trace Elements = in . read V Int ( ) ; Stack Trace Element [ ] stack Trace = new Stack Trace Element [ stack Trace Elements ] ; for ( int i = NUM ; i < stack Trace Elements ; i ++ ) { final String declaring Classs = in . read String ( ) ; final String file Name = in . read Optional String ( ) ; final String method Name = in . read String ( ) ; final int line Number = in . read V Int ( ) ; stack Trace [ i ] = new Stack Trace Element ( declaring Classs , method Name , file Name , line Number ) ; } throwable . set Stack Trace ( stack Trace ) ; int num Suppressed = in . read V Int ( ) ; for ( int i = NUM ; i < num Suppressed ; i ++ ) { throwable . add Suppressed ( in . read Throwable ( ) ) ; } return throwable ; }
public Held Locks Token refresh ( long expiration Date Ms ) { return new Held Locks Token ( token Id , client , creation Date Ms , expiration Date Ms , lock Map , lock Timeout , version Id ) ; }
public static M Print Format copy ( Properties ctx , int from AD Print Format ID , int to AD Print Format ID ) { return copy ( ctx , from AD Print Format ID , to AD Print Format ID , - NUM ) ; }
public Register Values ( final com . google . security . zynamics . binnavi . debug . models . targetinformation . Register Values register Values ) { final List < Thread Register Values > values = new Array List < Thread Register Values > ( ) ; for ( final Thread Registers thread Register Values : register Values ) { values . add ( new Thread Register Values ( thread Register Values ) ) ; } this . values = values ; }
private void save Configuration Files ( List < String > configuration Files , String handle Id , Start Request request ) { int i = NUM ; if ( configuration Files == null || configuration Files . size ( ) == NUM ) { return ; } for ( String filename : configuration Files ) { Input Stream input Stream = request . get File ( STRING + i , BOOL ) ; file Manager . save File ( handle Id , filename , input Stream ) ; i ++ ; } }
public void add All ( int [ ] data ) { int data Len = data . length ; if ( data Len == NUM ) { return ; } int newcap = size + ( int ) ( data Len * NUM ) + NUM ; ensure Capacity ( newcap ) ; System . arraycopy ( data , NUM , array , size , data Len ) ; size += data Len ; }
public void write ( byte [ ] b ) throws java . io . IO Exception { write ( b , NUM , b . length ) ; }
public void add Scanning Callback ( One Sheeld Scanning Callback scanning Callback ) { if ( scanning Callback != null && ! scanning Callbacks . contains ( scanning Callback ) ) scanning Callbacks . add ( scanning Callback ) ; }
public void paint ( Graphics g , J Component c ) { Rectangle bounds = c . get Bounds ( ) ; check ( bounds ) ; int h = c . get Height ( ) ; int w = c . get Width ( ) ; g . draw Image ( m back Image , NUM , NUM , w , h , bounds . x , bounds . y , bounds . x + w , bounds . y + h , c ) ; }
public final double sample Min ( ) { long count = acquire Count . get ( ) - release Count . get ( ) ; long min = min . get And Set ( count ) ; return min ; }
public boolean is Page Break ( ) { if ( is Function Row ( ) && m nodes != null ) { for ( int i = NUM ; i < m nodes . size ( ) ; i ++ ) { Object o = m nodes . get ( i ) ; if ( o instanceof Print Data Element ) { Print Data Element pde = ( Print Data Element ) o ; if ( pde . is Page Break ( ) ) return BOOL ; } } } return BOOL ; }
void join Pool ( Executor Service pool ) { try { pool . shutdown ( ) ; if ( ! pool . await Termination ( NUM * LONG DELAY MS , MILLISECONDS ) ) { try { thread Fail ( STRING + pool + STRING ) ; } finally { pool . shutdown Now ( ) ; pool . await Termination ( MEDIUM DELAY MS , MILLISECONDS ) ; } } } catch ( Security Exception ok ) { } catch ( Interrupted Exception fail ) { thread Fail ( STRING ) ; } }
public static boolean is Proposition Symbol Identifier Start ( char ch ) { return Character . is Java Identifier Start ( ch ) ; }
public static void o ( Z a ) { o ( a , Parameters . Output Field Width , Parameters . Output Frac Places ) ; }
public int search ( String txt ) { int m = pat . length ( ) ; int n = txt . length ( ) ; int skip ; for ( int i = NUM ; i <= n - m ; i += skip ) { skip = NUM ; for ( int j = m - NUM ; j >= NUM ; j -- ) { if ( pat . char At ( j ) != txt . char At ( i + j ) ) { skip = Math . max ( NUM , j - right [ txt . char At ( i + j ) ] ) ; break ; } } if ( skip == NUM ) return i ; } return n ; }
protected Instances determine Output Format ( Instances input Format ) throws Exception { int i ; int [ ] indices ; String Builder order ; Instances output ; m Attribute Indices . set Upper ( input Format . num Attributes ( ) - NUM ) ; order = new String Builder ( ) ; indices = m Attribute Indices . get Selection ( ) ; if ( indices . length == NUM ) throw new Weka Exception ( STRING ) ; for ( i = NUM ; i < indices . length ; i ++ ) { if ( i > NUM ) order . append ( STRING ) ; order . append ( STRING + ( indices [ i ] + NUM ) ) ; } for ( i = NUM ; i < input Format . num Attributes ( ) ; i ++ ) { if ( m Attribute Indices . is In Range ( i ) ) continue ; order . append ( STRING ) ; order . append ( STRING + ( i + NUM ) ) ; } m Reorder . set Attribute Indices ( order . to String ( ) ) ; m Reorder . set Input Format ( input Format ) ; output = m Reorder . get Output Format ( ) ; output . set Class Index ( indices . length ) ; output . set Relation Name ( STRING + indices . length ) ; return output ; }
public static String trim Length ( String str , int length ) { if ( str == null ) return str ; if ( length <= NUM ) throw new Illegal Argument Exception ( STRING + length ) ; if ( str . length ( ) > length ) return str . substring ( NUM , length ) ; return str ; }
public synchronized void clear Transactions ( Date from Date ) { lock . lock ( ) ; try { if ( from Date == null ) { unspent . clear ( ) ; spent . clear ( ) ; pending . clear ( ) ; dead . clear ( ) ; } else { remove Entries After Date ( unspent , from Date ) ; remove Entries After Date ( spent , from Date ) ; remove Entries After Date ( pending , from Date ) ; remove Entries After Date ( dead , from Date ) ; } } finally { lock . unlock ( ) ; } }
private void process Files ( ) throws Compilation Failed Exception , IO Exception , URI Syntax Exception { Groovy Shell groovy = new Groovy Shell ( conf ) ; setup Context Class Loader ( groovy ) ; Script s = groovy . parse ( get Script Source ( is Script File , script ) ) ; if ( args . is Empty ( ) ) { Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( System . in ) ) ; Print Writer writer = new Print Writer ( System . out ) ; try { process Reader ( s , reader , writer ) ; } finally { reader . close ( ) ; writer . close ( ) ; } } else { Iterator i = args . iterator ( ) ; while ( i . has Next ( ) ) { String filename = ( String ) i . next ( ) ; File file = hunt For The Script File ( filename ) ; process File ( s , file ) ; } } }
public boolean compute Scroll Offset ( ) { if ( m Finished ) { return BOOL ; } final long time Passed = Animation Utils . current Animation Time Millis ( ) - m Start Time ; float time Passed Percent = time Passed * NUM / m Duration ; if ( time Passed >= m Duration ) { m Finished = BOOL ; time Passed Percent = NUM ; } m Curr Value = Math . round ( m Value Factor * m Path Points Holder . get Y ( time Passed Percent ) ) ; return BOOL ; }
public static void call Agent App ( Context context , String operation , String app Uri , String app Name ) { Intent intent = new Intent ( Constants . AGENT APP SERVICE NAME ) ; Intent explicit Intent = create Explicit From Implicit Intent ( context , intent ) ; if ( explicit Intent != null ) { intent = explicit Intent ; } intent . put Extra ( STRING , operation ) ; intent . set Package ( Constants . PACKAGE NAME ) ; if ( app Uri != null ) { intent . put Extra ( STRING , app Uri ) ; } if ( app Name != null ) { intent . put Extra ( STRING , app Name ) ; } context . start Service ( intent ) ; }
public synchronized void store Resource Config ( String cluster Name , Resource Type resource Type , Tungsten Properties resource Props ) throws Configuration Exception { if ( get Cluster Home ( ) == null ) { throw new Configuration Exception ( STRING + get Module Properties File Name ( Configuration Constants . TR PROPERTIES , get Cluster Home ( ) ) ) ; } String resource Dir = get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ; File resources = new File ( resource Dir ) ; if ( ! resources . is Directory ( ) ) { if ( resources . mkdirs ( ) ) { logger . info ( String . format ( STRING , resource Dir ) ) ; } else { String msg = String . format ( STRING , get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ) ; logger . error ( msg ) ; throw new Configuration Exception ( msg ) ; } } String out File Name = resources . get Absolute Path ( ) + File . separator + resource Props . get String ( STRING ) + STRING ; store ( resource Props , out File Name ) ; }
public Content Proposal Adapter ( Control control , I Control Content Adapter control Content Adapter , I Content Proposal Provider proposal Provider , Key Stroke key Stroke , char [ ] auto Activation Characters ) { super ( ) ; Assert . is Not Null ( control ) ; Assert . is Not Null ( control Content Adapter ) ; this . control = control ; this . control Content Adapter = control Content Adapter ; this . proposal Provider = proposal Provider ; this . trigger Key Stroke = key Stroke ; if ( auto Activation Characters != null ) { this . auto Activate String = new String ( auto Activation Characters ) ; } add Control Listener ( control ) ; }
public void load File ( String filename , Abstract File Loader ... loaders ) { Arff Panel panel ; panel = new Arff Panel ( filename , loaders ) ; panel . add Change Listener ( this ) ; tabbed Pane . add Tab ( panel . get Title ( ) , panel ) ; tabbed Pane . set Selected Index ( tabbed Pane . get Tab Count ( ) - NUM ) ; }
public static double generate Random Double Between ( double lower Limit , double upper Limit ) { return lower Limit + ( ( upper Limit - lower Limit ) * r . next Double ( ) ) ; }
public S Graph Item Provider Adapter Factory ( ) { supported Types . add ( I Editing Domain Item Provider . class ) ; supported Types . add ( I Structured Item Content Provider . class ) ; supported Types . add ( I Tree Item Content Provider . class ) ; supported Types . add ( I Item Label Provider . class ) ; supported Types . add ( I Item Property Source . class ) ; }
private double kd KNN Search ( int left , int right , int axis , O query , KNN Heap knns , DBID Array Iter iter , double maxdist ) { if ( right - left <= leafsize ) { for ( iter . seek ( left ) ; iter . get Offset ( ) < right ; iter . advance ( ) ) { double dist = norm . distance ( query , relation . get ( iter ) ) ; count Object Access ( ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { knns . insert ( dist , iter ) ; } maxdist = knns . get KNN Distance ( ) ; } return maxdist ; } final int middle = ( left + right ) > > > NUM ; O split = relation . get ( iter . seek ( middle ) ) ; count Object Access ( ) ; final double delta = split . double Value ( axis ) - query . double Value ( axis ) ; final boolean onleft = ( delta >= NUM ) ; final boolean onright = ( delta <= NUM ) ; final int next = ( axis + NUM ) % dims ; if ( onleft && onright ) { double dist = norm . distance ( query , split ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { assert ( iter . get Offset ( ) == middle ) ; knns . insert ( dist , iter ) ; maxdist = knns . get KNN Distance ( ) ; } if ( left < middle ) { maxdist = kd KNN Search ( left , middle , next , query , knns , iter , maxdist ) ; } if ( middle + NUM < right ) { maxdist = kd KNN Search ( middle + NUM , right , next , query , knns , iter , maxdist ) ; } } else { if ( onleft ) { if ( left < middle ) { maxdist = kd KNN Search ( left , middle , next , query , knns , iter , maxdist ) ; } if ( Math . abs ( delta ) <= maxdist ) { double dist = norm . distance ( query , split ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { knns . insert ( dist , iter . seek ( middle ) ) ; maxdist = knns . get KNN Distance ( ) ; } } if ( ( middle + NUM < right ) && ( Math . abs ( delta ) <= maxdist ) ) { maxdist = kd KNN Search ( middle + NUM , right , next , query , knns , iter , maxdist ) ; } } else { if ( middle + NUM < right ) { maxdist = kd KNN Search ( middle + NUM , right , next , query , knns , iter , maxdist ) ; } if ( Math . abs ( delta ) <= maxdist ) { double dist = norm . distance ( query , split ) ; count Distance Computation ( ) ; if ( dist <= maxdist ) { knns . insert ( dist , iter . seek ( middle ) ) ; maxdist = knns . get KNN Distance ( ) ; } } if ( ( left < middle ) && ( Math . abs ( delta ) <= maxdist ) ) { maxdist = kd KNN Search ( left , middle , next , query , knns , iter , maxdist ) ; } } } return maxdist ; }
private void parse ( XML Stream Reader parser , Handler handler , Map < String , Object > values , Stack < Set < String > > stack , boolean record Started ) throws IO Exception , XML Stream Exception { Set < String > values Addedin This Frame = null ; if ( is Record ) { record Started = BOOL ; values Addedin This Frame = new Hash Set < > ( ) ; stack . push ( values Addedin This Frame ) ; } else if ( record Started ) { values Addedin This Frame = stack . peek ( ) ; } try { if ( attributes != null ) { for ( Node node : attributes ) { String value = parser . get Attribute Value ( null , node . name ) ; if ( value != null || ( record Started && ! is Record ) ) { put Text ( values , value , node . field Name , node . multi Valued ) ; values Addedin This Frame . add ( node . field Name ) ; } } } Set < Node > children Found = new Hash Set < > ( ) ; int event = - NUM ; int flattened Starts = NUM ; String Builder text = new String Builder ( ) ; while ( BOOL ) { event = parser . next ( ) ; if ( event == END ELEMENT ) { if ( flattened Starts > NUM ) flattened Starts -- ; else { if ( has Text && values Addedin This Frame != null ) { values Addedin This Frame . add ( field Name ) ; put Text ( values , text . to String ( ) , field Name , multi Valued ) ; } if ( is Record ) handler . handle ( get Deep Copy ( values ) , for Each Path ) ; if ( child Nodes != null && record Started && ! is Record && ! children Found . contains All ( child Nodes ) ) { for ( Node n : child Nodes ) { if ( ! children Found . contains ( n ) ) n . put Nulls ( values , values Addedin This Frame ) ; } } return ; } } else if ( has Text && ( event == CDATA || event == CHARACTERS || event == SPACE ) ) { text . append ( parser . get Text ( ) ) ; } else if ( event == START ELEMENT ) { if ( flatten ) flattened Starts ++ ; else handle Start Element ( parser , children Found , handler , values , stack , record Started ) ; } else if ( event == END DOCUMENT ) return ; } } finally { if ( ( is Record || ! record Started ) && ! stack . empty ( ) ) { Set < String > clean This = stack . pop ( ) ; if ( clean This != null ) { for ( String fld : clean This ) values . remove ( fld ) ; } } } }
public void connection Lost ( ) throws Mqtt Exception { boolean reconnected = BOOL ; synchronized ( conn Lock ) { while ( ! reconnected && ! conn Lock Notified ) { try { wmqtt Client . connect ( ) ; reconnected = BOOL ; } catch ( Mqtt Exception mqe ) { if ( user Connect ) { throw mqe ; } } try { conn Lock . wait ( NUM ) ; } catch ( Interrupted Exception ie ) { } } conn Lock Notified = BOOL ; } if ( reconnected ) { try { String request Topic [ ] = { REQ TOPIC } ; wmqtt Client . subscribe ( request Topic , sub Qo S ) ; } catch ( Mqtt Exception e ) { disconnect Client ( ) ; destroy Client ( ) ; throw e ; } } }
synchronized void remove Tracer ( Tracer tracer ) { if ( cur Tracers . remove ( tracer ) ) { LOG . trace ( to String ( ) + STRING + tracer . to String ( ) ) ; if ( cur Tracers . size ( ) == NUM ) { remove And Close All Span Receivers ( ) ; } } }
private List < Entry > reduce With Douglas Peuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= NUM || entries . size ( ) < NUM ) { return entries ; } keep [ NUM ] = BOOL ; keep [ entries . size ( ) - NUM ] = BOOL ; algorithm Douglas Peucker ( entries , epsilon , NUM , entries . size ( ) - NUM ) ; List < Entry > reduced Entries = new Array List < Entry > ( ) ; for ( int i = NUM ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry cur Entry = entries . get ( i ) ; reduced Entries . add ( new Entry ( cur Entry . get Val ( ) , cur Entry . get X Index ( ) ) ) ; } } return reduced Entries ; }
public void restore ( double value ) { set Value ( Math . min ( max Value , get Value ( ) + value ) ) ; }
@ Ignore @ Test public void test Region Factory Properties Region Attributes ( ) { }
public void add Sub Tree ( int index , List < Node > children ) { List < Node Descriptor > node Descriptors = convert Tree Nodes Helper ( children ) ; roots . add Children ( index , node Descriptors ) ; List < Node > nodes = new Array List < > ( ) ; for ( Node Descriptor child : node Descriptors ) { nodes . add ( child . get Node ( ) ) ; } if ( ! nodes . is Empty ( ) ) { fire Event ( new Store Add Event ( index , nodes ) ) ; } }
public static String append Version Suffix ( String api Version , String version Suffix ) { return Strings . is Null Or Empty ( version Suffix ) ? api Version : api Version + version Suffix ; }
@ Override public void incoming Object ( I Analyzed Interval analyzed Interval ) throws Ade Exception { for ( I Analyzed Message Summary ams : analyzed Interval . get Analyzed Messages ( ) ) { final String id = ams . get Message Id ( ) ; Msg Data data = m msg Data . get ( id ) ; if ( data == null ) { data = new Msg Data ( ) ; m msg Data . put ( id , data ) ; } if ( ! is Clustered ( ams ) ) { data . m total Log Counts += Math . log ( ams . get Number Of Appearances ( ) ) ; data . m interval Count ++ ; } data . m all Count += ams . get Number Of Appearances ( ) ; data . m interval All Count ++ ; if ( data . m max Num Appearance < ams . get Number Of Appearances ( ) ) { data . m max Num Appearance = ams . get Number Of Appearances ( ) ; } } ++ m total Interval Count ; }
public static void write ( File file , Char Sequence data , Charset encoding , boolean append ) throws IO Exception { String str = data == null ? null : data . to String ( ) ; write String To File ( file , str , encoding , append ) ; }
public Bayes Estimator Editor ( Bayes Estimator Wrapper bayes Est Wrapper ) { this ( bayes Est Wrapper . get Estimated Bayes Im ( ) , bayes Est Wrapper . get Data Set ( ) ) ; }
public void mark Key For Preload ( int idx ) { if ( preload Keys == null ) preload Keys = new Bit Set ( ) ; preload Keys . set ( idx , BOOL ) ; }
private void add Token ( String token Str ) { Integer token Int = ( Integer ) f Token Names . get ( token Str ) ; if ( token Int == null ) { token Int = new Integer ( f Token Names . size ( ) ) ; f Token Names . put ( token Int , token Str ) ; } add Token ( token Int . int Value ( ) ) ; }
protected boolean apply Peephole Branch Opts ( IR ir ) { boolean did Something = BOOL ; for ( Enumeration < Basic Block > e = ir . get Basic Blocks ( ) ; e . has More Elements ( ) ; ) { Basic Block bb = e . next Element ( ) ; if ( ! bb . is Empty ( ) ) { for ( Enumeration < Instruction > ie = bb . enumerate Branch Instructions ( ) ; ie . has More Elements ( ) ; ) { Instruction s = ie . next Element ( ) ; if ( optimize Branch Instruction ( ir , s , bb ) ) { did Something = BOOL ; ie = bb . enumerate Branch Instructions ( ) ; } } } } return did Something ; }
public static void exponential Sleep ( int attempt , int base , int max ) throws Interrupted Exception { long sleep Seconds = ( long ) Math . min ( max , Math . pow ( base , attempt ) ) ; LOG . debug ( String . format ( STRING , attempt , sleep Seconds ) ) ; Thread . sleep ( NUM * sleep Seconds ) ; }
public static Array List < Map . Entry < String , String > > split ( final String text ) { Array List < Map . Entry < String , String > > a = new Array List < > ( NUM + text . length ( ) / NUM ) ; final String Builder o = new String Builder ( ) ; final String Builder l = new String Builder ( ) ; for ( int i = NUM ; i < text . length ( ) ; i ++ ) { final char c = text . char At ( i ) ; if ( Character . is Letter Or Digit ( c ) ) { o . append ( c ) ; l . append ( Character . to Lower Case ( c ) ) ; continue ; } if ( o . length ( ) > NUM ) { a . add ( new Abstract Map . Simple Entry < String , String > ( l . to String ( ) , o . to String ( ) ) ) ; o . set Length ( NUM ) ; l . set Length ( NUM ) ; } } if ( o . length ( ) > NUM ) { a . add ( new Abstract Map . Simple Entry < String , String > ( l . to String ( ) , o . to String ( ) ) ) ; o . set Length ( NUM ) ; l . set Length ( NUM ) ; } return a ; }
@ Override public void remove Request ( int interrupt Number ) { synchronized ( interrupt Request Queue ) { Interrupt Request request To Remove = null ; for ( Interrupt Request interrupt Request : interrupt Request Queue ) { if ( interrupt Request . get Interrupt Number ( ) == interrupt Number ) { request To Remove = interrupt Request ; break ; } } if ( request To Remove != null ) { interrupt Request Queue . remove ( request To Remove ) ; } } }
@ Override public final void on Heatmap Failed ( ) { m Update Pending = BOOL ; }
public static String construct Request Uri ( String path , Multi Map params , List < String > params To Remove , String sub Resource , Slash Handling slash Handling ) { String result = path ; if ( params To Remove != null ) { for ( String param To Remove : params To Remove ) { params . remove ( param To Remove ) ; } } boolean path Ends With Slash = result . ends With ( SLASH ) ; if ( sub Resource != null ) { if ( path Ends With Slash ) { result = result + sub Resource ; } else { result = result + SLASH + sub Resource ; } } if ( slash Handling . equals ( Slash Handling . END WITH SLASH ) ) { if ( ! path Ends With Slash ) { result = result + SLASH ; } } else if ( slash Handling . equals ( Slash Handling . END WITHOUT SLASH ) ) { result = remove From End Of String ( result , SLASH ) ; } if ( ! params . is Empty ( ) ) { result = result + STRING + Expansion Delta Util . map To Delimeted String ( params , STRING ) ; } return result ; }
public long object Field Offset ( Field field ) { if ( Modifier . is Static ( field . get Modifiers ( ) ) ) { throw new Illegal Argument Exception ( STRING ) ; } return object Field Offset 0 ( field ) ; }
@ Override protected synchronized void read ( long offset , byte [ ] b ) throws IO Exception { if ( byte Buffer != null ) { byte Buffer . position ( ( int ) offset ) ; byte Buffer . get ( b ) ; } else { throw new IO Exception ( STRING + get Path ( ) + STRING ) ; } }
public void end of file ( ) { elapsed time += timestamp end - timestamp beg ; long end = ( long ) Math . ceil ( timestamp end ) ; long addend = file timestamp gap + file timestamp gap min - NUM ; timestamp ofs = ( end + addend ) / file timestamp gap * file timestamp gap ; timestamp beg = input has time zero ? timestamp ofs : - NUM ; timestamp end = timestamp beg ; }
Generic Package BO ( KLV Packet . Header header ) { super ( header ) ; }
public Edge find Edge ( Coordinate p0 , Coordinate p1 ) { for ( int i = NUM ; i < edges . size ( ) ; i ++ ) { Edge e = ( Edge ) edges . get ( i ) ; Coordinate [ ] e Coord = e . get Coordinates ( ) ; if ( p0 . equals ( e Coord [ NUM ] ) && p1 . equals ( e Coord [ NUM ] ) ) return e ; } return null ; }
public Object put ( String key , Object value ) { final int len = key . length ( ) ; if ( len > m char Buffer . length ) { m char Buffer = new char [ len ] ; } Node node = m Root ; for ( int i = NUM ; i < len ; i ++ ) { Node next Node = node . m next Char [ Character . to Lower Case ( key . char At ( i ) ) ] ; if ( next Node != null ) { node = next Node ; } else { for ( ; i < len ; i ++ ) { Node new Node = new Node ( ) ; if ( m lower Case Only ) { node . m next Char [ Character . to Lower Case ( key . char At ( i ) ) ] = new Node ; } else { node . m next Char [ Character . to Upper Case ( key . char At ( i ) ) ] = new Node ; node . m next Char [ Character . to Lower Case ( key . char At ( i ) ) ] = new Node ; } node = new Node ; } break ; } } Object ret = node . m Value ; node . m Value = value ; return ret ; }
protected final void report Issue ( Health Issue health Issue ) { Event Bus event Bus ; synchronized ( m Lock ) { if ( m Health Event Bus == null ) { LOG . w ( STRING + STRING , health Issue . to String ( ) ) ; return ; } m Active Issues . add ( health Issue ) ; event Bus = m Health Event Bus ; } event Bus . post ( health Issue . discovered ) ; }
private static void warm Up Pool ( O Database Document Pool pool , String db URL , String user , String password , int min Size ) { logger . trace ( STRING , Integer . value Of ( min Size ) ) ; List < O Database Document Tx > list = new Array List < O Database Document Tx > ( ) ; for ( int count = NUM ; count < min Size ; count ++ ) { logger . trace ( STRING , Integer . value Of ( count ) ) ; try { list . add ( pool . acquire ( db URL , user , password ) ) ; } catch ( Exception ex ) { logger . warn ( STRING , Integer . value Of ( count ) , ex ) ; } } for ( O Database Document Tx entry : list ) { try { if ( entry != null ) { entry . close ( ) ; } } catch ( Exception ex ) { logger . warn ( STRING , entry , ex ) ; } } }
@ Override public void agg ( Object new Val ) { if ( new Val instanceof byte [ ] ) { Byte Buffer buffer = Byte Buffer . wrap ( ( byte [ ] ) new Val ) ; buffer . rewind ( ) ; while ( buffer . has Remaining ( ) ) { byte [ ] value Byte = new byte [ buffer . get Int ( ) ] ; buffer . get ( value Byte ) ; Big Decimal value Big Decimal = Data Type Util . byte To Big Decimal ( value Byte ) ; agg Val = agg Val . add ( value Big Decimal ) ; count += buffer . get Double ( ) ; first Time = BOOL ; } return ; } if ( first Time ) { agg Val = ( Big Decimal ) new Val ; first Time = BOOL ; } else { agg Val = agg Val . add ( ( Big Decimal ) new Val ) ; } count ++ ; }
protected HSSF Rich Text String escape Column Value ( final Object raw Value ) { if ( raw Value == null ) { return null ; } String return String = Object Utils . to String ( raw Value ) ; return String = String Escape Utils . escape Java ( String Utils . trim To Empty ( return String ) ) ; return String = String Utils . replace ( String Utils . trim ( return String ) , STRING , STRING ) ; return String = String Utils . replace ( String Utils . trim ( return String ) , STRING , STRING ) ; return String = String Escape Utils . unescape Java ( return String ) ; return String = remove Html Tags And Spaces ( return String ) ; return new HSSF Rich Text String ( return String ) ; }
public boolean is External Entity ( String entity Name ) { Entity entity = ( Entity ) f Entities . get ( entity Name ) ; if ( entity == null ) { return BOOL ; } return entity . is External ( ) ; }
protected void process Hierarchy Event ( Hierarchy Event evt ) { super . process Hierarchy Event ( evt ) ; if ( ( evt . get Change Flags ( ) & Hierarchy Event . SHOWING CHANGED ) == Hierarchy Event . SHOWING CHANGED ) { boolean showing = is Showing ( ) ; if ( ! showing && popup != null ) hide Popup ( ) ; else if ( showing && popup == null && show Pending ) auto Complete Input ( ) ; } }
public void add Request Header ( String key , String value ) { if ( user Headers == null ) { user Headers = new Hashtable ( ) ; } if ( key . equals Ignore Case ( STRING ) ) { set Content Type ( value ) ; } else { user Headers . put ( key , value ) ; } }
public boolean is Completed ( ) { for ( Aborting Runnable ar : tasks ) { synchronized ( ar ) { if ( ! ar . done ) { return BOOL ; } } } return BOOL ; }
default Byte Buffer serialize ( H type Handler , T value ) { Byte Buffer buffer = Byte Buffer . allocate ( size ( type Handler , value ) ) ; serialize ( type Handler , value , buffer ) ; return buffer ; }
private int [ ] do Intersection ( int [ ] c2 ) { int [ ] result = new int [ chars . length + c2 . length ] ; int i = NUM ; int j = NUM ; int old I ; int old J ; int index = NUM ; while ( i < chars . length && j < c2 . length ) { if ( i < chars . length && i % NUM == NUM ) { while ( j < c2 . length && c2 [ j ] < chars [ i ] ) { ++ j ; } if ( j < c2 . length && j % NUM == NUM && c2 [ j ] == chars [ i ] ) { ++ j ; } } old I = i ; while ( j % NUM == NUM && i < chars . length && chars [ i ] <= c2 [ j ] ) { ++ i ; } for ( int k = old I ; k < i ; k ++ ) { result [ index ++ ] = chars [ k ] ; } old J = j ; while ( i % NUM == NUM && j < c2 . length && c2 [ j ] <= chars [ i ] ) { ++ j ; } for ( int k = old J ; k < j ; k ++ ) { result [ index ++ ] = c2 [ k ] ; } if ( j < c2 . length && j % NUM == NUM ) { while ( i < chars . length && chars [ i ] < c2 [ j ] ) { ++ i ; } if ( i < chars . length && i % NUM == NUM && c2 [ j ] == chars [ i ] ) { ++ i ; } } } if ( result . length > index ) { int [ ] tmpbuf = new int [ index ] ; System . arraycopy ( result , NUM , tmpbuf , NUM , index ) ; return tmpbuf ; } return result ; }

public boolean on Touch Event ( Motion Event event ) { try { int pointer Count = multi Touch Supported ? ( Integer ) m get Pointer Count . invoke ( event ) : NUM ; if ( get Mode ( ) == MODE NOTHING && ! handle Single Touch Events && pointer Count == NUM ) return BOOL ; int action = event . get Action ( ) ; int hist Len = event . get History Size ( ) / pointer Count ; for ( int hist Idx = NUM ; hist Idx <= hist Len ; hist Idx ++ ) { boolean processing Hist = hist Idx < hist Len ; if ( ! multi Touch Supported || pointer Count == NUM ) { x Vals [ NUM ] = processing Hist ? event . get Historical X ( hist Idx ) : event . get X ( ) ; y Vals [ NUM ] = processing Hist ? event . get Historical Y ( hist Idx ) : event . get Y ( ) ; pressure Vals [ NUM ] = processing Hist ? event . get Historical Pressure ( hist Idx ) : event . get Pressure ( ) ; } else { int num Pointers = Math . min ( pointer Count , MAX TOUCH POINTS ) ; for ( int ptr Idx = NUM ; ptr Idx < num Pointers ; ptr Idx ++ ) { int ptr Id = ( Integer ) m get Pointer Id . invoke ( event , ptr Idx ) ; pointer Ids [ ptr Idx ] = ptr Id ; x Vals [ ptr Idx ] = ( Float ) ( processing Hist ? m get Historical X . invoke ( event , ptr Idx , hist Idx ) : m get X . invoke ( event , ptr Idx ) ) ; y Vals [ ptr Idx ] = ( Float ) ( processing Hist ? m get Historical Y . invoke ( event , ptr Idx , hist Idx ) : m get Y . invoke ( event , ptr Idx ) ) ; pressure Vals [ ptr Idx ] = ( Float ) ( processing Hist ? m get Historical Pressure . invoke ( event , ptr Idx , hist Idx ) : m get Pressure . invoke ( event , ptr Idx ) ) ; } } decode Touch Event ( pointer Count , x Vals , y Vals , pressure Vals , pointer Ids , processing Hist ? Motion Event . ACTION MOVE : action , processing Hist ? BOOL : action != Motion Event . ACTION UP && ( action & ( ( NUM << ACTION POINTER INDEX SHIFT ) - NUM ) ) != ACTION POINTER UP && action != Motion Event . ACTION CANCEL , processing Hist ? event . get Historical Event Time ( hist Idx ) : event . get Event Time ( ) ) ; } return BOOL ; } catch ( Exception e ) { Log . e ( TAG , STRING , e ) ; return BOOL ; } }
public void write Golomb ( int divisor , int value ) throws IO Exception { int q = value / divisor ; for ( int i = NUM ; i < q ; i ++ ) { write Bit ( BOOL , MAX PROBABILITY / NUM ) ; } write Bit ( BOOL , MAX PROBABILITY / NUM ) ; int r = value - q * divisor ; int bit = NUM - Integer . number Of Leading Zeros ( divisor - NUM ) ; if ( r < ( ( NUM << bit ) - divisor ) ) { bit -- ; } else { r += ( NUM << bit ) - divisor ; } for ( ; bit >= NUM ; bit -- ) { write Bit ( ( ( r > > > bit ) & NUM ) == NUM , MAX PROBABILITY / NUM ) ; } }
private Set < String > included In ( final Collection < Rev Commit > tips , int limit ) throws IO Exception , Missing Object Exception , Incorrect Object Type Exception { Set < String > result = new Hash Set < > ( ) ; for ( Rev Commit tip : tips ) { boolean commit Found = BOOL ; rw . reset Retain ( Rev Flag . UNINTERESTING , contains Target ) ; rw . mark Start ( tip ) ; for ( Rev Commit commit : rw ) { if ( commit . equals ( target ) || commit . has ( contains Target ) ) { commit Found = BOOL ; tip . add ( contains Target ) ; result . add All ( commit To Ref . get ( tip ) ) ; break ; } } if ( ! commit Found ) { rw . mark Uninteresting ( tip ) ; } else if ( NUM < limit && limit < result . size ( ) ) { break ; } } return result ; }
private int min ( int a , int b ) { if ( a < b ) return a ; return b ; }
public void add Tree Model Listener ( Tree Model Listener l ) { tree Model Listeners . add Element ( l ) ; }
public static URI Name name Constraint ( Der Value value ) throws IO Exception { URI uri ; String name = value . get IA 5 String ( ) ; try { uri = new URI ( name ) ; } catch ( URI Syntax Exception use ) { throw new IO Exception ( STRING + name , use ) ; } if ( uri . get Scheme ( ) == null ) { String host = uri . get Scheme Specific Part ( ) ; try { DNS Name host DNS ; if ( host . starts With ( STRING ) ) { host DNS = new DNS Name ( host . substring ( NUM ) ) ; } else { host DNS = new DNS Name ( host ) ; } return new URI Name ( uri , host , host DNS ) ; } catch ( IO Exception ioe ) { throw new IO Exception ( STRING + name , ioe ) ; } } else { throw new IO Exception ( STRING + STRING + name ) ; } }
public Projected Stream add View ( String namespace , String name , Expression ... parameters ) { views . add ( View . create ( namespace , name , parameters ) ) ; return this ; }
protected int read ( Speech Record recorder , byte [ ] buffer ) { int len = buffer . length ; int num Of Bytes = recorder . read ( buffer , NUM , len ) ; int status = get Status ( num Of Bytes , len ) ; if ( status == NUM && num Of Bytes >= NUM ) { System . arraycopy ( buffer , NUM , m Recording , m Recorded Length , num Of Bytes ) ; m Recorded Length += len ; } return status ; }
public int candy ( int [ ] ratings ) { int [ ] candies = new int [ ratings . length ] ; candies [ NUM ] = NUM ; for ( int i = NUM ; i < ratings . length ; i ++ ) candies [ i ] = ratings [ i ] > ratings [ i - NUM ] ? candies [ i - NUM ] + NUM : NUM ; int res = candies [ candies . length - NUM ] ; for ( int i = ratings . length - NUM ; i >= NUM ; i -- ) { if ( ratings [ i ] > ratings [ i + NUM ] ) candies [ i ] = Math . max ( candies [ i ] , candies [ i + NUM ] + NUM ) ; res += candies [ i ] ; } return res ; }
public static Zone Rules of ( Zone Offset base Standard Offset , Zone Offset base Wall Offset , List < Zone Offset Transition > standard Offset Transition List , List < Zone Offset Transition > transition List , List < Zone Offset Transition Rule > last Rules ) { Objects . require Non Null ( base Standard Offset , STRING ) ; Objects . require Non Null ( base Wall Offset , STRING ) ; Objects . require Non Null ( standard Offset Transition List , STRING ) ; Objects . require Non Null ( transition List , STRING ) ; Objects . require Non Null ( last Rules , STRING ) ; return new Zone Rules ( base Standard Offset , base Wall Offset , standard Offset Transition List , transition List , last Rules ) ; }
protected int hash ( Object o ) { int h = o == null ? NUM : o . hash Code ( ) ; h += ( h << NUM ) ^ NUM ; h ^= ( h > > > NUM ) ; h += ( h << NUM ) ; h ^= ( h > > > NUM ) ; h += ( h << NUM ) + ( h << NUM ) ; return h ^ ( h > > > NUM ) ; }
public void add Delete Template ( String delete Template ) { delete Templates . add ( delete Template ) ; }
private Bitmap create Photo Thumbnail ( final String a Image Url ) { Bitmap bitmap Ret Value = null ; if ( null != a Image Url ) { Uri image Uri = Uri . from File ( new File ( a Image Url ) ) ; int rotation Angle = Image Utils . get Rotation Angle For Bitmap ( Vector Medias Picker Activity . this , image Uri ) ; try { final String filename = image Uri . get Path ( ) ; File Input Stream image Stream = new File Input Stream ( new File ( filename ) ) ; bitmap Ret Value = create Photo Thumbnail ( image Stream , rotation Angle ) ; image Stream . close ( ) ; System . gc ( ) ; } catch ( Out Of Memory Error e ) { Log . e ( LOG TAG , STRING ) ; } catch ( Exception e ) { Log . e ( LOG TAG , STRING + e . get Message ( ) ) ; } } return bitmap Ret Value ; }
public Object Name pre Register ( M Bean Server server , Object Name name ) throws Exception { if ( name == null ) { if ( config == null ) return null ; if ( config . get Name ( ) == null ) return null ; name = Scan Manager . make M Bean Name ( Scan Dir Config MX Bean . class , config . get Name ( ) ) ; } object Name = name ; mbean Server = server ; synchronized ( this ) { configname = name . get Key Property ( STRING ) ; if ( config == null ) config = new Scan Manager Config ( configname ) ; else config = config . copy ( configname ) ; } return name ; }
void parse ( To Date Parser params , Format Token Enum format Token Enum , String format Token Str ) ;
public CC Texture Atlas ( CC Texture 2 D tex , int n ) { capacity = n ; texture = tex ; total Quads = NUM ; with Color Array = BOOL ; Byte Buffer tbb = Byte Buffer . allocate Direct ( cc Quad 2 . size * capacity * NUM ) ; tbb . order ( Byte Order . native Order ( ) ) ; texture Coordinates = tbb . as Float Buffer ( ) ; Byte Buffer vbb = Byte Buffer . allocate Direct ( cc Quad 3 . size * capacity * NUM ) ; vbb . order ( Byte Order . native Order ( ) ) ; vertex Coordinates = vbb . as Float Buffer ( ) ; Byte Buffer isb = Byte Buffer . allocate Direct ( NUM * capacity * NUM ) ; isb . order ( Byte Order . native Order ( ) ) ; indices = isb . as Short Buffer ( ) ; init Indices ( ) ; }
@ Suppress Warnings ( STRING ) public static < E > void transform String Collection ( Collection < String > original , Collection < E > collection , Class < E > element Class ) throws Preference Exception { Method parse Method = find Parse Method ( element Class ) ; if ( null != parse Method ) { for ( String to Transform : original ) { try { Object transformed = parse Method . invoke ( null , to Transform ) ; if ( element Class . is Assignable From ( transformed . get Class ( ) ) ) { collection . add ( ( E ) transformed ) ; } } catch ( Exception e ) { throw new Preference Exception ( STRING + element Class . get Name ( ) + STRING , e ) ; } } } else { throw new Preference Exception ( STRING + element Class . get Name ( ) + STRING + element Class . get Name ( ) + STRING ) ; } }
public void put String ( String s ) { ensure Capacity ( ( s . length ( ) * NUM ) + NUM ) ; System . arraycopy ( s . get Bytes ( ) , NUM , this . byte Buffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; this . byte Buffer [ this . position ++ ] = NUM ; }
@ Override public void external Entity Decl ( String name , XML Resource Identifier identifier , Augmentations augs ) throws XNI Exception { try { if ( f Decl Handler != null ) { String public Id = identifier . get Public Id ( ) ; String system Id = f Resolve DTDUR Is ? identifier . get Expanded System Id ( ) : identifier . get Literal System Id ( ) ; f Decl Handler . external Entity Decl ( name , public Id , system Id ) ; } } catch ( SAX Exception e ) { throw new XNI Exception ( e ) ; } }
public EWMA ( double alpha , long interval , Time Unit interval Unit ) { this . interval = interval Unit . to Nanos ( interval ) ; this . alpha = alpha ; }
private String pre Process Signature ( String signature ) { int index ; if ( ( index = signature . index Of ( STRING ) ) > NUM ) { signature = signature . substring ( NUM , index ) ; } while ( ( index = signature . index Of ( STRING ) ) > NUM ) { signature = signature . substring ( NUM , index ) + signature . substring ( index + NUM , signature . length ( ) ) ; } return signature ; }
private static Get Images Response check Get Images Response ( Get Images Response get Images Response ) throws Rpc Exception { logger . info ( STRING , get Images Response ) ; switch ( get Images Response . get Result ( ) ) { case OK : break ; case DATASTORE NOT FOUND : throw new Datastore Not Found Exception ( get Images Response . get Error ( ) ) ; case SYSTEM ERROR : throw new System Error Exception ( get Images Response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STRING , get Images Response . get Result ( ) ) ) ; } return get Images Response ; }
public void schedule ( Timer Task task , Date when , long period ) { if ( period <= NUM || when . get Time ( ) < NUM ) { throw new Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) - System . current Time Millis ( ) ; schedule Impl ( task , delay < NUM ? NUM : delay , period , BOOL ) ; }
public void ellipse ( double x , double y , double semi Major Axis , double semi Minor Axis ) { if ( semi Major Axis < NUM ) throw new Illegal Argument Exception ( STRING ) ; if ( semi Minor Axis < NUM ) throw new Illegal Argument Exception ( STRING ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( NUM * semi Major Axis ) ; double hs = factor Y ( NUM * semi Minor Axis ) ; if ( ws <= NUM && hs <= NUM ) pixel ( x , y ) ; else offscreen . draw ( new Ellipse 2 D . Double ( xs - ws / NUM , ys - hs / NUM , ws , hs ) ) ; draw ( ) ; }
public void request Cursor ( java . awt . Cursor cursor ) { if ( cursor == null ) { if ( show Wait Cursor && ! waiting For Layers ) reset Cursor ( ) ; current Map Bean Cursor = null ; } else if ( this . map != null ) { Cursor new Cursor ; if ( show Wait Cursor && waiting For Layers ) { new Cursor = Cursor . get Predefined Cursor ( Cursor . WAIT CURSOR ) ; current Map Bean Cursor = cursor ; } else new Cursor = cursor ; map . set Cursor ( new Cursor ) ; } }
public void unlock Flushing ( ) { flush Lock . unlock ( ) ; }
public static boolean is Primitive Or Wrapper ( Class clazz ) { Assert . not Null ( clazz , STRING ) ; return ( clazz . is Primitive ( ) || is Primitive Wrapper ( clazz ) ) ; }
public static String generate Native Guid ( Compute System device ) { return String . format ( STRING , device Type Map . get ( device . get System Type ( ) ) , device . get Ip Address ( ) , device . get Port Number ( ) ) ; }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Short Component Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
public static C Criterium Tree Node find Node ( final C Criterium Tree Node node , final I Criterium criterium ) { if ( node . get Criterium ( ) == criterium ) { return node ; } for ( final C Criterium Tree Node child : node . get Children ( ) ) { final C Criterium Tree Node child Node = find Node ( child , criterium ) ; if ( child Node != null ) { return child Node ; } } return null ; }
public static int poisson ( double lambda ) { if ( ! ( lambda > NUM ) ) throw new Illegal Argument Exception ( STRING ) ; if ( Double . is Infinite ( lambda ) ) throw new Illegal Argument Exception ( STRING ) ; int k = NUM ; double p = NUM ; double L = Math . exp ( - lambda ) ; do { k ++ ; p *= uniform ( ) ; } while ( p >= L ) ; return k - NUM ; }
String read Line ( boolean ignore LF ) throws IO Exception { String Buffer s = null ; int start Char ; synchronized ( lock ) { ensure Open ( ) ; boolean omit LF = ignore LF || skip LF ; buffer Loop : for ( ; ; ) { if ( next Char >= n Chars ) fill ( ) ; if ( next Char >= n Chars ) { if ( s != null && s . length ( ) > NUM ) return s . to String ( ) ; else return null ; } boolean eol = BOOL ; char c = NUM ; int i ; if ( omit LF && ( cb [ next Char ] == STRING ) ) next Char ++ ; skip LF = BOOL ; omit LF = BOOL ; char Loop : for ( i = next Char ; i < n Chars ; i ++ ) { c = cb [ i ] ; if ( ( c == STRING ) || ( c == STRING ) ) { eol = BOOL ; break char Loop ; } } start Char = next Char ; next Char = i ; if ( eol ) { String str ; if ( s == null ) { str = new String ( cb , start Char , i - start Char ) ; } else { s . append ( cb , start Char , i - start Char ) ; str = s . to String ( ) ; } next Char ++ ; if ( c == STRING ) { skip LF = BOOL ; } return str ; } if ( s == null ) s = new String Buffer ( default Expected Line Length ) ; s . append ( cb , start Char , i - start Char ) ; } } }
protected boolean play User Sound ( String sound Identifier ) { Object sound = builtin Sounds . get ( sound Identifier ) ; if ( sound == null ) { return BOOL ; } return BOOL ; }
public Iterator < String > iterate Formatters ( ) { return formatters . iterator ( ) ; }
private void add Property ( Property prop , int index , Map < String , Property > keys map , String key name ) throws Malformed Object Name Exception { if ( keys map . contains Key ( key name ) ) throw new Malformed Object Name Exception ( STRING + key name + STRING ) ; if ( index == kp array . length ) { Property [ ] tmp prop array = new Property [ index + NUM ] ; System . arraycopy ( kp array , NUM , tmp prop array , NUM , index ) ; kp array = tmp prop array ; } kp array [ index ] = prop ; keys map . put ( key name , prop ) ; }
public boolean is Alive ( ) { return ! socket . is Closed ( ) && ! socket . is Input Shutdown ( ) && ! socket . is Output Shutdown ( ) ; }
private void initialize Values ( ) { mn Size = Math . min ( get Measured Height ( ) , get Measured Width ( ) ) ; mn Ring Radius = ( int ) ( mn Size - mn Ring Width ) / NUM ; mn Inner Circle Radius = ( int ) ( mn Size - ( mn Ring Width * NUM ) ) / NUM ; mn View Center = mn Size / NUM ; mn Line Width = STATUS SYMBOL WIDTH PERCENT * mn Size ; }
public static java . util . Date parse Date Time ( String date , String format , String locale , String time Zone ) { Simple Date Format date Format = get Date Format ( format , locale , time Zone ) ; try { synchronized ( date Format ) { return date Format . parse ( date ) ; } } catch ( Exception e ) { throw Db Exception . get ( Error Code . PARSE ERROR 1 , e , date ) ; } }
public Field Storage Scheme Impl ( int digest Size , String algorithm ) throws Exception { this . message Digest = Message Digest . get Instance ( algorithm ) ; this . digest Lock = new Object ( ) ; this . random = new Secure Random ( ) ; this . digest Size = digest Size ; }
private void create Gui ( ) { final J Panel top Panel = new J Panel ( new Border Layout ( ) ) ; final J Panel inner Top Panel = new J Panel ( new Border Layout ( ) ) ; top Panel . add ( inner Top Panel ) ; inner Top Panel . add ( m std Edit Panel ) ; inner Top Panel . add ( m debugger Panel , Border Layout . SOUTH ) ; final J Panel button Panel = new J Panel ( new Grid Layout ( NUM , NUM ) ) ; button Panel . set Border ( new Empty Border ( NUM , NUM , NUM , NUM ) ) ; button Panel . add ( new J Panel ( ) ) ; button Panel . add ( m save Button ) ; top Panel . add ( button Panel , Border Layout . SOUTH ) ; final J Panel inner Sp = new J Panel ( new Border Layout ( ) ) ; m middle Panel . set Preferred Size ( new Dimension ( m middle Panel . get Preferred Size ( ) . width , NUM ) ) ; inner Sp . add ( m middle Panel , Border Layout . NORTH ) ; inner Sp . add ( m bottom Panel , Border Layout . CENTER ) ; final J Split Pane outer Sp = new J Split Pane ( J Split Pane . VERTICAL SPLIT , BOOL , top Panel , inner Sp ) ; outer Sp . set One Touch Expandable ( BOOL ) ; outer Sp . set Divider Location ( outer Sp . get Minimum Divider Location ( ) ) ; outer Sp . set Resize Weight ( NUM ) ; final J Panel inner Panel = new J Panel ( new Border Layout ( ) ) ; inner Panel . add ( outer Sp ) ; add ( inner Panel ) ; }
public void load ACL Config ( ) { acl Entries = new Array List < > ( ) ; for ( Access Control Level item : configuration . get Access Conrol Levels ( ) ) { ACL Entry acl Entry = new ACL Entry ( ) ; acl Entry . role = item . get Role ( ) ; acl Entry . type = item . get Resource Type ( ) ; acl Entry . folder = item . get Folder ( ) ; acl Entry . file Delete = item . is File Delete ( ) ; acl Entry . file Rename = item . is File Rename ( ) ; acl Entry . file Upload = item . is File Upload ( ) ; acl Entry . file View = item . is File View ( ) ; acl Entry . folder Create = item . is Folder Create ( ) ; acl Entry . folder Delete = item . is Folder Delete ( ) ; acl Entry . folder Rename = item . is Folder Rename ( ) ; acl Entry . folder View = item . is Folder View ( ) ; acl Entries . add ( acl Entry ) ; } }
private final void update Buffer ( int offset ) { f Buffer Offset = offset ; if ( f Buffer Offset + f Buffer . length > f Range Offset + f Range Length ) f Buffer Length = f Range Length - ( f Buffer Offset - f Range Offset ) ; else f Buffer Length = f Buffer . length ; try { final String content = f Document . get ( f Buffer Offset , f Buffer Length ) ; content . get Chars ( NUM , f Buffer Length , f Buffer , NUM ) ; } catch ( Bad Location Exception e ) { } }
public void send Audio ( final String url , final String access Token , @ Not Null Data Request Body request Body , final Async Callback < Avs Response , Exception > callback ) throws IO Exception { this . request Body = request Body ; if ( callback != null ) { callback . start ( ) ; } Log . i ( TAG , STRING ) ; start = System . current Time Millis ( ) ; try { prepare Connection ( url , access Token ) ; final Avs Response response = complete Post ( ) ; if ( response != null && response . is Empty ( ) ) { if ( callback != null ) { callback . failure ( new Avs Audio Exception ( STRING ) ) ; } return ; } if ( callback != null ) { if ( response != null ) { callback . success ( response ) ; } callback . complete ( ) ; } Log . i ( TAG , STRING ) ; Log . i ( TAG , STRING + ( System . current Time Millis ( ) - start ) ) ; } catch ( IO Exception | Avs Exception e ) { on Error ( callback , e ) ; } }
public Follower Info ( Follower . Type type , String stream , List < Follower > followers , int total ) { this . type = type ; this . followers = followers ; this . total = total ; this . time = System . current Time Millis ( ) ; this . stream = stream ; this . request Error = BOOL ; this . request Error Description = null ; }
void remove View ( View view ) { int index = m Callback . index Of Child ( view ) ; if ( index < NUM ) { return ; } m Callback . remove View At ( index ) ; if ( m Bucket . remove ( index ) ) { m Hidden Views . remove ( view ) ; } if ( DEBUG ) { Log . d ( TAG , STRING + index + STRING + this ) ; } }
public void test Big Ints Round Trip ( ) { for ( int i = NUM ; i < NUM ; i ++ ) { Big Integer value = Test Util . next Big Integer ( random ( ) , NUM ) ; int length = value . to Byte Array ( ) . length ; int max Length = Test Util . next Int ( random ( ) , length , length + NUM ) ; byte [ ] encoded = new byte [ max Length ] ; Numeric Utils . big Int To Sortable Bytes ( value , max Length , encoded , NUM ) ; assert Equals ( value , Numeric Utils . sortable Bytes To Big Int ( encoded , NUM , max Length ) ) ; } }
private void serialize Test Summary ( K Xml Serializer serializer ) throws IO Exception { serializer . start Tag ( ns , SUMMARY TAG ) ; serializer . attribute ( ns , HAS CRASH ATTR , get Has Crash ( ) ) ; serializer . attribute ( ns , CRASH FILE ATTR , get Crash File ( ) ) ; serializer . attribute ( ns , DURATION ATTR , get Duration ( ) ) ; serializer . attribute ( Cts Xml Result Reporter . ns , RESULT ATTR , get Result ( ) ) ; serializer . end Tag ( ns , SUMMARY TAG ) ; }
@ Override public boolean is Component Enabled ( Resolve Info resolve Info ) { if ( resolve Info != null && resolve Info . service Info != null && ! Text Utils . is Empty ( resolve Info . service Info . package Name ) ) { if ( m Permitted Package Names == null || is System App ( resolve Info . service Info . application Info ) ) { return BOOL ; } else { return m Permitted Package Names . contains ( resolve Info . service Info . package Name ) ; } } return BOOL ; }
public Verified Download ( Logger log , Artifact Context context , File Content Store file Content Store , Node node ) { this . log = log ; this . context = context ; parent = Node Utils . first Parent ( node ) ; if ( parent == null ) { throw new Illegal Argument Exception ( STRING + node ) ; } this . node = node ; this . file Content Store = file Content Store ; File f ; File parent Dir = file Content Store . get File ( parent ) ; parent Dir . mkdirs ( ) ; try { f = File . create Temp File ( node . get Label ( ) + STRING , STRING , parent Dir ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; log . debug ( STRING + e ) ; f = new File ( parent Dir , node . get Label ( ) + Abstract Node Repository Manager . VALIDATING ) ; File Util . delete ( f ) ; } f . delete On Exit ( ) ; temp Node = parent . get Child ( f . get Name ( ) ) ; temp File = file Content Store . get File ( temp Node ) ; }
public static byte [ ] hex String To Byte ( final String source ) { byte [ ] bytes = null ; if ( source != null ) { bytes = new byte [ source . length ( ) / NUM ] ; int i = NUM ; while ( i < bytes . length ) { bytes [ i ] = ( byte ) ( Integer . parse Int ( source . substring ( i * NUM , ( i + NUM ) * NUM ) , NUM ) ) ; i ++ ; } } return bytes ; }
@ Override protected final boolean write Data ( Byte Buffer data ) { synchronized ( guard ) { Ls Server Packet packet = send Msg Queue . poll First ( ) ; if ( packet == null ) { return BOOL ; } packet . write ( this , data ) ; return BOOL ; } }
public synchronized boolean generate ( Projection proj ) { double up Lat ; int columns = get Columns ( ) ; int rows = get Rows ( ) ; super . clear ( ) ; set Shape ( null ) ; if ( render Type == RENDERTYPE LATLON ) { double right Lon ; right Lon = longitude + columns * horizontal Resolution ; up Lat = latitude + rows * vertical Resolution ; point 1 = ( Point ) proj . forward ( up Lat , longitude , new Point ( ) ) ; point 2 = ( Point ) proj . forward ( latitude , right Lon , new Point ( ) ) ; height = point 2 . y - point 1 . y ; width = point 2 . x - point 1 . x ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + height + STRING + width ) ; } } else if ( render Type == RENDERTYPE XY || render Type == RENDERTYPE OFFSET ) { width = ( int ) Math . round ( columns * horizontal Resolution ) ; height = ( int ) Math . round ( rows * vertical Resolution ) ; if ( render Type == RENDERTYPE OFFSET ) { up Lat = latitude + columns * vertical Resolution ; point 1 = ( Point ) proj . forward ( up Lat , longitude , new Point ( ) ) ; point 1 . x += point . x ; point 1 . y += point . y ; } else { point 1 = point ; } point 2 = new Point ( point 1 . x + width , point 1 . y + height ) ; } else { return BOOL ; } if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + point 1 + STRING + point 2 + STRING + height + STRING + width ) ; } set Shape ( ) ; if ( generator != null && generator . need Generate To Render ( ) ) { add ( generator . generate ( this , proj ) ) ; } else if ( grid Objects != null ) { add ( generate Grid Objects ( proj ) ) ; } set Label Location ( get Shape ( ) , proj ) ; set Need To Regenerate ( BOOL ) ; return BOOL ; }
@ Override public E remove ( int location ) { E result ; if ( location < NUM || location >= size ) { throw new Index Out Of Bounds Exception ( STRING + location + STRING + size ) ; } if ( location == NUM ) { result = array [ first Index ] ; array [ first Index ++ ] = null ; } else if ( location == size - NUM ) { int last Index = first Index + size - NUM ; result = array [ last Index ] ; array [ last Index ] = null ; } else { int element Index = first Index + location ; result = array [ element Index ] ; if ( location < size / NUM ) { System . arraycopy ( array , first Index , array , first Index + NUM , location ) ; array [ first Index ++ ] = null ; } else { System . arraycopy ( array , element Index + NUM , array , element Index , size - location - NUM ) ; array [ first Index + size - NUM ] = null ; } } size -- ; if ( size == NUM ) { first Index = NUM ; } mod Count ++ ; return result ; }
public java . lang . String Buffer insert ( int offset , java . lang . Object obj ) { internal . insert ( offset , obj ) ; return this ; }
private boolean show File Chooser ( ) { Class dst Category = Destination . class ; Destination dst = ( Destination ) as Current . get ( dst Category ) ; if ( dst == null ) { dst = ( Destination ) as Original . get ( dst Category ) ; if ( dst == null ) { dst = ( Destination ) ps Current . get Default Attribute Value ( dst Category ) ; if ( dst == null ) { try { dst = new Destination ( new URI ( STRING ) ) ; } catch ( URI Syntax Exception e ) { } } } } File file Dest ; if ( dst != null ) { try { file Dest = new File ( dst . get URI ( ) ) ; } catch ( Exception e ) { file Dest = new File ( STRING ) ; } } else { file Dest = new File ( STRING ) ; } Validating File Chooser jfc = new Validating File Chooser ( ) ; jfc . set Approve Button Text ( get Msg ( STRING ) ) ; jfc . set Dialog Title ( get Msg ( STRING ) ) ; jfc . set Dialog Type ( J File Chooser . SAVE DIALOG ) ; jfc . set Selected File ( file Dest ) ; int return Val = jfc . show Dialog ( this , null ) ; if ( return Val == J File Chooser . APPROVE OPTION ) { file Dest = jfc . get Selected File ( ) ; try { as Current . add ( new Destination ( file Dest . to URI ( ) ) ) ; } catch ( Exception e ) { as Current . remove ( dst Category ) ; } } else { as Current . remove ( dst Category ) ; } return ( return Val == J File Chooser . APPROVE OPTION ) ; }
@ Override public void on Project Closed ( Project Action Event event ) { Project Descriptor project = event . get Project ( ) ; final String project Type Id = project . get Type ( ) ; boolean is JS Project = project Type Id . ends With ( STRING ) ; if ( is JS Project ) { workspace Agent . remove Part ( yeoman Part Presenter ) ; } }
protected void on Mouse Click ( ) { if ( on Mouse Click != null ) { on Mouse Click . run ( ) ; } }
public void init All Day Heights ( ) { if ( m Max Allday Events <= m Max Unexpanded Allday Event Count ) { return ; } if ( m Show All All Day Events ) { int max AD Height = m View Height - DAY HEADER HEIGHT - MIN HOURS HEIGHT ; max AD Height = Math . min ( max AD Height , ( int ) ( m Max Allday Events * MIN UNEXPANDED ALLDAY EVENT HEIGHT ) ) ; m Animate Day Event Height = max AD Height / m Max Allday Events ; } else { m Animate Day Event Height = ( int ) MIN UNEXPANDED ALLDAY EVENT HEIGHT ; } }
private void send Response ( UUID node Id , Igfs Communication Message msg ) { try { send With Retries ( node Id , msg ) ; } catch ( Ignite Checked Exception e ) { if ( e . has Cause ( Cluster Topology Checked Exception . class ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STRING + STRING + node Id ) ; } else U . error ( log , STRING + node Id , e ) ; } }
public boolean show Next Notification ( ) { int i = get Selected Index ( ) ; if ( i != - NUM && i < get Notfication Count ( ) - NUM ) { model . set Selected Item ( model . get Element At ( i + NUM ) ) ; return BOOL ; } return BOOL ; }
@ Override public void write External ( Object Output out ) throws IO Exception { super . write External ( out ) ; out . write Int ( DBID Util . as Integer ( routing Object ID ) ) ; out . write Double ( parent Distance ) ; out . write Double ( covering Radius ) ; }
public void add Input Node ( B Node input Node ) { if ( input Node == this ) { log . warning ( STRING + node Id ) ; } if ( contains Cycles ( input Node ) ) { log . warning ( STRING + input Node . get Id ( ) + STRING + node Id ) ; } if ( this instanceof Action Node ) { log . warning ( STRING ) ; } if ( input Node instanceof Utility Node ) { log . warning ( STRING + input Node . get Id ( ) + STRING + node Id + STRING ) ; } add Input Node internal ( input Node ) ; input Node . add Output Node internal ( this ) ; }
public static C Connection connect ( final C Database Configuration configuration ) throws Couldnt Load Driver Exception , Couldnt Connect Exception { check Driver ( configuration ) ; try { return new C Connection ( configuration ) ; } catch ( final SQL Exception e ) { C Utility Functions . log Exception ( e ) ; throw new Couldnt Connect Exception ( e , e . get Error Code ( ) , e . get SQL State ( ) ) ; } }
public String show Switch Wwn ( ) throws Network Device Controller Exception { SSH Prompt [ ] prompts = { SSH Prompt . POUND , SSH Prompt . GREATER THAN , SSH Prompt . MDS CONFIG , SSH Prompt . MDS CONFIG IVR ZONE , SSH Prompt . MDS CONFIG IVR ZONESET } ; String Builder buf = new String Builder ( ) ; send Wait For ( MDS Dialog Properties . get String ( STRING ) , default Timeout , prompts , buf ) ; String [ ] lines = get Lines ( buf ) ; String [ ] regex = { MDS Dialog Properties . get String ( STRING ) } ; String switch Wwn = null ; String [ ] groups = new String [ NUM ] ; for ( String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case NUM : switch Wwn = groups [ NUM ] ; break ; } if ( switch Wwn != null ) { break ; } } return switch Wwn ; }
public static Transaction Parameter Buffer process Mapping ( String mapping ) throws FB Resource Exception { Transaction Parameter Buffer result = new Transaction Parameter Buffer Impl ( ) ; String Tokenizer st = new String Tokenizer ( mapping , STRING ) ; while ( st . has More Tokens ( ) ) { String token = st . next Token ( ) ; Integer arg Value = null ; if ( token . contains ( STRING ) ) { String [ ] parts = token . split ( STRING ) ; try { arg Value = Integer . value Of ( parts [ NUM ] ) ; } catch ( Number Format Exception ex ) { throw new FB Resource Exception ( parts [ NUM ] + STRING ) ; } token = parts [ NUM ] ; } Integer value = Parameter Buffer Helper . get Tpb Param ( token ) ; if ( value == null ) { throw new FB Resource Exception ( STRING + token + STRING ) ; } if ( arg Value == null ) { result . add Argument ( value ) ; } else { result . add Argument ( value , arg Value ) ; } } return result ; }
private void update Adapter Items ( ) { Section Info last Section Info = null ; String last Section Name = null ; Fast Scroll Section Info last Fast Scroller Section Info = null ; int position = NUM ; int app Index = NUM ; m Filtered Apps . clear ( ) ; m Fast Scroller Sections . clear ( ) ; m Adapter Items . clear ( ) ; m Sections . clear ( ) ; if ( DEBUG PREDICTIONS ) { if ( m Predicted App Components . is Empty ( ) && ! m Apps . is Empty ( ) ) { m Predicted App Components . add ( new Component Key ( m Apps . get ( NUM ) . component Name , User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new Component Key ( m Apps . get ( NUM ) . component Name , User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new Component Key ( m Apps . get ( NUM ) . component Name , User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new Component Key ( m Apps . get ( NUM ) . component Name , User Handle Compat . my User Handle ( ) ) ) ; } } m Predicted Apps . clear ( ) ; if ( m Predicted App Components != null && ! m Predicted App Components . is Empty ( ) && ! has Filter ( ) ) { for ( Component Key ck : m Predicted App Components ) { App Info info = m Component To App Map . get ( ck ) ; if ( info != null ) { m Predicted Apps . add ( info ) ; } else { if ( Launcher App State . is Dogfood Build ( ) ) { Log . e ( TAG , STRING + ck . flatten To String ( m Launcher ) ) ; } } if ( m Predicted Apps . size ( ) == m Num Predicted Apps Per Row ) { break ; } } if ( ! m Predicted Apps . is Empty ( ) ) { last Section Info = new Section Info ( ) ; last Fast Scroller Section Info = new Fast Scroll Section Info ( STRING ) ; Adapter Item section Item = Adapter Item . as Section Break ( position ++ , last Section Info ) ; m Sections . add ( last Section Info ) ; m Fast Scroller Sections . add ( last Fast Scroller Section Info ) ; m Adapter Items . add ( section Item ) ; for ( App Info info : m Predicted Apps ) { Adapter Item app Item = Adapter Item . as Predicted App ( position ++ , last Section Info , STRING , last Section Info . num Apps ++ , info , app Index ++ ) ; if ( last Section Info . first App Item == null ) { last Section Info . first App Item = app Item ; last Fast Scroller Section Info . fast Scroll To Item = app Item ; } m Adapter Items . add ( app Item ) ; m Filtered Apps . add ( info ) ; } } } for ( App Info info : get Filters App Infos ( ) ) { String section Name = get And Update Cached Section Name ( info . title ) ; if ( last Section Info == null || ! section Name . equals ( last Section Name ) ) { last Section Name = section Name ; last Section Info = new Section Info ( ) ; last Fast Scroller Section Info = new Fast Scroll Section Info ( section Name ) ; m Sections . add ( last Section Info ) ; m Fast Scroller Sections . add ( last Fast Scroller Section Info ) ; if ( ! has Filter ( ) ) { Adapter Item section Item = Adapter Item . as Section Break ( position ++ , last Section Info ) ; m Adapter Items . add ( section Item ) ; } } Adapter Item app Item = Adapter Item . as App ( position ++ , last Section Info , section Name , last Section Info . num Apps ++ , info , app Index ++ ) ; if ( last Section Info . first App Item == null ) { last Section Info . first App Item = app Item ; last Fast Scroller Section Info . fast Scroll To Item = app Item ; } m Adapter Items . add ( app Item ) ; m Filtered Apps . add ( info ) ; } if ( has Filter ( ) ) { if ( has No Filtered Results ( ) ) { m Adapter Items . add ( Adapter Item . as Empty Search ( position ++ ) ) ; } else { m Adapter Items . add ( Adapter Item . as Divider ( position ++ ) ) ; } m Adapter Items . add ( Adapter Item . as Market Search ( position ++ ) ) ; } merge Sections ( ) ; if ( m Num Apps Per Row != NUM ) { int num Apps In Section = NUM ; int num Apps In Row = NUM ; int row Index = - NUM ; for ( Adapter Item item : m Adapter Items ) { item . row Index = NUM ; if ( item . view Type == All Apps Grid Adapter . SECTION BREAK VIEW TYPE ) { num Apps In Section = NUM ; } else if ( item . view Type == All Apps Grid Adapter . ICON VIEW TYPE || item . view Type == All Apps Grid Adapter . PREDICTION ICON VIEW TYPE ) { if ( num Apps In Section % m Num Apps Per Row == NUM ) { num Apps In Row = NUM ; row Index ++ ; } item . row Index = row Index ; item . row App Index = num Apps In Row ; num Apps In Section ++ ; num Apps In Row ++ ; } } m Num App Rows In Adapter = row Index + NUM ; switch ( m Fast Scroll Distribution Mode ) { case FAST SCROLL FRACTION DISTRIBUTE BY ROWS FRACTION : float row Fraction = NUM / m Num App Rows In Adapter ; for ( Fast Scroll Section Info info : m Fast Scroller Sections ) { Adapter Item item = info . fast Scroll To Item ; if ( item . view Type != All Apps Grid Adapter . ICON VIEW TYPE && item . view Type != All Apps Grid Adapter . PREDICTION ICON VIEW TYPE ) { info . touch Fraction = NUM ; continue ; } float sub Row Fraction = item . row App Index * ( row Fraction / m Num Apps Per Row ) ; info . touch Fraction = item . row Index * row Fraction + sub Row Fraction ; } break ; case FAST SCROLL FRACTION DISTRIBUTE BY NUM SECTIONS : float per Section Touch Fraction = NUM / m Fast Scroller Sections . size ( ) ; float cumulative Touch Fraction = NUM ; for ( Fast Scroll Section Info info : m Fast Scroller Sections ) { Adapter Item item = info . fast Scroll To Item ; if ( item . view Type != All Apps Grid Adapter . ICON VIEW TYPE && item . view Type != All Apps Grid Adapter . PREDICTION ICON VIEW TYPE ) { info . touch Fraction = NUM ; continue ; } info . touch Fraction = cumulative Touch Fraction ; cumulative Touch Fraction += per Section Touch Fraction ; } break ; } } if ( m Adapter != null ) { m Adapter . notify Data Set Changed ( ) ; } }
public void test Update 3 ( ) { int new Value 1 = - NUM ; int new Value 2 = - NUM ; String update Query = STRING + Database Creator . TEST TABLE 1 + STRING + new Value 1 + STRING + new Value 2 ; try { int num = statement . execute Update ( update Query ) ; assert Equals ( STRING , number Of Records , num ) ; String select Query = STRING + Database Creator . TEST TABLE 1 ; Result Set result = statement . execute Query ( select Query ) ; while ( result . next ( ) ) { } result . close ( ) ; } catch ( SQL Exception e ) { fail ( STRING + e . get Message ( ) ) ; } }
public void remove Memberships ( String universal Id , Set membership ) throws AM Console Exception { if ( ( membership == null ) || membership . is Empty ( ) ) { throw new AM Console Exception ( STRING ) ; } SSO Token sso Token = get User SSO Token ( ) ; String current Id = STRING ; try { AM Identity amid = Id Utils . get Identity ( sso Token , universal Id ) ; String [ ] params = new String [ NUM ] ; params [ NUM ] = universal Id ; for ( Iterator iter = membership . iterator ( ) ; iter . has Next ( ) ; ) { String id = ( String ) iter . next ( ) ; AM Identity amidentity = Id Utils . get Identity ( sso Token , id ) ; current Id = id ; params [ NUM ] = id ; log Event ( STRING , params ) ; amidentity . remove Member ( amid ) ; log Event ( STRING , params ) ; } } catch ( SSO Exception e ) { String [ ] params Ex = { current Id , universal Id , get Error String ( e ) } ; log Event ( STRING , params Ex ) ; debug . warning ( STRING , e ) ; throw new AM Console Exception ( get Error String ( e ) ) ; } catch ( Id Repo Exception e ) { String [ ] params Ex = { current Id , universal Id , get Error String ( e ) } ; log Event ( STRING , params Ex ) ; debug . warning ( STRING , e ) ; throw new AM Console Exception ( get Error String ( e ) ) ; } }
private static Address Get Int Array Elements ( JNI Environment env , int array JREF , Address is Copy Address ) { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { int [ ] source Array = ( int [ ] ) env . get JNI Ref ( array JREF ) ; int size = source Array . length ; if ( Memory Manager . will Never Move ( source Array ) ) { JNI Generic Helpers . set Bool Star ( is Copy Address , BOOL ) ; return Magic . object As Address ( source Array ) ; } else { Address copy Buffer = sys Call . sys Malloc ( size << LOG BYTES IN INT ) ; if ( copy Buffer . is Zero ( ) ) { env . record Exception ( new Out Of Memory Error ( ) ) ; return Address . zero ( ) ; } Memory . memcopy ( copy Buffer , Magic . object As Address ( source Array ) , size << LOG BYTES IN INT ) ; JNI Generic Helpers . set Bool Star ( is Copy Address , BOOL ) ; return copy Buffer ; } } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return Address . zero ( ) ; } }
private void escape Utf 8 ( ) { int chars Length = string Value . length ( ) ; chars Offset = NUM ; position = NUM ; if ( chars Length == NUM ) { position = NUM ; escaped Array = new byte [ ] { ( byte ) STRING , ( byte ) STRING } ; return ; } escaped Array = new byte [ ( chars Length * NUM ) + NUM ] ; escaped Array [ position ++ ] = ( byte ) STRING ; char char Value ; if ( no Backslash Escapes ) { do { char Value = string Value . char At ( chars Offset ) ; if ( char Value < NUM ) { if ( char Value == STRING ) escaped Array [ position ++ ] = ( byte ) STRING ; escaped Array [ position ++ ] = ( byte ) char Value ; chars Offset ++ ; } else { break ; } } while ( chars Offset < chars Length ) ; } else { do { char Value = string Value . char At ( chars Offset ) ; if ( char Value < NUM ) { if ( char Value == STRING || char Value == STRING || char Value == STRING || char Value == NUM ) escaped Array [ position ++ ] = ( byte ) STRING ; escaped Array [ position ++ ] = ( byte ) char Value ; chars Offset ++ ; } else { break ; } } while ( chars Offset < chars Length ) ; } while ( chars Offset < chars Length ) { char curr Char = string Value . char At ( chars Offset ++ ) ; if ( curr Char < NUM ) { if ( curr Char == STRING ) { escaped Array [ position ++ ] = no Backslash Escapes ? ( byte ) STRING : ( byte ) STRING ; } else if ( ! no Backslash Escapes && ( curr Char == STRING || curr Char == STRING || curr Char == NUM ) ) { escaped Array [ position ++ ] = ( byte ) STRING ; } escaped Array [ position ++ ] = ( byte ) curr Char ; } else get Non Ascii Byte ( curr Char , string Value , chars Length ) ; } escaped Array [ position ++ ] = ( byte ) STRING ; string Value = null ; binary = BOOL ; }
private void prepare Transfers ( ) throws Lib Usb Exception { if ( m Available Transfers == null ) { m Available Transfers = new Linked Transfer Queue < > ( ) ; for ( int x = NUM ; x < TRANSFER BUFFER POOL SIZE ; x ++ ) { Transfer transfer = Lib Usb . alloc Transfer ( ) ; if ( transfer == null ) { throw new Lib Usb Exception ( STRING , Lib Usb . ERROR NO MEM ) ; } final Byte Buffer buffer = Byte Buffer . allocate Direct ( m Buffer Size ) ; Lib Usb . fill Bulk Transfer ( transfer , m Device Handle , USB ENDPOINT , buffer , Buffer Processor . this , STRING , USB TIMEOUT MS ) ; m Available Transfers . add ( transfer ) ; } } }
private void flush Left ( ) throws IO Exception { append Newline If Necessary ( left Buf , left Column ) ; while ( left Buf . length ( ) != NUM ) { right Column . write ( STRING ) ; output Full Lines ( ) ; } }
public Map < String , Object > finalize Order Entry Payment ( String check Out Payment Id , Big Decimal amount , boolean single Use , boolean append ) { Map < String , Object > result = Service Util . return Success ( ) ; if ( Util Validate . is Not Empty ( check Out Payment Id ) ) { if ( ! append ) { cart . clear Payments ( ) ; } cart . add Payment Amount ( check Out Payment Id , amount , single Use ) ; } return result ; }
private void clear All ( ) { steppable Objects . clear ( ) ; object Selection . remove All ( ) ; objects In Combo . clear ( ) ; selected Object = null ; occurrence = NUM ; input Changed ( ) ; }
public Builder delete Name ( ) { delete Fields . add ( STRING ) ; return this ; }
@ Override public int [ ] execute Batch ( ) throws SQL Exception { try { int id = get Next Id ( Trace Object . PREPARED STATEMENT ) ; debug Code Call ( STRING ) ; if ( batch Parameters == null ) { batch Parameters = New . array List ( ) ; } batch Identities = New . array List ( ) ; int size = batch Parameters . size ( ) ; int [ ] result = new int [ size ] ; boolean error = BOOL ; SQL Exception next = null ; check Closed For Write ( ) ; try { for ( int i = NUM ; i < size ; i ++ ) { Value [ ] set = batch Parameters . get ( i ) ; Array List < ? extends Parameter Interface > parameters = command . get Parameters ( ) ; for ( int j = NUM ; j < set . length ; j ++ ) { Value value = set [ j ] ; Parameter Interface param = parameters . get ( j ) ; param . set Value ( value , BOOL ) ; } try { result [ i ] = execute Update Internal ( ) ; Result Set rs = conn . get Generated Keys ( this , id ) ; while ( rs . next ( ) ) { batch Identities . add ( rs . get Object ( NUM ) ) ; } } catch ( Exception re ) { SQL Exception e = log And Convert ( re ) ; if ( next == null ) { next = e ; } else { e . set Next Exception ( next ) ; next = e ; } result [ i ] = Statement . EXECUTE FAILED ; error = BOOL ; } } batch Parameters = null ; if ( error ) { Jdbc Batch Update Exception e = new Jdbc Batch Update Exception ( next , result ) ; throw e ; } return result ; } finally { after Writing ( ) ; } } catch ( Exception e ) { throw log And Convert ( e ) ; } }
public void end Statement ( ) { for ( Transaction Lifecycle Listener l : lifecycle Listeners ) l . on Tx End Statement ( this ) ; }
long resize Lun ( long size , boolean force ) { Na Element elem = new Na Element ( STRING ) ; elem . add New Child ( STRING , Boolean . to String ( force ) ) ; elem . add New Child ( STRING , path ) ; elem . add New Child ( STRING , Long . to String ( size ) ) ; Na Element result = null ; try { result = server . invoke Elem ( elem ) ; return result . get Child Long Value ( STRING , - NUM ) ; } catch ( Exception e ) { String msg = STRING + path ; log . error ( msg , e ) ; throw new Net App Exception ( msg , e ) ; } }
@ Suppress Warnings ( STRING ) public boolean wait For Completion ( Application Id app Id , App Status Callback callback , long timeout Millis ) throws Yarn Exception , IO Exception { long start Millis = System . current Time Millis ( ) ; while ( BOOL ) { try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { LOG . debug ( STRING ) ; } Application Report report = client RM . get Application Report ( app Id ) ; if ( callback . exit Loop ( report ) == BOOL ) { return BOOL ; } Yarn Application State state = report . get Yarn Application State ( ) ; Final Application Status ds Status = report . get Final Application Status ( ) ; if ( Yarn Application State . FINISHED == state ) { if ( Final Application Status . SUCCEEDED == ds Status ) { LOG . info ( STRING ) ; return BOOL ; } else { LOG . info ( STRING + STRING + state . to String ( ) + STRING + ds Status . to String ( ) + STRING ) ; return BOOL ; } } else if ( Yarn Application State . KILLED == state || Yarn Application State . FAILED == state ) { LOG . info ( STRING + STRING + state . to String ( ) + STRING + ds Status . to String ( ) + STRING ) ; return BOOL ; } if ( System . current Time Millis ( ) - start Millis > timeout Millis ) { LOG . info ( STRING ) ; client RM . kill Application ( app Id ) ; return BOOL ; } } }
public static Byte Buffer read Fully ( File Channel channel , long file Offset , int bytes To Read ) throws IO Exception { Byte Buffer buffer = Byte Buffer . allocate ( bytes To Read ) ; int total Bytes Read = NUM ; while ( total Bytes Read < bytes To Read ) { int bytes Read = channel . read ( buffer , file Offset + total Bytes Read ) ; if ( bytes Read < NUM ) { throw new EOF Exception ( STRING + bytes To Read + STRING + total Bytes Read + STRING ) ; } total Bytes Read += bytes Read ; } buffer . flip ( ) ; return buffer ; }
public static String format Date ( Date date ) { String format String = STRING ; Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( date ) ; if ( cal . is Set ( Calendar . MINUTE ) ) format String = STRING ; else format String = STRING ; Simple Date Format formatter = new Simple Date Format ( format String ) ; return formatter . format ( date ) ; }
protected abstract int main Exec ( Output Stream out , Log Stream log ) throws IO Exception ;
protected String Buffer construct Statement ( Row Change Data . Action Type action , String schema Name , String table Name , Array List < One Row Change . Column Spec > columns , Array List < One Row Change . Column Spec > keys , Array List < One Row Change . Column Val > key Values , Array List < One Row Change . Column Val > col Values ) { String Buffer stmt = new String Buffer ( ) ; if ( action == Row Change Data . Action Type . INSERT ) { stmt . append ( STRING ) ; stmt . append ( conn . get Database Object Name ( schema Name ) + STRING + conn . get Database Object Name ( table Name ) ) ; stmt . append ( STRING ) ; print Column Spec ( stmt , columns , null , col Values , Print Mode . NAMES ONLY , STRING ) ; stmt . append ( STRING ) ; stmt . append ( STRING ) ; print Column Spec ( stmt , columns , null , col Values , Print Mode . PLACE HOLDER , STRING ) ; stmt . append ( STRING ) ; } else if ( action == Row Change Data . Action Type . UPDATE ) { stmt . append ( STRING ) ; stmt . append ( conn . get Database Object Name ( schema Name ) + STRING + conn . get Database Object Name ( table Name ) ) ; stmt . append ( STRING ) ; print Column Spec ( stmt , columns , null , col Values , Print Mode . ASSIGNMENT , STRING ) ; stmt . append ( STRING ) ; print Column Spec ( stmt , keys , key Values , col Values , Print Mode . ASSIGNMENT , STRING ) ; } else if ( action == Row Change Data . Action Type . DELETE ) { stmt . append ( STRING ) ; stmt . append ( conn . get Database Object Name ( schema Name ) + STRING + conn . get Database Object Name ( table Name ) ) ; stmt . append ( STRING ) ; print Column Spec ( stmt , keys , key Values , col Values , Print Mode . ASSIGNMENT , STRING ) ; } return stmt ; }
public static String resolve Properties ( String input String ) { if ( ! String Utils . has Text ( input String ) ) { return input String ; } String temp String = input String . trim ( ) ; String out String = STRING ; int start Index = NUM ; while ( temp String . index Of ( STRING , start Index ) != - NUM ) { int starts With Pos = temp String . index Of ( STRING , start Index ) ; int ends With Pos = temp String . index Of ( STRING , starts With Pos + NUM ) ; int next Bracket = temp String . index Of ( STRING , starts With Pos + NUM ) ; if ( next Bracket != - NUM && ends With Pos > next Bracket ) { ends With Pos = temp String . index Of ( STRING , ends With Pos + NUM ) ; } int default Pos = temp String . last Index Of ( STRING , ends With Pos ) ; if ( default Pos < starts With Pos ) { default Pos = - NUM ; } if ( starts With Pos != - NUM && ends With Pos != - NUM ) { String value = temp String . substring ( starts With Pos + NUM , ends With Pos ) ; String default String ; String key ; if ( default Pos != - NUM ) { default String = value . substring ( value . last Index Of ( STRING ) + NUM ) ; key = value . substring ( NUM , value . last Index Of ( STRING ) ) ; } else { key = value ; default String = value ; } out String += temp String . substring ( start Index , starts With Pos ) + System . get Property ( key , default String ) ; start Index = ends With Pos + NUM ; } } if ( start Index < temp String . length ( ) ) { out String += temp String . substring ( start Index ) ; } return out String ; }
public synchronized void remove OF Channel Handler ( OF Channel Handler h ) { connected Channel Handlers . remove ( h ) ; }
public static boolean stream To File ( final Input Stream input Stream , final File target File , final boolean do Append ) { if ( input Stream == null || ! is Writable ( target File , BOOL ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } boolean is Succeed = BOOL ; final int buffer size = NUM ; Output Stream output Stream = null ; try { output Stream = new File Output Stream ( target File , do Append ) ; byte [ ] bytes = new byte [ buffer size ] ; int count = NUM ; while ( ( count = input Stream . read ( bytes , NUM , buffer size ) ) > NUM ) output Stream . write ( bytes , NUM , count ) ; is Succeed = BOOL ; output Stream . flush ( ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } catch ( Index Out Of Bounds Exception e ) { e . print Stack Trace ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { if ( output Stream != null ) try { sync ( output Stream ) ; output Stream . close ( ) ; } catch ( IO Exception e ) { } } return is Succeed ; }
public void add Arg ( Function Lib Function Arg arg ) { arg . set Function ( this ) ; argument . add ( arg ) ; if ( arg . get Default Value ( ) != null ) has Default Values = BOOL ; }
public void register Text Flavor Properties ( String nat , String charset , String eoln , String terminators ) { Long format = get Format For Native As Long ( nat ) ; text Natives . add ( format ) ; native Charsets . put ( format , ( charset != null && charset . length ( ) != NUM ) ? charset : get Default Text Charset ( ) ) ; if ( eoln != null && eoln . length ( ) != NUM && ! eoln . equals ( STRING ) ) { native EOL Ns . put ( format , eoln ) ; } if ( terminators != null && terminators . length ( ) != NUM ) { Integer i Terminators = Integer . value Of ( terminators ) ; if ( i Terminators . int Value ( ) > NUM ) { native Terminators . put ( format , i Terminators ) ; } } }
public Namespace Id concat ( final Namespace Id Part part ) { final Namespace Id Part [ ] parts = new Namespace Id Part [ this . namespace Id Parts . length + NUM ] ; System . arraycopy ( this . namespace Id Parts , NUM , parts , NUM , this . namespace Id Parts . length ) ; parts [ this . namespace Id Parts . length ] = part ; return new Namespace Id ( parts ) ; }
private double [ ] [ ] Calc Constant Coef ( Variogram variogarm , List < Kriging Point > NN Points ) { int n = NN Points . size ( ) ; double [ ] [ ] mat = new double [ n + NUM ] [ n + NUM ] ; double dist = NUM ; for ( int i = NUM ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { dist = Math . sqrt ( Math . abs ( Math . pow ( NN Points . get ( i ) . x - NN Points . get ( j ) . x , NUM ) ) + Math . abs ( Math . pow ( NN Points . get ( i ) . y - NN Points . get ( j ) . y , NUM ) ) ) ; mat [ i ] [ j ] = get Theoretical SV Value ( dist , variogarm ) ; mat [ j ] [ i ] = mat [ i ] [ j ] ; } } for ( int i = NUM ; i < n ; i ++ ) { mat [ i ] [ n ] = NUM ; mat [ n ] [ i ] = NUM ; } return mat ; }
public static Object deserialization ( String file Path ) { Object Input Stream in = null ; try { in = new Object Input Stream ( new File Input Stream ( file Path ) ) ; Object o = in . read Object ( ) ; in . close ( ) ; return o ; } catch ( File Not Found Exception e ) { throw new Runtime Exception ( STRING , e ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( STRING , e ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING , e ) ; } finally { IO Util . close ( in ) ; } }
public String finished ( Logger log ) { if ( m av Insts Per Sec == NUM ) { compute Update ( System . current Time Millis ( ) ) ; } int nS = m num Samples > NUM ? m num Samples : NUM ; String msg = STRING + m instance Count + STRING + m av Insts Per Sec / nS + STRING ; if ( log != null ) { log . status Message ( m status Message Prefix + msg ) ; } return msg ; }
public void include ( final Path Matcher matcher ) { include Matchers . add ( matcher ) ; }
public Array List < Mech Summary > generate Units ( int num ) { return generate Units ( num , null ) ; }
public static Automaton random Automaton ( Random random ) { Automaton a1 = random Single Automaton ( random ) ; Automaton a2 = random Single Automaton ( random ) ; switch ( random . next Int ( NUM ) ) { case NUM : return Operations . concatenate ( a1 , a2 ) ; case NUM : return Operations . union ( a1 , a2 ) ; case NUM : return Operations . intersection ( a1 , a2 ) ; default : return Operations . minus ( a1 , a2 , DEFAULT MAX DETERMINIZED STATES ) ; } }
protected void select Item ( ) { if ( items Table . get Selection Count ( ) == NUM ) { return ; } final List < DL Item > selected Items = new Array List < DL Item > ( ) ; for ( final Table Item table Item : items Table . get Selection ( ) ) { final DL Item item = ( DL Item ) table Item . get Data ( ) ; item . set Last Action ( LAST ACTION . SELECTION ) ; selected Items . add ( item ) ; selection . add ( item ) ; items . remove ( item ) ; fire Selection Event ( item ) ; } fire Selection Change Event ( selected Items ) ; redraw Tables ( ) ; }
protected void canopy Init ( Instances data ) throws Exception { if ( m canopy Clusters == null ) { m canopy Clusters = new Canopy ( ) ; m canopy Clusters . set Num Clusters ( m Num Clusters ) ; m canopy Clusters . set Seed ( get Seed ( ) ) ; m canopy Clusters . set T 2 ( get Canopy T 2 ( ) ) ; m canopy Clusters . set T 1 ( get Canopy T 1 ( ) ) ; m canopy Clusters . set Max Num Candidate Canopies To Hold In Memory ( get Canopy Max Num Canopies To Hold In Memory ( ) ) ; m canopy Clusters . set Periodic Pruning Rate ( get Canopy Periodic Pruning Rate ( ) ) ; m canopy Clusters . set Minimum Canopy Density ( get Canopy Minimum Canopy Density ( ) ) ; m canopy Clusters . set Debug ( get Debug ( ) ) ; m canopy Clusters . build Clusterer ( data ) ; } m Cluster Centroids = m canopy Clusters . get Canopies ( ) ; }
public void update Scrollbars ( ) { Point preferred Size = get Table Size ( ) ; Rectangle client Area = get Client Area ( ) ; for ( int double Pass = NUM ; double Pass <= NUM ; double Pass ++ ) { if ( preferred Size . y > client Area . height ) { v Scroll . set Visible ( BOOL ) ; } else { v Scroll . set Visible ( BOOL ) ; v Scroll . set Values ( NUM , NUM , NUM , NUM , NUM , NUM ) ; } if ( preferred Size . x > client Area . width ) { h Scroll . set Visible ( BOOL ) ; } else { h Scroll . set Visible ( BOOL ) ; h Scroll . set Values ( NUM , NUM , NUM , NUM , NUM , NUM ) ; } client Area = get Client Area ( ) ; } if ( v Scroll . get Visible ( ) ) { int max = get Item Count ( ) ; int thumb = ( get Visible Grid Height ( ) + NUM ) / ( get Item Height ( ) + NUM ) ; int selection = Math . min ( v Scroll . get Selection ( ) , max ) ; v Scroll . set Values ( selection , NUM , max , thumb , NUM , thumb ) ; } if ( h Scroll . get Visible ( ) ) { if ( ! column Scrolling ) { int hidden Area = preferred Size . x - client Area . width + NUM ; int selection = Math . min ( h Scroll . get Selection ( ) , hidden Area - NUM ) ; h Scroll . set Values ( selection , NUM , hidden Area + client Area . width - NUM , client Area . width , HORZ SCROLL INCREMENT , client Area . width ) ; } else { int hidden Area = preferred Size . x - client Area . width + NUM ; int max = NUM ; int i = NUM ; while ( hidden Area > NUM && i < get Column Count ( ) ) { Grid Column col = columns . get ( i ) ; i ++ ; hidden Area -= col . get Width ( ) ; max ++ ; } max ++ ; int vis Cols = columns . size ( ) ; max = Math . min ( vis Cols , max ) ; int selection = Math . min ( h Scroll . get Selection ( ) , max ) ; h Scroll . set Values ( selection , NUM , max , NUM , NUM , NUM ) ; } } }
private void read Object ( Object Input Stream oos ) throws IO Exception , Class Not Found Exception { i Instant = ( Local Date ) oos . read Object ( ) ; Date Time Field Type type = ( Date Time Field Type ) oos . read Object ( ) ; i Field = type . get Field ( i Instant . get Chronology ( ) ) ; }
public String pre Process User Input ( String user Input , I State Access state , boolean is Req ) throws Install Exception { String proc Res = null ; if ( is Req ) { proc Res = pre Proc User Input If Required ( user Input , state ) ; } else { proc Res = pre Proc User Input If Optional ( user Input , state ) ; } return proc Res ; }
@ Override public final int read Unsigned Byte ( ) throws IO Exception { return dis . read Unsigned Byte ( ) ; }
public static String create Hash ( char [ ] password ) throws No Such Algorithm Exception , Invalid Key Spec Exception { Secure Random random = new Secure Random ( ) ; byte [ ] salt = new byte [ SALT BYTE SIZE ] ; random . next Bytes ( salt ) ; byte [ ] hash = pbkdf 2 ( password , salt , PBKDF 2 ITERATIONS , HASH BYTE SIZE ) ; return PBKDF 2 ITERATIONS + STRING + to Hex ( salt ) + STRING + to Hex ( hash ) ; }
public void add Ignored Emote ( String emote Code ) { ignored Emotes . add ( emote Code ) ; }
public boolean is Function Allowed ( Name name ) { return functions Allowed . contains ( name ) ; }
public void store ( Element root ) { Element values ; List < String > names = get Consist Name List ( ) ; if ( Control . backward Compatible ) { root . add Content ( values = new Element ( Xml . CONSISTS ) ) ; for ( String name : names ) { String consist Names = name + STRING ; values . add Content ( consist Names ) ; } } Element consists = new Element ( Xml . NEW CONSISTS ) ; for ( String name : names ) { Element consist = new Element ( Xml . CONSIST ) ; consist . set Attribute ( new Attribute ( Xml . NAME , name ) ) ; consists . add Content ( consist ) ; } root . add Content ( consists ) ; root . add Content ( values = new Element ( Xml . ENGINES ) ) ; for ( Rolling Stock rs : get By Road Name List ( ) ) { Engine eng = ( Engine ) rs ; values . add Content ( eng . store ( ) ) ; } }
public void test Constructor Sign Bytes Zero Null 1 ( ) { byte a Bytes [ ] = { } ; int a Sign = - NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = a Number . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , a Number . signum ( ) ) ; }
public static boolean connect ( File Descriptor fd , Inet Address inet Address , int port ) throws Socket Exception { try { return Io Bridge . connect ( fd , inet Address , port , NUM ) ; } catch ( Socket Timeout Exception ex ) { throw new Assertion Error ( ex ) ; } }
public SVG Rasterizer ( URL url ) { this . input = new Transcoder Input ( url . to String ( ) ) ; }
public void test Get Elements By Tag Name NS 1 ( ) throws Throwable { Document doc ; Document new Doc ; Document Type doc Type = null ; DOM Implementation dom Impl ; Node List child List ; String null NS = null ; doc = ( Document ) load ( STRING , builder ) ; dom Impl = doc . get Implementation ( ) ; new Doc = dom Impl . create Document ( null NS , STRING , doc Type ) ; child List = new Doc . get Elements By Tag Name NS ( STRING , STRING ) ; assert Equals ( STRING , NUM , child List . get Length ( ) ) ; }
@ HLE Unimplemented @ HLE Function ( nid = NUM , version = NUM , check Inside Interrupt = BOOL ) public int sce Sas Set Triangular Wave ( int sas Core , int voice , int unknown ) { check Sas And Voice Handles Good ( sas Core , voice ) ; return NUM ; }
public void handle Tbl Request Handler List Href Edit Action Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; SCSAML 2 SOAP Binding Request Handler List Edit View Bean vb = ( SCSAML 2 SOAP Binding Request Handler List Edit View Bean ) get View Bean ( SCSAML 2 SOAP Binding Request Handler List Edit View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; vb . populate Values ( ( String ) get Display Field Value ( TBL REQUEST HANDLER LIST HREF EDIT ACTION ) ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }
protected static void draw Data Point ( double x , double y , int size , int shape , Graphics gx ) { Font lf = new Font ( STRING , Font . PLAIN , NUM ) ; Font Metrics fm = gx . get Font Metrics ( lf ) ; if ( size == NUM ) { size = NUM ; } if ( shape != ERROR SHAPE && shape != MISSING SHAPE ) { shape = shape % NUM ; } switch ( shape ) { case X SHAPE : draw X ( gx , x , y , size ) ; break ; case PLUS SHAPE : draw Plus ( gx , x , y , size ) ; break ; case DIAMOND SHAPE : draw Diamond ( gx , x , y , size ) ; break ; case TRIANGLEUP SHAPE : draw Triangle Up ( gx , x , y , size ) ; break ; case TRIANGLEDOWN SHAPE : draw Triangle Down ( gx , x , y , size ) ; break ; case ERROR SHAPE : gx . draw Rect ( ( int ) ( x - size ) , ( int ) ( y - size ) , ( size * NUM ) , ( size * NUM ) ) ; break ; case MISSING SHAPE : int hf = fm . get Ascent ( ) ; int width = fm . string Width ( STRING ) ; gx . draw String ( STRING , ( int ) ( x - ( width / NUM ) ) , ( int ) ( y + ( hf / NUM ) ) ) ; break ; } }
public boolean redo ( Set < Integer > p changed nets ) { brd components . redo ( observers ) ; Collection < Undo Object Storable > cancelled objects = new Linked List < Undo Object Storable > ( ) ; Collection < Undo Object Storable > restored objects = new Linked List < Undo Object Storable > ( ) ; boolean result = undo items . redo ( cancelled objects , restored objects ) ; Iterator < Undo Object Storable > it = cancelled objects . iterator ( ) ; while ( it . has Next ( ) ) { Brd Item curr item = ( Brd Item ) it . next ( ) ; search tree manager . remove ( curr item ) ; observers . notify deleted ( curr item ) ; if ( p changed nets != null ) { for ( int i = NUM ; i < curr item . net count ( ) ; ++ i ) { p changed nets . add ( curr item . get net no ( i ) ) ; } } } it = restored objects . iterator ( ) ; while ( it . has Next ( ) ) { Brd Item curr item = ( Brd Item ) it . next ( ) ; curr item . r board = this ; search tree manager . insert ( curr item ) ; curr item . art item clear ( ) ; observers . notify new ( curr item ) ; if ( p changed nets != null ) { for ( int i = NUM ; i < curr item . net count ( ) ; ++ i ) { p changed nets . add ( curr item . get net no ( i ) ) ; } } } return result ; }
void init ( List < Column Meta Data > column Meta Data ) { this . column Meta Data = column Meta Data ; column Roles . clear ( ) ; column Names . clear ( ) ; int column Index = NUM ; for ( Column Meta Data column : column Meta Data ) { add Column To Columns Maps ( column Index , column ) ; if ( ! column . is Removed ( ) ) { selected Columns . add ( column Index ) ; } column Index ++ ; } check For Duplicates ( ) ; }
private static Field find Field ( Object instance , String name ) throws No Such Field Exception { for ( Class < ? > clazz = instance . get Class ( ) ; clazz != null ; clazz = clazz . get Superclass ( ) ) { try { Field field = clazz . get Declared Field ( name ) ; if ( ! field . is Accessible ( ) ) { field . set Accessible ( BOOL ) ; } return field ; } catch ( No Such Field Exception e ) { } } throw new No Such Field Exception ( STRING + name + STRING + instance . get Class ( ) ) ; }
private void dump ASCII ( Utterance utterance ) { if ( wave Dump File != null ) { LPC Result lpc Result = ( LPC Result ) utterance . get Object ( STRING ) ; try { if ( wave Dump File . equals ( STRING ) ) { lpc Result . dump ASCII ( ) ; } else { lpc Result . dump ASCII ( wave Dump File ) ; } } catch ( IO Exception ioe ) { error ( STRING + wave Dump File + STRING + ioe ) ; } } }
private static boolean date By Ordinal ( Date Time Formatter Builder bld , Collection < Date Time Field Type > fields , boolean extended , boolean strict ISO ) { boolean reduced Prec = BOOL ; if ( fields . remove ( Date Time Field Type . year ( ) ) ) { bld . append ( Constants . ye ) ; if ( fields . remove ( Date Time Field Type . day Of Year ( ) ) ) { append Separator ( bld , extended ) ; bld . append Day Of Year ( NUM ) ; } else { reduced Prec = BOOL ; } } else if ( fields . remove ( Date Time Field Type . day Of Year ( ) ) ) { bld . append Literal ( STRING ) ; bld . append Day Of Year ( NUM ) ; } return reduced Prec ; }
protected void write Attributes ( Attribute Set attr ) throws IO Exception { conv Attr . remove Attributes ( conv Attr ) ; convert To HTML 32 ( attr , conv Attr ) ; Enumeration names = conv Attr . get Attribute Names ( ) ; while ( names . has More Elements ( ) ) { Object name = names . next Element ( ) ; if ( name instanceof HTML . Tag || name instanceof Style Constants || name == HTML . Attribute . ENDTAG ) { continue ; } write ( STRING + name + STRING + conv Attr . get Attribute ( name ) + STRING ) ; } }
public Page Range add Single Page ( int page Number ) { sequence Starts . add ( page Number ) ; sequence Ends . add ( page Number ) ; return this ; }
public static List < Dimensional Item Object > as List ( Collection < ? extends Dimensional Item Object > collection ) { List < Dimensional Item Object > list = new Array List < > ( ) ; list . add All ( collection ) ; return list ; }
public Create Index Request aliases ( X Content Builder source ) { return aliases ( source . bytes ( ) ) ; }
private static Table Info create Table Info ( String table Name , Integer page Number , int flags , Short type , String linked Db Name , String linked Table Name ) { if ( TYPE LINKED TABLE . equals ( type ) ) { return new Linked Table Info ( page Number , table Name , flags , linked Db Name , linked Table Name ) ; } return new Table Info ( page Number , table Name , flags ) ; }
public static String gensalt ( final int log rounds , final Secure Random random ) { final String Buffer rs = new String Buffer ( ) ; final byte rnd [ ] = new byte [ BCRYPT SALT LEN ] ; random . next Bytes ( rnd ) ; rs . append ( STRING ) ; if ( log rounds < NUM ) { rs . append ( STRING ) ; } if ( log rounds > NUM ) { throw new Illegal Argument Exception ( STRING ) ; } rs . append ( Integer . to String ( log rounds ) ) ; rs . append ( STRING ) ; rs . append ( encode base 64 ( rnd , rnd . length ) ) ; return rs . to String ( ) ; }
public void add Listener ( @ Not Null Configuration Listener listener ) { if ( my Listeners == null ) { my Listeners = new Array List < > ( ) ; } my Listeners . add ( listener ) ; }
public void do Window Open ( ) { }
public boolean submit No Wake ( Runnable task , Class Loader loader ) { boolean is Priority = BOOL ; boolean is Queue = BOOL ; boolean is Wake = BOOL ; return schedule Impl ( task , loader , MAX EXPIRE , is Priority , is Queue , is Wake ) ; }
public static int hash 3 ( int hash , Object x , Object y , Object z ) { return NUM | ( hash + NUM * System . identity Hash Code ( x ) + NUM * System . identity Hash Code ( y ) + NUM * System . identity Hash Code ( z ) ) ; }
public void import Data ( final File the File ) { try { CSV Parser the Parser = new CSV Parser ( new File Input Stream ( the File ) , STRING , STRING , STRING ) ; String [ ] [ ] values = the Parser . get All Values ( ) ; String [ ] line ; double [ ] vector ; int dimension = values [ NUM ] . length ; init ( dimension ) ; for ( int i = NUM ; i < values . length ; i ++ ) { line = values [ i ] ; vector = new double [ values [ NUM ] . length ] ; for ( int j = NUM ; j < line . length ; j ++ ) { vector [ j ] = Double . parse Double ( line [ j ] ) ; } add Datapoint ( new Data Point Colored ( vector ) ) ; } } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } projection Method . init ( ) ; projection Method . project ( ) ; fire Projector Data Changed ( ) ; }
public static Double Stream concat ( Double Stream a , Double Stream b ) { Objects . require Non Null ( a ) ; Objects . require Non Null ( b ) ; Spliterator . Of Double split = new Streams . Concat Spliterator . Of Double ( a . spliterator ( ) , b . spliterator ( ) ) ; Double Stream stream = Stream Support . double Stream ( split , a . is Parallel ( ) || b . is Parallel ( ) ) ; return stream . on Close ( Streams . composed Close ( a , b ) ) ; }
@ Category ( Flaky Test . class ) @ Test public void test Missing Member Redundancy 1 ( ) { Host host = Host . get Host ( NUM ) ; VM vm 0 = host . get VM ( NUM ) ; VM vm 1 = host . get VM ( NUM ) ; VM vm 2 = host . get VM ( NUM ) ; create PR ( vm 0 , NUM ) ; create PR ( vm 1 , NUM ) ; create Data ( vm 0 , NUM , NUM BUCKETS , STRING ) ; Set < Integer > vm 0 Buckets = get Bucket List ( vm 0 ) ; Set < Integer > vm 1 Buckets = get Bucket List ( vm 1 ) ; close Cache ( vm 1 ) ; check Data ( vm 0 , NUM , NUM BUCKETS , STRING ) ; remove Data ( vm 0 , NUM , NUM BUCKETS / NUM ) ; create Data ( vm 0 , NUM BUCKETS / NUM , NUM BUCKETS , STRING ) ; create PR ( vm 2 , NUM ) ; Set < Integer > vm 2 Buckets = get Bucket List ( vm 2 ) ; assert Equals ( Collections . empty Set ( ) , vm 2 Buckets ) ; create PR ( vm 1 , NUM ) ; check Data ( vm 1 , NUM , NUM BUCKETS / NUM , null ) ; check Data ( vm 1 , NUM BUCKETS / NUM , NUM BUCKETS , STRING ) ; assert Equals ( vm 0 Buckets , get Bucket List ( vm 0 ) ) ; assert Equals ( vm 1 Buckets , get Bucket List ( vm 1 ) ) ; assert Equals ( Collections . empty Set ( ) , get Bucket List ( vm 2 ) ) ; }
public static void trim Lines ( final Document doc , final int line Count ) { if ( doc . get Length ( ) < line Count ) { return ; } try { final String text = doc . get Text ( NUM , doc . get Length ( ) ) ; int returns Found = NUM ; for ( int i = text . length ( ) - NUM ; i >= NUM ; i -- ) { if ( text . char At ( i ) == STRING ) { returns Found ++ ; } if ( returns Found == line Count ) { doc . remove ( NUM , i ) ; return ; } } } catch ( final Bad Location Exception e ) { Client Logger . log Error ( STRING , e ) ; } }
private void adjust Column Widths ( J Table table ) { Table Column Model model = table . get Column Model ( ) ; for ( int column = NUM ; column < table . get Column Count ( ) ; column ++ ) { Table Column tc = model . get Column ( column ) ; int width = tc . get Width ( ) ; for ( int row = NUM ; row < table . get Row Count ( ) ; row ++ ) { Component comp = table . prepare Renderer ( table . get Cell Renderer ( row , column ) , row , column ) ; width = Math . max ( width , comp . get Preferred Size ( ) . width ) ; } tc . set Preferred Width ( width ) ; } }
public static List < Volume > query Volumes By Iterative Query ( Db Client db Client , List < URI > volume UR Is ) { List < Volume > volumes = new Array List < Volume > ( ) ; @ Suppress Warnings ( STRING ) Iterator < Volume > volume Iterator = db Client . query Iterative Objects ( Volume . class , volume UR Is ) ; while ( volume Iterator . has Next ( ) ) { volumes . add ( volume Iterator . next ( ) ) ; } return volumes ; }
protected static String [ ] split String By Delimiter Points ( String s Str , Integer [ ] i Res ) { Array List al Res = new Array List ( ) ; for ( int i Cnt = NUM ; i Cnt < i Res . length ; i Cnt ++ ) { if ( i Cnt == NUM ) al Res . add ( s Str . substring ( NUM , i Res [ i Cnt ] ) ) ; else al Res . add ( s Str . substring ( i Res [ i Cnt - NUM ] , i Res [ i Cnt ] ) ) ; } if ( i Res . length > NUM ) al Res . add ( s Str . substring ( i Res [ i Res . length - NUM ] ) ) ; else al Res . add ( s Str ) ; String [ ] s Res = new String [ al Res . size ( ) ] ; al Res . to Array ( s Res ) ; return s Res ; }
private void disable Index Form ( ) { edit Index Index = - NUM ; index Name . set Text ( STRING ) ; index Type . set Text ( STRING ) ; selected Columns . remove All ( ) ; index Name . set Enabled ( BOOL ) ; index Type . set Enabled ( BOOL ) ; selected Columns . set Enabled ( BOOL ) ; del Index . set Enabled ( BOOL ) ; index Add Button . set Enabled ( BOOL ) ; index Remove Button . set Enabled ( BOOL ) ; index Up Button . set Enabled ( BOOL ) ; index Down Button . set Enabled ( BOOL ) ; }
public static void srs print bytes ( String tag , Byte Buffer bb , int size ) { String Builder sb = new String Builder ( ) ; int i = NUM ; int bytes in line = NUM ; int max = bb . remaining ( ) ; for ( i = NUM ; i < size && i < max ; i ++ ) { sb . append ( String . format ( STRING , Integer . to Hex String ( bb . get ( i ) & NUM ) ) ) ; if ( ( ( i + NUM ) % bytes in line ) == NUM ) { Log . i ( tag , String . format ( STRING , i / bytes in line * bytes in line , i , sb . to String ( ) ) ) ; sb = new String Builder ( ) ; } } if ( sb . length ( ) > NUM ) { Log . i ( tag , String . format ( STRING , size / bytes in line * bytes in line , i - NUM , sb . to String ( ) ) ) ; } }
public void interrupt ( ) { final Thread t = thread Var . get ( ) ; if ( t != null ) { t . interrupt ( ) ; while ( t . is Alive ( ) ) { try { Thread . sleep ( NUM ) ; } catch ( final Interrupted Exception e ) { Log Writer . write Log ( STRING + e . get Message ( ) ) ; } } } thread Var . clear ( ) ; }
private String make Content ( Stream Info info , String content ) { content = content . replace ( STRING , info . get Title ( ) ) ; content = content . replace ( STRING , info . get Game ( ) ) ; content = content . replace ( STRING , Helper . format Viewer Count ( info . get Viewers ( ) ) ) ; content = content . replace ( STRING , Helper . format Viewer Count ( info . get Follower Count ( ) ) ) ; content = content . replace ( STRING , Helper . format Viewer Count ( info . get Subscriber Count ( ) ) ) ; content = content . replace ( STRING , String . value Of ( info . get Viewers ( ) ) ) ; content = content . replace ( STRING , String . value Of ( info . get Follower Count ( ) ) ) ; content = content . replace ( STRING , String . value Of ( info . get Subscriber Count ( ) ) ) ; return content ; }
private void draw Rectangle ( final Graphics 2 D g2 d , final Color fill Color , final Color out Line Color , final int width , final int height ) { g2 d . set Color ( out Line Color ) ; g2 d . fill Rect ( BUBBLE OFFSET , NUM , width , height ) ; g2 d . set Color ( fill Color ) ; g2 d . fill Rect ( BUBBLE OFFSET + NUM , NUM , width - NUM , height - NUM ) ; }
public static Object invoke ( Invocation State invocation State , Class < ? > target Class , Object o , Object functional Object , Class < ? > invoker , String method , boolean [ ] primitives , Object [ ] args ) throws Throwable { if ( primitives . length != args . length ) throw new Lt Bug ( STRING ) ; List < Method > method List = new Array List < > ( ) ; Queue < Class < ? > > interfaces = new Array Deque < > ( ) ; Class < ? > c = o == null ? target Class : o . get Class ( ) ; while ( c != null ) { Collections . add All ( interfaces , c . get Interfaces ( ) ) ; fill Method Candidates ( c , invoker , method , args , method List , o == null ) ; c = c . get Superclass ( ) ; } c = o == null ? target Class : o . get Class ( ) ; Collections . add All ( interfaces , c . get Interfaces ( ) ) ; while ( ! interfaces . is Empty ( ) ) { Class < ? > i = interfaces . remove ( ) ; fill Method Candidates ( i , invoker , method , args , method List , o == null ) ; Collections . add All ( interfaces , i . get Interfaces ( ) ) ; } if ( method List . is Empty ( ) ) { if ( c . is Array ( ) ) { if ( method . equals ( STRING ) && args . length >= NUM && args [ NUM ] instanceof Integer ) { Object res = Array . get ( o , ( Integer ) args [ NUM ] ) ; if ( args . length == NUM ) return res ; boolean [ ] bs = new boolean [ primitives . length - NUM ] ; Object [ ] as = new Object [ args . length - NUM ] ; for ( int i = NUM ; i < args . length ; ++ i ) { bs [ i - NUM ] = primitives [ i ] ; as [ i - NUM ] = args [ i ] ; } return invoke ( invocation State , target Class , res , null , invoker , STRING , bs , as ) ; } else if ( method . equals ( STRING ) && args . length >= NUM && args [ NUM ] instanceof Integer ) { if ( args . length == NUM ) { Array . set ( o , ( Integer ) args [ NUM ] , args [ NUM ] ) ; return args [ NUM ] ; } else { Object elem = Array . get ( o , ( Integer ) args [ NUM ] ) ; boolean [ ] bs = new boolean [ primitives . length - NUM ] ; Object [ ] as = new Object [ args . length - NUM ] ; for ( int i = NUM ; i < args . length ; ++ i ) { bs [ i - NUM ] = primitives [ i ] ; as [ i - NUM ] = args [ i ] ; } return invoke ( invocation State , target Class , elem , null , invoker , STRING , bs , as ) ; } } } else { if ( args . length == NUM && is Box Type ( c ) && is Box Type ( args [ NUM ] . get Class ( ) ) ) { return invoke Primitive ( o , method , args [ NUM ] ) ; } else if ( args . length == NUM && is Box Type ( c ) ) { return invoke Primitive ( o , method ) ; } else if ( method . equals ( STRING ) && args . length == NUM && ( args [ NUM ] instanceof String || o instanceof String ) ) { return String . value Of ( o ) + String . value Of ( args [ NUM ] ) ; } else if ( method . equals ( STRING ) ) { return invoke ( invocation State , target Class , o , functional Object , invoker , STRING , primitives , args ) ; } else if ( method . equals ( STRING ) && args . length == NUM ) { return ! Lt Runtime . cast To Bool ( o ) ; } } if ( ! invocation State . is Calling Reverse ) { if ( o != null && args . length == NUM && args [ NUM ] != null ) { String method Name = STRING + method ; Object 2 = args [ NUM ] ; Invocation State reverse Invocation State = new Invocation State ( ) ; reverse Invocation State . is Calling Reverse = BOOL ; try { return invoke ( reverse Invocation State , 2 . get Class ( ) , 2 , null , invoker , method Name , new boolean [ ] { BOOL } , new Object [ ] { o } ) ; } catch ( Throwable t ) { if ( reverse Invocation State . method Found ) { throw t ; } } } if ( functional Object != null ) { Invocation State call Functional State = new Invocation State ( ) ; try { return call Functional Object ( call Functional State , functional Object , invoker , args ) ; } catch ( Throwable t ) { if ( call Functional State . method Found ) throw t ; } } invocation State . method Found = BOOL ; Method call = null ; try { Class < ? > cc = target Class ; if ( o != null ) { cc = o . get Class ( ) ; } call = cc . get Method ( STRING , Object . class , String . class , boolean [ ] . class , Object [ ] . class ) ; if ( Modifier . is Static ( call . get Modifiers ( ) ) && ! call . get Return Type ( ) . equals ( void . class ) ) { invocation State . method Found = BOOL ; } } catch ( No Such Method Exception ignore ) { } if ( invocation State . method Found ) { assert call != null ; try { return call . invoke ( null , o , method , primitives , args ) ; } catch ( Invocation Target Exception e ) { throw e . get Target Exception ( ) ; } } } if ( ! invocation State . from Field && ! invocation State . is Calling Reverse ) { Object result = Lt Runtime . get Field ( o , method , invoker ) ; if ( result != null && ! result . equals ( Unit . get ( ) ) ) { invocation State . method Found = BOOL ; return call Functional Object ( result , invoker , args ) ; } } String Builder sb = new String Builder ( ) . append ( o == null ? target Class . get Name ( ) : o . get Class ( ) . get Name ( ) ) . append ( STRING ) . append ( method ) . append ( STRING ) ; boolean is First = BOOL ; for ( Object arg : args ) { if ( is First ) is First = BOOL ; else sb . append ( STRING ) ; sb . append ( arg == null ? STRING : arg . get Class ( ) . get Name ( ) ) ; } sb . append ( STRING ) ; throw new Lt Runtime Exception ( STRING + sb . to String ( ) ) ; } Method method To Invoke = find Best Match ( method List , args , primitives ) ; invocation State . method Found = BOOL ; trans To Required Type ( args , method To Invoke . get Parameter Types ( ) ) ; method To Invoke . set Accessible ( BOOL ) ; try { Object res = method To Invoke . invoke ( o , args ) ; if ( method To Invoke . get Return Type ( ) == void . class ) return Unit . get ( ) ; else return res ; } catch ( Invocation Target Exception e ) { throw e . get Target Exception ( ) ; } }
private static boolean is Compound Noun ( final Expression Type cur Type , final Expression Type next Type , final boolean preceding Verb ) { final boolean next Is Subj Obj Name = next Type . is Object ( ) || ( next Type . is Subject ( ) && ! next Type . is Pronoun ( ) ) ; if ( next Is Subj Obj Name ) { final boolean curr Is Subj Obj = cur Type . is Object ( ) || ( cur Type . is Subject ( ) && ! cur Type . is Pronoun ( ) && ! cur Type . is Name ( ) ) ; if ( curr Is Subj Obj ) { return BOOL ; } else if ( cur Type . is Adjective ( ) ) { return BOOL ; } else if ( cur Type . is Verb ( ) && preceding Verb ) { return BOOL ; } } return BOOL ; }
@ Override public int hash Code ( ) { int code = f Name . hash Code ( ) ; if ( f Target Namespace != null ) code = ( code << NUM ) + f Target Namespace . hash Code ( ) ; return code ; }
public Builder add Action ( String action Type , Action action ) { m Actions . add ( new Action Pair ( action Type , action ) ) ; return this ; }
public static void move File To Directory ( File src File , File dest Dir , boolean create Dest Dir ) throws IO Exception { if ( src File == null ) { throw new Null Pointer Exception ( STRING ) ; } else if ( dest Dir == null ) { throw new Null Pointer Exception ( STRING ) ; } else { if ( ! dest Dir . exists ( ) && create Dest Dir ) { dest Dir . mkdirs ( ) ; } if ( ! dest Dir . exists ( ) ) { throw new File Not Found Exception ( STRING + dest Dir + STRING + create Dest Dir + STRING ) ; } else if ( ! dest Dir . is Directory ( ) ) { throw new IO Exception ( STRING + dest Dir + STRING ) ; } else { move File ( src File , new File ( dest Dir , src File . get Name ( ) ) ) ; } } }
public static List < Point 2 D > divide Conquer Brownian Bridge ( double D , Point 2 D t0 y 0 , Point 2 D t1 y 1 , int depth , Space Time Rejector 1 D rejector ) { List < Point 2 D > points = new Linked List < Point 2 D > ( ) ; points . add ( t0 y 0 ) ; points . add ( t1 y 1 ) ; divide Conquer Brownian Bridge ( D , NUM , points , depth , rejector ) ; return points ; }
protected static void remove All Triggers ( Connection conn , String prefix ) throws SQL Exception { Statement stat = conn . create Statement ( ) ; Result Set rs = stat . execute Query ( STRING ) ; Statement stat 2 = conn . create Statement ( ) ; while ( rs . next ( ) ) { String schema = rs . get String ( STRING ) ; String name = rs . get String ( STRING ) ; if ( name . starts With ( prefix ) ) { name = String Utils . quote Identifier ( schema ) + STRING + String Utils . quote Identifier ( name ) ; stat 2 . execute ( STRING + name ) ; } } }
public boolean contains ( Group Category category ) { return f Content . contains ( category ) ; }
public static boolean is Volume CG Full Copy Source ( Volume volume , Db Client db Client ) { boolean is Full Copy Source = BOOL ; String Set full Copy Ids = volume . get Full Copies ( ) ; if ( ( full Copy Ids != null ) && ( ! full Copy Ids . is Empty ( ) ) ) { Iterator < String > full Copy Ids Iter = full Copy Ids . iterator ( ) ; while ( full Copy Ids Iter . has Next ( ) ) { URI full Copy URI = URI . create ( full Copy Ids Iter . next ( ) ) ; Volume full Copy Volume = db Client . query Object ( Volume . class , full Copy URI ) ; if ( ( full Copy Volume != null ) && ( ! full Copy Volume . get Inactive ( ) ) ) { String group Name = full Copy Volume . get Replication Group Instance ( ) ; if ( Null Column Value Getter . is Not Null Value ( group Name ) || V Plex Util . is Backend Full Copy In Replication Group ( full Copy Volume , db Client ) ) { is Full Copy Source = BOOL ; break ; } } } } return is Full Copy Source ; }
@ Override public void assert Equals ( String message , Object expected Obj , Object actual Obj ) { ANOVA Matrix expected = ( ANOVA Matrix ) expected Obj ; ANOVA Matrix actual = ( ANOVA Matrix ) actual Obj ; message = message + STRING + actual . get Source ( ) + STRING ; double [ ] [ ] expected Probabilities = expected . get Probabilities ( ) ; double [ ] [ ] actual Probabilities = actual . get Probabilities ( ) ; for ( int i = NUM ; i < expected Probabilities . length ; i ++ ) { for ( int j = NUM ; j < expected Probabilities [ i ] . length ; j ++ ) { Assert . assert Equals ( message + STRING , expected Probabilities [ i ] [ j ] , actual Probabilities [ i ] [ j ] , NUM ) ; } } Assert . assert Equals ( message + STRING , expected . get Significance Level ( ) , actual . get Significance Level ( ) , NUM ) ; }
public void test member Add terminate Client ( ) throws Interrupted Exception { final Quorum < ? , ? > quorum = quorums [ NUM ] ; final Quorum Member < ? > client = clients [ NUM ] ; final Quorum Actor < ? , ? > actor = actors [ NUM ] ; final UUID service Id = client . get Service Id ( ) ; assert False ( client . is Member ( ) ) ; assert Equals ( new UUID [ ] { } , quorum . get Members ( ) ) ; actor . member Add ( ) ; fixture . await Deque ( ) ; assert True ( client . is Member ( ) ) ; assert Equals ( new UUID [ ] { service Id } , quorum . get Members ( ) ) ; assert Equals ( client , quorum . get Client ( ) ) ; quorum . terminate ( ) ; try { quorum . get Client ( ) ; } catch ( Illegal State Exception ex ) { log . info ( STRING + ex ) ; } assert Equals ( Quorum . NO QUORUM , quorum . token ( ) ) ; assert Equals ( Quorum . NO QUORUM , quorum . last Valid Token ( ) ) ; assert Equals ( new UUID [ ] { } , quorum . get Members ( ) ) ; assert Equals ( new UUID [ ] { } , quorum . get Joined ( ) ) ; assert Equals ( new UUID [ ] { } , quorum . get Pipeline ( ) ) ; assert Equals ( Collections . empty Map ( ) , quorum . get Votes ( ) ) ; try { assert False ( client . is Member ( ) ) ; } catch ( Illegal State Exception ex ) { log . info ( STRING + ex ) ; } quorum . terminate ( ) ; }
public void request After Explanation ( @ Non Null String [ ] permissions ) { Array List < String > permissions To Request = new Array List < > ( ) ; for ( String permission Name : permissions ) { if ( is Permission Declined ( permission Name ) ) { permissions To Request . add ( permission Name ) ; } else { permission Callback . on Permission Pre Granted ( permission Name ) ; } } if ( permissions To Request . is Empty ( ) ) return ; permissions = permissions To Request . to Array ( new String [ permissions To Request . size ( ) ] ) ; Activity Compat . request Permissions ( context , permissions , REQUEST PERMISSIONS ) ; }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { log . warn ( STRING , e ) ; } }
final public void println ( double v ) { try { out . println ( v ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
public int read ( char [ ] cbuf ) throws java . io . IO Exception { return read ( cbuf , NUM , cbuf . length ) ; }
public int read ( char [ ] cbuf , int off , int len ) throws IO Exception { int num = NUM ; int val ; while ( num < len ) { if ( ( val = is . read ( ) ) < NUM ) { return ( num != NUM ) ? num : - NUM ; } switch ( val & NUM ) { case NUM : case NUM : cbuf [ off ++ ] = ( char ) ( ( ( val & NUM ) << NUM ) | ( is . read ( ) & NUM ) ) ; break ; case NUM : cbuf [ off ++ ] = ( char ) ( ( ( val & NUM ) << NUM ) | ( ( is . read ( ) & NUM ) << NUM ) | ( is . read ( ) & NUM ) ) ; break ; case NUM : throw new Unsupported Encoding Exception ( STRING ) ; default : cbuf [ off ++ ] = ( char ) val ; break ; } num ++ ; } return num ; }
private static boolean Call Boolean Method V ( JNI Environment env , int obj JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object obj = env . get JNI Ref ( obj JREF ) ; Object return Obj = JNI Helpers . invoke With Var Arg ( obj , method ID , arg Address , Type Reference . Boolean , BOOL ) ; return Reflection . unwrap Boolean ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return BOOL ; } }
public static Array List < Program Block > rcreate Deep Copy Program Blocks ( Array List < Program Block > child Blocks , long pid , int ID Prefix , Hash Set < String > fn Stack , Hash Set < String > fn Created , boolean plain , boolean force Deep Copy ) throws DML Runtime Exception { Array List < Program Block > tmp = new Array List < Program Block > ( ) ; for ( Program Block pb : child Blocks ) { Program prog = pb . get Program ( ) ; Program Block tmp PB = null ; if ( pb instanceof While Program Block ) { tmp PB = create Deep Copy While Program Block ( ( While Program Block ) pb , pid , ID Prefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else if ( pb instanceof For Program Block && ! ( pb instanceof Par For Program Block ) ) { tmp PB = create Deep Copy For Program Block ( ( For Program Block ) pb , pid , ID Prefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else if ( pb instanceof Par For Program Block ) { Par For Program Block pfpb = ( Par For Program Block ) pb ; if ( Par For Program Block . ALLOW NESTED PARALLELISM ) tmp PB = create Deep Copy Par For Program Block ( pfpb , pid , ID Prefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; else tmp PB = create Deep Copy For Program Block ( ( For Program Block ) pb , pid , ID Prefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else if ( pb instanceof If Program Block ) { tmp PB = create Deep Copy If Program Block ( ( If Program Block ) pb , pid , ID Prefix , prog , fn Stack , fn Created , plain , force Deep Copy ) ; } else { tmp PB = new Program Block ( prog ) ; tmp PB . set Statement Block ( create Statement Block Copy ( pb . get Statement Block ( ) , pid , plain , force Deep Copy ) ) ; tmp PB . set Thread ID ( pid ) ; } tmp PB . set Instructions ( create Deep Copy Instruction Set ( pb . get Instructions ( ) , pid , ID Prefix , prog , fn Stack , fn Created , plain , BOOL ) ) ; tmp . add ( tmp PB ) ; } return tmp ; }
private boolean open For Writing ( ) { File root = new File ( Properties . CTG DIR ) ; if ( root . exists ( ) ) { if ( root . is Directory ( ) ) { if ( ! root . can Write ( ) ) { logger . error ( STRING + root . get Absolute Path ( ) ) ; return BOOL ; } } else { boolean deleted = root . delete ( ) ; if ( ! deleted ) { logger . error ( STRING + root + STRING ) ; return BOOL ; } else { if ( ! root . mkdirs ( ) ) { logger . error ( STRING + root . get Absolute Path ( ) ) ; return BOOL ; } } } } else { if ( ! root . mkdirs ( ) ) { logger . error ( STRING + root . get Absolute Path ( ) ) ; return BOOL ; } } File tests Folder = get Best Test Folder ( ) ; if ( ! tests Folder . exists ( ) ) { if ( ! tests Folder . mkdirs ( ) ) { logger . error ( STRING + tests Folder . get Absolute Path ( ) ) ; return BOOL ; } } File seed Folder = get Seed In Folder ( ) ; if ( ! seed Folder . exists ( ) ) { if ( ! seed Folder . mkdirs ( ) ) { logger . error ( STRING + seed Folder . get Absolute Path ( ) ) ; } } return BOOL ; }
public void test Doubles Round Trip ( ) { byte [ ] encoded = new byte [ Double . BYTES ] ; for ( int i = NUM ; i < NUM ; i ++ ) { double value = Double . long Bits To Double ( Test Util . next Long ( random ( ) , Long . MIN VALUE , Long . MAX VALUE ) ) ; Numeric Utils . long To Sortable Bytes ( Numeric Utils . double To Sortable Long ( value ) , encoded , NUM ) ; double actual = Numeric Utils . sortable Long To Double ( Numeric Utils . sortable Bytes To Long ( encoded , NUM ) ) ; assert Equals ( Double . double To Long Bits ( value ) , Double . double To Long Bits ( actual ) ) ; } }
public static boolean is Cglib Proxy Class ( Class < ? > clazz ) { return ( clazz != null && is Cglib Proxy Class Name ( clazz . get Name ( ) ) ) ; }
private static Pair < String , String > pre Indexed ASR ( final long offset , final I Translation Environment environment , final List < Reil Instruction > instructions , final String register Node Value 1 , final String register Node Value 2 , final String immediate Node Value ) { final String address = environment . get Next Variable String ( ) ; final String index = environment . get Next Variable String ( ) ; final String tmp Var = environment . get Next Variable String ( ) ; long base Offset = offset ; if ( immediate Node Value . equals ( STRING ) ) { final String is Zero Condition = environment . get Next Variable String ( ) ; final String tmp Var 1 = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , dw , register Node Value 2 , wd , String . value Of ( - NUM ) , dw , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create Bisz ( base Offset ++ , dw , tmp Var 1 , bt , is Zero Condition ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , dw , String . value Of ( NUM ) , bt , is Zero Condition , dw , index ) ) ; } else { final String tmp Var 1 = environment . get Next Variable String ( ) ; final String tmp Var 2 = environment . get Next Variable String ( ) ; final String tmp Var 3 = environment . get Next Variable String ( ) ; final String tmp Var 4 = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create Add ( base Offset ++ , dw , register Node Value 2 , dw , String . value Of ( NUM ) , dw , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , dw , tmp Var 1 , dw , STRING + immediate Node Value , dw , tmp Var 2 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , dw , String . value Of ( NUM ) , dw , STRING + immediate Node Value , dw , tmp Var 3 ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , dw , tmp Var 2 , dw , tmp Var 3 , qw , tmp Var 4 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , qw , tmp Var 4 , dw , d Word Bit Mask , dw , index ) ) ; } instructions . add ( Reil Helpers . create Add ( base Offset ++ , dw , register Node Value 1 , dw , index , dw , tmp Var ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , dw , tmp Var , dw , d Word Bit Mask , dw , address ) ) ; instructions . add ( Reil Helpers . create Str ( base Offset ++ , dw , address , dw , register Node Value 1 ) ) ; return new Pair < String , String > ( address , register Node Value 1 ) ; }
public Class < ? > load Class ( String name ) throws Class Not Found Exception { return init Class Loader . load Class ( name ) ; }
private void attach To Root ( ) { Wait For Async Utils . wait For Async Fx ( NUM , null ) ; Wait For Async Utils . wait For Fx Events ( ) ; }
protected boolean is Any Test Component In Target ( Geometry test Geom ) { List coords = Component Coordinate Extracter . get Coordinates ( test Geom ) ; for ( Iterator i = coords . iterator ( ) ; i . has Next ( ) ; ) { Coordinate p = ( Coordinate ) i . next ( ) ; int loc = target Point Locator . locate ( p ) ; if ( loc != Location . EXTERIOR ) return BOOL ; } return BOOL ; }
private Simple Object search Inner ( Request Context context , long snapshot Time ) throws Response Exception { List < Simple Object > results = new Array List < > ( ) ; for ( T item : search Impl ( context , snapshot Time ) ) { results . add ( convert To Json ( item , context , snapshot Time ) ) ; } Simple Object response = new Simple Object ( ) ; response . put ( STRING , results ) ; response . put ( STRING , Utils . to Iso 8601 ( new Date ( snapshot Time ) ) ) ; return response ; }
public static URI determine Final Endpoint ( URI endpoint , String bucket , Client Configuration client Config ) { try { String Builder conbined Endpoint = new String Builder ( ) ; conbined Endpoint . append ( String . format ( STRING , endpoint . get Scheme ( ) ) ) ; conbined Endpoint . append ( build Canonical Host ( endpoint , bucket , client Config ) ) ; conbined Endpoint . append ( endpoint . get Port ( ) != - NUM ? String . format ( STRING , endpoint . get Port ( ) ) : STRING ) ; conbined Endpoint . append ( endpoint . get Path ( ) ) ; return new URI ( conbined Endpoint . to String ( ) ) ; } catch ( URI Syntax Exception ex ) { throw new Illegal Argument Exception ( ex . get Message ( ) , ex ) ; } }
protected Value parse Q Name Or Boolean ( ) throws IO Exception , RDF Parse Exception { int c = read Code Point ( ) ; if ( c == - NUM ) { throw EOF Exception ( ) ; } if ( c != STRING && ! Turtle Util . is Prefix Start Char ( c ) ) { report Error ( STRING + new String ( Character . to Chars ( c ) ) + STRING , Basic Parser Settings . VERIFY RELATIVE URIS ) ; } String namespace = null ; if ( c == STRING ) { namespace = get Namespace ( STRING ) ; } else { String Builder prefix = new String Builder ( NUM ) ; append Codepoint ( prefix , c ) ; int previous Char = c ; c = read Code Point ( ) ; while ( Turtle Util . is Prefix Char ( c ) ) { append Codepoint ( prefix , c ) ; previous Char = c ; c = read Code Point ( ) ; } if ( c != STRING ) { String value = prefix . to String ( ) ; if ( value . equals ( STRING ) || value . equals ( STRING ) ) { unread ( c ) ; return create Literal ( value , null , XML Schema . BOOLEAN , get Line Number ( ) , - NUM ) ; } } else { if ( previous Char == STRING ) { report Fatal Error ( STRING ) ; } } verify Character Or Fail ( c , STRING ) ; namespace = get Namespace ( prefix . to String ( ) ) ; } String Builder local Name = new String Builder ( NUM ) ; c = read Code Point ( ) ; if ( Turtle Util . is Name Start Char ( c ) ) { if ( c == STRING ) { local Name . append ( read Local Escaped Char ( ) ) ; } else { append Codepoint ( local Name , c ) ; } int previous Char = c ; c = read Code Point ( ) ; while ( Turtle Util . is Name Char ( c ) ) { if ( c == STRING ) { local Name . append ( read Local Escaped Char ( ) ) ; } else { append Codepoint ( local Name , c ) ; } previous Char = c ; c = read Code Point ( ) ; } unread ( c ) ; if ( previous Char == STRING ) { unread ( previous Char ) ; local Name . delete Char At ( local Name . length ( ) - NUM ) ; } } else { unread ( c ) ; } String local Name String = local Name . to String ( ) ; for ( int i = NUM ; i < local Name String . length ( ) ; i ++ ) { if ( local Name String . char At ( i ) == STRING ) { if ( i > local Name String . length ( ) - NUM || ! ASCII Util . is Hex ( local Name String . char At ( i + NUM ) ) || ! ASCII Util . is Hex ( local Name String . char At ( i + NUM ) ) ) { report Fatal Error ( STRING + local Name String ) ; } } } return create URI ( namespace + local Name String ) ; }
public Time Series Collection ( Time Series series ) { this ( series , Time Zone . get Default ( ) ) ; }
public static < E > List < E > of ( E e1 , E e2 ) { List < E > list = new Array List < > ( ) ; list . add ( e1 ) ; list . add ( e2 ) ; return list ; }
@ Override public void add Attribute ( String name , double value ) { String str = Double . to String ( value ) ; if ( str . ends With ( STRING ) ) str = str . substring ( NUM , str . length ( ) - NUM ) ; current . set Attribute ( name , str ) ; }
@ Request Mapping ( value = STRING , method = Request Method . GET ) public @ Response Body List < Message > list Messages For Application ( @ Path Variable final String application Name , @ Path Variable final Integer nb Rows ) throws Service Exception , Check Exception { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING ) ; logger . debug ( STRING + application Name ) ; logger . debug ( STRING + nb Rows ) ; } User user = authentification Utils . get Authentificated User ( ) ; String application Name Local = application Name . replace All ( STRING , STRING ) ; return message Service . list By App ( user , application Name Local , nb Rows ) ; }
public void fill area ( Pla Point Float [ ] [ ] p point lists , Graphics p g , Color p color , double p translucency factor ) { if ( p color == null ) return ; General Path draw path = new General Path ( General Path . WIND EVEN ODD ) ; for ( int jndex = NUM ; jndex < p point lists . length ; ++ jndex ) { Polygon draw polygon = new Polygon ( ) ; Pla Point Float [ ] curr point list = p point lists [ jndex ] ; for ( int index = NUM ; index < curr point list . length ; index ++ ) { Point 2 D curr corner = coordinate transform . board to screen ( curr point list [ index ] ) ; draw polygon . add Point ( ( int ) Math . round ( curr corner . get X ( ) ) , ( int ) Math . round ( curr corner . get Y ( ) ) ) ; } draw path . append ( draw polygon , BOOL ) ; } Graphics 2 D g2 = ( Graphics 2 D ) p g ; g2 . set Color ( p color ) ; set translucency ( g2 , p translucency factor ) ; g2 . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g2 . fill ( draw path ) ; }
@ Override public void zoom Domain Axes ( double factor , Plot Rendering Info info , Point 2 D source ) { zoom Domain Axes ( factor , info , source , BOOL ) ; }
@ Override public void on Bind View Holder ( Category View Holder holder , int position ) { int amount Due = NUM ; if ( position == NUM ) { for ( Category category : m Categories ) { amount Due += m Due Challenge Counts . get ( category . get Id ( ) ) ; } holder . bind All Categories Card ( amount Due ) ; } else { final Category category = m Categories . get ( position - NUM ) ; holder . bind Card ( category , m Due Challenge Counts . get ( category . get Id ( ) ) ) ; } }
public Array ( final double [ ] array , final int size ) { this ( array , size , Enum Set . none Of ( Address . Flags . class ) ) ; }
public static Image create Reflected Image ( final Image source ) { if ( source == null ) { return null ; } if ( source . is Disposed ( ) ) { SWT . error ( SWT . ERROR WIDGET DISPOSED ) ; } final Rectangle source Bounds = source . get Bounds ( ) ; final Image new Image = new Image ( source . get Device ( ) , new Rectangle ( NUM , NUM , source Bounds . width , ( int ) ( source Bounds . height * NUM ) ) ) ; final GC gc = new GC ( new Image ) ; gc . set Advanced ( BOOL ) ; gc . draw Image ( source , NUM , NUM ) ; final Transform t = new Transform ( source . get Device ( ) ) ; t . set Elements ( NUM , NUM , NUM , - NUM , NUM , source Bounds . height + source Bounds . height / NUM ) ; gc . set Transform ( t ) ; gc . draw Image ( source , NUM , NUM ) ; t . dispose ( ) ; gc . dispose ( ) ; final Image Data img Data = new Image . get Image Data ( ) ; final int width = img Data . width ; final int height = img Data . height ; final byte [ ] alpha Data = new byte [ height * width ] ; final byte [ ] no Alpha = new byte [ width ] ; for ( int x = NUM ; x < width ; x ++ ) { no Alpha [ x ] = ( byte ) NUM ; } for ( int y = NUM ; y < height ; y ++ ) { final byte [ ] alpha Row = new byte [ width ] ; if ( y < source Bounds . height ) { System . arraycopy ( no Alpha , NUM , alpha Data , y * width , width ) ; } else { for ( int x = NUM ; x < width ; x ++ ) { alpha Row [ x ] = ( byte ) ( NUM - NUM * y / height ) ; } System . arraycopy ( alpha Row , NUM , alpha Data , y * width , width ) ; } } img Data . alpha Data = alpha Data ; new Image . dispose ( ) ; return new Image ( source . get Device ( ) , img Data ) ; }
private Encrypted Properties ( String password ) { PBE Parameter Spec ps = new javax . crypto . spec . PBE Parameter Spec ( salt , NUM ) ; Secret Key Factory kf ; try { kf = Secret Key Factory . get Instance ( STRING ) ; Secret Key k = kf . generate Secret ( new javax . crypto . spec . PBE Key Spec ( password . to Char Array ( ) ) ) ; encrypter = Cipher . get Instance ( STRING ) ; decrypter = Cipher . get Instance ( STRING ) ; encrypter . init ( Cipher . ENCRYPT MODE , k , ps ) ; decrypter . init ( Cipher . DECRYPT MODE , k , ps ) ; } catch ( No Such Algorithm Exception e ) { e . print Stack Trace ( ) ; } catch ( No Such Padding Exception e ) { e . print Stack Trace ( ) ; } catch ( Invalid Key Spec Exception e ) { e . print Stack Trace ( ) ; } catch ( Invalid Key Exception e ) { e . print Stack Trace ( ) ; } catch ( Invalid Algorithm Parameter Exception e ) { e . print Stack Trace ( ) ; } }
public static String escape String ( final String string ) { if ( string . index Of ( DELIMITER COMPONENT ) < NUM ) { final int length = string . length ( ) ; final String Buffer buffer = new String Buffer ( length + NUM ) ; for ( int index = NUM ; index < length ; index ++ ) { final char character = string . char At ( index ) ; if ( DELIMITER COMPONENT == character ) buffer . append ( DELIMITER COMPONENT ) ; buffer . append ( character ) ; } return buffer . to String ( ) ; } return string ; }
public static boolean is File Type Supported ( int file Type , Sequence sequence ) { List providers = get Midi File Writers ( ) ; for ( int i = NUM ; i < providers . size ( ) ; i ++ ) { Midi File Writer writer = ( Midi File Writer ) providers . get ( i ) ; if ( writer . is File Type Supported ( file Type , sequence ) ) { return BOOL ; } } return BOOL ; }
public void create ( SSO Token token , String obj Name , Map attrs ) throws SMS Exception , SSO Exception { if ( obj Name == null || obj Name . length ( ) == NUM || attrs == null ) { throw new Illegal Argument Exception ( STRING + STRING ) ; } String obj Key = obj Name . to Lower Case ( ) ; String filepath = null ; mRW Lock . read Request ( ) ; try { filepath = m Name Map . get Property ( obj Key ) ; if ( filepath != null ) { String errmsg = STRING + obj Name + STRING + filepath ; m Debug . error ( errmsg ) ; throw new Service Already Exists Exception ( errmsg ) ; } } finally { mRW Lock . read Done ( ) ; } mRW Lock . write Request ( ) ; try { filepath = m Name Map . get Property ( obj Key ) ; if ( filepath != null ) { String errmsg = STRING + obj Name + STRING + filepath ; m Debug . error ( errmsg ) ; throw new Service Already Exists Exception ( errmsg ) ; } filepath = get Attr File ( obj Name ) ; File filehandle = new File ( filepath ) ; File parent Dir = filehandle . get Parent File ( ) ; if ( parent Dir . is Directory ( ) ) { String errmsg = STRING + obj Name + STRING + parent Dir . get Path ( ) + STRING ; m Debug . error ( errmsg ) ; throw new Service Already Exists Exception ( errmsg ) ; } Set sunserviceids = null ; Set sunxmlkeyvals = null ; Properties props = new Properties ( ) ; Set keys = attrs . key Set ( ) ; if ( keys != null ) { for ( Iterator i = keys . iterator ( ) ; i . has Next ( ) ; ) { String key = ( String ) i . next ( ) ; Set vals = ( Set ) attrs . get ( key ) ; if ( key . equals Ignore Case ( SMS Entry . ATTR SERVICE ID ) ) { sunserviceids = vals ; } else if ( key . equals Ignore Case ( SMS Entry . ATTR XML KEYVAL ) ) { sunxmlkeyvals = vals ; } props . put ( key , to Val String ( vals ) ) ; } } try { if ( ! parent Dir . mkdirs ( ) ) { String errmsg = STRING + obj Name + STRING + parent Dir . get Path ( ) ; m Debug . error ( errmsg ) ; throw new SMS Exception ( errmsg ) ; } try { if ( ! filehandle . create New File ( ) ) { String errmsg = STRING + obj Name + STRING + filepath ; m Debug . error ( errmsg ) ; throw new SMS Exception ( errmsg ) ; } } catch ( IO Exception e ) { String errmsg = STRING + obj Name + STRING + filehandle . get Path ( ) + STRING + e . get Message ( ) ; m Debug . error ( STRING , e ) ; throw new SMS Exception ( errmsg ) ; } save Properties ( props , filehandle , obj Name ) ; if ( sunserviceids != null && ! sunserviceids . is Empty ( ) ) { create Sun Service Id Files ( parent Dir , sunserviceids ) ; } if ( sunxmlkeyvals != null && ! sunxmlkeyvals . is Empty ( ) ) { create Sun Xml Key Val Files ( parent Dir , sunxmlkeyvals ) ; } m Name Map . set Property ( obj Key , filepath ) ; save Properties ( m Name Map , m Name Map Handle , null ) ; } catch ( SMS Exception e ) { delete Dir ( parent Dir ) ; m Name Map . remove ( obj Key ) ; throw e ; } } finally { mRW Lock . write Done ( ) ; } }
public static int run Open DS Setup ( Map map ) { String [ ] setup Cmd = { STRING , STRING , STRING , STRING , Constants . DEFAULT ROOT SUFFIX , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; setup Cmd [ NUM ] = ( String ) map . get ( Setup Constants . CONFIG VAR DIRECTORY ADMIN SERVER PORT ) ; setup Cmd [ NUM ] = ( String ) map . get ( Setup Constants . CONFIG VAR ROOT SUFFIX ) ; setup Cmd [ NUM ] = ( String ) map . get ( Setup Constants . CONFIG VAR DS MGR DN ) ; setup Cmd [ NUM ] = ( String ) map . get ( Setup Constants . CONFIG VAR DIRECTORY SERVER PORT ) ; setup Cmd [ NUM ] = ( String ) map . get ( Setup Constants . CONFIG VAR DIRECTORY JMX SERVER PORT ) ; setup Cmd [ NUM ] = get Open DJ Host Name ( map ) ; setup Cmd [ NUM ] = System Properties . get ( Setup Constants . DJ BACKEND TYPE CONFIG NAME , Setup Constants . DJ BACKEND TYPE DEFAULT ) ; Object [ ] params = { concat ( setup Cmd ) } ; Setup Progress . report Start ( STRING , params ) ; setup Cmd [ NUM ] = ( String ) map . get ( Setup Constants . CONFIG VAR DS MGR PWD ) ; int ret = Install DS . main CLI ( setup Cmd , Setup Progress . get Output Stream ( ) , Setup Progress . get Output Stream ( ) , Temp Log File . new Temp Log File ( STRING ) ) ; if ( ret == NUM ) { Setup Progress . report End ( STRING , null ) ; } else { Setup Progress . report End ( STRING , null ) ; } return ret ; }
private void update Arc View Positions ( ) { float half Width = get Width ( ) / NUM ; double radius = get Width ( ) * NUM ; double pow Radius = radius * radius ; double rotation ; float half View Width ; double delta X ; double delta Y ; int view Position ; for ( int count = get Child Count ( ) , i = NUM ; i < count ; i ++ ) { View view = get Child At ( i ) ; rotation = NUM ; half View Width = view . get Width ( ) / NUM ; view . set Pivot X ( half View Width ) ; view . set Pivot Y ( view . get Height ( ) ) ; if ( settings . is Fan Radius Enable ( ) ) { delta X = half Width - get Decorated Left ( view ) - half View Width ; delta Y = radius - Math . sqrt ( pow Radius - delta X * delta X ) ; view . set Translation Y ( ( float ) delta Y ) ; rotation = ( Math . to Degrees ( Math . asin ( ( radius - delta Y ) / radius ) ) - NUM ) * Math . signum ( delta X ) ; } view Position = get Position ( view ) ; Double base View Rotation = view Rotations Map . get ( view Position ) ; if ( base View Rotation == null ) { base View Rotation = random . next Double ( ) * settings . get Angle Item Bounce ( ) * NUM - settings . get Angle Item Bounce ( ) ; view Rotations Map . put ( view Position , base View Rotation ) ; } view . set Rotation ( ( float ) ( rotation + base View Rotation ) ) ; } }
@ Not Null public static String normalize ( @ Not Null String path ) { int start = NUM ; boolean separator = BOOL ; if ( System Info . is Windows ) { if ( path . starts With ( STRING ) ) { start = NUM ; separator = BOOL ; } else if ( path . starts With ( STRING ) ) { return normalize Tail ( NUM , path , BOOL ) ; } } for ( int i = start ; i < path . length ( ) ; ++ i ) { final char c = path . char At ( i ) ; if ( c == STRING ) { if ( separator ) { return normalize Tail ( i , path , BOOL ) ; } separator = BOOL ; } else if ( c == STRING ) { return normalize Tail ( i , path , separator ) ; } else { separator = BOOL ; } } return path ; }
private boolean is Inter Org ( M Acct Schema as ) { M Acct Schema Element elementorg = as . get Acct Schema Element ( M Acct Schema Element . ELEMENTTYPE Organization ) ; if ( elementorg == null || ! elementorg . is Balanced ( ) ) { return BOOL ; } if ( m io Line != null && m o Line != null && m io Line . get AD Org ID ( ) != m o Line . get AD Org ID ( ) ) return BOOL ; return BOOL ; }
private boolean parse Attribute ( Attributes Impl attrs ) throws Jasper Exception { String q Name = parse Name ( ) ; if ( q Name == null ) return BOOL ; String local Name = q Name ; String uri = STRING ; int index = q Name . index Of ( STRING ) ; if ( index != - NUM ) { String prefix = q Name . substring ( NUM , index ) ; uri = page Info . get URI ( prefix ) ; if ( uri == null ) { err . jsp Error ( reader . mark ( ) , STRING , prefix ) ; } local Name = q Name . substring ( index + NUM ) ; } reader . skip Spaces ( ) ; if ( ! reader . matches ( STRING ) ) err . jsp Error ( reader . mark ( ) , STRING ) ; reader . skip Spaces ( ) ; char quote = ( char ) reader . next Char ( ) ; if ( quote != STRING && quote != STRING ) err . jsp Error ( reader . mark ( ) , STRING ) ; String watch String = STRING ; if ( reader . matches ( STRING ) ) watch String = STRING ; watch String = watch String + quote ; String attr Value = parse Attribute Value ( watch String ) ; attrs . add Attribute ( uri , local Name , q Name , STRING , attr Value ) ; return BOOL ; }
public static byte [ ] load Binary File As Bytes ( final String file ) throws IO Exception { final File Input Stream input Stream = new File Input Stream ( file ) ; final byte [ ] data = new byte [ input Stream . available ( ) ] ; input Stream . read ( data ) ; input Stream . close ( ) ; return data ; }
@ Suppress Warnings ( STRING ) public void test stream API 2 ( ) { final List < I Binding Set > expected Solutions = new Array List < I Binding Set > ( ) ; { final I Binding Set expected = new List Binding Set ( ) ; expected . set ( Var . var ( STRING ) , new Constant < IV > ( term Id ) ) ; expected Solutions . add ( expected ) ; } { final I Binding Set expected = new List Binding Set ( ) ; expected Solutions . add ( expected ) ; } { final I Binding Set expected = new List Binding Set ( ) ; expected . set ( Var . var ( STRING ) , new Constant < IV > ( term Id ) ) ; expected . set ( Var . var ( STRING ) , new Constant < IV > ( blob IV ) ) ; expected Solutions . add ( expected ) ; } do Encode Decode Test ( expected Solutions ) ; }
@ Override public String to String ( ) { String Buffer buffer = new String Buffer ( ) ; if ( terms . size ( ) > NUM ) { buffer . append ( STRING ) ; boolean first Term = BOOL ; for ( Split Condition condition : terms ) { if ( ! first Term ) { buffer . append ( STRING ) ; } buffer . append ( condition . to String ( ) ) ; first Term = BOOL ; } buffer . append ( STRING ) ; } else { buffer . append ( STRING ) ; } buffer . append ( label Name ) ; if ( frequencies != null ) { buffer . append ( STRING ) ; for ( int i = NUM ; i < frequencies . length ; i ++ ) { if ( i != NUM ) { buffer . append ( STRING ) ; } buffer . append ( frequencies [ i ] ) ; } buffer . append ( STRING ) ; } return buffer . to String ( ) ; }
public void insert Index Interval ( int index , int length , boolean before ) { int ins Min Index = ( before ) ? index : index + NUM ; int ins Max Index = ( ins Min Index + length ) - NUM ; for ( int i = max Index ; i >= ins Min Index ; i -- ) { set State ( i + length , value . get ( i ) ) ; } boolean set Inserted Values = ( ( get Selection Mode ( ) == SINGLE SELECTION ) ? BOOL : value . get ( index ) ) ; for ( int i = ins Min Index ; i <= ins Max Index ; i ++ ) { set State ( i , set Inserted Values ) ; } int lead Index = this . lead Index ; if ( lead Index > index || ( before && lead Index == index ) ) { lead Index = this . lead Index + length ; } int anchor Index = this . anchor Index ; if ( anchor Index > index || ( before && anchor Index == index ) ) { anchor Index = this . anchor Index + length ; } if ( lead Index != this . lead Index || anchor Index != this . anchor Index ) { update Lead Anchor Indices ( anchor Index , lead Index ) ; } fire Value Changed ( ) ; }
public Repl DBMS Event filter ( Repl DBMS Event event ) throws Replicator Exception , Interrupted Exception { total Events ++ ; Timestamp source Tstamp = event . get Extracted Tstamp ( ) ; long current Time = System . current Time Millis ( ) ; prefetch Latency = current Time - source Tstamp . get Time ( ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + event . get Seqno ( ) + STRING + prefetch Latency ) ; } if ( last Checked == NUM || ( current Time - last Checked >= interval ) ) { get Current Slave Header ( ) ; } if ( allow All ) { prefetch Events ++ ; return event ; } if ( event . get Seqno ( ) <= slave Seqno ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + event . get Seqno ( ) + STRING + slave Seqno ) ; } return null ; } if ( ( slave Latency - prefetch Latency ) < ahead Min Millis ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + event . get Seqno ( ) + STRING + prefetch Latency + STRING + slave Latency ) ; } return null ; } long ahead Millis = NUM ; long original Slave Latency = slave Latency ; while ( ( ahead Millis = original Slave Latency - prefetch Latency ) > ahead Max Millis ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + ahead Millis ) ; long sleep Start Millis = System . current Time Millis ( ) ; try { prefetch State = Prefetch State . sleeping ; Thread . sleep ( sleep Time ) ; } finally { prefetch State = Prefetch State . active ; sleep Time Millis += ( System . current Time Millis ( ) - sleep Start Millis ) ; } current Time = System . current Time Millis ( ) ; prefetch Latency = current Time - source Tstamp . get Time ( ) ; get Current Slave Header ( ) ; if ( event . get Seqno ( ) <= slave Seqno ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + event . get Seqno ( ) + STRING + slave Seqno ) ; } return null ; } } prefetch Events ++ ; if ( logger . is Debug Enabled ( ) && total Events % NUM == NUM ) logger . debug ( STRING + prefetch Events + STRING + ( NUM * prefetch Events / total Events ) + STRING ) ; return event ; }
public Prompting Trust Manager ( final Console Application app , final String accepted Store Path , final X509 Trust Manager source Trust Manager ) throws Key Store Exception , IO Exception , No Such Algorithm Exception , Certificate Exception { Reject . if Null ( app , accepted Store Path ) ; this . app = app ; this . nested Trust Manager = source Trust Manager ; in Memory Trust Store = Key Store . get Instance ( Key Store . get Default Type ( ) ) ; on Disk Trust Store = Key Store . get Instance ( Key Store . get Default Type ( ) ) ; final File on Disk Trust Store Path = new File ( accepted Store Path ) ; in Memory Trust Store . load ( null , null ) ; if ( ! on Disk Trust Store Path . exists ( ) ) { on Disk Trust Store . load ( null , null ) ; } else { try ( final File Input Stream fos = new File Input Stream ( on Disk Trust Store Path ) ) { on Disk Trust Store . load ( fos , DEFAULT PASSWORD ) ; } } final Trust Manager Factory tmf = Trust Manager Factory . get Instance ( Trust Manager Factory . get Default Algorithm ( ) ) ; tmf . init ( in Memory Trust Store ) ; X509 Trust Manager x509 tm = null ; for ( final Trust Manager tm : tmf . get Trust Managers ( ) ) { if ( tm instanceof X509 Trust Manager ) { x509 tm = ( X509 Trust Manager ) tm ; break ; } } if ( x509 tm == null ) { throw new No Such Algorithm Exception ( ) ; } this . in Memory Trust Manager = x509 tm ; tmf . init ( on Disk Trust Store ) ; x509 tm = null ; for ( final Trust Manager tm : tmf . get Trust Managers ( ) ) { if ( tm instanceof X509 Trust Manager ) { x509 tm = ( X509 Trust Manager ) tm ; break ; } } if ( x509 tm == null ) { throw new No Such Algorithm Exception ( ) ; } this . on Disk Trust Manager = x509 tm ; }
public void recursive Delete ( File file Or Directory ) { if ( file Or Directory . is Directory ( ) ) for ( File child : file Or Directory . list Files ( ) ) recursive Delete ( child ) ; try { file Or Directory . delete ( ) ; } catch ( Exception e ) { e . get Stack Trace ( ) ; } }
public int file Write ( long handle , byte [ ] buffer , int offset , int count ) { if ( ( offset | count ) < NUM || offset > buffer . length || buffer . length - offset < count ) { throw new Array Index Out Of Bounds Exception ( STRING + buffer . length + STRING + offset + STRING + count ) ; } if ( count == NUM ) { return NUM ; } byte [ ] data = buffer ; if ( offset > NUM ) { data = new byte [ count ] ; System . arraycopy ( buffer , offset , data , NUM , count ) ; } Int Out bytes Written Out = new Int Out ( ) ; try { check Result ( Lib I Mobile Device . afc file write ( get Ref ( ) , handle , data , count , bytes Written Out ) ) ; int bytes Written = bytes Written Out . get Value ( ) ; return bytes Written ; } finally { bytes Written Out . delete ( ) ; } }
private void handle Local Associated Other ( ) { for ( Array List < Register Spec > specs : local Variables . values ( ) ) { int rop Reg = param Range End ; boolean done = BOOL ; do { int max Category = NUM ; int sz = specs . size ( ) ; for ( int i = NUM ; i < sz ; i ++ ) { Register Spec ssa Spec = specs . get ( i ) ; int category = ssa Spec . get Category ( ) ; if ( ! ssa Regs Mapped . get ( ssa Spec . get Reg ( ) ) && category > max Category ) { max Category = category ; } } rop Reg = find Rop Reg For Local ( rop Reg , max Category ) ; if ( can Map Regs ( specs , rop Reg ) ) { done = try Map Regs ( specs , rop Reg , max Category , BOOL ) ; } rop Reg ++ ; } while ( ! done ) ; } }
public static void register ( Resource Resolver Spi resource Resolver Spi , boolean start ) { Java Utils . check Register Permission ( ) ; synchronized ( resolver List ) { if ( start ) { resolver List . add ( NUM , new Resource Resolver ( resource Resolver Spi ) ) ; } else { resolver List . add ( new Resource Resolver ( resource Resolver Spi ) ) ; } } if ( log . is Loggable ( java . util . logging . Level . FINE ) ) { log . log ( java . util . logging . Level . FINE , STRING + resource Resolver Spi . to String ( ) ) ; } }
private boolean process Authentication Response ( final Http Method method ) { LOG . trace ( STRING + STRING ) ; try { switch ( method . get Status Code ( ) ) { case Http Status . SC UNAUTHORIZED : return process WWW Auth Challenge ( method ) ; case Http Status . SC PROXY AUTHENTICATION REQUIRED : return process Proxy Auth Challenge ( method ) ; default : return BOOL ; } } catch ( final Exception e ) { if ( LOG . is Error Enabled ( ) ) { LOG . error ( e . get Message ( ) , e ) ; } return BOOL ; } }
public boolean equal Byte Arrays ( byte [ ] buf 1 , byte [ ] buf 2 ) throws IO Exception { Byte Array Input Stream b1 = new Byte Array Input Stream ( buf 1 ) ; Byte Array Input Stream b2 = new Byte Array Input Stream ( buf 2 ) ; for ( int i = NUM ; i < b1 . available ( ) ; ) { int byte 1 = b1 . read ( ) ; int byte 2 = b2 . read ( ) ; if ( byte 1 != byte 2 ) { b1 . close ( ) ; b2 . close ( ) ; return BOOL ; } } b1 . close ( ) ; b2 . close ( ) ; return BOOL ; }
public void run Injector Pipeline ( Pipeline injector Pipeline ) { Pipeline Result result = injector Pipeline . run ( ) ; if ( result instanceof Dataflow Pipeline Job ) { jobs To Cancel . add ( ( ( Dataflow Pipeline Job ) result ) ) ; } }

public void generate Search Page ( List < Api Service > services ) { List < Api Method > all Methods = new Array List < Api Method > ( ) ; for ( Api Service service : services ) { all Methods . add All ( service . methods ) ; } int key = NUM ; for ( Api Method method : all Methods ) { method . index Key = STRING + key ++ ; } Map < String , Object > parameters = new Hash Map < String , Object > ( ) ; parameters . put ( STRING , all Methods ) ; parameters . put ( STRING , STRING ) ; add Common Template Parameters ( parameters ) ; Template Engine . generate File From Template ( Known Paths . get Template File ( SEARCH TEMPLATE ) , Known Paths . get Html Output File ( SEARCH TEMPLATE ) , parameters ) ; }
protected void deactivate Window ( Execution Window window ) { lock . lock ( ) ; try { if ( active Windows . contains Key ( window . get Id ( ) ) ) { LOG . info ( STRING + window . get Label ( ) ) ; active Windows . remove ( window . get Id ( ) ) ; } } finally { lock . unlock ( ) ; } }
private void copy To Buffer ( Buffer b Dest ) { if ( reassembled Data Full Size <= MAX H264 FRAME SIZE ) { byte [ ] final Data = new byte [ reassembled Data Full Size + NUM ] ; int final Data Pos = NUM ; final Data [ final Data Pos ] = reassembled Data NAL Header ; final Data Pos += NUM ; int pos Current = reassembled Data Pos Seq Start ; int pos Seq = NUM ; while ( ( pos Current & VIDEO DECODER MAX PAYLOADS CHUNKS MASK ) != reassembled Data Pos Seq End ) { pos Seq = pos Current & VIDEO DECODER MAX PAYLOADS CHUNKS MASK ; System . arraycopy ( reassembled Data [ pos Seq ] , NUM , final Data , final Data Pos , reassembled Data Size [ pos Seq ] ) ; final Data Pos += reassembled Data Size [ pos Seq ] ; pos Current ++ ; } System . arraycopy ( reassembled Data [ reassembled Data Pos Seq End ] , NUM , final Data , final Data Pos , reassembled Data Size [ reassembled Data Pos Seq End ] ) ; b Dest . set Data ( final Data ) ; b Dest . set Length ( reassembled Data Size [ reassembled Data Pos Seq End ] ) ; b Dest . set Offset ( NUM ) ; b Dest . set Timestamp ( timestamp ) ; b Dest . set Format ( format ) ; b Dest . set Flags ( Buffer . FLAG RTP MARKER | Buffer . FLAG RTP TIME ) ; b Dest . set Video Orientation ( video Orientation ) ; b Dest . set Sequence Number ( seq Number ) ; } reassembled Data = null ; }
public static final void write Int Array Xml ( int [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . to String ( N ) ) ; for ( int i = NUM ; i < N ; i ++ ) { out . start Tag ( null , STRING ) ; out . attribute ( null , STRING , Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , STRING ) ; } out . end Tag ( null , STRING ) ; }
private void unify Username By Email ( Map < String , List < Log Commit Info > > username Map ) { for ( Entry < String , List < Log Commit Info > > entry : username Map . entry Set ( ) ) { List < String > names = get Names List ( entry . get Value ( ) ) ; String new User Name = names . get ( NUM ) ; if ( names . size ( ) > NUM ) new User Name = get New Name ( names ) ; for ( Log Commit Info commit : entry . get Value ( ) ) { commit . set User Name ( new User Name ) ; } } }
public static boolean has Column ( final C Connection connection , final String table Name , final String column Name ) { Preconditions . check Not Null ( column Name , STRING ) ; Preconditions . check Not Null ( table Name , STRING ) ; Preconditions . check Not Null ( connection , STRING ) ; final String query = String . format ( STRING + STRING , table Name , column Name ) ; try ( Result Set result = connection . execute Query ( query , BOOL ) ) { return result . first ( ) ; } catch ( final SQL Exception e ) { return BOOL ; } }
public ELF Formatter ( ) { String timestamp Generator Class = lmanager . get Property ( Log Constants . SECURE TIMESTAMP GENERATOR ) ; try { Class clz = Class . for Name ( timestamp Generator Class ) ; secure Timestamp Generator = ( I Timestamp Generator ) clz . new Instance ( ) ; } catch ( Class Not Found Exception cnfe ) { Debug . error ( STRING + STRING , cnfe ) ; } catch ( Instantiation Exception ie ) { Debug . error ( STRING + STRING , ie ) ; } catch ( Illegal Access Exception iae ) { Debug . error ( STRING + STRING , iae ) ; } }
public static String read All ( final URL url ) throws IO Exception { try ( Input Stream input = url . open Stream ( ) ) { return read All ( input ) ; } }
public static Data Network init Network ( ) { Random random = new Random ( System . current Time Millis ( ) ) ; int id = random . next Int ( ) ; while ( used Ids . contains ( id ) ) { id = random . next Int ( ) ; } ; Data Network net = new Data Network ( ) ; used Ids . add ( id ) ; net . network ID = id ; return net ; }
static public String format Bytes ( long bytes ) { double val = NUM ; String units = STRING ; if ( bytes < NUM ) { val = bytes ; units = STRING ; } else if ( bytes < NUM ) { val = ( bytes / NUM ) ; units = STRING ; } else if ( bytes < NUM ) { val = ( bytes / NUM ) ; units = STRING ; } else { val = ( bytes / NUM ) ; units = STRING ; } Decimal Format df = new Decimal Format ( STRING ) ; return df . format ( val ) + STRING + units ; }
public static boolean check Alarm Service ( Context context , Pending Intent service Pending Intent ) { final Intent i = new Intent ( context , Github Widget Service . class ) ; return Pending Intent . get Service ( context , NUM , i , Pending Intent . FLAG NO CREATE ) != null ; }
public void test Divide Exception Invalid RM ( ) { String a = STRING ; int a Scale = NUM ; String b = STRING ; int b Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal b Number = new Big Decimal ( new Big Integer ( b ) , b Scale ) ; try { a Number . divide ( b Number , NUM ) ; fail ( STRING ) ; } catch ( Illegal Argument Exception e ) { assert Equals ( STRING , STRING , e . get Message ( ) ) ; } }
public void delete By App Id ( Long app Id ) { List < Config > configs = config Dao . list By App Id ( app Id , NUM , NUM ) ; if ( configs != null && ! configs . is Empty ( ) ) { for ( Config config : configs ) { delete ( config ) ; } } }
private Map < String , String > check IP Version ( String range ) { Map < String , String > details = new Hash Map < String , String > ( NUM ) ; String Tokenizer st ; String ip Start , ip End ; if ( range . contains ( STRING ) ) { debug . message ( STRING ) ; st = new String Tokenizer ( range , STRING ) ; if ( st . count Tokens ( ) != NUM ) { throw new Illegal Argument Exception ( range + STRING ) ; } ip Start = st . next Token ( ) ; ip End = st . next Token ( ) ; if ( Validate I Paddress . is I Pv 4 ( ip Start ) && Validate I Paddress . is I Pv 4 ( ip End ) ) { details . put ( IP Version , IP V4 ) ; details . put ( IP TYPE , STRING ) ; } else if ( Validate I Paddress . is I Pv 6 ( ip Start ) && Validate I Paddress . is I Pv 6 ( ip End ) ) { details . put ( IP Version , IP V6 ) ; details . put ( IP TYPE , STRING ) ; details . put ( IP START , ip Start ) ; details . put ( IP END , ip End ) ; } else { throw new Illegal Argument Exception ( range + STRING ) ; } } else if ( range . contains ( STRING ) ) { debug . message ( STRING ) ; String cidr ; st = new String Tokenizer ( range , STRING ) ; if ( st . count Tokens ( ) != NUM ) { throw new Illegal Argument Exception ( STRING ) ; } ip Start = st . next Token ( ) ; cidr = st . next Token ( ) ; if ( Validate I Paddress . is I Pv 4 ( ip Start ) && ( Integer . parse Int ( cidr ) >= NUM ) && ( Integer . parse Int ( cidr ) <= NUM ) ) { details . put ( IP Version , IP V4 ) ; details . put ( IP TYPE , STRING ) ; } else if ( Validate I Paddress . is I Pv 6 ( ip Start ) && ( Integer . parse Int ( cidr ) >= NUM ) && ( Integer . parse Int ( cidr ) <= NUM ) ) { details . put ( IP Version , IP V6 ) ; details . put ( IP TYPE , STRING ) ; } else { throw new Illegal Argument Exception ( ip Start + STRING ) ; } } else { debug . message ( STRING ) ; if ( Validate I Paddress . is I Pv 4 ( range ) ) { details . put ( IP Version , IP V4 ) ; details . put ( IP TYPE , STRING ) ; } else if ( Validate I Paddress . is I Pv 6 ( range ) ) { details . put ( IP Version , IP V6 ) ; details . put ( IP TYPE , STRING ) ; } else { throw new Illegal Argument Exception ( range + STRING ) ; } } return details ; }
private View move Selection ( int delta , int children Left , int children Right ) { if ( DEBUG ) Log . i ( TAG , STRING + delta + STRING + children Left + CHILDREN RIGHT + children Right + M FIRST POSITION + m First Position ) ; final int fading Edge Length = get Horizontal Fading Edge Length ( ) ; final int selected Position = m Selected Position ; final int num Rows = m Num Rows ; final int horizontal Spacing = m Horizontal Spacing ; int old Column Start ; int column Start ; int column End = - NUM ; if ( ! m Stack From Bottom ) { old Column Start = ( selected Position - delta ) - ( ( selected Position - delta ) % num Rows ) ; column Start = selected Position - ( selected Position % num Rows ) ; } else { int inverted Selection = m Item Count - NUM - selected Position ; column End = m Item Count - NUM - ( inverted Selection - ( inverted Selection % num Rows ) ) ; column Start = Math . max ( NUM , column End - num Rows + NUM ) ; inverted Selection = m Item Count - NUM - ( selected Position - delta ) ; old Column Start = m Item Count - NUM - ( inverted Selection - ( inverted Selection % num Rows ) ) ; old Column Start = Math . max ( NUM , old Column Start - num Rows + NUM ) ; } final int row Delta = column Start - old Column Start ; final int left Selection Pixel = get Left Selection Pixel ( children Left , fading Edge Length , column Start ) ; final int right Selection Pixel = get Right Selection Pixel ( children Right , fading Edge Length , num Rows , column Start ) ; m First Position = column Start ; View sel ; View reference View ; if ( row Delta > NUM ) { final int old Right = m Reference View In Selected Row == null ? NUM : m Reference View In Selected Row . get Right ( ) ; sel = make Column ( m Stack From Bottom ? column End : column Start , old Right + horizontal Spacing , BOOL ) ; reference View = m Reference View ; adjust For Right Fading Edge ( reference View , left Selection Pixel , right Selection Pixel ) ; } else if ( row Delta < NUM ) { final int old Top = m Reference View In Selected Row == null ? NUM : m Reference View In Selected Row . get Left ( ) ; sel = make Column ( m Stack From Bottom ? column End : column Start , old Top - horizontal Spacing , BOOL ) ; reference View = m Reference View ; adjust For Left Fading Edge ( reference View , left Selection Pixel , right Selection Pixel ) ; } else { final int old Top = m Reference View In Selected Row == null ? NUM : m Reference View In Selected Row . get Left ( ) ; sel = make Column ( m Stack From Bottom ? column End : column Start , old Top , BOOL ) ; reference View = m Reference View ; } if ( ! m Stack From Bottom ) { fill Left ( column Start - num Rows , reference View . get Left ( ) - horizontal Spacing ) ; adjust Views Left Or Right ( ) ; fill Right ( column Start + num Rows , reference View . get Right ( ) + horizontal Spacing ) ; } else { fill Right ( column Start + num Rows , reference View . get Right ( ) + horizontal Spacing ) ; adjust Views Left Or Right ( ) ; fill Left ( column Start - NUM , reference View . get Left ( ) - horizontal Spacing ) ; } return sel ; }
@ Override public Shape Tile Simplex intersection ( Shape Tile Simplex p other ) { if ( is empty ( ) || p other . is empty ( ) ) return EMPTY ; Array List < Pla Line Int > new arr = new Array List < Pla Line Int > ( lines size ( ) + p other . lines size ( ) ) ; new arr . add All ( lines list ) ; new arr . add All ( p other . lines list ) ; Shape Tile Simplex result = new Shape Tile Simplex ( new arr ) ; return result . remove redundant lines ( ) ; }
public static void change UID ( long old UID , long new UID , String from File , String to File ) throws Exception { String input File ; String temp File ; File file ; String content ; String line ; Buffered Reader reader ; Buffered Writer writer ; if ( ! is KOML ( from File ) ) { input File = from File + STRING ; binary To KOML ( from File , input File ) ; } else { input File = from File ; } reader = new Buffered Reader ( new File Reader ( input File ) ) ; content = STRING ; while ( ( line = reader . read Line ( ) ) != null ) { if ( ! content . equals ( STRING ) ) content += STRING ; content += line ; } reader . close ( ) ; content = content . replace All ( STRING + Long . to String ( old UID ) + STRING , STRING + Long . to String ( new UID ) + STRING ) ; temp File = input File + STRING ; writer = new Buffered Writer ( new File Writer ( temp File ) ) ; writer . write ( content ) ; writer . flush ( ) ; writer . close ( ) ; if ( ! is KOML ( to File ) ) { koml To Binary ( temp File , to File ) ; } else { writer = new Buffered Writer ( new File Writer ( to File ) ) ; writer . write ( content ) ; writer . flush ( ) ; writer . close ( ) ; } file = new File ( temp File ) ; file . delete ( ) ; }
public static double create Double Setting ( final Map < String , String > raw Settings , final String setting Name , final double default Value ) { final String setting String = raw Settings . get ( setting Name ) ; if ( setting String == null ) { return default Value ; } else { try { return Double . parse Double ( setting String ) ; } catch ( final Number Format Exception exception ) { C Utility Functions . log Exception ( exception ) ; return default Value ; } } }
private Item lookup Do ( Template tmpl ) { if ( is Empty ( tmpl . service Types ) || tmpl . service ID != null ) { Item Iter iter = matching Items ( tmpl ) ; if ( iter . has Next ( ) ) return iter . next ( ) ; return null ; } List services = matching Services ( tmpl . service Types ) ; long now = System Time . time Millis ( ) ; int slen = services . size ( ) ; if ( slen == NUM ) return null ; int srand = random . next Int ( Integer . MAX VALUE ) % slen ; for ( int i = NUM ; i < slen ; i ++ ) { Svc Reg reg = ( Svc Reg ) services . get ( ( i + srand ) % slen ) ; if ( reg . lease Expiration > now && match Attributes ( tmpl , reg . item ) ) return reg . item ; } return null ; }
@ Override public boolean run After ( List tasks , int size ) { for ( int i = NUM ; i < size ; i ++ ) { Cache Task t = ( Cache Task ) tasks . get ( i ) ; if ( t instanceof Register Listener Task || t instanceof Lookup Task || t instanceof Notify Event Task ) { Proxy Reg other Reg = t . get Proxy Reg ( ) ; if ( reg . equals ( other Reg ) ) { if ( this Task Seq N > t . get Seq N ( ) ) return BOOL ; } } } return super . run After ( tasks , size ) ; }
private void create Index ( String index Name , boolean unique , boolean scalar Required , boolean lax , Json Path [ ] columns , String language ) throws Oracle Exception { Prepared Statement stmt = null ; if ( index Name == null ) throw SODA Utils . make Exception ( SODA Message . EX ARG CANNOT BE NULL , STRING ) ; index Name = Collection Descriptor . string To Identifier ( index Name ) ; String sqltext = null ; if ( columns == null || columns . length == NUM ) { if ( ( options . content Data Type == Collection Descriptor . NCHAR CONTENT ) || ( options . content Data Type == Collection Descriptor . NCLOB CONTENT ) ) { throw SODA Utils . make Exception ( SODA Message . EX UNSUPPORTED INDEX CREATE , options . get Content Data Type ( ) ) ; } else if ( options . content Lob Encrypt != Collection Descriptor . LOB ENCRYPT NONE ) { throw SODA Utils . make Exception ( SODA Message . EX UNSUPPORTED ENCRYPTED INDEX CREATE ) ; } else if ( options . key Data Type == Collection Descriptor . NCHAR KEY ) { throw SODA Utils . make Exception ( SODA Message . EX UNSUPPORTED INDEX CREATE 2 ) ; } sqltext = build CTX Index DDL ( index Name , language ) ; } else { sqltext = build Index DDL ( index Name , unique , scalar Required , lax , columns ) ; } try { metrics . start Timing ( ) ; if ( Oracle Log . is Logging Enabled ( ) ) log . info ( STRING + sqltext ) ; stmt = conn . prepare Statement ( sqltext ) ; stmt . execute ( ) ; if ( Oracle Log . is Logging Enabled ( ) ) log . info ( STRING + index Name ) ; stmt . close ( ) ; stmt = null ; metrics . record DDL ( ) ; } catch ( SQL Exception e ) { if ( e . get Error Code ( ) == ORA SQL OBJECT EXISTS ) { if ( Oracle Log . is Logging Enabled ( ) ) log . warning ( e . to String ( ) ) ; } else { if ( Oracle Log . is Logging Enabled ( ) ) log . warning ( e . to String ( ) ) ; throw SODA Utils . make Exception With SQL Text ( e , sqltext ) ; } } finally { for ( String message : SODA Utils . close Cursor ( stmt , null ) ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( message ) ; } } }
public double p Norm ( double p ) { if ( p <= NUM ) throw new Illegal Argument Exception ( STRING + p ) ; double result = NUM ; if ( p == NUM ) { for ( Index Value iv : this ) result += abs ( iv . get Value ( ) ) ; } else if ( p == NUM ) { for ( Index Value iv : this ) result += iv . get Value ( ) * iv . get Value ( ) ; result = Math . sqrt ( result ) ; } else if ( Double . is Infinite ( p ) ) { for ( Index Value iv : this ) result = Math . max ( result , abs ( iv . get Value ( ) ) ) ; } else { for ( Index Value iv : this ) result += pow ( abs ( iv . get Value ( ) ) , p ) ; result = pow ( result , NUM / p ) ; } return result ; }
public static File create Testing File ( Path relative Path ) { Path path = relative Path . to Absolute Path ( ) ; if ( ! in Target Dir ( path ) ) { throw new Illegal State Exception ( STRING + relative Path + STRING ) ; } return Io Util . create File ( path ) ; }
public static String remove Cross Reference ( String text ) { if ( Strings . is Null Or Empty ( text ) ) { return STRING ; } Pattern pattern = Pattern . compile ( STRING + STRING ) ; Matcher matcher = pattern . matcher ( text ) ; String Buffer result = new String Buffer ( ) ; while ( matcher . find ( ) ) { String replacement Text = matcher . group ( STRING ) ; replacement Text = Matcher . quote Replacement ( replacement Text ) ; matcher . append Replacement ( result , replacement Text ) ; } matcher . append Tail ( result ) ; return result . to String ( ) ; }
private String create Sized String ( final String message , final int pixels ) { Font Metrics fm = get Font Metrics ( get Font ( ) ) ; String word ; String Tokenizer st = new String Tokenizer ( message ) ; int new Width = pixels ; while ( st . has More Tokens ( ) ) { word = st . next Token ( ) ; new Width = Math . max ( new Width , fm . string Width ( word ) ) ; } String Builder sb = new String Builder ( ) ; String Builder cursb = new String Builder ( ) ; boolean is New Line ; st = new String Tokenizer ( message , STRING , BOOL ) ; while ( st . has More Tokens ( ) ) { word = st . next Token ( ) ; if ( word . equals ( STRING ) ) continue ; is New Line = word . equals ( STRING ) ; if ( is New Line || fm . string Width ( cursb . to String ( ) + word ) > new Width ) { sb . append ( cursb . to String ( ) ) ; sb . append ( STRING ) ; cursb = new String Builder ( ) ; } if ( ! is New Line ) { cursb . append ( word ) ; cursb . append ( STRING ) ; } } sb . append ( cursb . to String ( ) ) ; return sb . to String ( ) ; }
protected boolean update Attachment Point ( ) { boolean moved = BOOL ; this . old A Ps = attachment Points ; if ( attachment Points == null || attachment Points . is Empty ( ) ) return BOOL ; List < Attachment Point > ap List = new Array List < Attachment Point > ( ) ; if ( attachment Points != null ) ap List . add All ( attachment Points ) ; Map < Datapath Id , Attachment Point > new Map = get AP Map ( ap List ) ; if ( new Map == null || new Map . size ( ) != ap List . size ( ) ) { moved = BOOL ; } if ( moved ) { log . info ( STRING , attachment Points , new Map ) ; List < Attachment Point > new AP List = new Array List < Attachment Point > ( ) ; if ( new Map != null ) new AP List . add All ( new Map . values ( ) ) ; this . attachment Points = new AP List ; } return moved ; }
public void add All ( List < Soft Wrap Impl > soft Wraps ) { my Wraps . add All ( soft Wraps ) ; }
public static double dps For Move ( final Pokemon p , final boolean primary ) { final Pokemon Move move = primary ? p . get Move 1 ( ) : p . get Move 2 ( ) ; return dps For Move ( p . get Pokemon Id ( ) , move , primary ) ; }
public static String truncate ( final String string , final int max Len ) { if ( string . length ( ) <= max Len ) return string ; else return string . substring ( NUM , max Len ) ; }
public void perform Ranking Update ( Map < Integer , Integer > legion Ranking ) { log . info ( STRING ) ; long start Time = System . current Time Millis ( ) ; Iterator < Legion > legions Iterator = all Cached Legions . iterator ( ) ; int legions Updated = NUM ; this . legion Ranking = legion Ranking ; while ( legions Iterator . has Next ( ) ) { Legion legion = legions Iterator . next ( ) ; if ( legion Ranking . contains Key ( legion . get Legion Id ( ) ) ) { legion . set Legion Rank ( legion Ranking . get ( legion . get Legion Id ( ) ) ) ; Packet Send Utility . broadcast Packet To Legion ( legion , new SM LEGION EDIT ( NUM , legion ) ) ; } legions Updated ++ ; } long work Time = System . current Time Millis ( ) - start Time ; log . info ( STRING + work Time + STRING + legions Updated ) ; }
public static void upto ( float self , Number to , @ Closure Params ( First Param . class ) Closure closure ) { float to 1 = to . float Value ( ) ; if ( self <= to 1 ) { for ( float i = self ; i <= to 1 ; i ++ ) { closure . call ( i ) ; } } else throw new Groovy Runtime Exception ( STRING + to + STRING + self + STRING ) ; }
protected void parse DOM Element ( Element element ) throws SAML 2 Exception { Assertion Factory assertion Factory = Assertion Factory . get Instance ( ) ; Protocol Factory proto Factory = Protocol Factory . get Instance ( ) ; request Id = element . get Attribute ( SAML 2 Constants . ID ) ; validate ID ( request Id ) ; version = element . get Attribute ( SAML 2 Constants . VERSION ) ; validate Version ( version ) ; String issue Instant Str = element . get Attribute ( SAML 2 Constants . ISSUE INSTANT ) ; validate Issue Instant ( issue Instant Str ) ; destination URI = element . get Attribute ( SAML 2 Constants . DESTINATION ) ; consent = element . get Attribute ( SAML 2 Constants . CONSENT ) ; Node List n List = element . get Child Nodes ( ) ; if ( ( n List != null ) && ( n List . get Length ( ) > NUM ) ) { for ( int i = NUM ; i < n List . get Length ( ) ; i ++ ) { Node child Node = n List . item ( i ) ; String c Name = child Node . get Local Name ( ) ; if ( c Name != null ) { if ( c Name . equals ( SAML 2 Constants . ISSUER ) ) { validate Issuer ( ) ; name ID = assertion Factory . create Issuer ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . SIGNATURE ) ) { validate Signature ( ) ; signature String = XML Utils . print ( ( Element ) child Node ) ; is Signed = BOOL ; } else if ( c Name . equals ( SAML 2 Constants . EXTENSIONS ) ) { validate Extensions ( ) ; extensions = proto Factory . create Extensions ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . SUBJECT ) ) { validate Subject ( ) ; subject = assertion Factory . create Subject ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . NAMEIDPOLICY ) ) { validate Name ID Policy ( ) ; name ID Policy = proto Factory . create Name ID Policy ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . CONDITIONS ) ) { validate Conditions ( ) ; conditions = assertion Factory . create Conditions ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . REQ AUTHN CONTEXT ) ) { validate Req Authn Context ( ) ; req Authn Context = proto Factory . create Requested Authn Context ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . SCOPING ) ) { validate Scoping ( ) ; scoping = proto Factory . create Scoping ( ( Element ) child Node ) ; } } } } String force Authn Attr = element . get Attribute ( SAML 2 Constants . FORCEAUTHN ) ; if ( ( force Authn Attr != null ) && ( force Authn Attr . length ( ) > NUM ) ) { force Authn = SAML 2 SDK Utils . boolean Value Of ( force Authn Attr ) ; } String is Passive Attr = element . get Attribute ( SAML 2 Constants . ISPASSIVE ) ; if ( ( is Passive Attr != null ) && ( is Passive Attr . length ( ) > NUM ) ) { is Passive = SAML 2 SDK Utils . boolean Value Of ( is Passive Attr ) ; } protocol Binding = element . get Attribute ( SAML 2 Constants . PROTOBINDING ) ; String index = element . get Attribute ( SAML 2 Constants . ASSERTION CONSUMER SVC INDEX ) ; if ( ( index != null ) && ( index . length ( ) > NUM ) ) { assertion Consumer Svc Index = new Integer ( index ) ; validate Assertion Consumer Service Index ( assertion Consumer Svc Index ) ; } assertion Consumer Service URL = XML Utils . unescape Special Characters ( element . get Attribute ( SAML 2 Constants . ASSERTION CONSUMER SVC URL ) ) ; index = element . get Attribute ( SAML 2 Constants . ATTR CONSUMING SVC INDEX ) ; if ( ( index != null ) && ( index . length ( ) > NUM ) ) { attr Consuming Svc Index = new Integer ( index ) ; validate Attribute Consuming Service Index ( attr Consuming Svc Index ) ; } provider Name = element . get Attribute ( SAML 2 Constants . PROVIDER NAME ) ; }
public static String read String From Url Generic ( String url ) throws IO Exception { Input Stream is = null ; URL url Obj = null ; String response String = Pc Constants . NA ; try { url Obj = new URL ( url ) ; URL Connection con = url Obj . open Connection ( ) ; con . set Connect Timeout ( Parallec Global Config . url Connection Connect Timeout Millis ) ; con . set Read Timeout ( Parallec Global Config . url Connection Read Timeout Millis ) ; is = con . get Input Stream ( ) ; Buffered Reader rd = new Buffered Reader ( new Input Stream Reader ( is , Charset . for Name ( STRING ) ) ) ; response String = Pc File Network Io Utils . read All ( rd ) ; } finally { if ( is != null ) { is . close ( ) ; } } return response String ; }
public void add ( T item ) { if ( items . add ( item ) ) { notify Data Set Changed ( ) ; } }
private void update Share Acl ( Net App Cluster Api nc Api , String share Name , List < Share ACL > input Acls , Acl Operation action ) { if ( input Acls . is Empty ( ) ) { return ; } List < Cifs Acl > acls = new Array List < Cifs Acl > ( ) ; for ( Share ACL new Acl : input Acls ) { Cifs Acl cif new = new Cifs Acl ( ) ; String domain = new Acl . get Domain ( ) ; String user Or Group = new Acl . get Group ( ) == null ? new Acl . get User ( ) : new Acl . get Group ( ) ; if ( domain != null && ! domain . is Empty ( ) ) { user Or Group = domain + STRING + user Or Group ; } cif new . set User Name ( user Or Group ) ; cif new . set Access ( get Access Enum ( new Acl . get Permission ( ) ) ) ; acls . add ( cif new ) ; } switch ( action ) { case ADD : nc Api . add CIFS Share Acl ( share Name , acls ) ; break ; case MODIFY : nc Api . modify CIFS Share Acl ( share Name , acls ) ; break ; case DELETE : nc Api . delete CIFS Share Acl ( share Name , acls ) ; break ; case FORCE ADD : for ( Cifs Acl cifs Acl : acls ) { try { List < Cifs Acl > single ACL = new Array List < Cifs Acl > ( ) ; single ACL . add ( cifs Acl ) ; nc Api . add CIFS Share Acl ( share Name , single ACL ) ; } catch ( Exception e ) { log . error ( STRING + cifs Acl . get User Name ( ) + STRING , e ) ; } } break ; case FORCE DELETE : for ( Cifs Acl cifs Acl : acls ) { try { List < Cifs Acl > single ACL = new Array List < Cifs Acl > ( ) ; single ACL . add ( cifs Acl ) ; nc Api . delete CIFS Share Acl ( share Name , single ACL ) ; } catch ( Exception e ) { log . error ( STRING + cifs Acl . get User Name ( ) + STRING , e ) ; } } break ; default : throw new Illegal Argument Exception ( action + STRING ) ; } }
public Is Composing Parser parse ( ) throws Parser Configuration Exception , SAX Exception , Parse Failure Exception { try { SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; SAX Parser parser = factory . new SAX Parser ( ) ; parser . parse ( m Input Source , this ) ; return this ; } catch ( IO Exception e ) { throw new Parse Failure Exception ( STRING , e ) ; } }
public Builder delete Roles ( ) { delete Fields . add ( STRING ) ; return this ; }
protected void ensure Unsigned Properties ( ) throws DSS Exception { final Node List qualifying Properties Node List = current Signature Dom . get Elements By Tag Name NS ( X Ad ES Namespaces . X Ad ES , STRING ) ; if ( qualifying Properties Node List . get Length ( ) != NUM ) { throw new DSS Exception ( STRING ) ; } qualifying Properties Dom = ( Element ) qualifying Properties Node List . item ( NUM ) ; final Node List unsigned Properties Node List = current Signature Dom . get Elements By Tag Name NS ( X Ad ES Namespaces . X Ad ES , STRING ) ; final int length = unsigned Properties Node List . get Length ( ) ; if ( length == NUM ) { unsigned Properties Dom = ( Element ) qualifying Properties Node List . item ( NUM ) ; } else if ( length == NUM ) { unsigned Properties Dom = DSSXML Utils . add Element ( document Dom , qualifying Properties Dom , X Ad ES Namespaces . X Ad ES , STRING ) ; } else { throw new DSS Exception ( STRING ) ; } }
public static double mean ( double [ ] data , int [ ] inds ) { double mean = NUM ; for ( int i = NUM ; i < inds . length ; i ++ ) { if ( Double . is Na N ( data [ inds [ i ] ] ) ) throw new Illegal Argument Exception ( STRING ) ; mean += data [ inds [ i ] ] ; } mean /= inds . length ; return mean ; }
public static final String Builder strip All Spaces ( final String Builder text ) { int pointer 2 = text . length ( ) - NUM ; while ( pointer 2 > NUM ) { if ( text . char At ( pointer 2 ) == STRING ) { text . delete Char At ( pointer 2 ) ; } pointer 2 -- ; if ( pointer 2 < NUM ) { break ; } } return text ; }
@ Override public Result do Comparison Test ( final Properties properties ) throws Exception { final long timeout = Long . parse Long ( properties . get Property ( Test Options . TIMEOUT ) ) ; final int nclients = Integer . parse Int ( properties . get Property ( Test Options . NCLIENTS ) ) ; final int ntrials = Integer . parse Int ( properties . get Property ( Test Options . NTRIALS ) ) ; final int key Len = Integer . parse Int ( properties . get Property ( Test Options . KEYLEN ) ) ; final int nops = Integer . parse Int ( properties . get Property ( Test Options . NOPS ) ) ; final double abort Rate = Double . parse Double ( properties . get Property ( Test Options . ABORT RATE ) ) ; final Result result = do Concurrent Client Test ( journal , timeout , nclients , ntrials , key Len , nops , abort Rate ) ; return result ; }
private void import Text ( ) { J File Chooser jc = new J File Chooser ( ) ; jc . set Dialog Title ( Msg . get Msg ( Env . get Ctx ( ) , STRING ) ) ; jc . set Dialog Type ( J File Chooser . OPEN DIALOG ) ; jc . set File Selection Mode ( J File Chooser . FILES ONLY ) ; if ( jc . show Open Dialog ( this ) != J File Chooser . APPROVE OPTION ) return ; String Buffer sb = new String Buffer ( ) ; try { Input Stream Reader in = new Input Stream Reader ( new File Input Stream ( jc . get Selected File ( ) ) ) ; char [ ] cbuf = new char [ NUM ] ; int count ; while ( ( count = in . read ( cbuf ) ) > NUM ) sb . append ( cbuf , NUM , count ) ; in . close ( ) ; } catch ( Exception e ) { log . log ( Level . WARNING , e . get Message ( ) ) ; return ; } text Area . set Text ( sb . to String ( ) ) ; update Status Bar ( ) ; }
private List < String > fetch Block Cos Id List ( ) throws SOS Failure { final String method Name = STRING ; log . trace ( method Name + STRING ) ; final String BLOCK COS URI = STRING ; List < String > block Cos Id List = new Array List < String > ( ) ; try { Co S List cos Elem List = client . query Object ( BLOCK COS URI , Co S List . class ) ; if ( cos Elem List != null && cos Elem List . get Cos Elements ( ) != null ) { for ( Co S Element elem : cos Elem List . get Cos Elements ( ) ) { if ( elem != null ) { block Cos Id List . add ( elem . get Id ( ) ) ; } } } log . trace ( method Name + STRING + block Cos Id List ) ; if ( cos Elem List != null && block Cos Id List != null ) { log . trace ( method Name + STRING + block Cos Id List . size ( ) + STRING ) ; return block Cos Id List ; } log . trace ( method Name + STRING ) ; return new Array List < String > ( ) ; } catch ( No Such Algorithm Exception e ) { log . error ( method Name + STRING , e ) ; throw new SOS Failure ( e ) ; } catch ( Uniform Interface Exception e ) { log . error ( method Name + STRING , e ) ; throw new SOS Failure ( e ) ; } }
private static < T > boolean complete Task ( Vi PR Task Monitor < T > task , Vi PR Task Handler < T > handler ) { try { T value = task . get Value ( ) ; handler . on Success ( task . get Task ( ) , value ) ; return BOOL ; } catch ( Execution Exception e ) { handler . on Failure ( task . get Task ( ) , e ) ; return BOOL ; } }
public final double sample Max ( ) { long max = time Max . get And Set ( NUM ) ; return scale * max ; }
public static void write File Txt ( String file Name , String [ ] total File ) throws IO Exception { try ( final Writer writer = Files . new Buffered Writer ( Paths . get ( file Name ) , Charset . for Name ( STRING ) ) ; Print Writer pw = new Print Writer ( writer ) ) { for ( String file : total File ) { pw . println ( file ) ; } } }
public synchronized void insert Chunk Auth Tag ( int chunk Idx , byte [ ] chunk Auth Tag ) throws File Encryption Exception { if ( chunk Idx < NUM || chunk Auth Tag == null || chunk Auth Tag . length != CHUNK AUTH TAG LENGTH ) { throw new File Encryption Exception ( STRING ) ; } else { if ( atag List . size ( ) <= chunk Idx ) { atag List . ensure Capacity ( chunk Idx + NUM ) ; pad To ( atag List , chunk Idx ) ; atag List . add ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } else { atag List . set ( chunk Idx , Arrays . copy Of ( chunk Auth Tag , CHUNK AUTH TAG LENGTH ) ) ; } } }
public < Annotation Type extends Annotation > void register ( Field Binder < Annotation Type > field Binder ) { Set < Annotated Field < Annotation Type > > annotated Fields = Annotated Fields . get ( field Binder . get Annotation Class ( ) , annotated Type ) ; if ( ! annotated Fields . is Empty ( ) ) { object Binders . add ( new Annotated Field Binder < > ( field Binder , annotated Fields ) ) ; } }
public static String file Name Clean ( String s ) { char [ ] chars = s . to Char Array ( ) ; String Buffer sb = new String Buffer ( ) ; for ( int i = NUM ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c == STRING ) ) { sb . append ( c ) ; } else { if ( c == STRING || c == STRING ) { sb . append ( STRING ) ; } else { sb . append ( STRING + ( int ) c + STRING ) ; } } } return sb . to String ( ) ; }
private static DOM Implementation jaxp DOM Implementation ( ) { Document Builder Factory factory = Document Builder Factory . new Instance ( ) ; factory . set Namespace Aware ( BOOL ) ; Document Builder builder ; try { builder = factory . new Document Builder ( ) ; } catch ( Parser Configuration Exception e ) { throw new Runtime Exception ( e ) ; } return builder . get DOM Implementation ( ) ; }
public void add DTED Directory Handler ( DTED Directory Handler handler ) { directories . add ( handler ) ; }
public void write Jar From Content ( final String class Name , final String content , final File output File ) throws IO Exception { File Output Stream file Output Stream = new File Output Stream ( output File ) ; write Jar From Content ( class Name , content , file Output Stream ) ; file Output Stream . close ( ) ; }
public Snmp Var Bind [ ] decode Var Bind List ( Ber Decoder bdec ) throws Ber Exception { bdec . open Sequence ( ) ; Vector < Snmp Var Bind > tmp = new Vector < Snmp Var Bind > ( ) ; while ( bdec . cannot Close Sequence ( ) ) { Snmp Var Bind bind = new Snmp Var Bind ( ) ; bdec . open Sequence ( ) ; bind . oid = new Snmp Oid ( bdec . fetch Oid ( ) ) ; bind . set Snmp Value ( decode Var Bind Value ( bdec ) ) ; bdec . close Sequence ( ) ; tmp . add Element ( bind ) ; } bdec . close Sequence ( ) ; Snmp Var Bind [ ] var Bind List = new Snmp Var Bind [ tmp . size ( ) ] ; tmp . copy Into ( var Bind List ) ; return var Bind List ; }
public static void init Urban Sim Zone Writer ( ) { try { log . info ( STRING ) ; parcel Writer = IO Utils . get Buffered Writer ( Internal Constants . MATSIM 4 OPUS TEMP + FILE NAME ) ; log . info ( STRING + Internal Constants . MATSIM 4 OPUS TEMP + FILE NAME + STRING ) ; parcel Writer . write ( Internal Constants . PARCEL ID + STRING + Internal Constants . ACCESSIBILITY BY FREESPEED + STRING + Internal Constants . ACCESSIBILITY BY CAR + STRING + Internal Constants . ACCESSIBILITY BY BIKE + STRING + Internal Constants . ACCESSIBILITY BY WALK ) ; parcel Writer . new Line ( ) ; log . info ( STRING ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public void start Execution Every Day At ( Custom Timer Task task , int target Hour , int target Min , int target Sec ) { Bot Logger . warn ( LOGTAG , STRING + task . get Task Name ( ) ) ; final Runnable task Wrapper = null ; if ( task . get Times ( ) != NUM ) { final long delay = comput Next Dilay ( target Hour , target Min , target Sec ) ; executor Service . schedule ( task Wrapper , delay , Time Unit . SECONDS ) ; } }
private String post RP Change Vpool Steps ( Workflow workflow , String wait For , List < Volume Descriptor > volume Descriptors , String task Id ) { List < Volume Descriptor > rp Volume Descriptors = Volume Descriptor . filter By Type ( volume Descriptors , new Volume Descriptor . Type [ ] { Volume Descriptor . Type . RP EXISTING SOURCE } , null ) ; if ( rp Volume Descriptors . is Empty ( ) ) { return wait For ; } List < Volume Descriptor > migrated Block Data Descriptors = new Array List < Volume Descriptor > ( ) ; List < URI > volumes With Migration = new Array List < URI > ( ) ; if ( volume Descriptors != null ) { List < Volume Descriptor > migrate Descriptors = Volume Descriptor . filter By Type ( volume Descriptors , new Volume Descriptor . Type [ ] { Volume Descriptor . Type . VPLEX MIGRATE VOLUME } , null ) ; if ( migrate Descriptors != null && ! migrate Descriptors . is Empty ( ) ) { s logger . info ( STRING ) ; Iterator < Volume Descriptor > migration Iter = migrate Descriptors . iterator ( ) ; while ( migration Iter . has Next ( ) ) { Volume Descriptor migration Desc = migration Iter . next ( ) ; Migration migration = s db Client . query Object ( Migration . class , migration Desc . get Migration Id ( ) ) ; volumes With Migration . add ( migration . get Source ( ) ) ; Volume migrated Volume = s db Client . query Object ( Volume . class , migration . get Volume ( ) ) ; Volume Descriptor migrated Block Data Desc = new Volume Descriptor ( Volume Descriptor . Type . BLOCK DATA , migrated Volume . get Storage Controller ( ) , migrated Volume . get Id ( ) , null , migrated Volume . get Consistency Group ( ) , migration Desc . get Capabilities Values ( ) ) ; migrated Block Data Descriptors . add ( migrated Block Data Desc ) ; } } } List < Volume Descriptor > block Data Descriptors = new Array List < Volume Descriptor > ( ) ; for ( Volume Descriptor descr : rp Volume Descriptors ) { Volume rp Existing Source = s db Client . query Object ( Volume . class , descr . get Volume URI ( ) ) ; if ( RP Helper . is V Plex Volume ( rp Existing Source , s db Client ) ) { s logger . info ( String . format ( STRING , rp Existing Source . get Label ( ) ) ) ; if ( null != rp Existing Source . get Associated Volumes ( ) ) { for ( String assoc Volume Id : rp Existing Source . get Associated Volumes ( ) ) { Volume assoc Volume = s db Client . query Object ( Volume . class , URI . create ( assoc Volume Id ) ) ; if ( volumes With Migration . contains ( assoc Volume . get Id ( ) ) ) { s logger . info ( String . format ( STRING , assoc Volume . get Label ( ) ) ) ; continue ; } if ( Null Column Value Getter . is Not Null Value ( assoc Volume . get Replication Group Instance ( ) ) ) { Volume Descriptor block Data Desc = new Volume Descriptor ( Volume Descriptor . Type . BLOCK DATA , assoc Volume . get Storage Controller ( ) , assoc Volume . get Id ( ) , null , rp Existing Source . get Consistency Group ( ) , descr . get Capabilities Values ( ) ) ; block Data Descriptors . add ( block Data Desc ) ; assoc Volume . set Consistency Group ( rp Existing Source . get Consistency Group ( ) ) ; s db Client . update Object ( assoc Volume ) ; s logger . info ( String . format ( STRING , assoc Volume . get Label ( ) , rp Existing Source . get Consistency Group ( ) , assoc Volume . get Storage Controller ( ) ) ) ; } } } } } if ( ! block Data Descriptors . is Empty ( ) ) { wait For = block Device Controller . add Steps For Create Consistency Group ( workflow , wait For , block Data Descriptors , STRING ) ; wait For = block Device Controller . add Steps For Update Consistency Group ( workflow , wait For , block Data Descriptors , null ) ; } block Data Descriptors . add All ( migrated Block Data Descriptors ) ; s logger . info ( STRING ) ; wait For = replica Device Controller . add Steps For Create Volumes ( workflow , wait For , block Data Descriptors , task Id ) ; return wait For ; }
private void capture Different String ( String old Name , String new Name , String app Name , Map < String , String > map , String default Value ) { Reject . if Null ( app Name ) ; Reject . if Null ( map ) ; if ( old Name == null && new Name == null ) { map . put ( app Name , default Value ) ; } else if ( new Name != null && ! new Name . equals ( old Name ) ) { map . put ( app Name , new Name ) ; } }
@ Override protected void draw X Labels ( List < Double > x Labels , Double [ ] x Text Label Locations , Canvas canvas , Paint paint , int left , int top , int bottom , double x Pixels Per Unit , double min X , double max X ) { int length = x Labels . size ( ) ; if ( length > NUM ) { boolean show Labels = m Renderer . is Show Labels ( ) ; boolean show Grid Y = m Renderer . is Show Grid Y ( ) ; Date Format format = get Date Format ( x Labels . get ( NUM ) , x Labels . get ( length - NUM ) ) ; for ( int i = NUM ; i < length ; i ++ ) { long label = Math . round ( x Labels . get ( i ) ) ; float x Label = ( float ) ( left + x Pixels Per Unit * ( label - min X ) ) ; if ( show Labels ) { paint . set Color ( m Renderer . get X Labels Color ( ) ) ; canvas . draw Line ( x Label , bottom , x Label , bottom + m Renderer . get Labels Text Size ( ) / NUM , paint ) ; draw Text ( canvas , format . format ( new Date ( label ) ) , x Label , bottom + m Renderer . get Labels Text Size ( ) * NUM / NUM + m Renderer . get X Labels Padding ( ) , paint , m Renderer . get X Labels Angle ( ) ) ; } if ( show Grid Y ) { paint . set Color ( m Renderer . get Grid Color ( NUM ) ) ; canvas . draw Line ( x Label , bottom , x Label , top , paint ) ; } } } draw X Text Labels ( x Text Label Locations , canvas , paint , BOOL , left , top , bottom , x Pixels Per Unit , min X , max X ) ; }
public static byte [ ] decode From String ( String src ) { if ( src == null ) { return null ; } if ( src . length ( ) == NUM ) { return new byte [ NUM ] ; } byte [ ] result ; try { result = delegate . decode ( src . get Bytes ( DEFAULT CHARSET . display Name ( ) ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Illegal State Exception ( e ) ; } return result ; }
public static void queue Column Load ( I Cubic World world , Cube IO loader , int x , int z , Consumer < Column > runnable ) { Queued Column key = new Queued Column ( x , z , world ) ; Async Column IO Provider task = column Tasks . get ( key ) ; if ( task == null ) { task = new Async Column IO Provider ( key , loader ) ; task . add Callback ( runnable ) ; column Tasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . add Callback ( runnable ) ; } }
protected Object deserialize Unknown Header ( Data Input is , int head , Elsa Stack object Stack ) throws IO Exception { throw new IO Exception ( STRING + head ) ; }
private void load Mapped Binary ( File Input Stream is ) throws IO Exception { File Channel fc = is . get Channel ( ) ; Mapped Byte Buffer bb = fc . map ( File Channel . Map Mode . READ ONLY , NUM , ( int ) fc . size ( ) ) ; bb . load ( ) ; load Database ( bb ) ; is . close ( ) ; }
private static void primitive 2 b ( Method Visitor mv , Class Node type ) { Label true Label = new Label ( ) ; Label false Label = new Label ( ) ; if ( type == Class Helper . double TYPE ) { mv . visit Insn ( DCONST 0 ) ; mv . visit Insn ( DCMPL ) ; } else if ( type == Class Helper . long TYPE ) { mv . visit Insn ( LCONST 0 ) ; mv . visit Insn ( LCMP ) ; } else if ( type == Class Helper . float TYPE ) { mv . visit Insn ( FCONST 0 ) ; mv . visit Insn ( FCMPL ) ; } else if ( type == Class Helper . int TYPE ) { } mv . visit Jump Insn ( IFEQ , false Label ) ; mv . visit Insn ( ICONST 1 ) ; mv . visit Jump Insn ( GOTO , true Label ) ; mv . visit Label ( false Label ) ; mv . visit Insn ( ICONST 0 ) ; mv . visit Label ( true Label ) ; }
@ No Warning ( STRING ) static Array List < Ideas 2009 05 20 > remove Duplicates False Positive ( final Array List < Ideas 2009 05 20 > list ) { final Array List < Ideas 2009 05 20 > results = new Array List < Ideas 2009 05 20 > ( ) ; final Array List < String > sections = new Array List < String > ( ) ; while ( list . size ( ) > NUM ) { final Ideas 2009 05 20 specification = list . remove ( NUM ) ; final Iterator < Ideas 2009 05 20 > iterator = list . iterator ( ) ; while ( iterator . has Next ( ) ) { final Ideas 2009 05 20 other = iterator . next ( ) ; if ( specification . equals ( other ) ) { final String [ ] other Sections = other . get Sections ( ) ; if ( null != sections ) { sections . add All ( Arrays . as List ( other Sections ) ) ; } iterator . remove ( ) ; } } final Ideas 2009 05 20 merged = merge In Sections ( specification , sections ) ; results . add ( merged ) ; sections . clear ( ) ; } return results ; }
public String quoted String ( ) throws Parse Exception { int start Idx = ptr + NUM ; if ( look Ahead ( NUM ) != STRING ) return null ; consume ( NUM ) ; while ( BOOL ) { char next = get Next Char ( ) ; if ( next == STRING ) { break ; } else if ( next == STRING ) { throw new Parse Exception ( this . buffer + STRING , this . ptr ) ; } else if ( next == STRING ) { consume ( NUM ) ; } } return buffer . substring ( start Idx , ptr - NUM ) ; }
@ Override public Session create Session ( Principal Id principal , Authn Method auth Method , String external IDP Session Id , String idp Ent Id ) throws Saml Service Exception { Validate . not Null ( principal , STRING ) ; Calendar calendar = new Gregorian Calendar ( ) ; calendar . add ( Calendar . MINUTE , Shared . SESSION LIFETIME MINUTES ) ; Date session End Time = calendar . get Time ( ) ; try { Session current Session = new Session ( principal , session End Time , auth Method ) ; if ( external IDP Session Id != null ) { Validate . not Empty ( idp Ent Id , STRING ) ; current Session . set Using Ext IDP ( BOOL ) ; current Session . set Ext IDP To Used ( new IDP Config ( idp Ent Id ) ) ; current Session . set Ext IDP Session ID ( external IDP Session Id ) ; } add ( current Session ) ; return current Session ; } catch ( No Such Algorithm Exception e ) { throw new Saml Service Exception ( e ) ; } }
public boolean equals ( Object o ) { if ( o instanceof Coverage Char Vdt ) { Coverage Char Vdt civ = ( Coverage Char Vdt ) o ; return ( ( attribute == civ . attribute ) && ( value == civ . value ) ) ; } else { return BOOL ; } }
public static void load Props From File ( Path file Path , File System fs ) throws IO Exception { if ( fs . exists ( file Path ) ) { try ( Input Stream stream = fs . open ( file Path ) ) { logger . info ( STRING + file Path . to String ( ) + STRING ) ; load Properties ( stream ) ; } catch ( IO Exception e ) { logger . error ( STRING + file Path . to String ( ) + STRING ) ; e . print Stack Trace ( ) ; } } else { logger . warn ( STRING + file Path . to String ( ) + STRING ) ; } }
public void test Case 7 ( ) { byte a Bytes [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; byte b Bytes [ ] = { NUM } ; int a Sign = NUM ; int b Sign = NUM ; byte r Bytes [ ] = { NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . multiply ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
int assign ( String webapp Id ) { int activity Index = check If Assigned ( webapp Id ) ; if ( activity Index == INVALID ACTIVITY INDEX ) { activity Index = m Activity List . get ( NUM ) . m Activity Index ; Activity Entry new Entry = new Activity Entry ( activity Index , webapp Id ) ; m Activity List . set ( NUM , new Entry ) ; } mark Activity Used ( activity Index , webapp Id ) ; return activity Index ; }
@ Override public synchronized void stop ( ) { LOGGER . info ( STRING ) ; timer . cancel ( ) ; running = BOOL ; }
private void validate Fields ( ) { String url = url Combo . get Text ( ) ; if ( url . length ( ) == NUM ) { set Error Message ( null ) ; set Page Complete ( BOOL ) ; return ; } try { new SVN Url ( url ) ; } catch ( Malformed URL Exception e ) { set Error Message ( Policy . bind ( STRING , e . get Message ( ) ) ) ; set Page Complete ( BOOL ) ; return ; } set Error Message ( null ) ; set Page Complete ( BOOL ) ; }
public static void create RMA 6 File From DAA ( String creator , String daa File , String rma 6 File Name , boolean use Compression , Document doc , int max Matches Per Read , boolean has Magnitudes , Progress Listener progress Listener ) throws IO Exception , Canceled Exception { final RMA 6 From Blast Creator rma 6 Creator = new RMA 6 From Blast Creator ( creator , Blast File Format . DAA , doc . get Blast Mode ( ) , new String [ ] { daa File } , new String [ ] { } , rma 6 File Name , use Compression , doc , max Matches Per Read , has Magnitudes ) ; rma 6 Creator . parse Files ( progress Listener ) ; }
public synchronized void init ( ) { if ( stats On ) { return ; } stats On = BOOL ; executor = Executors . new Single Thread Scheduled Executor ( new Customizable Thread Factory ( STAT THREAD NAME ) ) ; executor . schedule At Fixed Rate ( new Stat Logger ( ) , display Rate In Mins , display Rate In Mins , Time Unit . MINUTES ) ; executor . schedule At Fixed Rate ( new Per Minute Processing ( ) , NUM , NUM , Time Unit . SECONDS ) ; executor . schedule At Fixed Rate ( new Per Hour Processing ( ) , NUM , NUM , Time Unit . SECONDS ) ; executor . schedule At Fixed Rate ( new Per Day Processing ( ) , NUM , NUM , Time Unit . SECONDS ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return PATH ; case NUM : return BLOCK SIZE BYTES ; case NUM : return TOTAL LBA BLOCKS ; case NUM : return TOTAL SPACE ; default : return null ; } }
public void test Sneaky Bean Properties ( ) throws Exception { Object Mapper mapper = new Object Mapper ( ) ; String Long Map Bean bean = mapper . read Value ( STRING , String Long Map Bean . class ) ; assert Not Null ( bean ) ; Map < String , Long > map = bean . value ; assert Equals ( NUM , map . size ( ) ) ; assert Equals ( Long . value Of ( NUM ) , map . get ( STRING ) ) ; String List Bean bean 2 = mapper . read Value ( STRING , String List Bean . class ) ; assert Not Null ( bean 2 ) ; List < String > list = bean 2 . value ; assert Same ( Generic List . class , list . get Class ( ) ) ; assert Equals ( NUM , list . size ( ) ) ; assert Equals ( STRING , list . get ( NUM ) ) ; }
public final void build Signed Directory ( ) throws Exception { try ( Byte Array Output Stream mime Content = new Byte Array Output Stream ( ) ) { build ( mime Content ) ; log . debug ( STRING , mime Content . to String ( ) ) ; byte [ ] content Bytes = mime Content . to Byte Array ( ) ; mime Content . reset ( ) ; sign ( content Bytes , mime Content ) ; Files . write ( temp Conf Path , mime Content . to Byte Array ( ) ) ; log . debug ( STRING , temp Conf Path ) ; } }
protected final void match Token ( String match Str , int i ) throws IO Exception , Json Parse Exception { final int len = match Str . length ( ) ; do { if ( input Ptr >= input End ) { if ( ! load More ( ) ) { report Invalid EOF In Value ( ) ; } } if ( input Buffer [ input Ptr ] != match Str . char At ( i ) ) { report Invalid Token ( match Str . substring ( NUM , i ) , STRING ) ; } ++ input Ptr ; } while ( ++ i < len ) ; if ( input Ptr >= input End ) { if ( ! load More ( ) ) { return ; } } char c = input Buffer [ input Ptr ] ; if ( c < STRING || c == STRING || c == STRING ) { return ; } if ( Character . is Java Identifier Part ( c ) ) { report Invalid Token ( match Str . substring ( NUM , i ) , STRING ) ; } return ; }
public static Object deserialize Object ( final byte [ ] obj Bytes ) throws IO Exception , Class Not Found Exception { Object Input Stream obj In = null ; try { obj In = new Object Input Stream ( new Byte Array Input Stream ( obj Bytes ) ) ; return obj In . read Object ( ) ; } finally { close ( obj In ) ; } }
public Interval overlap ( Readable Interval interval ) { interval = Date Time Utils . get Readable Interval ( interval ) ; if ( overlaps ( interval ) == BOOL ) { return null ; } long start = Math . max ( get Start Millis ( ) , interval . get Start Millis ( ) ) ; long end = Math . min ( get End Millis ( ) , interval . get End Millis ( ) ) ; return new Interval ( start , end , get Chronology ( ) ) ; }
public static String dictionary To String ( Dictionary < Object , Object > dict ) { Enumeration < Object > keys = dict . keys ( ) ; Object key , value ; String Buffer result = new String Buffer ( ) ; while ( keys . has More Elements ( ) ) { key = keys . next Element ( ) ; value = dict . get ( key ) ; result . append ( key . to String ( ) ) ; result . append ( STRING ) ; result . append ( value . to String ( ) ) ; result . append ( STRING ) ; } return result . to String ( ) ; }
public void add Item To Shopping Cart ( Shopping Cart Item item ) { if ( item == null ) { throw new Invalid Parameter Exception ( STRING ) ; } shopping Cart Items . add ( item ) ; }
public void animate To ( float left , float top , float right , float bottom , Animation Callback animation Callback ) { Center Crop Translator translator = Center Crop Translator . get ( tiles View , source Width , source Height ) ; float target Content Width = ( right - left ) * translator . initial Content Scale ; float target Content Height = ( bottom - top ) * translator . initial Content Scale ; float max Scale X = tiles View . get Content Width ( ) / target Content Width ; float max Scale Y = tiles View . get Content Height ( ) / target Content Height ; float scale = Math . min ( max Scale X , max Scale Y ) ; int zoom Level = ( int ) ( scale < NUM ? scale + NUM : Math . log ( scale * NUM - NUM ) / Math . log ( NUM ) + NUM ) ; if ( zoom Level < tiles View . get Min Zoom Level ( ) ) { zoom Level = tiles View . get Min Zoom Level ( ) ; } if ( zoom Level > tiles View . get Zoom Level ( ) ) { zoom Level = tiles View . get Zoom Level ( ) ; } animate To ( ( left + right ) / NUM , ( top + bottom ) / NUM , zoom Level , animation Callback ) ; }
public static double sample Kurtosis Standard Error ( int size ) { int n = size ; return Math . sqrt ( NUM * n * ( n - NUM ) * ( n - NUM ) / ( ( n - NUM ) * ( n - NUM ) * ( n + NUM ) * ( n + NUM ) ) ) ; }
private void check Contains ( Spanned text , String [ ] spans , String span Name , int start , int end ) throws Exception { for ( String i : spans ) { if ( i . equals ( span Name ) ) { assert Equals ( start , text . get Span Start ( i ) ) ; assert Equals ( end , text . get Span End ( i ) ) ; return ; } } fail ( ) ; }
public Analyzer save Analysis ( File file ) throws IO Exception { Print Stream ps = null ; try { ps = new Print Stream ( new Buffered Output Stream ( new File Output Stream ( file ) ) ) ; print Analysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
@ Suppress Warnings ( STRING ) private static void load Extensions ( final Class Loader class Loader ) { for ( final Map . Entry < Class , Set < Class > > entry : definition Map . entry Set ( ) ) { final Service Loader < ? > service Loader = Service Loader . load ( entry . get Key ( ) , class Loader ) ; for ( final Object o : service Loader ) { register Service Class ( o . get Class ( ) , extension Classloader Lookup , class Loader , entry . get Value ( ) ) ; } } }
@ Override protected void on Dialog Closed ( boolean positive Result ) { if ( positive Result ) { String current Value = String . value Of ( m Hour Picker . get Value ( ) * HOUR + m Minute Picker . get Value ( ) * MINUTE + m Second Picker . get Value ( ) * SECOND ) ; if ( call Change Listener ( current Value ) ) { persist String ( current Value ) ; } } }
public String ( byte [ ] bytes , java . lang . String enc ) throws java . io . Unsupported Encoding Exception { this ( bytes To Chars ( bytes , NUM , bytes . length , enc ) ) ; }
protected void assert Sender Config ( String config ) throws Exception { context = new Class Path Xml Application Context ( config ) ; consumer = ( Spring Consumer ) context . get Bean ( STRING ) ; assert True ( STRING , consumer != null ) ; consumer . start ( ) ; producer = ( Spring Producer ) context . get Bean ( STRING ) ; assert True ( STRING , producer != null ) ; consumer . flush Messages ( ) ; producer . start ( ) ; consumer . wait For Messages To Arrive ( producer . get Message Count ( ) ) ; List < Message > messages = consumer . flush Messages ( ) ; LOG . info ( STRING ) ; for ( Message message : messages ) { LOG . info ( STRING + message ) ; } assert Equals ( STRING , producer . get Message Count ( ) , messages . size ( ) ) ; }
public String decode ( Abstract Message msg , Boolean ext , int header ) { String str = Cbus Op Codes . decode ( msg , ext , header ) ; return ( str ) ; }
private boolean classify Example ( Instance example ) throws Exception { double class Value = - NUM ; for ( Enumeration < Rule List > e = new Weka Enumeration < Rule List > ( m Decision List ) ; e . has More Elements ( ) && class Value < NUM ; ) { Rule List rl = e . next Element ( ) ; class Value = rl . classify Instance ( example ) ; } if ( class Value >= NUM ) { example . set Class Value ( class Value ) ; return BOOL ; } else { return BOOL ; } }
public static int hash 3 ( int hash , Object x , Object y , Object z ) { return NUM | ( hash + NUM * System . identity Hash Code ( x ) + NUM * System . identity Hash Code ( y ) + NUM * System . identity Hash Code ( z ) ) ; }
public void test Update 5 ( ) { int factor = NUM ; String update Query = STRING + Database Creator . TEST TABLE 1 + STRING + factor ; try { String select Query = STRING + Database Creator . TEST TABLE 1 ; Result Set result = statement . execute Query ( select Query ) ; Hash Set < Big Decimal > values = new Hash Set < Big Decimal > ( ) ; int num = statement . execute Update ( update Query ) ; assert Equals ( STRING , number Of Records , num ) ; result = statement . execute Query ( select Query ) ; assert True ( STRING , values . is Empty ( ) ) ; result . close ( ) ; } catch ( SQL Exception e ) { fail ( STRING + e . get Message ( ) ) ; } }
public void decrypt ( Key Parameter aes Key ) { lock . lock ( ) ; try { check State ( get Encryption Type ( ) != Encryption Type . UNENCRYPTED , STRING ) ; check Not Null ( key Crypter ) ; Array List < EC Key > decrypted Key Chain = new Array List < EC Key > ( ) ; for ( EC Key key : keychain ) { if ( ! key . is Encrypted ( ) ) { decrypted Key Chain . add ( key ) ; } else { EC Key decrypted EC Key = key . decrypt ( key Crypter , aes Key ) ; decrypted Key Chain . add ( decrypted EC Key ) ; } } keychain = decrypted Key Chain ; key Crypter = null ; extensions . remove ( Multi Bit Wallet Protobuf Serializer . ORG MULTIBIT WALLET PROTECT 2 ) ; } finally { lock . unlock ( ) ; } }
public static Script create Multi Sig Input Script Bytes ( List < byte [ ] > signatures , @ Nullable byte [ ] multisig Program Bytes ) { check Argument ( signatures . size ( ) <= NUM ) ; Script Builder builder = new Script Builder ( ) ; builder . small Num ( NUM ) ; for ( byte [ ] signature : signatures ) builder . data ( signature ) ; if ( multisig Program Bytes != null ) builder . data ( multisig Program Bytes ) ; return builder . build ( ) ; }
private void write Keystore ( File config Defaults ) throws IO Exception { File keystore XML = new File ( config Defaults , STRING ) ; Print Stream writer = Server Config Utils . open ( keystore XML ) ; writer . print ( STRING ) ; writer . print ( gen Password ( ) ) ; writer . println ( STRING ) ; Server Config Utils . close ( writer ) ; }
@ Gen Ignore static Record create Record ( String name , String address , Class type , Json Object metadata ) { return create Record ( name , address , type != null ? type . get Name ( ) : null , metadata ) ; }
private static long spin ( long ms ) { long start = thread MX Bean . get Current Thread Cpu Time ( ) ; do { long duration MS = ( thread MX Bean . get Current Thread Cpu Time ( ) - start ) / NUM ; if ( duration MS >= ms ) { return duration MS ; } } while ( BOOL ) ; }
public synchronized void insert Audio ( String inputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , byte [ ] audio ) throws SQL Exception { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( lookup Audio ( inputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; Prepared Statement st = connection . prepare Statement ( query ) ; st . set String ( NUM , inputtext ) ; st . set Bytes ( NUM , audio ) ; st . execute Update ( ) ; st . close ( ) ; }
public void add Conditions ( Iterable < ? extends Data Table Filter Condition > conditions ) { boolean changed = BOOL ; for ( Data Table Filter Condition condition : conditions ) { if ( condition != null ) { condition Stack . add ( condition ) ; changed = BOOL ; } } if ( changed ) { set Selected Indices ( update Selection ( ) ) ; inform Data Table Filtered Listener ( ) ; } }
public static byte [ ] pack Byte Buffer Into Single Byte Array ( Byte Buffer [ ] byte Buffer Arr ) { if ( null == byte Buffer Arr || byte Buffer Arr . length == NUM ) { return null ; } int no Of Col = byte Buffer Arr . length ; short offset Len = ( short ) ( no Of Col * NUM ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM ; index < byte Buffer Arr . length - NUM ; index ++ ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; int no Of Bytes = individual Col . capacity ( ) ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len += no Of Bytes ; individual Col . rewind ( ) ; } for ( int index = NUM ; index < byte Buffer Arr . length ; index ++ ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; buffer . put ( individual Col . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
public void find Package And Class ( ) throws IO Exception { package Name = null ; class Name = null ; Line Number Reader reader = new Line Number Reader ( new File Reader ( input File ) ) ; while ( class Name == null || package Name == null ) { String line = reader . read Line ( ) ; if ( line == null ) break ; if ( package Name == null ) { int index = line . index Of ( STRING ) ; if ( index >= NUM ) { index += NUM ; int end = line . index Of ( STRING , index ) ; if ( end >= index ) { package Name = line . substring ( index , end ) ; package Name = package Name . trim ( ) ; } } } if ( class Name == null ) { int index = line . index Of ( STRING ) ; if ( index >= NUM ) { index += NUM ; class Name = line . substring ( index ) ; class Name = class Name . trim ( ) ; } } } if ( class Name == null ) class Name = STRING ; }
public static Set < URI > fetch SRDF Target Virtual Pools ( Db Client db Client ) { Set < URI > srdf Protected Target V Pools = new Hash Set < URI > ( ) ; try { List < URI > vpool Remote Setting UR Is = db Client . query By Type ( Vpool Remote Copy Protection Settings . class , BOOL ) ; Iterator < Vpool Remote Copy Protection Settings > v Pool Remote Settings Itr = db Client . query Iterative Objects ( Vpool Remote Copy Protection Settings . class , vpool Remote Setting UR Is , BOOL ) ; while ( v Pool Remote Settings Itr . has Next ( ) ) { Vpool Remote Copy Protection Settings r Setting = v Pool Remote Settings Itr . next ( ) ; if ( null != r Setting && ! Null Column Value Getter . is Null URI ( r Setting . get Virtual Pool ( ) ) ) { srdf Protected Target V Pools . add ( r Setting . get Virtual Pool ( ) ) ; } } } catch ( Exception ex ) { log . error ( STRING , ex ) ; } return srdf Protected Target V Pools ; }
public static int cardinality ( long [ ] v ) { int sum = NUM ; for ( int i = NUM ; i < v . length ; i ++ ) { sum += Long . bit Count ( v [ i ] ) ; } return sum ; }
public Extended String Literal extend With ( String Literal lit ) { int length = this . source . length ; System . arraycopy ( this . source , NUM , this . source = new char [ length + lit . source . length ] , NUM , length ) ; System . arraycopy ( lit . source , NUM , this . source , length , lit . source . length ) ; this . source End = lit . source End ; return this ; }
public static void w ( String msg , Object ... args ) { if ( ! allow W ) return ; Stack Trace Element caller = get Caller Stack Trace Element ( ) ; String tag = generate Tag ( caller ) ; if ( s Level > LEVEL WARNING ) { return ; } if ( args . length > NUM ) { msg = String . format ( msg , args ) ; } Log . w ( tag , msg ) ; }
public D Open Pkcs 11 Key Store ( J Frame parent ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; }

public void add Listener ( final L listener ) { Validate . not Null ( listener , STRING ) ; listeners . add ( listener ) ; }
static boolean wait For ( Process process , long timeout ) throws Interrupted Exception { final int interval = NUM * NUM ; long time Waiting = NUM ; while ( time Waiting < timeout ) { if ( ! is Process Alive ( process ) ) return BOOL ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + process + STRING + ( timeout - time Waiting ) + STRING + timeout + STRING ) ; try { Thread . sleep ( interval ) ; } catch ( Interrupted Exception e ) { e . fill In Stack Trace ( ) ; throw e ; } time Waiting += interval ; } return BOOL ; }
private synchronized void read Object ( java . io . Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; init ( get Name ( ) , get Mask ( actions ) ) ; }
public void add Phi Operand ( Register Spec register Spec , Ssa Basic Block pred Block ) { operands . add ( new Operand ( register Spec , pred Block . get Index ( ) , pred Block . get Rop Label ( ) ) ) ; sources = null ; }
private Wikibase Date check ( int year , int month , int day , int hour , int minute , int second ) { Wikibase Date wb Date = new Wikibase Date ( year , month , day , hour , minute , second ) ; assert Equals ( wb Date . to String ( ) , joda Seconds ( year , month , day , hour , minute , second ) , wb Date . seconds Since Epoch ( ) ) ; check Round Trip ( wb Date ) ; return wb Date ; }
public static byte [ ] decode ( String s ) { return decode ( s , NO OPTIONS ) ; }
@ Suppress Warnings ( STRING ) public static void add File ( File f ) throws IO Exception { add URL ( f . to URL ( ) ) ; }
public Sample Set ( String Tokenizer tok , Buffered Reader reader ) { try { int num Samples = Integer . parse Int ( tok . next Token ( ) ) ; int num Channels = Integer . parse Int ( tok . next Token ( ) ) ; int sample Rate = Integer . parse Int ( tok . next Token ( ) ) ; float coeff Min = Float . parse Float ( tok . next Token ( ) ) ; float coeff Range = Float . parse Float ( tok . next Token ( ) ) ; float post Emphasis = Float . parse Float ( tok . next Token ( ) ) ; int residual Fold = Integer . parse Int ( tok . next Token ( ) ) ; samples = new Sample [ num Samples ] ; sample Info = new Sample Info ( sample Rate , num Channels , residual Fold , coeff Min , coeff Range , post Emphasis ) ; for ( int i = NUM ; i < num Samples ; i ++ ) { samples [ i ] = new Sample ( reader , num Channels ) ; } } catch ( No Such Element Exception nse ) { throw new Error ( STRING + nse . get Message ( ) ) ; } }
@ Override public Env Var add New Env Var ( String name , Class < ? > type , String value ) { Env Var env Var = null ; if ( ! exist ( name ) ) { env Var = new Env Var ( name , type , BOOL ) ; env Var . set Value ( value ) ; env Var List . add ( env Var ) ; } return env Var ; }
public void make Class ( String str , boolean caseless ) { for ( int i = NUM ; i < str . length ( ) ; ) { int ch = str . code Point At ( i ) ; make Class ( ch , caseless ) ; i += Character . char Count ( ch ) ; } }
private Monitor Trigger Event create Event ( Trigger t , Statistic global Stat ) { Monitor Trigger Event event = new Monitor Trigger Event ( ) ; event . set App Id ( this . app Id ) ; event . set Trigger Id ( t . get Trigger Id ( ) ) ; event . set Metric Value ( global Stat . get Value ( ) ) ; event . set Time Stamp ( System . current Time Millis ( ) ) ; event . set Trigger ( t ) ; event . set Metric Type ( t . get Metric ( ) ) ; return event ; }
private static int do Regex Search ( final Object element , final String line Text , final int line Counter , final String local Search String , final int start Position , final boolean case Sensitive , final List < Search Result > results ) { final Pattern pattern = case Sensitive ? Pattern . compile ( local Search String ) : Pattern . compile ( local Search String , Pattern . CASE INSENSITIVE ) ; final Matcher matcher = pattern . matcher ( line Text ) ; final boolean found = matcher . find ( start Position ) ; if ( found ) { final int start = matcher . start ( ) ; final int end = matcher . end ( ) ; if ( start != end ) { results . add ( new Search Result ( element , line Counter , start , end - start ) ) ; } if ( matcher . end ( ) == line Text . length ( ) ) { return - NUM ; } if ( start == end ) { return end + NUM ; } return end ; } else { return - NUM ; } }
protected static byte [ ] input Stream To Byte Array ( Input Stream str ) throws IO Exception { try ( Byte Array Output Stream baos = new Byte Array Output Stream ( ) ) { int len = NUM ; byte [ ] buf = new byte [ NUM ] ; while ( ( len = str . read ( buf ) ) != - NUM ) { baos . write ( buf , NUM , len ) ; } return baos . to Byte Array ( ) ; } }
public Builder add Content Item ( Content Item content Item ) { if ( content Items == null ) { content Items = new Array List < Content Item > ( ) ; content Type = Http Media Type . APPLICATION JSON ; } content Items . add ( content Item ) ; return this ; }
private String encode To String ( String in , int flags ) throws Exception { String b64 = Base 64 . encode To String ( in . get Bytes ( ) , flags ) ; String dec = decode String ( b64 ) ; assert Equals ( in , dec ) ; return b64 ; }
public void calculate Exclusive Min ( double min ) { if ( exclusive Min == - NUM ) { exclusive Min = min ; } else { exclusive Min = Math . min ( exclusive Min , min ) ; } }
private void offer ( Blocking Queue < Task > queue , Task task ) throws Queue Timeout Exception { try { debug ( STRING , task . to String ( ) ) ; if ( ! queue . offer ( wrap ( task ) , configuration . get Queue Timeout ( ) , Time Unit . SECONDS ) ) { throw new Queue Timeout Exception ( task ) ; } } catch ( Interrupted Exception e ) { throw new Queue Timeout Exception ( task , e ) ; } }
public static void audit File ( Db Client db Client , Operation Type Enum audit Type , boolean operational Status , String description , Object ... descparams ) { Audit Log Manager audit Mgr = Audit Log Manager Factory . get Audit Log Manager ( ) ; audit Mgr . set Db Client ( db Client ) ; audit Mgr . record Audit Log ( null , null , EVENT SERVICE TYPE , audit Type , System . current Time Millis ( ) , operational Status ? Audit Log Manager . AUDITLOG SUCCESS : Audit Log Manager . AUDITLOG FAILURE , description , descparams ) ; }
public final double radian ( Coords d ) { final Ideal Hex src = Ideal Hex . get ( this ) ; final Ideal Hex dst = Ideal Hex . get ( d ) ; if ( src . cy == dst . cy ) { return ( src . cx < dst . cx ) ? Math . PI / NUM : Math . PI * NUM ; } double r = Math . atan ( ( dst . cx - src . cx ) / ( src . cy - dst . cy ) ) ; if ( src . cy < dst . cy ) { r = ( r + Math . PI ) % ( Math . PI * NUM ) ; } if ( r < NUM ) { r += Math . PI * NUM ; } return r ; }
private static Char Handler parse Unprintable Codes ( String [ ] code Strings ) { if ( code Strings . length != NUM ) { throw new Illegal State Exception ( STRING + Arrays . as List ( code Strings ) ) ; } return new Unprintable Char Handler ( codes To Bytes ( code Strings [ NUM ] , BOOL ) ) ; }
protected void add Pending Join ( Internal Distributed Member id ) { synchronized ( this . pending Joins Lock ) { List old Pending Joins = this . pending Joins ; if ( ! old Pending Joins . contains ( id ) ) { List new Pending Joins = new Array List ( old Pending Joins ) ; new Pending Joins . add ( id ) ; this . pending Joins = new Pending Joins ; } } }
@ Suppress Warnings ( STRING ) public static float percentage To Value ( float percentage , float start Value , float end Value ) { float min = Math . min ( start Value , end Value ) ; float max = Math . max ( start Value , end Value ) ; float delta = max - min ; return ( delta * ( percentage / NUM ) ) + min ; }
public static boolean is Network Connected ( Context context ) { if ( context == null ) { return BOOL ; } Connectivity Manager cm = ( Connectivity Manager ) context . get System Service ( Context . CONNECTIVITY SERVICE ) ; Network Info network Info = cm . get Active Network Info ( ) ; return ( network Info != null && network Info . is Connected ( ) ) ; }
public void modify Item ( int position , Object new Obj ) { if ( is Data List Not Empty ( ) && position < m Data List . size ( ) && position >= NUM ) { m Data List . set ( position , new Obj ) ; notify Item Changed ( position ) ; } }
public static void read From File Channel With Eof Exception ( File Channel channel , long channel Position , Byte Buffer dest ) throws IO Exception { int read = read From File Channel ( channel , channel Position , dest ) ; if ( read < NUM ) { throw new EOF Exception ( STRING + channel Position + STRING + dest . limit ( ) + STRING + channel . size ( ) + STRING ) ; } }
private void apply Image Matrix ( float width , float height , boolean center , boolean animate ) { if ( m Bitmap != null && width > NUM && height > NUM ) { m Image Matrix . invert ( m Image Inverse Matrix ) ; Rect F crop Rect = m Crop Overlay View . get Crop Window Rect ( ) ; m Image Inverse Matrix . map Rect ( crop Rect ) ; m Image Matrix . reset ( ) ; m Image Matrix . post Translate ( ( width - m Bitmap . get Width ( ) ) / NUM , ( height - m Bitmap . get Height ( ) ) / NUM ) ; map Image Points By Image Matrix ( ) ; if ( m Degrees Rotated > NUM ) { m Image Matrix . post Rotate ( m Degrees Rotated , Bitmap Utils . get Rect Center X ( m Image Points ) , Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; } float scale = Math . min ( width / Bitmap Utils . get Rect Width ( m Image Points ) , height / Bitmap Utils . get Rect Height ( m Image Points ) ) ; if ( m Scale Type == Scale Type . FIT CENTER || ( m Scale Type == Scale Type . CENTER INSIDE && scale < NUM ) || ( scale > NUM && m Auto Zoom Enabled ) ) { m Image Matrix . post Scale ( scale , scale , Bitmap Utils . get Rect Center X ( m Image Points ) , Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; } m Image Matrix . post Scale ( m Zoom , m Zoom , Bitmap Utils . get Rect Center X ( m Image Points ) , Bitmap Utils . get Rect Center Y ( m Image Points ) ) ; map Image Points By Image Matrix ( ) ; m Image Matrix . map Rect ( crop Rect ) ; if ( center ) { m Zoom Offset X = width > Bitmap Utils . get Rect Width ( m Image Points ) ? NUM : Math . max ( Math . min ( width / NUM - crop Rect . center X ( ) , - Bitmap Utils . get Rect Left ( m Image Points ) ) , get Width ( ) - Bitmap Utils . get Rect Right ( m Image Points ) ) / m Zoom ; m Zoom Offset Y = height > Bitmap Utils . get Rect Height ( m Image Points ) ? NUM : Math . max ( Math . min ( height / NUM - crop Rect . center Y ( ) , - Bitmap Utils . get Rect Top ( m Image Points ) ) , get Height ( ) - Bitmap Utils . get Rect Bottom ( m Image Points ) ) / m Zoom ; } else { m Zoom Offset X = Math . min ( Math . max ( m Zoom Offset X * m Zoom , - crop Rect . left ) , - crop Rect . right + width ) / m Zoom ; m Zoom Offset Y = Math . min ( Math . max ( m Zoom Offset Y * m Zoom , - crop Rect . top ) , - crop Rect . bottom + height ) / m Zoom ; } m Image Matrix . post Translate ( m Zoom Offset X * m Zoom , m Zoom Offset Y * m Zoom ) ; crop Rect . offset ( m Zoom Offset X * m Zoom , m Zoom Offset Y * m Zoom ) ; m Crop Overlay View . set Crop Window Rect ( crop Rect ) ; map Image Points By Image Matrix ( ) ; if ( animate ) { m Animation . set End State ( m Image Points , m Image Matrix ) ; m Image View . start Animation ( m Animation ) ; } else { m Image View . set Image Matrix ( m Image Matrix ) ; } update Image Bounds ( BOOL ) ; } }
public static void add Startup Listener ( Start Up Listener s ) { s startup Listeners . add ( s ) ; }
public static void close ( @ Nullable Selection Key rsrc , @ Nullable Ignite Logger log ) { if ( rsrc != null ) close ( rsrc . channel ( ) , log ) ; }
public Completable Future < ? > optimize Old Files ( ) { synchronized ( this ) { if ( optimize Old Files ) return Completable Future . completed Future ( null ) ; Completable Future < ? > task = new Completable Future < > ( ) ; Thread thr = new Thread ( null ) ; thr . set Daemon ( BOOL ) ; thr . start ( ) ; pending Tasks . add ( task ) ; optimize Old Files = BOOL ; task . when Complete ( null ) ; return task ; } }
private static Key create DES Key ( final byte [ ] bytes , final int offset ) { final byte [ ] key Bytes = new byte [ NUM ] ; System . arraycopy ( bytes , offset , key Bytes , NUM , NUM ) ; final byte [ ] material = new byte [ NUM ] ; material [ NUM ] = key Bytes [ NUM ] ; material [ NUM ] = ( byte ) ( key Bytes [ NUM ] << NUM | ( key Bytes [ NUM ] & NUM ) > > > NUM ) ; material [ NUM ] = ( byte ) ( key Bytes [ NUM ] << NUM | ( key Bytes [ NUM ] & NUM ) > > > NUM ) ; material [ NUM ] = ( byte ) ( key Bytes [ NUM ] << NUM | ( key Bytes [ NUM ] & NUM ) > > > NUM ) ; material [ NUM ] = ( byte ) ( key Bytes [ NUM ] << NUM | ( key Bytes [ NUM ] & NUM ) > > > NUM ) ; material [ NUM ] = ( byte ) ( key Bytes [ NUM ] << NUM | ( key Bytes [ NUM ] & NUM ) > > > NUM ) ; material [ NUM ] = ( byte ) ( key Bytes [ NUM ] << NUM | ( key Bytes [ NUM ] & NUM ) > > > NUM ) ; material [ NUM ] = ( byte ) ( key Bytes [ NUM ] << NUM ) ; odd Parity ( material ) ; return new Secret Key Spec ( material , STRING ) ; }
protected void write Model File ( ) throws IO Exception { modfile = File . create Temp File ( STRING , STRING ) ; try ( Output Stream Writer fw = new Output Stream Writer ( new File Output Stream ( modfile ) , encoding ) ) { Js Compiler . begin Wrapper ( fw ) ; fw . write ( STRING ) ; Model Encoder . encode Model ( mmg . get Model ( ) , fw ) ; fw . write ( STRING ) ; Js Compiler . end Wrapper ( fw ) ; } finally { } }
public String html All ( boolean set Included ) { String Builder sb = new String Builder ( ) ; for ( Node node : nodes ) { sb . append ( set Included ? node . get Html ( ) : node . get Inner Html ( ) ) ; } return sb . to String ( ) ; }
private boolean scan Expr ( Symbol Table symbol Table , Tokens tokens , String data , int current Offset , int end Offset ) throws XNI Exception { int ch ; int name Offset ; String name Handle = null ; while ( BOOL ) { if ( current Offset == end Offset ) { break ; } ch = data . char At ( current Offset ) ; byte chartype = ( ch >= NUM ) ? CHARTYPE NONASCII : fASCII Char Map [ ch ] ; switch ( chartype ) { case CHARTYPE SLASH : if ( ++ current Offset == end Offset ) { return BOOL ; } add Token ( tokens , Tokens . XPTRTOKEN ELEM CHILD ) ; ch = data . char At ( current Offset ) ; int child = NUM ; while ( ch >= STRING && ch <= STRING ) { child = ( child * NUM ) + ( ch - STRING ) ; if ( ++ current Offset == end Offset ) { break ; } ch = data . char At ( current Offset ) ; } if ( child == NUM ) { report Error ( STRING , new Object [ ] { new Character ( ( char ) ch ) } ) ; return BOOL ; } tokens . add Token ( child ) ; break ; case CHARTYPE DIGIT : case CHARTYPE LETTER : case CHARTYPE MINUS : case CHARTYPE NONASCII : case CHARTYPE OTHER : case CHARTYPE PERIOD : case CHARTYPE UNDERSCORE : name Offset = current Offset ; current Offset = scan NC Name ( data , end Offset , current Offset ) ; if ( current Offset == name Offset ) { report Error ( STRING , new Object [ ] { data } ) ; return BOOL ; } if ( current Offset < end Offset ) { ch = data . char At ( current Offset ) ; } else { ch = - NUM ; } name Handle = symbol Table . add Symbol ( data . substring ( name Offset , current Offset ) ) ; add Token ( tokens , Tokens . XPTRTOKEN ELEM NCNAME ) ; tokens . add Token ( name Handle ) ; break ; } } return BOOL ; }
public void add Line Data ( int input Start Line , String input File Name , int input Line Count , int output Start Line , int output Line Increment ) { int file Index = file Path List . index Of ( input File Name ) ; if ( file Index == - NUM ) throw new Illegal Argument Exception ( STRING + input File Name ) ; if ( output Start Line == NUM ) return ; Line Info li = new Line Info ( ) ; li . set Input Start Line ( input Start Line ) ; li . set Input Line Count ( input Line Count ) ; li . set Output Start Line ( output Start Line ) ; li . set Output Line Increment ( output Line Increment ) ; if ( file Index != last File ID ) li . set Line File ID ( file Index ) ; last File ID = file Index ; line Data . add ( li ) ; }
public String ( java . lang . String Buffer buffer ) { this . offset = NUM ; this . count = buffer . length ( ) ; this . value = new char [ count ] ; buffer . get Chars ( NUM , count , value , NUM ) ; }
public static Range iterate To Find Range Bounds ( XY Dataset dataset , List visible Series Keys , Range x Range , boolean include Interval ) { Param Checks . null Not Permitted ( dataset , STRING ) ; Param Checks . null Not Permitted ( visible Series Keys , STRING ) ; Param Checks . null Not Permitted ( x Range , STRING ) ; double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; if ( include Interval && dataset instanceof OHLC Dataset ) { OHLC Dataset ohlc = ( OHLC Dataset ) dataset ; Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double x = ohlc . get X Value ( series , item ) ; if ( x Range . contains ( x ) ) { double lvalue = ohlc . get Low Value ( series , item ) ; double uvalue = ohlc . get High Value ( series , item ) ; if ( ! Double . is Na N ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . is Na N ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } } } } else if ( include Interval && dataset instanceof Box And Whisker XY Dataset ) { Box And Whisker XY Dataset bx = ( Box And Whisker XY Dataset ) dataset ; Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double x = bx . get X Value ( series , item ) ; if ( x Range . contains ( x ) ) { Number lvalue = bx . get Min Regular Value ( series , item ) ; Number uvalue = bx . get Max Regular Value ( series , item ) ; if ( lvalue != null ) { minimum = Math . min ( minimum , lvalue . double Value ( ) ) ; } if ( uvalue != null ) { maximum = Math . max ( maximum , uvalue . double Value ( ) ) ; } } } } } else if ( include Interval && dataset instanceof Interval XY Dataset ) { Interval XY Dataset ixyd = ( Interval XY Dataset ) dataset ; Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double x = ixyd . get X Value ( series , item ) ; if ( x Range . contains ( x ) ) { double yvalue = ixyd . get Y Value ( series , item ) ; double lvalue = ixyd . get Start Y Value ( series , item ) ; double uvalue = ixyd . get End Y Value ( series , item ) ; if ( ! Double . is Na N ( yvalue ) ) { minimum = Math . min ( minimum , yvalue ) ; maximum = Math . max ( maximum , yvalue ) ; } if ( ! Double . is Na N ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . is Na N ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } } } } else { Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double x = dataset . get X Value ( series , item ) ; double y = dataset . get Y Value ( series , item ) ; if ( x Range . contains ( x ) ) { if ( ! Double . is Na N ( y ) ) { minimum = Math . min ( minimum , y ) ; maximum = Math . max ( maximum , y ) ; } } } } } if ( minimum == Double . POSITIVE INFINITY ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
public Zk Config Manager ( Solr Zk Client zk Client ) { this . zk Client = zk Client ; }
private void create Entity ( SSO Token token , Persistent Object parent Obj , int object Type , Map attributes , String profile Name ) throws UMS Exception , AM Entry Exists Exception , AM Exception { String org DN = get Organization DN ( internal Token , parent Obj . get DN ( ) ) ; Attr Set attr Set = Common Utils . map To Attr Set ( attributes ) ; make Naming First ( attr Set , get Naming Attribute ( object Type ) , profile Name ) ; String ct Name = get Creation Template Name ( object Type ) ; if ( ct Name == null ) { ct Name = STRING ; } Template Manager temp Mgr = Template Manager . get Template Manager ( ) ; Creation Template creation Temp = temp Mgr . get Creation Template ( ct Name , new Guid ( org DN ) , Template Manager . SCOPE ANCESTORS ) ; attr Set = combine O Cs ( creation Temp , attr Set ) ; Persistent Object user = new Persistent Object ( creation Temp , attr Set ) ; try { parent Obj . add Child ( user ) ; } catch ( Access Rights Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING , e ) ; } throw new AM Exception ( token , STRING ) ; } catch ( Entry Already Exists Exception ee ) { if ( Compliance Services Impl . is Compliance User Deletion Enabled ( ) ) { compliance Impl . check If Deleted User ( token , user . get DN ( ) ) ; } if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING , ee ) ; } throw new AM Entry Exists Exception ( token , STRING , ee ) ; } catch ( UMS Exception ue ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STRING + STRING , ue ) ; } process Internal Exception ( token , ue , STRING ) ; } }
private void update Zoning Map ( Un Managed Export Mask mask , List < com . emc . storageos . db . client . model . Initiator > initiators , List < com . emc . storageos . db . client . model . Storage Port > storage Ports ) { Zone Info Map zoning Map = network Device Controller . get Initiators Zone Info Map ( initiators , storage Ports ) ; for ( Zone Info zone Info : zoning Map . values ( ) ) { log . info ( STRING , zone Info . get Zone Name ( ) , zone Info . get Initiator Wwn ( ) , zone Info . get Port Wwn ( ) ) ; } mask . set Zoning Map ( zoning Map ) ; }
public void reject Session ( Invitation Status status ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STRING ) ; } m Invitation Status = status ; synchronized ( m Wait User Answer ) { m Wait User Answer . notify All ( ) ; } }
public void fling ( int start X , int start Y , int velocity X , int velocity Y , int min X , int max X , int min Y , int max Y ) { if ( m Flywheel && ! m Finished ) { float old Vel = get Curr Velocity ( ) ; float dx = ( float ) ( m Final X - m Start X ) ; float dy = ( float ) ( m Final Y - m Start Y ) ; float hyp = ( float ) Math . hypot ( dx , dy ) ; float ndx = dx / hyp ; float ndy = dy / hyp ; float old Velocity X = ndx * old Vel ; float old Velocity Y = ndy * old Vel ; if ( Math . signum ( velocity X ) == Math . signum ( old Velocity X ) && Math . signum ( velocity Y ) == Math . signum ( old Velocity Y ) ) { velocity X += old Velocity X ; velocity Y += old Velocity Y ; } } m Mode = FLING MODE ; m Finished = BOOL ; float velocity = ( float ) Math . hypot ( velocity X , velocity Y ) ; m Velocity = velocity ; m Duration = get Spline Fling Duration ( velocity ) ; m Start Time = Animation Utils . current Animation Time Millis ( ) ; m Start X = start X ; m Start Y = start Y ; float coeff X = velocity == NUM ? NUM : velocity X / velocity ; float coeff Y = velocity == NUM ? NUM : velocity Y / velocity ; double total Distance = get Spline Fling Distance ( velocity ) ; m Distance = ( int ) ( total Distance * Math . signum ( velocity ) ) ; m Min X = min X ; m Max X = max X ; m Min Y = min Y ; m Max Y = max Y ; m Final X = start X + ( int ) Math . round ( total Distance * coeff X ) ; m Final X = Math . min ( m Final X , m Max X ) ; m Final X = Math . max ( m Final X , m Min X ) ; m Final Y = start Y + ( int ) Math . round ( total Distance * coeff Y ) ; m Final Y = Math . min ( m Final Y , m Max Y ) ; m Final Y = Math . max ( m Final Y , m Min Y ) ; }
public static double [ ] create Random Grid Values ( int width , int height , double min , double max , int num Iterations , double smoothness ) { int num Values = width * height ; double [ ] values = new double [ num Values ] ; for ( int i = NUM ; i < num Iterations ; i ++ ) { double offset = NUM - ( i / ( double ) num Iterations ) ; int x1 = ( int ) Math . round ( Math . random ( ) * ( width - NUM ) ) ; int x2 = ( int ) Math . round ( Math . random ( ) * ( width - NUM ) ) ; int y1 = ( int ) Math . round ( Math . random ( ) * ( height - NUM ) ) ; int y2 = ( int ) Math . round ( Math . random ( ) * ( height - NUM ) ) ; int dx 1 = x2 - x1 ; int dy 1 = y2 - y1 ; for ( int y = NUM ; y < height ; y ++ ) { int dy 2 = y - y1 ; for ( int x = NUM ; x < width ; x ++ ) { int dx 2 = x - x1 ; if ( ( dx 2 * dy 1 - dx 1 * dy 2 ) >= NUM ) values [ x + y * width ] += offset ; } } } smooth Values ( width , height , values , smoothness ) ; scale Values ( values , num Values , min , max ) ; return values ; }
private void read ASCII ( final Buffered Reader buffer ) throws Number Format Exception , IO Exception { Raj Log . i ( STRING ) ; final List < Float > vertices = new Array List < Float > ( ) ; final List < Float > normals = new Array List < Float > ( ) ; final float [ ] temp Norms = new float [ NUM ] ; int next Offset , prev Offset , i , insert ; String line ; line = buffer . read Line ( ) ; while ( ( line = buffer . read Line ( ) ) != null ) { if ( line . contains ( STRING ) ) { next Offset = line . last Index Of ( STRING ) ; temp Norms [ NUM ] = Float . parse Float ( line . substring ( next Offset + NUM ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( STRING , prev Offset - NUM ) ; temp Norms [ NUM ] = Float . parse Float ( line . substring ( next Offset + NUM , prev Offset ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( STRING , prev Offset - NUM ) ; temp Norms [ NUM ] = Float . parse Float ( line . substring ( next Offset + NUM , prev Offset ) ) ; for ( i = NUM ; i < NUM ; i ++ ) { normals . add ( temp Norms [ NUM ] ) ; normals . add ( temp Norms [ NUM ] ) ; normals . add ( temp Norms [ NUM ] ) ; } } else if ( line . contains ( STRING ) ) { insert = vertices . size ( ) ; next Offset = line . last Index Of ( STRING ) ; vertices . add ( Float . parse Float ( line . substring ( next Offset + NUM ) ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( STRING , prev Offset - NUM ) ; vertices . add ( insert , Float . parse Float ( line . substring ( next Offset + NUM , prev Offset ) ) ) ; prev Offset = next Offset ; next Offset = line . last Index Of ( STRING , prev Offset - NUM ) ; vertices . add ( insert , Float . parse Float ( line . substring ( next Offset + NUM , prev Offset ) ) ) ; } } float [ ] vertices Arr = new float [ vertices . size ( ) ] ; float [ ] normals Arr = new float [ normals . size ( ) ] ; for ( i = NUM ; i < vertices Arr . length ; i ++ ) { vertices Arr [ i ] = vertices . get ( i ) ; normals Arr [ i ] = normals . get ( i ) ; } vertices . clear ( ) ; normals . clear ( ) ; int [ ] indices Arr = new int [ vertices Arr . length / NUM ] ; for ( i = NUM ; i < indices Arr . length ; i ++ ) indices Arr [ i ] = i ; m Root Object . set Data ( vertices Arr , normals Arr , null , null , indices Arr , BOOL ) ; }
public byte [ ] [ ] generate Keys ( final int nkeys ) { if ( nkeys < NUM ) throw new Illegal Argument Exception ( ) ; if ( nkeys > max Keys ) throw new Illegal Argument Exception ( ) ; final Set < byte [ ] > set = new Tree Set < byte [ ] > ( Bytes Util . Unsigned Byte Array Comparator . INSTANCE ) ; final byte [ ] [ ] keys = new byte [ max Keys ] [ ] ; int n = NUM ; while ( n < max Keys ) { final byte [ ] key = new byte [ r . next Int ( max Key Length ) + NUM ] ; r . next Bytes ( key ) ; if ( set . add ( key ) ) { keys [ n ++ ] = key ; } } Arrays . sort ( keys , Bytes Util . Unsigned Byte Array Comparator . INSTANCE ) ; for ( int i = nkeys ; i < max Keys ; i ++ ) { keys [ i ] = null ; } return keys ; }
@ Override protected void register New Selector ( ) throws IO Exception { synchronized ( selector ) { Set < Selection Key > keys = selector . keys ( ) ; Selector new Selector = null ; if ( selector Provider == null ) { new Selector = Selector . open ( ) ; } else { new Selector = selector Provider . open Selector ( ) ; } for ( Selection Key key : keys ) { Selectable Channel ch = key . channel ( ) ; Nio Session session = ( Nio Session ) key . attachment ( ) ; Selection Key new Key = ch . register ( new Selector , key . interest Ops ( ) , session ) ; session . set Selection Key ( new Key ) ; } selector . close ( ) ; selector = new Selector ; } }
public static Iterator create Shape 3 D ( Shape shape , double baseline Height , Color color , boolean filled ) { int buffer Size = DEFAULT NPOINTS BUFFER SIZE ; double [ ] data = expand Array D ( buffer Size , null ) ; int data Index = NUM ; int refresh Counter = buffer Size ; int [ ] strip Count = new int [ NUM ] ; strip Count [ NUM ] = NUM ; Path Iterator pi 2 = shape . get Path Iterator ( null ) ; float flatness = NUM ; Flattening Path Iterator pi = new Flattening Path Iterator ( pi 2 , flatness ) ; double [ ] coords = new double [ NUM ] ; double pntx = NUM ; double pnty = NUM ; double pntz = baseline Height ; Hash Set set = new Hash Set ( ) ; Shape 3 D shape 3 D = null ; Debug . message ( STRING , STRING ) ; while ( ! pi . is Done ( ) ) { int type = pi . current Segment ( coords ) ; switch ( type ) { case Path Iterator . SEG MOVETO : if ( data Index != NUM ) { shape 3 D = create Shape 3 D ( data , data Index , strip Count , color , filled ) ; if ( shape 3 D != null ) { set . add ( shape 3 D ) ; } data = expand Array D ( buffer Size , null ) ; data Index = NUM ; } case Path Iterator . SEG LINETO : pntx = coords [ NUM ] ; pnty = coords [ NUM ] ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + pntx + STRING + pnty ) ; } if ( data Index >= data . length ) { data = expand Array D ( buffer Size , data ) ; refresh Counter = buffer Size ; } data [ data Index ++ ] = pntx ; data [ data Index ++ ] = pntz ; data [ data Index ++ ] = pnty ; strip Count [ NUM ] ++ ; refresh Counter -= NUM ; break ; default : Debug . message ( STRING , STRING + coords [ NUM ] + STRING + coords [ NUM ] + STRING ) ; } pi . next ( ) ; } if ( data Index != NUM ) { shape 3 D = create Shape 3 D ( data , data Index , strip Count , color , filled ) ; if ( shape 3 D != null ) { set . add ( shape 3 D ) ; } } return set . iterator ( ) ; }
public static String remove Package Name ( String fully qualified name ) { if ( fully qualified name == null ) return null ; int lastdot = fully qualified name . last Index Of ( STRING ) ; if ( lastdot < NUM ) { return STRING ; } else { return fully qualified name . substring ( lastdot + NUM ) ; } }
@ Override public void flip ( W Component Peer peer , Component target , Volatile Image back Buffer , int x1 , int y1 , int x2 , int y2 , Buffer Capabilities . Flip Contents flip Action ) { if ( flip Action == Buffer Capabilities . Flip Contents . COPIED ) { Surface Manager vsm = Surface Manager . get Manager ( back Buffer ) ; Surface Data sd = vsm . get Primary Surface Data ( ) ; if ( sd instanceof WGLV Sync Off Screen Surface Data ) { WGLV Sync Off Screen Surface Data vsd = ( WGLV Sync Off Screen Surface Data ) sd ; Surface Data bbsd = vsd . get Flip Surface ( ) ; Graphics 2 D bbg = new Sun Graphics 2 D ( bbsd , Color . black , Color . white , null ) ; try { bbg . draw Image ( back Buffer , NUM , NUM , null ) ; } finally { bbg . dispose ( ) ; } } else { Graphics g = peer . get Graphics ( ) ; try { g . draw Image ( back Buffer , x1 , y1 , x2 , y2 , x1 , y1 , x2 , y2 , null ) ; } finally { g . dispose ( ) ; } return ; } } else if ( flip Action == Buffer Capabilities . Flip Contents . PRIOR ) { return ; } OGL Surface Data . swap Buffers ( peer . get Data ( ) ) ; if ( flip Action == Buffer Capabilities . Flip Contents . BACKGROUND ) { Graphics g = back Buffer . get Graphics ( ) ; try { g . set Color ( target . get Background ( ) ) ; g . fill Rect ( NUM , NUM , back Buffer . get Width ( ) , back Buffer . get Height ( ) ) ; } finally { g . dispose ( ) ; } } }
public PT Property add Property ( final PT Property property ) { if ( properties . contains ( property ) ) { throw new Illegal Argument Exception ( STRING + property . get Name ( ) + STRING ) ; } properties . add ( property ) ; property . set Parent Table ( this ) ; return property ; }
Speed Predictor ( ) { times = new double [ VECTOR LENGTH ] ; Wt Window Manager wm = Wt Window Manager . get Instance ( ) ; prediction = Math Helper . parse Double Default ( wm . get Property ( SPEED PROPERTY , Double . to String ( INITIAL PREDICTED SPEED ) ) , INITIAL PREDICTED SPEED ) ; jitter = Math Helper . parse Double ( wm . get Property ( JITTER PROPERTY , STRING ) ) ; double average = TURN LENGTH / prediction ; for ( int i = NUM ; i < VECTOR LENGTH ; i ++ ) { times [ i ] = average ; } }
public void write Bytes ( Data Output out ) throws IO Exception { out . write Long ( most Sig ) ; out . write Long ( least Sig ) ; }
public void end Attributes ( ) throws SAX Exception { String uri = get Current Element Uri ( ) ; String local = get Current Element Local ( ) ; String prefix = ns Context . get Prefix ( uri ) ; assert ( prefix != null ) ; String qname ; if ( prefix . length ( ) != NUM ) qname = prefix + STRING + local ; else qname = local ; ns Context . iterate Declared Prefixes ( start Prefix Callback ) ; writer . start Element ( uri , local , qname , attributes ) ; attributes . clear ( ) ; text Buf . set Length ( NUM ) ; }
protected int [ ] read Color Table ( int ncolors ) { int nbytes = NUM * ncolors ; int [ ] tab = null ; byte [ ] c = new byte [ nbytes ] ; int n = NUM ; try { n = in . read ( c ) ; } catch ( IO Exception e ) { } if ( n < nbytes ) { status = STATUS FORMAT ERROR ; } else { tab = new int [ NUM ] ; int i = NUM ; int j = NUM ; while ( i < ncolors ) { int r = c [ j ++ ] & NUM ; int g = c [ j ++ ] & NUM ; int b = c [ j ++ ] & NUM ; tab [ i ++ ] = NUM | ( r << NUM ) | ( g << NUM ) | b ; } } return tab ; }
public static void save To Protected Store ( Private Key private Key , Certificate certificate , File store Location , String alias , String private Key Password , String key Store Password , String key Store Type ) throws IO Exception , Key Store Exception , No Such Provider Exception , No Such Algorithm Exception , Certificate Exception { Key Store store = null ; if ( key Store Type . equals ( STRING ) ) { store = Key Store . get Instance ( key Store Type , Crypto Util . get Security Provider Name ( Key Store . class ) ) ; } else store = Key Store . get Instance ( key Store Type ) ; store . load ( null , null ) ; Certificate [ ] chain = new Certificate [ NUM ] ; chain [ NUM ] = certificate ; if ( private Key Password != null ) store . set Key Entry ( alias , private Key , private Key Password . to Char Array ( ) , chain ) ; else store . set Key Entry ( alias , private Key , null , chain ) ; File Output Stream f Out = new File Output Stream ( store Location ) ; try { store . store ( f Out , key Store Password == null ? null : key Store Password . to Char Array ( ) ) ; } finally { f Out . close ( ) ; } }
public static boolean delete Files ( final File file ) { boolean ok = BOOL ; if ( file != null ) { if ( file . is Directory ( ) ) { final File [ ] files = file . list Files ( ) ; if ( files != null ) { for ( final File f : files ) { if ( f . is File ( ) ) { ok &= f . delete ( ) ; } } } else { ok = BOOL ; } ok &= file . delete ( ) ; } } return ok ; }
protected int draw Legend ( Canvas canvas , Default Renderer renderer , String [ ] titles , int left , int right , int y , int width , int height , int legend Size , Paint paint , boolean calculate ) { float size = NUM ; if ( renderer . is Show Legend ( ) ) { float current X = left ; float current Y = y + height - legend Size + size ; paint . set Text Align ( Align . LEFT ) ; paint . set Text Size ( renderer . get Legend Text Size ( ) ) ; int s Length = Math . min ( titles . length , renderer . get Series Renderer Count ( ) ) ; for ( int i = NUM ; i < s Length ; i ++ ) { Simple Series Renderer r = renderer . get Series Renderer At ( i ) ; final float line Size = get Legend Shape Width ( i ) ; if ( r . is Show Legend Item ( ) ) { String text = titles [ i ] ; if ( titles . length == renderer . get Series Renderer Count ( ) ) { paint . set Color ( r . get Color ( ) ) ; } else { paint . set Color ( Color . LTGRAY ) ; } float [ ] widths = new float [ text . length ( ) ] ; paint . get Text Widths ( text , widths ) ; float sum = NUM ; for ( float value : widths ) { sum += value ; } float extra Size = line Size + NUM + sum ; float current Width = current X + extra Size ; if ( i > NUM && get Exceed ( current Width , renderer , right , width ) ) { current X = left ; current Y += renderer . get Legend Text Size ( ) ; size += renderer . get Legend Text Size ( ) ; current Width = current X + extra Size ; } if ( get Exceed ( current Width , renderer , right , width ) ) { float max Width = right - current X - line Size - NUM ; if ( is Vertical ( renderer ) ) { max Width = width - current X - line Size - NUM ; } int nr = paint . break Text ( text , BOOL , max Width , widths ) ; text = text . substring ( NUM , nr ) + STRING ; } if ( ! calculate ) { draw Legend Shape ( canvas , r , current X , current Y , i , paint ) ; draw String ( canvas , text , current X + line Size + NUM , current Y + NUM , paint ) ; } current X += extra Size ; } } } return Math . round ( size + renderer . get Legend Text Size ( ) ) ; }
public abstract boolean is Search Compatible ( E element , Search Criteria search Criteria , Repository Definition repository Definition ) ;
private void disable Buttons ( ) { set Kick Enabled ( BOOL ) ; set Punch Enabled ( BOOL ) ; set Push Enabled ( BOOL ) ; set Trip Enabled ( BOOL ) ; set Grapple Enabled ( BOOL ) ; set Jump Jet Enabled ( BOOL ) ; set Club Enabled ( BOOL ) ; set Brush Off Enabled ( BOOL ) ; set Thrash Enabled ( BOOL ) ; set Dodge Enabled ( BOOL ) ; set Proto Enabled ( BOOL ) ; set Vibro Enabled ( BOOL ) ; set Explosives Enabled ( BOOL ) ; but Done . set Enabled ( BOOL ) ; set Next Enabled ( BOOL ) ; }
private MGRS Components break MGRS String ( String MGRS String ) { int num digits ; int num letters ; int i = NUM ; int j = NUM ; long error code = MGRS NO ERROR ; int zone = NUM ; int [ ] letters = new int [ NUM ] ; long easting = NUM ; long northing = NUM ; int precision = NUM ; while ( i < MGRS String . length ( ) && MGRS String . char At ( i ) == STRING ) { i ++ ; } j = i ; while ( i < MGRS String . length ( ) && Character . is Digit ( MGRS String . char At ( i ) ) ) { i ++ ; } num digits = i - j ; if ( num digits <= NUM ) if ( num digits > NUM ) { zone = Integer . parse Int ( MGRS String . substring ( j , i ) ) ; if ( ( zone < NUM ) || ( zone > NUM ) ) error code |= MGRS STRING ERROR ; } else error code |= MGRS STRING ERROR ; j = i ; while ( i < MGRS String . length ( ) && Character . is Letter ( MGRS String . char At ( i ) ) ) { i ++ ; } num letters = i - j ; if ( num letters == NUM ) { letters [ NUM ] = alphabet . index Of ( Character . to Upper Case ( MGRS String . char At ( j ) ) ) ; if ( ( letters [ NUM ] == LETTER I ) || ( letters [ NUM ] == LETTER O ) ) error code |= MGRS STRING ERROR ; letters [ NUM ] = alphabet . index Of ( Character . to Upper Case ( MGRS String . char At ( j + NUM ) ) ) ; if ( ( letters [ NUM ] == LETTER I ) || ( letters [ NUM ] == LETTER O ) ) error code |= MGRS STRING ERROR ; letters [ NUM ] = alphabet . index Of ( Character . to Upper Case ( MGRS String . char At ( j + NUM ) ) ) ; if ( ( letters [ NUM ] == LETTER I ) || ( letters [ NUM ] == LETTER O ) ) error code |= MGRS STRING ERROR ; } else error code |= MGRS STRING ERROR ; j = i ; while ( i < MGRS String . length ( ) && Character . is Digit ( MGRS String . char At ( i ) ) ) { i ++ ; } num digits = i - j ; if ( ( num digits <= NUM ) && ( num digits % NUM == NUM ) ) { int n ; double multiplier ; n = num digits / NUM ; precision = n ; if ( n > NUM ) { easting = Integer . parse Int ( MGRS String . substring ( j , j + n ) ) ; northing = Integer . parse Int ( MGRS String . substring ( j + n , j + n + n ) ) ; multiplier = Math . pow ( NUM , NUM - n ) ; easting *= multiplier ; northing *= multiplier ; } else { easting = NUM ; northing = NUM ; } } else error code |= MGRS STRING ERROR ; last error = error code ; if ( error code == MGRS NO ERROR ) return new MGRS Components ( zone , letters [ NUM ] , letters [ NUM ] , letters [ NUM ] , easting , northing , precision ) ; return null ; }
public static String trim ( @ Non Null String str , int start , int end ) { return str . length ( ) > start ? ( str . length ( ) > end ? str . substring ( start , end ) : str . substring ( start ) ) : STRING ; }
private void write Sort Index File ( List < String > data , String column Id ) throws IO Exception { Column Identifier column Identifier = new Column Identifier ( column Id , null , null ) ; Map < String , Integer > data To Surrogate Key Map = new Hash Map < > ( data . size ( ) ) ; int surrogate Key = NUM ; List < Integer > inverted Index List = new Array List < > ( data . size ( ) ) ; for ( int i = NUM ; i < data . size ( ) ; i ++ ) { data To Surrogate Key Map . put ( data . get ( i ) , ++ surrogate Key ) ; } List < String > sorted Key List = new Array List < > ( data To Surrogate Key Map . key Set ( ) ) ; Collections . sort ( sorted Key List ) ; List < Integer > sorted Index List = new Array List < > ( data . size ( ) ) ; int [ ] inverted Index Array = new int [ sorted Key List . size ( ) ] ; for ( int i = NUM ; i < sorted Key List . size ( ) ; i ++ ) { Integer key = data To Surrogate Key Map . get ( sorted Key List . get ( i ) ) ; sorted Index List . add ( key ) ; inverted Index Array [ -- key ] = i + NUM ; } for ( int i = NUM ; i < inverted Index Array . length ; i ++ ) { inverted Index List . add ( inverted Index Array [ i ] ) ; } Carbon Dictionary Sort Index Writer dictionary Sort Index Writer = new Carbon Dictionary Sort Index Writer Impl ( carbon Table Identifier , column Identifier , carbon Store Path ) ; try { dictionary Sort Index Writer . write Sort Index ( sorted Index List ) ; dictionary Sort Index Writer . write Inverted Sort Index ( inverted Index List ) ; } finally { dictionary Sort Index Writer . close ( ) ; } }
private Target create Target ( Element dom Element ) { Feature Definition feat Def = this . feature Definition ; int num Features = feat Def . get Number Of Features ( ) ; int num Byte Features = feat Def . get Number Of Byte Features ( ) ; int num Short Features = feat Def . get Number Of Short Features ( ) ; int num Continious Features = feat Def . get Number Of Continuous Features ( ) ; byte [ ] byte Features = new byte [ num Byte Features ] ; short [ ] short Features = new short [ num Short Features ] ; float [ ] float Features = new float [ num Continious Features ] ; int byte Count = NUM ; int short Count = NUM ; int float Count = NUM ; for ( int i = NUM ; i < num Features ; i ++ ) { String feat Name = feat Def . get Feature Name ( i ) ; String feat Value = STRING ; if ( feat Def . is Byte Feature ( feat Name ) || feat Def . is Short Feature ( feat Name ) ) { if ( dom Element . has Attribute ( feat Name ) ) { feat Value = dom Element . get Attribute ( feat Name ) ; } boolean has Feature = feat Def . has Feature Value ( feat Name , feat Value ) ; if ( ! has Feature ) feat Value = STRING ; if ( feat Def . is Byte Feature ( i ) ) { byte Features [ byte Count ++ ] = feat Def . get Feature Value As Byte ( i , feat Value ) ; } else if ( feat Def . is Short Feature ( i ) ) { short Features [ short Count ++ ] = feat Def . get Feature Value As Short ( i , feat Value ) ; } } else { if ( dom Element . has Attribute ( STRING ) ) { feat Value = dom Element . get Attribute ( STRING ) ; } float Features [ float Count ++ ] = get Meaning Scale Value ( feat Name , feat Value ) ; } } Feature Vector new FV = feat Def . to Feature Vector ( NUM , byte Features , short Features , float Features ) ; String name = STRING ; if ( dom Element . has Attribute ( STRING ) ) { name = dom Element . get Attribute ( STRING ) ; } Target new Target = new Target ( name , dom Element ) ; new Target . set Feature Vector ( new FV ) ; return new Target ; }
public Web Cookie ( String name , String value ) { int length = name . length ( ) ; for ( int i = length - NUM ; i >= NUM ; i -- ) { char ch = name . char At ( i ) ; if ( ch >= NUM || ! valid Char [ ch ] ) throw new Illegal Argument Exception ( STRING + name ) ; else if ( ch == STRING && i == NUM ) throw new Illegal Argument Exception ( STRING ) ; } this . name = name ; this . value = value ; }
public synchronized void sort ( final Comparator < String [ ] > comparator ) { Check . not Null ( comparator , STRING ) ; Collections . sort ( rows , comparator ) ; }
private void write Output File ( String Builder builder ) throws IO Exception { Print Writer writer = new Print Writer ( get Output File ( ) , STRING ) ; writer . write ( builder . to String ( ) ) ; writer . flush ( ) ; writer . close ( ) ; }
public static boolean is XML Name NS ( String name ) { if ( name . length ( ) > NUM && ( ! is Name Start Char ( name . char At ( NUM ) ) || name . char At ( NUM ) == STRING ) ) { return BOOL ; } for ( int i = NUM ; i < name . length ( ) ; i ++ ) { if ( ! is Name Char ( name . char At ( i ) ) || name . char At ( i ) == STRING ) { return BOOL ; } } return BOOL ; }
public PW Reset Exception ( Throwable t ) { super ( t ) ; err List = new Array List ( NUM ) ; err List . add ( t . get Message ( ) ) ; }
public static String [ ] concatenate String Arrays ( String [ ] array 1 , String [ ] array 2 ) { if ( Object Utils . is Empty ( array 1 ) ) { return array 2 ; } if ( Object Utils . is Empty ( array 2 ) ) { return array 1 ; } String [ ] new Arr = new String [ array 1 . length + array 2 . length ] ; System . arraycopy ( array 1 , NUM , new Arr , NUM , array 1 . length ) ; System . arraycopy ( array 2 , NUM , new Arr , array 1 . length , array 2 . length ) ; return new Arr ; }
public boolean to Starting ( ) { Lifecycle State state ; synchronized ( this ) { state = state ; if ( state . is After Starting ( ) && ! state . is Stopped ( ) ) { return BOOL ; } state = STARTING ; last Change Time = Current Time . current Time ( ) ; if ( log != null && log . is Loggable ( level ) && log . is Loggable ( Level . FINER ) ) { log . finer ( STRING + name ) ; } } notify Listeners ( state , STARTING ) ; return BOOL ; }
public Node Set DTM ( Node Iterator iterator , X Path Context xctxt ) { super ( ) ; Node node ; m manager = xctxt . get DTM Manager ( ) ; while ( null != ( node = iterator . next Node ( ) ) ) { int handle = xctxt . get DTM Handle From Node ( node ) ; add Node In Doc Order ( handle , xctxt ) ; } }
public List < Local Date > top ( int n ) { List < Local Date > top = new Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ; Int Arrays . parallel Quick Sort ( values , Reverse Int Comparator . instance ( ) ) ; for ( int i = NUM ; i < n && i < values . length ; i ++ ) { top . add ( Packed Local Date . as Local Date ( values [ i ] ) ) ; } return top ; }
public static String grab Name ( String signature ) { Matcher matcher = sig RE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group Count ( ) != NUM ) logger . error ( STRING , signature ) ; return matcher . group ( NUM ) ; }
protected Metric reduce ( List < Metric > metrics ) { System Assert . require Argument ( metrics != null , STRING ) ; Metric Distiller distiller = new Metric Distiller ( ) ; distiller . distill ( metrics ) ; Map < Long , List < String > > collated = collate ( metrics ) ; Map < Long , String > min Datapoints = reduce ( collated , metrics ) ; String new Metric Name = distiller . get Metric ( ) == null ? default Metric Name : distiller . get Metric ( ) ; Metric new Metric = new Metric ( default Scope , new Metric Name ) ; new Metric . set Display Name ( distiller . get Display Name ( ) ) ; new Metric . set Units ( distiller . get Units ( ) ) ; new Metric . set Tags ( distiller . get Tags ( ) ) ; new Metric . set Datapoints ( min Datapoints ) ; return new Metric ; }
public Instance next Element ( Instances dataset ) { Instance result ; result = null ; if ( is Incremental ( ) ) { if ( m Incremental Buffer != null ) { result = m Incremental Buffer ; m Incremental Buffer = null ; } else { try { result = m Loader . get Next Instance ( dataset ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; result = null ; } } } else { if ( m Batch Counter < m Batch Buffer . num Instances ( ) ) { result = m Batch Buffer . instance ( m Batch Counter ) ; m Batch Counter ++ ; } } if ( result != null ) { result . set Dataset ( dataset ) ; } return result ; }
private static Filter assertion Value 2 Substring Filter ( final String filter String , final String attr Type , final int equal Pos , final int end Pos ) { final byte [ ] value Bytes = get Bytes ( filter String . substring ( equal Pos , end Pos ) ) ; boolean has Escape = BOOL ; final Linked List < Integer > asterisk Positions = new Linked List < > ( ) ; for ( int i = NUM ; i < value Bytes . length ; i ++ ) { if ( value Bytes [ i ] == ASTERISK ) { asterisk Positions . add ( i ) ; } else if ( value Bytes [ i ] == BACKSLASH ) { has Escape = BOOL ; } } if ( asterisk Positions . is Empty ( ) ) { final Localizable Message message = ERR LDAP FILTER SUBSTRING NO ASTERISKS . get ( filter String , equal Pos + NUM , end Pos ) ; throw new Localized Illegal Argument Exception ( message ) ; } Byte String sub Initial ; int first Pos = asterisk Positions . remove First ( ) ; if ( first Pos == NUM ) { sub Initial = null ; } else if ( has Escape ) { final Byte String Builder buffer = new Byte String Builder ( first Pos ) ; escape Hex Chars ( buffer , attr Type , value Bytes , NUM , first Pos , equal Pos ) ; sub Initial = buffer . to Byte String ( ) ; } else { sub Initial = Byte String . wrap ( value Bytes , NUM , first Pos ) ; } final Array List < Byte String > sub Any = new Array List < > ( ) ; for ( final int asterisk Pos : asterisk Positions ) { final int length = asterisk Pos - first Pos - NUM ; if ( has Escape ) { final Byte String Builder buffer = new Byte String Builder ( length ) ; escape Hex Chars ( buffer , attr Type , value Bytes , first Pos + NUM , asterisk Pos , equal Pos ) ; sub Any . add ( buffer . to Byte String ( ) ) ; buffer . clear ( ) ; } else { sub Any . add ( Byte String . wrap ( value Bytes , first Pos + NUM , length ) ) ; } first Pos = asterisk Pos ; } Byte String sub Final ; if ( first Pos == ( value Bytes . length - NUM ) ) { sub Final = null ; } else { final int length = value Bytes . length - first Pos - NUM ; if ( has Escape ) { final Byte String Builder buffer = new Byte String Builder ( length ) ; escape Hex Chars ( buffer , attr Type , value Bytes , first Pos + NUM , value Bytes . length , equal Pos ) ; sub Final = buffer . to Byte String ( ) ; } else { sub Final = Byte String . wrap ( value Bytes , first Pos + NUM , length ) ; } } return new Filter ( new Substrings Impl ( attr Type , sub Initial , sub Any , sub Final ) ) ; }
public Input Builder < T > emit All ( Collection < T > records ) { input . add All ( records ) ; return this ; }
public void handle Button 3 Request ( Request Invocation Event event ) throws Model Control Exception { try { AM View Bean Base vb = ( AM View Bean Base ) get View Bean ( Class . for Name ( ( String ) get Page Session Attribute ( PG ATTR CONFIG PAGE ) ) ) ; remove Page Session Attribute ( PG ATTR CONFIG PAGE ) ; remove Page Session Attribute ( PG ATTR PROPERTY NAMES ) ; pass Pg Session Map ( vb ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( Class Not Found Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }
public JSON Exception ( Throwable cause ) { super ( cause . get Message ( ) ) ; this . cause = cause ; }
public double distance ( Pla Point Int p to point ) { return Math . sqrt ( distance square ( p to point ) ) ; }
private void handle Test Run Failed ( String error Msg ) { error Msg = ( error Msg == null ? STRING : error Msg ) ; Log . i ( LOG TAG , String . format ( STRING , error Msg ) ) ; String test Run Stack Trace = STRING ; if ( ( m Current Test Result != null ) && ( m Current Test Result . is Complete ( ) ) ) { Test Identifier test Id = new Test Identifier ( m Current Test Result . m Test Class , m Current Test Result . m Test Name ) ; Map < String , String > empty Map = Collections . empty Map ( ) ; if ( m Current Test Result . has Stack Trace ( ) ) { test Run Stack Trace = m Current Test Result . get Trace ( ) ; } for ( I Test Run Listener listener : m Test Listeners ) { listener . test Failed ( I Test Run Listener . Test Failure . ERROR , test Id , STRING + test Run Stack Trace ) ; listener . test Ended ( test Id , empty Map ) ; } clear Current Test Result ( ) ; } for ( I Test Run Listener listener : m Test Listeners ) { listener . test Run Failed ( error Msg ) ; listener . test Run Ended ( m Total Run Time , get Run Metrics ( ) ) ; } }
public void start ( int total Seeds , int max NFE ) { this . total Seeds = total Seeds ; this . max NFE = max NFE ; last Seed = NUM ; last NFE = NUM ; current Seed = NUM ; current NFE = NUM ; statistics . clear ( ) ; start Time = System . current Time Millis ( ) ; last Time = start Time ; }
private void verify Signature ( X509 Certificate cert ) throws Cert Path Validator Exception { String msg = STRING ; if ( debug != null ) debug . println ( STRING + msg + STRING ) ; try { cert . verify ( prev Pub Key , sig Provider ) ; } catch ( Signature Exception e ) { throw new Cert Path Validator Exception ( msg + STRING , e , null , - NUM , Basic Reason . INVALID SIGNATURE ) ; } catch ( General Security Exception e ) { throw new Cert Path Validator Exception ( msg + STRING , e ) ; } if ( debug != null ) debug . println ( msg + STRING ) ; }
public static byte [ ] SHA 1 ( final byte [ ] message , final int offset , final int length ) { Message Digest digest ; try { digest = Message Digest . get Instance ( STRING ) ; digest . update ( message , offset , length ) ; final byte [ ] sha 1 = digest . digest ( ) ; return sha 1 ; } catch ( final No Such Algorithm Exception e ) { } return null ; }
public void sort ( Array List < Value [ ] > rows , int offset , int limit ) { int rows Size = rows . size ( ) ; if ( rows . is Empty ( ) || offset >= rows Size || limit == NUM ) { return ; } if ( offset < NUM ) { offset = NUM ; } if ( offset + limit > rows Size ) { limit = rows Size - offset ; } if ( limit == NUM && offset == NUM ) { rows . set ( NUM , Collections . min ( rows , this ) ) ; return ; } Value [ ] [ ] arr = rows . to Array ( new Value [ rows Size ] [ ] ) ; Utils . sort Top N ( arr , offset , limit , this ) ; for ( int i = NUM , end = Math . min ( offset + limit , rows Size ) ; i < end ; i ++ ) { rows . set ( i , arr [ i ] ) ; } }
public static boolean equals ( byte [ ] array 1 , byte [ ] array 2 ) { if ( array 1 == array 2 ) { return BOOL ; } if ( array 1 == null || array 2 == null || array 1 . length != array 2 . length ) { return BOOL ; } for ( int i = NUM ; i < array 1 . length ; i ++ ) { if ( array 1 [ i ] != array 2 [ i ] ) { return BOOL ; } } return BOOL ; }
private byte [ ] write Checked Bytes ( Message Nano proto ) { Checked Message wrapper = new Checked Message ( ) ; wrapper . payload = Message Nano . to Byte Array ( proto ) ; CRC 32 checksum = new CRC 32 ( ) ; checksum . update ( wrapper . payload ) ; wrapper . checksum = checksum . get Value ( ) ; return Message Nano . to Byte Array ( wrapper ) ; }
public static void write Scaled Chart As PNG ( Output Stream out , J Free Chart chart , int width , int height , int width Scale Factor , int height Scale Factor ) throws IO Exception { Param Checks . null Not Permitted ( out , STRING ) ; Param Checks . null Not Permitted ( chart , STRING ) ; double desired Width = width * width Scale Factor ; double desired Height = height * height Scale Factor ; double default Width = width ; double default Height = height ; boolean scale = BOOL ; if ( ( width Scale Factor != NUM ) || ( height Scale Factor != NUM ) ) { scale = BOOL ; } double scale X = desired Width / default Width ; double scale Y = desired Height / default Height ; Buffered Image image = new Buffered Image ( ( int ) desired Width , ( int ) desired Height , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g2 = image . create Graphics ( ) ; if ( scale ) { Affine Transform saved = g2 . get Transform ( ) ; g2 . transform ( Affine Transform . get Scale Instance ( scale X , scale Y ) ) ; chart . draw ( g2 , new Rectangle 2 D . Double ( NUM , NUM , default Width , default Height ) , null , null ) ; g2 . set Transform ( saved ) ; g2 . dispose ( ) ; } else { chart . draw ( g2 , new Rectangle 2 D . Double ( NUM , NUM , default Width , default Height ) , null , null ) ; } out . write ( encode As PNG ( image ) ) ; }
protected boolean play User Sound ( String sound Identifier ) { Object sound = builtin Sounds . get ( sound Identifier ) ; if ( sound == null ) { return BOOL ; } return BOOL ; }
public static Object fetch From DB Sql ( final Connection connection , final String sql Query ) throws SQL Exception { Prepared Statement statement = null ; Result Set result Set = null ; try { statement = connection . prepare Statement ( sql Query ) ; result Set = statement . execute Query ( ) ; if ( result Set != null && result Set . next ( ) ) return result Set . get String ( NUM ) ; else return null ; } catch ( final SQL Exception e ) { final String err Msg = STRING + sql Query + STRING ; LOGGER . error ( err Msg , e ) ; throw new Application Runtime Exception ( err Msg , e ) ; } finally { if ( statement != null ) statement . close ( ) ; if ( result Set != null ) result Set . close ( ) ; } }
public static int find Name ( String name , String [ ] table ) { for ( int i = NUM ; i < table . length ; i ++ ) { if ( name . equals ( table [ i ] ) ) { return i ; } } return - NUM ; }
private static Bitmap transform ( @ Non Null final Matrix scaler , @ Non Null final Bitmap source , final int target Width , final int target Height , final int options ) { final boolean scale Up = ( options & OPTIONS SCALE UP ) != NUM ; final boolean recycle = ( options & OPTIONS RECYCLE INPUT ) != NUM ; int delta X = source . get Width ( ) - target Width ; int delta Y = source . get Height ( ) - target Height ; if ( ! scale Up && ( delta X < NUM || delta Y < NUM ) ) { Bitmap b2 = Bitmap . create Bitmap ( target Width , target Height , Bitmap . Config . ARGB 8888 ) ; Canvas c = new Canvas ( b2 ) ; int delta X Half = Math . max ( NUM , delta X / NUM ) ; int delta Y Half = Math . max ( NUM , delta Y / NUM ) ; final Rect src = new Rect ( delta X Half , delta Y Half , delta X Half + Math . min ( target Width , source . get Width ( ) ) , delta Y Half + Math . min ( target Height , source . get Height ( ) ) ) ; int dst X = ( target Width - src . width ( ) ) / NUM ; int dst Y = ( target Height - src . height ( ) ) / NUM ; final Rect dst = new Rect ( dst X , dst Y , target Width - dst X , target Height - dst Y ) ; c . draw Bitmap ( source , src , dst , null ) ; if ( recycle ) { source . recycle ( ) ; } c . set Bitmap ( null ) ; return b2 ; } float bitmap Width F = source . get Width ( ) ; float bitmap Height F = source . get Height ( ) ; float bitmap Aspect = bitmap Width F / bitmap Height F ; float view Aspect = ( float ) target Width / target Height ; Matrix scaler Matrix = scaler ; if ( bitmap Aspect > view Aspect ) { float scale = target Height / bitmap Height F ; if ( scale < NUM || scale > NUM ) { scaler . set Scale ( scale , scale ) ; } else { scaler Matrix = null ; } } else { float scale = target Width / bitmap Width F ; if ( scale < NUM || scale > NUM ) { scaler . set Scale ( scale , scale ) ; } else { scaler Matrix = null ; } } final Bitmap b1 ; if ( scaler Matrix != null ) { b1 = Bitmap . create Bitmap ( source , NUM , NUM , source . get Width ( ) , source . get Height ( ) , scaler Matrix , BOOL ) ; } else { b1 = source ; } if ( recycle && b1 != source ) { source . recycle ( ) ; } final int dx 1 = Math . max ( NUM , b1 . get Width ( ) - target Width ) ; final int dy 1 = Math . max ( NUM , b1 . get Height ( ) - target Height ) ; final Bitmap b2 = Bitmap . create Bitmap ( b1 , dx 1 / NUM , dy 1 / NUM , target Width , target Height ) ; if ( b2 != b1 ) { if ( recycle || b1 != source ) { b1 . recycle ( ) ; } } return b2 ; }
private void score Waypoint Results ( Collection < Waypoint > waypoints , Search Query query , Collection < Scored Result > output ) { for ( Waypoint waypoint : waypoints ) { double score = score Waypoint Result ( query , waypoint ) ; output . add ( new Scored Result ( waypoint , score ) ) ; } }
private Long life Remaining ( ) { return maximum Life Millis - ( System . current Time Millis ( ) - start Up Time ) ; }
public void test Doubles Compare ( ) { Bytes Ref left = new Bytes Ref ( new byte [ Double . BYTES ] ) ; Bytes Ref right = new Bytes Ref ( new byte [ Double . BYTES ] ) ; for ( int i = NUM ; i < NUM ; i ++ ) { double left Value = Double . long Bits To Double ( Test Util . next Long ( random ( ) , Long . MIN VALUE , Long . MAX VALUE ) ) ; Numeric Utils . long To Sortable Bytes ( Numeric Utils . double To Sortable Long ( left Value ) , left . bytes , left . offset ) ; double right Value = Double . long Bits To Double ( Test Util . next Long ( random ( ) , Long . MIN VALUE , Long . MAX VALUE ) ) ; Numeric Utils . long To Sortable Bytes ( Numeric Utils . double To Sortable Long ( right Value ) , right . bytes , right . offset ) ; assert Equals ( Integer . signum ( Double . compare ( left Value , right Value ) ) , Integer . signum ( left . compare To ( right ) ) ) ; } }
public static void put Object Volatile ( Object obj , long off , Object val ) { UNSAFE . put Object Volatile ( obj , off , val ) ; }
public void filled Circle ( double x , double y , double r ) { if ( r < NUM ) throw new Illegal Argument Exception ( STRING ) ; double xs = scale X ( x ) ; double ys = scale Y ( y ) ; double ws = factor X ( NUM * r ) ; double hs = factor Y ( NUM * r ) ; if ( ws <= NUM && hs <= NUM ) pixel ( x , y ) ; else offscreen . fill ( new Ellipse 2 D . Double ( xs - ws / NUM , ys - hs / NUM , ws , hs ) ) ; draw ( ) ; }
final public void println ( int v ) { Writer out = this . out ; if ( out == null ) return ; print ( v ) ; try { out . write ( newline , NUM , newline . length ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } }
public void write SI 16 ( short value ) throws IO Exception { flush Bits ( ) ; out . write ( value & NUM ) ; out . write ( value > > NUM ) ; bytes Written += NUM ; }
public static final String Builder trim ( final String Builder content buffer ) { char c ; final int length = content buffer . length ( ) ; for ( int i = length - NUM ; i > - NUM ; i -- ) { c = content buffer . char At ( i ) ; if ( c == STRING ) { content buffer . delete Char At ( i ) ; } else { i = - NUM ; } } return content buffer ; }
public static boolean is Button Pressed ( Input Event e , int button ) { return ( e . get Modifiers ( ) & button ) == button ; }
private void fill XML Attributes ( Start Element event ) { f Attributes . remove All Attributes ( ) ; final Iterator attrs = event . get Attributes ( ) ; while ( attrs . has Next ( ) ) { Attribute attr = ( Attribute ) attrs . next ( ) ; fill Q Name ( f Attribute Q Name , attr . get Name ( ) ) ; String type = attr . get DTD Type ( ) ; int idx = f Attributes . get Length ( ) ; f Attributes . add Attribute NS ( f Attribute Q Name , ( type != null ) ? type : XML Symbols . fCDATA Symbol , attr . get Value ( ) ) ; f Attributes . set Specified ( idx , attr . is Specified ( ) ) ; } }
public void collect And Set Properties ( ) { if ( property Consumer != null ) { String prefix = property Consumer . get Property Prefix ( ) ; Properties props = collect Properties ( ) ; property Consumer . set Properties ( prefix , props ) ; } }
public void copy Header ( Input Stream in , Output Stream out ) throws IO Exception { Buffered Input Stream is = new Buffered Input Stream ( in ) ; byte [ ] buf = new byte [ NUM * NUM ] ; int bytes Read ; while ( ( bytes Read = is . read ( buf ) ) != - NUM ) { out . write ( buf , NUM , bytes Read ) ; } }
private static Date read Date ( Data Input data Input ) throws IO Exception { if ( data Input . read Int ( ) != NUM ) { throw new Illegal State Exception ( STRING ) ; } byte [ ] buffer = new byte [ NUM ] ; data Input . read Fully ( buffer ) ; return unpack Date ( buffer ) ; }
public < Annotation Type extends Annotation > void register ( Type Binder < Annotation Type > type Binder ) { @ Nullable Annotated Type < Annotation Type > annotated Type = Annotated Types . get ( type Binder . get Annotation Class ( ) , this . annotated Type ) ; if ( annotated Type != null ) { object Binders . add ( new Annotated Type Binder < > ( type Binder , annotated Type ) ) ; } }
public static boolean some Permission Permanently Denied ( Object object , List < String > denied Permissions ) { for ( String denied Permission : denied Permissions ) { if ( permission Permanently Denied ( object , denied Permission ) ) { return BOOL ; } } return BOOL ; }
@ Override protected void prepare Builders ( @ Nullable String cache Name , Collection < Jdbc Type > types ) throws Cache Exception { Map < String , Pojo Properties Cache > pojo Props = U . new Hash Map ( types . size ( ) * NUM ) ; for ( Jdbc Type type : types ) { String key Type Name = type . get Key Type ( ) ; Type Kind key Kind = kind For Name ( key Type Name ) ; if ( key Kind == Type Kind . POJO ) { if ( pojo Props . contains Key ( key Type Name ) ) throw new Cache Exception ( STRING + U . mask Name ( cache Name ) + STRING + key Type Name + STRING ) ; pojo Props . put ( key Type Name , new Pojo Properties Cache ( key Type Name , type . get Key Fields ( ) ) ) ; } String val Type Name = type . get Value Type ( ) ; Type Kind val Kind = kind For Name ( val Type Name ) ; if ( val Kind == Type Kind . POJO ) pojo Props . put ( val Type Name , new Pojo Properties Cache ( val Type Name , type . get Value Fields ( ) ) ) ; } if ( ! pojo Props . is Empty ( ) ) { Map < String , Map < String , Pojo Properties Cache > > new Pojos Props = new Hash Map < > ( pojos Props ) ; new Pojos Props . put ( cache Name , pojo Props ) ; pojos Props = new Pojos Props ; } }
public void add PSR ( Piloting Roll Data psr ) { pilot Rolls . add Element ( psr ) ; }
public void add Results ( Add On Changes Result result ) { selected Add Ons . add All ( result . get Selected Add Ons ( ) ) ; old Versions . add All ( result . old Versions ) ; uninstalls . add All ( result . get Uninstalls ( ) ) ; new Versions . add All ( result . get New Versions ( ) ) ; installs . add All ( result . get Installs ( ) ) ; optional Add Ons . add All ( result . get Optional Add Ons ( ) ) ; unload Extensions . add All ( result . get Unload Extensions ( ) ) ; soft Unload Extensions . add All ( result . get Soft Unload Extensions ( ) ) ; }
private void rederive Color ( ) { Color src = UI Manager . get Color ( ui Default Parent Name ) ; if ( src != null ) { float [ ] tmp = Color . RG Bto HSB ( src . get Red ( ) , src . get Green ( ) , src . get Blue ( ) , null ) ; tmp [ NUM ] = clamp ( tmp [ NUM ] + h Offset ) ; tmp [ NUM ] = clamp ( tmp [ NUM ] + s Offset ) ; tmp [ NUM ] = clamp ( tmp [ NUM ] + b Offset ) ; int alpha = clamp ( src . get Alpha ( ) + a Offset ) ; argb Value = ( Color . HS Bto RGB ( tmp [ NUM ] , tmp [ NUM ] , tmp [ NUM ] ) & NUM ) | ( alpha << NUM ) ; } else { float [ ] tmp = new float [ NUM ] ; tmp [ NUM ] = clamp ( h Offset ) ; tmp [ NUM ] = clamp ( s Offset ) ; tmp [ NUM ] = clamp ( b Offset ) ; int alpha = clamp ( a Offset ) ; argb Value = ( Color . HS Bto RGB ( tmp [ NUM ] , tmp [ NUM ] , tmp [ NUM ] ) & NUM ) | ( alpha << NUM ) ; } }
public final void increase Idle Count ( Idle Status status , long current Time ) { if ( status == Idle Status . BOTH IDLE ) { idle Count For Both . increment And Get ( ) ; last Idle Time For Both = current Time ; } else if ( status == Idle Status . READER IDLE ) { idle Count For Read . increment And Get ( ) ; last Idle Time For Read = current Time ; } else if ( status == Idle Status . WRITER IDLE ) { idle Count For Write . increment And Get ( ) ; last Idle Time For Write = current Time ; } else { throw new Illegal Argument Exception ( STRING + status ) ; } }
private void add Span ( Cache Span span ) { Tree Set < Cache Span > spans For Key = cached Spans . get ( span . key ) ; if ( spans For Key == null ) { spans For Key = new Tree Set < > ( ) ; cached Spans . put ( span . key , spans For Key ) ; } spans For Key . add ( span ) ; total Space += span . length ; notify Span Added ( span ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return BOOL ; if ( ! ( obj instanceof DNS Name ) ) return BOOL ; DNS Name other = ( DNS Name ) obj ; return name . equals Ignore Case ( other . name ) ; }
private void repaint Children ( final Rectangle r ) { final Rectangle content = get Content Size ( ) ; for ( final LW Component Peer < ? , ? > child : get Children ( ) ) { final Rectangle child Bounds = child . get Bounds ( ) ; Rectangle to Paint = r . intersection ( child Bounds ) ; to Paint = to Paint . intersection ( content ) ; to Paint . translate ( - child Bounds . x , - child Bounds . y ) ; child . repaint Peer ( to Paint ) ; } }
private String match ( Pattern re ) { if ( index >= input . length ( ) ) { return null ; } Matcher matcher = re . matcher ( input ) ; matcher . region ( index , input . length ( ) ) ; boolean m = matcher . find ( ) ; if ( m ) { index = matcher . end ( ) ; return matcher . group ( ) ; } else { return null ; } }
public static String [ ] split String ( final String str , final char split Char ) { final int length = str . length ( ) ; final String Builder bulder = new String Builder ( Math . max ( NUM , length ) ) ; int counter = NUM ; for ( int i = NUM ; i < length ; i ++ ) { if ( str . char At ( i ) == split Char ) { counter ++ ; } } final String [ ] result = new String [ counter ] ; int position = NUM ; for ( int i = NUM ; i < length ; i ++ ) { final char chr = str . char At ( i ) ; if ( chr == split Char ) { result [ position ++ ] = bulder . to String ( ) ; bulder . set Length ( NUM ) ; } else { bulder . append ( chr ) ; } } if ( position < result . length ) { result [ position ] = bulder . to String ( ) ; } return result ; }
public static String format Reddit Url ( String url ) { url = url . replace First ( STRING , STRING ) ; if ( url . matches ( STRING ) ) { String subdomain = url . split ( STRING , NUM ) [ NUM ] ; String domain Regex = STRING + subdomain + STRING ; if ( subdomain . equals Ignore Case ( STRING ) ) { url = url . replace First ( domain Regex , STRING ) ; url = STRING + url ; } else if ( subdomain . matches ( STRING ) ) { return STRING ; } else if ( subdomain . matches ( STRING ) ) { url = url . replace First ( domain Regex , STRING ) ; } else { url = url . replace First ( domain Regex , STRING + subdomain ) ; } } if ( url . starts With ( STRING ) ) url = STRING + url ; if ( url . ends With ( STRING ) ) url = url . substring ( NUM , url . length ( ) - NUM ) ; if ( url . matches ( STRING ) ) { url = url . replace First ( STRING , STRING ) ; } return url ; }
public static String extract CSV Output Line Freq ( String csv Out ) { String tokens [ ] = csv Out . split ( STRING , - NUM ) ; return tokens [ NUM ] ; }
public void connect ( String server , int port , Map < String , Object > connection Params , I Pending Service Callback connect Callback , Object [ ] connect Call Arguments ) { log . debug ( STRING , new Object [ ] { server , port , connection Params , connect Callback , Arrays . to String ( connect Call Arguments ) } ) ; log . info ( STRING , new Object [ ] { scheme , server , port , connection Params . get ( STRING ) } ) ; this . connection Params = connection Params ; this . connect Arguments = connect Call Arguments ; if ( ! connection Params . contains Key ( STRING ) ) { connection Params . put ( STRING , NUM ) ; } this . connect Callback = connect Callback ; start Connector ( server , port ) ; }
@ Suppress Warnings ( STRING ) public static boolean check E Tag Validators ( final Http Servlet Request req , final Http Servlet Response resp , final Method req Method , final String etag ) { final List < String > if None Match List = Collections . list ( req . get Headers ( STRING ) ) ; if ( if None Match List . size ( ) > NUM && is Matching Etag ( if None Match List , etag ) ) { if ( req Method == Method . GET || req Method == Method . HEAD ) { send Not Modified ( resp ) ; } else { send Precondition Failed ( resp ) ; } return BOOL ; } final List < String > if Match List = Collections . list ( req . get Headers ( STRING ) ) ; if ( if Match List . size ( ) > NUM && ! is Matching Etag ( if Match List , etag ) ) { send Precondition Failed ( resp ) ; return BOOL ; } return BOOL ; }
public List < Ivr Zone > show Active Ivr Zone ( ) throws Network Device Controller Exception { return show Ivr Zones ( BOOL ) ; }
@ Suppress Warnings ( STRING ) public static < K > Immutable Array 3 < K > empty ( ) { return ( Immutable Array 3 < K > ) EMPTY ; }
void place At Position ( final I Group Member Node node , final Integer position To Place ) { if ( position To Place == null ) { non Optional Non Minus Nodes . add Last ( node ) ; } else { non Optional Non Minus Nodes . add ( position To Place , node ) ; } }
public static String to String ( final B Op bop ) { final String Builder sb = new String Builder ( ) ; to String ( bop , sb , NUM ) ; sb . set Length ( sb . length ( ) - NUM ) ; return sb . to String ( ) ; }
@ Override public int hash Code ( ) { int hash = ( ( time . to Second Of Day ( ) + ( time End Of Day ? NUM : NUM ) ) << NUM ) + ( month . ordinal ( ) << NUM ) + ( ( dom + NUM ) << NUM ) + ( ( dow == null ? NUM : dow . ordinal ( ) ) << NUM ) + ( time Definition . ordinal ( ) ) ; return hash ^ standard Offset . hash Code ( ) ^ offset Before . hash Code ( ) ^ offset After . hash Code ( ) ; }
public boolean delete Edge Reference ( Atlas Edge edge , Data Types . Type Category type Category , boolean is Composite , boolean force Delete Struct Trait ) throws Atlas Exception { LOG . debug ( STRING , string ( edge ) ) ; boolean force Delete = ( type Category == Data Types . Type Category . STRUCT || type Category == Data Types . Type Category . TRAIT ) ? force Delete Struct Trait : BOOL ; if ( type Category == Data Types . Type Category . STRUCT || type Category == Data Types . Type Category . TRAIT || ( type Category == Data Types . Type Category . CLASS && is Composite ) ) { Atlas Vertex vertex For Delete = edge . get In Vertex ( ) ; delete Edge ( edge , BOOL , force Delete ) ; delete Type Vertex ( vertex For Delete , type Category , force Delete ) ; } else { delete Edge ( edge , BOOL , BOOL ) ; } return ! soft Delete || force Delete ; }
private static List < String > read Lines ( Reader in ) throws IO Exception { List < String > lines = new Array List < > ( ) ; try { Buffered Reader bin = new Buffered Reader ( in ) ; for ( String line = null ; ( line = bin . read Line ( ) ) != null ; lines . add ( line ) ) { } } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IO Exception var 2 ) { } } } return lines ; }
private Platform Target create Platform Cache ( Ignite Cache Proxy cache ) { return new Platform Cache ( platform Ctx , cache , BOOL , cache Exts ) ; }
@ Override public boolean should Use Fully Qualified Name ( @ Not Null Psi File target File , @ Not Null String class Qualified Name ) { if ( class Qualified Name . equals ( CLASS R ) || class Qualified Name . starts With ( CLASS R PREFIX ) ) { return BOOL ; } int index = class Qualified Name . last Index Of ( STRING ) ; if ( index == class Qualified Name . length ( ) - NUM && class Qualified Name . char At ( index + NUM ) == STRING ) { String pkg = get Application Package ( target File ) ; if ( pkg != null ) { return ! is Resource Class Reference ( class Qualified Name , pkg + STRING ) ; } } else if ( index > NUM && class Qualified Name . char At ( index - NUM ) == STRING && class Qualified Name . char At ( index - NUM ) == STRING ) { return class Qualified Name . starts With ( CLASS R ) || Resource Type . get Enum ( class Qualified Name . substring ( index + NUM ) ) != null ; } return BOOL ; }
public int compare To ( Object other ) { return name . compare To ( ( ( Turnout Operation ) other ) . name ) ; }
@ Override public boolean is Modified ( ) { long now = Current Time . current Time ( ) ; long last Check Time = last Check Time . get ( ) ; if ( now <= last Check Time + check Interval ) { return is Modified ; } if ( ! last Check Time . compare And Set ( last Check Time , now ) ) { return is Modified ; } if ( is Modified Impl ( ) ) { is Modified = BOOL ; } else { is Modified = BOOL ; } return is Modified ; }
protected void store Image Replaced Element ( Element e , Replaced Element cc , String uri , final int css Width , final int css Height ) { if ( image Components == null ) { image Components = new Hash Map ( ) ; } Cache Key key = new Cache Key ( e , uri , css Width , css Height ) ; image Components . put ( key , cc ) ; }
public boolean is Client Newer Than ( String version ) { if ( client Version == null ) { return BOOL ; } return Version . compare ( client Version , version ) > NUM ; }
@ Override public Connection Pool Data Source create Connection Pool Data Source ( Properties properties ) throws SQL Exception { Properties properties Copy = new Properties ( ) ; if ( properties != null ) { properties Copy . put All ( properties ) ; } reject Unsupported Options ( properties Copy ) ; reject Pooling Options ( properties Copy ) ; Jdbc Data Source data Source = new Jdbc Data Source ( ) ; setup H 2 Data Source ( data Source , properties Copy ) ; return data Source ; }
private void record Visit Field ( Object object , Field object Field , Field field ) { Map < String , Set < String > > bag = visited Fields . get ( object ) ; if ( bag == null ) { bag = new Hash Map < > ( ) ; visited Fields . put ( object , bag ) ; } Set < String > fields = bag . get ( object Field ) ; String object Filed Key = object Field == null ? STRING : object Field . to Generic String ( ) ; if ( fields == null ) { fields = new Hash Set < > ( ) ; bag . put ( object Filed Key , fields ) ; } fields . add ( field . to Generic String ( ) ) ; }
private void snap In Center ( ) { final View Item current Item = m View Item [ m Current Item ] ; final int current View Center = current Item . get Center X ( ) ; if ( m Controller . is Scrolling ( ) || m Is User Scrolling || m Center X == current View Center ) { return ; } int snap In Time = ( int ) ( SNAP IN CENTER TIME MS * ( ( float ) Math . abs ( m Center X - current View Center ) ) / m Draw Area . width ( ) ) ; m Controller . scroll To Position ( current View Center , snap In Time , BOOL ) ; if ( get Current View Type ( ) == Image Data . VIEW TYPE STICKY && ! m Controller . is Scaling ( ) && m Scale != FULL SCREEN SCALE ) { m Controller . go To Full Screen ( ) ; } }
public void delete Meta Object ( int index ) { Meta Objects . set ( index , null ) ; }
private String quote Terminals ( String words ) { String Builder quoted Words = new String Builder ( ) ; for ( String word : words . split ( STRING ) ) if ( word . starts With ( STRING ) && word . ends With ( STRING ) ) quoted Words . append ( String . format ( STRING , word ) ) ; else quoted Words . append ( String . format ( STRING , word ) ) ; return quoted Words . substring ( NUM , quoted Words . length ( ) - NUM ) ; }
public synchronized void remove Recent Item ( T item ) { item = from String ( to String ( item ) ) ; m Recent Items . remove ( item ) ; if ( m Ignore Changes ) return ; write Props ( ) ; update Menu ( ) ; }
public void test Invoke All 3 ( ) throws Interrupted Exception { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new Array List < Callable < String > > ( ) ; l . add ( new String Task ( ) ) ; l . add ( null ) ; try { e . invoke All ( l ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public Lib Package add ( String p name , Lib Package Pin [ ] p pin arr , Pla Shape [ ] p outline , Dsn Package Keepout [ ] p keepout arr , Dsn Package Keepout [ ] p via keepout arr , Dsn Package Keepout [ ] p place keepout arr , boolean p is front ) { Lib Package new package = new Lib Package ( p name , pkg count ( ) + NUM , p pin arr , p outline , p keepout arr , p via keepout arr , p place keepout arr , p is front , this ) ; package list . add ( new package ) ; return new package ; }
@ Override public void close ( ) throws IO Exception { Input Stream input = m streams . get ( ) ; if ( null != input ) { input . close ( ) ; } }
private void create Block Snapshot Data ( String name , int num Snapshots ) throws Exception { Volume volume = new Volume ( ) ; URI volume URI = URI Util . create Id ( Volume . class ) ; test Volume UR Is . add ( volume URI ) ; volume . set Id ( volume URI ) ; String vol Name = STRING ; volume . set Label ( vol Name ) ; URI cg Uri = create Block Consistency Group ( vol Name + STRING ) ; volume . set Consistency Group ( cg Uri ) ; db Client . create Object ( volume ) ; for ( int i = NUM ; i <= num Snapshots ; i ++ ) { Block Snapshot block Snapshot = new Block Snapshot ( ) ; URI block Snapshot URI = URI Util . create Id ( Block Snapshot . class ) ; test Block Snapshot UR Is . add ( block Snapshot URI ) ; block Snapshot . set Id ( block Snapshot URI ) ; block Snapshot . set Label ( name + i ) ; block Snapshot . set Snapset Label ( name + i ) ; block Snapshot . set Parent ( new Named URI ( volume . get Id ( ) , name + i ) ) ; block Snapshot . set Consistency Group ( cg Uri ) ; db Client . create Object ( block Snapshot ) ; Block Snapshot query Snap = db Client . query Object ( Block Snapshot . class , block Snapshot URI ) ; } }
@ Override public synchronized void stop ( ) { if ( running ) { LOGGER . info ( STRING ) ; for ( Endpoint ep : endpoints ) { ep . stop ( ) ; } running = BOOL ; } }
public Json Array add ( String value ) { values . add ( value Of ( value ) ) ; return this ; }
public boolean retain All ( Abstract Long List other ) { if ( other . size ( ) == NUM ) { if ( size == NUM ) return BOOL ; set Size ( NUM ) ; return BOOL ; } int limit = other . size ( ) - NUM ; int j = NUM ; for ( int i = NUM ; i < size ; i ++ ) { if ( other . index Of From To ( get Quick ( i ) , NUM , limit ) >= NUM ) set Quick ( j ++ , get Quick ( i ) ) ; } boolean modified = ( j != size ) ; set Size ( j ) ; return modified ; }
private void update ( ) { list Data . clear ( ) ; for ( String game : search Result ) { list Data . add Element ( game ) ; } if ( ! search Result . is Empty ( ) && ! favorites . is Empty ( ) ) { list Data . add Element ( STRING ) ; } for ( String game : favorites ) { list Data . add Element ( game ) ; } search Result Info . set Text ( STRING + search Result . size ( ) + STRING + STRING + favorites . size ( ) + STRING ) ; list . set Selected Value ( game Input . get Text ( ) , BOOL ) ; }
public static String explode ( Collection < String > collection , String delimiter ) { String Builder sb = new String Builder ( ) ; if ( ! collection . is Empty ( ) ) { Iterator < String > i = collection . iterator ( ) ; sb . append ( i . next ( ) ) ; while ( i . has Next ( ) ) { sb . append ( delimiter ) ; sb . append ( i . next ( ) ) ; } } return sb . to String ( ) ; }
public static int between ( int val , int min , int max ) { return Math . max ( Math . min ( val , max ) , min ) ; }
protected long write Data To File ( Node Holder node Holder , File Channel channel ) throws Carbon Data Writer Exception { byte [ ] [ ] compressed Index = node Holder . get Compressed Index ( ) ; byte [ ] [ ] compressed Index Map = node Holder . get Compressed Index Map ( ) ; byte [ ] [ ] compressed Data Index = node Holder . get Compressed Data Index ( ) ; int index Block Size = NUM ; int index = NUM ; for ( int i = NUM ; i < node Holder . get Key Block Index Length ( ) . length ; i ++ ) { index Block Size += node Holder . get Key Block Index Length ( ) [ index ++ ] + Carbon Common Constants . INT SIZE IN BYTE ; } for ( int i = NUM ; i < node Holder . get Data Index Map Length ( ) . length ; i ++ ) { index Block Size += node Holder . get Data Index Map Length ( ) [ i ] ; } Byte Buffer byte Buffer = Byte Buffer . allocate ( node Holder . get Key Array ( ) . length + node Holder . get Data Array ( ) . length + index Block Size ) ; long offset = NUM ; try { offset = channel . size ( ) ; byte Buffer . put ( node Holder . get Key Array ( ) ) ; byte Buffer . put ( node Holder . get Data Array ( ) ) ; Byte Buffer buffer 1 = null ; for ( int i = NUM ; i < compressed Index . length ; i ++ ) { buffer 1 = Byte Buffer . allocate ( node Holder . get Key Block Index Length ( ) [ i ] ) ; buffer 1 . put Int ( compressed Index [ i ] . length ) ; buffer 1 . put ( compressed Index [ i ] ) ; if ( compressed Index Map [ i ] . length > NUM ) { buffer 1 . put ( compressed Index Map [ i ] ) ; } buffer 1 . rewind ( ) ; byte Buffer . put ( buffer 1 . array ( ) ) ; } for ( int i = NUM ; i < compressed Data Index . length ; i ++ ) { byte Buffer . put ( compressed Data Index [ i ] ) ; } byte Buffer . flip ( ) ; channel . write ( byte Buffer ) ; } catch ( IO Exception exception ) { throw new Carbon Data Writer Exception ( STRING , exception ) ; } return offset ; }
static void append Lang Item ( XMP Node array Node , String item Lang , String item Value ) throws XMP Exception { XMP Node new Item = new XMP Node ( ARRAY ITEM NAME , item Value , null ) ; XMP Node lang Qual = new XMP Node ( XML LANG , item Lang , null ) ; new Item . add Qualifier ( lang Qual ) ; if ( ! X DEFAULT . equals ( lang Qual . get Value ( ) ) ) { array Node . add Child ( new Item ) ; } else { array Node . add Child ( NUM , new Item ) ; } }
public boolean is Discard If File Altered ( String frame ID ) { return discard If File Altered Frames . contains ( frame ID ) ; }
public String [ ] parse Configuration ( URL xml URL ) throws IO Exception , SAX Exception { Input Stream is = xml URL . open Stream ( ) ; Document document = null ; try { document = builder . parse ( is ) ; } finally { is . close ( ) ; } return ( parse Configuration ( document ) ) ; }
public double empirical HSIC ( Tetrad Matrix Ky , Tetrad Matrix Kx , int m ) { Tetrad Matrix Kyx = Ky . times ( Kx ) ; double emp HSIC = NUM ; for ( int i = NUM ; i < m ; i ++ ) { emp HSIC += Kyx . get ( i , i ) ; } emp HSIC /= Math . pow ( m - NUM , NUM ) ; return emp HSIC ; }
protected void load Frame Information ( Rpf Toc Entry rpf Toc Entry ) { try { if ( bin File == null && a Toc File Path != null ) { bin File = new Binary Buffered File ( a Toc File Path ) ; bin File . byte Order ( a Toc Byte Order ) ; read Frame Information ( bin File , rpf Toc Entry ) ; bin File . close ( ) ; bin File = null ; } } catch ( IO Exception ioe ) { Debug . error ( STRING + ioe ) ; } catch ( Format Exception fe ) { Debug . error ( STRING + fe ) ; } }
void send Audio Events ( Object event , List listeners ) { if ( ( listeners == null ) || ( listeners . size ( ) == NUM ) ) { return ; } start ( ) ; Event Info event Info = new Event Info ( event , listeners ) ; post Event ( event Info ) ; }
private void compose Page JPG ( File output File ) throws Exception { File file Memory Block JPG = null ; Buffered Image image Blocks = new Buffered Image ( memory Width , memory Height , Buffered Image . TYPE INT RGB ) ; Graphics graphics = image Blocks . get Graphics ( ) ; Buffered Image image = null ; for ( int i = memory Block Processed ; i < memory Block Total ; i ++ ) { file Memory Block JPG = new File ( path , prefix + STRING + i + STRING ) ; image = Image IO . read ( file Memory Block JPG ) ; graphics . draw Image ( Image IO . read ( file Memory Block JPG ) , NUM , memory Row , null ) ; file Memory Block JPG . delete ( ) ; memory Row += image . get Height ( ) ; } image Blocks . flush ( ) ; graphics . dispose ( ) ; num Page ++ ; Image IO . write ( image Blocks , STRING , output File ) ; add Temp File ( output File ) ; add Scan File ( output File ) ; }
public final void add Path ( @ Not Null Android Studio Wizard Path path ) { my Paths . add ( path ) ; path . attach To Wizard ( this ) ; my Path List Iterator = new Path Iterator ( my Paths ) ; }
protected boolean attach Input ( Input Stream is ) { boolean is Ofx 1 = BOOL ; boolean result = BOOL ; try { Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( is ) ) ; reader . mark ( HEADER SIZE + NUM ) ; String header = STRING ; for ( int i = NUM ; i < HEADER SIZE ; i ++ ) { header = header + reader . read Line ( ) ; } if ( ( header . index Of ( STRING ) != - NUM ) || ( header . index Of ( STRING ) != - NUM ) ) { is Ofx 1 = BOOL ; } else if ( ( header . index Of ( STRING ) != - NUM ) || ( header . index Of ( STRING ) != - NUM ) ) { is Ofx 1 = BOOL ; } else { is Ofx 1 = BOOL ; } reader . reset ( ) ; if ( is Ofx 1 ) { m reader = new Buffered Reader ( new Input Stream Reader ( new OFX 1 To XML ( reader ) ) ) ; } else { m reader = reader ; } result = BOOL ; } catch ( IO Exception e ) { m error Message = STRING ; m error Description = e . get Message ( ) ; return result ; } return result ; }
private void load Default Exclude Pattern ( final String src Folder ) { if ( build Tool Name . equals Ignore Case ( STRING ) ) { ignore File = Ignore File . load ( src Folder , JDK IGNORE PATTERN ) ; } else if ( build Tool Name . equals Ignore Case ( STRING ) ) { ignore File = Ignore File . load ( src Folder , ANT IGNORE PATTERN ) ; } }
public void add Arg If Absent ( final B Op arg ) { if ( arg == null ) throw new Illegal Argument Exception ( ) ; if ( arg == this ) throw new Illegal Argument Exception ( ) ; if ( ! args . contains ( arg ) ) { add Arg ( arg ) ; } }
public static boolean looks Like A Border Style ( String val ) { return BORDER STYLES . contains ( val ) ; }
public void test Get Attribute Node NS 1 ( ) throws Throwable { Document doc ; Element element ; Attr attribute 1 ; Attr attribute 2 ; Attr attribute ; String attr Value ; String attr Name ; String att Node Name ; String attr Local Name ; String attr NS ; doc = ( Document ) load ( STRING , builder ) ; element = doc . create Element NS ( STRING , STRING ) ; attribute 1 = doc . create Attribute NS ( STRING , STRING ) ; element . set Attribute Node NS ( attribute 1 ) ; attribute 2 = doc . create Attribute NS ( STRING , STRING ) ; element . set Attribute Node NS ( attribute 2 ) ; attribute = element . get Attribute Node NS ( STRING , STRING ) ; attr Value = attribute . get Node Value ( ) ; attr Name = attribute . get Name ( ) ; att Node Name = attribute . get Node Name ( ) ; attr Local Name = attribute . get Local Name ( ) ; attr NS = attribute . get Namespace URI ( ) ; assert Equals ( STRING , STRING , attr Value ) ; assert Equals ( STRING , STRING , attr Name ) ; assert Equals ( STRING , STRING , att Node Name ) ; assert Equals ( STRING , STRING , attr Local Name ) ; assert Equals ( STRING , STRING , attr NS ) ; }
public int update Note ( Note note ) { SQ Lite Database db = get Writable Database ( ) ; String spannable As Html = Html . to Html ( note . get Spannable ( ) ) ; String date = dt . format ( new Date ( ) ) ; Content Values values = new Content Values ( ) ; values . put ( KEY IMAGE , Bitmap Converter . get Bytes ( note . get Image ( ) ) ) ; values . put ( KEY DATE UPDATED , date ) ; values . put ( KEY SPANNABLE NOTE , spannable As Html ) ; values . put ( KEY NOTE TITLE , note . get Title ( ) ) ; return db . update ( TABLE NOTES , values , KEY ID + STRING , new String [ ] { String . value Of ( note . get Id ( ) ) } ) ; }
void add Previous ( Node < T > n ) { prev Nodes . add ( n ) ; Collections . sort ( prev Nodes , is Vertical ? vertical Comparator : horizontal Comparator ) ; }
protected void options Dialog Property Change ( Property Change Event event ) { log . debug ( STRING ) ; fire Property Change ( Property Change ID . OPTION CHANGE , event . get Old Value ( ) , event . get New Value ( ) ) ; }
public static final java . lang . String read UTF ( java . io . Data Input in ) throws java . io . IO Exception { return decode UTF ( in . read Unsigned Short ( ) , in ) ; }
public static List reverse List ( List l ) { Linked List l Res = new Linked List ( ) ; int i List Size = l . size ( ) ; for ( int i Cnt = NUM ; i Cnt < i List Size ; i Cnt ++ ) { l Res . add ( l . get ( i List Size - i Cnt - NUM ) ) ; } return l Res ; }
static Repaint Manager current Manager ( App Context app Context ) { Repaint Manager rm = ( Repaint Manager ) app Context . get ( repaint Manager Key ) ; if ( rm == null ) { rm = new Repaint Manager ( BUFFER STRATEGY TYPE ) ; app Context . put ( repaint Manager Key , rm ) ; } return rm ; }
private List < V Plex Initiator Info > find Initiators On Cluster ( String cluster Name , List < Port Info > initiator Port Info , List < Port Info > unfound Initiator Port Info ) throws V Plex Api Exception { List < V Plex Initiator Info > initiator Info List = new Array List < V Plex Initiator Info > ( ) ; V Plex Api Discovery Manager discovery Mgr = vplex Api Client . get Discovery Manager ( ) ; List < V Plex Initiator Info > cluster Initiator Info List = discovery Mgr . get Initiator Info For Cluster ( cluster Name ) ; for ( Port Info port Info : initiator Port Info ) { String port WWN = port Info . get Port WWN ( ) ; for ( V Plex Initiator Info cluster Initiator Info : cluster Initiator Info List ) { if ( port WWN . equals ( cluster Initiator Info . get Port Wwn ( ) ) ) { initiator Info List . add ( cluster Initiator Info ) ; if ( unfound Initiator Port Info != null ) { unfound Initiator Port Info . remove ( port Info ) ; } String port Name = port Info . get Name ( ) ; if ( ( port Name != null ) && ( port Name . length ( ) != NUM ) ) { cluster Initiator Info . set Registration Name ( port Name ) ; } else { cluster Initiator Info . set Registration Name ( V Plex Api Constants . REGISTERED INITIATOR PREFIX + cluster Initiator Info . get Port Wwn Raw ( ) ) ; } Initiator Type initiator Type = Initiator Type . value Of Type ( port Info . get Type ( ) ) ; if ( initiator Type == null ) { s logger . info ( STRING , port Info . get Type ( ) ) ; initiator Type = Initiator Type . DEFAULT ; } cluster Initiator Info . set Initiator Type ( initiator Type ) ; break ; } } } return initiator Info List ; }
private static int flush Buffer ( Writer out , char [ ] buffer , int buffer Index ) throws IO Exception { if ( buffer Index > NUM ) out . write ( buffer , NUM , buffer Index ) ; return NUM ; }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case Eip Package . ROUTER NAME : return NAME EDEFAULT == null ? name != null : ! NAME EDEFAULT . equals ( name ) ; case Eip Package . ROUTER TO CHANNELS : return to Channels != null && ! to Channels . is Empty ( ) ; case Eip Package . ROUTER FROM CHANNELS : return from Channels != null && ! from Channels . is Empty ( ) ; case Eip Package . ROUTER OWNED ROUTES : return owned Routes != null && ! owned Routes . is Empty ( ) ; case Eip Package . ROUTER TYPE : return type != TYPE EDEFAULT ; } return super . e Is Set ( feature ID ) ; }
public void add Section ( final Time Section SECTION ) { if ( null == SECTION ) return ; sections . add ( SECTION ) ; Collections . sort ( sections , new Time Section Comparator ( ) ) ; fire Update Event ( SECTION EVENT ) ; }
@ Suppress Warnings ( STRING ) @ Not Null private static Text Range process Smart Tabs ( @ Not Null Helper helper , @ Not Null Text Range range , int tab Width ) { Char Sequence prev Line Indent = helper . get Prev Line Indent ( ) ; if ( prev Line Indent == null ) { return process Tabs ( helper , range , tab Width ) ; } Char Sequence current Line Indent = helper . get Current Line Indent ( ) ; int line Start = NUM ; int start = Math . max ( NUM , range . get Start Offset ( ) - helper . get Current Line Start Offset ( ) ) ; int end = Math . min ( current Line Indent . length ( ) , range . get End Offset ( ) - helper . get Current Line Start Offset ( ) ) ; int indent Offset = NUM ; int tabs Replaced = NUM ; for ( int i = line Start ; i < end && indent Offset < prev Line Indent . length ( ) ; i ++ , indent Offset ++ ) { char c = current Line Indent . char At ( i ) ; if ( prev Line Indent . char At ( indent Offset ) == STRING ) { if ( c == STRING ) { continue ; } else { break ; } } if ( c == STRING ) { continue ; } if ( end - i < tab Width ) { break ; } boolean can Replace = BOOL ; for ( int j = i + NUM , max = Math . min ( end , i + tab Width ) ; j < max ; j ++ ) { if ( current Line Indent . char At ( j ) != STRING ) { can Replace = BOOL ; break ; } } if ( ! can Replace ) { break ; } if ( i < start ) { i += tab Width - NUM ; continue ; } helper . replace ( i , i + tab Width , STRING ) ; tabs Replaced ++ ; end -= tab Width - NUM ; } return tabs Replaced > NUM ? Text Range . create ( range . get Start Offset ( ) , range . get End Offset ( ) - tabs Replaced * ( tab Width - NUM ) ) : range ; }
public void add All ( D Vector v ) { expand For ( size + v . size - NUM , NUM ) ; System . arraycopy ( v . vector , NUM , vector , size - v . size , v . size ) ; }
public static void drain ( Input Stream in Str ) throws IO Exception { byte [ ] bs = new byte [ BUFFER SIZE ] ; while ( in Str . read ( bs , NUM , bs . length ) >= NUM ) { } }
protected abstract Response Message send Request Core ( Request request , Execution Context context ) throws IO Exception ;
public synchronized void start ( ) { if ( workers . size ( ) > NUM ) { throw new Runtime Exception ( STRING + STRING ) ; } for ( int i = NUM ; i < num Workers ; i ++ ) { Worker worker = new Worker < Job > ( worker Name , jobs To Run , this ) ; workers . add ( worker ) ; } for ( Worker w : workers ) { try { Thread . sleep ( NUM ) ; } catch ( Exception e ) { LOG . error ( e ) ; } w . start ( ) ; } }
public static Array List < String > convert String Array To Array List ( String [ ] string Array ) { if ( string Array != null && string Array . length > NUM ) { return new Array List < > ( Arrays . as List ( string Array ) ) ; } else { return null ; } }
public String Body ( final String text , final String mime Type , Charset charset ) throws Unsupported Encoding Exception { super ( mime Type ) ; if ( text == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( charset == null ) { charset = Charset . for Name ( HTTP . UTF 8 ) ; } this . content = text . get Bytes ( charset . name ( ) ) ; this . charset = charset ; }
public Brd Layer Structure ( Collection < Dsn Layer > p layers ) { layers list = new Array List < Brd Layer > ( p layers . size ( ) ) ; for ( Dsn Layer a layer : p layers ) { layers list . add ( new Brd Layer ( a layer . layer no , a layer . name , a layer . is signal ) ) ; } Collections . sort ( layers list ) ; }
private List < Regex Rule > read Rules ( Reader reader ) throws IO Exception , Illegal Argument Exception { Buffered Reader in = new Buffered Reader ( reader ) ; List < Regex Rule > rules = new Array List < Regex Rule > ( ) ; String line ; while ( ( line = in . read Line ( ) ) != null ) { if ( line . length ( ) == NUM ) { continue ; } char first = line . char At ( NUM ) ; boolean sign = BOOL ; switch ( first ) { case STRING : sign = BOOL ; break ; case STRING : sign = BOOL ; break ; case STRING : case STRING : case STRING : continue ; default : throw new IO Exception ( STRING + line ) ; } String regex = line . substring ( NUM ) ; if ( LOG . is Trace Enabled ( ) ) { LOG . trace ( STRING + regex + STRING ) ; } Regex Rule rule = create Rule ( sign , regex ) ; rules . add ( rule ) ; } return rules ; }
public void write ( char c [ ] , int off , int len ) { if ( off < NUM || off > c . length || len < NUM || off + len > c . length || off + len < NUM ) { throw new Index Out Of Bounds Exception ( ) ; } else if ( len == NUM ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { expand Capacity ( newcount ) ; } System . arraycopy ( c , off , buf , count , len ) ; count = newcount ; }
protected Set < Resource > do Find Matching File System Resources ( File root Dir , String sub Pattern ) throws IO Exception { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + root Dir . get Path ( ) + STRING ) ; } Set < File > matching Files = retrieve Matching Files ( root Dir , sub Pattern ) ; Set < Resource > result = new Linked Hash Set < Resource > ( matching Files . size ( ) ) ; for ( File file : matching Files ) { result . add ( new File System Resource ( file ) ) ; } return result ; }
public static Typed Operation create Array Element Assignment ( Array Type array Type ) { List < Type > type List = new Array List < > ( ) ; type List . add ( array Type ) ; type List . add ( Java Types . INT TYPE ) ; type List . add ( array Type . get Component Type ( ) ) ; Type Tuple input Types = new Type Tuple ( type List ) ; return new Typed Term Operation ( new Array Element Set ( array Type . get Component Type ( ) ) , input Types , Java Types . VOID TYPE ) ; }
public void remove Listener ( final ISPARQL Update Listener l ) { if ( is Read Only ( ) ) throw new Unsupported Operation Exception ( ) ; if ( l == null ) throw new Illegal Argument Exception ( ) ; listeners . remove ( l ) ; }
private void update Data Type State ( ) { boolean is Sync Enabled = m Sync Switch Preference . is Checked ( ) ; boolean sync Everything = m Sync Everything . is Checked ( ) ; boolean password Sync Configurable = m Profile Sync Service . is Sync Initialized ( ) && m Profile Sync Service . is Cryptographer Ready ( ) ; for ( Check Box Preference pref : m All Types ) { boolean can Sync Type = pref != m Sync Passwords || password Sync Configurable ; if ( ! is Sync Enabled ) { pref . set Checked ( BOOL ) ; } else if ( sync Everything ) { pref . set Checked ( can Sync Type ) ; } pref . set Enabled ( is Sync Enabled && ! sync Everything && can Sync Type ) ; } if ( is Sync Enabled && ! sync Everything ) { Set < Integer > sync Types = m Profile Sync Service . get Preferred Data Types ( ) ; m Sync Autofill . set Checked ( sync Types . contains ( Model Type . AUTOFILL ) ) ; m Sync Bookmarks . set Checked ( sync Types . contains ( Model Type . BOOKMARKS ) ) ; m Sync Omnibox . set Checked ( sync Types . contains ( Model Type . TYPED URLS ) ) ; m Sync Passwords . set Checked ( password Sync Configurable && sync Types . contains ( Model Type . PASSWORDS ) ) ; m Sync Recent Tabs . set Checked ( sync Types . contains ( Model Type . PROXY TABS ) ) ; m Sync Settings . set Checked ( sync Types . contains ( Model Type . PRIORITY PREFERENCES ) ) ; } }
private static int index Of Unicode Escape ( @ Not Null String text , int offset ) { final int length = text . length ( ) ; for ( int i = NUM ; i < length ; i ++ ) { final char c = text . char At ( i ) ; if ( c != STRING ) { continue ; } boolean is Escape = BOOL ; int previous Char = i - NUM ; while ( previous Char >= NUM && text . char At ( previous Char ) == STRING ) { is Escape = ! is Escape ; previous Char -- ; } if ( ! is Escape ) { continue ; } int next Char = i ; do { next Char ++ ; if ( next Char >= length ) { break ; } } while ( text . char At ( next Char ) == STRING ) ; if ( next Char == i + NUM || next Char + NUM >= length ) { break ; } if ( String Util . is Hex Digit ( text . char At ( next Char ) ) && String Util . is Hex Digit ( text . char At ( next Char + NUM ) ) && String Util . is Hex Digit ( text . char At ( next Char + NUM ) ) && String Util . is Hex Digit ( text . char At ( next Char + NUM ) ) ) { final int escape End = next Char + NUM ; if ( offset <= escape End ) { return i ; } } } return - NUM ; }
public static boolean is Double ( String desc ) { return desc . ends With ( STRING ) ; }
RSA Private Crt Key Impl ( byte [ ] encoded ) throws Invalid Key Exception { decode ( encoded ) ; RSA Key Factory . check RSA Provider Key Lengths ( n . bit Length ( ) , e ) ; }
private void configure Auth ( Client Builder client Builder ) { if ( conf . client . auth Type == Authentication Type . OAUTH ) { auth Token = Jersey Client Util . configure O Auth 1 ( conf . client . oauth , client Builder ) ; } else if ( conf . client . auth Type != Authentication Type . NONE ) { Jersey Client Util . configure Password Auth ( conf . client . auth Type , conf . client . basic Auth , client Builder ) ; } }
J Panel make Button Panel ( Action Listener update Listener , Action Listener cancel Listener , Action Listener delete Listener ) { J Panel panel 3 = new J Panel ( ) ; panel 3 . set Layout ( new Box Layout ( panel 3 , Box Layout . X AXIS ) ) ; J Button cancel Action = new J Button ( Bundle . get Message ( STRING ) ) ; panel 3 . add ( cancel Action ) ; panel 3 . add ( Box . create Horizontal Strut ( STRUT ) ) ; cancel Action . add Action Listener ( cancel Listener ) ; cancel Action . set Tool Tip Text ( rbx . get String ( STRING ) ) ; J Button update Action = new J Button ( Bundle . get Message ( STRING ) ) ; panel 3 . add ( update Action ) ; panel 3 . add ( Box . create Horizontal Strut ( STRUT ) ) ; update Action . add Action Listener ( update Listener ) ; update Action . set Tool Tip Text ( rbx . get String ( STRING ) ) ; J Button delete Action = new J Button ( Bundle . get Message ( STRING ) ) ; panel 3 . add ( delete Action ) ; delete Action . add Action Listener ( delete Listener ) ; delete Action . set Tool Tip Text ( rbx . get String ( STRING ) ) ; return panel 3 ; }
public static void write Line ( Buffered Writer writer , String line ) throws IO Exception { writer . write ( line ) ; writer . new Line ( ) ; }
public void add ( WX Dom Object child , int index ) { if ( child == null || index < - NUM || s Destroy . get ( ) ) { return ; } if ( children == null ) { children = new Array List < > ( ) ; } int count = children . size ( ) ; index = index >= count ? - NUM : index ; if ( index == - NUM ) { children . add ( child ) ; super . add Child At ( child , super . get Child Count ( ) ) ; } else { children . add ( index , child ) ; super . add Child At ( child , index ) ; } child . parent = this ; }
private static < T , R > R access Safely ( Lock lock , List < T > list , Function < List < T > , R > list Function ) { final R return Value ; lock . lock ( ) ; try { return Value = list Function . apply ( list ) ; } finally { lock . unlock ( ) ; } return return Value ; }
public static License read ( final String license ) { final String trimmed License = license . trim ( ) ; if ( s Licenses . contains Key ( trimmed License ) ) { return s Licenses . get ( trimmed License ) ; } else { throw new Illegal State Exception ( String . format ( STRING , trimmed License ) ) ; } }
public D Name Constraints ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public Int Column ( int nrows , int capacity , int default Value ) { super ( int . class , new Integer ( default Value ) ) ; if ( capacity < nrows ) { throw new Illegal Argument Exception ( STRING ) ; } m values = new int [ capacity ] ; Arrays . fill ( m values , default Value ) ; m size = nrows ; }
void read SIN ( ) throws IO Exception { while ( BOOL ) { String S = isr . read Line ( ) ; if ( S == null ) return ; if ( S . starts With ( STRING ) ) return ; } }
private void check Alter Partial Converters ( ) throws Security Exception { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { sm . check Permission ( new Joda Time Permission ( STRING ) ) ; } }
public boolean equals ( final Object obj ) { return this == obj || obj instanceof Artifact Coordinates && equals ( ( Artifact Coordinates ) obj ) ; }
public static String convert Timestamp To Date String ( boolean use UTC , long milli ) { Date date = new Date ( milli ) ; Simple Date Format source Format = new Simple Date Format ( STRING ) ; source Format . set Time Zone ( use UTC ? Time Zone . get Time Zone ( STRING ) : Time Zone . get Default ( ) ) ; return source Format . format ( date ) ; }
private void write File ( List < String > lines , File file ) throws Exception { try ( Print Writer writer = new Print Writer ( new File Output Stream ( file ) ) ) { for ( String line : lines ) { writer . println ( line ) ; } } }
@ Override public Query new Prefix Query ( String text ) { if ( settings . lowercase Expanded Terms ( ) ) { text = text . to Lower Case ( settings . locale ( ) ) ; } Boolean Query . Builder bq = new Boolean Query . Builder ( ) ; bq . set Disable Coord ( BOOL ) ; for ( Map . Entry < String , Float > entry : weights . entry Set ( ) ) { try { if ( settings . analyze Wildcard ( ) ) { Query analyzed Query = new Possibly Analyzed Query ( entry . get Key ( ) , text ) ; analyzed Query . set Boost ( entry . get Value ( ) ) ; bq . add ( analyzed Query , Boolean Clause . Occur . SHOULD ) ; } else { Prefix Query prefix = new Prefix Query ( new Term ( entry . get Key ( ) , text ) ) ; prefix . set Boost ( entry . get Value ( ) ) ; bq . add ( prefix , Boolean Clause . Occur . SHOULD ) ; } } catch ( Runtime Exception e ) { return rethrow Unless Lenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }
public Source Call Chain Info ( Soot Method m , Stmt s , String type ) { this . type = type ; this . link = STRING ; this . method = m ; this . stmt = s ; calls = NUM ; if ( type . equals ( STRING ) ) syscalls = NUM ; }
public void discard Recording ( ) { Log . d ( TAG , STRING ) ; if ( ( STATE RECORDING == m Internal State ) && ( null != m Recorder ) ) { stop Recorder ( ) ; } else if ( ( STATE PLAYBACK == m Internal State ) && ( null != m Player ) ) { stop Player ( ) ; } if ( null != m Record File && ! m Is Recording File Saved ) { if ( ! m Record File . delete ( ) ) { Log . d ( TAG , STRING ) ; } m Record File = null ; m Record Start Time = NUM ; m Record Time = NUM ; } set State ( STATE IDLE ) ; Log . d ( TAG , STRING ) ; }
public double convexity Bias ( final double future Price , final double t , final double T , final double sigma , final double a ) { QL . require ( future Price >= NUM , STRING ) ; QL . require ( t >= NUM , STRING ) ; QL . require ( T >= t , STRING ) ; QL . require ( a >= NUM , STRING ) ; final double delta T = ( T - t ) ; final double temp Delta T = ( NUM - Math . exp ( - a * delta T ) ) / a ; final double half Sigma Square = sigma * sigma / NUM ; final double lambda = half Sigma Square * ( NUM - Math . exp ( - NUM * a * t ) ) / a * temp Delta T * temp Delta T ; final double temp T = ( NUM - Math . exp ( - a * t ) ) / a ; final double phi = half Sigma Square * temp Delta T * temp T * temp T ; final double z = lambda + phi ; final double future Rate = ( NUM - future Price ) / NUM ; return ( NUM - Math . exp ( - z ) ) * ( future Rate + NUM / ( T - t ) ) ; }
public static void not Empty ( String string ) { if ( string == null || string . length ( ) == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
public static final Variable Context [ ] parse ( String variable ) { char [ ] text = variable . to Char Array ( ) ; List < Variable Context > contexts = new Array List < > ( ) ; int i = add Member ( text , NUM , contexts ) ; while ( i < text . length ) { if ( text [ i ] == STRING ) { if ( text [ ++ i ] == STRING ) { i = add String Index ( text , i , contexts ) ; } else { i = add Int Index ( text , i , contexts ) ; } ++ i ; } else { i = add Member ( text , i + NUM , contexts ) ; } } return contexts . to Array ( new Variable Context [ contexts . size ( ) ] ) ; }
public static Object [ ] build Value Array ( Parsed Sql parsed Sql , Map < String , ? > param Source ) { List < Object > param Array = new Array List < Object > ( ) ; if ( parsed Sql . get Named Parameter Count ( ) > NUM && parsed Sql . get Unnamed Parameter Count ( ) > NUM ) { throw new Illegal State Exception ( STRING + parsed Sql . get Named Parameter Count ( ) + STRING + parsed Sql . get Unnamed Parameter Count ( ) + STRING + parsed Sql . get Original Sql ( ) + STRING ) ; } List < String > param Names = parsed Sql . get Parameter Names ( ) ; for ( int i = NUM ; i < param Names . size ( ) ; i ++ ) { String param Name = param Names . get ( i ) ; Object value = param Source . get ( param Name ) ; if ( value instanceof Collection < ? > ) { Collection < ? > collection = ( Collection < ? > ) value ; for ( Object object : collection ) { param Array . add ( object ) ; } } else { param Array . add ( value ) ; } } return param Array . to Array ( new Object [ param Array . size ( ) ] ) ; }
public void on Fedlet SLO Success ( Http Servlet Request request , Http Servlet Response response , Logout Request logout Req , Logout Response logout Res , String hosted Entity ID , String idp Entity ID , String binding ) throws SAML 2 Exception { on Fedlet SLO Success Or Failure ( request , response , logout Req , logout Res , hosted Entity ID , idp Entity ID , binding , BOOL ) ; return ; }
private void validate Removal Of Public Network Interface ( String instance Id , int desired Network Interface State Count ) throws Throwable { if ( this . is Aws Client Mock ) { return ; } Compute State stopped Compute State = get Compute By AWS Id ( this . host , instance Id ) ; assert Not Null ( stopped Compute State ) ; for ( String network Link : stopped Compute State . network Interface Links ) { assert False ( network Link . contains ( PUBLIC INTERFACE ) ) ; } validate Network Interface Count ( desired Network Interface State Count ) ; }
public static List < X509 Certificate > parse Certificates ( String [ ] base 64 Encoded Certificates ) throws Certificate Exception { List < X509 Certificate > certificates = new Array List < X509 Certificate > ( ) ; for ( String base 64 Encoded Certificate : base 64 Encoded Certificates ) { certificates . add ( parse Certificate ( base 64 Encoded Certificate ) ) ; } return certificates ; }
private Membership Key inner Join ( Inet Address group , Network Interface interf , Inet Address source ) throws IO Exception { if ( ! group . is Multicast Address ( ) ) throw new Illegal Argument Exception ( STRING ) ; if ( group instanceof Inet 4 Address ) { if ( family == Standard Protocol Family . INET 6 && ! Net . can I Pv 6 Socket Join I Pv 4 Group ( ) ) throw new Illegal Argument Exception ( STRING ) ; } else if ( group instanceof Inet 6 Address ) { if ( family != Standard Protocol Family . INET 6 ) throw new Illegal Argument Exception ( STRING ) ; } else { throw new Illegal Argument Exception ( STRING ) ; } if ( source != null ) { if ( source . is Any Local Address ( ) ) throw new Illegal Argument Exception ( STRING ) ; if ( source . is Multicast Address ( ) ) throw new Illegal Argument Exception ( STRING ) ; if ( source . get Class ( ) != group . get Class ( ) ) throw new Illegal Argument Exception ( STRING ) ; } Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) sm . check Multicast ( group ) ; synchronized ( state Lock ) { if ( ! is Open ( ) ) throw new Closed Channel Exception ( ) ; if ( registry == null ) { registry = new Membership Registry ( ) ; } else { Membership Key key = registry . check Membership ( group , interf , source ) ; if ( key != null ) return key ; } Membership Key Impl key ; if ( ( family == Standard Protocol Family . INET 6 ) && ( ( group instanceof Inet 6 Address ) || Net . can Join 6 With I Pv 4 Group ( ) ) ) { int index = interf . get Index ( ) ; if ( index == - NUM ) throw new IO Exception ( STRING ) ; byte [ ] group Address = Net . inet 6 As Byte Array ( group ) ; byte [ ] source Address = ( source == null ) ? null : Net . inet 6 As Byte Array ( source ) ; int n = Net . join 6 ( fd , group Address , index , source Address ) ; if ( n == IO Status . UNAVAILABLE ) throw new Unsupported Operation Exception ( ) ; key = new Membership Key Impl . Type 6 ( this , group , interf , source , group Address , index , source Address ) ; } else { Inet 4 Address target = Net . any Inet 4 Address ( interf ) ; if ( target == null ) throw new IO Exception ( STRING ) ; int group Address = Net . inet 4 As Int ( group ) ; int target Address = Net . inet 4 As Int ( target ) ; int source Address = ( source == null ) ? NUM : Net . inet 4 As Int ( source ) ; int n = Net . join 4 ( fd , group Address , target Address , source Address ) ; if ( n == IO Status . UNAVAILABLE ) throw new Unsupported Operation Exception ( ) ; key = new Membership Key Impl . Type 4 ( this , group , interf , source , group Address , target Address , source Address ) ; } registry . add ( key ) ; return key ; } }
@ Override protected void close File ( Input Stream is ) throws IO Exception { super . close File ( is ) ; br . close ( ) ; br = null ; path = null ; }
public final void turn By ( double angle ) { angle = Geometric . clamp Angle Degree ( angle ) ; orientation += angle ; orientation = Geometric . clamp Angle Degree ( orientation ) ; Geometric . rotate To ( velocity , Math . to Radians ( orientation ) ) ; }
public static String to String ( URI uri , Charset encoding ) throws IO Exception { return to String ( uri . to URL ( ) , Charsets . to Charset ( encoding ) ) ; }
void put ( int field Number , Field Data data ) { int i = binary Search ( field Number ) ; if ( i >= NUM ) { m Data [ i ] = data ; } else { i = ~ i ; if ( i < m Size && m Data [ i ] == DELETED ) { m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; return ; } if ( m Garbage && m Size >= m Field Numbers . length ) { gc ( ) ; i = ~ binary Search ( field Number ) ; } if ( m Size >= m Field Numbers . length ) { int n = ideal Int Array Size ( m Size + NUM ) ; int [ ] nkeys = new int [ n ] ; Field Data [ ] nvalues = new Field Data [ n ] ; System . arraycopy ( m Field Numbers , NUM , nkeys , NUM , m Field Numbers . length ) ; System . arraycopy ( m Data , NUM , nvalues , NUM , m Data . length ) ; m Field Numbers = nkeys ; m Data = nvalues ; } if ( m Size - i != NUM ) { System . arraycopy ( m Field Numbers , i , m Field Numbers , i + NUM , m Size - i ) ; System . arraycopy ( m Data , i , m Data , i + NUM , m Size - i ) ; } m Field Numbers [ i ] = field Number ; m Data [ i ] = data ; m Size ++ ; } }
private void calc Content Rect ( ) { Insets content Insets = get Content Border Insets ( tab Placement ) ; Rectangle bounds = tab Pane . get Bounds ( ) ; Insets insets = tab Pane . get Insets ( ) ; int cx ; int cy ; int cw ; int ch ; switch ( tab Placement ) { case LEFT : cx = tab Area Rect . x + tab Area Rect . width + content Insets . left ; cy = tab Area Rect . y + content Insets . top ; cw = bounds . width - insets . left - insets . right - tab Area Rect . width - content Insets . left - content Insets . right ; ch = bounds . height - insets . top - insets . bottom - content Insets . top - content Insets . bottom ; break ; case RIGHT : cx = insets . left + content Insets . left ; cy = insets . top + content Insets . top ; cw = bounds . width - insets . left - insets . right - tab Area Rect . width - content Insets . left - content Insets . right ; ch = bounds . height - insets . top - insets . bottom - content Insets . top - content Insets . bottom ; break ; case BOTTOM : cx = insets . left + content Insets . left ; cy = insets . top + content Insets . top ; cw = bounds . width - insets . left - insets . right - content Insets . left - content Insets . right ; ch = bounds . height - insets . top - insets . bottom - tab Area Rect . height - content Insets . top - content Insets . bottom ; break ; case TOP : default : cx = tab Area Rect . x + content Insets . left ; cy = tab Area Rect . y + tab Area Rect . height + content Insets . top ; cw = bounds . width - insets . left - insets . right - content Insets . left - content Insets . right ; ch = bounds . height - insets . top - insets . bottom - tab Area Rect . height - content Insets . top - content Insets . bottom ; } content Rect . set Bounds ( cx , cy , cw , ch ) ; }
public void init ( String btxn , Business Txn Config btc ) { Filter Processor fp = null ; if ( btc . get Filter ( ) != null ) { fp = new Filter Processor ( btxn , btc ) ; } synchronized ( filter Map ) { Filter Processor oldfp = filter Map . get ( btxn ) ; if ( oldfp != null ) { global Exclusion Filters . remove ( oldfp ) ; btxn Filters . remove ( oldfp ) ; } if ( fp != null ) { filter Map . put ( btxn , fp ) ; if ( fp . is Include All ( ) ) { global Exclusion Filters . add ( fp ) ; } else { btxn Filters . add ( fp ) ; } } else { filter Map . remove ( btxn ) ; } } }
public double weighted distance ( Shape Tile Box p other , double p horizontal weight , double p vertical weight ) { double result ; double max ll x = Math . max ( box ll . v x , p other . box ll . v x ) ; double max ll y = Math . max ( box ll . v y , p other . box ll . v y ) ; double min ur x = Math . min ( box ur . v x , p other . box ur . v x ) ; double min ur y = Math . min ( box ur . v y , p other . box ur . v y ) ; if ( min ur x >= max ll x ) { result = Math . max ( p vertical weight * ( max ll y - min ur y ) , NUM ) ; } else if ( min ur y >= max ll y ) { result = Math . max ( p horizontal weight * ( max ll x - min ur x ) , NUM ) ; } else { double delta x = max ll x - min ur x ; double delta y = max ll y - min ur y ; delta x *= p horizontal weight ; delta y *= p vertical weight ; result = Math . sqrt ( delta x * delta x + delta y * delta y ) ; } return result ; }
protected List < Process Change > remove Equipment Control Tags ( final T abstract Equipment , final Configuration Element Report equipment Report ) { List < Process Change > changes = new Array List < > ( ) ; LOGGER . debug ( STRING ) ; Long alive Tag Id = abstract Equipment . get Alive Tag Id ( ) ; if ( alive Tag Id != null ) { Configuration Element Report tag Report = new Configuration Element Report ( Action . REMOVE , Entity . CONTROLTAG , alive Tag Id ) ; Process Change change = control Tag Config Handler . remove Control Tag ( alive Tag Id , tag Report ) ; if ( change . process Action Required ( ) ) { change . set Nested Sub Report ( tag Report ) ; changes . add ( change ) ; } else { equipment Report . add Sub Report ( tag Report ) ; } } Long comm Tag Id = abstract Equipment . get Comm Fault Tag Id ( ) ; if ( comm Tag Id != null ) { Configuration Element Report tag Report = new Configuration Element Report ( Action . REMOVE , Entity . CONTROLTAG , comm Tag Id ) ; Process Change change = control Tag Config Handler . remove Control Tag ( comm Tag Id , tag Report ) ; if ( change . process Action Required ( ) ) { change . set Nested Sub Report ( tag Report ) ; changes . add ( change ) ; } else { equipment Report . add Sub Report ( tag Report ) ; } } Long state Tag Id = abstract Equipment . get State Tag Id ( ) ; Configuration Element Report tag Report = new Configuration Element Report ( Action . REMOVE , Entity . CONTROLTAG , state Tag Id ) ; Process Change change = control Tag Config Handler . remove Control Tag ( state Tag Id , tag Report ) ; if ( change . process Action Required ( ) ) { change . set Nested Sub Report ( tag Report ) ; changes . add ( change ) ; } else { equipment Report . add Sub Report ( tag Report ) ; } return changes ; }
private void enable Stronger Defaults ( Socket socket ) { if ( is Secure ( socket ) ) { SSL Socket ssl Socket = ( SSL Socket ) socket ; read SSL Parameters ( ssl Socket ) ; if ( m Enable Stonger Default Protocal Version && m Protocols != null ) { ssl Socket . set Enabled Protocols ( m Protocols ) ; } if ( m Enable Stonger Default SSL Cipher Suite && m Cipher Suites != null ) { ssl Socket . set Enabled Cipher Suites ( m Cipher Suites ) ; } } }
private static Platform find Platform ( ) { try { try { Class . for Name ( STRING ) ; } catch ( Class Not Found Exception e ) { Class . for Name ( STRING ) ; } Optional Method < Socket > set Use Session Tickets = new Optional Method < > ( null , STRING , boolean . class ) ; Optional Method < Socket > set Hostname = new Optional Method < > ( null , STRING , String . class ) ; Method traffic Stats Tag Socket = null ; Method traffic Stats Untag Socket = null ; Optional Method < Socket > get Alpn Selected Protocol = null ; Optional Method < Socket > set Alpn Protocols = null ; try { Class < ? > traffic Stats = Class . for Name ( STRING ) ; traffic Stats Tag Socket = traffic Stats . get Method ( STRING , Socket . class ) ; traffic Stats Untag Socket = traffic Stats . get Method ( STRING , Socket . class ) ; try { Class . for Name ( STRING ) ; get Alpn Selected Protocol = new Optional Method < > ( byte [ ] . class , STRING ) ; set Alpn Protocols = new Optional Method < > ( null , STRING , byte [ ] . class ) ; } catch ( Class Not Found Exception ignored ) { } } catch ( Class Not Found Exception | No Such Method Exception ignored ) { } return new Android ( set Use Session Tickets , set Hostname , traffic Stats Tag Socket , traffic Stats Untag Socket , get Alpn Selected Protocol , set Alpn Protocols ) ; } catch ( Class Not Found Exception ignored ) { } try { String nego Class Name = STRING ; Class < ? > nego Class = Class . for Name ( nego Class Name ) ; Class < ? > provider Class = Class . for Name ( nego Class Name + STRING ) ; Class < ? > client Provider Class = Class . for Name ( nego Class Name + STRING ) ; Class < ? > server Provider Class = Class . for Name ( nego Class Name + STRING ) ; Method put Method = nego Class . get Method ( STRING , SSL Socket . class , provider Class ) ; Method get Method = nego Class . get Method ( STRING , SSL Socket . class ) ; Method remove Method = nego Class . get Method ( STRING , SSL Socket . class ) ; return new Jdk With Jetty Boot Platform ( put Method , get Method , remove Method , client Provider Class , server Provider Class ) ; } catch ( Class Not Found Exception | No Such Method Exception ignored ) { } return new Platform ( ) ; }
public void update Execution Status ( Execution Update Data execution Update Data ) { Closeable Http Response http Response = null ; http Response = post Over Http ( execution Update Data , STRING + execution Update Data . get State Machine Id ( ) + STRING + execution Update Data . get Task Id ( ) + STRING ) ; Http Client Utils . close Quietly ( http Response ) ; }
@ Override public void build Classifier ( Instances data ) throws Exception { if ( m fast Regression && ( m fixed Num Iterations < NUM ) ) { m fixed Num Iterations = try Logistic ( data ) ; } Instances cv Data = new Instances ( data ) ; cv Data . stratify ( m num Folds Pruning ) ; double [ ] [ ] alphas = new double [ m num Folds Pruning ] [ ] ; double [ ] [ ] errors = new double [ m num Folds Pruning ] [ ] ; for ( int i = NUM ; i < m num Folds Pruning ; i ++ ) { Instances train = cv Data . train CV ( m num Folds Pruning , i ) ; Instances test = cv Data . test CV ( m num Folds Pruning , i ) ; build Tree ( train , null , train . num Instances ( ) , NUM , null ) ; int num Nodes = get Num Inner Nodes ( ) ; alphas [ i ] = new double [ num Nodes + NUM ] ; errors [ i ] = new double [ num Nodes + NUM ] ; prune ( alphas [ i ] , errors [ i ] , test ) ; } cv Data = null ; build Tree ( data , null , data . num Instances ( ) , NUM , null ) ; int num Nodes = get Num Inner Nodes ( ) ; double [ ] tree Alphas = new double [ num Nodes + NUM ] ; int iterations = prune ( tree Alphas , null , null ) ; double [ ] tree Errors = new double [ num Nodes + NUM ] ; for ( int i = NUM ; i <= iterations ; i ++ ) { double alpha = Math . sqrt ( tree Alphas [ i ] * tree Alphas [ i + NUM ] ) ; double error = NUM ; for ( int k = NUM ; k < m num Folds Pruning ; k ++ ) { int l = NUM ; while ( alphas [ k ] [ l ] <= alpha ) { l ++ ; } error += errors [ k ] [ l - NUM ] ; } tree Errors [ i ] = error ; } int best = - NUM ; double best Error = Double . MAX VALUE ; for ( int i = iterations ; i >= NUM ; i -- ) { if ( tree Errors [ i ] < best Error ) { best Error = tree Errors [ i ] ; best = i ; } } double best Alpha = Math . sqrt ( tree Alphas [ best ] * tree Alphas [ best + NUM ] ) ; unprune ( ) ; prune ( best Alpha ) ; }
public static String format Message ( int error Code , String message , Object ... arguments ) { for ( int i = NUM ; i < arguments . length ; i ++ ) { Object a = arguments [ i ] ; if ( ! ( a instanceof Exception ) ) { String s = a == null ? STRING : a . to String ( ) ; if ( s . length ( ) > NUM ) { s = s . substring ( NUM , NUM ) + STRING ; } arguments [ i ] = s ; } } return Message Format . format ( message , arguments ) + STRING + Constants . VERSION MAJOR + STRING + Constants . VERSION MINOR + STRING + Constants . BUILD ID + STRING + error Code + STRING ; }
private void define Internal Frame Iconify Buttons ( UI Defaults d ) { String p = STRING ; String c = PAINTER PREFIX + STRING ; d . put ( p + STRING , STRING ) ; d . put ( p + STRING , new Title Pane Iconify Button Window Not Focused State ( ) ) ; d . put ( p + STRING , new Title Pane Iconify Button Window Minimized State ( ) ) ; d . put ( p + STRING , new Insets UI Resource ( NUM , NUM , NUM , NUM ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND MOUSEOVER ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND PRESSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND ENABLED WINDOWNOTFOCUSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND MOUSEOVER WINDOWNOTFOCUSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND PRESSED WINDOWNOTFOCUSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND MINIMIZED DISABLED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND MINIMIZED ENABLED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND MINIMIZED MOUSEOVER ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND MINIMIZED PRESSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND MINIMIZED ENABLED WINDOWNOTFOCUSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND MINIMIZED MOUSEOVER WINDOWNOTFOCUSED ) ) ; d . put ( p + STRING , new Lazy Painter ( c , Title Pane Iconify Button Painter . Which . BACKGROUND MINIMIZED PRESSED WINDOWNOTFOCUSED ) ) ; d . put ( p + STRING , new Sea Glass Icon ( p , STRING , NUM , NUM ) ) ; }
public static Workflow . Method resync Clone Method ( URI storage , List < URI > clone , Boolean update Op Status , boolean is CG ) { return new Workflow . Method ( STRING , storage , clone , update Op Status , is CG ) ; }
@ Override public synchronized void remove Data Source Listener ( Data Source Listener dsl ) { m data Listeners . remove ( dsl ) ; }
public String left Str ( String str , int length ) { return str . substring ( NUM , Math . min ( str . length ( ) , length ) ) ; }
public boolean contains Block ( Block b ) { Array List < Block > b List = get Internal Blocks List ( ) ; for ( int i = NUM ; i < b List . size ( ) ; i ++ ) { if ( b == b List . get ( i ) ) { return BOOL ; } } return BOOL ; }
public static < T extends Storable > T unserialize ( Class < T > clazz , Data data ) { try { T storable Obj = clazz . new Instance ( ) ; storable Obj . load ( data ) ; return storable Obj ; } catch ( Exception e ) { throw new Data Exception ( e ) ; } }
private synchronized void stop Inclusion Timer ( ) { logger . debug ( STRING ) ; if ( inclusion ) { request Add Nodes Stop ( ) ; } else if ( exclusion ) { request Remove Nodes Stop ( ) ; } else { logger . error ( STRING ) ; } inclusion = BOOL ; exclusion = BOOL ; if ( timer Task != null ) { timer Task . cancel ( ) ; timer Task = null ; } }
public void push Template Folder ( @ Not Null File folder ) { my Last Template Folders . push ( folder ) ; }
void assign Depth First Numbers ( Control Flow Graph cfg ) { int instruction Count = ir . count Instructions ( ) ; reg Alloc State . initialize Depth First Numbering ( instruction Count ) ; int cur Dfn = instruction Count - NUM ; list Of Blocks = null ; for ( Basic Block bb = reverse Top First ; bb != null ; bb = ( Basic Block ) bb . sorted Prev ) { bb . next Sorted = list Of Blocks ; list Of Blocks = bb ; Enumeration < Instruction > e = bb . reverse Instr Enumerator ( ) ; while ( e . has More Elements ( ) ) { Instruction inst = e . next Element ( ) ; reg Alloc State . set DFN ( inst , cur Dfn ) ; cur Dfn -- ; } } if ( Linear Scan . DEBUG ) { reg Alloc State . print Dfns ( ir ) ; } }
protected void draw Cubic ( Canvas c , Line Data Set data Set , List < Entry > entries ) { Transformer trans = m Chart . get Transformer ( data Set . get Axis Dependency ( ) ) ; Entry entry From = data Set . get Entry For X Index ( m Min X ) ; Entry entry To = data Set . get Entry For X Index ( m Max X ) ; int minx = data Set . get Entry Position ( entry From ) ; int maxx = Math . min ( data Set . get Entry Position ( entry To ) + NUM , entries . size ( ) ) ; float phase X = m Animator . get Phase X ( ) ; float phase Y = m Animator . get Phase Y ( ) ; float intensity = data Set . get Cubic Intensity ( ) ; cubic Path . reset ( ) ; int size = ( int ) Math . ceil ( ( maxx - minx ) * phase X + minx ) ; minx = Math . max ( minx - NUM , NUM ) ; size = Math . min ( size + NUM , entries . size ( ) ) ; if ( size - minx >= NUM ) { float prev Dx = NUM ; float prev Dy = NUM ; float cur Dx = NUM ; float cur Dy = NUM ; Entry cur = entries . get ( minx ) ; Entry next = entries . get ( minx + NUM ) ; Entry prev = entries . get ( minx ) ; Entry prev Prev = entries . get ( minx ) ; cubic Path . move To ( cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; prev Dx = ( next . get X Index ( ) - cur . get X Index ( ) ) * intensity ; prev Dy = ( next . get Val ( ) - cur . get Val ( ) ) * intensity ; cur = entries . get ( minx + NUM ) ; next = entries . get ( minx + ( size - minx > NUM ? NUM : NUM ) ) ; cur Dx = ( next . get X Index ( ) - prev . get X Index ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get X Index ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get X Index ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; for ( int j = minx + NUM ; j < size - NUM ; j ++ ) { prev Prev = entries . get ( j - NUM ) ; prev = entries . get ( j - NUM ) ; cur = entries . get ( j ) ; next = entries . get ( j + NUM ) ; prev Dx = ( cur . get X Index ( ) - prev Prev . get X Index ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev Prev . get Val ( ) ) * intensity ; cur Dx = ( next . get X Index ( ) - prev . get X Index ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get X Index ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get X Index ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; } if ( size > entries . size ( ) - NUM ) { cur = entries . get ( entries . size ( ) - NUM ) ; prev = entries . get ( entries . size ( ) - NUM ) ; prev Prev = entries . get ( ( entries . size ( ) >= NUM ) ? entries . size ( ) - NUM : entries . size ( ) - NUM ) ; next = cur ; prev Dx = ( cur . get X Index ( ) - prev Prev . get X Index ( ) ) * intensity ; prev Dy = ( cur . get Val ( ) - prev Prev . get Val ( ) ) * intensity ; cur Dx = ( next . get X Index ( ) - prev . get X Index ( ) ) * intensity ; cur Dy = ( next . get Val ( ) - prev . get Val ( ) ) * intensity ; cubic Path . cubic To ( prev . get X Index ( ) + prev Dx , ( prev . get Val ( ) + prev Dy ) * phase Y , cur . get X Index ( ) - cur Dx , ( cur . get Val ( ) - cur Dy ) * phase Y , cur . get X Index ( ) , cur . get Val ( ) * phase Y ) ; } } if ( data Set . is Draw Filled Enabled ( ) ) { cubic Fill Path . reset ( ) ; cubic Fill Path . add Path ( cubic Path ) ; draw Cubic Fill ( m Bitmap Canvas , data Set , cubic Fill Path , trans , entry From . get X Index ( ) , entry From . get X Index ( ) + size ) ; } m Render Paint . set Color ( data Set . get Color ( ) ) ; m Render Paint . set Style ( Paint . Style . STROKE ) ; trans . path Value To Pixel ( cubic Path ) ; m Bitmap Canvas . draw Path ( cubic Path , m Render Paint ) ; m Render Paint . set Path Effect ( null ) ; }
public static int waiting ( int d , Predicate p ) { int count = NUM ; Sim Event event ; Iterator < Sim Event > iterator = deferred . iterator ( ) ; while ( iterator . has Next ( ) ) { event = iterator . next ( ) ; if ( ( event . get Destination ( ) == d ) && ( p . match ( event ) ) ) { count ++ ; } } return count ; }
private void generate Chunks For Schema ( String schema Name ) { try { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + schema Name ) ; Array List < Table > tables From Schema = connection . get Tables ( schema Name , BOOL , BOOL ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + tables From Schema ) ; if ( tables From Schema != null && tables From Schema . size ( ) > NUM ) { for ( Table table : tables From Schema ) { generate Chunks For Table ( table , - NUM , null ) ; } } } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public static void add River ( I Board board , Hash Map < I Hex , Point > reverse Hex ) { int min Elevation = Integer . MAX VALUE ; Hash Set < I Hex > river Hexes = new Hash Set < I Hex > ( ) ; I Hex field ; Point p = null ; int direction = NUM ; int next Left = NUM ; int next Right = NUM ; int width = board . get Width ( ) ; int height = board . get Height ( ) ; if ( ( width < NUM ) || ( height < NUM ) ) { return ; } switch ( Compute . random Int ( NUM ) ) { case NUM : p = new Point ( NUM , Compute . random Int ( NUM ) - NUM + height / NUM ) ; direction = Compute . random Int ( NUM ) + NUM ; next Left = direction - NUM ; next Right = direction + NUM ; break ; case NUM : p = new Point ( width - NUM , Compute . random Int ( NUM ) - NUM + height / NUM ) ; direction = Compute . random Int ( NUM ) + NUM ; next Left = direction - NUM ; next Right = ( direction + NUM ) % NUM ; break ; case NUM : case NUM : p = new Point ( Compute . random Int ( NUM ) - NUM + width / NUM , NUM ) ; direction = NUM ; next Right = NUM ; next Left = NUM ; break ; } field = board . get Hex ( p . x , p . y ) ; I Terrain Factory f = Terrains . get Terrain Factory ( ) ; do { field . remove All Terrains ( ) ; field . add Terrain ( f . create Terrain ( Terrains . WATER , NUM ) ) ; river Hexes . add ( field ) ; p = reverse Hex . get ( field ) ; river Hexes . add All ( extend River To Side ( board , p , Compute . random Int ( NUM ) , next Left , reverse Hex ) ) ; river Hexes . add All ( extend River To Side ( board , p , Compute . random Int ( NUM ) , next Right , reverse Hex ) ) ; switch ( Compute . random Int ( NUM ) ) { case NUM : field = board . get Hex In Dir ( p . x , p . y , ( direction + NUM ) % NUM ) ; break ; case NUM : field = board . get Hex In Dir ( p . x , p . y , ( direction + NUM ) % NUM ) ; break ; default : field = board . get Hex In Dir ( p . x , p . y , direction ) ; break ; } } while ( field != null ) ; Hash Set < I Hex > tmp River Hexes = new Hash Set < I Hex > ( river Hexes ) ; while ( ! tmp River Hexes . is Empty ( ) ) { Iterator < I Hex > iter = tmp River Hexes . iterator ( ) ; field = iter . next ( ) ; if ( field . get Level ( ) < min Elevation ) { min Elevation = field . get Level ( ) ; } tmp River Hexes . remove ( field ) ; Point this Hex = reverse Hex . get ( field ) ; for ( int i = NUM ; i < NUM ; i ++ ) { field = board . get Hex In Dir ( this Hex . x , this Hex . y , i ) ; if ( ( field != null ) && ( field . get Level ( ) < min Elevation ) ) { min Elevation = field . get Level ( ) ; } tmp River Hexes . remove ( field ) ; } } Iterator < I Hex > iter = river Hexes . iterator ( ) ; while ( iter . has Next ( ) ) { field = iter . next ( ) ; field . set Level ( min Elevation ) ; } return ; }
private void parse Entity ( Element entity Node , Vector < Entity > list ) { Entity entity = null ; String chassis = entity Node . get Attribute ( CHASSIS ) ; String model = entity Node . get Attribute ( MODEL ) ; entity = get Entity ( chassis , model ) ; if ( entity == null ) { warning . append ( STRING ) ; return ; } parse Entity Attributes ( entity , entity Node ) ; Node List nl = entity Node . get Child Nodes ( ) ; for ( int i = NUM ; i < nl . get Length ( ) ; i ++ ) { Node curr Node = nl . item ( i ) ; if ( curr Node . get Parent Node ( ) != entity Node ) { continue ; } int node Type = curr Node . get Node Type ( ) ; if ( node Type == Node . ELEMENT NODE ) { Element curr Ele = ( Element ) curr Node ; String node Name = curr Node . get Node Name ( ) ; if ( node Name . equals Ignore Case ( PILOT ) ) { parse Pilot ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( LOCATION ) ) { parse Location ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( MOVEMENT ) ) { parse Movement ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( TURRETLOCK ) ) { parse Turret Lock ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( TURRET 2 LOCK ) ) { parse Turret 2 Lock ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( SI ) ) { parse SI ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( HEAT ) ) { parse Heat ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( FUEL ) ) { parse Fuel ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( KF ) ) { parse KF ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( SAIL ) ) { parse Sail ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( AEROCRIT ) ) { parse Aero Crit ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( TANKCRIT ) ) { parse Tank Crit ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( BOMBS ) ) { parse Bombs ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( C3 I ) ) { parse C 3 I ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( BA MEA ) ) { parse BAMEA ( curr Ele , entity ) ; } else if ( node Name . equals Ignore Case ( BA APM ) ) { parse BAAPM ( curr Ele , entity ) ; } } else { continue ; } } list . add ( entity ) ; }
public static File locate Replicator Log Dir ( ) { if ( replicator Log Dir == null ) { String replicator Log = System . get Property ( LOG DIR ) ; if ( replicator Log == null ) replicator Log Dir = new File ( locate Replicator Home Dir ( ) , STRING ) ; else replicator Log Dir = new File ( replicator Log ) ; if ( ! replicator Log Dir . is Directory ( ) ) { throw new Server Runtime Exception ( STRING + replicator Log Dir ) ; } } return replicator Log Dir ; }
public void add Record ( String message Id , int i , double d ) { if ( m msg Data == null ) { m msg Data = new Tree Map < String , Log Normal Score . Msg Data > ( ) ; m min Lambda = NUM ; } final Msg Data data = new Msg Data ( ) ; data . m total Log Counts = i ; data . m lambda = d ; m msg Data . put ( message Id , data ) ; m min Lambda = Math . min ( data . m lambda , m min Lambda ) ; m total Interval Count = NUM ; }
private DD compute E By Taylor Series ( ) { DD s = DD . value Of ( NUM ) ; DD t = DD . value Of ( NUM ) ; double n = NUM ; int i = NUM ; while ( t . double Value ( ) > DD . EPS ) { i ++ ; n += NUM ; t = t . divide ( DD . value Of ( n ) ) ; s = s . add ( t ) ; } return s ; }
public java . lang . String Builder append ( float f ) { return append ( Float . to String ( f ) ) ; }
public static void ensure Directory ( String ... file Paths ) { if ( file Paths != null ) { File file ; for ( String file Path : file Paths ) { file = new File ( file Path ) ; if ( file . exists ( ) && ! file . is Directory ( ) ) { throw new Illegal Argument Exception ( STRING + file . get Absolute Path ( ) ) ; } else if ( ! file . exists ( ) ) { if ( ! file . mkdirs ( ) ) { throw new Illegal State Exception ( STRING + file . get Absolute Path ( ) ) ; } } } } }
public String test Destination ( Location destination , Track track ) { return rs Test Destination ( destination , track ) ; }
@ Override public Text Annotation next ( ) { if ( stack . is Empty ( ) && file Index >= file List . size ( ) ) throw new No Such Element Exception ( ) ; if ( stack Index >= stack . size ( ) ) { stack Index = NUM ; do { try { stack = get Text Annotations From File ( file List . get ( file Index ++ ) ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new No Such Element Exception ( e . get Message ( ) ) ; } } while ( stack . is Empty ( ) && file Index < file List . size ( ) ) ; } Text Annotation return Ta = stack . get ( stack Index ++ ) ; return return Ta ; }
static Stack Trace Element find Test Class Trace Element ( Stack Trace Element [ ] trace ) { for ( int i = trace . length - NUM ; i >= NUM ; i -- ) { Stack Trace Element element = trace [ i ] ; if ( TEST CASE CLASS . equals ( element . get Class Name ( ) ) && TEST CASE METHOD . equals ( element . get Method Name ( ) ) ) { return trace [ i - NUM ] ; } } throw new Illegal Argument Exception ( STRING ) ; }
public static String deployment Action In Progress Feedback ( final String id ) throws JSON Exception { return deployment Action Feedback ( id , STRING ) ; }
protected void on Before Process ( ) { }
public DOM 4 J Test Document Builder Factory ( Document Builder Setting [ ] settings ) throws DOM Test Incompatible Exception { super ( settings ) ; try { Class Loader class Loader = Class Loader . get System Class Loader ( ) ; Class dom Factory Class = class Loader . load Class ( STRING ) ; Method get Instance = dom Factory Class . get Method ( STRING , new Class [ ] { } ) ; dom Factory = get Instance . invoke ( null , new Object [ ] { } ) ; dom Impl = ( DOM Implementation ) dom Factory ; Class sax Reader Class = class Loader . load Class ( STRING ) ; Constructor sax Reader Constructor = sax Reader Class . get Constructor ( new Class [ ] { class Loader . load Class ( STRING ) } ) ; sax Reader = sax Reader Constructor . new Instance ( new Object [ ] { dom Factory } ) ; Method get Reader Method = sax Reader Class . get Method ( STRING , new Class [ ] { } ) ; xml Reader = ( XML Reader ) get Reader Method . invoke ( sax Reader , new Object [ NUM ] ) ; read Method = sax Reader Class . get Method ( STRING , new Class [ ] { java . net . URL . class } ) ; } catch ( Invocation Target Exception ex ) { throw new DOM Test Incompatible Exception ( ex . get Target Exception ( ) , null ) ; } catch ( Exception ex ) { throw new DOM Test Incompatible Exception ( ex , null ) ; } }
public void write ( Input Stream stream ) { if ( is Final ) { log . warning ( STRING ) ; return ; } try { int n Read ; byte [ ] buffer = new byte [ NUM * NUM ] ; while ( ( n Read = stream . read ( buffer , NUM , buffer . length ) ) != - NUM ) { byte [ ] new Data = new byte [ data . length + n Read ] ; System . arraycopy ( data , NUM , new Data , NUM , data . length ) ; System . arraycopy ( buffer , NUM , new Data , data . length , n Read ) ; data = new Data ; } } catch ( IO Exception e ) { log . warning ( STRING ) ; } }
public String parse ( String input Template , String intput Encoding , String output File , String output Encoding , String object ID , Object object ) throws Exception { if ( object ID != null && object != null ) { control Context . put ( object ID , object ) ; } Template template = get Template ( input Template , input Encoding != null ? input Encoding : this . input Encoding ) ; if ( output File == null || output File . equals ( STRING ) ) { String Writer sw = new String Writer ( ) ; template . merge ( control Context , sw ) ; return sw . to String ( ) ; } else { Writer writer = null ; if ( writers . get ( output File ) == null ) { writer = get Writer ( get Output Path ( ) + File . separator + output File , output Encoding != null ? output Encoding : this . output Encoding ) ; writers . put ( output File , writer ) ; } else { writer = ( Writer ) writers . get ( output File ) ; } Velocity Context vc = new Velocity Context ( control Context ) ; template . merge ( vc , writer ) ; return STRING ; } }
private String read Alternate Link ( Xml Pull Parser parser ) throws IO Exception , Xml Pull Parser Exception { String link = null ; parser . require ( Xml Pull Parser . START TAG , ns , STRING ) ; String tag = parser . get Name ( ) ; String rel Type = parser . get Attribute Value ( null , STRING ) ; if ( rel Type . equals ( STRING ) ) { link = parser . get Attribute Value ( null , STRING ) ; } while ( BOOL ) { if ( parser . next Tag ( ) == Xml Pull Parser . END TAG ) { break ; } } return link ; }
public void write Exif ( byte [ ] jpeg , String exif Out File Name ) throws File Not Found Exception , IO Exception { if ( jpeg == null || exif Out File Name == null ) { throw new Illegal Argument Exception ( NULL ARGUMENT STRING ) ; } Output Stream s = null ; s = get Exif Writer Stream ( exif Out File Name ) ; s . write ( jpeg , NUM , jpeg . length ) ; s . flush ( ) ; s . close ( ) ; }
private void create Esxi Session ( Image Server Dialog d , Compute Image Job job , Compute Image ci , Compute Image Server image Server ) { String s = Image Server Utils . get Resource As String ( ESXI 5 X UUID TEMPLATE ) ; String Builder sb = new String Builder ( s ) ; Image Server Utils . replace All ( sb , STRING , ci . get Image Name ( ) ) ; Image Server Utils . replace All ( sb , STRING , ci . get Path To Directory ( ) ) ; Image Server Utils . replace All ( sb , STRING , job . get Pxe Boot Identifier ( ) ) ; String content = sb . to String ( ) ; log . trace ( content ) ; d . write File ( image Server . get Tftp Boot Dir ( ) + PXELINUX CFG DIR + job . get Pxe Boot Identifier ( ) , content ) ; s = d . read File ( image Server . get Tftp Boot Dir ( ) + ci . get Path To Directory ( ) + STRING ) ; sb = new String Builder ( s . trim ( ) ) ; Image Server Utils . replace All ( sb , STRING , STRING + ci . get Path To Directory ( ) ) ; Image Server Utils . replace All ( sb , STRING , STRING + image Server . get Image Server Second Ip ( ) + STRING + image Server . get Image Server Http Port ( ) + STRING + job . get Pxe Boot Identifier ( ) + STRING ) ; content = sb . to String ( ) ; log . trace ( content ) ; d . write File ( image Server . get Tftp Boot Dir ( ) + PXELINUX CFG DIR + job . get Pxe Boot Identifier ( ) + STRING , content ) ; content = generate Kickstart ( job , ci , image Server ) ; d . write File ( image Server . get Tftp Boot Dir ( ) + HTTP KICKSTART DIR + job . get Pxe Boot Identifier ( ) , content ) ; content = generate Firstboot ( job , ci ) ; d . write File ( image Server . get Tftp Boot Dir ( ) + HTTP FIRSTBOOT DIR + job . get Pxe Boot Identifier ( ) , content ) ; d . rm ( image Server . get Tftp Boot Dir ( ) + HTTP SUCCESS DIR + job . get Pxe Boot Identifier ( ) ) ; d . rm ( image Server . get Tftp Boot Dir ( ) + HTTP FAILURE DIR + job . get Pxe Boot Identifier ( ) ) ; }
public void add Extension ( String ext ) { synchronized ( exts ) { ext = ext . to Lower Case ( ) ; exts . add ( ext ) ; } }
public void add Observer ( Observer observer ) { if ( observer == null ) { throw new Null Pointer Exception ( ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public double distance ( Vec x , List < Double > qi , int k ) { if ( k >= mean Sqrd Norms . length || k < NUM ) throw new Index Out Of Bounds Exception ( STRING + mean Sqrd Norms . length + STRING + k + STRING ) ; return Math . sqrt ( Math . max ( kernel . eval ( NUM , NUM , Arrays . as List ( x ) , qi ) - NUM / ownes [ k ] * eval Sum K ( x , qi , k , new Designations ) + mean Sqrd Norms [ k ] * norm Consts [ k ] , NUM ) ) ; }
public String process Pattern ( String new Pattern ) throws Illegal Argument Exception { int idx = NUM ; int offnum = - NUM ; String Buffer outpat = new String Buffer ( ) ; offsets = new int [ BUFSIZE ] ; arguments = new String [ BUFSIZE ] ; max Offset = - NUM ; while ( BOOL ) { int ridx = - NUM ; int lidx = new Pattern . index Of ( ldel , idx ) ; if ( lidx >= NUM ) { ridx = new Pattern . index Of ( rdel , lidx + ldel . length ( ) ) ; } else { break ; } if ( ++ offnum >= BUFSIZE ) { throw new Illegal Argument Exception ( STRING ) ; } if ( ridx < NUM ) { if ( exactmatch ) { throw new Illegal Argument Exception ( STRING ) ; } else { break ; } } outpat . append ( new Pattern . substring ( idx , lidx ) ) ; offsets [ offnum ] = outpat . length ( ) ; arguments [ offnum ] = new Pattern . substring ( lidx + ldel . length ( ) , ridx ) ; idx = ridx + rdel . length ( ) ; max Offset ++ ; } outpat . append ( new Pattern . substring ( idx ) ) ; return outpat . to String ( ) ; }
void retain ( Object owner , Field field ) { retain ( ) ; Map < String , Integer > fields = owners . get ( owner ) ; if ( fields == null ) { fields = new Hash Map < > ( ) ; owners . put ( owner , fields ) ; } Integer count = fields . get ( field . to Generic String ( ) ) ; if ( count == null ) { fields . put ( field . to Generic String ( ) , NUM ) ; } else { count ++ ; fields . put ( field . to Generic String ( ) , count ) ; } }
public static List < Alert Dto > transform To Dto ( List < Alert > alerts ) { if ( alerts == null ) { throw new Web Application Exception ( STRING , Status . INTERNAL SERVER ERROR ) ; } List < Alert Dto > result = new Array List < Alert Dto > ( ) ; for ( Alert alert : alerts ) { result . add ( transform To Dto ( alert ) ) ; } return result ; }
public void test Execute Null Runnable ( ) { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { @ Suppress Warnings ( STRING ) Future < ? > future = e . submit ( ( Runnable ) null ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void remove Group Properties Listener ( Group Properties Listener group Properties Listener ) { group Properties Listeners . remove ( group Properties Listener ) ; }
public static void edit Global Edge Comment ( final Abstract SQL Provider provider , final I Navi Edge edge , final Integer comment Id , final Integer user Id , final String new Comment ) throws Couldnt Save Data Exception { Preconditions . check Not Null ( provider , STRING ) ; Preconditions . check Not Null ( edge , STRING ) ; Preconditions . check Not Null ( comment Id , STRING ) ; Preconditions . check Not Null ( user Id , STRING ) ; Postgre SQL Comment Functions . edit Comment ( provider , comment Id , user Id , new Comment ) ; }
private void report Exception Throw ( Element element , Throwable t ) { if ( element != null ) { log Message ( STRING , element ) ; } log Exception ( t ) ; error Message ( element , STRING , t , Arrays . to String ( Arrays . copy Of ( t . get Stack Trace ( ) , NUM ) ) ) ; }
public synchronized void clear Sessions ( Context context , Boolean clear Credentials ) { synchronized ( LOG TAG ) { while ( mMX Sessions . size ( ) > NUM ) { clear Session ( context , mMX Sessions . get ( NUM ) , clear Credentials ) ; } } }
protected void check If Deleted User ( SSO Token token , String user DN ) throws AM Entry Exists Exception { String user Attribute [ ] = { USER STATUS ATTRIBUTE } ; Attr attr ; try { Persistent Object po = UMS Object . get Object ( token , new Guid ( user DN ) , user Attribute ) ; attr = po . get Attribute ( USER STATUS ATTRIBUTE ) ; } catch ( UMS Exception ue ) { if ( debug . message Enabled ( ) ) debug . message ( STRING , ue ) ; return ; } if ( attr != null ) { String attr Value = attr . get Value ( ) ; if ( attr Value != null && attr Value . equals Ignore Case ( STRING ) ) { debug . warning ( STRING + STRING + user DN ) ; throw new AM Entry Exists Exception ( AMSDK Bundle . get String ( STRING ) , STRING ) ; } } }
private double [ ] line Intersect ( double x1 , double y1 , double x2 , double y2 , double x , double y , double offset ) { double xval ; double yval ; double xn = - NUM , yn = - NUM ; double change ; if ( x == NUM ) { if ( ( x1 <= offset && offset < x2 ) || ( x1 >= offset && offset > x2 ) ) { xval = x1 - x2 ; change = ( offset - x2 ) / xval ; yn = ( y1 - y2 ) * change + y2 ; if ( NUM <= yn && yn <= y ) { xn = offset ; } else { xn = - NUM ; } } } else if ( y == NUM ) { if ( ( y1 <= offset && offset < y2 ) || ( y1 >= offset && offset > y2 ) ) { yval = ( y1 - y2 ) ; change = ( offset - y2 ) / yval ; xn = ( x1 - x2 ) * change + x2 ; if ( NUM <= xn && xn <= x ) { yn = offset ; } else { xn = - NUM ; } } } double [ ] ret = new double [ NUM ] ; ret [ NUM ] = xn ; ret [ NUM ] = yn ; return ret ; }
private void create Partition Region ( List vm List , int start Index For Region , int end Index For Region , int local Max Memory , int redundancy ) { Iterator node Iterator = vm List . iterator ( ) ; while ( node Iterator . has Next ( ) ) { VM vm = ( VM ) node Iterator . next ( ) ; vm . invoke ( create Multiple PR With Total Num Bucket Prop Set ( pr Prefix , start Index For Region , end Index For Region , redundancy , local Max Memory , NUM ) ) ; } }
private void fft ( double re [ ] , double im [ ] , int direction ) { int n = re . length ; int bits = ( int ) Math . rint ( Math . log ( n ) / Math . log ( NUM ) ) ; if ( n != ( NUM << bits ) ) throw new Illegal Argument Exception ( STRING ) ; int local N ; int j = NUM ; for ( int i = NUM ; i < n - NUM ; i ++ ) { if ( i < j ) { double temp = re [ j ] ; re [ j ] = re [ i ] ; re [ i ] = temp ; temp = im [ j ] ; im [ j ] = im [ i ] ; im [ i ] = temp ; } int k = n / NUM ; while ( ( k >= NUM ) && ( k - NUM < j ) ) { j = j - k ; k = k / NUM ; } j = j + k ; } for ( int m = NUM ; m <= bits ; m ++ ) { local N = NUM << m ; double Wjk r = NUM ; double Wjk i = NUM ; double theta = two PI / local N ; double Wj r = Math . cos ( theta ) ; double Wj i = direction * Math . sin ( theta ) ; int nby 2 = local N / NUM ; for ( j = NUM ; j < nby 2 ; j ++ ) { for ( int k = j ; k < n ; k += local N ) { int id = k + nby 2 ; double tempr = Wjk r * re [ id ] - Wjk i * im [ id ] ; double tempi = Wjk r * im [ id ] + Wjk i * re [ id ] ; re [ id ] = re [ k ] - tempr ; im [ id ] = im [ k ] - tempi ; re [ k ] += tempr ; im [ k ] += tempi ; } double wtemp = Wjk r ; Wjk r = Wj r * Wjk r - Wj i * Wjk i ; Wjk i = Wj r * Wjk i + Wj i * wtemp ; } } }
private void build Network ( final Network network , int [ ] nodes Per Layer , Point 2 D initial Position , final Neuron input Neuron Template ) { set Label ( STRING ) ; List < Neuron > input Layer Neurons = new Array List < Neuron > ( ) ; for ( int i = NUM ; i < nodes Per Layer [ NUM ] ; i ++ ) { input Layer Neurons . add ( new Neuron ( network , input Neuron Template ) ) ; } Neuron Group input Layer = new Neuron Group ( network , input Layer Neurons ) ; input Layer . set Clamped ( BOOL ) ; add Neuron Group ( input Layer ) ; input Layer . set Layout Based On Size ( initial Position ) ; Synapse synapse = Synapse . get Template Synapse ( new Static Synapse Rule ( ) ) ; synapse . set Lower Bound ( - NUM ) ; synapse . set Upper Bound ( NUM ) ; Neuron Group last Layer = input Layer ; for ( int i = NUM ; i < nodes Per Layer . length ; i ++ ) { List < Neuron > hidden Layer Neurons = new Array List < Neuron > ( ) ; for ( int j = NUM ; j < nodes Per Layer [ i ] ; j ++ ) { Sigmoidal Rule rule = new Sigmoidal Rule ( ) ; Neuron neuron = new Neuron ( network , rule ) ; rule . set Lower Bound ( NUM ) ; neuron . set Update Priority ( i ) ; hidden Layer Neurons . add ( neuron ) ; } Neuron Group hidden Layer = new Neuron Group ( network , hidden Layer Neurons ) ; hidden Layer . set Layout Based On Size ( ) ; add Neuron Group ( hidden Layer ) ; Network Layout Manager . offset Neuron Group ( last Layer , hidden Layer , Direction . NORTH , between Layer Interval ) ; All To All connection = new All To All ( ) ; Synapse Group lh = connect Neuron Groups ( last Layer , hidden Layer , connection ) ; lh . randomize Connection Weights ( ) ; last Layer = hidden Layer ; } }
private static boolean are Equal ( int from Index , Char Sequence left , Char Sequence right ) { if ( left == right ) return BOOL ; if ( ( left == null ) || ( right == null ) ) return BOOL ; int n = left . length ( ) ; if ( right . length ( ) != n ) return BOOL ; for ( int i = n ; i > from Index ; ) { if ( left . char At ( -- i ) != right . char At ( i ) ) return BOOL ; } return BOOL ; }
public int num productions ( ) { return productions . size ( ) ; }
public void add Tight Source Node ( AST Node reference ) { f Tight Source Range Nodes . add ( reference ) ; List < Structural Property Descriptor > properties = reference . structural Properties For Type ( ) ; for ( Iterator < Structural Property Descriptor > iterator = properties . iterator ( ) ; iterator . has Next ( ) ; ) { Structural Property Descriptor descriptor = iterator . next ( ) ; if ( descriptor . is Child Property ( ) ) { AST Node child = ( AST Node ) reference . get Structural Property ( descriptor ) ; if ( child != null && is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } else if ( descriptor . is Child List Property ( ) ) { List < ? extends AST Node > children = AST Nodes . get Child List Property ( reference , ( Child List Property Descriptor ) descriptor ) ; for ( Iterator < ? extends AST Node > iterator 2 = children . iterator ( ) ; iterator 2 . has Next ( ) ; ) { AST Node child = iterator 2 . next ( ) ; if ( is Extending ( child , reference ) ) { add Tight Source Node ( child ) ; } } } } }
protected boolean is Event Disabled ( X Event e ) { if ( enable Log . is Loggable ( Platform Logger . Level . FINEST ) ) { enable Log . finest ( STRING , e , ( is Enabled ( ) ? STRING : STRING ) ) ; } if ( ! is Enabled ( ) ) { switch ( e . get type ( ) ) { case X Constants . Button Press : case X Constants . Button Release : case X Constants . Key Press : case X Constants . Key Release : case X Constants . Enter Notify : case X Constants . Leave Notify : case X Constants . Motion Notify : if ( enable Log . is Loggable ( Platform Logger . Level . FINER ) ) { enable Log . finer ( STRING , e ) ; } return BOOL ; } } switch ( e . get type ( ) ) { case X Constants . Map Notify : case X Constants . Unmap Notify : return BOOL ; } return super . is Event Disabled ( e ) ; }
public D Policy Qualifier Info Chooser ( J Frame parent , String title , Policy Qualifier Info policy Qualifier Info ) throws IO Exception { super ( parent , title , Modality Type . DOCUMENT MODAL ) ; init Components ( policy Qualifier Info ) ; }
protected void transform Path ( Path path ) { path . transform ( m Matrix Value To Px ) ; path . transform ( m Matrix Touch ) ; path . transform ( m Matrix Offset ) ; }
private void convert Procedure Call ( final String Builder target , final String procedure Call ) throws SQL Exception { FB Escaped Call Parser temp Parser = new FB Escaped Call Parser ( mode ) ; FB Procedure Call call = temp Parser . parse Call ( procedure Call ) ; call . check Parameters ( ) ; target . append ( call . get SQL ( BOOL ) ) ; }
public void add Chat Session Listener ( Chat Session Listener listener ) { if ( ( listener != null ) && ! m Listeners . contains ( listener ) ) { m Listeners . add ( listener ) ; } }
List < Isilon Event > filter Events ( List < Isilon Event > events ) { long most Recent Timestamp = latest Time Threshold ; List < Isilon Event > filtered Events = new Array List < Isilon Event > ( ) ; for ( Isilon Event event : events ) { long latest Time = event . get Latest Time ( ) ; if ( latest Time > latest Time Threshold ) { filtered Events . add ( event ) ; if ( latest Time > most Recent Timestamp ) { most Recent Timestamp = latest Time ; } } } most Recent Timestamp In Polling Cycle = most Recent Timestamp ; return filtered Events ; }
public Packet Output Stream write Date Length ( final Calendar calendar ) { assure Buffer Capacity ( NUM ) ; buffer . put ( ( byte ) NUM ) ; buffer . put Short ( ( short ) calendar . get ( Calendar . YEAR ) ) ; buffer . put ( ( byte ) ( ( calendar . get ( Calendar . MONTH ) + NUM ) & NUM ) ) ; buffer . put ( ( byte ) ( calendar . get ( Calendar . DAY OF MONTH ) & NUM ) ) ; buffer . put ( ( byte ) NUM ) ; buffer . put ( ( byte ) NUM ) ; buffer . put ( ( byte ) NUM ) ; return this ; }
public void store Device Throttled ( Device d ) { long interval Ns = sync Store Write Interval Ms * NUM * NUM ; if ( ! is Master ) return ; if ( d == null ) return ; long now = System . nano Time ( ) ; Long last = last Write Times . get ( d . get Device Key ( ) ) ; if ( last == null || now - last > interval Ns ) { write Updated Device To Storage ( d ) ; last Write Times . put ( d . get Device Key ( ) , now ) ; } else { cnt Device Store Throttled . update Counter With Flush ( ) ; } }
private boolean is Message From User ( Message message , User user ) { String user Id = null ; boolean is My Message = BOOL ; if ( message . user != null && message . user . user ID != null ) { user Id = message . user . user ID ; } else { user Id = message . user ID ; } if ( user Id . equals ( user . user ID ) ) { is My Message = BOOL ; } if ( message . type == Const . Message Type . TYPE NEW USER || message . type == Const . Message Type . TYPE USER LEAVE ) { is My Message = BOOL ; } return is My Message ; }
synchronized void do Connect ( Inet Address address , int port , int timeout ) throws IO Exception { synchronized ( fd Lock ) { if ( ! close Pending && ( socket == null || ! socket . is Bound ( ) ) ) { Net Hooks . before Tcp Connect ( fd , address , port ) ; } } try { acquire FD ( ) ; try { socket Connect ( address , port , timeout ) ; synchronized ( fd Lock ) { if ( close Pending ) { throw new Socket Exception ( STRING ) ; } } if ( socket != null ) { socket . set Bound ( ) ; socket . set Connected ( ) ; } } finally { release FD ( ) ; } } catch ( IO Exception e ) { close ( ) ; throw e ; } }
public static boolean is Boolean ( String str ) { return str . equals ( STRING ) || str . equals ( STRING ) || str . equals ( STRING ) || str . equals ( STRING ) ; }
protected void handle Install Request Failure ( Member State member , Install Request request , Throwable error ) { fail Attempt ( member , error ) ; }
public List < Feed Item > load All Deep From Cursor ( Cursor cursor ) { int count = cursor . get Count ( ) ; List < Feed Item > list = new Array List < Feed Item > ( count ) ; if ( cursor . move To First ( ) ) { if ( identity Scope != null ) { identity Scope . lock ( ) ; identity Scope . reserve Room ( count ) ; } try { do { list . add ( load Current Deep ( cursor , BOOL ) ) ; } while ( cursor . move To Next ( ) ) ; } finally { if ( identity Scope != null ) { identity Scope . unlock ( ) ; } } } return list ; }
public static String decode ( Byte Buffer buff ) throws Character Coding Exception { Char Buffer chars = UTF 8 Decoder . decode ( buff ) ; return chars . to String ( ) ; }
protected List < String > convert List To Lower Case ( List < String > list ) { List < String > lower Case List = new Array List < > ( ) ; for ( String value : list ) { lower Case List . add ( value . to Lower Case ( ) ) ; } return lower Case List ; }
public boolean write Next Part ( byte [ ] data ) throws J Plag Exception { if ( remaining Bytes < data . length ) { throw new J Plag Exception ( STRING , STRING + STRING , STRING ) ; } try { File Output Stream out = new File Output Stream ( file , BOOL ) ; out . write ( data ) ; out . close ( ) ; remaining Bytes -= data . length ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; throw new J Plag Exception ( STRING , STRING + STRING , STRING ) ; } return remaining Bytes == NUM ; }
private J Tabbed Pane create Tabbed Pane ( final boolean is Default Settings Dialog , final boolean is Callgraph ) { final J Tabbed Pane tab = new J Tabbed Pane ( ) ; add Tab ( tab , STRING , new C Automatism Panel ( m settings , is Default Settings Dialog ) ) ; add Tab ( tab , STRING , new C Edge Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Hierarchic Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Orthogonal Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Circular Panel ( m settings ) ) ; if ( ! is Callgraph ) { add Tab ( tab , STRING , new C Disassembly Panel ( m settings ) ) ; } add Tab ( tab , STRING , new C Controls Panel ( m settings ) ) ; add Tab ( tab , STRING , new C Misc Panel ( m settings , ! is Default Settings Dialog || is Callgraph ) ) ; tab . set Preferred Size ( new Dimension ( FRAME WIDTH , FRAME HEIGHT ) ) ; return tab ; }
public void update Width ( ) { if ( m Sum Of Weights > NUM ) { double mean = m Weighted Sum / m Sum Of Weights ; double variance = m Weighted Sum Squared / m Sum Of Weights - mean * mean ; if ( variance < NUM ) { variance = NUM ; } m Width = Math . sqrt ( variance ) * Math . pow ( m Sum Of Weights , m Exponent ) ; if ( m Width <= m Min Width ) { m Width = m Min Width ; } } else { m Width = Double . MAX VALUE ; } }
public OF Vendor Data Type lookup Vendor Data Type ( int vendor Data Type ) { return data Type Map . get ( Long . value Of ( vendor Data Type ) ) ; }

public static int find Global Valley Location ( float [ ] data ) { float min = Float . Na N ; int imin = - NUM ; for ( int i = NUM ; i < data . length ; i ++ ) { if ( Float . is Na N ( data [ i ] ) ) continue ; if ( Float . is Na N ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }
protected void move Up Selected ( ) { int selected Index = table . get Selected Row ( ) ; if ( selected Index > - NUM ) { int index = data . move Up ( index To Model ( selected Index ) ) ; set Row Selected ( index To View ( index ) ) ; } }
private Volume find RPV Plex Volume With Orginal Assets ( String Set backing Volume UR Is ) { Volume vol With Original Assets = null ; for ( String backing Volume URI : backing Volume UR Is ) { Volume backing Volume = db Client . query Object ( Volume . class , URI . create ( backing Volume URI ) ) ; if ( backing Volume != null && backing Volume . get Virtual Pool ( ) != null ) { Virtual Pool vpool = db Client . query Object ( Virtual Pool . class , backing Volume . get Virtual Pool ( ) ) ; if ( Virtual Pool . is RPV Plex Protect HA Side ( vpool ) ) { vol With Original Assets = backing Volume ; break ; } } } return vol With Original Assets ; }
public void stop ( ) { executor . shutdown ( ) ; try { executor . await Termination ( TERMINATE DELAY , Time Unit . SECONDS ) ; } catch ( Exception e ) { logger . error ( STRING ) ; if ( ! executor . is Shutdown ( ) ) { executor . shutdown Now ( ) ; } } }
private static boolean update Index ( final Project project , final Virtual File root , final Collection < File Path > added , final Collection < File Path > removed , final List < Vcs Exception > exceptions ) { boolean rc = BOOL ; if ( ! added . is Empty ( ) ) { try { Git File Utils . add Paths ( project , root , added ) ; } catch ( Vcs Exception ex ) { exceptions . add ( ex ) ; rc = BOOL ; } } if ( ! removed . is Empty ( ) ) { try { Git File Utils . delete ( project , root , removed , STRING ) ; } catch ( Vcs Exception ex ) { exceptions . add ( ex ) ; rc = BOOL ; } } return rc ; }
public boolean login ( ) throws Login Exception { switch ( status ) { case UNINITIALIZED : default : throw new Login Exception ( STRING ) ; case INITIALIZED : case AUTHENTICATED : if ( token && ! null Stream ) { throw new Login Exception ( STRING + P11 KEYSTORE + STRING + NONE ) ; } if ( token && private Key Password URL != null ) { throw new Login Exception ( STRING + P11 KEYSTORE + STRING ) ; } if ( protected Path && ( key Store Password URL != null || private Key Password URL != null ) ) { throw new Login Exception ( STRING + STRING ) ; } if ( protected Path ) { get Alias And Passwords ( PROTECTED PATH ) ; } else if ( token ) { get Alias And Passwords ( TOKEN ) ; } else { get Alias And Passwords ( NORMAL ) ; } try { get Key Store Info ( ) ; } finally { if ( private Key Password != null && private Key Password != key Store Password ) { Arrays . fill ( private Key Password , STRING ) ; private Key Password = null ; } if ( key Store Password != null ) { Arrays . fill ( key Store Password , STRING ) ; key Store Password = null ; } } status = AUTHENTICATED ; return BOOL ; case LOGGED IN : return BOOL ; } }
private Date advance To Next Day Of Week If Necessary ( Date fire Time , boolean force To Advance Next Day ) { Time Of Day s Time Of Day = get Start Time Of Day ( ) ; Date fire Time Start Date = s Time Of Day . get Time Of Day For Date ( fire Time ) ; Calendar fire Time Start Date Cal = create Calendar Time ( fire Time Start Date ) ; int day Of Week Of Fire Time = fire Time Start Date Cal . get ( Calendar . DAY OF WEEK ) ; Set < Integer > days Of Week To Fire = get Days Of Week ( ) ; if ( force To Advance Next Day || ! days Of Week To Fire . contains ( day Of Week Of Fire Time ) ) { for ( int i = NUM ; i <= NUM ; i ++ ) { fire Time Start Date Cal . add ( Calendar . DATE , NUM ) ; day Of Week Of Fire Time = fire Time Start Date Cal . get ( Calendar . DAY OF WEEK ) ; if ( days Of Week To Fire . contains ( day Of Week Of Fire Time ) ) { fire Time = fire Time Start Date Cal . get Time ( ) ; break ; } } } Date e Time = get End Time ( ) ; if ( e Time != null && fire Time . get Time ( ) > e Time . get Time ( ) ) { return null ; } return fire Time ; }
public static Vector 3 ceil ( Vector 3 o ) { return new Vector 3 ( Math . ceil ( o . x ) , Math . ceil ( o . y ) , Math . ceil ( o . z ) ) ; }
@ Override protected boolean is Frontier Empty ( ) { clean Up Frontier ( ) ; update Metrics ( frontier . size ( ) ) ; return frontier . is Empty ( ) ; }
private void parse Attributes ( Typed Array a ) { bar Width = ( int ) a . get Dimension ( R . styleable . Progress Wheel bar Width , bar Width ) ; rim Width = ( int ) a . get Dimension ( R . styleable . Progress Wheel rim Width , rim Width ) ; spin Speed = ( int ) a . get Dimension ( R . styleable . Progress Wheel spin Speed , spin Speed ) ; delay Millis = a . get Integer ( R . styleable . Progress Wheel delay Millis , delay Millis ) ; if ( delay Millis < NUM ) { delay Millis = NUM ; } bar Color = a . get Color ( R . styleable . Progress Wheel bar Color , bar Color ) ; bar Length = ( int ) a . get Dimension ( R . styleable . Progress Wheel bar Length , bar Length ) ; text Size = ( int ) a . get Dimension ( R . styleable . Progress Wheel text Size , text Size ) ; text Color = ( int ) a . get Color ( R . styleable . Progress Wheel text Color , text Color ) ; if ( a . has Value ( R . styleable . Progress Wheel text ) ) { set Text ( a . get String ( R . styleable . Progress Wheel text ) ) ; } rim Color = ( int ) a . get Color ( R . styleable . Progress Wheel rim Color , rim Color ) ; circle Color = ( int ) a . get Color ( R . styleable . Progress Wheel circle Color , circle Color ) ; contour Color = a . get Color ( R . styleable . Progress Wheel contour Color , contour Color ) ; contour Size = a . get Dimension ( R . styleable . Progress Wheel contour Size , contour Size ) ; a . recycle ( ) ; }
public static byte [ ] concatenate ( byte [ ] a , byte [ ] b ) { int length A = a . length ; int length B = b . length ; byte [ ] concat = new byte [ length A + length B ] ; System . arraycopy ( a , NUM , concat , NUM , length A ) ; System . arraycopy ( b , NUM , concat , length A , length B ) ; return concat ; }
public boolean before Everyday ( Omni Date compare Date ) { Calendar calendar = Calendar . get Instance ( ) ; calendar . set Time ( compare Date . get Date ( ) ) ; int compare Hour = calendar . get ( Calendar . HOUR OF DAY ) ; int compare Minute = calendar . get ( Calendar . MINUTE ) ; int compare Second = calendar . get ( Calendar . SECOND ) ; int compare Second In Day = compare Hour * SECONDS IN HOUR + compare Minute * SECONDS IN MINUTE + compare Second ; calendar . set Time ( value ) ; int hour = calendar . get ( Calendar . HOUR OF DAY ) ; int minute = calendar . get ( Calendar . MINUTE ) ; int second = calendar . get ( Calendar . SECOND ) ; int second In Day = hour * SECONDS IN HOUR + minute * SECONDS IN MINUTE + second ; if ( second In Day <= compare Second In Day ) { return BOOL ; } return BOOL ; }
public void change Item Text At Position ( int item Index , String new Text ) { if ( item Index < NUM || item Index > space Items . size ( ) ) { throw Array Index Out Of Bounds Exception ( item Index ) ; } else { Space Item space Item = space Items . get ( item Index ) ; Relative Layout text And Icon Container = ( Relative Layout ) space Item List . get ( item Index ) ; Text View space Item Icon = ( Text View ) text And Icon Container . find View By Id ( R . id . space text ) ; space Item Icon . set Text ( new Text ) ; space Item . set Item Name ( new Text ) ; changed Item And Icon Hash Map . put ( item Index , space Item ) ; } }
public void map Volume To SCSI Initiator ( String volume Id , String initiator Id ) throws Exception { log . info ( STRING ) ; String uri = Scale IO Constants . get Map Volume To Scsi Initiator URI ( volume Id ) ; Scale IO Map Volume To Scsi Initiator map Parm = new Scale IO Map Volume To Scsi Initiator ( ) ; map Parm . set Scsi Initiator Id ( initiator Id ) ; map Parm . set Allow Multiple Mapp ( STRING ) ; post ( URI . create ( uri ) , get Json For Entity ( map Parm ) ) ; }
public static < T > Collection < T > not Empty ( Collection < T > list , String name ) { not Null ( list , name ) ; if ( list . is Empty ( ) ) { throw new Illegal Argument Exception ( String . format ( STRING , name ) ) ; } return list ; }
public final void bounds ( int range ) { double x0 = cx 0 ; double y0 = cy 0 ; double x1 = cx 0 + cx 1 + cx 2 + cx 3 ; double y1 = cy 0 + cy 1 + cy 2 + cy 3 ; double minx = Math . min ( x0 , x1 ) ; double miny = Math . min ( y0 , y1 ) ; double maxx = Math . max ( x0 , x1 ) ; double maxy = Math . max ( y0 , y1 ) ; if ( cx 3 != NUM ) { double t1 = - ( Math . sqrt ( cx 2 * cx 2 - NUM * cx 1 * cx 3 ) + cx 2 ) / ( NUM * cx 3 ) ; double t2 = ( Math . sqrt ( cx 2 * cx 2 - NUM * cx 1 * cx 3 ) - cx 2 ) / ( NUM * cx 3 ) ; if ( t1 > NUM && t1 < NUM ) { double x = eval X ( t1 ) ; minx = Math . min ( x , minx ) ; maxx = Math . max ( x , maxx ) ; } if ( t2 > NUM && t2 < NUM ) { double x = eval X ( t2 ) ; minx = Math . min ( x , minx ) ; maxx = Math . max ( x , maxx ) ; } } if ( cy 3 != NUM ) { double t1 = - ( Math . sqrt ( cy 2 * cy 2 - NUM * cy 1 * cy 3 ) + cy 2 ) / ( NUM * cy 3 ) ; double t2 = ( Math . sqrt ( cy 2 * cy 2 - NUM * cy 1 * cy 3 ) - cy 2 ) / ( NUM * cy 3 ) ; if ( t1 > NUM && t1 < NUM ) { double y = eval Y ( t1 ) ; miny = Math . min ( y , miny ) ; maxy = Math . max ( y , maxy ) ; } if ( t2 > NUM && t2 < NUM ) { double y = eval Y ( t2 ) ; miny = Math . min ( y , miny ) ; maxy = Math . max ( y , maxy ) ; } } add Rect ( ( int ) minx - range , ( int ) miny - range , ( int ) ( maxx + range ) , ( int ) ( maxy + range ) ) ; }
private void fill Ordinal To Block Mapping For Dimension ( ) { int block Ordinal = - NUM ; Carbon Dimension dimension = null ; int index = NUM ; int prvcolumn Group Id = - NUM ; while ( index < dimensions . size ( ) ) { dimension = dimensions . get ( index ) ; if ( dimension . is Columnar ( ) || dimension . column Group Id ( ) != prvcolumn Group Id ) { block Ordinal ++ ; } dimension Ordinal To Block Mapping . put ( dimension . get Ordinal ( ) , block Ordinal ) ; prvcolumn Group Id = dimension . column Group Id ( ) ; index ++ ; } index = NUM ; while ( index < complex Dimensions . size ( ) ) { dimension = complex Dimensions . get ( index ) ; dimension Ordinal To Block Mapping . put ( dimension . get Ordinal ( ) , ++ block Ordinal ) ; block Ordinal = fill Complex Dimension Child Block Index ( block Ordinal , dimension ) ; index ++ ; } fill Block To Dimension Ordinal Mapping ( ) ; }
public void write ( byte [ ] b , int off , int len , long pos ) throws IO Exception { if ( b == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ( off < NUM ) || ( len < NUM ) || ( pos < NUM ) || ( off + len > b . length ) || ( off + len < NUM ) ) { throw new Index Out Of Bounds Exception ( ) ; } long last Pos = pos + len - NUM ; if ( last Pos >= length ) { pad ( last Pos ) ; length = last Pos + NUM ; } int offset = ( int ) ( pos % BUFFER LENGTH ) ; while ( len > NUM ) { byte [ ] buf = get Cache Block ( pos / BUFFER LENGTH ) ; int nbytes = Math . min ( len , BUFFER LENGTH - offset ) ; System . arraycopy ( b , off , buf , offset , nbytes ) ; pos += nbytes ; off += nbytes ; len -= nbytes ; offset = NUM ; } }
public void add Scanning Callback ( One Sheeld Scanning Callback scanning Callback ) { if ( scanning Callback != null && ! scanning Callbacks . contains ( scanning Callback ) ) scanning Callbacks . add ( scanning Callback ) ; }
public void write ( byte [ ] buf , int off , int len ) throws T Transport Exception { if ( output Stream == null ) { throw new T Transport Exception ( T Transport Exception . NOT OPEN , STRING ) ; } try { output Stream . write ( buf , off , len ) ; } catch ( IO Exception iox ) { throw new T Transport Exception ( T Transport Exception . UNKNOWN , iox ) ; } }
public void handle Gateway Receiver Stop ( Gateway Receiver recv ) throws Management Exception { if ( ! is Service Initialised ( STRING ) ) { return ; } Gateway Receiver M Bean mbean = ( Gateway Receiver M Bean ) service . get Local Gateway Receiver MX Bean ( ) ; Gateway Receiver M Bean Bridge bridge = mbean . get Bridge ( ) ; bridge . stop Server ( ) ; Notification notification = new Notification ( JMX Notification Type . GATEWAY RECEIVER STOPPED , member Source , Sequence Number . next ( ) , System . current Time Millis ( ) , Management Constants . GATEWAY RECEIVER STOPPED PREFIX ) ; member Level Notif Emitter . send Notification ( notification ) ; }
public static List < Property > diff ( Shape old Shape , Shape new Shape ) { List < Property > old List = old Shape . get Property List Internal ( BOOL ) ; List < Property > new List = new Shape . get Property List Internal ( BOOL ) ; List < Property > diff = new Array List < > ( old List ) ; diff . add All ( new List ) ; List < Property > intersection = new Array List < > ( old List ) ; intersection . retain All ( new List ) ; diff . remove All ( intersection ) ; return diff ; }
public static boolean is Readable ( final File file ) { if ( file == null || ! file . is File ( ) ) { Log . e ( File Utils . class , STRING ) ; return BOOL ; } return file . exists ( ) && file . can Read ( ) ; }
final public int read ( final byte [ ] a , final int aoff , final int alen ) throws IO Exception { if ( alen == NUM ) { return NUM ; } final int remaining = limit - off ; if ( remaining == NUM ) { return - NUM ; } final int n = remaining < alen ? remaining : alen ; System . arraycopy ( buf , this . off , a , aoff , n ) ; this . off += n ; return n ; }
public void delete Users ( Set users ) throws AM Exception , SSO Exception { Iterator iter = users . iterator ( ) ; while ( iter . has Next ( ) ) { String user DN = ( String ) iter . next ( ) ; AM User user = new AM User Impl ( super . token , user DN ) ; user . delete ( ) ; } }
public String ( byte [ ] bytes , java . lang . String enc ) throws java . io . Unsupported Encoding Exception { this ( bytes To Chars ( bytes , NUM , bytes . length , enc ) ) ; }
private FP Tree build FP Tree ( final Relation < Bit Vector > relation , int [ ] iidx , final int items ) { FP Tree tree = new FP Tree ( items ) ; Finite Progress prog = LOG . is Verbose ( ) ? new Finite Progress ( STRING , relation . size ( ) , LOG ) : null ; int [ ] buf = new int [ items ] ; for ( DBID Iter iditer = relation . iter DBI Ds ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { int l = NUM ; Sparse Feature Vector < ? > bv = relation . get ( iditer ) ; for ( int it = bv . iter ( ) ; bv . iter Valid ( it ) ; it = bv . iter Advance ( it ) ) { int i = iidx [ bv . iter Dim ( it ) ] ; if ( i < NUM ) { continue ; } buf [ l ++ ] = i ; } if ( l >= minlength ) { Arrays . sort ( buf , NUM , l ) ; tree . insert ( buf , NUM , l , NUM ) ; } LOG . increment Processed ( prog ) ; } LOG . ensure Completed ( prog ) ; return tree ; }
protected void scale To ( Projection this Proj ) { if ( DEBUG ) { logger . fine ( STRING ) ; } if ( bitmap == null ) { if ( DEBUG ) { logger . fine ( STRING ) ; } return ; } Rectangle win Rect = new Rectangle ( this Proj . get Width ( ) , this Proj . get Height ( ) ) ; Rectangle proj Rect = new Rectangle ( ) ; proj Rect . set Location ( point 1 ) ; proj Rect . set Size ( point 2 . x - point 1 . x , point 2 . y - point 1 . y ) ; Rectangle source Rect = new Rectangle ( ) ; source Rect . width = bitmap . get Width ( this ) ; source Rect . height = bitmap . get Height ( this ) ; clip Rect = null ; Rectangle i Rect = proj Rect ; if ( corners == null || corners . size ( ) <= NUM ) { i Rect = win Rect . intersection ( proj Rect ) ; } if ( ! i Rect . is Empty ( ) ) { Rectangle n Clip Rect = new Rectangle ( ) ; n Clip Rect . set Bounds ( source Rect ) ; if ( ( i Rect . width >= NUM ) && ( i Rect . height >= NUM ) ) { if ( ! win Rect . contains ( proj Rect ) ) { double x Scale Factor = ( double ) source Rect . width / ( double ) proj Rect . width ; double y Scale Factor = ( double ) source Rect . height / ( double ) proj Rect . height ; int x Offset = i Rect . x - proj Rect . x ; int y Offset = i Rect . y - proj Rect . y ; n Clip Rect . x = ( int ) Math . floor ( x Offset * x Scale Factor ) ; n Clip Rect . y = ( int ) Math . floor ( y Offset * y Scale Factor ) ; n Clip Rect . width = ( int ) Math . ceil ( i Rect . width * x Scale Factor ) ; n Clip Rect . height = ( int ) Math . ceil ( i Rect . height * y Scale Factor ) ; if ( n Clip Rect . width + n Clip Rect . x > source Rect . width ) { n Clip Rect . width = source Rect . width - n Clip Rect . x ; } if ( n Clip Rect . height + n Clip Rect . y > source Rect . height ) { n Clip Rect . height = source Rect . height - n Clip Rect . y ; } } if ( n Clip Rect . width <= NUM ) { n Clip Rect . width = NUM ; } if ( n Clip Rect . height <= NUM ) { n Clip Rect . height = NUM ; } double width Adj = ( double ) i Rect . width / ( double ) n Clip Rect . width ; double height Adj = ( double ) i Rect . height / ( double ) n Clip Rect . height ; Affine Transform xform = new Affine Transform ( ) ; xform . set To Scale ( width Adj , height Adj ) ; clip Rect = n Clip Rect ; this . scaling X Form Op = new Affine Transform Op ( xform , get Scale Transform Type ( ) ) ; point 1 . set Location ( i Rect . x , i Rect . y ) ; point 2 . set Location ( i Rect . x + i Rect . width , i Rect . y + i Rect . height ) ; } } }
public void write Raw Bytes ( final byte [ ] value , int offset , int length ) throws IO Exception { if ( buffer . remaining ( ) >= length ) { buffer . put ( value , offset , length ) ; } else { throw new Out Of Space Exception ( buffer . position ( ) , buffer . limit ( ) ) ; } }
private Cuboid ( String world Name , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { this . world Name = world Name ; this . x1 = Math . min ( x1 , x2 ) ; this . x2 = Math . max ( x1 , x2 ) ; this . y1 = Math . min ( y1 , y2 ) ; this . y2 = Math . max ( y1 , y2 ) ; this . z1 = Math . min ( z1 , z2 ) ; this . z2 = Math . max ( z1 , z2 ) ; }
public double log Marginal Likelihood Harmonic ( List < Double > v ) { double sum = NUM ; final int size = v . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) sum += v . get ( i ) ; double denominator = Log Tricks . log Zero ; for ( int i = NUM ; i < size ; i ++ ) denominator = Log Tricks . log Sum ( denominator , sum - v . get ( i ) ) ; return sum - denominator + Strict Math . log ( size ) ; }
public boolean is Destroy Message ( ) { if ( message == null ) { throw new Illegal State Exception ( STRING ) ; } return ! callee . equals ( STRING ) && ( message . equals ( STRING ) || message . starts With ( STRING ) ) ; }
public static Version Number parse Operating System Version ( @ Nonnull final Operating System Family family , @ Nonnull final String user Agent ) { Check . not Null ( family , STRING ) ; Check . not Null ( user Agent , STRING ) ; final Version Number v ; if ( Operating System Family . ANDROID == family ) { v = identify Android Version ( user Agent ) ; } else if ( Operating System Family . BADA == family ) { v = identify Bada Version ( user Agent ) ; } else if ( Operating System Family . BSD == family ) { v = identify BSD Version ( user Agent ) ; } else if ( Operating System Family . IOS == family ) { v = identify IOS Version ( user Agent ) ; } else if ( Operating System Family . JVM == family ) { v = identify Java Version ( user Agent ) ; } else if ( Operating System Family . OS X == family ) { v = identify OSX Version ( user Agent ) ; } else if ( Operating System Family . SYMBIAN == family ) { v = identify Symbian Version ( user Agent ) ; } else if ( Operating System Family . WEBOS == family ) { v = identify Web OS Version ( user Agent ) ; } else if ( Operating System Family . WINDOWS == family ) { v = identify Windows Version ( user Agent ) ; } else { v = Version Number . UNKNOWN ; } return v ; }
public void update Headers ( Uri uri , Send Req send Req ) { synchronized ( PDU CACHE INSTANCE ) { if ( PDU CACHE INSTANCE . is Updating ( uri ) ) { if ( LOCAL LOGV ) Log . v ( TAG , STRING + uri + STRING ) ; try { PDU CACHE INSTANCE . wait ( ) ; } catch ( Interrupted Exception e ) { Log . e ( TAG , STRING , e ) ; } } } PDU CACHE INSTANCE . purge ( uri ) ; Content Values values = new Content Values ( NUM ) ; byte [ ] content Type = send Req . get Content Type ( ) ; if ( content Type != null ) { values . put ( STRING , to Iso String ( content Type ) ) ; } long date = send Req . get Date ( ) ; if ( date != - NUM ) { values . put ( STRING , date ) ; } int delivery Report = send Req . get Delivery Report ( ) ; if ( delivery Report != NUM ) { values . put ( STRING , delivery Report ) ; } long expiry = send Req . get Expiry ( ) ; if ( expiry != - NUM ) { values . put ( STRING , expiry ) ; } byte [ ] msg Class = send Req . get Message Class ( ) ; if ( msg Class != null ) { values . put ( STRING , to Iso String ( msg Class ) ) ; } int priority = send Req . get Priority ( ) ; if ( priority != NUM ) { values . put ( STRING , priority ) ; } int read Report = send Req . get Read Report ( ) ; if ( read Report != NUM ) { values . put ( STRING , read Report ) ; } byte [ ] trans Id = send Req . get Transaction Id ( ) ; if ( trans Id != null ) { values . put ( STRING , to Iso String ( trans Id ) ) ; } Encoded String Value subject = send Req . get Subject ( ) ; if ( subject != null ) { values . put ( STRING , to Iso String ( subject . get Text String ( ) ) ) ; values . put ( STRING , subject . get Character Set ( ) ) ; } else { values . put ( STRING , STRING ) ; } long message Size = send Req . get Message Size ( ) ; if ( message Size > NUM ) { values . put ( STRING , message Size ) ; } Pdu Headers headers = send Req . get Pdu Headers ( ) ; Hash Set < String > recipients = new Hash Set < String > ( ) ; for ( int addr Type : ADDRESS FIELDS ) { Encoded String Value [ ] array = null ; if ( addr Type == Pdu Headers . FROM ) { Encoded String Value v = headers . get Encoded String Value ( addr Type ) ; if ( v != null ) { array = new Encoded String Value [ NUM ] ; array [ NUM ] = v ; } } else { array = headers . get Encoded String Values ( addr Type ) ; } if ( array != null ) { long msg Id = Content Uris . parse Id ( uri ) ; update Address ( msg Id , addr Type , array ) ; if ( addr Type == Pdu Headers . TO ) { for ( Encoded String Value v : array ) { if ( v != null ) { recipients . add ( v . get String ( ) ) ; } } } } } if ( ! recipients . is Empty ( ) ) { long thread Id = Utils . get Or Create Thread Id ( m Context , recipients ) ; values . put ( STRING , thread Id ) ; } Sqlite Wrapper . update ( m Context , m Content Resolver , uri , values , null , null ) ; }
private String Part create String Part ( final String name , final String value ) { final String Part string Part = new String Part ( name , value ) ; string Part . set Transfer Encoding ( null ) ; string Part . set Content Type ( null ) ; return string Part ; }
public void sleep ( long milli Seconds ) { lock . lock ( ) ; try { if ( t != NUM ) { t = System . current Time Millis ( ) + milli Seconds ; while ( BOOL ) { final long dt = t - System . current Time Millis ( ) ; if ( dt <= NUM ) { break ; } else { wakeup . await ( dt , Time Unit . MILLISECONDS ) ; } } } t = System . current Time Millis ( ) ; } catch ( Interrupted Exception e ) { logger . error ( e . get Message ( ) , e ) ; } finally { lock . unlock ( ) ; } }
public boolean add via padstack ( Lib Padstack p padstack ) { if ( p padstack == null ) return BOOL ; if ( get via padstack ( p padstack . pads name ) != null ) return BOOL ; via padstacks . add ( p padstack ) ; return BOOL ; }
protected Args Base ( ) { argv = null ; start Time = NUM ; program Info = null ; env = null ; }
@ Override public void element ( String element Name , Augmentations augs ) throws XNI Exception { if ( f Mixed && f Validation ) { if ( f Mixed Element Types . contains ( element Name ) ) { f Error Reporter . report Error ( XML Message Formatter . XML DOMAIN , STRING , new Object [ ] { fDTD Element Decl Name , element Name } , XML Error Reporter . SEVERITY ERROR ) ; } else { f Mixed Element Types . add ( element Name ) ; } } if ( fDTD Grammar != null ) fDTD Grammar . element ( element Name , augs ) ; if ( fDTD Content Model Handler != null ) { fDTD Content Model Handler . element ( element Name , augs ) ; } }
private static Point find Midnormal Point ( Point center , Point a , Point b , Rect area , int radius ) { if ( a . y == b . y ) { if ( a . y < center . y ) { return new Point ( ( a . x + b . x ) / NUM , center . y + radius ) ; } return new Point ( ( a . x + b . x ) / NUM , center . y - radius ) ; } if ( a . x == b . x ) { if ( a . x < center . x ) { return new Point ( center . x + radius , ( a . y + b . y ) / NUM ) ; } return new Point ( center . x - radius , ( a . y + b . y ) / NUM ) ; } double ab Slope = ( a . y - b . y ) / ( a . x - b . x * NUM ) ; double midnormal Slope = - NUM / ab Slope ; double radian = Math . tan ( midnormal Slope ) ; int dy = ( int ) ( radius * Math . sin ( radian ) ) ; int dx = ( int ) ( radius * Math . cos ( radian ) ) ; Point point = new Point ( center . x + dx , center . y + dy ) ; if ( ! in Area ( point , area , NUM ) ) { point = new Point ( center . x - dx , center . y - dy ) ; } return point ; }
private static Document parse Xml From Bytebuffer ( Byte Buffer buffer , Parse Options options ) throws XMP Exception { Input Source source = new Input Source ( buffer . get Byte Stream ( ) ) ; try { return parse Input Source ( source ) ; } catch ( XMP Exception e ) { if ( e . get Error Code ( ) == XMP Error . BADXML || e . get Error Code ( ) == XMP Error . BADSTREAM ) { if ( options . get Accept Latin 1 ( ) ) { buffer = Latin 1 Converter . convert ( buffer ) ; } if ( options . get Fix Control Chars ( ) ) { try { String encoding = buffer . get Encoding ( ) ; Reader fix Reader = new Fix ASCII Controls Reader ( new Input Stream Reader ( buffer . get Byte Stream ( ) , encoding ) ) ; return parse Input Source ( new Input Source ( fix Reader ) ) ; } catch ( Unsupported Encoding Exception e1 ) { throw new XMP Exception ( STRING , XMP Error . INTERNALFAILURE , e ) ; } } source = new Input Source ( buffer . get Byte Stream ( ) ) ; return parse Input Source ( source ) ; } else { throw e ; } } }
private boolean is Online ( ) { String port = HOST IP . contains ( STRING ) ? HOST IP . substring ( HOST IP . index Of ( STRING ) + NUM ) : STRING ; String ip = HOST IP . contains ( STRING ) ? HOST IP . substring ( NUM , HOST IP . index Of ( STRING ) ) : HOST IP ; Socket socket = null ; try { Socket Address sockaddr = new Inet Socket Address ( ip , new Integer ( port ) ) ; socket = new Socket ( ) ; socket . connect ( sockaddr , NUM ) ; } catch ( Number Format Exception | IO Exception e ) { return BOOL ; } finally { try { if ( socket != null ) { socket . close ( ) ; } } catch ( IO Exception ex ) { } } return BOOL ; }
@ Override public void on Artist Update ( Provider Identifier provider , Artist a ) throws Remote Exception { if ( a == null ) { Log . w ( TAG , STRING ) ; return ; } Artist cached = m Cache . get Artist ( a . get Ref ( ) ) ; if ( cached == null ) { m Cache . put Artist ( provider , a ) ; post Artist For Update ( a ) ; } else if ( ! cached . is Identical ( a ) ) { cached . set Name ( a . get Name ( ) ) ; Iterator < String > it = a . albums ( ) ; while ( it . has Next ( ) ) { cached . add Album ( it . next ( ) ) ; } cached . set Is Loaded ( a . is Loaded ( ) ) ; post Artist For Update ( a ) ; } }
private Properties read Properties ( final String properties File Path ) throws IO Exception { Properties properties = new Properties ( ) ; File props File = new File ( properties File Path ) ; File Input Stream fis = null ; if ( props File . exists ( ) ) { try { fis = new File Input Stream ( props File ) ; properties . load ( fis ) ; } finally { if ( fis != null ) { fis . close ( ) ; } } } return properties ; }
public Tiled Grayscale Matrix ( final Grayscale Matrix matrix , final int tile Width , final int tile Height ) { if ( matrix . get Width ( ) < tile Width || matrix . get Height ( ) < tile Height ) { throw new Illegal Argument Exception ( STRING ) ; } if ( tile Width <= NUM || tile Height <= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } this . tile Width = tile Width ; this . tile Height = tile Height ; this . tiles X = matrix . get Width ( ) / tile Width ; this . tiles Y = matrix . get Height ( ) / tile Height ; int rounded Width = tiles X * tile Width ; int rounded Height = tiles Y * tile Height ; tiles = new Array List < Grayscale Matrix > ( rounded Width * rounded Height ) ; for ( int i = NUM ; i < tiles Y ; i ++ ) { for ( int j = NUM ; j < tiles X ; j ++ ) { tiles . add ( Grayscale Matrix . create From Region ( matrix , tile Width , tile Height , this . tile Width * j , this . tile Height * i ) ) ; } } }
@ Override public void connection Notification ( String event Name , Object source ) { if ( connection Allowed ( event Name ) ) { if ( m first Input == null ) { m first Input = source ; m first Input Connection Type = event Name ; } else { m second Input = source ; m second Input Connection Type = event Name ; } } if ( m first Input != null && m second Input != null ) { if ( m first Input Connection Type . length ( ) > NUM || m second Input Connection Type . length ( ) > NUM ) { if ( ! m first Input Connection Type . equals ( STRING ) && ! m second Input Connection Type . equals ( STRING ) ) { m incoming Batch Connections = BOOL ; } else { m incoming Batch Connections = BOOL ; } } else { m incoming Batch Connections = BOOL ; } } }
public static Class generate Class Impl ( String name , Modifiers modifiers , Class [ ] interfaces , Class super Class , BSH Block block , boolean is Interface , Call Stack callstack , Interpreter interpreter ) throws Eval Error { try { Capabilities . set Accessibility ( BOOL ) ; } catch ( Capabilities . Unavailable e ) { throw new Eval Error ( STRING , block , callstack ) ; } Name Space enclosing Name Space = callstack . top ( ) ; String package Name = enclosing Name Space . get Package ( ) ; String class Name = enclosing Name Space . is Class ? ( enclosing Name Space . get Name ( ) + STRING + name ) : name ; String fq Class Name = package Name == null ? class Name : package Name + STRING + class Name ; String bsh Static Field Name = Class Generator Util . BSHSTATIC + class Name ; Bsh Class Manager bcm = interpreter . get Class Manager ( ) ; bcm . defining Class ( fq Class Name ) ; Name Space class Static Name Space = new Name Space ( enclosing Name Space , class Name ) ; class Static Name Space . is Class = BOOL ; callstack . push ( class Static Name Space ) ; block . eval Block ( callstack , interpreter , BOOL , Class Node Filter . CLASSCLASSES ) ; Variable [ ] variables = get Declared Variables ( block , callstack , interpreter , package Name ) ; Delayed Eval Bsh Method [ ] methods = get Declared Methods ( block , callstack , interpreter , package Name ) ; Class Generator Util class Generator = new Class Generator Util ( modifiers , class Name , package Name , super Class , interfaces , variables , methods , is Interface ) ; Class clas = bcm . get Associated Class ( fq Class Name ) ; if ( clas == null ) { byte [ ] code = class Generator . generate Class ( Interpreter . get Save Classes ( ) ) ; if ( Interpreter . get Save Classes ( ) ) save Classes ( class Name , code ) ; else clas = bcm . define Class ( fq Class Name , code ) ; } if ( ! Interpreter . get Save Classes ( ) ) { class Generator . init Static Name Space ( class Static Name Space , block ) ; enclosing Name Space . import Class ( fq Class Name . replace ( STRING , STRING ) ) ; class Static Name Space . set Class Static ( clas ) ; block . eval Block ( callstack , interpreter , BOOL , Class Node Filter . CLASSSTATIC ) ; if ( ! clas . is Interface ( ) ) install Static Block ( clas , bsh Static Field Name , class Static Name Space , interpreter ) ; } callstack . pop ( ) ; bcm . done Defining Class ( fq Class Name ) ; return clas ; }
public void clear Last Login Time ( ) { operations . add ( Password Policy State Operation Type . CLEAR LAST LOGIN TIME ) ; }
public static String format Java Doc Box ( String text ) { require Non Null ( text ) ; return format Text Box ( text , JAVA DOC WIDTH , JAVADOC WORDS , JAVA DOC SINGLE LINE WORDS ) ; }
public static Explanation match ( float value , String description , Explanation ... details ) { return new Explanation ( BOOL , value , description , Arrays . as List ( details ) ) ; }
public void remove Plot Tool Bar ( ) { if ( plot Tool Bar == null ) { return ; } remove ( plot Tool Bar ) ; }
private float [ ] convert Dash List To Array ( List < Float > dash List ) { if ( dash List == null ) { return null ; } float [ ] dashes = new float [ dash List . size ( ) ] ; int i = NUM ; for ( Float f : dash List ) { dashes [ i ++ ] = ( f != null ? f : Float . Na N ) ; } return dashes ; }
@ Override public long position ( byte [ ] pattern , long start ) throws SQL Exception { if ( is Debug Enabled ( ) ) { debug Code ( STRING + quote Bytes ( pattern ) + STRING + start + STRING ) ; } if ( Constants . BLOB SEARCH ) { try { check Closed ( ) ; if ( pattern == null ) { return - NUM ; } if ( pattern . length == NUM ) { return NUM ; } Buffered Input Stream in = new Buffered Input Stream ( value . get Input Stream ( ) ) ; IO Utils . skip Fully ( in , start - NUM ) ; int pos = NUM ; int pattern Pos = NUM ; while ( BOOL ) { int x = in . read ( ) ; if ( x < NUM ) { break ; } if ( x == ( pattern [ pattern Pos ] & NUM ) ) { if ( pattern Pos == NUM ) { in . mark ( pattern . length ) ; } if ( pattern Pos == pattern . length ) { return pos - pattern Pos ; } pattern Pos ++ ; } else { if ( pattern Pos > NUM ) { in . reset ( ) ; pos -= pattern Pos ; } } pos ++ ; } return - NUM ; } catch ( Exception e ) { throw log And Convert ( e ) ; } } throw unsupported ( STRING ) ; }
static void inflate Gens ( Segment Infos infos , Collection < String > files , Info Stream info Stream ) { long max Segment Gen = Long . MIN VALUE ; int max Segment Name = Integer . MIN VALUE ; Map < String , Long > max Per Segment Gen = new Hash Map < > ( ) ; for ( String file Name : files ) { if ( file Name . equals ( Index File Names . OLD SEGMENTS GEN ) || file Name . equals ( Index Writer . WRITE LOCK NAME ) ) { } else if ( file Name . starts With ( Index File Names . SEGMENTS ) ) { try { max Segment Gen = Math . max ( Segment Infos . generation From Segments File Name ( file Name ) , max Segment Gen ) ; } catch ( Number Format Exception ignore ) { } } else if ( file Name . starts With ( Index File Names . PENDING SEGMENTS ) ) { try { max Segment Gen = Math . max ( Segment Infos . generation From Segments File Name ( file Name . substring ( NUM ) ) , max Segment Gen ) ; } catch ( Number Format Exception ignore ) { } } else { String segment Name = Index File Names . parse Segment Name ( file Name ) ; assert segment Name . starts With ( STRING ) : STRING + file Name ; if ( file Name . to Lower Case ( Locale . ROOT ) . ends With ( STRING ) ) { continue ; } max Segment Name = Math . max ( max Segment Name , Integer . parse Int ( segment Name . substring ( NUM ) , Character . MAX RADIX ) ) ; Long cur Gen = max Per Segment Gen . get ( segment Name ) ; if ( cur Gen == null ) { cur Gen = NUM ; } try { cur Gen = Math . max ( cur Gen , Index File Names . parse Generation ( file Name ) ) ; } catch ( Number Format Exception ignore ) { } max Per Segment Gen . put ( segment Name , cur Gen ) ; } } infos . set Next Write Generation ( Math . max ( infos . get Generation ( ) , max Segment Gen ) ) ; if ( infos . counter < NUM + max Segment Name ) { if ( info Stream . is Enabled ( STRING ) ) { info Stream . message ( STRING , STRING + ( NUM + max Segment Name ) + STRING + infos . counter ) ; } infos . counter = NUM + max Segment Name ; } for ( Segment Commit Info info : infos ) { Long gen = max Per Segment Gen . get ( info . info . name ) ; assert gen != null ; long gen Long = gen ; if ( info . get Next Write Del Gen ( ) < gen Long + NUM ) { if ( info Stream . is Enabled ( STRING ) ) { info Stream . message ( STRING , STRING + info . info . name + STRING + ( gen Long + NUM ) + STRING + info . get Next Write Del Gen ( ) ) ; } info . set Next Write Del Gen ( gen Long + NUM ) ; } if ( info . get Next Write Field Infos Gen ( ) < gen Long + NUM ) { if ( info Stream . is Enabled ( STRING ) ) { info Stream . message ( STRING , STRING + info . info . name + STRING + ( gen Long + NUM ) + STRING + info . get Next Write Field Infos Gen ( ) ) ; } info . set Next Write Field Infos Gen ( gen Long + NUM ) ; } if ( info . get Next Write Doc Values Gen ( ) < gen Long + NUM ) { if ( info Stream . is Enabled ( STRING ) ) { info Stream . message ( STRING , STRING + info . info . name + STRING + ( gen Long + NUM ) + STRING + info . get Next Write Doc Values Gen ( ) ) ; } info . set Next Write Doc Values Gen ( gen Long + NUM ) ; } } }
public byte [ ] decompress ( Input Stream is ) { inflater . reset ( ) ; Inflater Input Stream iis = new Inflater Input Stream ( is , inflater ) ; Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; try { while ( BOOL ) { int b = iis . read ( ) ; if ( b == - NUM ) break ; baos . write ( b ) ; } } catch ( IO Exception ex ) { throw new Runtime Exception ( ex ) ; } return baos . to Byte Array ( ) ; }
private boolean has Searchable Columns ( ) { boolean ret Value = BOOL ; m table Name = M Query . get Zoom Table Name ( m column Name ) ; m key Column Name = M Query . get Zoom Column Name ( m column Name ) ; if ( m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) || m column Name . equals ( STRING ) ) { ret Value = BOOL ; } else { String query = STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( query , null ) ; pstmt . set String ( NUM , m key Column Name ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { ret Value = BOOL ; } } catch ( SQL Exception ex ) { log . log ( Level . SEVERE , query , ex ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } } return ret Value ; }
private boolean read Port ( ) { current Url Marker . set Index ( Url Part . PORT , buffer . length ( ) ) ; int port Len = NUM ; while ( ! reader . eof ( ) ) { char curr = reader . read ( ) ; port Len ++ ; if ( curr == STRING ) { buffer . append ( curr ) ; return read Path ( ) ; } else if ( curr == STRING ) { buffer . append ( curr ) ; return read Query String ( ) ; } else if ( curr == STRING ) { buffer . append ( curr ) ; return read Fragment ( ) ; } else if ( check Matching Character ( curr ) == Character Match . Character Match Stop || ! Char Utils . is Numeric ( curr ) ) { reader . go Back ( ) ; if ( port Len == NUM ) { buffer . delete ( buffer . length ( ) - NUM , buffer . length ( ) ) ; } current Url Marker . unset Index ( Url Part . PORT ) ; return read End ( Read End State . Valid Url ) ; } else { buffer . append ( curr ) ; } } return read End ( Read End State . Valid Url ) ; }
static Token [ ] lexx ( final String format ) { final Array List < Token > list = new Array List < Token > ( format . length ( ) ) ; boolean in Literal = BOOL ; String Builder buffer = null ; Token previous = null ; for ( int i = NUM ; i < format . length ( ) ; i ++ ) { final char ch = format . char At ( i ) ; if ( in Literal && ch != STRING ) { buffer . append ( ch ) ; continue ; } Object value = null ; switch ( ch ) { case STRING : if ( in Literal ) { buffer = null ; in Literal = BOOL ; } else { buffer = new String Builder ( ) ; list . add ( new Token ( buffer ) ) ; in Literal = BOOL ; } break ; case STRING : value = y ; break ; case STRING : value = M ; break ; case STRING : value = d ; break ; case STRING : value = H ; break ; case STRING : value = m ; break ; case STRING : value = s ; break ; case STRING : value = S ; break ; default : if ( buffer == null ) { buffer = new String Builder ( ) ; list . add ( new Token ( buffer ) ) ; } buffer . append ( ch ) ; } if ( value != null ) { if ( previous != null && previous . get Value ( ) == value ) { previous . increment ( ) ; } else { final Token token = new Token ( value ) ; list . add ( token ) ; previous = token ; } buffer = null ; } } if ( in Literal ) { throw new Illegal Argument Exception ( STRING + format ) ; } return list . to Array ( new Token [ list . size ( ) ] ) ; }
public static void save ( File file , byte [ ] bytes ) throws IO Exception { Output Stream os = new File Output Stream ( file ) ; try { os = new Buffered Output Stream ( os ) ; for ( int i = NUM ; i < bytes . length ; i += NUM ) { int len = Math . min ( bytes . length - i , NUM ) ; os . write ( bytes , i , len ) ; } } finally { os . close ( ) ; } }
public void assert Joined ( final UUID service Id ) { m triggers . add ( new Quorum Event Invariant ( Quorum Event Enum . SERVICE LEAVE , service Id ) ) ; assert Membership ( m quorum . get Joined ( ) , service Id ) ; }
Object add Parser Highlight ( Parser Notice notice , Highlight Painter p ) throws Bad Location Exception { Document doc = text Area . get Document ( ) ; Text UI mapper = text Area . get UI ( ) ; int start = notice . get Offset ( ) ; int end = NUM ; if ( start == - NUM ) { int line = notice . get Line ( ) ; Element root = doc . get Default Root Element ( ) ; if ( line >= NUM && line < root . get Element Count ( ) ) { Element elem = root . get Element ( line ) ; start = elem . get Start Offset ( ) ; end = elem . get End Offset ( ) ; } } else { end = start + notice . get Length ( ) ; } Highlight Info i = new Layered Highlight Info ( ) ; i . painter = p ; i . p0 = doc . create Position ( start ) ; i . p1 = doc . create Position ( end ) ; i . notice = notice ; parser Highlights . add ( i ) ; mapper . damage Range ( text Area , start , end ) ; return i ; }
private void add Connections ( Collection < Connection > connections ) throws Guacamole Exception { for ( Connection connection : connections ) { API Connection Group parent = retrieved Groups . get ( connection . get Parent Identifier ( ) ) ; if ( parent != null ) { Collection < API Connection > children = parent . get Child Connections ( ) ; if ( children == null ) { children = new Array List < API Connection > ( ) ; parent . set Child Connections ( children ) ; } API Connection api Connection = new API Connection ( connection ) ; retrieved Connections . put ( connection . get Identifier ( ) , api Connection ) ; children . add ( api Connection ) ; } else logger . debug ( STRING , connection . get Identifier ( ) , connection . get Parent Identifier ( ) ) ; } }
private static boolean contained In ( final Rectangle 2 D r , final Collection < Polygon > shapes ) { for ( final Shape item : shapes ) { if ( item . contains ( r ) ) { return BOOL ; } } return BOOL ; }
private void add Decoration ( Decoration d , int index ) { if ( decorations != null ) { decoration Starts = add To Vector ( d , index , decorations , decoration Starts ) ; } else if ( decoration == null ) { decoration = d ; } else { if ( ! decoration . equals ( d ) ) { decorations = new Vector < Decoration > ( INITIAL SIZE ) ; decorations . add Element ( decoration ) ; decorations . add Element ( d ) ; decoration Starts = new int [ INITIAL SIZE ] ; decoration Starts [ NUM ] = NUM ; decoration Starts [ NUM ] = index ; } } }
public int parse Reference ( String s ) { this . input = s ; this . index = NUM ; String dest ; String title ; int match Chars ; int start Index = index ; match Chars = parse Link Label ( ) ; if ( match Chars == NUM ) { return NUM ; } String raw Label = input . substring ( NUM , match Chars ) ; if ( peek ( ) != STRING ) { return NUM ; } index ++ ; spnl ( ) ; dest = parse Link Destination ( ) ; if ( dest == null || dest . length ( ) == NUM ) { return NUM ; } int before Title = index ; spnl ( ) ; title = parse Link Title ( ) ; if ( title == null ) { index = before Title ; } boolean at Line End = BOOL ; if ( index != input . length ( ) && match ( LINE END ) == null ) { if ( title == null ) { at Line End = BOOL ; } else { title = null ; index = before Title ; at Line End = match ( LINE END ) != null ; } } if ( ! at Line End ) { return NUM ; } String normalized Label = Escaping . normalize Reference ( raw Label ) ; if ( normalized Label . is Empty ( ) ) { return NUM ; } if ( ! reference Map . contains Key ( normalized Label ) ) { Link link = new Link ( dest , title ) ; reference Map . put ( normalized Label , link ) ; } return index - start Index ; }
public void record Block Volume Operation ( Db Client db Client , Operation Type Enum op Type , Operation . Status status , Object ... ext Param ) { try { boolean op Status = ( Operation . Status . ready == status ) ? BOOL : BOOL ; String ev Type ; ev Type = op Type . get Ev Type ( op Status ) ; String ev Desc = op Type . get Description ( ) ; String op Stage = Audit Log Manager . AUDITOP END ; logger . info ( STRING , op Type . to String ( ) , ev Type . to String ( ) + STRING + ev Desc ) ; record Bourne Volume Event ( db Client , get Id ( ) , ev Type , status , ev Desc ) ; String id = ( String ) ext Param [ NUM ] ; switch ( op Type ) { case CREATE BLOCK VOLUME : case DELETE BLOCK VOLUME : Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; case EXPAND BLOCK VOLUME : String size = ( String ) ext Param [ NUM ] ; Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id , size ) ; break ; case CREATE VOLUME FULL COPY : Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; case DETACH VOLUME FULL COPY : Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; case RESTORE VOLUME FULL COPY : case RESYNCHRONIZE VOLUME FULL COPY : case ACTIVATE VOLUME FULL COPY : Audit Block Util . audit Block ( db Client , op Type , op Status , op Stage , id ) ; break ; default : logger . error ( STRING ) ; } } catch ( Exception e ) { logger . error ( STRING , op Type . to String ( ) , e ) ; } }
@ Override public void put ( double val , double weight ) { final double nn = weight + this . n ; final double delta = val - this . m1 ; final double otherm 2 = val * val ; final double otherm 3 = otherm 2 * val ; final double otherm 4 = otherm 3 * val ; final double delta nn = delta / nn ; final double delta nn 2 = delta nn * delta nn ; final double delta nn 3 = delta nn 2 * delta nn ; final double na 2 = this . n * this . n ; final double nb 2 = weight * weight ; final double ntn = this . n * weight ; this . m4 += otherm 4 + delta * delta nn 3 * ntn * ( na 2 - ntn + nb 2 ) + NUM * ( na 2 * otherm 2 + nb 2 * this . m2 ) * delta nn 2 + NUM * ( this . n * otherm 3 - weight * this . m3 ) * delta nn ; this . m3 += otherm 3 + delta * delta nn 2 * ntn * ( this . n - weight ) + NUM * ( this . n * otherm 2 - weight * this . m2 ) * delta nn ; this . m2 += otherm 2 + delta * delta nn * this . n * weight ; this . m1 += weight * delta nn ; this . n = nn ; min = Math . min ( min , val ) ; max = Math . max ( max , val ) ; }
public void close ( ) throws IO Exception { if ( ! closed ) { try { if ( ! eof ) { exhaust Input Stream ( this ) ; } } finally { eof = BOOL ; closed = BOOL ; } } }
protected synchronized int determine Minimum Number Of Parent Dirs ( ) { int result ; Hash Set < String > files ; int num ; int i ; int max ; result = - NUM ; max = NUM ; for ( i = NUM ; i < m Recent Items . size ( ) ; i ++ ) max = Math . max ( max , File Utils . get Directory Depth ( m Recent Items . get ( i ) ) ) ; num = NUM ; do { files = new Hash Set < String > ( ) ; for ( i = NUM ; i < m Recent Items . size ( ) ; i ++ ) files . add ( File Utils . create Partial Filename ( m Recent Items . get ( i ) , num ) ) ; if ( files . size ( ) == m Recent Items . size ( ) ) result = num ; else num ++ ; } while ( ( files . size ( ) < m Recent Items . size ( ) ) && ( num <= max ) ) ; return result ; }
void output Variables ( List < Var Holder > vars ) { boolean first = BOOL ; for ( Var Holder vh : vars ) { if ( vh . name != null ) { if ( first ) { gen . out ( STRING , vh . name ) ; first = BOOL ; } else { gen . out ( STRING , vh . name ) ; } } else if ( vh . destr != null && vh . vars != null ) { for ( Tree . Variable v : vh . vars ) { final String vname = names . name ( v . get Declaration Model ( ) ) ; if ( first ) { gen . out ( STRING , vname ) ; first = BOOL ; } else { gen . out ( STRING , vname ) ; } } } } if ( ! first ) { gen . end Line ( BOOL ) ; } }
@ Suppress Warnings ( STRING ) public void handle Button 1 Request ( Request Invocation Event event ) throws Model Control Exception { submit Cycle = BOOL ; String sub Config Name = ( String ) get Display Field Value ( TF EVENT HANDLER NAME ) ; if ( String Utils . is Blank ( sub Config Name ) ) { set Inline Alert Message ( CC Alert . TYPE ERROR , ERROR MESSAGE , STRING ) ; forward To ( ) ; } Abstract Audit Model model = ( Abstract Audit Model ) get Model ( ) ; try { AM Property Sheet ps = ( AM Property Sheet ) get Child ( PROPERTY ATTRIBUTE ) ; String schema Name = ( String ) get Page Session Attribute ( AUDIT HANDLER TYPE ) ; @ Suppress Warnings ( STRING ) Map < String , Set < String > > values = ps . get Attribute Values ( model . get Event Handler Attribute Names ( schema Name ) ) ; model . create Event Handler ( sub Config Name , schema Name , values ) ; back To Profile View Bean ( ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , ERROR MESSAGE , e . get Message ( ) ) ; forward To ( ) ; } }
private void init ( ) { set Title ( STRING ) ; wta Panel = new WTA Properties Panel ( network Panel ) ; tab Logic . add ( wta Panel ) ; layout Panel = new Main Layout Panel ( BOOL , this ) ; layout Panel . set Current Layout ( Winner Take All . DEFAULT LAYOUT ) ; tab Layout . add ( layout Panel ) ; tabbed Pane . add Tab ( STRING , tab Logic ) ; tabbed Pane . add Tab ( STRING , tab Layout ) ; set Content Pane ( tabbed Pane ) ; Action help Action = new Show Help Action ( wta Panel . get Help Path ( ) ) ; add Button ( new J Button ( help Action ) ) ; }
@ Override public double op ( double z ) { z = ( z - average ) / sigma ; double result = NUM * ( NUM + error Function . op ( z * Constants . M SQRT 2 ) ) ; if ( result <= NUM ) { double sum = NUM ; final double zsqr = z * z ; double i = NUM , g = NUM , x , y , a = Constants . QL MAX REAL , lasta ; do { lasta = a ; x = ( NUM * i - NUM ) / zsqr ; y = x * ( ( NUM * i - NUM ) / zsqr ) ; a = g * ( x - y ) ; sum -= a ; g *= y ; ++ i ; a = Math . abs ( a ) ; } while ( lasta > a && a >= Math . abs ( sum * Constants . QL EPSILON ) ) ; result = - gaussian . op ( z ) / z * sum ; } return result ; }
@ Override public int hash Code ( ) { int hash Code = cached Hash Code ; if ( hash Code == NUM ) { hash Code = NUM ; hash Code = NUM * hash Code + Arrays . hash Code ( eras ) ; hash Code = NUM * hash Code + Arrays . hash Code ( months ) ; hash Code = NUM * hash Code + Arrays . hash Code ( short Months ) ; hash Code = NUM * hash Code + Arrays . hash Code ( weekdays ) ; hash Code = NUM * hash Code + Arrays . hash Code ( short Weekdays ) ; hash Code = NUM * hash Code + Arrays . hash Code ( ampms ) ; hash Code = NUM * hash Code + Arrays . deep Hash Code ( get Zone Strings Wrapper ( ) ) ; hash Code = NUM * hash Code + Objects . hash Code ( local Pattern Chars ) ; cached Hash Code = hash Code ; } return hash Code ; }
private void serialize Class ( Class clazz , Map < String , List < String > > class Fields ) throws Runtime Exception { File current = new File ( get Current Directory ( ) ) ; if ( ! current . exists ( ) || ! current . is Directory ( ) ) { throw new Illegal State Exception ( STRING + current . get Absolute Path ( ) + STRING + STRING + STRING ) ; } try { Field field = clazz . get Declared Field ( STRING ) ; int modifiers = field . get Modifiers ( ) ; boolean static = Modifier . is Static ( modifiers ) ; boolean final = Modifier . is Final ( modifiers ) ; field . set Accessible ( BOOL ) ; if ( ! static || ! final || ! ( NUM == field . get Long ( null ) ) ) { throw new Runtime Exception ( STRING + clazz + STRING + STRING ) ; } int num Fields = get Num Non Serial Version UID Fields ( clazz ) ; if ( num Fields > NUM ) { Method method = clazz . get Method ( STRING ) ; Object object = method . invoke ( null ) ; File file = new File ( current , clazz . get Name ( ) + STRING ) ; boolean created = file . create New File ( ) ; File Output Stream out = new File Output Stream ( file ) ; Object Output Stream obj Out = new Object Output Stream ( out ) ; obj Out . write Object ( object ) ; out . close ( ) ; } Object Stream Class object Stream Class = Object Stream Class . lookup ( clazz ) ; String class Name = object Stream Class . get Name ( ) ; Object Stream Field [ ] fields = object Stream Class . get Fields ( ) ; @ Suppress Warnings ( STRING ) List < String > field List = new Array List < > ( ) ; for ( Object Stream Field object Stream Field : fields ) { String field Name = object Stream Field . get Name ( ) ; field List . add ( field Name ) ; } class Fields . put ( class Name , field List ) ; } catch ( No Such Field Exception e ) { throw new Runtime Exception ( ( STRING + STRING + clazz + STRING + STRING ) ) ; } catch ( No Such Method Exception e ) { } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( STRING + STRING + clazz + STRING , e ) ; } catch ( Invocation Target Exception e ) { throw new Runtime Exception ( STRING + STRING + clazz + STRING , e ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING + STRING + get Current Directory ( ) + STRING + clazz + STRING , e ) ; } }
private static List find Labeled Edge Rings ( Collection dir Edges ) { List edge Ring Starts = new Array List ( ) ; long curr Label = NUM ; for ( Iterator i = dir Edges . iterator ( ) ; i . has Next ( ) ; ) { Polygonize Directed Edge de = ( Polygonize Directed Edge ) i . next ( ) ; if ( de . is Marked ( ) ) continue ; if ( de . get Label ( ) >= NUM ) continue ; edge Ring Starts . add ( de ) ; List edges = Edge Ring . find Dir Edges In Ring ( de ) ; label ( edges , curr Label ) ; curr Label ++ ; } return edge Ring Starts ; }
public byte [ ] encrypt ( byte [ ] data ) throws Crypto Exception { try { byte [ ] ciphertext ; if ( use Explicit Iv ) { ciphertext = Array Converter . concatenate ( encrypt Iv . get IV ( ) , encrypt Cipher . do Final ( data ) ) ; } else { encrypt Cipher . init ( Cipher . ENCRYPT MODE , encrypt Key , encrypt Iv ) ; ciphertext = encrypt Cipher . do Final ( data ) ; encrypt Iv = new Iv Parameter Spec ( Arrays . copy Of Range ( ciphertext , ciphertext . length - decrypt Cipher . get Block Size ( ) , ciphertext . length ) ) ; } return ciphertext ; } catch ( Bad Padding Exception | Illegal Block Size Exception | Invalid Algorithm Parameter Exception | Invalid Key Exception ex ) { throw new Crypto Exception ( ex ) ; } }
public void remove Event Listener ( Video Sharing Listener listener ) throws Rcs Service Not Available Exception , Rcs Generic Exception { if ( m Api == null ) { throw new Rcs Service Not Available Exception ( ) ; } try { Weak Reference < I Video Sharing Listener > weak Ref = m Video Sharing Listeners . remove ( listener ) ; if ( weak Ref == null ) { return ; } I Video Sharing Listener rcs Listener = weak Ref . get ( ) ; if ( rcs Listener != null ) { m Api . remove Event Listener 2 ( rcs Listener ) ; } } catch ( Exception e ) { Rcs Illegal Argument Exception . assert Exception ( e ) ; throw new Rcs Generic Exception ( e ) ; } }
private int read Local ( final Byte Buffer buffer , final long position ) throws IO Exception { final int request Len = buffer . remaining ( ) ; final long eof = m channel . size ( ) ; if ( eof < ( position + request Len ) ) { if ( position == eof ) return - NUM ; final int len = ( int ) ( eof - position ) ; buffer . limit ( len ) ; File Channel Utility . read All ( m reopener , buffer , position ) ; buffer . limit ( request Len ) ; } else { File Channel Utility . read All ( m reopener , buffer , position ) ; } return request Len - buffer . remaining ( ) ; }
public boolean matches Ignore Case ( String sa ) { if ( length != sa . length ( ) ) return BOOL ; char [ ] buffer = buffer ; int offset = offset ; for ( int i = length - NUM ; i >= NUM ; i -- ) { char ca = buffer [ offset + i ] ; char cb = sa . char At ( i ) ; if ( ca != cb && Character . to Lower Case ( ca ) != Character . to Lower Case ( cb ) ) return BOOL ; } return BOOL ; }
@ Override public void mouse Released ( Mouse Event e ) { synchronized ( mouse Lock ) { mouse Pressed = BOOL ; } if ( e . get Button ( ) == Mouse Event . BUTTON 1 ) { for ( Draw Listener listener : listeners ) listener . mouse Released ( user X ( e . get X ( ) ) , user Y ( e . get Y ( ) ) ) ; } }
@ Override public void draw Series ( Canvas canvas , Paint paint , List < Float > points , List < Double > values , XY Series Renderer renderer , Support Series Render support Series Render , float y Axis Value , int series Index , int start Index ) { paint . set Color ( renderer . get Color ( ) ) ; paint . set Style ( Style . FILL ) ; int length = points . size ( ) ; XY Value Series series = ( XY Value Series ) m Dataset . get Series At ( series Index ) ; double max = series . get Max Value ( ) ; double coef = MAX BUBBLE SIZE / max ; for ( int i = NUM ; i < length ; i += NUM ) { double size = series . get Value ( start Index + i / NUM ) * coef + MIN BUBBLE SIZE ; draw Circle ( canvas , paint , points . get ( i ) , points . get ( i + NUM ) , ( float ) size ) ; } }
public void remove Channel ( Channel channel ) { if ( channel != null ) { switch ( channel . get Channel Type ( ) ) { case STANDARD : int index = m Channels . index Of ( channel ) ; m Channels . remove ( channel ) ; if ( index >= NUM ) { fire Table Rows Deleted ( index , index ) ; } break ; case TRAFFIC : m Traffic Channels . remove ( channel ) ; break ; default : break ; } broadcast ( new Channel Event ( channel , Event . NOTIFICATION DELETE ) ) ; } }
public static String join ( Object [ ] array , String separator ) { if ( array == null ) { return null ; } if ( array . length == NUM ) { return String Pool . EMPTY ; } if ( array . length == NUM ) { return String . value Of ( array [ NUM ] ) ; } final String Builder sb = new String Builder ( array . length * NUM ) ; for ( int i = NUM ; i < array . length ; i ++ ) { if ( i > NUM ) { sb . append ( separator ) ; } sb . append ( array [ i ] ) ; } return sb . to String ( ) ; }
public final double do Operation ( ) throws Operator Failed Exception { Node Ref root = tree . get Root ( ) ; List < Node Ref > candidates = new Array List < Node Ref > ( ) ; for ( int i = NUM ; i < tree . get Node Count ( ) ; i ++ ) { Node Ref node = tree . get Node ( i ) ; if ( node != root && tree . get Parent ( node ) != root ) { Node Ref parent = tree . get Parent ( node ) ; int sum = rate Change ( tree , node ) + rate Change ( tree , parent ) ; if ( sum == NUM ) candidates . add ( node ) ; } } if ( candidates . size ( ) == NUM ) throw new Operator Failed Exception ( STRING ) ; Node Ref node = candidates . get ( Math Utils . next Int ( candidates . size ( ) ) ) ; Node Ref parent = tree . get Parent ( node ) ; double node Trait , parent Trait ; double node Rate , parent Rate ; node Trait = tree . get Node Trait ( node , indicator Trait ) ; parent Trait = tree . get Node Trait ( parent , indicator Trait ) ; tree . set Node Trait ( node , indicator Trait , parent Trait ) ; tree . set Node Trait ( parent , indicator Trait , node Trait ) ; if ( trait 2 != null ) { node Trait = tree . get Node Trait ( node , trait 2 ) ; parent Trait = tree . get Node Trait ( parent , trait 2 ) ; tree . set Node Trait ( node , trait 2 , parent Trait ) ; tree . set Node Trait ( parent , trait 2 , node Trait ) ; } else { node Rate = tree . get Node Rate ( node ) ; parent Rate = tree . get Node Rate ( parent ) ; tree . set Node Rate ( node , parent Rate ) ; tree . set Node Rate ( parent , node Rate ) ; } return NUM ; }
protected void create Supply ( int AD Org ID , int PP MRP ID , M Product product , Big Decimal Qty Planned , Timestamp Demand Date Start Schedule , String trx Name ) throws Adempiere Exception , SQL Exception { if ( is Synchronize ( ) && m product planning . get DD Network Distribution ID ( ) > NUM ) { create DD Order ( AD Org ID , PP MRP ID , product , Qty Planned , Demand Date Start Schedule , trx Name ) ; } else if ( product . is Purchased ( ) ) { create Requisition ( AD Org ID , PP MRP ID , product , Qty Planned , Demand Date Start Schedule , trx Name ) ; } else if ( product . is BOM ( ) ) { create PP Order ( AD Org ID , PP MRP ID , product , Qty Planned , Demand Date Start Schedule , trx Name ) ; } else { throw new Illegal State Exception ( STRING + STRING + product + STRING + m product planning + STRING ) ; } }
public List < Local Date > top ( int n ) { List < Local Date > top = new Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ; Int Arrays . parallel Quick Sort ( values , Reverse Int Comparator . instance ( ) ) ; for ( int i = NUM ; i < n && i < values . length ; i ++ ) { top . add ( Packed Local Date . as Local Date ( values [ i ] ) ) ; } return top ; }
@ Override public void load XML ( Node stepnode , List < Database Meta > databases , Map < String , Counter > counters ) throws Kettle XML Exception { try { database Name = XML Handler . get Tag Value ( stepnode , STRING ) ; tabel Name = XML Handler . get Tag Value ( stepnode , STRING ) ; mdkey Size = XML Handler . get Tag Value ( stepnode , STRING ) ; measure Count = XML Handler . get Tag Value ( stepnode , STRING ) ; heir And Key Size = XML Handler . get Tag Value ( stepnode , STRING ) ; table Name = XML Handler . get Tag Value ( stepnode , STRING ) ; group By Enabled = XML Handler . get Tag Value ( stepnode , STRING ) ; aggregator Class String = XML Handler . get Tag Value ( stepnode , STRING ) ; aggregator String = XML Handler . get Tag Value ( stepnode , STRING ) ; fact Dim Lens String = XML Handler . get Tag Value ( stepnode , STRING ) ; level Anddata Type String = XML Handler . get Tag Value ( stepnode , STRING ) ; partition ID = XML Handler . get Tag Value ( stepnode , STRING ) ; segment Id = XML Handler . get Tag Value ( stepnode , STRING ) ; task No = XML Handler . get Tag Value ( stepnode , STRING ) ; } catch ( Exception e ) { throw new Kettle XML Exception ( STRING , e ) ; } }
public void read Data ( Data Input din ) throws IO Exception { reference = din . read Unsigned Short ( ) ; and Mask = din . read Unsigned Short ( ) ; or Mask = din . read Unsigned Short ( ) ; }
public float inner Product ( Feature Vector other ) { float cost = NUM ; for ( int i = NUM ; i < DENSE FEATURE NAMES . size ( ) ; i ++ ) cost += get Dense ( i ) * other . get Dense ( i ) ; for ( String key : sparse Features . key Set ( ) ) cost += sparse Features . get ( key ) * other . get Sparse ( key ) ; return cost ; }
public final double do Operation ( ) throws Operator Failed Exception { final double scale = ( scale Factor + ( Math Utils . next Double ( ) * ( ( NUM / scale Factor ) - scale Factor ) ) ) ; double old Value = variance . get Parameter Value ( NUM ) ; double new Value = scale * old Value ; double logq = - Math . log ( scale ) ; final Bounds < Double > bounds = variance . get Bounds ( ) ; if ( new Value < bounds . get Lower Limit ( NUM ) || new Value > bounds . get Upper Limit ( NUM ) ) { throw new Operator Failed Exception ( STRING ) ; } variance . set Parameter Value ( NUM , new Value ) ; Node Ref root = tree . get Root ( ) ; final int index = root . get Number ( ) ; List < Node Ref > list Node = new Array List < Node Ref > ( ) ; get Subtree ( list Node , tree . get Node ( index ) ) ; final double rate Scale = Math . sqrt ( scale ) ; for ( Node Ref node : list Node ) { old Value = tree . get Node Rate ( node ) ; new Value = old Value * rate Scale ; tree . set Node Rate ( node , new Value ) ; } logq += ( list Node . size ( ) - NUM ) * Math . log ( rate Scale ) ; return logq ; }
@ Override public boolean add All ( int location , Collection < ? extends E > collection ) { if ( location < NUM || location > size ) { throw new Index Out Of Bounds Exception ( STRING + location + STRING + size ) ; } Object [ ] dumparray = to Object Array ( collection ) ; int grow Size = dumparray . length ; if ( grow Size == NUM ) { return BOOL ; } if ( location == NUM ) { grow At Front ( grow Size ) ; first Index -= grow Size ; } else if ( location == size ) { if ( first Index + size > array . length - grow Size ) { grow At End ( grow Size ) ; } } else { if ( array . length - size < grow Size ) { grow For Insert ( location , grow Size ) ; } else if ( first Index + size > array . length - grow Size || ( first Index > NUM && location < size / NUM ) ) { int new First = first Index - grow Size ; if ( new First < NUM ) { int index = location + first Index ; System . arraycopy ( array , index , array , index - new First , size - location ) ; new First = NUM ; } System . arraycopy ( array , first Index , array , new First , location ) ; first Index = new First ; } else { int index = location + first Index ; System . arraycopy ( array , index , array , index + grow Size , size - location ) ; } } System . arraycopy ( dumparray , NUM , this . array , location + first Index , grow Size ) ; size += grow Size ; mod Count ++ ; return BOOL ; }
public static int compare ( Date left , Date right ) { return compare ( left . get Time ( ) / NUM , right . get Time ( ) / NUM ) ; }
public void test clear All Solution Sets ( ) { final List < I Binding Set [ ] > in 1 = new Linked List < I Binding Set [ ] > ( ) ; { final List < I Binding Set > t = new Linked List < I Binding Set > ( ) ; { final List Binding Set b = new List Binding Set ( ) ; t . add ( b ) ; } in 1 . add ( t . to Array ( new I Binding Set [ NUM ] ) ) ; } final List < I Binding Set [ ] > in 2 = new Linked List < I Binding Set [ ] > ( ) ; { final List < I Binding Set > t = new Linked List < I Binding Set > ( ) ; { final List Binding Set b = new List Binding Set ( ) ; t . add ( b ) ; } { final List Binding Set b = new List Binding Set ( ) ; t . add ( b ) ; } in 1 . add ( t . to Array ( new I Binding Set [ NUM ] ) ) ; } final String solution Set 1 = get Name ( ) + NUM ; final String solution Set 2 = get Name ( ) + NUM ; try { solution Sets Manager . get Solutions ( solution Set 1 ) ; fail ( STRING + Illegal State Exception . class ) ; } catch ( Illegal State Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + ex ) ; } try { solution Sets Manager . get Solutions ( solution Set 2 ) ; fail ( STRING + Illegal State Exception . class ) ; } catch ( Illegal State Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + ex ) ; } solution Sets Manager . put Solutions ( solution Set 1 , new Closeable Iterator Wrapper < I Binding Set [ ] > ( in 1 . iterator ( ) ) ) ; solution Sets Manager . put Solutions ( solution Set 2 , new Closeable Iterator Wrapper < I Binding Set [ ] > ( in 2 . iterator ( ) ) ) ; assert Same Solutions Any Order ( flatten ( in 1 . iterator ( ) ) , solution Sets Manager . get Solutions ( solution Set 1 ) ) ; assert Same Solutions Any Order ( flatten ( in 2 . iterator ( ) ) , solution Sets Manager . get Solutions ( solution Set 2 ) ) ; solution Sets Manager . clear All Solutions ( ) ; try { final I Closeable Iterator < I Binding Set [ ] > itr = solution Sets Manager . get Solutions ( solution Set 1 ) ; try { assert False ( itr . has Next ( ) ) ; } finally { itr . close ( ) ; } fail ( STRING + Illegal State Exception . class ) ; } catch ( Illegal State Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + ex ) ; } assert False ( solution Sets Manager . exists Solutions ( solution Set 1 ) ) ; try { solution Sets Manager . get Solutions ( solution Set 2 ) ; fail ( STRING + Illegal State Exception . class ) ; } catch ( Illegal State Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( STRING + ex ) ; } assert False ( solution Sets Manager . exists Solutions ( solution Set 2 ) ) ; }
private void init Connection ( ) throws Replicator Exception { try { logger . info ( STRING + server Port ) ; Inet Address host = Inet Address . get By Name ( STRING ) ; socket = new Socket ( host , server Port ) ; socket . set So Timeout ( timeout * NUM ) ; logger . debug ( STRING + socket . get Receive Buffer Size ( ) ) ; logger . info ( STRING + socket . get Remote Socket Address ( ) ) ; to Server = new Print Writer ( socket . get Output Stream ( ) , BOOL ) ; from Server = new Buffered Reader ( new Input Stream Reader ( socket . get Input Stream ( ) ) ) ; } catch ( Unknown Host Exception e ) { throw new Replicator Exception ( STRING + e , e ) ; } catch ( IO Exception e ) { throw new Replicator Exception ( STRING + e , e ) ; } }
protected boolean test ( double val 1 , double val 2 , String Buffer buf ) { boolean ret = BOOL ; switch ( op ) { case NUM : ret = val 1 == val 2 ; break ; case NUM : ret = val 1 != val 2 ; break ; case NUM : ret = val 1 < val 2 ; break ; case NUM : ret = val 1 > val 2 ; break ; case NUM : ret = val 1 <= val 2 ; break ; case NUM : ret = val 1 >= val 2 ; } if ( buf != null ) { String operation = null ; switch ( op ) { case NUM : operation = ( ret + STRING + val 1 + STRING + val 2 ) ; break ; case NUM : operation = ( ret + STRING + val 1 + STRING + val 2 ) ; break ; case NUM : operation = ( ret + STRING + val 1 + STRING + val 2 ) ; break ; case NUM : operation = ( ret + STRING + val 1 + STRING + val 2 ) ; break ; case NUM : operation = ( ret + STRING + val 1 + STRING + val 2 ) ; break ; case NUM : operation = ( ret + STRING + val 1 + STRING + val 2 ) ; } buf . append ( STRING + to String ( ) + STRING + operation ) ; } return ret ; }
private boolean is Debuggable ( Level level ) { if ( level . int Value ( ) < debug Level . int Value ( ) || debug Level == Level . OFF ) { return BOOL ; } return BOOL ; }
static Object [ ] compute Folder Non Java Resources ( I Package Fragment Root root , I Container folder , char [ ] [ ] inclusion Patterns , char [ ] [ ] exclusion Patterns ) throws Java Model Exception { I Resource [ ] non Java Resources = new I Resource [ NUM ] ; int non Java Resources Counter = NUM ; try { I Resource [ ] members = folder . members ( ) ; int length = members . length ; if ( length > NUM ) { I Java Project other Java Project = Java Core . create ( folder . get Project ( ) ) ; String source Level = other Java Project . get Option ( Java Core . COMPILER SOURCE , BOOL ) ; String compliance Level = other Java Project . get Option ( Java Core . COMPILER COMPLIANCE , BOOL ) ; Java Project java Project = ( Java Project ) root . get Java Project ( ) ; I Classpath Entry [ ] classpath = java Project . get Resolved Classpath ( ) ; next Resource : for ( int i = NUM ; i < length ; i ++ ) { I Resource member = members [ i ] ; switch ( member . get Type ( ) ) { case I Resource . FILE : String file Name = member . get Name ( ) ; if ( Util . is Valid Compilation Unit Name ( file Name , source Level , compliance Level ) && ! Util . is Excluded ( member , inclusion Patterns , exclusion Patterns ) ) continue next Resource ; if ( Util . is Valid Class File Name ( file Name , source Level , compliance Level ) ) continue next Resource ; if ( is Classpath Entry ( member . get Full Path ( ) , classpath ) ) continue next Resource ; break ; case I Resource . FOLDER : if ( Util . is Valid Folder Name For Package ( member . get Name ( ) , source Level , compliance Level ) && ( ! Util . is Excluded ( member , inclusion Patterns , exclusion Patterns ) || is Classpath Entry ( member . get Full Path ( ) , classpath ) ) ) continue next Resource ; break ; } if ( non Java Resources . length == non Java Resources Counter ) { System . arraycopy ( non Java Resources , NUM , ( non Java Resources = new I Resource [ non Java Resources Counter * NUM ] ) , NUM , non Java Resources Counter ) ; } non Java Resources [ non Java Resources Counter ++ ] = member ; } } return non Java Resources ; } catch ( Core Exception e ) { throw new Java Model Exception ( e ) ; } }
public static boolean rename File ( File input Path , File new File Path ) { if ( new File Path . exists ( ) ) { Log . e ( TAG , STRING + new File Path . get Absolute Path ( ) ) ; return BOOL ; } if ( input Path . is Directory ( ) ) { Log . e ( TAG , STRING + input Path . get Absolute Path ( ) ) ; return BOOL ; } if ( ! create Directory If Needed ( new File Path . get Absolute Path ( ) ) ) { Log . e ( TAG , STRING + new File Path . get Absolute Path ( ) ) ; return BOOL ; } return input Path . rename To ( new File Path ) ; }
private void write Net Buffer ( ) throws Ignite Checked Exception { try { ch . write ( out Net Buf ) ; } catch ( IO Exception e ) { throw new Ignite Checked Exception ( STRING , e ) ; } }
public Power Manager Menu ( ) { super ( ) ; Button Group group = new Button Group ( ) ; set Text ( STRING ) ; List < Power Manager > managers = Instance Manager . get List ( Power Manager . class ) ; for ( Power Manager mgr : managers ) { if ( mgr != null ) { J Menu Item item = new J Radio Button Menu Item ( mgr . get User Name ( ) ) ; add ( item ) ; group . add ( item ) ; items . add ( item ) ; item . add Action Listener ( null ) ; } } set Default ( ) ; }
public synchronized void add Consumer ( Image Consumer ic ) { if ( ! ics . contains ( ic ) ) { ics . add Element ( ic ) ; } }
private synchronized void refresh Sockets ( ) { refresh Aperture ( ) ; int n = pending Sockets + active Sockets . size ( ) ; if ( n < target Aperture && ! active Factories . is Empty ( ) ) { logger . debug ( STRING , n , target Aperture , target Aperture - n ) ; add Sockets ( target Aperture - n ) ; } else if ( target Aperture < active Sockets . size ( ) ) { logger . debug ( STRING , n , target Aperture ) ; quick Slowest RS ( ) ; } long now = Clock . now ( ) ; if ( now - last Refresh < refresh Period ) { return ; } else { long prev = refresh Period ; refresh Period = ( long ) Math . min ( refresh Period * NUM , max Refresh Period ) ; logger . info ( STRING , prev / NUM , refresh Period / NUM ) ; } last Refresh = now ; add Sockets ( NUM ) ; }
public static void update Context ( LRMI Invocation Trace invocation Trace , Proxy Write Type proxy Write Type , Invocation Stage stage , Platform Logical Version source Logical Version , Platform Logical Version target Logical Version , boolean create Snapshot , Boolean use Stub Cache , Inet Socket Address client End Point Address ) { LRMI Invocation Context Holder holder = invocation Contexts . get ( ) ; LRMI Invocation Context invocation Context = holder . get Context ( ) ; LRMI Invocation Context actual Context = create Snapshot ? invocation Context . snapshot ( ) : invocation Context ; if ( invocation Trace != null || create Snapshot ) actual Context . set Trace ( invocation Trace ) ; if ( proxy Write Type != null || create Snapshot ) actual Context . set Proxy Write Type ( proxy Write Type ) ; if ( stage != null || create Snapshot ) actual Context . set Invocation Stage ( stage ) ; if ( source Logical Version != null || create Snapshot ) actual Context . set Source Logical Version ( source Logical Version ) ; if ( target Logical Version != null || create Snapshot ) actual Context . set Target Logical Version ( target Logical Version ) ; if ( use Stub Cache != null ) actual Context . set Use Stub Cache ( use Stub Cache . boolean Value ( ) ) ; if ( client End Point Address != null || create Snapshot ) { actual Context . set Client End Point Address ( client End Point Address ) ; } if ( create Snapshot ) { if ( invocation Context . liveness Priority Enabled In Next Invocation ) actual Context . set Liveness Priority Enabled ( BOOL ) ; if ( invocation Context . custom Priority Enabled In Next Invocation ) actual Context . set Custom Priority Enabled ( BOOL ) ; if ( invocation Context . callback Method In Next Invocation ) actual Context . set Callback Method ( BOOL ) ; } holder . set Context ( actual Context ) ; }
public void test Pawn Moves ( ) throws Chess Parse Error { String fen = STRING ; Position pos = Text IO . read FEN ( fen ) ; assert Equals ( fen , Text IO . to FEN ( pos ) ) ; List < String > str Moves = get Move List ( pos , BOOL ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert Equals ( NUM , str Moves . size ( ) ) ; pos . set Ep Square ( - NUM ) ; str Moves = get Move List ( pos , BOOL ) ; assert Equals ( NUM , str Moves . size ( ) ) ; pos . set White Move ( BOOL ) ; str Moves = get Move List ( pos , BOOL ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert Equals ( NUM , str Moves . size ( ) ) ; pos . set Piece ( Position . get Square ( NUM , NUM ) , Piece . BPAWN ) ; str Moves = get Move List ( pos , BOOL ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; assert True ( str Moves . contains ( STRING ) ) ; }
public static int check And Correct ( Binary Message frame , int start Index ) { int syndrome = get Syndrome ( frame , start Index ) ; if ( syndrome == NUM ) { return NUM ; } Binary Message copy = frame . get Sub Message ( start Index , start Index + NUM ) ; int index = - NUM ; int syndrome Weight = MAX CORRECTABLE ERRORS ; int errors = NUM ; while ( index < NUM ) { if ( index != - NUM ) { if ( index > NUM ) { copy . flip ( index - NUM ) ; } copy . flip ( index ) ; syndrome Weight = MAX CORRECTABLE ERRORS - NUM ; } syndrome = get Syndrome ( copy , NUM ) ; if ( syndrome > NUM ) { for ( int i = NUM ; i < NUM ; i ++ ) { errors = Integer . bit Count ( syndrome ) ; if ( errors <= syndrome Weight ) { copy . xor ( NUM , NUM , syndrome ) ; copy . rotate Right ( i , NUM , NUM ) ; if ( index >= NUM ) { errors ++ ; } int corrected = copy . get Int ( NUM , NUM ) ; int original = frame . get Int ( start Index , start Index + NUM ) ; int error Count = Integer . bit Count ( original ^ corrected ) ; if ( error Count <= NUM ) { frame . load ( start Index , NUM , corrected ) ; } return error Count ; } else { copy . rotate Left ( NUM , NUM ) ; syndrome = get Syndrome ( copy , NUM ) ; } } index ++ ; } } return NUM ; }
public static Expr Node [ ] validate ( String view Name , Event Type event Type , Statement Context statement Context , List < Expr Node > expressions , boolean allow Constant Result ) throws View Parameter Exception { List < Expr Node > results = new Array List < Expr Node > ( ) ; int expression Number = NUM ; Stream Type Service stream Type Service = new Stream Type Service Impl ( event Type , null , BOOL , statement Context . get Engine URI ( ) ) ; for ( Expr Node expr : expressions ) { Expr Node validated = validate Expr ( view Name , statement Context , expr , stream Type Service , expression Number ) ; results . add ( validated ) ; if ( ( ! allow Constant Result ) && ( validated . is Constant Result ( ) ) ) { String message = STRING + expression Number + get View Desc ( view Name ) + STRING ; log . error ( message ) ; throw new View Parameter Exception ( message ) ; } expression Number ++ ; } return results . to Array ( new Expr Node [ results . size ( ) ] ) ; }
private static int last Unescaped Index Of ( @ Not Null String s , int from , char c ) { int result = from ; do { result = s . last Index Of ( c , result - NUM ) ; } while ( result != - NUM && ! is Unescaped ( s , result , c ) ) ; return result ; }
@ Override public String generate URL ( XY Dataset dataset , int series , int item ) { String url = this . prefix ; boolean first Parameter = url . index Of ( STRING ) == - NUM ; url += first Parameter ? STRING : STRING ; url += this . series Parameter Name + STRING + series + STRING + this . item Parameter Name + STRING + item ; return url ; }
public boolean is Idle Expire ( ) { if ( ! lifecycle . is Active ( ) ) { return BOOL ; } long now = get Current Time Actual ( ) ; long idle Expire = thread Idle Expire Time . get ( ) ; int idle Count = idle Count . get ( ) ; if ( idle Min < idle Count ) { long next Idle Expire = now + idle Timeout ; if ( idle Max < idle Count && idle Min < idle Max ) { thread Idle Expire Time . compare And Set ( idle Expire , next Idle Expire ) ; return BOOL ; } else if ( idle Expire < now && thread Idle Expire Time . compare And Set ( idle Expire , next Idle Expire ) ) { return BOOL ; } } return BOOL ; }
public void handle Button 1 Request ( Request Invocation Event event ) throws Model Control Exception { FS Auth Domains Model model = ( FS Auth Domains Model ) get Model ( ) ; String name = ( String ) get Display Field Value ( model . TF NAME ) ; AM Property Sheet ps = ( AM Property Sheet ) get Child ( PROPERTY ATTRIBUTE ) ; try { String realm = model . get Realm ( name ) ; Map values = ps . get Attribute Values ( model . get Data Map ( ) , BOOL , model ) ; model . set Attribute Values ( realm , name , values ) ; Serialized Field sz Cache = ( Serialized Field ) get Child ( SZ CACHE ) ; Federation View Bean vb = ( Federation View Bean ) get View Bean ( Federation View Bean . class ) ; CC Add Remove add Remove List = ( CC Add Remove ) get Child ( ADD REMOVE PROVIDERS ) ; add Remove List . restore State Data ( ) ; CC Add Remove Model add Remove Model = ( CC Add Remove Model ) add Remove List . get Model ( ) ; List list = new Array List ( get Selected Values ( add Remove Model ) ) ; model . add Providers ( realm , name , list ) ; set Inline Alert Message ( CC Alert . TYPE INFO , STRING , STRING ) ; forward To ( ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; forward To ( ) ; } }
public boolean strip ( String infile , String outfile ) { if ( infile == null ) throw new Null Pointer Exception ( STRING ) ; File in = new File ( infile ) ; File out = null ; if ( outfile != null ) out = new File ( outfile ) ; return strip ( in , out ) ; }
public static void drop All ( Connection conn ) throws SQL Exception { Statement stat = conn . create Statement ( ) ; stat . execute ( STRING + SCHEMA ) ; remove All Triggers ( conn , TRIGGER PREFIX ) ; remove Index Files ( conn ) ; }
public boolean remove Job Group To Never Delete ( String group ) { return group != null && job Groups To Never Delete . remove ( group ) ; }
private Mobile Doc create Layout ( Mobile Doc doc , M Workflow wf , int active Node , MWF Node [ ] nodes , Array List nodes ID , int [ ] [ ] image Map ) { body b = doc . get Body ( ) ; b . add Element ( print Workflow ( active Node , wf , nodes , nodes ID , image Map ) ) ; b . add Element ( new hr ( ) ) ; b . add Element ( print Description ( active Node , wf , nodes , nodes ID ) ) ; b . add Element ( new br ( ) ) ; b . add Element ( print Control Panel ( active Node , wf , nodes , nodes ID ) ) ; return doc ; }
@ Override public void request Close Read ( ) { state = state . to Close Read ( ) ; try { request Loop ( ) ; } catch ( Exception e ) { log . log ( Level . WARNING , e . to String ( ) , e ) ; } }
public Multi Match Query Builder field ( String field , float boost ) { fields . add ( field ) ; if ( fields Boosts == null ) { fields Boosts = new Object Float Hash Map < > ( ) ; } fields Boosts . put ( field , boost ) ; return this ; }
private byte [ ] decrypt ( byte [ ] data , NTRU Encryption Private Key Parameters priv Key ) throws Invalid Cipher Text Exception { Polynomial priv t = priv Key . t ; Integer Polynomial priv fp = priv Key . fp ; Integer Polynomial pub = priv Key . h ; int N = params . N ; int q = params . q ; int db = params . db ; int max Msg Len Bytes = params . max Msg Len Bytes ; int dm 0 = params . dm 0 ; int pk Len = params . pk Len ; int min Calls Mask = params . min Calls Mask ; boolean hash Seed = params . hash Seed ; byte [ ] oid = params . oid ; if ( max Msg Len Bytes > NUM ) { throw new Data Length Exception ( STRING ) ; } int b Len = db / NUM ; Integer Polynomial e = Integer Polynomial . from Binary ( data , N , q ) ; Integer Polynomial ci = decrypt ( e , priv t , priv fp ) ; if ( ci . count ( - NUM ) < dm 0 ) { throw new Invalid Cipher Text Exception ( STRING ) ; } if ( ci . count ( NUM ) < dm 0 ) { throw new Invalid Cipher Text Exception ( STRING ) ; } if ( ci . count ( NUM ) < dm 0 ) { throw new Invalid Cipher Text Exception ( STRING ) ; } Integer Polynomial cR = ( Integer Polynomial ) e . clone ( ) ; cR . sub ( ci ) ; cR . mod Positive ( q ) ; Integer Polynomial cR 4 = ( Integer Polynomial ) cR . clone ( ) ; cR 4 . mod Positive ( NUM ) ; byte [ ] co R 4 = cR 4 . to Binary ( NUM ) ; Integer Polynomial mask = MGF ( co R 4 , N , min Calls Mask , hash Seed ) ; Integer Polynomial cM Trin = ci ; cM Trin . sub ( mask ) ; cM Trin . mod 3 ( ) ; byte [ ] cM = cM Trin . to Binary 3 Sves ( ) ; byte [ ] cb = new byte [ b Len ] ; System . arraycopy ( cM , NUM , cb , NUM , b Len ) ; int cl = cM [ b Len ] & NUM ; if ( cl > max Msg Len Bytes ) { throw new Invalid Cipher Text Exception ( STRING + cl + STRING + max Msg Len Bytes ) ; } byte [ ] cm = new byte [ cl ] ; System . arraycopy ( cM , b Len + NUM , cm , NUM , cl ) ; byte [ ] p0 = new byte [ cM . length - ( b Len + NUM + cl ) ] ; System . arraycopy ( cM , b Len + NUM + cl , p0 , NUM , p0 . length ) ; if ( ! Arrays . constant Time Are Equal ( p0 , new byte [ p0 . length ] ) ) { throw new Invalid Cipher Text Exception ( STRING ) ; } byte [ ] bh = pub . to Binary ( q ) ; byte [ ] h Trunc = copy Of ( bh , pk Len / NUM ) ; byte [ ] s Data = build S Data ( oid , cm , cl , cb , h Trunc ) ; Polynomial cr = generate Blinding Poly ( s Data , cm ) ; Integer Polynomial cR Prime = cr . mult ( pub ) ; cR Prime . mod Positive ( q ) ; if ( ! cR Prime . equals ( cR ) ) { throw new Invalid Cipher Text Exception ( STRING ) ; } return cm ; }
public void await All Acks Received ( ) throws Ignite Interrupted Checked Exception { lock . lock ( ) ; try { while ( ! ack Map . is Empty ( ) ) U . await ( all Acks Rcv Cond ) ; } finally { lock . unlock ( ) ; } }
public static String to Bits ( final long x ) { final String Builder sb = new String Builder ( ) ; long t = x ; boolean first = BOOL ; for ( int i = NUM ; i < NUM ; i ++ ) { if ( t < NUM ) { sb . append ( STRING ) ; first = BOOL ; } else if ( first ) { sb . append ( STRING ) ; } t = t << NUM ; } assert t == NUM ; return sb . to String ( ) ; }
public void copy Residuals ( byte [ ] source , int target Position , int target Size ) { int unit Size = source . length ; if ( unit Size < target Size ) { int target Start = ( target Size - unit Size ) / NUM ; System . arraycopy ( source , NUM , residuals , target Position + target Start , source . length ) ; } else { int source Position = ( unit Size - target Size ) / NUM ; System . arraycopy ( source , source Position , residuals , target Position , target Size ) ; } }
public double linear Distance ( Location location ) { if ( location == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STRING , STRING , STRING ) ) ; } double lat 1 = Math . to Radians ( this . latitude ) ; double lon 1 = Math . to Radians ( this . longitude ) ; double lat 2 = Math . to Radians ( location . latitude ) ; double lon 2 = Math . to Radians ( location . longitude ) ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) { return NUM ; } double d Lat = lat 2 - lat 1 ; double d Lon = lon 2 - lon 1 ; if ( Math . abs ( d Lon ) > Math . PI ) { d Lon = d Lon > NUM ? - ( NUM * Math . PI - d Lon ) : ( NUM * Math . PI + d Lon ) ; } double distance Radians = Math . sqrt ( d Lat * d Lat + d Lon * d Lon ) ; return Double . is Na N ( distance Radians ) ? NUM : distance Radians ; }
public static Named List read From Resource Loader ( Solr Resource Loader loader , String name ) { Input Stream Reader reader ; try { reader = new Input Stream Reader ( loader . open Resource ( name ) , Standard Charsets . UTF 8 ) ; } catch ( Solr Resource Not Found Exception ex ) { log . debug ( STRING + ex . get Message ( ) ) ; return null ; } catch ( Exception ex ) { throw new Solr Exception ( Error Code . SERVER ERROR , STRING + name , ex ) ; } try { return read From Input Stream ( reader ) ; } finally { IO Utils . close Quietly ( reader ) ; } }
public void fire Annotation Moved ( Workflow Annotation anno ) { List < Workflow Annotation > list = new Linked List < > ( ) ; list . add ( anno ) ; fire Annotations Moved ( list ) ; }
@ Override public void modify Variable Id ( String old Var Id , String new Var Id ) { Map < Assignment , Double > new Table = new Hash Map < Assignment , Double > ( ) ; for ( Assignment head : table . key Set ( ) ) { Assignment new Head = head . copy ( ) ; if ( head . contains Var ( old Var Id ) ) { Value cond Val = new Head . remove Pair ( old Var Id ) ; new Head . add Pair ( new Var Id , cond Val ) ; } new Table . put ( new Head , table . get ( head ) ) ; } if ( head Vars . contains ( old Var Id ) ) { head Vars . remove ( old Var Id ) ; head Vars . add ( new Var Id ) ; } table = new Table ; intervals = null ; }
protected void initialize ( ) { List < Add User Fields . Attribute Spec > specs = m filter . get Attribute Specs ( ) ; m list Model = new Default List Model ( ) ; m list . set Model ( m list Model ) ; if ( specs . size ( ) > NUM ) { m up But . set Enabled ( BOOL ) ; m down But . set Enabled ( BOOL ) ; for ( Add User Fields . Attribute Spec s : specs ) { Add User Fields . Attribute Spec spec Copy = new Add User Fields . Attribute Spec ( s . to String Internal ( ) ) ; m list Model . add Element ( spec Copy ) ; } m list . repaint ( ) ; } else { m name Field . set Enabled ( BOOL ) ; m type Field . set Enabled ( BOOL ) ; m date Format Field . set Enabled ( BOOL ) ; m value Field . set Enabled ( BOOL ) ; } }
private static double parse Time ( String s ) throws Number Format Exception { if ( s . length ( ) > NUM ) throw new Number Format Exception ( STRING + s + STRING ) ; double result = NUM ; char [ ] c = s . to Char Array ( ) ; char [ ] x = new char [ ] { STRING , STRING , STRING , STRING } ; for ( int i = NUM ; i < c . length ; i ++ ) x [ i + NUM - c . length ] = c [ i ] ; try { int hours = Integer . parse Int ( STRING + x [ NUM ] + x [ NUM ] ) ; int minutes = Integer . parse Int ( STRING + x [ NUM ] + x [ NUM ] ) ; result = hours * NUM + minutes * NUM ; } catch ( Number Format Exception e ) { throw new Number Format Exception ( STRING + s + STRING ) ; } if ( result < ( NUM * NUM ) ) result += ( NUM * NUM ) ; return result ; }
protected final void add Workers ( Collection < Worker Thread > workers ) { for ( final Iterator < Worker Thread > iter = workers . iterator ( ) ; iter . has Next ( ) ; ) { final Worker Thread worker = iter . next ( ) ; add Worker ( worker ) ; } }
void insert ( V val , K key ) { Array List < K > list = map . get ( val ) ; if ( list == null ) { list = new Array List < K > ( NUM ) ; map . put ( clone Value ( val ) , list ) ; } list . add ( key ) ; }
@ Override public int hash Code ( ) { int hc = hash Code Value ; if ( hc == NUM ) { hc = base Locale . hash Code ( ) ; if ( locale Extensions != null ) { hc ^= locale Extensions . hash Code ( ) ; } hash Code Value = hc ; } return hc ; }
public void add Sample ( int weight , float value ) { ensure Sorted By Index ( ) ; Sample new Sample = recycled Sample Count > NUM ? recycled Samples [ -- recycled Sample Count ] : new Sample ( ) ; new Sample . index = next Sample Index ++ ; new Sample . weight = weight ; new Sample . value = value ; samples . add ( new Sample ) ; total Weight += weight ; while ( total Weight > max Weight ) { int excess Weight = total Weight - max Weight ; Sample oldest Sample = samples . get ( NUM ) ; if ( oldest Sample . weight <= excess Weight ) { total Weight -= oldest Sample . weight ; samples . remove ( NUM ) ; if ( recycled Sample Count < MAX RECYCLED SAMPLES ) { recycled Samples [ recycled Sample Count ++ ] = oldest Sample ; } } else { oldest Sample . weight -= excess Weight ; total Weight -= excess Weight ; } } }
private static String make Qualified Method Name ( String name , String [ ] params ) { String Buffer sb = new String Buffer ( name ) ; sb . append ( STRING ) ; for ( int i = NUM ; i < params . length ; i ++ ) { sb . append ( STRING ) ; sb . append ( params [ i ] ) ; } return sb . to String ( ) ; }
void write ( ) { clear Attributes ( ) ; if ( term Attribute . length ( ) < buffer . length ( ) ) { term Attribute . resize Buffer ( buffer . length ( ) ) ; } char termbuffer [ ] = term Attribute . buffer ( ) ; buffer . get Chars ( NUM , buffer . length ( ) , termbuffer , NUM ) ; term Attribute . set Length ( buffer . length ( ) ) ; if ( has Illegal Offsets ) { offset Attribute . set Offset ( saved Start Offset , saved End Offset ) ; } else { offset Attribute . set Offset ( start Offset , end Offset ) ; } pos Inc Attribute . set Position Increment ( position ( BOOL ) ) ; type Attribute . set Type ( saved Type ) ; accum Pos Inc = NUM ; }
public Pattern extract Ip ( String str ) { Pattern pattern = null ; String [ ] ips = str . split ( STRING ) ; List < Ip Node > ip Nodes = new Array List < > ( ) ; for ( String ip : ips ) { ip = ip . trim ( ) ; if ( ip . index Of ( STRING ) != - NUM ) { int mask = Integer . value Of ( ip . substring ( ip . index Of ( STRING ) + NUM ) ) ; ip = ip . substring ( NUM , ip . index Of ( STRING ) ) ; while ( ip . split ( STRING ) . length < NUM ) { ip += STRING ; } Ip Node node = new Ip Node ( ip , mask ) ; ip Nodes . add ( node ) ; } else { Ip Node node = new Ip Node ( ip , NUM ) ; ip Nodes . add ( node ) ; } } pattern = new Ip Pattern ( ip Nodes ) ; return pattern ; }
@ Override public void message Received ( Next Filter next Filter , Io Session session , Object message ) throws Exception { LOGGER . debug ( STRING , session . get Id ( ) ) ; if ( ! ( message instanceof Io Buffer ) ) { next Filter . message Received ( session , message ) ; return ; } Io Buffer in = ( Io Buffer ) message ; Protocol Decoder decoder = factory . get Decoder ( session ) ; Protocol Decoder Output decoder Out = get Decoder Out ( session , next Filter ) ; while ( in . has Remaining ( ) ) { int old Pos = in . position ( ) ; try { lock . acquire ( ) ; decoder . decode ( session , in , decoder Out ) ; decoder Out . flush ( next Filter , session ) ; } catch ( Exception e ) { Protocol Decoder Exception pde ; if ( e instanceof Protocol Decoder Exception ) { pde = ( Protocol Decoder Exception ) e ; } else { pde = new Protocol Decoder Exception ( e ) ; } if ( pde . get Hexdump ( ) == null ) { int cur Pos = in . position ( ) ; in . position ( old Pos ) ; pde . set Hexdump ( in . get Hex Dump ( ) ) ; in . position ( cur Pos ) ; } decoder Out . flush ( next Filter , session ) ; next Filter . exception Caught ( session , pde ) ; if ( ! ( e instanceof Recoverable Protocol Decoder Exception ) || ( in . position ( ) == old Pos ) ) { break ; } } finally { lock . release ( ) ; } } }
public Object parse Object ( String source , Parse Position pos ) { return null ; }
public Stream < T > stream ( ) { return Stream Support . stream ( spliterator ( ) , BOOL ) ; }
public void store ( ) throws Id Repo Exception , SSO Exception { Id Services id Services = Id Services Factory . get Data Store Services ( ) ; if ( mod Map != null && ! mod Map . is Empty ( ) ) { id Services . set Attributes ( token , type , name , mod Map , BOOL , org Name , univ DN , BOOL ) ; mod Map . clear ( ) ; } if ( binary Mod Map != null && ! binary Mod Map . is Empty ( ) ) { id Services . set Attributes ( token , type , name , binary Mod Map , BOOL , org Name , univ DN , BOOL ) ; binary Mod Map . clear ( ) ; } }
protected Size 2 D arrange NN ( Block Container container , Graphics 2 D g2 ) { double max W = NUM ; double max H = NUM ; List blocks = container . get Blocks ( ) ; Iterator iterator = blocks . iterator ( ) ; while ( iterator . has Next ( ) ) { Block b = ( Block ) iterator . next ( ) ; if ( b != null ) { Size 2 D s = b . arrange ( g2 , Rectangle Constraint . NONE ) ; max W = Math . max ( max W , s . width ) ; max H = Math . max ( max H , s . height ) ; } } double width = this . columns * max W ; double height = this . rows * max H ; Rectangle Constraint c = new Rectangle Constraint ( width , height ) ; return arrange FF ( container , g2 , c ) ; }
public static boolean is File Transfer Over Http ( Sip Request request ) { Cpim Message message = extract Cpim Message ( request ) ; if ( message == null ) { return BOOL ; } String content Type = message . get Content Type ( ) ; return content Type != null && content Type . starts With ( File Transfer Http Info Document . MIME TYPE ) ; }
public static org . opcfoundation . ua . transport . security . Key Pair create Https Certificate ( String host Name , String application Uri , int days , org . opcfoundation . ua . transport . security . Key Pair issuer Cert ) throws IO Exception , General Security Exception { if ( application Uri == null ) throw new Null Pointer Exception ( STRING ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING , Arrays . to String ( Security . get Providers ( ) ) ) ; Key Pair key Pair = generate Key Pair ( ) ; X509 Certificate cert ; cert = generate Certificate ( STRING + host Name , days , application Uri , key Pair . get Public ( ) , key Pair . get Private ( ) , issuer Cert ) ; return to Key Pair ( cert , key Pair . get Private ( ) ) ; }
@ Suppress Warnings ( STRING ) public void handle Button 1 Request ( Request Invocation Event event ) throws Model Control Exception { submit Cycle = BOOL ; String sub Config Name = ( String ) get Display Field Value ( TF EVENT HANDLER NAME ) ; if ( String Utils . is Blank ( sub Config Name ) ) { set Inline Alert Message ( CC Alert . TYPE ERROR , ERROR MESSAGE , STRING ) ; forward To ( ) ; } Abstract Audit Model model = ( Abstract Audit Model ) get Model ( ) ; try { AM Property Sheet ps = ( AM Property Sheet ) get Child ( PROPERTY ATTRIBUTE ) ; String schema Name = ( String ) get Page Session Attribute ( AUDIT HANDLER TYPE ) ; @ Suppress Warnings ( STRING ) Map < String , Set < String > > values = ps . get Attribute Values ( model . get Event Handler Attribute Names ( schema Name ) ) ; model . create Event Handler ( sub Config Name , schema Name , values ) ; back To Profile View Bean ( ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , ERROR MESSAGE , e . get Message ( ) ) ; forward To ( ) ; } }
public String enable Module ( String id , String module ) { Tenant tenant = tenants . get ( id ) ; if ( tenant == null ) { return STRING + id + STRING ; } Module Descriptor mod = module Manager . get ( module ) ; if ( mod == null ) { return STRING + module + STRING ; } String deperr = check Dependencies ( tenant , mod ) ; if ( ! deperr . is Empty ( ) ) { return deperr ; } tenant . enable Module ( module ) ; return STRING ; }
public void children Removed ( Bean Context Membership Event bcme ) { Iterator it = bcme . iterator ( ) ; while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public static void mkdirs ( File directory ) throws Create Directory Exception { if ( directory . exists ( ) ) { if ( directory . is Directory ( ) ) { return ; } if ( ! directory . delete ( ) ) { throw new Create Directory Exception ( directory . get Absolute Path ( ) , new File Delete Exception ( directory . get Absolute Path ( ) ) ) ; } } if ( ! directory . mkdirs ( ) && ! directory . is Directory ( ) ) { throw new Create Directory Exception ( directory . get Absolute Path ( ) ) ; } }
public String to Clock ( ) { String Builder s = new String Builder ( ) ; s . append ( ( ( this . weeks * NUM + this . days ) * NUM + this . hours ) + STRING ) ; if ( this . minutes < NUM ) { s . append ( STRING ) ; } s . append ( this . minutes + STRING ) ; if ( this . seconds < NUM ) { s . append ( STRING ) ; } s . append ( this . seconds + STRING ) ; if ( this . milliseconds < NUM ) { s . append ( STRING ) ; } if ( this . milliseconds < NUM ) { s . append ( STRING ) ; } s . append ( this . milliseconds ) ; return s . to String ( ) ; }
public static boolean is Config File Keyword ( String name ) { return CONFIG KEYWORDS . contains ( name ) ; }
public static String extract Password From Image Url ( String image Url ) { Pattern r = Pattern . compile ( IMAGEURL PASSWORD SPLIT REGEX ) ; Matcher m = r . matcher ( image Url ) ; String password = null ; if ( m . find ( ) && m . group Count ( ) >= NUM && String Utils . is Not Blank ( m . group ( NUM ) ) ) { password = m . group ( NUM ) ; Pattern hostpattern = Pattern . compile ( IMAGEURL HOST REGEX ) ; Matcher host Matcher = hostpattern . matcher ( password ) ; if ( host Matcher . find ( ) ) { String pre Hostregex = STRING + host Matcher . group ( NUM ) ; Pattern pwd Pattern = Pattern . compile ( pre Hostregex ) ; Matcher pwd Matcher = pwd Pattern . matcher ( password ) ; if ( pwd Matcher . find ( ) ) { password = pwd Matcher . group ( NUM ) ; } } } return password ; }
public boolean equals ( Object other ) { if ( other == null ) return BOOL ; if ( get Class ( ) != other . get Class ( ) ) { return BOOL ; } Host Port that = ( Host Port ) other ; return port == that . port && host . equals ( that . host ) ; }
String rename Type ( Type type ) { if ( type == null ) { return null ; } if ( type . get Sort ( ) == Type . OBJECT ) { String in = type . get Internal Name ( ) ; return STRING + rename Internal Type ( in ) + STRING ; } else if ( type . get Sort ( ) == Type . ARRAY ) { String Builder sb = new String Builder ( ) ; for ( int n = type . get Dimensions ( ) ; n > NUM ; n -- ) { sb . append ( STRING ) ; } sb . append ( rename Type ( type . get Element Type ( ) ) ) ; return sb . to String ( ) ; } return type . get Descriptor ( ) ; }
public static void write Element List ( XML Output xml Output , String tag Name , Iterator < String > list Value Iterator ) throws IO Exception { while ( list Value Iterator . has Next ( ) ) { xml Output . open Tag ( tag Name ) ; xml Output . write Text ( list Value Iterator . next ( ) ) ; xml Output . close Tag ( tag Name ) ; } }
public D Policy Constraints ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
Collection < Cluster Node > alive Cache Nodes ( @ Nullable String cache Name , final long top Ver ) { return filter ( top Ver , alive Cache Nodes . get ( mask Null ( cache Name ) ) ) ; }
public static final void write Byte Array Xml ( byte [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int N = val . length ; out . attribute ( null , STRING , Integer . to String ( N ) ) ; String Builder sb = new String Builder ( val . length * NUM ) ; for ( int i = NUM ; i < N ; i ++ ) { int b = val [ i ] ; int h = b > > NUM ; sb . append ( h >= NUM ? ( STRING + h - NUM ) : ( STRING + h ) ) ; h = b & NUM ; sb . append ( h >= NUM ? ( STRING + h - NUM ) : ( STRING + h ) ) ; } out . text ( sb . to String ( ) ) ; out . end Tag ( null , STRING ) ; }
public void cancel Requests By TAG ( Object TAG , boolean may Interrupt If Running ) { if ( TAG == null ) { log . d ( LOG TAG , STRING ) ; return ; } for ( List < Request Handle > request List : request Map . values ( ) ) { if ( request List != null ) { for ( Request Handle request Handle : request List ) { if ( TAG . equals ( request Handle . get Tag ( ) ) ) request Handle . cancel ( may Interrupt If Running ) ; } } } }
public static void draw Horizontal Margin Indicator ( Graphics 2 D g , String text , int x1 , int x2 , int y ) { if ( x1 > x2 ) { int temp = x1 ; x1 = x2 ; x2 = temp ; } if ( text == null ) { g . draw Line ( x1 , y , x2 , y ) ; g . draw Line ( x1 , y , x1 + CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x1 , y , x1 + CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; g . draw Line ( x2 , y , x2 - CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x2 , y , x2 - CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; return ; } Canvas c = new Canvas ( ) ; Font Metrics fm = c . get Font Metrics ( s Font ) ; g . set Font ( s Font ) ; int padding = NUM ; Rectangle 2 D bounds = fm . get String Bounds ( text , g ) ; int th = ( int ) bounds . get Height ( ) ; int tw = ( int ) bounds . get Width ( ) ; int offset = NUM * CONNECTION ARROW SIZE ; int w = ( ( x2 - x1 ) - ( tw + NUM * padding ) ) / NUM ; if ( w <= padding ) { g . draw Line ( x1 , y , x2 , y ) ; g . draw String ( text , x1 + w + padding , y + offset ) ; g . draw Line ( x1 , y - CONNECTION ARROW SIZE , x1 , y + CONNECTION ARROW SIZE ) ; g . draw Line ( x2 , y - CONNECTION ARROW SIZE , x2 , y + CONNECTION ARROW SIZE ) ; } else { g . draw Line ( x1 , y , x1 + w , y ) ; g . draw Line ( x2 - w , y , x2 , y ) ; g . draw String ( text , x1 + w + padding , ( int ) ( y + ( bounds . get Height ( ) / NUM ) ) ) ; g . draw Line ( x1 , y , x1 + CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x1 , y , x1 + CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; g . draw Line ( x2 , y , x2 - CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x2 , y , x2 - CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; } }
public Log Record With DLSN read Op ( ) throws IO Exception { Log Record With DLSN next Record In Stream ; while ( BOOL ) { if ( last Record Skip To != null ) { next Record In Stream = last Record Skip To ; record Stream . advance ( NUM ) ; last Record Skip To = null ; return next Record In Stream ; } if ( record Set Reader != null ) { next Record In Stream = record Set Reader . next Record ( ) ; if ( null != next Record In Stream ) { record Stream . advance ( NUM ) ; return next Record In Stream ; } else { record Set Reader = null ; } } try { long metadata = in . read Long ( ) ; next Record In Stream = new Log Record With DLSN ( record Stream . get Current Position ( ) , start Sequence Id ) ; next Record In Stream . set Metadata ( metadata ) ; next Record In Stream . set Transaction Id ( in . read Long ( ) ) ; next Record In Stream . read Payload ( in ) ; if ( LOG . is Trace Enabled ( ) ) { if ( next Record In Stream . is Control ( ) ) { LOG . trace ( STRING , record Stream . get Name ( ) , next Record In Stream . get Dlsn ( ) ) ; } else { LOG . trace ( STRING , record Stream . get Name ( ) , next Record In Stream . get Dlsn ( ) ) ; } } int num Records = NUM ; if ( ! deserialize Record Set && next Record In Stream . is Record Set ( ) ) { num Records = Log Record Set . num Records ( next Record In Stream ) ; } if ( deserialize Record Set && next Record In Stream . is Record Set ( ) ) { record Set Reader = Log Record Set . of ( next Record In Stream ) ; } else { record Stream . advance ( num Records ) ; return next Record In Stream ; } } catch ( EOF Exception eof ) { break ; } } return null ; }
static public int cancel Operation ( int token ) { int canceled = NUM ; synchronized ( s Work Queue ) { Iterator < Operation Info > it = s Work Queue . iterator ( ) ; while ( it . has Next ( ) ) { if ( it . next ( ) . token == token ) { it . remove ( ) ; ++ canceled ; } } } if ( Async Query Service . local LOGV ) { Log . d ( TAG , STRING + token + STRING + canceled ) ; } return canceled ; }
final void long Accumulate ( long x , Long Binary Operator fn , boolean was Uncontended ) { int h ; if ( ( h = get Probe ( ) ) == NUM ) { Thread Local Random . current ( ) ; h = get Probe ( ) ; was Uncontended = BOOL ; } boolean collide = BOOL ; for ( ; ; ) { Cell [ ] as ; Cell a ; int n ; long v ; if ( ( as = cells ) != null && ( n = as . length ) > NUM ) { if ( ( a = as [ ( n - NUM ) & h ] ) == null ) { if ( cells Busy == NUM ) { Cell r = new Cell ( x ) ; if ( cells Busy == NUM && cas Cells Busy ( ) ) { boolean created = BOOL ; try { Cell [ ] rs ; int m , j ; if ( ( rs = cells ) != null && ( m = rs . length ) > NUM && rs [ j = ( m - NUM ) & h ] == null ) { rs [ j ] = r ; created = BOOL ; } } finally { cells Busy = NUM ; } if ( created ) break ; continue ; } } collide = BOOL ; } else if ( ! was Uncontended ) was Uncontended = BOOL ; else if ( a . cas ( v = a . value , ( ( fn == null ) ? v + x : fn . apply As Long ( v , x ) ) ) ) break ; else if ( n >= NCPU || cells != as ) collide = BOOL ; else if ( ! collide ) collide = BOOL ; else if ( cells Busy == NUM && cas Cells Busy ( ) ) { try { if ( cells == as ) { Cell [ ] rs = new Cell [ n << NUM ] ; for ( int i = NUM ; i < n ; ++ i ) rs [ i ] = as [ i ] ; cells = rs ; } } finally { cells Busy = NUM ; } collide = BOOL ; continue ; } h = advance Probe ( h ) ; } else if ( cells Busy == NUM && cells == as && cas Cells Busy ( ) ) { boolean init = BOOL ; try { if ( cells == as ) { Cell [ ] rs = new Cell [ NUM ] ; rs [ h & NUM ] = new Cell ( x ) ; cells = rs ; init = BOOL ; } } finally { cells Busy = NUM ; } if ( init ) break ; } else if ( cas Base ( v = base , ( ( fn == null ) ? v + x : fn . apply As Long ( v , x ) ) ) ) break ; } }
public Point 2 D inverse Transform ( Point 2 D view Point ) { Point 2 D view Center = get View Center ( ) ; double view Radius = get View Radius ( ) ; double ratio = get Ratio ( ) ; double dx = view Point . get X ( ) - view Center . get X ( ) ; double dy = view Point . get Y ( ) - view Center . get Y ( ) ; dx *= ratio ; Point 2 D point From Center = new Point 2 D . Double ( dx , dy ) ; Polar Point polar = Polar Point . cartesian To Polar ( point From Center ) ; double radius = polar . get Radius ( ) ; if ( radius > view Radius ) return delegate . inverse Transform ( view Point ) ; double mag = magnification ; radius /= mag ; polar . set Radius ( radius ) ; Point 2 D projected Point = Polar Point . polar To Cartesian ( polar ) ; projected Point . set Location ( projected Point . get X ( ) / ratio , projected Point . get Y ( ) ) ; Point 2 D translated Back = new Point 2 D . Double ( projected Point . get X ( ) + view Center . get X ( ) , projected Point . get Y ( ) + view Center . get Y ( ) ) ; return delegate . inverse Transform ( translated Back ) ; }
public void list ( Print Stream out , int indent ) { for ( int i = NUM ; i < indent ; i ++ ) { out . print ( STRING ) ; } out . println ( this ) ; }
private void init ( ) { set Title ( STRING ) ; competitive Panel = Competitive Properties Panel . create Competitive Properties Panel ( network Panel , Competitive Props Panel Type . CREATE NETWORK ) ; tab Logic . add ( competitive Panel ) ; layout Panel = new Main Layout Panel ( BOOL , this ) ; layout Panel . set Current Layout ( new Line Layout ( ) ) ; tab Layout . add ( layout Panel ) ; tabbed Pane . add Tab ( STRING , tab Logic ) ; tabbed Pane . add Tab ( STRING , layout Panel ) ; set Content Pane ( tabbed Pane ) ; Action help Action = new Show Help Action ( competitive Panel . get Help Path ( ) ) ; add Button ( new J Button ( help Action ) ) ; }
public static Revocation Status check ( X509 Certificate cert , X509 Certificate issuer Cert , URI responder URI , X509 Certificate responder Cert , Date date ) throws IO Exception , Cert Path Validator Exception { return check ( cert , issuer Cert , responder URI , responder Cert , date , Collections . < Extension > empty List ( ) ) ; }
public static void clear Rect ( Graphics 2 D g , Rectangle rect , Color background ) { if ( background != null ) { g . set Color ( background ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; } else { g . set Composite ( Alpha Composite . get Instance ( Alpha Composite . CLEAR , NUM ) ) ; g . fill Rect ( rect . x , rect . y , rect . width , rect . height ) ; g . set Composite ( Alpha Composite . Src Over ) ; } }
private void load Binary ( Input Stream is ) throws IO Exception { Data Input Stream dis = new Data Input Stream ( is ) ; if ( dis . read Int ( ) != MAGIC ) { throw new Error ( STRING ) ; } if ( dis . read Int ( ) != VERSION ) { throw new Error ( STRING ) ; } int phoneme Table Size = dis . read Int ( ) ; phoneme Table = new Array List ( phoneme Table Size ) ; for ( int i = NUM ; i < phoneme Table Size ; i ++ ) { String phoneme = dis . read UTF ( ) ; phoneme Table . add ( phoneme ) ; } int letter Index Size = dis . read Int ( ) ; letter Index = new Hash Map ( ) ; for ( int i = NUM ; i < letter Index Size ; i ++ ) { char c = dis . read Char ( ) ; int index = dis . read Int ( ) ; letter Index . put ( Character . to String ( c ) , new Integer ( index ) ) ; } int state Machine Size = dis . read Int ( ) ; state Machine = new Object [ state Machine Size ] ; for ( int i = NUM ; i < state Machine Size ; i ++ ) { int type = dis . read Int ( ) ; if ( type == Final State . TYPE ) { state Machine [ i ] = Final State . load Binary ( dis ) ; } else if ( type == Decision State . TYPE ) { state Machine [ i ] = Decision State . load Binary ( dis ) ; } else { throw new Error ( STRING ) ; } } }
public static File rename File ( File file , String new Name ) { String absolute Path = file . get Absolute Path ( ) ; String file Name = file . get Name ( ) ; String new Absolute Path = absolute Path . substring ( NUM , absolute Path . last Index Of ( file Name ) ) + new Name ; return new File ( new Absolute Path ) ; }
private double deviation ( double [ ] delta , double [ ] [ ] beta ) { final double a = square Sum ( delta ) ; final double b = square Sum ( transpose Times ( beta , delta ) ) ; return ( a > b ) ? Math . sqrt ( a - b ) : NUM ; }
private Json Writer open ( Json Scope empty , String open Bracket ) throws IO Exception { before Value ( BOOL ) ; stack . add ( empty ) ; out . write ( open Bracket ) ; return this ; }
protected double [ ] calculate Bar L 0 L 1 ( double value ) { double lclip = get Lower Clip ( ) ; double uclip = get Upper Clip ( ) ; double bar Low = Math . min ( this . base , value ) ; double bar High = Math . max ( this . base , value ) ; if ( bar High < lclip ) { return null ; } if ( bar Low > uclip ) { return null ; } bar Low = Math . max ( bar Low , lclip ) ; bar High = Math . min ( bar High , uclip ) ; return new double [ ] { bar Low , bar High } ; }
private static Properties load Properties ( ) { Properties properties = new Properties ( ) ; File file = new File ( STRING ) ; File Input Stream fis = null ; try { if ( file . exists ( ) ) { fis = new File Input Stream ( file ) ; properties . load ( fis ) ; } } catch ( Exception e ) { LOGGER . error ( e , e . get Message ( ) ) ; } finally { if ( null != fis ) { try { fis . close ( ) ; } catch ( IO Exception e ) { LOGGER . error ( e , e . get Message ( ) ) ; } } } return properties ; }
private void assert Zip And Unzip Of Directory Matches Original ( File source Dir ) throws IO Exception { File [ ] source Files = source Dir . list Files ( ) ; Arrays . sort ( source Files ) ; File zip File = create Zip File Handle ( ) ; Zip Files . zip Directory ( source Dir , zip File ) ; File output Dir = Files . create Temp Dir ( ) ; Zip Files . unzip File ( zip File , output Dir ) ; File [ ] output Files = output Dir . list Files ( ) ; Arrays . sort ( output Files ) ; assert That ( output Files , array With Size ( source Files . length ) ) ; for ( int i = NUM ; i < source Files . length ; i ++ ) { compare File Contents ( source Files [ i ] , output Files [ i ] ) ; } remove Recursive ( output Dir . to Path ( ) ) ; assert True ( zip File . delete ( ) ) ; }
public static void to Do ( @ Scope int scope , String tag ) { List < Long > tag Seen List = tag Last Seen Map . get ( tag ) ; if ( tag Seen List . is Empty ( ) ) { to Do Set . put ( tag ) ; return ; } Long tag Last Seen = tag Seen List . get ( tag Seen List . size ( ) - NUM ) ; if ( scope == THIS APP VERSION && tag Last Seen <= last App Updated Time ) { to Do Set . put ( tag ) ; } }
public void show Badge At Index ( int item Index , int badge Text , @ Color Int int badge Color ) { if ( item Index < NUM || item Index > space Items . size ( ) ) { throw Array Index Out Of Bounds Exception ( item Index ) ; } else { Relative Layout badge View = badge List . get ( item Index ) ; if ( Build . VERSION . SDK INT >= Build . VERSION CODES . JELLY BEAN ) { badge View . set Background ( Badge Helper . make Shape Drawable ( badge Color ) ) ; } else { badge View . set Background Drawable ( Badge Helper . make Shape Drawable ( badge Color ) ) ; } Badge Item badge Item = new Badge Item ( item Index , badge Text , badge Color ) ; Badge Helper . show Badge ( badge View , badge Item , should Show Badge With Nine Plus ) ; badge Save Instance Hash Map . put ( item Index , badge Item ) ; } }
public static void touch Last Database Update Time ( ) { last Database Update Time = System . current Time Millis ( ) ; }
public Catalog Entry ( int type , Vector args ) throws Catalog Exception { try { Integer i Args = ( Integer ) entry Args . get ( type ) ; if ( i Args . int Value ( ) != args . size ( ) ) { throw new Catalog Exception ( Catalog Exception . INVALID ENTRY ) ; } } catch ( Array Index Out Of Bounds Exception e ) { throw new Catalog Exception ( Catalog Exception . INVALID ENTRY TYPE ) ; } entry Type = type ; this . args = args ; }
@ Override public void wait For GC ( ) { boolean all Waiting ; synchronized ( count ) { mutators Blocked ++ ; all Waiting = all Waiting For GC ( ) ; } wait For GC ( all Waiting , BOOL ) ; synchronized ( count ) { mutators Blocked -- ; } }
public void push ( final int a ) { if ( pointer >= stack . length ) { final int [ ] new Stack = new int [ ( int ) ( stack . length * NUM ) ] ; System . arraycopy ( stack , NUM , new Stack , NUM , stack . length ) ; stack = new Stack ; } stack [ pointer ] = a ; pointer ++ ; }
public Gossip Service ( String cluster , String ip Address , int port , String id , List < Gossip Member > gossip Members , Gossip Settings settings , Gossip Listener listener ) throws Interrupted Exception , Unknown Host Exception { gossip Manager = new Random Gossip Manager ( cluster , ip Address , port , id , settings , gossip Members , listener ) ; }
public Wildcard Pattern ( String pattern , boolean is Case Sensitive , String delimiters ) { this ( pattern , is Case Sensitive , BOOL , delimiters ) ; }
public int hash Code ( ) { int hash = type . hash Code ( ) ; if ( name != null ) hash ^= name . hash Code ( ) ; if ( actions != null ) hash ^= actions . hash Code ( ) ; return hash ; }
public AM Service Profile Model Impl ( Http Servlet Request req , String service Name , Map map ) throws AM Console Exception { super ( req , map ) ; this . service Name = service Name ; try { xml Builder = new Property XML Builder ( service Name , get Display Schema Types ( ) , this ) ; if ( service Name . equals ( ADMIN CONSOLE SERVICE ) && Service Manager . is Realm Enabled ( ) ) { AM View Config config = AM View Config . get Instance ( ) ; xml Builder . discard Attribute ( config . get Realm Enable Hidden Console Attr Names ( ) ) ; } } catch ( SMS Exception e ) { throw new AM Console Exception ( get Error String ( e ) ) ; } catch ( SSO Exception e ) { throw new AM Console Exception ( get Error String ( e ) ) ; } }
public Polynomial Function add ( final Polynomial Function p ) { final int low Length = Fast Math . min ( coefficients . length , p . coefficients . length ) ; final int high Length = Fast Math . max ( coefficients . length , p . coefficients . length ) ; double [ ] new Coefficients = new double [ high Length ] ; for ( int i = NUM ; i < low Length ; ++ i ) { new Coefficients [ i ] = coefficients [ i ] + p . coefficients [ i ] ; } System . arraycopy ( ( coefficients . length < p . coefficients . length ) ? p . coefficients : coefficients , low Length , new Coefficients , low Length , high Length - low Length ) ; return new Polynomial Function ( new Coefficients ) ; }
public static int convert To Color Int ( String argb ) throws Number Format Exception { if ( argb . starts With ( STRING ) ) { argb = argb . replace ( STRING , STRING ) ; } int alpha = - NUM , red = - NUM , green = - NUM , blue = - NUM ; if ( argb . length ( ) == NUM ) { alpha = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; red = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; green = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; blue = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; } else if ( argb . length ( ) == NUM ) { alpha = NUM ; red = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; green = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; blue = Integer . parse Int ( argb . substring ( NUM , NUM ) , NUM ) ; } return Color . argb ( alpha , red , green , blue ) ; }
@ Override public void on Action ( ) { on Action ( Action Type . LOOK ) ; }
public I Binary Tree Node < T > next ( ) { if ( stack . empty ( ) ) { throw new java . util . No Such Element Exception ( STRING ) ; } Moment m = stack . peek ( ) ; advance ( ) ; return m . node ; }
@ Override public void start Element ( String namespace URI , String local Name , String q Name , Attributes atts ) throws SAX Exception { if ( q Name . equals ( KEY TAG ) ) { clear Current Text ( ) ; } else { throw new SAX Exception ( STRING + q Name ) ; } }
public void cancel All ( ) { for ( Future future : runable Map . values ( ) ) { future . cancel ( BOOL ) ; } runable Map . clear ( ) ; shutdown ( ) ; }
@ Override protected void force Delete Attribute At ( int position ) { int index = locate Index ( position ) ; m Num Attributes -- ; if ( ( index >= NUM ) && ( m Indices [ index ] == position ) ) { int [ ] temp Indices = new int [ m Indices . length - NUM ] ; double [ ] temp Values = new double [ m Att Values . length - NUM ] ; System . arraycopy ( m Indices , NUM , temp Indices , NUM , index ) ; System . arraycopy ( m Att Values , NUM , temp Values , NUM , index ) ; for ( int i = index ; i < m Indices . length - NUM ; i ++ ) { temp Indices [ i ] = m Indices [ i + NUM ] - NUM ; temp Values [ i ] = m Att Values [ i + NUM ] ; } m Indices = temp Indices ; m Att Values = temp Values ; } else { int [ ] temp Indices = new int [ m Indices . length ] ; double [ ] temp Values = new double [ m Att Values . length ] ; System . arraycopy ( m Indices , NUM , temp Indices , NUM , index + NUM ) ; System . arraycopy ( m Att Values , NUM , temp Values , NUM , index + NUM ) ; for ( int i = index + NUM ; i < m Indices . length ; i ++ ) { temp Indices [ i ] = m Indices [ i ] - NUM ; temp Values [ i ] = m Att Values [ i ] ; } m Indices = temp Indices ; m Att Values = temp Values ; } }
public void initialize ( Context context , Haptic Feedback Controller haptic Feedback Controller , int initial Hours Of Day , int initial Minutes , boolean is 24 Hour Mode ) { if ( m Time Initialized ) { Log . e ( TAG , STRING ) ; return ; } m Haptic Feedback Controller = haptic Feedback Controller ; m Is 24 Hour Mode = is 24 Hour Mode ; m Hide Am Pm = m Accessibility Manager . is Touch Exploration Enabled ( ) || m Is 24 Hour Mode ; m Circle View . initialize ( context , m Hide Am Pm ) ; m Circle View . invalidate ( ) ; if ( ! m Hide Am Pm ) { m Am Pm Circles View . initialize ( context , initial Hours Of Day < NUM ? AM : PM ) ; m Am Pm Circles View . invalidate ( ) ; } Resources res = context . get Resources ( ) ; int [ ] hours = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int [ ] hours 24 = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; int [ ] minutes = { NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; String [ ] hours Texts = new String [ NUM ] ; String [ ] inner Hours Texts = new String [ NUM ] ; String [ ] minutes Texts = new String [ NUM ] ; for ( int i = NUM ; i < NUM ; i ++ ) { hours Texts [ i ] = Language Utils . get Persian Numbers ( is 24 Hour Mode ? String . format ( STRING , hours 24 [ i ] ) : String . format ( STRING , hours [ i ] ) ) ; inner Hours Texts [ i ] = Language Utils . get Persian Numbers ( String . format ( STRING , hours [ i ] ) ) ; minutes Texts [ i ] = Language Utils . get Persian Numbers ( String . format ( STRING , minutes [ i ] ) ) ; } m Hour Radial Texts View . initialize ( res , hours Texts , ( is 24 Hour Mode ? inner Hours Texts : null ) , m Hide Am Pm , BOOL ) ; m Hour Radial Texts View . set Selection ( is 24 Hour Mode ? initial Hours Of Day : initial Hours Of Day % NUM ) ; m Hour Radial Texts View . invalidate ( ) ; m Minute Radial Texts View . initialize ( res , minutes Texts , null , m Hide Am Pm , BOOL ) ; m Minute Radial Texts View . set Selection ( initial Minutes ) ; m Minute Radial Texts View . invalidate ( ) ; set Value For Item ( HOUR INDEX , initial Hours Of Day ) ; set Value For Item ( MINUTE INDEX , initial Minutes ) ; int hour Degrees = ( initial Hours Of Day % NUM ) * HOUR VALUE TO DEGREES STEP SIZE ; m Hour Radial Selector View . initialize ( context , m Hide Am Pm , is 24 Hour Mode , BOOL , hour Degrees , is Hour Inner Circle ( initial Hours Of Day ) ) ; int minute Degrees = initial Minutes * MINUTE VALUE TO DEGREES STEP SIZE ; m Minute Radial Selector View . initialize ( context , m Hide Am Pm , BOOL , BOOL , minute Degrees , BOOL ) ; m Time Initialized = BOOL ; }
protected void decode Image Data ( ) { int Null Code = - NUM ; int npix = iw * ih ; int available , clear , code mask , code size , end of information , in code , old code , bits , code , count , i , datum , data size , first , top , bi , pi ; if ( ( pixels == null ) || ( pixels . length < npix ) ) { pixels = new byte [ npix ] ; } if ( prefix == null ) prefix = new short [ Max Stack Size ] ; if ( suffix == null ) suffix = new byte [ Max Stack Size ] ; if ( pixel Stack == null ) pixel Stack = new byte [ Max Stack Size + NUM ] ; data size = read ( ) ; clear = NUM << data size ; end of information = clear + NUM ; available = clear + NUM ; old code = Null Code ; code size = data size + NUM ; code mask = ( NUM << code size ) - NUM ; for ( code = NUM ; code < clear ; code ++ ) { prefix [ code ] = NUM ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = NUM ; for ( i = NUM ; i < npix ; ) { if ( top == NUM ) { if ( bits < code size ) { if ( count == NUM ) { count = read Block ( ) ; if ( count <= NUM ) break ; bi = NUM ; } datum += ( block [ bi ] & NUM ) << bits ; bits += NUM ; bi ++ ; count -- ; continue ; } code = datum & code mask ; datum >>= code size ; bits -= code size ; if ( ( code > available ) || ( code == end of information ) ) break ; if ( code == clear ) { code size = data size + NUM ; code mask = ( NUM << code size ) - NUM ; available = clear + NUM ; old code = Null Code ; continue ; } if ( old code == Null Code ) { pixel Stack [ top ++ ] = suffix [ code ] ; old code = code ; first = code ; continue ; } in code = code ; if ( code == available ) { pixel Stack [ top ++ ] = ( byte ) first ; code = old code ; } while ( code > clear ) { pixel Stack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = suffix [ code ] & NUM ; if ( available >= Max Stack Size ) break ; pixel Stack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code mask ) == NUM ) && ( available < Max Stack Size ) ) { code size ++ ; code mask += available ; } old code = in code ; } top -- ; pixels [ pi ++ ] = pixel Stack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { pixels [ i ] = NUM ; } }
public String find Value ( String k ) { if ( k == null ) { for ( int i = nkeys ; -- i >= NUM ; ) if ( keys [ i ] == null ) return values [ i ] ; } else for ( int i = nkeys ; -- i >= NUM ; ) { if ( k . equals Ignore Case ( keys [ i ] ) ) return values [ i ] ; } return null ; }
public boolean cleanup ( ) throws IO Exception { File System file System = File System . get ( config ) ; boolean success = BOOL ; for ( Path file : files ) { success &= file System . delete ( file , BOOL ) ; } return success ; }
public static Annotated Type Mirror remove Prefix ( final Elements elements , final Annotated Type Mirror anno Type ) { Annotated Type Mirror result = anno Type . deep Copy ( BOOL ) ; Set < Annotation Mirror > annos = anno Type . get Annotations ( ) ; for ( Annotation Mirror anno : annos ) { Annotation Mirror cleaned Mirror = remove Prefix ( elements , anno ) ; if ( cleaned Mirror != null ) { result . add Annotation ( cleaned Mirror ) ; } else { result . add Annotation ( anno ) ; } } return result ; }
public static Date string To Date ( String strdate , @ Suppress Warnings ( STRING ) String format ) { Date date = null ; Simple Date Format formatter = new Simple Date Format ( format ) ; try { date = formatter . parse ( strdate ) ; } catch ( Parse Exception e ) { e . print Stack Trace ( ) ; } return date ; }
public Grid Tcp Rest Nio Listener ( Ignite Logger log , Grid Tcp Rest Protocol proto , Grid Rest Protocol Handler hnd , Grid Kernal Context ctx ) { memcached Lsnr = new Grid Tcp Memcached Nio Listener ( log , hnd , ctx ) ; this . log = log ; this . proto = proto ; this . hnd = hnd ; }
protected void monitor ( long millis Time Stamp , List < Resource Instance > resource Instances ) { monitor Statistic Ids ( millis Time Stamp , resource Instances ) ; }
public static String detect Imdb Id ( String text ) { String imdb = STRING ; if ( text != null && ! text . is Empty ( ) ) { imdb = Strg Utils . substr ( text , STRING ) ; if ( imdb . is Empty ( ) ) { imdb = Strg Utils . substr ( text , STRING ) ; if ( ! imdb . is Empty ( ) ) { imdb = STRING + imdb ; } } } return imdb ; }
public void on Settings ( View v ) { if ( s Go Coder SDK == null ) return ; WZ Media Config configs [ ] = ( mWZ Camera View != null ? get Video Configs ( mWZ Camera View ) : new WZ Media Config [ NUM ] ) ; WZ Profile Level avc Profile Levels [ ] = WZ Encoder API . get Profile Levels ( ) ; if ( avc Profile Levels . length > NUM ) Arrays . sort ( avc Profile Levels ) ; Intent intent = new Intent ( this , Config Prefs Activity . class ) ; intent . put Extra ( Config Prefs . PREFS TYPE , Config Prefs . ALL PREFS ) ; intent . put Extra ( Config Prefs . VIDEO CONFIGS , configs ) ; intent . put Extra ( Config Prefs . H264 PROFILE LEVELS , avc Profile Levels ) ; start Activity ( intent ) ; }
private void write ( Coordinate [ ] coords , Writer writer , int level ) throws IO Exception { start Line ( level , writer ) ; start Geom Tag ( GML Constants . GML COORDINATES , null , writer ) ; int dim = NUM ; if ( coords . length > NUM ) { if ( ! ( Double . is Na N ( coords [ NUM ] . z ) ) ) dim = NUM ; } boolean is New Line = BOOL ; for ( int i = NUM ; i < coords . length ; i ++ ) { if ( is New Line ) { start Line ( level + NUM , writer ) ; is New Line = BOOL ; } if ( dim == NUM ) { writer . write ( STRING + coords [ i ] . x ) ; writer . write ( coordinate Separator ) ; writer . write ( STRING + coords [ i ] . y ) ; } else if ( dim == NUM ) { writer . write ( STRING + coords [ i ] . x ) ; writer . write ( coordinate Separator ) ; writer . write ( STRING + coords [ i ] . y ) ; writer . write ( coordinate Separator ) ; writer . write ( STRING + coords [ i ] . z ) ; } writer . write ( tuple Separator ) ; if ( ( i + NUM ) % max Coordinates Per Line == NUM && i < coords . length - NUM ) { writer . write ( STRING ) ; is New Line = BOOL ; } } if ( ! is New Line ) writer . write ( STRING ) ; start Line ( level , writer ) ; end Geom Tag ( GML Constants . GML COORDINATES , writer ) ; }
private static boolean is Intended Exception ( Exception e , Class < ? > clazz ) { final String message = e . get Message ( ) ; return ( ! Text Utils . is Empty ( message ) && message . starts With ( clazz . get Name ( ) ) ) ; }
public static void swap Pivot ( Matrix source , long diag , Matrix s , Matrix t ) { long swap Row = diag ; long swap Col = diag ; double max Value = Math . abs ( source . get As Double ( diag , diag ) ) ; long rows = source . get Row Count ( ) ; long cols = source . get Column Count ( ) ; double abs = NUM ; for ( long row = diag ; row < rows ; row ++ ) { for ( long col = diag ; col < cols ; col ++ ) { abs = Math . abs ( source . get As Double ( row , col ) ) ; if ( abs > max Value ) { max Value = abs ; swap Row = row ; swap Col = col ; } } } if ( swap Row != diag ) { swap Rows ( source , swap Row , diag ) ; swap Rows ( t , swap Row , diag ) ; } if ( swap Col != diag ) { swap Cols ( source , swap Col , diag ) ; swap Cols ( s , swap Col , diag ) ; } }
private boolean can Access Clipboard ( ) { Security Manager sm = System . get Security Manager ( ) ; if ( sm == null ) return BOOL ; try { sm . check Permission ( Security Constants . AWT . ACCESS CLIPBOARD PERMISSION ) ; return BOOL ; } catch ( Security Exception e ) { } return BOOL ; }
public Job create Job From Activiti Xml ( String activiti Xml , List < Parameter > parameters ) throws Exception { job Definition Service Test Helper . create Job Definition For Activiti Xml ( activiti Xml ) ; return job Service . create And Start Job ( create Job Create Request ( Abstract Service Test . TEST ACTIVITI NAMESPACE CD , Abstract Service Test . TEST ACTIVITI JOB NAME , parameters ) ) ; }
protected Set < File > retrieve Matching Files ( File root Dir , String pattern ) throws IO Exception { if ( ! root Dir . exists ( ) ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + root Dir . get Absolute Path ( ) + STRING ) ; } return Collections . empty Set ( ) ; } if ( ! root Dir . is Directory ( ) ) { if ( logger . is Warn Enabled ( ) ) { logger . warn ( STRING + root Dir . get Absolute Path ( ) + STRING ) ; } return Collections . empty Set ( ) ; } if ( ! root Dir . can Read ( ) ) { if ( logger . is Warn Enabled ( ) ) { logger . warn ( STRING + root Dir . get Absolute Path ( ) + STRING ) ; } return Collections . empty Set ( ) ; } String full Pattern = String Utils . replace ( root Dir . get Absolute Path ( ) , File . separator , STRING ) ; if ( ! pattern . starts With ( STRING ) ) { full Pattern += STRING ; } full Pattern = full Pattern + String Utils . replace ( pattern , File . separator , STRING ) ; Set < File > result = new Linked Hash Set < File > ( NUM ) ; do Retrieve Matching Files ( full Pattern , root Dir , result ) ; return result ; }
private String as Reg Pattern ( String string ) { String Buffer out = new String Buffer ( string . length ( ) ) ; for ( int i = NUM , length = string . length ( ) ; i < length ; i ++ ) { char ch = string . char At ( i ) ; if ( ch == STRING ) { out . append ( STRING ) ; } else if ( ch == STRING ) { out . append ( STRING ) ; } else { out . append ( ch ) ; } } return out . to String ( ) ; }
public static void main ( String [ ] args ) { java . net . URL input 100 = Class Loader . get System Resource ( filename data 100 + STRING ) ; java . net . URL input 200 = Class Loader . get System Resource ( filename data 200 + STRING ) ; log . info ( STRING ) ; sg 100 = Spatial Grid . read From File ( input 100 . get File ( ) ) ; sg 200 = Spatial Grid . read From File ( input 200 . get File ( ) ) ; try { out = new File Writer ( output File ) ; out . write ( STRING ) ; out . write ( STRING ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING + filename data 200 + STRING ) ; test One Method ( Interpolation . BILINEAR , Double . Na N ) ; test One Method ( Interpolation . BICUBIC , Double . Na N ) ; for ( int e = NUM ; e <= NUM ; e ++ ) { test One Method ( Interpolation . INVERSE DISTANCE WEIGHTING , e ) ; } try { out . write ( STRING ) ; out . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } log . info ( STRING ) ; }
public static < K , V > List < Key Value < K , V > > read Key Values ( String topic , Properties consumer Config ) { return read Key Values ( topic , consumer Config , UNLIMITED MESSAGES ) ; }
private static int transform Class Access For Instant Run ( int access ) { Access Right access Right = Access Right . from Node Access ( access ) ; return access Right == Access Right . PACKAGE PRIVATE ? access | Opcodes . ACC PUBLIC : access ; }
public Multi Bot Manager ( Executor Service bot Pool ) { check Not Null ( bot Pool , STRING ) ; this . bot Pool = More Executors . listening Decorator ( bot Pool ) ; this . manager Number = MANAGER COUNT . get And Increment ( ) ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; if ( server == null ) { throw new Invalid Object Exception ( STRING ) ; } else if ( lease == null ) { throw new Invalid Object Exception ( STRING ) ; } }
public void add Line End Cap ( Coordinate p0 , Coordinate p1 ) { Line Segment seg = new Line Segment ( p0 , p1 ) ; Line Segment offset L = new Line Segment ( ) ; compute Offset Segment ( seg , Position . LEFT , distance , offset L ) ; Line Segment offset R = new Line Segment ( ) ; compute Offset Segment ( seg , Position . RIGHT , distance , offset R ) ; double dx = p1 . x - p0 . x ; double dy = p1 . y - p0 . y ; double angle = Math . atan 2 ( dy , dx ) ; switch ( buf Params . get End Cap Style ( ) ) { case Buffer Parameters . CAP ROUND : seg List . add Pt ( offset L . p1 ) ; add Fillet ( p1 , angle + Math . PI / NUM , angle - Math . PI / NUM , CG Algorithms . CLOCKWISE , distance ) ; seg List . add Pt ( offset R . p1 ) ; break ; case Buffer Parameters . CAP FLAT : seg List . add Pt ( offset L . p1 ) ; seg List . add Pt ( offset R . p1 ) ; break ; case Buffer Parameters . CAP SQUARE : Coordinate square Cap Side Offset = new Coordinate ( ) ; square Cap Side Offset . x = Math . abs ( distance ) * Math . cos ( angle ) ; square Cap Side Offset . y = Math . abs ( distance ) * Math . sin ( angle ) ; Coordinate square Cap L Offset = new Coordinate ( offset L . p1 . x + square Cap Side Offset . x , offset L . p1 . y + square Cap Side Offset . y ) ; Coordinate square Cap R Offset = new Coordinate ( offset R . p1 . x + square Cap Side Offset . x , offset R . p1 . y + square Cap Side Offset . y ) ; seg List . add Pt ( square Cap L Offset ) ; seg List . add Pt ( square Cap R Offset ) ; break ; } }
@ Override public E remove ( int location ) { E result ; if ( location < NUM || location >= size ) { throw new Index Out Of Bounds Exception ( STRING + location + STRING + size ) ; } if ( location == NUM ) { result = array [ first Index ] ; array [ first Index ++ ] = null ; } else if ( location == size - NUM ) { int last Index = first Index + size - NUM ; result = array [ last Index ] ; array [ last Index ] = null ; } else { int element Index = first Index + location ; result = array [ element Index ] ; if ( location < size / NUM ) { System . arraycopy ( array , first Index , array , first Index + NUM , location ) ; array [ first Index ++ ] = null ; } else { System . arraycopy ( array , element Index + NUM , array , element Index , size - location - NUM ) ; array [ first Index + size - NUM ] = null ; } } size -- ; if ( size == NUM ) { first Index = NUM ; } mod Count ++ ; return result ; }
private List < Rule > parse Rules ( JSON Array rules ) throws Ade Usage Exception , JSON Exception { if ( rules . length ( ) == NUM ) throw new Ade Usage Exception ( STRING ) ; List < Rule > current Rules = new Array List < Rule > ( ) ; for ( int i = NUM ; i < rules . length ( ) ; i ++ ) { JSON Object rule = rules . get JSON Object ( i ) ; String name = rule . get String ( STRING ) ; String description = rule . get String ( STRING ) ; String membership Rule = rule . get String ( STRING ) ; if ( ! verify String Param ( name , NUM , STRING ) || ( description != null && description . length ( ) > NUM ) || name . equals Ignore Case ( STRING ) || ! verify String Param ( membership Rule , NUM , STRING ) ) { throw new Ade Usage Exception ( STRING ) ; } current Rules . add ( new Rule ( name , membership Rule , description ) ) ; validate Rule Names ( current Rules ) ; } return current Rules ; }
public static final byte [ ] to Octets ( Attribute Type type , String str ) { final byte [ ] s = str . get Bytes ( Standard Charsets . UTF 8 ) ; byte [ ] octets ; if ( s . length > Attribute . MAX ATTRIBUTE VALUE LENGTH ) { octets = new byte [ Attribute . MAX ATTRIBUTE LENGTH ] ; octets [ NUM ] = ( byte ) type . get Type Code ( ) ; octets [ NUM ] = ( byte ) Attribute . MAX ATTRIBUTE LENGTH ; System . arraycopy ( s , NUM , octets , NUM , Attribute . MAX ATTRIBUTE VALUE LENGTH ) ; } else { octets = new byte [ s . length + NUM ] ; octets [ NUM ] = ( byte ) type . get Type Code ( ) ; octets [ NUM ] = ( byte ) ( s . length + NUM ) ; System . arraycopy ( s , NUM , octets , NUM , s . length ) ; } return octets ; }
public float round ( float d , int decimal Place ) { Big Decimal bd = new Big Decimal ( Float . to String ( d ) ) ; bd = bd . set Scale ( decimal Place , Big Decimal . ROUND HALF UP ) ; return bd . float Value ( ) ; }
@ Override public synchronized void flush ( ) throws IO Exception { check Not Closed ( ) ; flush Internal ( ) ; out . flush ( ) ; }
private static void do Copy Directory ( File src Dir , File dest Dir , File Filter filter , boolean preserve File Date , List < String > exclusion List ) throws IO Exception { File [ ] src Files = filter == null ? src Dir . list Files ( ) : src Dir . list Files ( filter ) ; if ( src Files == null ) { throw new IO Exception ( STRING + src Dir ) ; } if ( dest Dir . exists ( ) ) { if ( dest Dir . is Directory ( ) == BOOL ) { throw new IO Exception ( STRING + dest Dir + STRING ) ; } } else { if ( ! dest Dir . mkdirs ( ) && ! dest Dir . is Directory ( ) ) { throw new IO Exception ( STRING + dest Dir + STRING ) ; } } if ( dest Dir . can Write ( ) == BOOL ) { throw new IO Exception ( STRING + dest Dir + STRING ) ; } for ( File src File : src Files ) { File dst File = new File ( dest Dir , src File . get Name ( ) ) ; if ( exclusion List == null || ! exclusion List . contains ( src File . get Canonical Path ( ) ) ) { if ( src File . is Directory ( ) ) { do Copy Directory ( src File , dst File , filter , preserve File Date , exclusion List ) ; } else { do Copy File ( src File , dst File , preserve File Date ) ; } } } if ( preserve File Date ) { dest Dir . set Last Modified ( src Dir . last Modified ( ) ) ; } }
static boolean is Octet String Valid ( String value , int max Length ) { if ( value == null ) return BOOL ; if ( value . length ( ) > max Length ) return BOOL ; return BOOL ; }
private static double [ ] next Point Around Line ( double lat 1 , double lon 1 , double lat 2 , double lon 2 ) { double x1 = lon 1 ; double x2 = lon 2 ; double y1 = lat 1 ; double y2 = lat 2 ; double min X = Math . min ( x1 , x2 ) ; double max X = Math . max ( x1 , x2 ) ; double min Y = Math . min ( y1 , y2 ) ; double max Y = Math . max ( y1 , y2 ) ; if ( min X == max X ) { return new double [ ] { next Latitude Between ( min Y , max Y ) , next Longitude Near ( min X , NUM * ( max Y - min Y ) ) } ; } else if ( min Y == max Y ) { return new double [ ] { next Latitude Near ( min Y , NUM * ( max X - min X ) ) , next Longitude Between ( min X , max X ) } ; } else { double x = next Longitude Between ( min X , max X ) ; double y = ( y1 - y2 ) / ( x1 - x2 ) * ( x - x1 ) + y1 ; if ( Double . is Finite ( y ) == BOOL ) { y = Math . copy Sign ( NUM , x1 ) ; } double delta = ( max Y - min Y ) * NUM ; y = Math . min ( NUM , y ) ; y = Math . max ( - NUM , y ) ; return new double [ ] { next Latitude Near ( y , delta ) , x } ; } }
public void add Clear Graph Data Button ( ) { J Button clear Button = new J Button ( STRING ) ; clear Button . set Action ( Time Series Plot Actions . get Clear Graph Action ( this ) ) ; button Panel . add ( clear Button ) ; }
private static float logistic ( double normalized Value , int min , int max ) { double t = normalized Value * NUM ; double result = ( max * min * Math . exp ( min * t ) ) / ( max + min * Math . exp ( min * t ) ) ; return ( float ) result ; }
private void write Csv File ( String filename , int number Of Lines After Header ) { Buffered Writer bw = IO Utils . get Buffered Writer ( filename ) ; try { for ( int i = NUM ; i < number Of Lines After Header ; i ++ ) { bw . write ( STRING ) ; bw . new Line ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + filename ) ; } finally { try { bw . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; fail ( STRING + filename ) ; } } }
public boolean is Plural ( ) { return type String . contains ( SUFFIX PLURAL ) ; }
public void add Notification ( @ Not Null Notification notification ) { notifications . add ( notification ) ; Notification Container Item item = new Notification Container Item ( notification , resources ) ; item . set Delegate ( this ) ; int index = n Grid . get Row Count ( ) ; n Grid . resize Rows ( index + NUM ) ; n Grid . set Widget ( index , NUM , item ) ; }
public void delete Nfs Datastore ( File Share Rest Rep file System , URI datacenter Id , Datastore datastore ) { String datastore Name = datastore . get Name ( ) ; List < Host System > hosts = get Hosts For Datastore ( datastore ) ; if ( hosts . is Empty ( ) ) { throw new Illegal State Exception ( STRING ) ; } enter Maintenance Mode ( datastore ) ; set Storage IO Control ( datastore , BOOL ) ; for ( Host System host : hosts ) { execute ( new Delete Datastore ( host , datastore ) ) ; } remove Nfs Datastore Tag ( file System , datacenter Id , datastore Name ) ; }
private void check Size ( final int i ) { if ( i >= max size ) { final int old size = max size ; max size += increment size ; if ( max size <= i ) { max size = i + increment size + NUM ; } final int [ ] [ ] temp = items ; items = new int [ max size ] [ NUM ] ; System . arraycopy ( temp , NUM , items , NUM , old size ) ; increment size = increment Size ( increment size ) ; } }
private void forward Media File ( String mime Type , Uri media Uri ) { String reshare Path = STRING + media Uri . get Path ( ) ; Intent share Intent = new Intent ( context , Im Url Activity . class ) ; share Intent . set Action ( Intent . ACTION SEND ) ; share Intent . set Data And Type ( Uri . parse ( reshare Path ) , mime Type ) ; context . start Activity ( share Intent ) ; }
protected void schedule Tasks ( Set < Task Image Container > tasks ) { synchronized ( m Shadow Task Map ) { for ( Task Image Container task : tasks ) { Image Shadow Task shadow Task = m Shadow Task Map . get ( task . m Session ) ; if ( shadow Task == null ) { throw new Illegal State Exception ( STRING ) ; } switch ( task . get Processing Priority ( ) ) { case FAST : m Thread Pool Fast . execute ( new Task Done Wrapper ( this , shadow Task , task ) ) ; break ; case AVERAGE : m Thread Pool Average . execute ( new Task Done Wrapper ( this , shadow Task , task ) ) ; break ; case SLOW : m Thread Pool Slow . execute ( new Task Done Wrapper ( this , shadow Task , task ) ) ; break ; default : m Thread Pool Slow . execute ( new Task Done Wrapper ( this , shadow Task , task ) ) ; break ; } } } }
public static String unquote ( String name ) { if ( ! name . is Empty ( ) && name . char At ( NUM ) == STRING ) { return name . substring ( NUM ) ; } return name ; }
public static void update Quests ( final Player player ) { final Entity Manager entity Mgr = Singleton Repository . get Entity Manager ( ) ; migrate Sum Timed Quest Slot ( player , STRING , STRING ) ; for ( final String quest Slot : player . get Quests ( ) ) { if ( player . has Quest ( quest Slot ) ) { final String item String = player . get Quest ( quest Slot ) ; final String [ ] parts = item String . split ( STRING ) ; final String Builder buffer = new String Builder ( ) ; boolean first = BOOL ; for ( int i = NUM ; i < parts . length ; ++ i ) { final String old Name = parts [ i ] ; String new Name = Update Converter . update Item Name ( old Name ) ; if ( ! new Name . equals ( old Name ) ) { if ( ! entity Mgr . is Creature ( new Name ) && ! entity Mgr . is Item ( new Name ) ) { new Name = old Name ; } } if ( first ) { buffer . append ( new Name ) ; first = BOOL ; } else { buffer . append ( STRING ) ; buffer . append ( new Name ) ; } } player . set Quest ( quest Slot , buffer . to String ( ) ) ; } } fix Kill Quests Slots ( player ) ; fix Daily Monster Quest Slot ( player ) ; fix Maze Quest Slot ( player ) ; }
private static Object report Get ( Object r ) throws Interrupted Exception , Execution Exception { if ( r == null ) throw new Interrupted Exception ( ) ; if ( r instanceof Alt Result ) { Throwable x , cause ; if ( ( x = ( ( Alt Result ) r ) . ex ) == null ) return null ; if ( x instanceof Cancellation Exception ) throw ( Cancellation Exception ) x ; if ( ( x instanceof Completion Exception ) && ( cause = x . get Cause ( ) ) != null ) x = cause ; throw new Execution Exception ( x ) ; } return r ; }
public int write ( final Protein protein , final boolean standalone ) throws IO Exception { check Entry Hierarchy ( ) ; if ( entry Hierarchy != null ) { for ( Protein Xref xref : protein . get Cross References ( ) ) { final Simple Protein simple Protein = Simple Protein . value Of ( protein , xref , entry Hierarchy ) ; if ( simple Protein != null ) { final Simple Hash model = build Model Map ( simple Protein , entry Hierarchy , standalone ) ; Writer writer = null ; try { final Template temp = free Marker Config . get Template ( free Marker Template ) ; check Temp Directory ( temp Directory ) ; if ( ! temp Directory . ends With ( File . separator ) ) { temp Directory = temp Directory + File . separator ; } Url Friendly Id Generator gen = Url Friendly Id Generator . get Instance ( ) ; String url Friendly Id = gen . generate ( xref . get Identifier ( ) ) ; final Path new Result File = Paths . get ( temp Directory + url Friendly Id + STRING ) ; result Files . add ( new Result File ) ; writer = Files . new Buffered Writer ( new Result File , character Set ) ; temp . process ( model , writer ) ; writer . flush ( ) ; } catch ( Template Exception e ) { e . print Stack Trace ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } } } return NUM ; }
public long insert ( String table , String null Column Hack , Content Values values ) { verify Db Is Open ( ) ; String Builder sql = new String Builder ( ) ; sql . append ( STRING ) ; sql . append ( STRING ) ; sql . append ( table ) ; sql . append ( STRING ) ; Object [ ] bind Args = null ; int size = ( values != null && values . size ( ) > NUM ) ? values . size ( ) : NUM ; if ( size > NUM ) { bind Args = new Object [ size ] ; int i = NUM ; for ( String col Name : values . key Set ( ) ) { sql . append ( ( i > NUM ) ? STRING : STRING ) ; sql . append ( col Name ) ; bind Args [ i ++ ] = values . get ( col Name ) ; } sql . append ( STRING ) ; sql . append ( STRING ) ; for ( i = NUM ; i < size ; i ++ ) { sql . append ( ( i > NUM ) ? STRING : STRING ) ; } } else { sql . append ( null Column Hack + STRING ) ; } sql . append ( STRING ) ; return execute Sql ( sql . to String ( ) , bind Args ) ; }
private void merge States ( int row Num , short [ ] new Values , Vector < Integer > rows Being Updated ) { short [ ] old Values = temp State Table . element At ( row Num ) ; boolean is Looping State = looping States . contains ( new Integer ( row Num ) ) ; for ( int i = NUM ; i < old Values . length ; i ++ ) { if ( old Values [ i ] == new Values [ i ] ) { continue ; } else if ( is Looping State && looping States . contains ( new Integer ( old Values [ i ] ) ) ) { if ( new Values [ i ] != NUM ) { if ( old Values [ i ] == NUM ) { clear Looping States = BOOL ; } old Values [ i ] = new Values [ i ] ; } } else if ( old Values [ i ] == NUM ) { old Values [ i ] = new Values [ i ] ; } else if ( i == num Categories ) { old Values [ i ] = ( short ) ( ( new Values [ i ] & ALL FLAGS ) | old Values [ i ] ) ; } else if ( old Values [ i ] != NUM && new Values [ i ] != NUM ) { int combined Row Num = search Merge List ( old Values [ i ] , new Values [ i ] ) ; if ( combined Row Num != NUM ) { old Values [ i ] = ( short ) combined Row Num ; } else { int old Row Num = old Values [ i ] ; int new Row Num = new Values [ i ] ; combined Row Num = temp State Table . size ( ) ; if ( merge List == null ) { merge List = new Vector < > ( ) ; } merge List . add Element ( new int [ ] { old Row Num , new Row Num , combined Row Num } ) ; short [ ] new Row = new short [ num Categories + NUM ] ; short [ ] old Row = temp State Table . element At ( old Row Num ) ; System . arraycopy ( old Row , NUM , new Row , NUM , num Categories + NUM ) ; temp State Table . add Element ( new Row ) ; old Values [ i ] = ( short ) combined Row Num ; if ( ( decision Point List . contains ( new Integer ( old Row Num ) ) || decision Point List . contains ( new Integer ( new Row Num ) ) ) && ! decision Point List . contains ( new Integer ( combined Row Num ) ) ) { decision Point List . add Element ( new Integer ( combined Row Num ) ) ; } if ( ( rows Being Updated . contains ( new Integer ( old Row Num ) ) || rows Being Updated . contains ( new Integer ( new Row Num ) ) ) && ! rows Being Updated . contains ( new Integer ( combined Row Num ) ) ) { decision Point List . add Element ( new Integer ( combined Row Num ) ) ; } for ( int k = NUM ; k < decision Point Stack . size ( ) ; k ++ ) { Vector < Integer > dpl = decision Point Stack . element At ( k ) ; if ( ( dpl . contains ( new Integer ( old Row Num ) ) || dpl . contains ( new Integer ( new Row Num ) ) ) && ! dpl . contains ( new Integer ( combined Row Num ) ) ) { dpl . add Element ( new Integer ( combined Row Num ) ) ; } } merge States ( combined Row Num , temp State Table . element At ( new Values [ i ] ) , rows Being Updated ) ; } } } return ; }
public String Hmm F 0 Generation ( HTS Utt Model um , HMM Data hts Data ) throws Exception { int frame , utt Frame , lf 0 Frame ; int hmm State , k , n , i ; boolean nobound ; HTS Model m ; HTSP Stream lf 0 Pst = null ; boolean voiced [ ] ; Cart Tree Set ms = hts Data . get Cart Tree Set ( ) ; lf 0 Pst = new HTSP Stream ( ms . get Lf 0 Stream ( ) , um . get Lf 0 Frame ( ) , HMM Data . Feature Type . LF 0 , NUM ) ; utt Frame = lf 0 Frame = NUM ; voiced = new boolean [ um . get Total Frame ( ) ] ; for ( i = NUM ; i < um . get Num Utt Model ( ) ; i ++ ) { m = um . get Utt Model ( i ) ; for ( hmm State = NUM ; hmm State < ms . get Num States ( ) ; hmm State ++ ) for ( frame = NUM ; frame < m . get Dur ( hmm State ) ; frame ++ ) { voiced [ utt Frame ] = m . get Voiced ( hmm State ) ; utt Frame ++ ; if ( m . get Voiced ( hmm State ) ) lf 0 Frame ++ ; } } utt Frame = NUM ; lf 0 Frame = NUM ; for ( i = NUM ; i < um . get Num Utt Model ( ) ; i ++ ) { m = um . get Utt Model ( i ) ; for ( hmm State = NUM ; hmm State < ms . get Num States ( ) ; hmm State ++ ) { for ( frame = NUM ; frame < m . get Dur ( hmm State ) ; frame ++ ) { for ( k = NUM ; k < ms . get Lf 0 Stream ( ) ; k ++ ) { int lw = lf 0 Pst . get DW Left Boundary ( k ) ; int rw = lf 0 Pst . get DW Right Boundary ( k ) ; nobound = BOOL ; for ( n = lw ; n <= rw ; n ++ ) if ( ( utt Frame + n ) <= NUM || um . get Total Frame ( ) <= ( utt Frame + n ) ) nobound = BOOL ; else nobound = ( nobound && voiced [ utt Frame + n ] ) ; if ( voiced [ utt Frame ] ) { lf 0 Pst . set Mseq ( lf 0 Frame , k , m . get Lf 0 Mean ( hmm State , k ) ) ; if ( nobound || k == NUM ) lf 0 Pst . set Ivseq ( lf 0 Frame , k , HTS Parameter Generation . finv ( m . get Lf 0 Variance ( hmm State , k ) ) ) ; else lf 0 Pst . set Ivseq ( lf 0 Frame , k , NUM ) ; } } if ( voiced [ utt Frame ] ) lf 0 Frame ++ ; utt Frame ++ ; } } } double f0 s [ ] = new double [ voiced . length ] ; i = NUM ; if ( lf 0 Frame > NUM ) { Log . i ( Mary . LOG , STRING ) ; lf 0 Pst . mlpg ( hts Data , hts Data . get Use GV ( ) ) ; for ( int t = NUM ; t < voiced . length ; t ++ ) { if ( voiced [ t ] ) { f0 s [ t ] = Math . exp ( lf 0 Pst . get Par ( i , NUM ) ) ; i ++ ; } else f0 s [ t ] = NUM ; } } double total Dur ; int total Frames ; String f0 Values = STRING ; int t = NUM ; for ( i = NUM ; i < um . get Num Utt Model ( ) ; i ++ ) { m = um . get Utt Model ( i ) ; f0 Values += m . get Phone Name ( ) + STRING + m . get Total Dur Millisec ( ) + STRING ; total Dur = m . get Total Dur ( ) ; total Frames = NUM ; if ( check Model Voiced ( m , ms . get Num States ( ) ) ) { for ( int j = NUM ; j < ms . get Num States ( ) ; j ++ ) { for ( frame = NUM ; frame < m . get Dur ( j ) ; frame ++ ) { total Frames ++ ; if ( f0 s [ t ] > NUM ) f0 Values += STRING + Integer . to String ( ( int ) ( ( total Frames / total Dur ) * NUM ) ) + STRING + Integer . to String ( ( int ) f0 s [ t ] ) + STRING ; t ++ ; } } } else { t = t + m . get Total Dur ( ) ; f0 Values += STRING ; } f0 Values += STRING ; } return ( f0 Values ) ; }
private void deserialize Query Field ( Query query , Element field ) throws Page Exception , Converter Exception { String name = field . get Attribute ( STRING ) ; Node List list = field . get Child Nodes ( ) ; int len = list . get Length ( ) ; int count = NUM ; for ( int i = NUM ; i < len ; i ++ ) { Node node = list . item ( i ) ; if ( node instanceof Element ) { query . set At ( name , ++ count , deserialize ( ( Element ) node ) ) ; } } }
private RE concat ( RE x , RE y ) { if ( rec == Recursion . RIGHT ) { return x . concat ( y ) ; } else { return y . concat ( x ) ; } }
public void add ( final Object element ) { Set old Selection = new Hash Set ( selection ) ; boolean rv = selection . add ( element ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } old Selection = null ; }
@ Override public void mouse Exited ( Mouse Event evt ) { delegate . mouse Moved ( evt ) ; }
public static void printf ( Locale locale , String format , Object ... args ) { out . printf ( locale , format , args ) ; out . flush ( ) ; }
public void test Sorts Same Attributes ( ) throws Exception { Xpp Dom dom 1 = Xpp Factory . build Dom ( STRING ) ; Xpp Dom dom 2 = Xpp Factory . build Dom ( STRING ) ; assert Equals ( - NUM , comparator . compare ( dom 1 , dom 2 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; assert Equals ( NUM , comparator . compare ( dom 2 , dom 1 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; }
public void add ( Dalv Insn insn ) { insns . add ( insn ) ; update Info ( insn ) ; }
private boolean is Valid State ( String key ) { if ( key == null ) { return BOOL ; } if ( key . equals ( rbean . get String ( STRING ) ) || key . equals ( rbean . get String ( STRING ) ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( key + STRING ) ; } return BOOL ; } for ( int i = NUM ; i < valid Key . length ; i ++ ) { if ( key . equals ( valid Key [ i ] ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( key + STRING ) ; } return BOOL ; } } if ( log . is Debug Enabled ( ) ) { log . debug ( key + STRING ) ; } return BOOL ; }
public static Number add ( Number a , Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return a . double Value ( ) + b . double Value ( ) ; } else { return a . long Value ( ) + b . long Value ( ) ; } }
public Builder optional Attributes ( final String ... name Or OI Ds ) { return optional Attributes ( Arrays . as List ( name Or OI Ds ) ) ; }
private void show Flags Dialog ( ) { int [ ] old Indices = flags List . get Selected Indices ( ) ; String [ ] buttons = { STRING , STRING } ; int result = J Option Pane . show Option Dialog ( tool Window Content , flags List , STRING , J Option Pane . YES NO CANCEL OPTION , J Option Pane . PLAIN MESSAGE , null , buttons , buttons [ NUM ] ) ; if ( result != NUM ) { flags List . set Selected Indices ( old Indices ) ; } else { if ( flags List . get Selected Indices ( ) . length > NUM && flags List . is Selected Index ( NUM ) ) { flags List . remove Selection Interval ( NUM , NUM ) ; } update Flags Text Field ( ) ; } }
private static byte [ ] read Resource ( Resource r ) throws IO Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ NUM ] ; Input Stream is = r . open ( ) ; try { for ( ; ; ) { int cnt = is . read ( buffer ) ; if ( cnt == - NUM ) break ; baos . write ( buffer , NUM , cnt ) ; } } finally { try { is . close ( ) ; } catch ( IO Exception ex ) { } } return baos . to Byte Array ( ) ; }
public < T > Lazy Future Stream < T > from Publisher ( final Publisher < ? extends T > publisher ) { Objects . require Non Null ( publisher ) ; final Seq Subscriber < T > sub = Seq Subscriber . subscriber ( ) ; publisher . subscribe ( sub ) ; return sub . to Future Stream ( this ) ; }
public Protobuf Parser ( Listener < Message Type > handler , Message Type prototype , int max Message Size , int timeout Millis ) { this . handler = handler ; this . prototype = prototype ; this . max Message Size = Math . min ( max Message Size , Integer . MAX VALUE - NUM ) ; set Timeout Enabled ( BOOL ) ; set Socket Timeout ( timeout Millis ) ; }
public Notification Set parse XML ( ) { if ( document == null ) { return null ; } Element notif Set Elem = document . get Document Element ( ) ; Notification Set notification Set = new Notification Set ( ) ; set Notification Set Attributes ( notif Set Elem , notification Set ) ; Node List notifs = notif Set Elem . get Elements By Tag Name ( STRING ) ; if ( notifs == null ) { return notification Set ; } int node Len = notifs . get Length ( ) ; for ( int i = NUM ; i < node Len ; i ++ ) { notification Set . add Notification ( parse Notification Element ( ( Element ) notifs . item ( i ) ) ) ; } return notification Set ; }
public Red Gradient ( int max Count ) { this . max Count = max Count ; factor = max Count / Math . log ( max Count ) ; }
public static void write Histogram ( T Double Double Hash Map map , String key Col , String val Col , String file , boolean descending ) throws IO Exception { Buffered Writer writer = new Buffered Writer ( new File Writer ( file ) ) ; writer . write ( key Col ) ; writer . write ( TAB ) ; writer . write ( val Col ) ; writer . new Line ( ) ; double [ ] keys = map . keys ( ) ; Arrays . sort ( keys ) ; if ( descending ) Array Utils . reverse ( keys ) ; for ( double key : keys ) { writer . write ( String . value Of ( key ) ) ; writer . write ( TAB ) ; writer . write ( String . value Of ( map . get ( key ) ) ) ; writer . new Line ( ) ; } writer . close ( ) ; }
public static < T > Completion Stage < T > dereference ( Completion Stage < ? extends Completion Stage < T > > stage ) { return stage . then Compose ( Function . identity ( ) ) ; }
public static Number plus ( Number left , Character right ) { return Number Number Plus . plus ( left , Integer . value Of ( right ) ) ; }
public static String clip String ( J Component c , Font Metrics fm , String string , int avail Text Width ) { String clip String = STRING ; avail Text Width -= Swing Utilities 2 . string Width ( c , fm , clip String ) ; if ( avail Text Width <= NUM ) { return clip String ; } boolean needs Text Layout ; synchronized ( chars Buffer Lock ) { int string Length = sync Chars Buffer ( string ) ; needs Text Layout = is Complex Layout ( chars Buffer , NUM , string Length ) ; if ( ! needs Text Layout ) { int width = NUM ; for ( int n Chars = NUM ; n Chars < string Length ; n Chars ++ ) { width += fm . char Width ( chars Buffer [ n Chars ] ) ; if ( width > avail Text Width ) { string = string . substring ( NUM , n Chars ) ; break ; } } } } if ( needs Text Layout ) { Attributed String a String = new Attributed String ( string ) ; if ( c != null ) { a String . add Attribute ( Text Attribute . NUMERIC SHAPING , c . get Client Property ( Text Attribute . NUMERIC SHAPING ) ) ; } Line Break Measurer measurer = new Line Break Measurer ( a String . get Iterator ( ) , Break Iterator . get Character Instance ( ) , get Font Render Context ( c , fm ) ) ; string = string . substring ( NUM , measurer . next Offset ( avail Text Width ) ) ; } return string + clip String ; }
public boolean add Element ( Object obj ) { synchronized ( actions ) { if ( allow To Change ) { return actions . add ( obj ) ; } } return BOOL ; }
public static boolean is Cglib Proxy Class ( Class < ? > clazz ) { return ( clazz != null && is Cglib Proxy Class Name ( clazz . get Name ( ) ) ) ; }
@ Override public void reset References ( ) { refs . clear ( ) ; }
public void add Slide ( @ Non Null Fragment fragment , @ Color Int int color ) { fragments . add ( fragment ) ; add Background Color ( color ) ; pager Adapter . notify Data Set Changed ( ) ; }
public static Float Buffer create Float Buffer ( float [ ] coords ) { Byte Buffer bb = Byte Buffer . allocate Direct ( coords . length * SIZEOF FLOAT ) ; bb . order ( Byte Order . native Order ( ) ) ; Float Buffer fb = bb . as Float Buffer ( ) ; fb . put ( coords ) ; fb . position ( NUM ) ; return fb ; }
protected void subscribe ( ) throws IO Exception { if ( sample Client Sub == null ) { try { sample Client Sub = new Sample Async Wait ( url , client Id Sub , clean Session , quiet Mode , user Name , password ) ; } catch ( Mqtt Exception e ) { e . print Stack Trace ( ) ; } } if ( sample Client Sub != null ) { String topic = STRING ; int qos = NUM ; try { sample Client Sub . subscribe ( topic , qos ) ; } catch ( Throwable e ) { e . print Stack Trace ( ) ; } } }
private void wm Sub Band ( Image img , double [ ] wm , int n , double a , double threshold ) { for ( int i = NUM ; i < img . get Width ( ) * img . get Height ( ) ; i ++ ) { if ( Math . abs ( img . get Data ( ) [ i ] ) > threshold ) { img . get Data ( ) [ i ] += ( a * Math . abs ( img . get Data ( ) [ i ] ) * wm [ i % n ] ) ; } } }
public synchronized void store Resource Config ( String cluster Name , Resource Type resource Type , Tungsten Properties resource Props ) throws Configuration Exception { if ( get Cluster Home ( ) == null ) { throw new Configuration Exception ( STRING + get Module Properties File Name ( Configuration Constants . TR PROPERTIES , get Cluster Home ( ) ) ) ; } String resource Dir = get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ; File resources = new File ( resource Dir ) ; if ( ! resources . is Directory ( ) ) { if ( resources . mkdirs ( ) ) { logger . info ( String . format ( STRING , resource Dir ) ) ; } else { String msg = String . format ( STRING , get Resource Config Dir Name ( get Cluster Home ( ) , cluster Name , resource Type ) ) ; logger . error ( msg ) ; throw new Configuration Exception ( msg ) ; } } String out File Name = resources . get Absolute Path ( ) + File . separator + resource Props . get String ( STRING ) + STRING ; store ( resource Props , out File Name ) ; }
private String process Scanned Files ( final String path , final String file Name ) throws Exception { if ( ! is Error ) { if ( scan Mode == Scan Mode Constants . SCAN MODE FILE ) { if ( ( temp Files != null ) && ! temp Files . is Empty ( ) ) { File file = ( File ) temp Files . get ( NUM ) ; File new File = new File ( path , this . prefix ) ; if ( new File . exists ( ) ) { new File . delete ( ) ; } file . rename To ( new File ) ; clear Temp Files ( ) ; return file Name ; } else { return null ; } } else if ( ( scan Mode == Scan Mode Constants . SCAN MODE NATIVE ) || ( scan Mode == Scan Mode Constants . SCAN MODE MEMORY ) ) { if ( ( temp Files != null ) && ! temp Files . is Empty ( ) ) { File new File = new File ( path , this . prefix ) ; if ( new File . exists ( ) ) { new File . delete ( ) ; } File Output Stream fos = null ; Document document = null ; try { fos = new File Output Stream ( new File ) ; document = new Document ( ) ; Pdf Writer . get Instance ( document , fos ) ; document . open ( ) ; File file Properties = ( File ) temp Files . get ( NUM ) ; Image image Properties = Image . get Instance ( file Properties . get Path ( ) ) ; document . set Page Size ( image Properties ) ; document . set Margins ( NUM , NUM , NUM , NUM ) ; File file = null ; Image image = null ; Iterator it = temp Files . iterator ( ) ; while ( it . has Next ( ) ) { file = ( File ) it . next ( ) ; document . new Page ( ) ; image = Image . get Instance ( file . get Path ( ) ) ; document . add ( image ) ; } } catch ( Exception e ) { throw e ; } finally { if ( document != null ) { document . close ( ) ; } if ( fos != null ) { fos . close ( ) ; } } clear Temp Files ( ) ; return new File . get Path ( ) ; } else { return null ; } } } else { clear Temp Files ( ) ; } return null ; }
private void start File Based Merge ( ) throws Carbon Sort Key And Group By Exception { try { data Sorter And Writer Executor Service . shutdown ( ) ; data Sorter And Writer Executor Service . await Termination ( NUM , Time Unit . DAYS ) ; } catch ( Interrupted Exception e ) { throw new Carbon Sort Key And Group By Exception ( STRING , e ) ; } }
public static Timestamp string To Time Stamp ( String date Time String , String date Time Format , Time Zone tz , Locale locale ) throws Parse Exception { Date Format date Format = to Date Time Format ( date Time Format , tz , locale ) ; Date parsed Date = date Format . parse ( date Time String ) ; return new Timestamp ( parsed Date . get Time ( ) ) ; }
public static J Component add Spring ( Container target ) { J Component spring = new Spring ( ) ; target . add ( spring , S Layout . EXPAND AXIAL ) ; return spring ; }
private void serialize Class ( Class clazz , Map < String , List < String > > class Fields ) throws Runtime Exception { File current = new File ( get Current Directory ( ) ) ; if ( ! current . exists ( ) || ! current . is Directory ( ) ) { throw new Illegal State Exception ( STRING + current . get Absolute Path ( ) + STRING + STRING + STRING ) ; } try { Field field = clazz . get Declared Field ( STRING ) ; int modifiers = field . get Modifiers ( ) ; boolean static = Modifier . is Static ( modifiers ) ; boolean final = Modifier . is Final ( modifiers ) ; field . set Accessible ( BOOL ) ; if ( ! static || ! final || ! ( NUM == field . get Long ( null ) ) ) { throw new Runtime Exception ( STRING + clazz + STRING + STRING ) ; } int num Fields = get Num Non Serial Version UID Fields ( clazz ) ; if ( num Fields > NUM ) { Method method = clazz . get Method ( STRING ) ; Object object = method . invoke ( null ) ; File file = new File ( current , clazz . get Name ( ) + STRING ) ; boolean created = file . create New File ( ) ; File Output Stream out = new File Output Stream ( file ) ; Object Output Stream obj Out = new Object Output Stream ( out ) ; obj Out . write Object ( object ) ; out . close ( ) ; } Object Stream Class object Stream Class = Object Stream Class . lookup ( clazz ) ; String class Name = object Stream Class . get Name ( ) ; Object Stream Field [ ] fields = object Stream Class . get Fields ( ) ; @ Suppress Warnings ( STRING ) List < String > field List = new Array List < > ( ) ; for ( Object Stream Field object Stream Field : fields ) { String field Name = object Stream Field . get Name ( ) ; field List . add ( field Name ) ; } class Fields . put ( class Name , field List ) ; } catch ( No Such Field Exception e ) { throw new Runtime Exception ( ( STRING + STRING + clazz + STRING + STRING ) ) ; } catch ( No Such Method Exception e ) { } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( STRING + STRING + clazz + STRING , e ) ; } catch ( Invocation Target Exception e ) { throw new Runtime Exception ( STRING + STRING + clazz + STRING , e ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STRING + STRING + get Current Directory ( ) + STRING + clazz + STRING , e ) ; } }
protected static Pair < String , String > asr Immediate ( final long offset , final I Translation Environment environment , final List < Reil Instruction > instructions , final String register Node Value , final String immediate Node Value ) { long base Offset = offset ; final String shifter Operand = environment . get Next Variable String ( ) ; final String shifter Carry Out = environment . get Next Variable String ( ) ; if ( immediate Node Value . equals ( STRING ) ) { final String tmp Var 1 = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value , word Size , thirty One Set , byte Size , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , byte Size , tmp Var 1 , byte Size , one Set , byte Size , shifter Carry Out ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , byte Size , shifter Carry Out , byte Size , String . value Of ( NUM ) , d Word Size , shifter Operand ) ) ; return new Pair < String , String > ( shifter Operand , shifter Carry Out ) ; } else { final String tmp Var 1 = environment . get Next Variable String ( ) ; final String tmp Var 2 = environment . get Next Variable String ( ) ; final String tmp Var 3 = environment . get Next Variable String ( ) ; final String tmp Var 4 = environment . get Next Variable String ( ) ; final String tmp Var 5 = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create Add ( base Offset ++ , d Word Size , register Node Value , d Word Size , bit Mask Highest Bit Set , q Word Size , tmp Var 1 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , q Word Size , tmp Var 1 , word Size , STRING + immediate Node Value , d Word Size , tmp Var 2 ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , bit Mask Highest Bit Set , word Size , STRING + immediate Node Value , d Word Size , tmp Var 3 ) ) ; instructions . add ( Reil Helpers . create Sub ( base Offset ++ , d Word Size , tmp Var 2 , d Word Size , tmp Var 3 , q Word Size , tmp Var 4 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , q Word Size , tmp Var 4 , d Word Size , bit Mask All Bits Set , d Word Size , shifter Operand ) ) ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , d Word Size , register Node Value , d Word Size , String . value Of ( - ( Integer . decode ( immediate Node Value ) - NUM ) ) , word Size , tmp Var 5 ) ) ; instructions . add ( Reil Helpers . create And ( base Offset ++ , word Size , tmp Var 5 , byte Size , one Set , byte Size , shifter Carry Out ) ) ; return new Pair < String , String > ( shifter Operand , shifter Carry Out ) ; } }
public static Plain Text plain ( byte text ) { return plain ( Integer . to String ( text ) ) ; }
public static boolean is Yesterday ( Date date ) { Calendar calendar = Calendar . get Instance ( ) ; calendar . add ( Calendar . DAY OF MONTH , - NUM ) ; int now Year = calendar . get ( Calendar . YEAR ) ; int now Month = calendar . get ( Calendar . MONTH ) ; int now Month Day = calendar . get ( Calendar . DAY OF MONTH ) ; calendar . set Time In Millis ( date . get Time ( ) ) ; int then Year = calendar . get ( Calendar . YEAR ) ; int then Month = calendar . get ( Calendar . MONTH ) ; int then Month Day = calendar . get ( Calendar . DAY OF MONTH ) ; return ( then Year == now Year ) && ( then Month == now Month ) && ( then Month Day == now Month Day ) ; }
public void start ( ) { managed Ports . add ( create Port ( ) ) ; fix Names ( ) ; ports . add Observer ( observer , BOOL ) ; }
protected void sprint ( short short Field ) { sprint ( String . value Of ( short Field ) ) ; }
public byte [ ] convert Nv 21 to Jpeg ( byte [ ] data copy , int w , int h , int [ ] strides ) { Log . e ( TAG , STRING ) ; Yuv Image yuv Image = new Yuv Image ( data copy , Image Format . NV 21 , w , h , strides ) ; Byte Array Output Stream post View Bytes = new Byte Array Output Stream ( ) ; yuv Image . compress To Jpeg ( new Rect ( NUM , NUM , w , h ) , NUM , post View Bytes ) ; try { post View Bytes . flush ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } Log . e ( TAG , STRING ) ; return post View Bytes . to Byte Array ( ) ; }
@ Override public Generator < I Line Segment > construct ( String [ ] args ) { return new Hub Generator ( Double . value Of ( args [ NUM ] ) , Double . value Of ( args [ NUM ] ) , Double . value Of ( args [ NUM ] ) ) ; }
private List < Storage Port > allocate Ports ( Storage Ports Allocator allocator , List < Storage Port > candidate Ports , int ports Requested , Network Lite net , URI varray URI ) { Collections . shuffle ( candidate Ports ) ; if ( simulation ) { Storage Ports Allocator . Port Allocation Context context = Storage Ports Allocator . get Port Allocation Context ( net , STRING , allocator . get Context ( ) ) ; for ( Storage Port port : candidate Ports ) { context . add Port ( port , null , null , null , null ) ; } List < Storage Port > ports Allocated = allocator . allocate Ports For Network ( ports Requested , context , BOOL , null , BOOL ) ; allocator . set Context ( context ) ; return ports Allocated ; } else { Map < Storage Port , Long > sport Map = block Scheduler . compute Storage Port Usage ( candidate Ports ) ; List < Storage Port > ports Allocated = allocator . select Storage Ports ( db Client , sport Map , net , varray URI , ports Requested , null , BOOL ) ; return ports Allocated ; } }
public void consume All ( long timeout , Time Unit unit ) throws Timeout Exception { final long stop Time = System . current Time Millis ( ) + unit . to Millis ( timeout ) ; while ( System . current Time Millis ( ) < stop Time ) { Event next Event = queue . poll ( ) ; if ( next Event != null ) { Testing . print ( STRING + next Event ) ; consumed Events . accept ( next Event ) ; } } }
public String hidden To Encoded String ( ) { String Builder buf = new String Builder ( ) ; for ( Iterator < String > i = hidden Bug Category Set . iterator ( ) ; i . has Next ( ) ; ) { buf . append ( i . next ( ) ) ; if ( i . has Next ( ) ) { buf . append ( LISTITEM DELIMITER ) ; } } buf . append ( FIELD DELIMITER ) ; return buf . to String ( ) ; }
public void update Combo Box ( J Combo Box < Schedule > box ) { box . remove All Items ( ) ; box . add Item ( null ) ; for ( Schedule schedule : get Schedules By Name List ( ) ) { box . add Item ( schedule ) ; } }
public static void open Projects ( final J Tree project Tree , final I Navi Project [ ] projects ) { for ( final I Navi Project project : projects ) { C Project Loader . load Project ( project Tree , project ) ; } }
private static boolean compare String Case ( final String val , final int comparator , final String attr ) { final String value = comparator == APPROX ? strip Whitespaces ( val ) : val ; final String attribute = comparator == APPROX ? strip Whitespaces ( attr ) : attr ; switch ( comparator ) { case APPROX : case EQUALS : return RFC 1960 Filter . string Compare ( value . to Char Array ( ) , NUM , attribute . to Char Array ( ) , NUM ) == NUM ; case GREATER : return RFC 1960 Filter . string Compare ( value . to Char Array ( ) , NUM , attribute . to Char Array ( ) , NUM ) <= NUM ; case LESS : return RFC 1960 Filter . string Compare ( value . to Char Array ( ) , NUM , attribute . to Char Array ( ) , NUM ) >= NUM ; default : throw new Illegal State Exception ( STRING ) ; } }
void inline Resources ( final Mail mail , final String html Template , final List < String > mail Template Chain , final String shop Code , final String locale , final String template Name ) throws Messaging Exception , IO Exception { if ( String Utils . is Not Blank ( html Template ) ) { final List < String > resources Ids = get Resources Id ( html Template ) ; if ( ! resources Ids . is Empty ( ) ) { for ( String resource Id : resources Ids ) { final String resource Filename = transform Resource Id To File Name ( resource Id ) ; final byte [ ] content = mail Template Resources Provider . get Resource ( mail Template Chain , shop Code , locale , template Name , resource Filename ) ; final Mail Part part = mail . add Part ( ) ; part . set Resource Id ( resource Id ) ; part . set Filename ( resource Filename ) ; part . set Data ( content ) ; } } } }
public void remove All Numeric Value Changed Listeners ( ) { while ( ! m Numeric Listeners . is Empty ( ) ) { m Numeric Listeners . remove ( NUM ) ; } }
protected Password unlock Entry ( String alias , Key Store State state ) { try { Key Store key Store = state . get Key Store ( ) ; D Get Password d Get Password = new D Get Password ( frame , Message Format . format ( res . get String ( STRING ) , alias ) ) ; d Get Password . set Location Relative To ( frame ) ; d Get Password . set Visible ( BOOL ) ; Password password = d Get Password . get Password ( ) ; if ( password == null ) { return null ; } key Store . get Key ( alias , password . to Char Array ( ) ) ; state . set Entry Password ( alias , password ) ; kse Frame . update Controls ( BOOL ) ; return password ; } catch ( General Security Exception ex ) { String problem Str = Message Format . format ( res . get String ( STRING ) , alias ) ; String [ ] causes = new String [ ] { res . get String ( STRING ) } ; Problem problem = new Problem ( problem Str , causes , ex ) ; D Problem d Problem = new D Problem ( frame , res . get String ( STRING ) , problem ) ; d Problem . set Location Relative To ( frame ) ; d Problem . set Visible ( BOOL ) ; return null ; } }
public long add And Get ( T obj , long delta ) { for ( ; ; ) { long current = get ( obj ) ; long next = current + delta ; if ( compare And Set ( obj , current , next ) ) return next ; } }
private static int [ ] [ ] successors ( final List < Vector 3 D > vertices , final List < int [ ] > facets , final int [ ] [ ] references ) { final int [ ] [ ] successors = new int [ vertices . size ( ) ] [ references [ NUM ] . length ] ; for ( final int [ ] s : successors ) { Arrays . fill ( s , - NUM ) ; } for ( int v = NUM ; v < vertices . size ( ) ; ++ v ) { for ( int k = NUM ; k < successors [ v ] . length && references [ v ] [ k ] >= NUM ; ++ k ) { final int [ ] facet = facets . get ( references [ v ] [ k ] ) ; int i = NUM ; while ( i < facet . length && facet [ i ] != v ) { ++ i ; } successors [ v ] [ k ] = facet [ ( i + NUM ) % facet . length ] ; for ( int l = NUM ; l < k ; ++ l ) { if ( successors [ v ] [ l ] == successors [ v ] [ k ] ) { final Vector 3 D start = vertices . get ( v ) ; final Vector 3 D end = vertices . get ( successors [ v ] [ k ] ) ; throw new Math Illegal Argument Exception ( Localized Geometry Formats . FACET ORIENTATION MISMATCH , start . get X ( ) , start . get Y ( ) , start . get Z ( ) , end . get X ( ) , end . get Y ( ) , end . get Z ( ) ) ; } } } } return successors ; }
private void load Old Update Properties ( ) throws IO Exception { prop = new Properties ( ) ; Input Stream is ; if ( old File . index Of ( STRING ) > NUM ) { URL url = new URL ( old File ) ; is = url . open Stream ( ) ; } else { is = new File Input Stream ( old File ) ; } prop . load ( is ) ; is . close ( ) ; }
protected double [ ] make Distribution ( Instances neighbours , double [ ] distances ) throws Exception { double total = NUM , weight ; double [ ] distribution = new double [ m Num Classes ] ; if ( m Class Type == Attribute . NOMINAL ) { for ( int i = NUM ; i < m Num Classes ; i ++ ) { distribution [ i ] = NUM / Math . max ( NUM , m Train . num Instances ( ) ) ; } total = ( double ) m Num Classes / Math . max ( NUM , m Train . num Instances ( ) ) ; } for ( int i = NUM ; i < neighbours . num Instances ( ) ; i ++ ) { Instance current = neighbours . instance ( i ) ; distances [ i ] = distances [ i ] * distances [ i ] ; distances [ i ] = Math . sqrt ( distances [ i ] / m Num Attributes Used ) ; switch ( m Distance Weighting ) { case WEIGHT INVERSE : weight = NUM / ( distances [ i ] + NUM ) ; break ; case WEIGHT SIMILARITY : weight = NUM - distances [ i ] ; break ; default : weight = NUM ; break ; } weight *= current . weight ( ) ; try { switch ( m Class Type ) { case Attribute . NOMINAL : distribution [ ( int ) current . class Value ( ) ] += weight ; break ; case Attribute . NUMERIC : distribution [ NUM ] += current . class Value ( ) * weight ; break ; } } catch ( Exception ex ) { throw new Error ( STRING ) ; } total += weight ; } if ( total > NUM ) { Utils . normalize ( distribution , total ) ; } return distribution ; }
private boolean is Valid State ( String key ) { if ( key == null ) { return BOOL ; } if ( key . equals ( rbean . get String ( STRING ) ) || key . equals ( rbean . get String ( STRING ) ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( key + STRING ) ; } return BOOL ; } for ( int i = NUM ; i < valid Key . length ; i ++ ) { if ( key . equals ( valid Key [ i ] ) ) { if ( log . is Debug Enabled ( ) ) { log . debug ( key + STRING ) ; } return BOOL ; } } if ( log . is Debug Enabled ( ) ) { log . debug ( key + STRING ) ; } return BOOL ; }
public static String pad ( String string , int min Length ) { String result = string ; int pad = min Length - string . length ( ) ; if ( pad > NUM ) { result = string + pad ( min Length - string . length ( ) ) ; } else if ( pad < NUM ) { result = string . substring ( NUM , min Length ) ; } return result ; }
public static String format Map Old ( String name , Map < String , String > props , String header , boolean was Modified ) { String indent = STRING ; String Builder builder = new String Builder ( ) ; builder . append ( header ) ; builder . append ( String . format ( STRING , name , modified Sign ( was Modified ) ) ) ; builder . append ( STRING ) ; for ( String key : props . key Set ( ) ) { builder . append ( String . format ( STRING , indent , key , props . get ( key ) ) ) ; } builder . append ( String . format ( STRING ) ) ; return builder . to String ( ) ; }
protected double [ ] calculate Bar L 0 L 1 ( double value ) { double lclip = get Lower Clip ( ) ; double uclip = get Upper Clip ( ) ; double bar Low = Math . min ( this . base , value ) ; double bar High = Math . max ( this . base , value ) ; if ( bar High < lclip ) { return null ; } if ( bar Low > uclip ) { return null ; } bar Low = Math . max ( bar Low , lclip ) ; bar High = Math . min ( bar High , uclip ) ; return new double [ ] { bar Low , bar High } ; }
public static Vector 3 ceil ( Vector 3 o ) { return new Vector 3 ( Math . ceil ( o . x ) , Math . ceil ( o . y ) , Math . ceil ( o . z ) ) ; }
public Datagram Packet multicast Receive ( ) throws IO Exception { byte [ ] buf = new byte [ NUM ] ; Datagram Packet dp = new Datagram Packet ( buf , buf . length ) ; multicast Socket . receive ( dp ) ; return dp ; }
@ Override public void flush ( ) throws IO Exception { flush Bytes ( BOOL ) ; }
private long hash ( final float [ ] a , final int l , final int k ) { final int [ ] w = weight [ k ] ; long h = init [ k ] ; int i = l ; while ( i -- != NUM ) h ^= ( h << NUM ) + Float . float To Raw Int Bits ( a [ i ] ) * w [ i % NUMBER OF WEIGHTS ] + ( h > > > NUM ) ; return ( h & NUM ) % m ; }
private static void assert Json Object Equals ( String expected , String actual ) { Object Mapper mapper = new Object Mapper ( ) ; Type Reference < Map < String , Object > > ref = new Type Reference < Map < String , Object > > ( ) { } ; try { Map < String , Object > em = mapper . read Value ( expected , ref ) ; Map < String , Object > am = mapper . read Value ( actual , ref ) ; assert Equals ( em , am ) ; } catch ( IO Exception e ) { throw new Illegal State Exception ( e ) ; } }
public Loco IO Mode List ( ) { mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC INPUT REP , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC INPUT REP , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REP , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REP , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REP , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REP , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REP , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REP , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC INPUT REP , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC INPUT REP , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; mode List . add ( new Loco IO Mode ( NUM , Ln Constants . OPC SW REQ , NUM , NUM , STRING ) ) ; validmodes = new String [ mode List . size ( ) ] ; for ( int i = NUM ; i <= mode List . size ( ) - NUM ; i ++ ) { Loco IO Mode m = mode List . element At ( i ) ; validmodes [ i ] = m . get Full Mode ( ) ; } }
private void handle Connect Error ( int retry , String host , int port , Socket Channel sock Channel , Closed Selector Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) logger . log ( Level . FINE , STRING + host + STRING + port + STRING + config . get Socket Connect Timeout ( ) + STRING + LRMI Utilities . KEEP ALIVE MODE , e ) ; try { sock Channel . close ( ) ; } catch ( Exception ex ) { if ( logger . is Loggable ( Level . FINE ) ) logger . log ( Level . FINE , STRING + host + STRING + port + STRING + config . get Socket Connect Timeout ( ) + STRING + LRMI Utilities . KEEP ALIVE MODE , ex ) ; } if ( retry + NUM == SELECTOR BUG CONNECT RETRY ) throw e ; }
public String sprintf ( ) { Enumeration e = v Fmt . elements ( ) ; Conversion Specification cs = null ; char c = NUM ; String Builder sb = new String Builder ( ) ; while ( e . has More Elements ( ) ) { cs = ( Conversion Specification ) e . next Element ( ) ; c = cs . get Conversion Character ( ) ; if ( c == STRING ) sb . append ( cs . get Literal ( ) ) ; else if ( c == STRING ) sb . append ( STRING ) ; } return sb . to String ( ) ; }
private static Table Info create Table Info ( String table Name , Integer page Number , int flags , Short type , String linked Db Name , String linked Table Name ) { if ( TYPE LINKED TABLE . equals ( type ) ) { return new Linked Table Info ( page Number , table Name , flags , linked Db Name , linked Table Name ) ; } return new Table Info ( page Number , table Name , flags ) ; }
private void update Locations ( ) { log . debug ( STRING ) ; remove Property Change Locations ( ) ; track Check Box List . clear ( ) ; int x = NUM ; p Locations . remove All ( ) ; String type = ( String ) type Combo Box . get Selected Item ( ) ; String load = ( String ) load Combo Box . get Selected Item ( ) ; log . debug ( STRING , type , load ) ; if ( location != null && location Manager . get Location By Name ( location . get Name ( ) ) == null ) { location = null ; } List < Location > locations = location Manager . get Locations By Name List ( ) ; for ( Location location : locations ) { if ( location != null && location != location ) { continue ; } location . add Property Change Listener ( this ) ; J Label location Name = new J Label ( location . get Name ( ) ) ; add Item Left ( p Locations , location Name , NUM , x ++ ) ; List < Track > tracks = location . get Track By Name List ( null ) ; for ( Track track : tracks ) { track . add Property Change Listener ( this ) ; J Check Box cb = new J Check Box ( track . get Name ( ) ) ; cb . set Name ( track . get Id ( ) + STRING + STRING ) ; add Check Box Action ( cb ) ; track Check Box List . add ( cb ) ; cb . set Enabled ( track . accepts Type Name ( type ) ) ; cb . set Selected ( track . accepts Load ( load , type ) ) ; add Item Left ( p Locations , cb , NUM , x ++ ) ; if ( cb . is Enabled ( ) ) { cb . set Tool Tip Text ( Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { load } ) ) ; } else { cb . set Tool Tip Text ( Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { type } ) ) ; } } if ( location . is Staging ( ) ) { J Label ships = new J Label ( location . get Name ( ) + STRING + Bundle . get Message ( STRING ) + STRING ) ; add Item Left ( p Locations , ships , NUM , x ++ ) ; for ( Track track : tracks ) { J Check Box cb = new J Check Box ( track . get Name ( ) ) ; cb . set Name ( track . get Id ( ) + STRING + STRING ) ; add Check Box Action ( cb ) ; track Check Box List . add ( cb ) ; cb . set Enabled ( track . accepts Type Name ( type ) ) ; cb . set Selected ( track . ships Load ( load , type ) ) ; add Item Left ( p Locations , cb , NUM , x ++ ) ; if ( cb . is Enabled ( ) ) { cb . set Tool Tip Text ( Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { load } ) ) ; } else { cb . set Tool Tip Text ( Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { type } ) ) ; } } } } p Locations . revalidate ( ) ; repaint ( ) ; }
public String KNN Tip Text ( ) { return STRING + STRING ; }
public static String [ ] array Split ( String s , char separator Char , boolean trim ) { if ( s == null ) { return null ; } int length = s . length ( ) ; if ( length == NUM ) { return new String [ NUM ] ; } Array List < String > list = New . array List ( ) ; String Builder buff = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i ++ ) { char c = s . char At ( i ) ; if ( c == separator Char ) { String e = buff . to String ( ) ; list . add ( trim ? e . trim ( ) : e ) ; buff . set Length ( NUM ) ; } else if ( c == STRING && i < length - NUM ) { buff . append ( s . char At ( ++ i ) ) ; } else { buff . append ( c ) ; } } String e = buff . to String ( ) ; list . add ( trim ? e . trim ( ) : e ) ; String [ ] array = new String [ list . size ( ) ] ; list . to Array ( array ) ; return array ; }
public double evaluation For Single Instance ( double [ ] dist , Instance instance , boolean store Predictions ) throws Exception { double pred ; if ( m Class Is Nominal ) { pred = Utils . max Index ( dist ) ; if ( dist [ ( int ) pred ] <= NUM ) { pred = Utils . missing Value ( ) ; } update Stats For Classifier ( dist , instance ) ; if ( store Predictions && ! m Discard Predictions ) { if ( m Predictions == null ) { m Predictions = new Array List < Prediction > ( ) ; } m Predictions . add ( new Nominal Prediction ( instance . class Value ( ) , dist , instance . weight ( ) ) ) ; } } else { pred = dist [ NUM ] ; update Stats For Predictor ( pred , instance ) ; if ( store Predictions && ! m Discard Predictions ) { if ( m Predictions == null ) { m Predictions = new Array List < Prediction > ( ) ; } m Predictions . add ( new Numeric Prediction ( instance . class Value ( ) , pred , instance . weight ( ) ) ) ; } } return pred ; }
public void end ( ) throws IO Exception { print ( STRING , null ) ; printer . println ( ) ; }
public static Col Group copy Col Group ( Col Group group ) { Col Group ret = null ; int [ ] col Indices = Arrays . copy Of ( group . get Col Indices ( ) , group . get Num Cols ( ) ) ; if ( group instanceof Col Group Uncompressed ) { Col Group Uncompressed in = ( Col Group Uncompressed ) group ; ret = new Col Group Uncompressed ( col Indices , in . get Num Rows ( ) , in . get Data ( ) ) ; } else if ( group instanceof Col Group RLE ) { Col Group RLE in = ( Col Group RLE ) group ; ret = new Col Group RLE ( col Indices , in . get Num Rows ( ) , in . has Zeros ( ) , in . get Values ( ) , in . get Bitmaps ( ) , in . get Bitmap Offsets ( ) ) ; } else if ( group instanceof Col Group OLE ) { Col Group OLE in = ( Col Group OLE ) group ; ret = new Col Group OLE ( col Indices , in . get Num Rows ( ) , in . has Zeros ( ) , in . get Values ( ) , in . get Bitmaps ( ) , in . get Bitmap Offsets ( ) ) ; } return ret ; }
protected static String normalize Url Ending ( String link ) { if ( link . index Of ( STRING ) > - NUM ) link = link . substring ( NUM , link . index Of ( STRING ) ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; if ( link . ends With ( STRING ) ) link = link . substring ( NUM , link . length ( ) - NUM ) ; return link ; }
@ Override public long skip ( long bytes ) throws IO Exception { if ( closed ) { throw new File Upload Exception ( Item Skipped Exception ) ; } int av = available ( ) ; if ( av == NUM ) { av = make Available ( ) ; if ( av == NUM ) { return NUM ; } } long res = Math . min ( av , bytes ) ; head += res ; return res ; }
@ Override protected void on Draw ( Canvas canvas ) { super . on Draw ( canvas ) ; if ( m Shader == null ) return ; float radius = m Center X <= m Center Y ? m Center X - NUM : m Center Y - NUM ; canvas . rotate ( m Rotate Degrees , m Center X , m Center Y ) ; canvas . draw Circle ( m Center X , m Center Y , radius , m Paint Cover ) ; canvas . rotate ( - m Rotate Degrees , m Center X , m Center Y ) ; canvas . draw Circle ( m Center X , m Center Y , m Button Radius , m Paint Button ) ; if ( m Progress Visibility ) { canvas . draw Arc ( rect F , NUM , NUM , BOOL , m Paint Progress Empty ) ; canvas . draw Arc ( rect F , NUM , calculate Past Progress Degree ( ) , BOOL , m Paint Progress Loaded ) ; String left Time = seconds To Time ( calculate Left Seconds ( ) ) ; m Paint Time . get Text Bounds ( left Time , NUM , left Time . length ( ) , m Rect Text ) ; canvas . draw Text ( left Time , ( float ) ( m Center X * Math . cos ( Math . to Radians ( NUM ) ) ) + m Width / NUM - m Rect Text . width ( ) / NUM , ( float ) ( m Center X * Math . sin ( Math . to Radians ( NUM ) ) ) + m Height / NUM + m Rect Text . height ( ) + NUM , m Paint Time ) ; String passed Time = seconds To Time ( calculate Passed Seconds ( ) ) ; m Paint Time . get Text Bounds ( passed Time , NUM , passed Time . length ( ) , m Rect Text ) ; canvas . draw Text ( passed Time , ( float ) ( m Center X * - Math . cos ( Math . to Radians ( NUM ) ) ) + m Width / NUM - m Rect Text . width ( ) / NUM , ( float ) ( m Center X * Math . sin ( Math . to Radians ( NUM ) ) ) + m Height / NUM + m Rect Text . height ( ) + NUM , m Paint Time ) ; } if ( m First Draw ) { toggle ( ) ; m First Draw = BOOL ; } m Play Pause Drawable . draw ( canvas ) ; }
private void add Callback Method ( String layout File , String callback ) { add To Map Set ( callback Methods , layout File , callback ) ; if ( include Dependencies . contains Key ( layout File ) ) for ( String target : include Dependencies . get ( layout File ) ) add Callback Method ( target , callback ) ; }
protected void ensure Initialized ( ) { if ( ! initialized ) { create Custom View ( ) ; create Filter Toolbar ( ) ; final J Panel tool Bar Panel ; if ( Application Manager . get Application ( ) != null ) { final Action Toolbar pr Actions Toolbar = create Toolbar ( create Actions Group ( ) ) ; final Action Toolbar feedback Actions Toolbar = create Toolbar ( create Feedback Group ( ) ) ; final Action Toolbar options Actions Toolbar = create Toolbar ( create Options Group ( ) ) ; final Flow Layout flow Layout = new Flow Layout ( Flow Layout . LEFT , NUM , JBUI . scale ( NUM ) ) ; final J Panel tool Bar Panel Left = new J Panel ( flow Layout ) ; tool Bar Panel Left . add ( pr Actions Toolbar . get Component ( ) ) ; tool Bar Panel Left . add ( search Filter ) ; add Custom Tools ( tool Bar Panel Left ) ; final Flow Layout flow Layout 2 = new Flow Layout ( Flow Layout . LEFT , NUM , JBUI . scale ( NUM ) ) ; final J Panel tool Bar Panel Middle = new J Panel ( flow Layout 2 ) ; tool Bar Panel Middle . add ( options Actions Toolbar . get Component ( ) ) ; Swing Helper . set Margin ( tool Bar Panel Middle , new Insets ( JBUI . scale ( NUM ) , JBUI . scale ( NUM ) , NUM , NUM ) ) ; tool Bar Panel = new J Panel ( new Border Layout ( ) ) ; tool Bar Panel . add ( tool Bar Panel Left , Border Layout . LINE START ) ; tool Bar Panel . add ( tool Bar Panel Middle , Border Layout . CENTER ) ; tool Bar Panel . add ( feedback Actions Toolbar . get Component ( ) , Border Layout . LINE END ) ; } else { tool Bar Panel = new J Panel ( ) ; } final J Panel status Panel = new J Panel ( new Flow Layout ( Flow Layout . LEFT ) ) ; status Label = new J Label ( ) ; status Link = new Hyperlink ( ) ; status Link . set Action Command ( CMD STATUS LINK ) ; status Panel . add ( status Label ) ; status Panel . add ( status Link ) ; tab Panel = new J Panel ( new Border Layout ( ) ) ; tab Panel . add ( tool Bar Panel , Border Layout . PAGE START ) ; tab Panel . add ( scroll Panel , Border Layout . CENTER ) ; tab Panel . add ( status Panel , Border Layout . PAGE END ) ; this . initialized = BOOL ; } }
@ Override public Shape Tile Box [ ] divide into sections ( double p max section width ) { if ( p max section width <= NUM ) { return new Shape Tile Box [ NUM ] ; } double length = box ur . v x - box ll . v x ; double height = box ur . v y - box ll . v y ; int x count = ( int ) Math . ceil ( length / p max section width ) ; int y count = ( int ) Math . ceil ( height / p max section width ) ; int section length x = ( int ) Math . ceil ( length / x count ) ; int section length y = ( int ) Math . ceil ( height / y count ) ; Shape Tile Box [ ] result = new Shape Tile Box [ x count * y count ] ; int curr index = NUM ; for ( int j = NUM ; j < y count ; ++ j ) { int curr lly = box ll . v y + j * section length y ; int curr ury ; if ( j == ( y count - NUM ) ) { curr ury = box ur . v y ; } else { curr ury = curr lly + section length y ; } for ( int i = NUM ; i < x count ; ++ i ) { int curr llx = box ll . v x + i * section length x ; int curr urx ; if ( i == ( x count - NUM ) ) { curr urx = box ur . v x ; } else { curr urx = curr llx + section length x ; } result [ curr index ] = new Shape Tile Box ( curr llx , curr lly , curr urx , curr ury ) ; ++ curr index ; } } return result ; }
public void increment ( int position , double weight ) { left Label Weights [ position ] += weight ; right Label Weights [ position ] -= weight ; left Weight += weight ; right Weight -= weight ; }
protected String append Suffix ( String file Name , String suffix ) { String new File Name = STRING ; int index Of Dot = file Name . last Index Of ( STRING ) ; if ( index Of Dot != - NUM ) { new File Name = file Name . substring ( NUM , index Of Dot ) ; new File Name += suffix ; new File Name += file Name . substring ( index Of Dot ) ; } else { new File Name = file Name + suffix ; } return new File Name ; }
public void delete ( String name ) throws IO Exception { if ( name . equals Ignore Case ( PERMITTED SUBTREES ) ) { permitted = null ; } else if ( name . equals Ignore Case ( EXCLUDED SUBTREES ) ) { excluded = null ; } else { throw new IO Exception ( STRING + STRING ) ; } encode This ( ) ; }
public static Data Frame normalize ( Data Frame data Frame ) { return normalize ( data Frame , NUM , NUM , Collections . < String > empty List ( ) ) ; }
private static boolean is Excluded ( Spatial s , Spatial exclude ) { if ( s . equals ( exclude ) ) { return BOOL ; } if ( s . get Parent ( ) != null ) { return is Excluded ( s . get Parent ( ) , exclude ) ; } return BOOL ; }
private void add Block Listeners ( Tracker tracker ) { List < O Block > range = tracker . get Range ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + tracker . get Train Name ( ) + STRING + range . size ( ) + STRING ) ; } Iterator < O Block > iter = range . iterator ( ) ; while ( iter . has Next ( ) ) { add Block Listener ( iter . next ( ) , tracker ) ; } }
public static String FTL String Literal Dec ( String s ) throws Parse Exception { int idx = s . index Of ( STRING ) ; if ( idx == - NUM ) { return s ; } int lidx = s . length ( ) - NUM ; int bidx = NUM ; String Builder buf = new String Builder ( lidx ) ; do { buf . append ( s . substring ( bidx , idx ) ) ; if ( idx >= lidx ) { throw new Parse Exception ( STRING , NUM , NUM ) ; } char c = s . char At ( idx + NUM ) ; switch ( c ) { case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : buf . append ( STRING ) ; bidx = idx + NUM ; break ; case STRING : { idx += NUM ; int x = idx ; int y = NUM ; int z = lidx > idx + NUM ? idx + NUM : lidx ; while ( idx <= z ) { char b = s . char At ( idx ) ; if ( b >= STRING && b <= STRING ) { y <<= NUM ; y += b - STRING ; } else if ( b >= STRING && b <= STRING ) { y <<= NUM ; y += b - STRING + NUM ; } else if ( b >= STRING && b <= STRING ) { y <<= NUM ; y += b - STRING + NUM ; } else { break ; } idx ++ ; } if ( x < idx ) { buf . append ( ( char ) y ) ; } else { throw new Parse Exception ( STRING , NUM , NUM ) ; } bidx = idx ; break ; } default : throw new Parse Exception ( STRING + c + STRING , NUM , NUM ) ; } idx = s . index Of ( STRING , bidx ) ; } while ( idx != - NUM ) ; buf . append ( s . substring ( bidx ) ) ; return buf . to String ( ) ; }
private static double make Scale ( Mat img , Size approx Size , boolean maximize , boolean integer Scale ) { Size image Size = img . size ( ) ; double ratio Width = approx Size . width / image Size . width ; double ratio Height = approx Size . height / image Size . height ; double ratio = maximize ? Math . max ( ratio Width , ratio Height ) : Math . min ( ratio Width , ratio Height ) ; if ( Math Util . equal ( ratio , NUM ) ) return NUM ; if ( integer Scale ) { double scale = ( ratio < NUM ) ? NUM / ratio : ratio ; scale = maximize ^ ( ratio < NUM ) ? Math . ceil ( scale ) : Math . floor ( scale ) ; return ( ratio < NUM ) ? NUM / scale : scale ; } else { return ratio ; } }
public static Endpoint Entry lookup ( Endpoint ep ) { synchronized ( endpoint Table ) { Endpoint Entry entry = endpoint Table . get ( ep ) ; if ( entry == null ) { entry = new Endpoint Entry ( ep ) ; endpoint Table . put ( ep , entry ) ; if ( gc Latency Request == null ) { gc Latency Request = GC . request Latency ( gc Interval ) ; } } return entry ; } }
private boolean use Aggregate Function ( String fields ) { String fields Upper = fields . to Upper Case ( ) ; int size = fields Upper . length ( ) ; String Buffer buffer = new String Buffer ( ) ; String token = null ; for ( int i = NUM ; i < size ; i ++ ) { char ch = fields Upper . char At ( i ) ; if ( Character . is Whitespace ( ch ) ) { if ( buffer . length ( ) > NUM ) { token = buffer . to String ( ) ; buffer = new String Buffer ( ) ; } } else { if ( is Operator ( ch ) ) { if ( buffer . length ( ) > NUM ) { token = buffer . to String ( ) ; buffer = new String Buffer ( ) ; } else { token = null ; } if ( ch == STRING && token != null ) { if ( token . equals ( STRING ) || token . equals ( STRING ) || token . equals ( STRING ) || token . equals ( STRING ) || token . equals ( STRING ) ) { return BOOL ; } } } else buffer . append ( ch ) ; } } return BOOL ; }
public static byte [ ] encode ( byte [ ] data ) { Byte Array Output Stream b Out = new Byte Array Output Stream ( ) ; try { encoder . encode ( data , NUM , data . length , b Out ) ; } catch ( Exception e ) { throw new Encoder Exception ( STRING + e . get Message ( ) , e ) ; } return b Out . to Byte Array ( ) ; }
public Section ( Location location , Location location 2 ) { this . min X = Math . min ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . min Y = Math . min ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . min Z = Math . min ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . max X = Math . max ( location . get Block X ( ) , location 2 . get Block X ( ) ) ; this . max Y = Math . max ( location . get Block Y ( ) , location 2 . get Block Y ( ) ) ; this . max Z = Math . max ( location . get Block Z ( ) , location 2 . get Block Z ( ) ) ; this . world = location . get World ( ) ; }
public MAV Link Message ( MAV Link Schema schema , int msg ID , int system ID , int component ID ) { this . schema = schema ; this . definition = schema . get Message Definition ( msg ID ) ; if ( definition == null ) { throw new Runtime Exception ( STRING + msg ID ) ; } this . payload = new byte [ definition . payload Length ] ; this . payload BB = Byte Buffer . wrap ( payload ) ; payload BB . order ( schema . get Byte Order ( ) ) ; this . system ID = system ID ; this . component ID = component ID ; this . msg ID = msg ID ; }
public static double log 10 ( final double x ) { final double hi Prec [ ] = new double [ NUM ] ; final double lores = log ( x , hi Prec ) ; if ( Double . is Infinite ( lores ) ) { return lores ; } final double tmp = hi Prec [ NUM ] * HEX 40000000 ; final double lna = hi Prec [ NUM ] + tmp - tmp ; final double lnb = hi Prec [ NUM ] - lna + hi Prec [ NUM ] ; final double rln 10 a = NUM ; final double rln 10 b = NUM ; return rln 10 b * lnb + rln 10 b * lna + rln 10 a * lnb + rln 10 a * lna ; }
public Script Builder small Num ( int num ) { return small Num ( chunks . size ( ) , num ) ; }
public boolean check shape ( Shape Tile [ ] tiles , int p layer , Net Nos List p net no arr , int p cl class ) { Awtree Shape Search default tree = search tree manager . get default tree ( ) ; for ( int index = NUM ; index < tiles . length ; ++ index ) { Shape Tile curr shape = tiles [ index ] ; if ( ! curr shape . is contained in ( bounding box ) ) return BOOL ; Collection < Awtree Find Entry > obstacles = default tree . find overlap tree entries with clearance ( curr shape , p layer , p net no arr , p cl class ) ; for ( Awtree Find Entry cur entry : obstacles ) { Awtree Object curr ob = cur entry . object ; boolean is obstacle = p net no arr . is obstacle ( curr ob ) ; if ( is obstacle ) return BOOL ; } } return BOOL ; }
public static void draw Image Clip ( Graphics g , Buffered Image image , Image Observer observer ) { Rectangle clip = g . get Clip Bounds ( ) ; if ( clip != null ) { int w = image . get Width ( ) ; int h = image . get Height ( ) ; int x = Math . max ( NUM , Math . min ( clip . x , w ) ) ; int y = Math . max ( NUM , Math . min ( clip . y , h ) ) ; w = Math . min ( clip . width , w - x ) ; h = Math . min ( clip . height , h - y ) ; if ( w > NUM && h > NUM ) { g . draw Image ( image . get Subimage ( x , y , w , h ) , clip . x , clip . y , observer ) ; } } else { g . draw Image ( image , NUM , NUM , observer ) ; } }
public void add Charge ( Attack Action ea ) { pending Charges . add Element ( ea ) ; process Game Event ( new Game New Action Event ( this , ea ) ) ; }
public static String read String ( final JSON Array json Array , final int index , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Array . get String ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT ARRAY , index ) ) ; } String value = null ; if ( ! json Array . is Null ( index ) ) { value = json Array . get String ( index ) ; } return value ; }
public static Web Element find Element Clickable After ( Search Context parent , By by , int timeout In Seconds ) { Preconditions . check Not Null ( parent ) ; Preconditions . check Not Null ( by ) ; try { Web Element Wait wait = new Web Element Wait ( parent , timeout In Seconds ) ; return wait . until ( null ) ; } catch ( Timeout Exception e ) { throw new Timeout Exception ( String . format ( STRING , by , timeout In Seconds ) , e ) ; } }
public final Test Subscriber assert Not Complete ( ) { String prefix = STRING ; boolean passed = BOOL ; if ( done . get Count ( ) != NUM ) { prefix = STRING ; } long c = completions ; if ( c == NUM ) { fail ( prefix , STRING , errors ) ; fail ( STRING ) ; passed = BOOL ; } else if ( c > NUM ) { fail ( prefix , STRING + c , errors ) ; fail ( STRING ) ; passed = BOOL ; } pass ( STRING , passed ) ; return this ; }
@ Target Api ( NUM ) public static boolean is Size Supported V 21 ( String mime Type , boolean secure , int width , int height ) throws Decoder Query Exception { Assertions . check State ( Util . SDK INT >= NUM ) ; Media Codec Info . Video Capabilities video Capabilities = get Video Capabilities V 21 ( mime Type , secure ) ; return video Capabilities != null && video Capabilities . is Size Supported ( width , height ) ; }
private void add Observed File ( String local Path , Account account ) { File file = new File ( local Path ) ; String parent Path = file . get Parent ( ) ; Folder Observer observer = m Folder Observers Map . get ( parent Path ) ; if ( observer == null ) { observer = new Folder Observer ( parent Path , account , get Application Context ( ) ) ; m Folder Observers Map . put ( parent Path , observer ) ; Log OC . d ( TAG , STRING + parent Path + STRING ) ; } observer . start Watching ( file . get Name ( ) ) ; Log OC . d ( TAG , STRING + local Path + STRING ) ; }
public static Property Info [ ] extract Bean Properties Info ( Type type ) { Class < ? > raw Type = get Raw Type ( type ) ; List < Property Info > result = new Array List < Property Info > ( ) ; List < Method > getter Methods = get Getter Methods ( raw Type ) ; List < Method > setter Methods = get Setter Methods ( raw Type ) ; try { for ( Method setter Method : setter Methods ) { String setter Property = get Property For Getter Or Setter Method ( setter Method ) ; for ( Method getter Method : getter Methods ) { String getter Property = get Property For Getter Or Setter Method ( getter Method ) ; if ( getter Property . equals ( setter Property ) ) { Type return Type = getter Method . get Generic Return Type ( ) ; Type property Type = get Property Type ( return Type , type , raw Type ) ; result . add ( new Property Info ( setter Property , property Type , getter Method , setter Method ) ) ; break ; } } } } catch ( Exception e ) { throw new Runtime Exception ( STRING + raw Type . get Canonical Name ( ) , e ) ; } return result . to Array ( new Property Info [ result . size ( ) ] ) ; }
protected < V > V parse Json ( Input Stream stream , Type type , Type list Type ) throws IO Exception { Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( stream , CHARSET UTF 8 ) , buffer Size ) ; if ( list Type == null ) try { return gson . from Json ( reader , type ) ; } catch ( Json Parse Exception jpe ) { L . e ( jpe ) ; IO Exception ioe = new IO Exception ( STRING ) ; ioe . init Cause ( jpe ) ; throw ioe ; } finally { try { reader . close ( ) ; } catch ( IO Exception ignored ) { } } else { Json Reader json Reader = new Json Reader ( reader ) ; try { if ( json Reader . peek ( ) == BEGIN ARRAY ) return gson . from Json ( json Reader , list Type ) ; else return gson . from Json ( json Reader , type ) ; } catch ( Json Parse Exception jpe ) { L . e ( jpe ) ; IO Exception ioe = new IO Exception ( STRING ) ; ioe . init Cause ( jpe ) ; throw ioe ; } finally { try { json Reader . close ( ) ; } catch ( IO Exception ignored ) { } } } }
public void increment Counts ( double [ ] [ ] [ ] counts , List < Transition State > full Viterbi State Seq ) { for ( int i = NUM ; i < full Viterbi State Seq . size ( ) ; ++ i ) { Transition State curr Ts = full Viterbi State Seq . get ( i ) ; Transition State Type curr Type = curr Ts . get Type ( ) ; if ( curr Type == Transition State Type . TMPL ) { int language = curr Ts . get Language Index ( ) ; if ( language >= NUM ) { int lm Char = curr Ts . get Lm Char Index ( ) ; int glyph = glyph Index ( curr Ts . get Glyph Char ( ) ) ; counts [ language ] [ lm Char ] [ glyph ] += NUM ; } } else if ( curr Type == Transition State Type . RMRGN HPHN INIT ) { int language = curr Ts . get Language Index ( ) ; if ( language >= NUM ) { Glyph Char curr Glyph Char = curr Ts . get Glyph Char ( ) ; if ( curr Glyph Char . template Char Index == space Char Index ) { int glyph = glyph Index ( curr Glyph Char ) ; counts [ language ] [ hyphen Char Index ] [ glyph ] += NUM ; } } } } }
public boolean remove Container And Cancel If Necessary ( Image Container container ) { m Containers . remove ( container ) ; if ( m Containers . size ( ) == NUM ) { m Request . cancel ( ) ; return BOOL ; } return BOOL ; }
@ Override public Kernel Density Function copy ( ) { Kernel Density Function copy = new Kernel Density Function ( points ) ; return copy ; }
public static Object serialize And Recover ( Object o ) { try { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; Object Output Stream so = new Object Output Stream ( bos ) ; so . write Object ( o ) ; Byte Array Input Stream bis = new Byte Array Input Stream ( bos . to Byte Array ( ) ) ; Object Input Stream si = new Object Input Stream ( bis ) ; return si . read Object ( ) ; } catch ( IO Exception ioe ) { return null ; } catch ( Class Not Found Exception cnfe ) { return null ; } }
public Update Pod Builder name ( String name ) { Objects . require Non Null ( name ) ; if ( name . index Of ( STRING ) >= NUM ) { throw new Illegal Argument Exception ( name ) ; } name = name ; return this ; }
public void test Add Issuer Ljavax security auth x500 X500 Principal 02 ( ) { X509 CRL Selector selector = new X509 CRL Selector ( ) ; X500 Principal iss 1 = new X500 Principal ( STRING ) ; X500 Principal iss 2 = new X500 Principal ( STRING ) ; CRL crl 1 = new Test CRL ( iss 1 ) ; CRL crl 2 = new Test CRL ( iss 2 ) ; selector . add Issuer ( iss 1 ) ; assert True ( STRING , selector . match ( crl 1 ) ) ; assert False ( STRING , selector . match ( crl 2 ) ) ; selector . add Issuer ( iss 2 ) ; assert True ( STRING , selector . match ( crl 2 ) ) ; }
public void read Dictionary ( String filename , String suffix , Input Stream res ) throws IO Exception { Buffered Reader in = new Buffered Reader ( new Input Stream Reader ( res ) ) ; String line ; while ( ( line = in . read Line ( ) ) != null ) { String [ ] terms = splitter . split ( line ) ; if ( terms . length > max Phrase Length ) continue ; if ( terms . length == NUM ) continue ; Gaz Entry ge = gaz . get ( terms [ NUM ] ) ; if ( ge == null ) { gaz . put ( terms [ NUM ] , new Gaz Entry ( terms , NUM , filename + suffix ) ) ; } else { ge . add Child ( terms , NUM , filename + suffix ) ; } } in . close ( ) ; }
public Resource Match compare ( String request Resource , String target Resource , boolean wildcard Compare ) { int begin Index 1 = NUM ; int end Index 1 = NUM ; int begin Index 2 = NUM ; int end Index 2 = NUM ; int strlen 1 = NUM ; int strlen 2 = NUM ; String substr = null ; if ( ( request Resource == null ) && ( target Resource == null ) ) { return ( Resource Match . EXACT MATCH ) ; } if ( ( ( request Resource == null ) || ( target Resource == null ) ) ) { return ( Resource Match . NO MATCH ) ; } if ( ! case Sensitive ) { request Resource = request Resource . to Lower Case ( ) ; target Resource = target Resource . to Lower Case ( ) ; } request Resource = reverse String ( request Resource ) ; target Resource = reverse String ( target Resource ) ; while ( request Resource . ends With ( delimiter ) ) { int len = request Resource . length ( ) ; request Resource = request Resource . substring ( NUM , len - NUM ) ; } while ( target Resource . ends With ( delimiter ) ) { int len = target Resource . length ( ) ; target Resource = target Resource . substring ( NUM , len - NUM ) ; } strlen 1 = request Resource . length ( ) ; strlen 2 = target Resource . length ( ) ; end Index 2 = target Resource . index Of ( wildcard , begin Index 2 ) ; if ( ( ! wildcard Compare ) || ( end Index 2 == - NUM ) ) { if ( request Resource . equals ( target Resource ) ) { return ( Resource Match . EXACT MATCH ) ; } if ( target Resource . starts With ( request Resource + delimiter ) ) { return ( Resource Match . SUB RESOURCE MATCH ) ; } if ( request Resource . starts With ( target Resource + delimiter ) ) { return ( Resource Match . SUPER RESOURCE MATCH ) ; } return ( Resource Match . NO MATCH ) ; } substr = target Resource . substring ( begin Index 2 , end Index 2 ) ; if ( end Index 2 > begin Index 2 ) { if ( ! ( request Resource . starts With ( substr ) ) ) { if ( substr . starts With ( request Resource + delimiter ) ) { return ( Resource Match . SUB RESOURCE MATCH ) ; } return ( Resource Match . NO MATCH ) ; } } begin Index 1 = begin Index 1 + ( end Index 2 - begin Index 2 ) ; if ( end Index 2 >= strlen 2 - NUM ) { return ( Resource Match . WILDCARD MATCH ) ; } begin Index 2 = end Index 2 + NUM ; while ( ( end Index 2 = target Resource . index Of ( wildcard , begin Index 2 ) ) != - NUM ) { substr = target Resource . substring ( begin Index 2 , end Index 2 ) ; if ( end Index 2 > begin Index 2 ) { if ( ( begin Index 1 = request Resource . index Of ( substr , begin Index 1 ) ) == - NUM ) { return ( Resource Match . SUB RESOURCE MATCH ) ; } } begin Index 1 = begin Index 1 + ( end Index 2 - begin Index 2 ) ; if ( end Index 2 >= strlen 2 - NUM ) { return ( Resource Match . WILDCARD MATCH ) ; } begin Index 2 = end Index 2 + NUM ; } substr = target Resource . substring ( begin Index 2 , strlen 2 ) ; if ( ( end Index 1 = request Resource . last Index Of ( substr , strlen 1 - NUM ) ) == - NUM ) { return ( Resource Match . SUB RESOURCE MATCH ) ; } if ( begin Index 1 > end Index 1 ) { return ( Resource Match . SUB RESOURCE MATCH ) ; } begin Index 1 = end Index 1 ; if ( ( strlen 1 - begin Index 1 ) == ( strlen 2 - begin Index 2 ) ) { return ( Resource Match . WILDCARD MATCH ) ; } begin Index 1 = begin Index 1 + ( strlen 2 - begin Index 2 ) ; substr = request Resource . substring ( begin Index 1 , begin Index 1 + NUM ) ; if ( substr . equals ( delimiter ) ) { return ( Resource Match . SUPER RESOURCE MATCH ) ; } return ( Resource Match . SUB RESOURCE MATCH ) ; }
private Value Graph Vertex find Or Create Vertex ( Register r ) { Value Graph Vertex v = get Vertex ( r ) ; if ( v == null ) { v = new Value Graph Vertex ( r ) ; v . set Label ( r , NUM ) ; graph . add Graph Node ( v ) ; name Map . put ( r , v ) ; } return v ; }
public boolean flush And Refresh ( ) throws IO Exception { message ( STRING ) ; Set < String > completed Merge Files ; synchronized ( finished Merged Files ) { completed Merge Files = Collections . unmodifiable Set ( new Hash Set < > ( finished Merged Files ) ) ; } mgr . maybe Refresh Blocking ( ) ; boolean result = set Current Infos ( completed Merge Files ) ; if ( result ) { message ( STRING + cur Infos . get Version ( ) ) ; finished Merged Files . remove All ( completed Merge Files ) ; message ( STRING + cur Infos . get Version ( ) + STRING + completed Merge Files + STRING + finished Merged Files ) ; } else { message ( STRING + cur Infos . get Version ( ) ) ; } return result ; }
public static boolean is Windows ( ) { String os Name = System . get Property ( STRING ) ; os Name = os Name . to Lower Case ( ) ; return os Name . index Of ( STRING ) != - NUM ; }
@ Suppress Warnings ( STRING ) public static < K extends Throwable > void throw If Instance ( Throwable t , Class < K > clazz ) throws K { if ( ( t != null ) && clazz . is Assignable From ( t . get Class ( ) ) ) { K kt = ( K ) t ; throw kt ; } }
protected void print ( double v ) throws IO Exception { print ( String . value Of ( v ) ) ; }
public Object 2 Double Open Hash Map < int [ ] > support Map ( int support Threshold ) { List < Item Set > item Sets = learn ( ) ; Object 2 Double Open Hash Map < int [ ] > support Map = new Object 2 Double Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { if ( item Set . support >= support Threshold ) { support Map . put ( item Set . items , item Set . support ) ; } } return support Map ; }
public static boolean is All Cap ( String str ) { if ( str . length ( ) <= NUM ) { return BOOL ; } for ( int i = NUM ; i < str . length ( ) ; i ++ ) { if ( ! Character . is Letter ( str . char At ( i ) ) || ! Character . is Upper Case ( str . char At ( i ) ) ) { return BOOL ; } } return BOOL ; }
public static void load ( Class < ? > parent , Class Loader cl ) { try { String full Name = RESOURCE PREFIX + parent . get Name ( ) ; Enumeration < URL > configfiles = cl . get Resources ( full Name ) ; while ( configfiles . has More Elements ( ) ) { URL next Element = configfiles . next Element ( ) ; char [ ] buf = new char [ NUM ] ; try ( Input Stream Reader is = new Input Stream Reader ( next Element . open Stream ( ) , STRING ) ) { int start = NUM , cur = NUM , valid = is . read ( buf , NUM , buf . length ) ; char c ; while ( cur < valid ) { while ( cur < valid && ( c = buf [ cur ] ) != STRING && c != STRING ) { cur ++ ; } if ( cur == valid && is . ready ( ) ) { if ( start > NUM ) { System . arraycopy ( buf , start , buf , NUM , valid - start ) ; valid -= start ; cur -= start ; start = NUM ; } else if ( valid == buf . length ) { throw new IO Exception ( STRING + buf . length + STRING + full Name ) ; } valid = is . read ( buf , valid , buf . length - valid ) ; continue ; } parse Line ( parent , buf , start , cur , next Element ) ; while ( cur < valid && ( ( c = buf [ cur ] ) == STRING || c == STRING ) ) { cur ++ ; } start = cur ; } } catch ( IO Exception x ) { throw new Abort Exception ( STRING , x ) ; } } } catch ( IO Exception x ) { throw new Abort Exception ( STRING , x ) ; } }
protected static int to Digit ( char ch , int index ) throws Decoder Exception { int digit = Character . digit ( ch , NUM ) ; if ( digit == - NUM ) { throw new Decoder Exception ( STRING + ch + STRING + index ) ; } return digit ; }
static void load Library With Class Loader ( String lib Name , Class Loader loader ) { Security Manager sc = System . get Security Manager ( ) ; if ( sc != null ) { sc . check Link ( lib Name ) ; } if ( loader != null ) { String full Lib Name = loader . find Library ( lib Name ) ; if ( full Lib Name != null ) { load Library ( full Lib Name , loader , null ) ; return ; } } String path = System . get Property ( STRING , STRING ) ; path += System . get Property ( STRING , STRING ) ; load Library ( lib Name , loader , path ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static void save To Protected Store ( Private Key private Key , Certificate certificate , File store Location , String alias , String private Key Password , String key Store Password , String key Store Type ) throws IO Exception , Key Store Exception , No Such Provider Exception , No Such Algorithm Exception , Certificate Exception { Key Store store = null ; if ( key Store Type . equals ( STRING ) ) { store = Key Store . get Instance ( key Store Type , Crypto Util . get Security Provider Name ( Key Store . class ) ) ; } else store = Key Store . get Instance ( key Store Type ) ; store . load ( null , null ) ; Certificate [ ] chain = new Certificate [ NUM ] ; chain [ NUM ] = certificate ; if ( private Key Password != null ) store . set Key Entry ( alias , private Key , private Key Password . to Char Array ( ) , chain ) ; else store . set Key Entry ( alias , private Key , null , chain ) ; File Output Stream f Out = new File Output Stream ( store Location ) ; try { store . store ( f Out , key Store Password == null ? null : key Store Password . to Char Array ( ) ) ; } finally { f Out . close ( ) ; } }
public And Query Builder add ( Query Builder filter Builder ) { filters . add ( filter Builder ) ; return this ; }
void update ( long time , int rows ) { count ++ ; execution Time Min = Math . min ( time , execution Time Min ) ; execution Time Max = Math . max ( time , execution Time Max ) ; row Count Min = Math . min ( rows , row Count Min ) ; row Count Max = Math . max ( rows , row Count Max ) ; double delta = rows - row Count Mean ; row Count Mean += delta / count ; row Count M 2 += delta * ( rows - row Count Mean ) ; delta = time - execution Time Mean ; execution Time Mean += delta / count ; execution Time M 2 += delta * ( time - execution Time Mean ) ; execution Time Cumulative += time ; row Count Cumulative += rows ; last Update Time = System . current Time Millis ( ) ; }
public static final void main ( String [ ] args ) { try { Properties properties = new Properties ( ) ; File journal = File . create Temp File ( STRING , STRING ) ; log . info ( journal . get Absolute Path ( ) ) ; journal . delete On Exit ( ) ; properties . set Property ( Bigdata Sail . Options . FILE , journal . get Absolute Path ( ) ) ; Bigdata Sail sail = new Bigdata Sail ( properties ) ; Bigdata Sail Repository repo = new Bigdata Sail Repository ( sail ) ; repo . initialize ( ) ; Bigdata Writer writer = new Bigdata Writer ( repo ) ; Collection < Bigdata Reader > readers = new Linked List < Bigdata Reader > ( ) ; for ( int i = NUM ; i < num Readers ; i ++ ) { readers . add ( new Bigdata Reader ( repo ) ) ; } Executor Service executor = Executors . new Cached Thread Pool ( ) ; Future writer Future = executor . submit ( writer ) ; Collection < Future > reader Futures = new Linked List < Future > ( ) ; for ( Bigdata Reader reader : readers ) { reader Futures . add ( executor . submit ( reader ) ) ; } writer Future . get ( ) ; for ( Bigdata Reader reader : readers ) { reader . kill ( ) ; } for ( Future reader Future : reader Futures ) { reader Future . get ( ) ; } repo . shut Down ( ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } }
@ Override public String to String ( ) { String result = STRING ; result += get Compatibility State ( ) ; if ( m Instances == null ) { result += STRING ; } else { result += STRING + Utils . back Quote Chars ( m Instances . relation Name ( ) ) ; } return result ; }
public final Array List < Brd Tracep > split with end point ( int line idx , Pla Point Int p point ) { Array List < Brd Tracep > risul = new Array List < Brd Tracep > ( NUM ) ; if ( ! is on the board ( ) ) return risul ; if ( ! split inside drill pad allowed ( p point ) ) return risul ; Array List < Polyline > split polylines = polyline . split at point ( line idx , p point ) ; if ( split polylines . size ( ) < NUM ) { if ( r board . debug ( Mdbg . TRACE SPLIT , Ldbg . DEBUG ) ) r board . user Println ( STRING + get id no ( ) ) ; return risul ; } r board . remove item ( this ) ; Brd Tracep first trace = r board . insert trace without cleaning ( split polylines . get ( NUM ) , get layer ( ) , get half width ( ) , net nos , clearance idx ( ) , get fixed state ( ) ) ; if ( first trace == null ) { r board . user Println ( STRING ) ; return risul ; } Brd Tracep second trace = r board . insert trace without cleaning ( split polylines . get ( NUM ) , get layer ( ) , get half width ( ) , net nos , clearance idx ( ) , get fixed state ( ) ) ; if ( second trace == null ) { r board . user Println ( STRING ) ; return risul ; } if ( r board . debug ( Mdbg . TRACE SPLIT , Ldbg . DEBUG ) ) r board . user Println ( STRING + first trace . get id no ( ) + STRING + second trace . get id no ( ) ) ; risul . add ( first trace ) ; risul . add ( second trace ) ; return risul ; }
public void write Bytes ( final byte [ ] bytes ) { if ( bytes == null ) return ; if ( current Bit Index < Byte . SIZE - NUM ) { for ( int i = NUM ; i < bytes . length ; i ++ ) { write ( bytes [ i ] , Byte . SIZE ) ; } } else { byte Stream . write ( bytes , NUM , bytes . length ) ; } }
public Create Index Request aliases ( X Content Builder source ) { return aliases ( source . bytes ( ) ) ; }
protected List < String > list User Names ( ) throws Users Repository Exception { Collection < User > users = get All Users ( ) ; List < String > user Names = new Array List < String > ( users . size ( ) ) ; for ( User user : users ) { user Names . add ( user . get User Name ( ) ) ; } users . clear ( ) ; return user Names ; }
void after Write ( Runnable task ) { write Buffer . add ( task ) ; drain Status . lazy Set ( REQUIRED ) ; try To Drain Buffers ( ) ; notify Listener ( ) ; }
public static void copy ( File src Dir , File rel Src File , File dest Dir , File rel Dest File ) throws IO Exception { File final Src File = ( src Dir != null ) ? new File ( src Dir , rel Src File . get Path ( ) ) : rel Src File ; File rel Dest Dir = rel Dest File . get Parent File ( ) ; if ( rel Dest Dir != null ) { File final Dest Dir = ( dest Dir != null ) ? new File ( dest Dir , rel Dest Dir . get Path ( ) ) : rel Dest Dir ; mkdirs ( final Dest Dir ) ; } File final Dest File = new File ( dest Dir , rel Dest File . get Path ( ) ) ; Files . copy ( final Src File . to Path ( ) , final Dest File . to Path ( ) , Standard Copy Option . REPLACE EXISTING , Standard Copy Option . COPY ATTRIBUTES ) ; }
public static String properties Encode ( Properties pp ) { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; try { pp . store ( bos , STRING ) ; } catch ( IO Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; } String result = new String ( bos . to Byte Array ( ) ) ; try { result = URL Encoder . encode ( result , Web Env . ENCODING ) ; } catch ( Unsupported Encoding Exception e ) { log . log ( Level . SEVERE , STRING + Web Env . ENCODING , e ) ; String enc = System . get Property ( STRING ) ; try { result = URL Encoder . encode ( result , enc ) ; log . info ( STRING + enc ) ; } catch ( Exception ex ) { log . log ( Level . SEVERE , STRING , ex ) ; } } return result ; }
public void generate Atom ( Xml Writer w , Extension Profile ext Profile ) throws IO Exception { Array List < Xml Writer . Attribute > attrs = new Array List < Xml Writer . Attribute > ( NUM ) ; List < Xml Namespace > ns Decls = new Array List < Xml Namespace > ( ) ; if ( rel != null ) { attrs . add ( new Xml Writer . Attribute ( STRING , rel ) ) ; } if ( type != null ) { attrs . add ( new Xml Writer . Attribute ( STRING , type ) ) ; } if ( href != null ) { attrs . add ( new Xml Writer . Attribute ( STRING , href ) ) ; } if ( href Lang != null ) { attrs . add ( new Xml Writer . Attribute ( STRING , href Lang ) ) ; } if ( title != null ) { attrs . add ( new Xml Writer . Attribute ( STRING , title ) ) ; } if ( title Lang != null ) { attrs . add ( new Xml Writer . Attribute ( STRING , title Lang ) ) ; } if ( length != - NUM ) { attrs . add ( new Xml Writer . Attribute ( STRING , String . value Of ( length ) ) ) ; } if ( etag != null ) { ns Decls . add ( Namespaces . g Ns ) ; attrs . add ( new Xml Writer . Attribute ( Namespaces . g Alias , STRING , etag ) ) ; } generate Start Element ( w , Namespaces . atom Ns , STRING , attrs , ns Decls ) ; if ( content != null ) { content . generate Atom ( w , ext Profile ) ; } generate Extensions ( w , ext Profile ) ; w . end Element ( Namespaces . atom Ns , STRING ) ; }
public void test Sorts Elements By Nth Name ( ) throws Exception { Xpp Dom dom 1 = Xpp Factory . build Dom ( STRING ) ; Xpp Dom dom 2 = Xpp Factory . build Dom ( STRING ) ; assert Equals ( - NUM , comparator . compare ( dom 1 , dom 2 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; assert Equals ( NUM , comparator . compare ( dom 2 , dom 1 ) ) ; assert Equals ( STRING , xpath . get ( ) ) ; }
public static void delete ( File file Or Directory ) { if ( ! file Or Directory . exists ( ) ) { return ; } if ( file Or Directory . is Directory ( ) ) { File [ ] files List = file Or Directory . list Files ( ) ; for ( File child : files List ) { delete ( child ) ; } } final File to = new File ( file Or Directory . get Absolute Path ( ) + System . current Time Millis ( ) ) ; file Or Directory . rename To ( to ) ; to . delete ( ) ; }
public static void insert Object At Offset ( Object [ ] source Array , Object [ ] destination Array , int offset , Object o ) { if ( offset == NUM ) { destination Array [ NUM ] = o ; System . arraycopy ( source Array , NUM , destination Array , NUM , source Array . length ) ; } else { if ( offset == source Array . length ) { System . arraycopy ( source Array , NUM , destination Array , NUM , source Array . length ) ; destination Array [ source Array . length ] = o ; } else { System . arraycopy ( source Array , NUM , destination Array , NUM , offset ) ; destination Array [ offset ] = o ; System . arraycopy ( source Array , offset , destination Array , offset + NUM , source Array . length - offset ) ; } } }
private boolean is Date Format String ( String string ) { if ( string . length ( ) < NUM ) { return BOOL ; } final int str Length = string . length ( ) ; final char start Char = string . char At ( NUM ) ; final char end Char = string . char At ( str Length - NUM ) ; if ( start Char == STRING || end Char == STRING ) { return BOOL ; } else if ( Character . is Letter ( start Char ) && string . char At ( NUM ) == STRING ) { return BOOL ; } final Matcher date Format Matcher = DATE FORMAT PATTERN . matcher ( string ) ; return date Format Matcher . find ( ) ; }
public void clear ( ) { m Categories . clear ( ) ; m Titles . clear ( ) ; m Values . clear ( ) ; }
public static Hash Map < String , String > parse Map ( String s ) { Hash Map < String , String > map = New . hash Map ( ) ; for ( int i = NUM , size = s . length ( ) ; i < size ; ) { int start Key = i ; i = s . index Of ( STRING , i ) ; if ( i < NUM ) { throw Data Utils . new Illegal State Exception ( Data Utils . ERROR FILE CORRUPT , STRING , s ) ; } String key = s . substring ( start Key , i ++ ) ; String Builder buff = new String Builder ( ) ; while ( i < size ) { char c = s . char At ( i ++ ) ; if ( c == STRING ) { break ; } else if ( c == STRING ) { while ( i < size ) { c = s . char At ( i ++ ) ; if ( c == STRING ) { if ( i == size ) { throw Data Utils . new Illegal State Exception ( Data Utils . ERROR FILE CORRUPT , STRING , s ) ; } c = s . char At ( i ++ ) ; } else if ( c == STRING ) { break ; } buff . append ( c ) ; } } else { buff . append ( c ) ; } } map . put ( key , buff . to String ( ) ) ; } return map ; }
public static void check Permissions ( I User user , I Guild guild , Enum Set < Permissions > required ) throws Missing Permissions Exception { try { Enum Set < Permissions > contained = Enum Set . none Of ( Permissions . class ) ; List < I Role > roles = user . get Roles For Guild ( guild ) ; for ( I Role role : roles ) { contained . add All ( role . get Permissions ( ) ) ; } check Permissions ( contained , required ) ; } catch ( Unsupported Operation Exception e ) { } }
@ Deprecated public static void run Finalizers On Exit ( boolean run ) { finalize On Exit = run ; }
public double predict Quantile ( double percentage ) { update Mean And Variance ( ) ; return m Mean + Statistics . normal Inverse ( percentage ) * Math . sqrt ( m Variance ) ; }
public static boolean check MD 5 ( final String md 5 Hash , final File file ) { if ( Text Utils . is Empty ( md 5 Hash ) || file == null || ! File Utils . is Readable ( file ) ) { Log . e ( STRING ) ; return BOOL ; } final String hash = get MD 5 ( file ) ; if ( hash == null ) { Log . e ( STRING ) ; return BOOL ; } return hash . equals Ignore Case ( md 5 Hash ) ; }
public void add Dimension Key Name ( String key ) { dimension Key Names . add ( key ) ; }
public static boolean contains Any ( Char Sequence cs , char ... search Chars ) { if ( is Empty ( cs ) || is Empty ( search Chars ) ) { return BOOL ; } int cs Length = cs . length ( ) ; int search Length = search Chars . length ; int cs Last = cs Length - NUM ; int search Last = search Length - NUM ; for ( int i = NUM ; i < cs Length ; i ++ ) { char ch = cs . char At ( i ) ; for ( int j = NUM ; j < search Length ; j ++ ) { if ( search Chars [ j ] == ch ) { if ( Character . is High Surrogate ( ch ) ) { if ( j == search Last ) { return BOOL ; } if ( i < cs Last && search Chars [ j + NUM ] == cs . char At ( i + NUM ) ) { return BOOL ; } } else { return BOOL ; } } } } return BOOL ; }
private static void define Entity ( String name , char value ) { if ( by Name . get ( name ) == null ) { by Name . put ( name , new Integer ( value ) ) ; by Char . put ( new Integer ( value ) , name ) ; } }
public static List < String > split Lines ( String text ) { List < String > list = new Array List < > ( ) ; if ( text != null ) { String lines [ ] = text . split ( STRING ) ; list . add All ( Arrays . as List ( lines ) ) ; } return list ; }
private Rectangle 2 D draw Fill ( Graphics 2 D g2 , Rectangle 2 D area ) { Rectangle 2 D filled Area = ( Rectangle 2 D ) area . clone ( ) ; filled Area = trim Margin ( filled Area ) ; filled Area = trim Border ( filled Area ) ; area = trim Padding ( area ) ; g2 . set Paint ( this . fill Paint ) ; g2 . fill ( filled Area ) ; draw Border ( g2 , filled Area ) ; return filled Area ; }
public void add Hole ( Linear Ring hole ) { if ( holes == null ) holes = new Array List ( ) ; holes . add ( hole ) ; }
@ Suppress Warnings ( STRING ) static Gui Component < ? > create Desktop Component ( final Generic Frame parent Frame , final Workspace Component component ) { Class < ? extends Workspace Component > component Class = component . get Class ( ) ; Class < ? extends Gui Component < ? > > gui Class = wrappers . get ( component Class ) ; if ( gui Class == null ) { throw new Illegal Argument Exception ( STRING + component . get Class ( ) ) ; } try { Generic Frame generic Frame = parent Frame != null ? parent Frame : new Desktop Internal Frame ( component ) ; Constructor < ? extends Gui Component < ? > > constructor = gui Class . get Constructor ( Generic Frame . class , component Class ) ; return constructor . new Instance ( generic Frame , component ) ; } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
private int read Input Data ( byte [ ] buf , int off , int len ) throws IO Exception { cb Lock . lock ( ) ; try { return iis . read ( buf , off , len ) ; } finally { cb Lock . unlock ( ) ; } }
public byte [ ] generate 160 Bit Hash Id ( ) throws Crypto Exception { try { DER Bit String public Key Bit String = encode Public Key As Bit String ( public Key ) ; return Digest Util . get Message Digest ( public Key Bit String . get Bytes ( ) , Digest Type . SHA 1 ) ; } catch ( IO Exception ex ) { throw new Crypto Exception ( res . get String ( STRING ) , ex ) ; } }
public static < C extends Configuration Client , S extends Configuration > Create Sub Command Handler < C , S > create ( Sub Command Argument Parser parser , Managed Object Path < ? , ? > p , Set Relation Definition < C , S > r ) throws Argument Exception { return new Create Sub Command Handler < > ( parser , p , r , null , p . child ( r ) ) ; }
public D Authority Information Access ( J Dialog parent , byte [ ] value ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; init Components ( ) ; prepopulate With Value ( value ) ; }
public void test Signer String ( ) throws Exception { Signer s = new Signer Stub ( STRING ) ; assert Not Null ( s ) ; assert Equals ( STRING , s . get Name ( ) ) ; assert Null ( s . get Private Key ( ) ) ; Signer s2 = new Signer Stub ( null ) ; assert Null ( s2 . get Name ( ) ) ; }
private Figure read Rect Element ( IXML Element elem ) throws IO Exception { Hash Map < Attribute Key , Object > a = new Hash Map < Attribute Key , Object > ( ) ; read Core Attributes ( elem , a ) ; read Transform Attribute ( elem , a ) ; read Opacity Attribute ( elem , a ) ; read Shape Attributes ( elem , a ) ; double x = to Number ( elem , read Attribute ( elem , STRING , STRING ) ) ; double y = to Number ( elem , read Attribute ( elem , STRING , STRING ) ) ; double w = to Width ( elem , read Attribute ( elem , STRING , STRING ) ) ; double h = to Height ( elem , read Attribute ( elem , STRING , STRING ) ) ; String rx Value = read Attribute ( elem , STRING , STRING ) ; String ry Value = read Attribute ( elem , STRING , STRING ) ; if ( rx Value . equals ( STRING ) ) { rx Value = ry Value ; } if ( ry Value . equals ( STRING ) ) { ry Value = rx Value ; } double rx = to Number ( elem , rx Value . equals ( STRING ) ? STRING : rx Value ) ; double ry = to Number ( elem , ry Value . equals ( STRING ) ? STRING : ry Value ) ; Figure figure = factory . create Rect ( x , y , w , h , rx , ry , a ) ; element Objects . put ( elem , figure ) ; return figure ; }
public boolean is Set Message Type ( ) { return isset bit vector . get ( MESSAGETYPE ISSET ID ) ; }
private boolean prepare ( J Component c , Container root , boolean is Paint , int x , int y , int w , int h ) { if ( bsg != null ) { bsg . dispose ( ) ; bsg = null ; } buffer Strategy = null ; if ( root != null ) { boolean contents Lost = BOOL ; Buffer Info buffer Info = get Buffer Info ( root ) ; if ( buffer Info == null ) { contents Lost = BOOL ; buffer Info = new Buffer Info ( root ) ; buffer Infos . add ( buffer Info ) ; if ( LOGGER . is Loggable ( Platform Logger . Level . FINER ) ) { LOGGER . finer ( STRING + root ) ; } } this . buffer Info = buffer Info ; if ( ! buffer Info . has Buffer Strategy Changed ( ) ) { buffer Strategy = buffer Info . get Buffer Strategy ( BOOL ) ; if ( buffer Strategy != null ) { bsg = buffer Strategy . get Draw Graphics ( ) ; if ( buffer Strategy . contents Restored ( ) ) { contents Lost = BOOL ; if ( LOGGER . is Loggable ( Platform Logger . Level . FINER ) ) { LOGGER . finer ( STRING ) ; } } } else { return BOOL ; } if ( buffer Info . get Contents Lost During Expose ( ) ) { contents Lost = BOOL ; buffer Info . set Contents Lost During Expose ( BOOL ) ; if ( LOGGER . is Loggable ( Platform Logger . Level . FINER ) ) { LOGGER . finer ( STRING ) ; } } if ( is Paint && c == root J && x == NUM && y == NUM && c . get Width ( ) == w && c . get Height ( ) == h ) { buffer Info . set In Sync ( BOOL ) ; } else if ( contents Lost ) { buffer Info . set In Sync ( BOOL ) ; if ( ! is Repainting Root ( ) ) { repaint Root ( root J ) ; } else { reset Double Buffer Per Window ( ) ; } } return ( buffer Infos != null ) ; } } return BOOL ; }
public J File Image Chooser ( final Shell parent , final int style , final File working Dir ) { file Dialog = new File Dialog ( parent , style ) ; if ( working Dir != null ) file Dialog . set Filter Path ( working Dir . get Absolute Path ( ) ) ; }
private List < Stat > process Port Stats Info ( Map < String , List < String > > inter Port Map , Map < String , Big Integer > string Map Port I Os , Storage System storage System , Db Client db Client , Long sample Time ) { List < Stat > stat = new Array List < Stat > ( ) ; Stat fe Port Stat = null ; for ( Entry < String , List < String > > entry : inter Port Map . entry Set ( ) ) { String interface IP = entry . get Key ( ) ; List < String > port List = entry . get Value ( ) ; String port Native Guid = Native GUID Generator . generate Native Guid ( storage System , interface IP , Native GUID Generator . PORT ) ; Storage Port storage Port = find Existing Port ( port Native Guid , db Client ) ; logger . info ( STRING , interface IP , storage Port . get Port Name ( ) ) ; Big Integer iovalue = new Big Integer ( STRING ) ; for ( String physical Name : port List ) { iovalue = iovalue . add ( string Map Port I Os . get ( physical Name ) ) ; } Long iopes = iovalue . long Value ( ) / port List . size ( ) ; Long kbytes = iopes / NUM ; logger . info ( STRING , iopes . to String ( ) , sample Time . to String ( ) ) ; storage Port . set Port Speed ( NUM ) ; port Metrics Processor . process IP Port Metrics ( kbytes , iopes , storage Port , sample Time ) ; fe Port Stat = prepare Port Stat Info ( port Native Guid , storage Port . get Id ( ) , iopes , sample Time ) ; stat . add ( fe Port Stat ) ; } return stat ; }
public final int read Int ( ) throws java . io . IO Exception { read Fully ( scratch , NUM , NUM ) ; return ( ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) ) ; }
public Replication Job create Job For Copy Partition ( long audit Log Id , long audit Log Entry Create Time , Named Partition named Partition ) throws State Update Exception { String partition Name = named Partition . get Name ( ) ; List < String > partition Names = new Array List < > ( ) ; partition Names . add ( partition Name ) ; Replication Operation replication Operation = Replication Operation . COPY PARTITION ; Map < String , String > extras = new Hash Map < > ( ) ; extras . put ( Persisted Job Info . AUDIT LOG ID EXTRAS KEY , Long . to String ( audit Log Id ) ) ; extras . put ( Persisted Job Info . AUDIT LOG ENTRY CREATE TIME KEY , Long . to String ( audit Log Entry Create Time ) ) ; Partition partition = named Partition . get Partition ( ) ; Hive Object Spec spec = new Hive Object Spec ( named Partition ) ; Persisted Job Info persisted Job Info = job Info Store . resilient Create ( replication Operation , Replication Status . PENDING , Replication Utils . get Location ( partition ) , src Cluster . get Name ( ) , spec , partition Names , Replication Utils . get Tldt ( partition ) , Optional . empty ( ) , Optional . empty ( ) , extras ) ; Replication Task replication Task = new Copy Partition Task ( conf , destination Object Factory , object Conflict Handler , src Cluster , dest Cluster , spec , Replication Utils . get Location ( partition ) , Optional . < Path > empty ( ) , directory Copier , BOOL ) ; return new Replication Job ( conf , replication Task , on State Change Handler , persisted Job Info ) ; }
public static void write File ( String to Write , String file Name ) throws File Not Found Exception , Unsupported Encoding Exception { logger . debug ( STRING + file Name ) ; Print Writer writer = null ; try { writer = new Print Writer ( file Name , STRING ) ; writer . println ( to Write ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } }
public static Map < String , Object > create Content ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = create Content Method ( dctx , context ) ; return result ; }
public static boolean is File Exist ( String file Path ) { if ( Handler String . is Blank ( file Path ) ) { return BOOL ; } File file = new File ( file Path ) ; return ( file . exists ( ) && file . is File ( ) ) ; }
public static void update Actor Position ( final Actor actor , final Stage stage , final Vector 2 new Screen Size In Stage Coords ) { if ( actor != null && stage != null ) { actor . set Position ( ( int ) ( ( actor . get X ( ) + actor . get Width ( ) / NUM ) / stage . get Width ( ) * new Screen Size In Stage Coords . x - actor . get Width ( ) / NUM ) , ( int ) ( ( actor . get Y ( ) + actor . get Height ( ) / NUM ) / stage . get Height ( ) * new Screen Size In Stage Coords . y - actor . get Height ( ) / NUM ) ) ; } }
public static double gamma ( double z ) { if ( z < NUM ) { return ( Internalgamma ( z ) ) ; } else { double multiplier = Math . floor ( z / NUM ) ; double remainder = z / multiplier ; double coef 1 = Math . pow ( NUM * Math . PI , ( NUM * ( NUM - multiplier ) ) ) ; double coef 2 = Math . pow ( multiplier , ( ( multiplier * remainder ) - NUM ) ) ; int N = ( int ) multiplier ; double prod = NUM ; for ( int k = NUM ; k < N ; k ++ ) { prod *= Internalgamma ( remainder + ( ( double ) k / multiplier ) ) ; } return coef 1 * coef 2 * prod ; } }
private void read Boot Json ( String basedir ) throws IO Exception { Bootstrap Config boot = Bootstrap Config . from Json File ( basedir + STRING ) ; String dsame Password ; String config Store Password ; try { AM Key Provider am Key Provider = new AM Key Provider ( boot . get Key Store Config ( STRING ) ) ; dsame Password = am Key Provider . get Secret ( DSAME PWD KEY ) ; config Store Password = am Key Provider . get Secret ( CONFIG PWD KEY ) ; } catch ( Key Store Exception e ) { throw new IO Exception ( STRING , e ) ; } String server instance = boot . get Instance ( ) ; if ( server instance == null ) { throw new IO Exception ( STRING ) ; } String dsame user = boot . get Dsame User ( ) ; for ( Config Store Properties cfp : boot . get Config Store List ( ) ) { Map m = new Hash Map ( ) ; String proto = cfp . get Ldap Protocol ( ) + STRING ; m . put ( PROTOCOL , proto ) ; m . put ( DS HOST , cfp . get Ldap Host ( ) ) ; String port = STRING + cfp . get Ldap Port ( ) ; m . put ( DS PORT , port ) ; m . put ( SERVER INSTANCE , server instance ) ; m . put ( PWD , config Store Password ) ; m . put ( DS BASE DN , cfp . get Base DN ( ) ) ; m . put ( USER , dsame user ) ; m . put ( DS MGR , cfp . get Dir Manager DN ( ) ) ; m . put ( DS PWD , dsame Password ) ; String bootstrap = create Bootstrap Resource ( m , BOOL ) ; bootstrap = String Utils . str Replace All ( bootstrap , STRING , URL Encoder . encode ( dsame user , STRING ) ) ; data . add ( bootstrap ) ; } }
public void read ( Byte Buffer byte Buffer ) throws Invalid Frame Exception , Invalid Data Type Exception { String identifier = read Identifier ( byte Buffer ) ; byte [ ] buffer = new byte [ get Frame Size Size ( ) ] ; if ( ! is Valid ID 3 v 2 Frame Identifier ( identifier ) ) { logger . config ( STRING + identifier ) ; byte Buffer . position ( byte Buffer . position ( ) - ( get Frame Id Size ( ) - NUM ) ) ; throw new Invalid Frame Identifier Exception ( get Logging Filename ( ) + STRING + identifier + STRING ) ; } byte Buffer . get ( buffer , NUM , get Frame Size Size ( ) ) ; frame Size = decode Size ( buffer ) ; if ( frame Size < NUM ) { throw new Invalid Frame Exception ( identifier + STRING + frame Size ) ; } else if ( frame Size == NUM ) { logger . warning ( STRING + identifier ) ; throw new Empty Frame Exception ( identifier + STRING ) ; } else if ( frame Size > byte Buffer . remaining ( ) ) { logger . warning ( STRING + identifier ) ; throw new Invalid Frame Exception ( identifier + STRING ) ; } else { logger . fine ( STRING + frame Size ) ; String id = ID 3 Tags . convert Frame ID 22 To 24 ( identifier ) ; if ( id == null ) { id = ID 3 Tags . convert Frame ID 22 To 23 ( identifier ) ; if ( id == null ) { if ( ID 3 Tags . is ID 3 v 22 Frame Identifier ( identifier ) ) { id = identifier ; } else { id = UNSUPPORTED ID ; } } } logger . fine ( STRING + identifier + STRING + id ) ; Byte Buffer frame Body Buffer = byte Buffer . slice ( ) ; frame Body Buffer . limit ( frame Size ) ; try { frame Body = read Body ( id , frame Body Buffer , frame Size ) ; } finally { byte Buffer . position ( byte Buffer . position ( ) + frame Size ) ; } } }
protected void save Buffer ( ) { String Buffer sb = m History . get Selected Buffer ( ) ; if ( sb != null ) { if ( m Save Out . save ( sb ) ) { J Option Pane . show Message Dialog ( this , STRING , STRING , J Option Pane . INFORMATION MESSAGE ) ; } } else { m Save Out But . set Enabled ( BOOL ) ; } }
private Recommendation find V Plex HA Recommendations ( Virtual Array varray , Virtual Pool vpool , Virtual Array ha Varray , Virtual Pool ha Vpool , Project project , Virtual Pool Capability Values Wrapper capabilities , Map < String , List < Storage Pool > > vplex Pool Map For Varray ) { Recommendation ha Recommendation = null ; List < Recommendation > vplex Ha V Array Recommendations = null ; if ( ha Varray == null ) { ha Varray = vplex Scheduler . get Ha Virtual Array ( varray , project , vpool ) ; } if ( ha Vpool == null ) { ha Vpool = vplex Scheduler . get Ha Virtual Pool ( varray , project , vpool ) ; } vplex Ha V Array Recommendations = get All HA Recommendations ( varray , vpool , ha Varray , ha Vpool , capabilities , vplex Pool Map For Varray ) ; if ( ! vplex Ha V Array Recommendations . is Empty ( ) ) { ha Recommendation = vplex Ha V Array Recommendations . get ( NUM ) ; } return ha Recommendation ; }
@ Not Null public static List < String > complete Absolute Path ( @ Not Null String prefix , Predicate < File > accept ) { String native Path = prefix . starts With ( STRING ) && System Info Rt . is Windows ? OS Util . bash Compatible To Native ( prefix ) : prefix ; File base = new File ( native Path ) ; boolean dot Suffix = prefix . ends With ( STRING ) && ! prefix . starts With ( STRING ) ; if ( ! base . exists ( ) || dot Suffix ) { base = base . get Parent File ( ) ; if ( base == null || ! base . exists ( ) ) { return Collections . empty List ( ) ; } } File base Path ; String match Prefix ; if ( base . is Directory ( ) ) { base Path = base ; match Prefix = STRING ; } else { base Path = base . get Parent File ( ) ; match Prefix = base . get Name ( ) ; } List < String > result = Lists . new Linked List ( ) ; for ( File file Candidate : collect Files ( base Path , match Prefix ) ) { if ( ! accept . apply ( file Candidate ) ) { continue ; } String result Path ; if ( file Candidate . is Directory ( ) ) { result Path = file Candidate . get Absolute Path ( ) + File . separator ; } else { result Path = file Candidate . get Absolute Path ( ) ; } result . add ( OS Util . to Bash Compatible ( result Path ) ) ; } return result ; }
protected void add ( Instance inst ) { for ( int i = NUM ; i < m Specifiers . size ( ) ; i ++ ) { Instance specifier = m Specifiers . get ( i ) ; boolean found = BOOL ; for ( int m Dataset Key Column : m Dataset Key Columns ) { if ( inst . value ( m Dataset Key Column ) != specifier . value ( m Dataset Key Column ) ) { found = BOOL ; } } if ( found ) { return ; } } m Specifiers . add ( inst ) ; }
public static void filter Supported Vpools Based On Tiering Policy ( Un Managed Volume un Managed Volume , String policy Name , Storage System system , Db Client db Client ) { String Set supported Vpool UR Is = un Managed Volume . get Supported Vpool Uris ( ) ; List < String > v Pools To Remove = new Array List < String > ( ) ; if ( supported Vpool UR Is != null ) { Iterator < String > itr = supported Vpool UR Is . iterator ( ) ; while ( itr . has Next ( ) ) { String uri = itr . next ( ) ; Virtual Pool v Pool = db Client . query Object ( Virtual Pool . class , URI . create ( uri ) ) ; if ( v Pool != null && ! v Pool . get Inactive ( ) ) { String auto Tier Policy Id = Native GUID Generator . generate Auto Tier Policy Native Guid ( system . get Native Guid ( ) , policy Name , Native GUID Generator . get Tiering Policy Key For System ( system ) ) ; if ( ! check V Pool Valid For Un Managed Volume Auto Tiering Policy ( v Pool , auto Tier Policy Id , system ) ) { String msg = STRING + STRING ; log . info ( String . format ( msg , new Object [ ] { uri , un Managed Volume . get Id ( ) , auto Tier Policy Id , v Pool . get Auto Tier Policy Name ( ) } ) ) ; v Pools To Remove . add ( uri ) ; } } else { v Pools To Remove . add ( uri ) ; } } } for ( String uri : v Pools To Remove ) { supported Vpool UR Is . remove ( uri ) ; } }
public static int copy Stream ( Input Stream source Stream , Output Stream destination Stream ) throws IO Exception { int bytes Read = NUM ; int total Bytes = NUM ; byte [ ] buffer = new byte [ NUM ] ; while ( bytes Read >= NUM ) { bytes Read = source Stream . read ( buffer , NUM , buffer . length ) ; if ( bytes Read > NUM ) { destination Stream . write ( buffer , NUM , bytes Read ) ; } total Bytes += bytes Read ; } destination Stream . flush ( ) ; destination Stream . close ( ) ; return total Bytes ; }
protected static int compare Prefix ( Unit NR Shape a , Unit NR Shape b ) { int min Level = Math . min ( a . get Level ( ) , b . get Level ( ) ) ; for ( int level = NUM ; level <= min Level ; level ++ ) { int diff = a . get Val At Level ( level ) - b . get Val At Level ( level ) ; if ( diff != NUM ) return diff ; } return NUM ; }
private int make Available ( ) throws IO Exception { if ( pos != - NUM ) { return NUM ; } total += tail - head - pad ; System . arraycopy ( buffer , tail - pad , buffer , NUM , pad ) ; head = NUM ; tail = pad ; for ( ; ; ) { int bytes Read = input . read ( buffer , tail , buf Size - tail ) ; if ( bytes Read == - NUM ) { final String msg = STRING ; throw new Malformed Stream Exception ( msg ) ; } tail += bytes Read ; find Separator ( ) ; int av = available ( ) ; if ( av > NUM || pos != - NUM ) { return av ; } } }
public double [ ] distribution For Instance ( Instance instance ) throws Exception { double trans Prob = NUM , temp = NUM ; double [ ] class Probability = new double [ m Num Classes ] ; double [ ] predicted Value = new double [ NUM ] ; for ( int i = NUM ; i < class Probability . length ; i ++ ) { class Probability [ i ] = NUM ; } predicted Value [ NUM ] = NUM ; if ( m Init Flag == ON ) { if ( m Blend Method == B ENTROPY ) { generate Random Class Colomns ( ) ; } m Cache = new K Star Cache [ m Num Attributes ] ; for ( int i = NUM ; i < m Num Attributes ; i ++ ) { m Cache [ i ] = new K Star Cache ( ) ; } m Init Flag = OFF ; } Instance train Instance ; Enumeration < Instance > enu = m Train . enumerate Instances ( ) ; while ( enu . has More Elements ( ) ) { train Instance = ( Instance ) enu . next Element ( ) ; trans Prob = instance Transformation Probability ( instance , train Instance ) ; switch ( m Class Type ) { case Attribute . NOMINAL : class Probability [ ( int ) train Instance . class Value ( ) ] += trans Prob ; break ; case Attribute . NUMERIC : predicted Value [ NUM ] += trans Prob * train Instance . class Value ( ) ; temp += trans Prob ; break ; } } if ( m Class Type == Attribute . NOMINAL ) { double sum = Utils . sum ( class Probability ) ; if ( sum <= NUM ) for ( int i = NUM ; i < class Probability . length ; i ++ ) class Probability [ i ] = ( double ) NUM / ( double ) m Num Classes ; else Utils . normalize ( class Probability , sum ) ; return class Probability ; } else { predicted Value [ NUM ] = ( temp != NUM ) ? predicted Value [ NUM ] / temp : NUM ; return predicted Value ; } }
private Group parse Group Result ( Result Set result Set ) throws SQL Exception , Ade Internal Exception { int uid = result Set . get Int ( STRING ) ; String name = result Set . get String ( STRING ) ; Short group Type Val = result Set . get Short ( STRING ) ; Group Type group Type = Group Type . get Group Type ( group Type Val ) ; Short data Type Val = result Set . get Short ( STRING ) ; Data Type data Type = Data Type . get Data Type ( data Type Val ) ; short evaluation Order = result Set . get Short ( STRING ) ; int rid = result Set . get Int ( STRING ) ; String rule Name = get Rule Name ( rid ) ; return new Group ( uid , name , group Type , data Type , evaluation Order , rule Name ) ; }
public long skip ( long n ) throws IO Exception { if ( n < NUM ) throw new Illegal Argument Exception ( STRING ) ; int nn = ( int ) Math . min ( n , max Skip Buffer Size ) ; synchronized ( lock ) { if ( ( skip Buffer == null ) || ( skip Buffer . length < nn ) ) skip Buffer = new char [ nn ] ; long r = n ; while ( r > NUM ) { int nc = read ( skip Buffer , NUM , ( int ) Math . min ( r , nn ) ) ; if ( nc == - NUM ) break ; r -= nc ; } return n - r ; } }
private Image Icon add Space To Icon ( Image Icon icon ) { int width = icon . get Icon Width ( ) ; int height = icon . get Icon Height ( ) ; int hspace = NUM ; Buffered Image res = new Buffered Image ( width + hspace , height , Buffered Image . TYPE INT ARGB ) ; Graphics g = res . get Graphics ( ) ; g . draw Image ( icon . get Image ( ) , NUM , NUM , null ) ; g . dispose ( ) ; return new Image Icon ( res ) ; }
private String parse Name ( ) throws Jasper Exception { char ch = ( char ) reader . peek Char ( ) ; if ( Character . is Letter ( ch ) || ch == STRING || ch == STRING ) { String Builder buf = new String Builder ( ) ; buf . append ( ch ) ; reader . next Char ( ) ; ch = ( char ) reader . peek Char ( ) ; while ( Character . is Letter ( ch ) || Character . is Digit ( ch ) || ch == STRING || ch == STRING || ch == STRING || ch == STRING ) { buf . append ( ch ) ; reader . next Char ( ) ; ch = ( char ) reader . peek Char ( ) ; } return buf . to String ( ) ; } return null ; }
public void add Header Line ( String line ) { m Lines . add ( line ) ; }
public static boolean has Column ( final C Connection connection , final String table Name , final String column Name ) { Preconditions . check Not Null ( column Name , STRING ) ; Preconditions . check Not Null ( table Name , STRING ) ; Preconditions . check Not Null ( connection , STRING ) ; final String query = String . format ( STRING + STRING , table Name , column Name ) ; try ( Result Set result = connection . execute Query ( query , BOOL ) ) { return result . first ( ) ; } catch ( final SQL Exception e ) { return BOOL ; } }
private String encode Parameters ( Map < String , String > params , String params Encoding ) { String Builder encoded Params = new String Builder ( ) ; try { for ( Map . Entry < String , String > entry : params . entry Set ( ) ) { encoded Params . append ( URL Encoder . encode ( entry . get Key ( ) , params Encoding ) ) ; encoded Params . append ( STRING ) ; encoded Params . append ( URL Encoder . encode ( entry . get Value ( ) , params Encoding ) ) ; encoded Params . append ( STRING ) ; } return encoded Params . to String ( ) ; } catch ( Unsupported Encoding Exception uee ) { throw new Runtime Exception ( STRING + params Encoding , uee ) ; } }
protected static String guess Type ( File file ) { String name = file . get Name ( ) ; String suffix = name . substring ( name . last Index Of ( STRING ) + NUM ) ; String type = mime Map . get ( suffix . to Lower Case ( Locale . ROOT ) ) ; return ( type != null ) ? type : STRING ; }
public void test Next All Terms ( ) throws Exception { List < String > terms List = new Array List < > ( ) ; terms List . add All ( Arrays . as List ( common Terms ) ) ; terms List . add All ( Arrays . as List ( medium Terms ) ) ; terms List . add All ( Arrays . as List ( rare Terms ) ) ; String terms [ ] = terms List . to Array ( new String [ NUM ] ) ; for ( int min Nr Should Match = NUM ; min Nr Should Match <= terms . length ; min Nr Should Match ++ ) { Scorer expected = scorer ( terms , min Nr Should Match , Mode . DOC VALUES ) ; Scorer actual = scorer ( terms , min Nr Should Match , Mode . SCORER ) ; assert Next ( expected , actual ) ; expected = scorer ( terms , min Nr Should Match , Mode . DOC VALUES ) ; actual = scorer ( terms , min Nr Should Match , Mode . BULK SCORER ) ; assert Next ( expected , actual ) ; } }
public boolean is Public ( ) { return Modifier . is Public ( method . get Modifiers ( ) ) ; }
public void form List Downloading Complete ( Hash Map < String , Form Details > result ) { dismiss Dialog ( PROGRESS DIALOG ) ; m Download Form List Task . set Downloader Listener ( null ) ; m Download Form List Task = null ; if ( result == null ) { Log . e ( t , STRING ) ; create Alert Dialog ( get String ( R . string . load remote form error ) , get String ( R . string . error occured ) , EXIT ) ; return ; } if ( result . contains Key ( Download Form List Task . DL AUTH REQUIRED ) ) { show Dialog ( AUTH DIALOG ) ; } else if ( result . contains Key ( Download Form List Task . DL ERROR MSG ) ) { String dialog Message = get String ( R . string . list failed with error , result . get ( Download Form List Task . DL ERROR MSG ) . error Str ) ; String dialog Title = get String ( R . string . load remote form error ) ; create Alert Dialog ( dialog Title , dialog Message , DO NOT EXIT ) ; } else { m Form Names And UR Ls = result ; m Form List . clear ( ) ; Array List < String > ids = new Array List < String > ( m Form Names And UR Ls . key Set ( ) ) ; for ( int i = NUM ; i < result . size ( ) ; i ++ ) { String form Details Key = ids . get ( i ) ; Form Details details = m Form Names And UR Ls . get ( form Details Key ) ; Hash Map < String , String > item = new Hash Map < String , String > ( ) ; item . put ( FORMNAME , details . form Name ) ; item . put ( FORMID DISPLAY , ( ( details . form Version == null ) ? STRING : ( get String ( R . string . version ) + STRING + details . form Version + STRING ) ) + STRING + details . form ID ) ; item . put ( FORMDETAIL KEY , form Details Key ) ; item . put ( FORM ID KEY , details . form ID ) ; item . put ( FORM VERSION KEY , details . form Version ) ; if ( m Form List . size ( ) == NUM ) { m Form List . add ( item ) ; } else { int j ; for ( j = NUM ; j < m Form List . size ( ) ; j ++ ) { Hash Map < String , String > compare Me = m Form List . get ( j ) ; String name = compare Me . get ( FORMNAME ) ; if ( name . compare To ( m Form Names And UR Ls . get ( ids . get ( i ) ) . form Name ) > NUM ) { break ; } } m Form List . add ( j , item ) ; } } select Superseded Forms ( ) ; m Form List Adapter . notify Data Set Changed ( ) ; m Download Button . set Enabled ( ! ( selected Item Count ( ) == NUM ) ) ; } }
native long create Drag Source ( Component component , Transferable transferable , Input Event native Trigger , int actions , long [ ] formats , Map format Map ) ;
private int put Length ( int len , Output Stream out ) throws IO Exception { int ret Val = NUM ; if ( len < NUM ) { out . write ( ( byte ) len ) ; ret Val = NUM ; } else if ( len < ( NUM << NUM ) ) { out . write ( ( byte ) NUM ) ; out . write ( ( byte ) len ) ; ret Val = NUM ; } else if ( len < ( NUM << NUM ) ) { out . write ( ( byte ) NUM ) ; out . write ( ( byte ) ( len > > NUM ) ) ; out . write ( ( byte ) len ) ; ret Val = NUM ; } else if ( len < ( NUM << NUM ) ) { out . write ( ( byte ) NUM ) ; out . write ( ( byte ) ( len > > NUM ) ) ; out . write ( ( byte ) ( len > > NUM ) ) ; out . write ( ( byte ) len ) ; ret Val = NUM ; } else { out . write ( ( byte ) NUM ) ; out . write ( ( byte ) ( len > > NUM ) ) ; out . write ( ( byte ) ( len > > NUM ) ) ; out . write ( ( byte ) ( len > > NUM ) ) ; out . write ( ( byte ) len ) ; ret Val = NUM ; } return ret Val ; }
boolean is Same Family ( HTML Font font ) { return ( ( family != null ) && ( font . get Family ( ) != null ) && ( family . equals ( font . get Family ( ) ) ) ) ; }
private T Input create Input ( String type , String name , String value ) { String out Val = value ; if ( value . contains ( STRING ) || value . contains ( STRING ) ) { if ( unique Sources . contains Key ( value ) && value . contains ( STRING ) ) { out Val = STRING + unique Sources . get ( value ) ; } else { int s = num Sources ; num Sources ++ ; unique Sources . put ( value , s ) ; out Val = STRING + s ; } } else if ( value . contains ( STRING ) ) { out Val = STRING ; } return new T Input ( type , name , out Val ) ; }
public String format ( Date Time Formatter formatter ) { Objects . require Non Null ( formatter , STRING ) ; return formatter . format ( this ) ; }
@ Dotted Class Name @ Suppress FB Warnings ( STRING ) public static String to Dotted Class Name ( @ Slashed Class Name ( when = When . UNKNOWN ) String class Name ) { if ( class Name . index Of ( STRING ) >= NUM ) { return Descriptor Factory . canonicalize String ( class Name . replace ( STRING , STRING ) ) ; } return class Name ; }
public D Authority Key Identifier ( J Dialog parent , byte [ ] value , Public Key authority Public Key ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; this . authority Public Key = authority Public Key ; init Components ( ) ; prepopulate With Value ( value ) ; }
private void play Previous ( ) { if ( media Type == Config . YOUTUBE MEDIA TYPE VIDEO ) { restart Video ( ) ; return ; } if ( next Was Called ) { iterator . previous ( ) ; next Was Called = BOOL ; } if ( ! iterator . has Previous ( ) ) { iterator = you Tube Videos . list Iterator ( you Tube Videos . size ( ) ) ; } video Item = iterator . previous ( ) ; previous Was Called = BOOL ; play Video ( ) ; }
public static Object invoke Declared ( Class c , Object obj , String method , Class [ ] param Classes , Object [ ] params ) throws Illegal Access Exception , No Such Method Exception , Invocation Target Exception { Method m = c . get Declared Method ( method , param Classes ) ; m . set Accessible ( BOOL ) ; return m . invoke ( obj , params ) ; }
public static Rotate Stream create ( String path ) throws Config Exception { synchronized ( format Streams ) { Weak Reference < Rotate Stream > ref = format Streams . get ( path ) ; Rotate Stream stream = ref != null ? ref . get ( ) : null ; if ( stream == null ) { stream = new Rotate Stream ( path ) ; format Streams . put ( path , new Weak Reference < Rotate Stream > ( stream ) ) ; } return stream ; } }
public synchronized void add ( Object obj ) { obj = copy ( obj ) ; if ( m History . contains ( obj ) ) { m History . remove ( obj ) ; } m History . insert Element At ( obj , NUM ) ; while ( m History . size ( ) > MAX HISTORY COUNT ) { m History . remove ( m History . size ( ) - NUM ) ; } }
public static String create Destination For Foldername ( String template , Movie movie ) { Pattern regex = Pattern . compile ( STRING ) ; Matcher mat = regex . matcher ( template ) ; while ( mat . find ( ) ) { template = template . replace ( mat . group ( NUM ) , replace Optional Variable ( mat . group ( NUM ) , movie , BOOL ) ) ; } return create Destination ( template , movie , BOOL ) ; }
public String next Token ( ) { int len = string . length ( ) ; int start = pos ; while ( start < len && del == string . char At ( start ) ) start ++ ; if ( start < len ) { pos = string . index Of ( del , start ) ; if ( start < pos && pos < len ) return string . substring ( start , pos ) ; else return string . substring ( start ) ; } throw new No Such Element Exception ( ) ; }
public boolean can Load ( Entity unit , boolean check Elev ) { if ( this instanceof Infantry ) { return BOOL ; } if ( ! unit . is Enemy Of ( this ) ) { Enumeration < Transporter > iter = transports . elements ( ) ; while ( iter . has More Elements ( ) ) { Transporter next = iter . next Element ( ) ; if ( next . can Load ( unit ) && ( ! check Elev || ( unit . get Elevation ( ) == get Elevation ( ) ) ) ) { return BOOL ; } } } return BOOL ; }
public static boolean read Boolean ( ) { String s = read String ( ) ; if ( s . equals Ignore Case ( STRING ) ) return BOOL ; if ( s . equals Ignore Case ( STRING ) ) return BOOL ; if ( s . equals ( STRING ) ) return BOOL ; if ( s . equals ( STRING ) ) return BOOL ; throw new Input Mismatch Exception ( ) ; }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case Functionblock Package . OPERATION NAME : return NAME EDEFAULT == null ? name != null : ! NAME EDEFAULT . equals ( name ) ; case Functionblock Package . OPERATION PARAMS : return params != null && ! params . is Empty ( ) ; case Functionblock Package . OPERATION RETURN TYPE : return return Type != null ; case Functionblock Package . OPERATION DESCRIPTION : return DESCRIPTION EDEFAULT == null ? description != null : ! DESCRIPTION EDEFAULT . equals ( description ) ; case Functionblock Package . OPERATION BREAKABLE : return breakable != BREAKABLE EDEFAULT ; } return super . e Is Set ( feature ID ) ; }
private void initialize Raw Source Code Map ( String raw Source ) { raw Source Code With Line = new Linked Hash Map < > ( ) ; int line Number = NUM ; String Reader sr = new String Reader ( raw Source ) ; Buffered Reader br = new Buffered Reader ( sr ) ; String line ; try { while ( ( line = br . read Line ( ) ) != null ) { if ( String Utils . is Not Blank ( line ) ) { raw Source Code With Line . put ( line Number , line ) ; line Number ++ ; } } } catch ( IO Exception ex ) { LOGGER . error ( STRING + ex . get Message ( ) ) ; } }
public static Matrix back Sub ( Matrix U , Matrix y ) { if ( y . rows ( ) != U . rows ( ) ) throw new Arithmetic Exception ( STRING ) ; Matrix x = new Dense Matrix ( U . cols ( ) , y . cols ( ) ) ; double [ ] x col k = new double [ y . rows ( ) ] ; final int start = Math . min ( U . rows ( ) , U . cols ( ) ) - NUM ; for ( int k = NUM ; k < y . cols ( ) ; k ++ ) { for ( int i = start ; i >= NUM ; i -- ) { x col k [ i ] = y . get ( i , k ) ; for ( int j = i + NUM ; j <= start ; j ++ ) x col k [ i ] -= U . get ( i , j ) * x col k [ j ] ; x col k [ i ] /= U . get ( i , i ) ; } for ( int i = NUM ; i < x col k . length ; i ++ ) if ( Double . is Infinite ( x col k [ i ] ) ) x . set ( i , k , NUM ) ; else x . set ( i , k , x col k [ i ] ) ; } return x ; }
private void record Visit Field ( Object object , Field object Field , Field field ) { Map < String , Set < String > > bag = visited Fields . get ( object ) ; if ( bag == null ) { bag = new Hash Map < > ( ) ; visited Fields . put ( object , bag ) ; } Set < String > fields = bag . get ( object Field ) ; String object Filed Key = object Field == null ? STRING : object Field . to Generic String ( ) ; if ( fields == null ) { fields = new Hash Set < > ( ) ; bag . put ( object Filed Key , fields ) ; } fields . add ( field . to Generic String ( ) ) ; }
public void remove Download ( Download Info Runnable download Info Runnable ) { m Completed List . remove ( download Info Runnable ) ; }
protected void add Shingled Phrase Queries ( final Boolean Query . Builder main Query , final List < Clause > clauses , final Collection < Field Params > fields , int shingle Size , final float tiebreaker , final int slop ) throws Syntax Error { if ( null == fields || fields . is Empty ( ) || null == clauses || clauses . size ( ) < shingle Size ) return ; if ( NUM == shingle Size ) shingle Size = clauses . size ( ) ; final int last Clause Index = shingle Size - NUM ; String Builder user Phrase Query = new String Builder ( ) ; for ( int i = NUM ; i < clauses . size ( ) - last Clause Index ; i ++ ) { user Phrase Query . append ( STRING ) ; for ( int j = NUM ; j <= last Clause Index ; j ++ ) { user Phrase Query . append ( clauses . get ( i + j ) . val ) ; user Phrase Query . append ( STRING ) ; } user Phrase Query . append ( STRING ) ; user Phrase Query . append ( STRING ) ; } Extended Solr Query Parser pp = create Edismax Query Parser ( this , IMPOSSIBLE FIELD NAME ) ; pp . add Alias ( IMPOSSIBLE FIELD NAME , tiebreaker , get Field Boosts ( fields ) ) ; pp . set Phrase Slop ( slop ) ; pp . set Remove Stop Filter ( BOOL ) ; pp . make Dismax = BOOL ; pp . min Clause Size = NUM ; Query phrase = pp . parse ( user Phrase Query . to String ( ) ) ; if ( phrase != null ) { main Query . add ( phrase , Boolean Clause . Occur . SHOULD ) ; } }
public static byte [ ] hex String To Bytes ( final String hex String ) { return Datatype Converter . parse Hex Binary ( hex String ) ; }
public boolean init Login ( ) { m cc = C Connection . get ( Adempiere . get Code Base Host ( ) ) ; host Field . set Value ( m cc ) ; if ( Ini . is Property Bool ( Ini . P VALIDATE CONNECTION ON STARTUP ) ) { validate Connection ( ) ; } user Text Field . set Text ( Ini . get Property ( Ini . P UID ) ) ; if ( Ini . is Property Bool ( Ini . P STORE PWD ) ) password Field . set Text ( Ini . get Property ( Ini . P PWD ) ) ; else password Field . set Text ( STRING ) ; language Combo . set Selected Item ( Ini . get Property ( Ini . P LANGUAGE ) ) ; if ( Ini . is Property Bool ( Ini . P A LOGIN ) ) { connection OK ( ) ; defaults OK ( ) ; if ( m connection OK ) m ok Pressed = BOOL ; return m connection OK ; } return BOOL ; }
public void snapshot ( Snapshot Index Commit snapshot Index Commit ) { logger . debug ( STRING , shard Id , snapshot Id , repository Name ) ; store . inc Ref ( ) ; try { final Map < String , Blob Meta Data > blobs ; try { blobs = blob Container . list Blobs ( ) ; } catch ( IO Exception e ) { throw new Index Shard Snapshot Failed Exception ( shard Id , STRING , e ) ; } long generation = find Latest File Name Generation ( blobs ) ; Tuple < Blob Store Index Shard Snapshots , Integer > tuple = build Blob Store Index Shard Snapshots ( blobs ) ; Blob Store Index Shard Snapshots snapshots = tuple . v1 ( ) ; int file List Generation = tuple . v2 ( ) ; final List < Blob Store Index Shard Snapshot . File Info > index Commit Point Files = new Array List < > ( ) ; int index Number Of Files = NUM ; long index Total Files Size = NUM ; Array List < File Info > files To Snapshot = new Array List < > ( ) ; final Store . Metadata Snapshot metadata ; try { metadata = store . get Metadata ( snapshot Index Commit ) ; } catch ( IO Exception e ) { throw new Index Shard Snapshot Failed Exception ( shard Id , STRING , e ) ; } for ( String file Name : snapshot Index Commit . get Files ( ) ) { if ( snapshot Status . aborted ( ) ) { logger . debug ( STRING , shard Id , snapshot Id , file Name ) ; throw new Index Shard Snapshot Failed Exception ( shard Id , STRING ) ; } logger . trace ( STRING , shard Id , snapshot Id , file Name ) ; final Store File Meta Data md = metadata . get ( file Name ) ; File Info existing File Info = null ; List < File Info > files Info = snapshots . find Physical Index Files ( file Name ) ; if ( files Info != null ) { for ( File Info file Info : files Info ) { try { maybe Recalculate Metadata Hash ( blob Container , file Info , metadata ) ; } catch ( Throwable e ) { logger . warn ( STRING , e , shard Id , file Info . physical Name ( ) , file Info . metadata ( ) ) ; } if ( file Info . is Same ( md ) && snapshot File Exists In Blobs ( file Info , blobs ) ) { existing File Info = file Info ; break ; } } } if ( existing File Info == null ) { index Number Of Files ++ ; index Total Files Size += md . length ( ) ; Blob Store Index Shard Snapshot . File Info snapshot File Info = new Blob Store Index Shard Snapshot . File Info ( file Name From Generation ( ++ generation ) , md , chunk Size ) ; index Commit Point Files . add ( snapshot File Info ) ; files To Snapshot . add ( snapshot File Info ) ; } else { index Commit Point Files . add ( existing File Info ) ; } } snapshot Status . files ( index Number Of Files , index Total Files Size ) ; if ( snapshot Status . aborted ( ) ) { logger . debug ( STRING , shard Id , snapshot Id ) ; throw new Index Shard Snapshot Failed Exception ( shard Id , STRING ) ; } snapshot Status . update Stage ( Index Shard Snapshot Status . Stage . STARTED ) ; for ( File Info snapshot File Info : files To Snapshot ) { try { snapshot File ( snapshot File Info ) ; } catch ( IO Exception e ) { throw new Index Shard Snapshot Failed Exception ( shard Id , STRING , e ) ; } } snapshot Status . index Version ( snapshot Index Commit . get Generation ( ) ) ; snapshot Status . update Stage ( Index Shard Snapshot Status . Stage . FINALIZE ) ; Blob Store Index Shard Snapshot snapshot = new Blob Store Index Shard Snapshot ( snapshot Id . get Snapshot ( ) , snapshot Index Commit . get Generation ( ) , index Commit Point Files , snapshot Status . start Time ( ) , System . current Time Millis ( ) - snapshot Status . start Time ( ) , index Number Of Files , index Total Files Size ) ; logger . trace ( STRING , shard Id , snapshot Id ) ; try { index Shard Snapshot Format . write ( snapshot , blob Container , snapshot Id . get Snapshot ( ) ) ; } catch ( IO Exception e ) { throw new Index Shard Snapshot Failed Exception ( shard Id , STRING , e ) ; } List < Snapshot Files > new Snapshots List = new Array List < > ( ) ; new Snapshots List . add ( new Snapshot Files ( snapshot . snapshot ( ) , snapshot . index Files ( ) ) ) ; for ( Snapshot Files point : snapshots ) { new Snapshots List . add ( point ) ; } finalize ( new Snapshots List , file List Generation + NUM , blobs ) ; snapshot Status . update Stage ( Index Shard Snapshot Status . Stage . DONE ) ; } finally { store . dec Ref ( ) ; } }
public final int store Session ( final Session session , final boolean invalidate Active ) { if ( session == null ) { Log . e ( TAG , STRING ) ; return NUM ; } if ( invalidate Active ) { invalidate Active Sessions ( ) ; } final Cursor cursor = content Resolver . query ( Content Uris . with Appended Id ( Content Provider . CONTENT URI SESSION , session . get Id ( ) ) , null , null , null , null ) ; if ( ! cursor . move To Next ( ) ) { store Session ( session ) ; cursor . close ( ) ; return NUM ; } else { Log . d ( TAG , STRING + session . get Id ( ) ) ; final Content Values values = new Content Values ( ) ; values . put ( Schema . COL CREATED AT , session . get Created At ( ) ) ; values . put ( Schema . COL LAST UPDATED , session . get Last Updated ( ) ) ; values . put ( Schema . COL DESCRIPTION , session . get Description ( ) ) ; values . put ( Schema . COL HAS BEEN EXPORTED , session . has Been Exported ( ) ) ; values . put ( Schema . COL IS ACTIVE , session . is Active ( ) ) ; values . put ( Schema . COL NUMBER OF CELLS , session . get Cells Count ( ) ) ; values . put ( Schema . COL NUMBER OF WIFIS , session . get Wifis Count ( ) ) ; values . put ( Schema . COL NUMBER OF WAYPOINTS , session . get Waypoints Count ( ) ) ; cursor . close ( ) ; return content Resolver . update ( Content Provider . CONTENT URI SESSION , values , Schema . COL ID + STRING , new String [ ] { String . value Of ( session . get Id ( ) ) } ) ; } }
public boolean check For Dangerous Props ( ) { final Map < String , String > dangerous Props = new Hash Map < String , String > ( ) ; dangerous Props . put ( STRING , STRING ) ; dangerous Props . put ( STRING , STRING ) ; boolean result = BOOL ; String [ ] lines = props Reader ( ) ; for ( String line : lines ) { for ( String key : dangerous Props . key Set ( ) ) { if ( line . contains ( key ) ) { String bad Value = dangerous Props . get ( key ) ; bad Value = STRING + bad Value + STRING ; if ( line . contains ( bad Value ) ) { Q Log . v ( key + STRING + bad Value + STRING ) ; result = BOOL ; } } } } return result ; }
public Builder delete Roles ( ) { delete Fields . add ( STRING ) ; return this ; }
protected void process Play Request ( ) { try To Get Audio Focus ( ) ; if ( m State == State . STOPPED ) { play Media ( ) ; } else if ( m State == State . PAUSED ) { m State = State . PLAYING ; set Up As Foreground ( String . format ( get String ( R . string . media state playing ) , m File . get File Name ( ) ) ) ; config And Start Media Player ( ) ; } }
private void parse Create Column ( Table Builder Kraken factory , String name ) { Token token ; if ( ( token = scan Token ( ) ) != Token . IDENTIFIER ) { throw error ( L . l ( STRING , token ) ) ; } String type = lexeme ; int length = - NUM ; int scale = - NUM ; if ( type . equals Ignore Case ( STRING ) ) { if ( ( token = peek Token ( ) ) == Token . IDENTIFIER ) { scan Token ( ) ; if ( lexeme . equals Ignore Case ( STRING ) ) { } else throw error ( L . l ( STRING , lexeme ) ) ; } } if ( ( token = peek Token ( ) ) == Token . LPAREN ) { scan Token ( ) ; if ( ( token = scan Token ( ) ) != Token . INTEGER ) { throw error ( STRING , token ) ; } length = Integer . parse Int ( lexeme ) ; if ( ( token = scan Token ( ) ) == Token . COMMA ) { if ( ( token = scan Token ( ) ) != Token . INTEGER ) { throw error ( STRING , token ) ; } scale = Integer . parse Int ( lexeme ) ; token = scan Token ( ) ; } if ( token != Token . RPAREN ) { throw error ( STRING , token ) ; } } if ( type . equals Ignore Case ( STRING ) ) { factory . add Varchar ( name , length ) ; } else if ( type . equals Ignore Case ( STRING ) ) { factory . add Blob ( name ) ; } else if ( type . equals Ignore Case ( STRING ) ) { factory . add String ( name ) ; } else if ( type . equals Ignore Case ( STRING ) ) { factory . add Object ( name ) ; } else if ( type . equals Ignore Case ( STRING ) ) { length = Math . max ( length , NUM ) ; factory . add Varchar ( name , length ) ; } else if ( type . equals Ignore Case ( STRING ) ) { if ( length < NUM ) { throw error ( STRING ) ; } factory . add Varbinary ( name , length ) ; } else if ( type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) ) { if ( length < NUM ) throw error ( L . l ( STRING ) ) ; factory . add Bytes ( name , length ) ; } else if ( type . equals Ignore Case ( STRING ) ) { factory . add Varchar ( name , NUM ) ; } else if ( type . equals Ignore Case ( STRING ) ) { factory . add Varchar ( name , NUM ) ; } else if ( type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) ) { factory . add Bool ( name ) ; } else if ( type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) ) { factory . add Int 8 ( name ) ; } else if ( type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) ) { factory . add Int 16 ( name ) ; } else if ( type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) ) { factory . add Int 32 ( name ) ; } else if ( type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) ) { factory . add Int 64 ( name ) ; } else if ( type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) ) { factory . add Double ( name ) ; } else if ( type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) ) { factory . add Float ( name ) ; } else if ( type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) ) { factory . add Date Time ( name ) ; } else if ( type . equals Ignore Case ( STRING ) || type . equals Ignore Case ( STRING ) ) { factory . add Varchar ( name , NUM ) ; } else if ( type . equals Ignore Case ( STRING ) ) { factory . add Identity ( name ) ; } else throw error ( L . l ( STRING , type ) ) ; while ( BOOL ) { token = scan Token ( ) ; switch ( token ) { case RPAREN : case COMMA : token = token ; return ; case PRIMARY : token = scan Token ( ) ; if ( token != Token . KEY ) throw error ( STRING , token ) ; factory . set Primary Key ( name ) ; break ; case NULL : break ; case NOT : if ( ( token = scan Token ( ) ) == Token . NULL ) factory . set Not Null ( name ) ; else throw error ( STRING , token ) ; break ; default : throw error ( STRING , token ) ; } } }
static Class Loader create Loader ( ) { List < URL > urls = new Array List < > ( ) ; for ( String name : new String [ ] { STRING , STRING } ) { String value = System . get Property ( name ) ; if ( value != null ) { add UR Ls From Path ( urls , value ) ; } } for ( int i = NUM ; add Patch Paths ( urls , i ) ; i ++ ) { } return new URL Class Loader ( urls . to Array ( new URL [ urls . size ( ) ] ) ) ; }
public long skip ( long n ) throws IO Exception { return f Input Stream . skip ( n ) ; }
public void update ( int fps , float angle ) { double speed = ( SPEED / FPS ) * Math . log ( radius ) ; y -= speed ; x += amp * Math . sin ( freq * ( step ++ * speed ) ) + skew ; if ( radius < max Radius ) { radius += max Radius / ( ( ( float ) fps / SPEED ) * radius ) ; if ( radius > max Radius ) radius = max Radius ; } }
private void check Group List ( List < Principal Id > group List , Principal Id subject ) throws Invalid Token Exception , System Exception { Principal Attribute Definition group Attribute Definition = get Supported Attribute Definition ( GROUP ) ; if ( group Attribute Definition == null ) { throw new Invalid Token Exception ( GROUP + STRING ) ; } final Principal Attribute group Attribute ; try { group Attribute = get Attribute ( subject , group Attribute Definition ) ; } catch ( Invalid Principal Exception e ) { throw new Invalid Token Exception ( String . format ( STRING , subject ) , e ) ; } List < Principal Id > current Group List = to Group List ( group Attribute . get Values ( ) ) ; List < Principal Id > token Group List = group List ; if ( token Group List . size ( ) != current Group List . size ( ) || ! token Group List . contains All ( current Group List ) ) { throw new Invalid Token Exception ( STRING + STRING ) ; } }
public void add Header ( String name , String value ) { if ( custom Headers == null ) { custom Headers = new Hash Map < > ( NUM ) ; } List < String > header = custom Headers . get ( name ) ; if ( header == null ) { header = new Array List < > ( ) ; custom Headers . put ( name , header ) ; } header . add ( value ) ; }

public static String convert String To Html ( String s ) { if ( s == null ) { return null ; } if ( s . length ( ) == NUM ) { return s ; } String Builder buff = new String Builder ( ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char ch = s . char At ( i ) ; String token = CODE MAP . get ( ch ) ; if ( token == null ) { if ( ch < NUM ) { buff . append ( ch ) ; } else { buff . append ( STRING ) ; buff . append ( STRING ) ; buff . append ( ( int ) ch ) ; buff . append ( STRING ) ; } } else { buff . append ( STRING ) ; buff . append ( token ) ; buff . append ( STRING ) ; } } return buff . to String ( ) ; }
protected Map < String , Raml Query Parameter > extract Query Parameters ( Raml Action Type api Action , Method method , Map < String , String > parameter Comments ) { if ( api Action . equals ( Raml Action Type . POST ) || method . get Parameter Count ( ) == NUM ) { return Collections . empty Map ( ) ; } Map < String , Raml Query Parameter > query Params = new Linked Hash Map < > ( ) ; for ( Parameter param : method . get Parameters ( ) ) { if ( is Query Parameter ( param ) ) { Raml Param Type simple Type = Schema Helper . map Simple Type ( param . get Type ( ) ) ; if ( simple Type == null ) { query Params . put All ( Schema Helper . convert Class To Query Parameters ( param , java Docs . get Java Doc ( param . get Type ( ) ) ) ) ; } else { String param Comment = parameter Comments . get ( param . get Name ( ) ) ; query Params . put All ( Schema Helper . convert Parameter To Query Parameter ( param , param Comment ) ) ; } } } return query Params ; }
public final T end ( int i ) { while ( i -- > NUM && ! tag Stack . is Empty ( ) ) { end ( ) ; } return get Self ( ) ; }
public static Table Meta create Temp ODPS Table ( Table Info table Meta , int life Cycle ) { Table Meta temp Table = new Table Meta ( ) ; temp Table . set Comment ( table Meta . get Comments ( ) ) ; temp Table . set Life Cycle ( life Cycle ) ; String table Schema = table Meta . get Table Schema ( ) ; String table Name = table Meta . get Table Name ( ) ; temp Table . set Table Name ( generate Temp Table Name ( table Schema , table Name ) ) ; List < Field Schema > temp Columns = new Array List < Field Schema > ( ) ; List < Column Info > columns = table Meta . get Columns ( ) ; for ( Column Info column : columns ) { Field Schema temp Column = new Field Schema ( ) ; temp Column . set Name ( column . get Name ( ) ) ; temp Column . set Type ( to ODPS Data Type ( column . get Data Type ( ) ) ) ; temp Column . set Comment ( column . get Comment ( ) ) ; temp Columns . add ( temp Column ) ; } temp Table . set Cols ( temp Columns ) ; temp Table . set Partition Keys ( null ) ; return temp Table ; }
private void parse And Init Values ( String encoded Description ) { check Not Blank ( encoded Description , STRING ) ; String [ ] token = TOKEN SEPARATOR PATTERN . split ( encoded Description ) ; check Argument ( token . length > NUM , STRING ) ; int next Index = NUM ; String next = token [ next Index ++ ] ; Default Alignment alignment = Default Alignment . value Of ( next , is Horizontal ( ) ) ; if ( alignment != null ) { set Default Alignment ( alignment ) ; check Argument ( token . length > NUM , STRING ) ; next = token [ next Index ++ ] ; } set Size ( parse Size ( next ) ) ; if ( next Index < token . length ) { set Resize Weight ( parse Resize Weight ( token [ next Index ] ) ) ; } }
private void assert Read Varint ( byte [ ] data , long value ) throws Exception { Coded Input Stream input = Coded Input Stream . new Instance ( data ) ; assert Equals ( ( int ) value , input . read Raw Varint 32 ( ) ) ; input = Coded Input Stream . new Instance ( data ) ; assert Equals ( value , input . read Raw Varint 64 ( ) ) ; assert True ( input . is At End ( ) ) ; for ( int block Size = NUM ; block Size <= NUM ; block Size *= NUM ) { input = Coded Input Stream . new Instance ( new Small Block Input Stream ( data , block Size ) ) ; assert Equals ( ( int ) value , input . read Raw Varint 32 ( ) ) ; input = Coded Input Stream . new Instance ( new Small Block Input Stream ( data , block Size ) ) ; assert Equals ( value , input . read Raw Varint 64 ( ) ) ; assert True ( input . is At End ( ) ) ; } byte [ ] longer Data = new byte [ data . length + NUM ] ; System . arraycopy ( data , NUM , longer Data , NUM , data . length ) ; Input Stream raw Input = new Byte Array Input Stream ( longer Data ) ; assert Equals ( ( int ) value , Coded Input Stream . read Raw Varint 32 ( raw Input ) ) ; assert Equals ( NUM , raw Input . available ( ) ) ; }

public void write Field ( String name , double value ) throws java . io . IO Exception { write Field ( name , Double . to String ( value ) ) ; }
public void remove Players Monsters ( ) { for ( final Creature creature : spawned Creatures ) { final Stendhal RP Zone monster Zone = creature . get Zone ( ) ; if ( monster Zone != null ) { monster Zone . remove ( creature ) ; } } }
public static java . sql . Time to Sql Time ( String hour Str , String minute Str , String second Str ) { java . util . Date new Date = to Date ( STRING , STRING , STRING , hour Str , minute Str , second Str ) ; if ( new Date != null ) { return new java . sql . Time ( new Date . get Time ( ) ) ; } else { return null ; } }
@ Override @ Graph Transaction public void delete Trait ( String guid , String trait Name To Be Deleted ) throws Trait Not Found Exception , Entity Not Found Exception , Repository Exception { LOG . debug ( STRING , trait Name To Be Deleted , guid ) ; Atlas Vertex instance Vertex = graph Helper . get Vertex For GUID ( guid ) ; List < String > trait Names = Graph Helper . get Trait Names ( instance Vertex ) ; if ( ! trait Names . contains ( trait Name To Be Deleted ) ) { throw new Trait Not Found Exception ( STRING + trait Name To Be Deleted + STRING + guid ) ; } try { final String entity Type Name = Graph Helper . get Type Name ( instance Vertex ) ; String relationship Label = Graph Helper . get Trait Label ( entity Type Name , trait Name To Be Deleted ) ; Atlas Edge edge = graph Helper . get Edge For Label ( instance Vertex , relationship Label ) ; if ( edge != null ) { delete Handler . delete Edge Reference ( edge , Data Types . Type Category . TRAIT , BOOL , BOOL ) ; trait Names . remove ( trait Name To Be Deleted ) ; update Traits ( instance Vertex , trait Names ) ; } } catch ( Exception e ) { throw new Repository Exception ( e ) ; } }
public void add Columns ( Collection < Column > columns ) { for ( Iterator < Column > it = columns . iterator ( ) ; it . has Next ( ) ; ) { add Column ( ( Column ) it . next ( ) ) ; } }
void save Offset In External Store ( String topic , int partition , long offset ) { try { File Writer writer = new File Writer ( storage Name ( topic , partition ) , BOOL ) ; Buffered Writer buffered Writer = new Buffered Writer ( writer ) ; buffered Writer . write ( offset + STRING ) ; buffered Writer . flush ( ) ; buffered Writer . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( e ) ; } }
public static String slurp URL No Exceptions ( URL u ) { try { return slurp URL ( u ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
protected synchronized void stop Loading ( ) { if ( loader Thread != null ) { loader Thread . interrupt ( ) ; } else { set Load Abort Request ( ) ; } }
void remove Item ( final Rounded Tool Item rounded Tool Item ) { check Widget ( ) ; items . remove ( rounded Tool Item ) ; }
public void add Attribute ( String alias , String type Uri , String value ) throws Message Exception { if ( alias . index Of ( STRING ) > - NUM || alias . index Of ( STRING ) > - NUM || alias . index Of ( STRING ) > - NUM || alias . index Of ( STRING ) > - NUM ) throw new Message Exception ( STRING + alias ) ; int count = get Count ( alias ) ; String index = STRING ; switch ( count ) { case NUM : parameters . set ( new Parameter ( STRING + alias , type Uri ) ) ; break ; case NUM : parameters . set ( new Parameter ( STRING + alias + STRING , get Parameter Value ( STRING + alias ) ) ) ; parameters . remove Parameters ( STRING + alias ) ; index = STRING ; break ; default : index = STRING + Integer . to String ( count + NUM ) ; } parameters . set ( new Parameter ( STRING + alias + index , value ) ) ; set Count ( alias , ++ count ) ; if ( DEBUG ) log . debug ( STRING + type Uri + STRING + alias + STRING + count ) ; }
protected void execute Tasks ( final Access Path Task [ ] tasks ) throws Exception { if ( executor == null ) { for ( Access Path Task task : tasks ) { task . call ( ) ; } return ; } final List < Future Task < Void > > future Tasks = new Linked List < Future Task < Void > > ( ) ; for ( Access Path Task task : tasks ) { final Future Task < Void > ft = new Future Task < Void > ( task ) ; future Tasks . add ( ft ) ; } try { for ( Future Task < Void > ft : future Tasks ) { if ( halt ) throw new Runtime Exception ( first Cause . get ( ) ) ; executor . execute ( ft ) ; } for ( Future Task < Void > ft : future Tasks ) { if ( ! halt ) ft . get ( ) ; } } finally { for ( Future Task < Void > ft : future Tasks ) { ft . cancel ( BOOL ) ; } } }
private void fetch File List ( long gen ) throws IO Exception { Modifiable Solr Params params = new Modifiable Solr Params ( ) ; params . set ( COMMAND , CMD GET FILE LIST ) ; params . set ( GENERATION , String . value Of ( gen ) ) ; params . set ( Common Params . WT , STRING ) ; params . set ( Common Params . QT , STRING ) ; Query Request req = new Query Request ( params ) ; Http Solr Server server = new Http Solr Server ( master Url , my Http Client ) ; try { server . set So Timeout ( NUM ) ; server . set Connection Timeout ( NUM ) ; Named List response = server . request ( req ) ; List < Map < String , Object > > files = ( List < Map < String , Object > > ) response . get ( CMD GET FILE LIST ) ; if ( files != null ) files To Download = Collections . synchronized List ( files ) ; else { files To Download = Collections . empty List ( ) ; LOG . error ( STRING + gen ) ; } files = ( List < Map < String , Object > > ) response . get ( CONF FILES ) ; if ( files != null ) conf Files To Download = Collections . synchronized List ( files ) ; } catch ( Solr Server Exception e ) { throw new IO Exception ( e ) ; } finally { server . shutdown ( ) ; } }
static private String user Id From Range With Mod ( String [ ] values , boolean include ) { int min Id = Integer . parse Int ( values [ NUM ] ) ; int max Id = Integer . parse Int ( values [ NUM ] ) ; int mod = Integer . parse Int ( values [ NUM ] ) ; Stack < Integer > stack = get Stack With Mods ( min Id , max Id , mod , include ) ; if ( stack . size ( ) > NUM ) { return Integer . to String ( stack . pop ( ) ) ; } throw new Illegal Argument Exception ( STRING ) ; }
public boolean wait Until Started ( int timeout ) { int cnt = NUM ; while ( cnt < timeout ) { if ( is Started ( ) ) { log . info ( STRING ) ; return BOOL ; } sleep ( NUM ) ; cnt ++ ; } return BOOL ; }
public static void write Parity Flag ( final I Translation Environment environment , final long offset , final Operand Size result Size , final String result , final List < Reil Instruction > instructions ) throws Illegal Argument Exception { Preconditions . check Not Null ( environment , STRING ) ; Preconditions . check Not Null ( result Size , STRING ) ; Preconditions . check Not Null ( result , STRING ) ; Preconditions . check Not Null ( instructions , STRING ) ; final String temp Reg = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create Str ( offset , result Size , result , result Size , temp Reg ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset + NUM , result Size , temp Reg , Operand Size . BYTE , STRING , result Size , Helpers . PARITY FLAG ) ) ; instructions . add ( Reil Helpers . create Xor ( offset + NUM , result Size , temp Reg , result Size , Helpers . PARITY FLAG , result Size , Helpers . PARITY FLAG ) ) ; instructions . add ( Reil Helpers . create And ( offset + NUM , result Size , Helpers . PARITY FLAG , result Size , String . value Of ( NUM ) , Operand Size . WORD , Helpers . PARITY FLAG ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset + NUM , Operand Size . WORD , String . value Of ( NUM ) , Operand Size . WORD , Helpers . PARITY FLAG , Operand Size . WORD , Helpers . PARITY FLAG ) ) ; instructions . add ( Reil Helpers . create And ( offset + NUM , Operand Size . WORD , Helpers . PARITY FLAG , Operand Size . WORD , String . value Of ( NUM ) , Operand Size . WORD , Helpers . PARITY FLAG ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset + NUM , Operand Size . WORD , Helpers . PARITY FLAG , Operand Size . BYTE , STRING , Operand Size . BYTE , Helpers . PARITY FLAG ) ) ; }
@ Override public void apply ( Nexus Stream Parser np ) throws Exception { np . match Ignore Case ( get Syntax ( ) ) ; if ( get Parent ( ) instanceof Overlap Graph Viewer ) { final Overlap Graph Viewer overlap Graph Viewer = ( Overlap Graph Viewer ) get Parent ( ) ; final Graph View graph View = overlap Graph Viewer . get Graph View ( ) ; final Node Map < String > node 2 Read Name Map = overlap Graph Viewer . get Node 2 Read Name Map ( ) ; final Set < String > previous Selection = Project Manager . get Previously Selected Node Labels ( ) ; if ( previous Selection . size ( ) > NUM ) { Graph graph = graph View . get Graph ( ) ; Node Set to Select = new Node Set ( graph ) ; for ( Node v = graph . get First Node ( ) ; v != null ; v = graph . get Next Node ( v ) ) { String label = node 2 Read Name Map . get ( v ) ; if ( label != null && previous Selection . contains ( label ) ) to Select . add ( v ) ; } if ( to Select . size ( ) > NUM ) { graph View . set Selected ( to Select , BOOL ) ; graph View . repaint ( ) ; } } } }
public static boolean contains Type Parameter ( Type type ) { if ( type . is Type Parameter ( ) ) return BOOL ; for ( Type pt : type . get Type Argument List ( ) ) { if ( contains Type Parameter ( pt ) ) { return BOOL ; } } if ( type . is Intersection ( ) ) { List < Type > types = type . get Satisfied Types ( ) ; for ( int i = NUM , l = types . size ( ) ; i < l ; i ++ ) { if ( contains Type Parameter ( types . get ( i ) ) ) return BOOL ; } return BOOL ; } if ( type . is Union ( ) ) { List < Type > types = type . get Case Types ( ) ; for ( int i = NUM , l = types . size ( ) ; i < l ; i ++ ) { if ( contains Type Parameter ( types . get ( i ) ) ) return BOOL ; } return BOOL ; } return BOOL ; }
public static void load Excludes Resource ( String resource Name ) throws IO Exception { excludes . clear ( ) ; excludes . put All ( load Properties From Resource ( resource Name ) ) ; }
public static void safe Close ( Input Stream in ) { try { if ( in != null ) in . close ( ) ; } catch ( IO Exception e ) { } }
public Configurable Jta Platform ( Transaction Manager tm , User Transaction ut ) { Assert . not Null ( tm , STRING ) ; this . transaction Manager = tm ; this . user Transaction = ( ut != null ? ut : new User Transaction Adapter ( tm ) ) ; }
public char skip Until ( String skip ) throws IO Exception { char ch ; do { ch = read Character ( ) ; } while ( skip . index Of ( ch ) == - NUM ) ; return ch ; }
private boolean contains Mapping ( Object key , Object value ) { if ( key == null ) { Hash Map Entry < K , V > e = entry For Null Key ; return e != null && Objects . equals ( value , e . value ) ; } int hash = secondary Hash ( key ) ; Hash Map Entry < K , V > [ ] tab = table ; int index = hash & ( tab . length - NUM ) ; for ( Hash Map Entry < K , V > e = tab [ index ] ; e != null ; e = e . next ) { if ( e . hash == hash && key . equals ( e . key ) ) { return Objects . equals ( value , e . value ) ; } } return BOOL ; }
public void sync Download Poi Box ( final Box box ) { if ( Flavor Utils . is Poi Storage ( ) ) { sync Download Poi Types ( ) ; } List < Poi > pois = backend . get Pois In Box ( box ) ; if ( pois . size ( ) > NUM ) { Timber . d ( STRING , pois . size ( ) ) ; poi Manager . merge From Osm Pois ( pois , box ) ; } else { Timber . d ( STRING ) ; } }
private void create Element ( Document doc , Element parent Element , String element Name , int value ) { Element element = doc . create Element ( element Name ) ; element . append Child ( doc . create Text Node ( Integer . to String ( value ) ) ) ; parent Element . append Child ( element ) ; }
public static void to Do ( @ Scope int scope , String tag ) { List < Long > tag Seen List = tag Last Seen Map . get ( tag ) ; if ( tag Seen List . is Empty ( ) ) { to Do Set . put ( tag ) ; return ; } Long tag Last Seen = tag Seen List . get ( tag Seen List . size ( ) - NUM ) ; if ( scope == THIS APP VERSION && tag Last Seen <= last App Updated Time ) { to Do Set . put ( tag ) ; } }
void variable Negation Changed ( int row , String oper ) { Conditional Variable variable = variable List . get ( row ) ; boolean state = variable . is Negated ( ) ; if ( oper == null ) { variable . set Negation ( BOOL ) ; } else { variable . set Negation ( oper . equals ( Bundle . get Message ( STRING ) ) ) ; } if ( variable . is Negated ( ) != state ) { make Antecedent ( ) ; } }
private void add Internal Header Fields ( String name , String value ) { String key = name . to Upper Case ( ) ; Vector < String > v = get Headers ( key ) ; if ( v == null ) { v = new Vector < > ( ) ; m Header Fields . put ( key , v ) ; } if ( value != null ) { v . add ( value ) ; } else { m Header Fields . remove ( key ) ; } }
public void load Lua Script ( final Redis Command redis Command , int execution Counter ) { final int execution Counter Incr = ++ execution Counter ; redis Client . script Exists ( this . sha , null ) ; }
View find Hidden Non Removed View ( int position , int type ) { final int count = m Hidden Views . size ( ) ; for ( int i = NUM ; i < count ; i ++ ) { final View view = m Hidden Views . get ( i ) ; Recycler View . View Holder holder = m Callback . get Child View Holder ( view ) ; if ( holder . get Position ( ) == position && ! holder . is Invalid ( ) && ( type == Recycler View . INVALID TYPE || holder . get Item View Type ( ) == type ) ) { return view ; } } return null ; }
public static boolean delete Recursive ( File file Or Directory ) { if ( file Or Directory . is Directory ( ) ) { File [ ] list = file Or Directory . list Files ( ) ; if ( list == null ) { return BOOL ; } for ( File f : list ) { if ( ! delete Recursive ( f ) ) { return BOOL ; } } } if ( ! file Or Directory . delete ( ) ) { if ( file Or Directory . exists ( ) ) { return BOOL ; } } return BOOL ; }
boolean is Tool Bar Button ( J Component c ) { return ( c . get Parent ( ) instanceof J Tool Bar ) ; }
private Priority Queue < Score Term > create Queue ( Map < String , Int > words , String ... field Names ) throws IO Exception { int num Docs = ir . num Docs ( ) ; final int limit = Math . min ( max Query Terms , words . size ( ) ) ; Freq Q queue = new Freq Q ( limit ) ; for ( String word : words . key Set ( ) ) { int tf = words . get ( word ) . x ; if ( min Term Freq > NUM && tf < min Term Freq ) { continue ; } String top Field = field Names [ NUM ] ; int doc Freq = NUM ; for ( String field Name : field Names ) { int freq = ir . doc Freq ( new Term ( field Name , word ) ) ; top Field = ( freq > doc Freq ) ? field Name : top Field ; doc Freq = ( freq > doc Freq ) ? freq : doc Freq ; } if ( min Doc Freq > NUM && doc Freq < min Doc Freq ) { continue ; } if ( doc Freq > max Doc Freq ) { continue ; } if ( doc Freq == NUM ) { continue ; } float idf = similarity . idf ( doc Freq , num Docs ) ; float score = tf * idf ; if ( queue . size ( ) < limit ) { queue . add ( new Score Term ( word , top Field , score , idf , doc Freq , tf ) ) ; } else { Score Term term = queue . top ( ) ; if ( term . score < score ) { term . update ( word , top Field , score , idf , doc Freq , tf ) ; queue . update Top ( ) ; } } } return queue ; }
@ Suppress Warnings ( STRING ) public static < Value T > Value T to Object ( Byte Buffer bf ) throws IO Exception , Class Not Found Exception { Object obj = null ; Input Stream is = null ; Object Input Stream ois = null ; try { is = new Byte Buffer Backed Input Stream ( bf ) ; ois = new Object Input Stream ( is ) ; obj = ois . read Object ( ) ; } finally { if ( is != null ) { is . close ( ) ; } if ( ois != null ) { ois . close ( ) ; } } return ( Value T ) obj ; }
public void exit ( int status ) { System . exit ( status ) ; }
public static double along Track Distance Rad ( double lat 1 , double lon 1 , double lat 2 , double lon 2 , double lat Q , double lon Q , double dist 1 Q , double ctd ) { int sign = Math . abs ( bearing Rad ( lat 1 , lon 1 , lat 2 , lon 2 ) - bearing Rad ( lat 1 , lon 1 , lat Q , lon Q ) ) < Math Util . HALFPI ? + NUM : - NUM ; return sign * Math . acos ( Math . cos ( dist 1 Q ) / Math . cos ( ctd ) ) ; }
@ Override public void process Challenge ( final String challenge ) throws Malformed Challenge Exception { final String s = Auth Challenge Parser . extract Scheme ( challenge ) ; if ( ! s . equals Ignore Case ( get Scheme Name ( ) ) ) { throw new Malformed Challenge Exception ( STRING + get Scheme Name ( ) + STRING + challenge ) ; } params = Auth Challenge Parser . extract Params ( challenge ) ; }
public static Big Integer calculate Gx ( Big Integer p , Big Integer g , Big Integer x ) { return g . mod Pow ( x , p ) ; }
public static boolean create Shipment ( M Acct Schema as , int AD Org ID , int M Product ID , int M Attribute Set Instance ID , int M In Out Line ID , int M Cost Element ID , Big Decimal Amt , Big Decimal Qty , String Description , boolean Is SO Trx , String trx Name ) { String sql = STRING + STRING + STRING + M In Out Line ID + STRING + as . get C Acct Schema ID ( ) + STRING + M Attribute Set Instance ID ; int no = DB . execute Update ( sql , trx Name ) ; if ( no != NUM ) s log . config ( STRING + no ) ; M Cost Detail cd = get ( as . get Ctx ( ) , STRING , M In Out Line ID , M Attribute Set Instance ID , as . get C Acct Schema ID ( ) , trx Name ) ; if ( cd == null ) { cd = new M Cost Detail ( as , AD Org ID , M Product ID , M Attribute Set Instance ID , M Cost Element ID , Amt , Qty , Description , trx Name ) ; cd . set M In Out Line ID ( M In Out Line ID ) ; cd . set Is SO Trx ( Is SO Trx ) ; } else { cd . set Delta Amt ( Amt . subtract ( cd . get Amt ( ) ) ) ; cd . set Delta Qty ( Qty . subtract ( cd . get Qty ( ) ) ) ; if ( cd . is Delta ( ) ) { cd . set Processed ( BOOL ) ; cd . set Amt ( Amt ) ; cd . set Qty ( Qty ) ; } else return BOOL ; } boolean ok = cd . save ( ) ; if ( ok && ! cd . is Processed ( ) ) { M Client client = M Client . get ( as . get Ctx ( ) , as . get AD Client ID ( ) ) ; if ( client . is Cost Immediate ( ) ) cd . process ( ) ; } s log . config ( STRING + ok + STRING + cd ) ; return ok ; }
protected synchronized void remember Last Thing ( Undo Event event ) { if ( undo Stack . size ( ) >= stack Size ) { undo Stack . remove Element At ( NUM ) ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + event . get Description ( ) + STRING ) ; } undo Stack . push ( event ) ; }
private static void use Cache Or Online Repository ( ) { if ( REP MIRROR == null ) { establish Mirror ( ) ; } if ( CACHE URL != null ) { PACKAGE MANAGER . set Package Repository URL ( CACHE URL ) ; } else if ( REP URL != null ) { PACKAGE MANAGER . set Package Repository URL ( REP URL ) ; } }
public List < Snapshot > snapshots ( String repository Name ) { Set < Snapshot > snapshot Set = new Hash Set ( ) ; List < Snapshots In Progress . Entry > entries = current Snapshots ( repository Name , null ) ; for ( Snapshots In Progress . Entry entry : entries ) { snapshot Set . add ( in Progress Snapshot ( entry ) ) ; } Repository repository = repositories Service . repository ( repository Name ) ; List < Snapshot Id > snapshot Ids = repository . snapshots ( ) ; for ( Snapshot Id snapshot Id : snapshot Ids ) { snapshot Set . add ( repository . read Snapshot ( snapshot Id ) ) ; } Array List < Snapshot > snapshot List = new Array List < > ( snapshot Set ) ; Collection Util . tim Sort ( snapshot List ) ; return Collections . unmodifiable List ( snapshot List ) ; }
public void add Static Method Call ( String owner , String method Name , String target Class , String target Method ) { Static Method Call Entry call = new Static Method Call Entry ( owner , method Name , target Class , target Method ) ; logger . info ( STRING + call . to String ( ) ) ; static Method Calls . add ( call ) ; }
protected void paint Content Border Right Edge ( Graphics g , int tab Placement , int selected Index , int x , int y , int w , int h ) { Rectangle sel Rect = selected Index < NUM ? null : get Tab Bounds ( selected Index , calc Rect ) ; g . set Color ( shadow ) ; if ( tab Placement != RIGHT || selected Index < NUM || ( sel Rect . y < y || sel Rect . y > y + h ) ) { g . set Color ( dark Shadow ) ; g . draw Line ( x + w - NUM , y , x + w - NUM , y + h - NUM ) ; } else { g . set Color ( dark Shadow ) ; g . draw Line ( x + w - NUM , y , x + w - NUM , sel Rect . y ) ; if ( sel Rect . y + sel Rect . height < y + h - NUM ) { g . set Color ( dark Shadow ) ; g . draw Line ( x + w - NUM , sel Rect . y + sel Rect . height , x + w - NUM , y + h - NUM ) ; } } }
public Frontier Query build Frontier Query ( Bytes Ref Hash collector Terms , Integer frontier Size ) { if ( collector Terms == null || collector Terms . size ( ) == NUM ) { return null ; } else { Query q = null ; if ( use Autn ) { Automaton autn = build Automaton ( collector Terms ) ; Automaton Query autn Query = new Automaton Query ( new Term ( from Field ) , autn ) ; q = autn Query ; } else { List < Bytes Ref > term List = new Array List < > ( collector Terms . size ( ) ) ; for ( int i = NUM ; i < collector Terms . size ( ) ; i ++ ) { Bytes Ref ref = new Bytes Ref ( ) ; collector Terms . get ( i , ref ) ; term List . add ( ref ) ; } q = new Terms Query ( from Field , term List ) ; } if ( traversal Filter != null ) { Boolean Query . Builder builder = new Boolean Query . Builder ( ) ; builder . add ( q , Occur . MUST ) ; builder . add ( traversal Filter , Occur . MUST ) ; q = builder . build ( ) ; } Frontier Query frontier = new Frontier Query ( q , frontier Size ) ; return frontier ; } }
protected Range find Domain Bounds ( XY Dataset dataset , boolean include Interval ) { if ( dataset == null ) { return null ; } if ( get Data Bounds Includes Visible Series Only ( ) ) { List visible Series Keys = new Array List ( ) ; int series Count = dataset . get Series Count ( ) ; for ( int s = NUM ; s < series Count ; s ++ ) { if ( is Series Visible ( s ) ) { visible Series Keys . add ( dataset . get Series Key ( s ) ) ; } } return Dataset Utilities . find Domain Bounds ( dataset , visible Series Keys , include Interval ) ; } return Dataset Utilities . find Domain Bounds ( dataset , include Interval ) ; }
void start Shutdown ( Shutdown Mode Amp mode , Exit Code exit Code , Result < String > result ) { shutdown Mode = mode ; shutdown Result . compare And Set ( null , result ) ; shutdown Exit Code . compare And Set ( null , exit Code ) ; wake ( ) ; }
public void remove Role ( AM Role role ) throws AM Exception , SSO Exception { remove Role ( role . get DN ( ) ) ; }
protected void write Change Record ( ) throws IO Exception { boolean has New Styles = has Style && ( fill Styles . size ( ) > NUM || line Styles . size ( ) > NUM ) ; boolean has Move To = ( move XY != null ) ; boolean has Fill Style 0 = fill 0 Index >= NUM ; boolean has Fill Style 1 = fill 1 Index >= NUM ; boolean has Line Style = line Index >= NUM ; if ( ( ! has Style ) && has Fill Style 0 ) { has Fill Style 1 = BOOL ; } if ( has New Styles ) { out . write U Bits ( NUM , NUM ) ; out . write U Bits ( NUM , NUM ) ; out . write U Bits ( NUM , NUM ) ; out . write U Bits ( NUM , NUM ) ; out . write U Bits ( NUM , NUM ) ; out . write U Bits ( NUM , NUM ) ; write Move XY ( NUM , NUM ) ; out . write U Bits ( fill Bits , NUM ) ; out . write U Bits ( fill Bits , NUM ) ; out . write U Bits ( line Bits , NUM ) ; if ( fill 0 Index == NUM ) { fill 0 Index = - NUM ; } if ( fill 1 Index == NUM ) { fill 1 Index = - NUM ; } if ( line Index == NUM ) { line Index = - NUM ; } fill Bits = Out Stream . determine Unsigned Bit Size ( fill Styles . size ( ) ) ; line Bits = Out Stream . determine Unsigned Bit Size ( line Styles . size ( ) ) ; write Styles ( fill Styles ) ; write Styles ( line Styles ) ; out . write U Bits ( NUM , fill Bits ) ; out . write U Bits ( NUM , line Bits ) ; write Change Record ( ) ; return ; } if ( has Fill Style 0 || has Fill Style 1 || has Line Style || has Move To ) { out . write U Bits ( NUM , NUM ) ; out . write U Bits ( NUM , NUM ) ; out . write U Bits ( NUM , has Line Style ? NUM : NUM ) ; out . write U Bits ( NUM , has Fill Style 1 ? NUM : NUM ) ; out . write U Bits ( NUM , has Fill Style 0 ? NUM : NUM ) ; out . write U Bits ( NUM , has Move To ? NUM : NUM ) ; if ( has Move To ) { int move X = move XY [ NUM ] ; int move Y = move XY [ NUM ] ; write Move XY ( move X , move Y ) ; } if ( has Fill Style 0 ) { out . write U Bits ( fill Bits , fill 0 Index ) ; } if ( has Fill Style 1 ) { out . write U Bits ( fill Bits , fill 1 Index ) ; } if ( has Line Style ) { out . write U Bits ( line Bits , line Index ) ; } move XY = null ; fill 0 Index = - NUM ; fill 1 Index = - NUM ; line Index = - NUM ; } }
@ Override public String post ( String url , int timeout , String user Agent , Map < String , String > form Data ) { String result = null ; Byte Array Output Stream baos = null ; try { baos = new Byte Array Output Stream ( ) ; post ( url , baos , timeout , user Agent , form Data ) ; result = new String ( baos . to Byte Array ( ) , STRING ) ; } catch ( Throwable e ) { LOG . error ( STRING + e . get Message ( ) , e ) ; } finally { close Quietly ( baos ) ; } return result ; }
public void test single Resource Locking serialized low Concurrency 5 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . set Property ( Test Options . NTHREADS , STRING ) ; properties . set Property ( Test Options . NTASKS , STRING ) ; properties . set Property ( Test Options . NRESOURCES , STRING ) ; properties . set Property ( Test Options . MIN LOCKS , STRING ) ; properties . set Property ( Test Options . MAX LOCKS , STRING ) ; properties . set Property ( Test Options . PREDECLARE LOCKS , STRING ) ; properties . set Property ( Test Options . SORT LOCK REQUESTS , STRING ) ; do Comparison Test ( properties ) ; }
public static void safe Invoke Later ( Runnable runnable ) { if ( Event Queue . is Dispatch Thread ( ) ) runnable . run ( ) ; else Swing Utilities . invoke Later ( runnable ) ; }
public void start ( Resource xml File , String sax Parser Cass ) throws Page Exception { Input Stream is = null ; try { XML Reader xml Reader = XML Util . create XML Reader ( sax Parser Cass ) ; xml Reader . set Content Handler ( this ) ; xml Reader . set Error Handler ( this ) ; xml Reader . parse ( new Input Source ( is = IO Util . to Buffered Input Stream ( xml File . get Input Stream ( ) ) ) ) ; } catch ( Exception e ) { throw Caster . to Page Exception ( e ) ; } finally { IO Util . close EL ( is ) ; } }
public static final byte [ ] encode Url ( Bit Set urlsafe , byte [ ] bytes ) { if ( bytes == null ) { return null ; } if ( urlsafe == null ) { urlsafe = WWW FORM URL ; } Byte Array Output Stream buffer = new Byte Array Output Stream ( ) ; for ( int i = NUM ; i < bytes . length ; i ++ ) { int b = bytes [ i ] ; if ( b < NUM ) { b = NUM + b ; } if ( urlsafe . get ( b ) ) { if ( b == STRING ) { b = STRING ; } buffer . write ( b ) ; } else { buffer . write ( STRING ) ; char hex 1 = Character . to Upper Case ( Character . for Digit ( ( b > > NUM ) & NUM , NUM ) ) ; char hex 2 = Character . to Upper Case ( Character . for Digit ( b & NUM , NUM ) ) ; buffer . write ( hex 1 ) ; buffer . write ( hex 2 ) ; } } return buffer . to Byte Array ( ) ; }
public void test Case 20 ( ) { byte a Bytes [ ] = { NUM } ; byte b Bytes [ ] = { NUM } ; byte r Bytes [ ] = { NUM } ; int a Sign = NUM ; int b Sign = NUM ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . subtract ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( NUM , result . signum ( ) ) ; }
@ Nonnull public Bug Instance add Class And Method ( Method Annotation method Annotation ) { add Class ( method Annotation . get Class Name ( ) ) ; add Method ( method Annotation ) ; return this ; }
public static void check Access And Aliases For Keystore ( String store Location , String store Password , boolean should Not Be Empty ) throws Configuration Exception { final String error Message = Message Format . format ( STRING , store Location ) ; try { List < String > aliases In Keystore = Security Helper . get Aliasesfor Keystore ( store Location , store Password ) ; if ( aliases In Keystore . is Empty ( ) && should Not Be Empty ) { throw new Configuration Exception ( Message Format . format ( STRING , store Location ) ) ; } } catch ( Key Store Exception e ) { throw new Configuration Exception ( Message Format . format ( error Message , e ) ) ; } catch ( No Such Algorithm Exception e ) { throw new Configuration Exception ( Message Format . format ( error Message , e ) ) ; } catch ( Certificate Exception e ) { throw new Configuration Exception ( Message Format . format ( error Message , e ) ) ; } catch ( IO Exception e ) { throw new Configuration Exception ( Message Format . format ( error Message , e ) ) ; } }
public static int parse Lower Map ( String s ) throws Number Format Exception { int lower Case = MAP UNDEFINED ; int length = s . length ( ) ; if ( length >= NUM && length <= NUM ) { lower Case = Integer . parse Int ( s , NUM ) ; } else if ( s . length ( ) != NUM ) { throw new Number Format Exception ( ) ; } return lower Case ; }
@ Override public void run ( ) { while ( ! is Interrupted ( ) ) { try { Value Holder < K , V > ref = ( Value Holder < K , V > ) queue . remove ( ) ; table . remove ( ref . get Key ( ) ) ; } catch ( Interrupted Exception e ) { interrupt ( ) ; break ; } } }
public void init ( ) { System Properties props = System Properties . get Instance ( ) ; Path playlist Folder = props . get Application Folder ( STRING ) ; String default Playlist File = props . get ( STRING , STRING ) ; String playlist File = props . get ( STRING , default Playlist File ) ; m Current Playlist Path = playlist Folder . resolve ( playlist File ) ; Playlist V 2 playlist = load ( m Current Playlist Path ) ; boolean save Required = BOOL ; if ( playlist == null ) { m Log . info ( STRING + STRING ) ; Path playlist V 1 Path = playlist Folder . resolve ( STRING ) ; Playlist Converter V 1 To V 2 converter = new Playlist Converter V 1 To V 2 ( playlist V 1 Path ) ; if ( converter . has Error Messages ( ) ) { m Log . error ( STRING + converter . get Error Messages ( ) ) ; } playlist = converter . get Converted Playlist ( ) ; save Required = BOOL ; } transfer Playlist To Models ( playlist ) ; if ( save Required ) { schedule Playlist Save ( ) ; } }
public static Print Data parse XML ( Properties ctx , File input ) { log . config ( input . to String ( ) ) ; Print Data pd = null ; try { Print Data Handler handler = new Print Data Handler ( ctx ) ; SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; SAX Parser parser = factory . new SAX Parser ( ) ; parser . parse ( input , handler ) ; pd = handler . get Print Data ( ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; } return pd ; }
public Pending Change prepare Add Row ( Object [ ] row , Row Id Impl row Id , Pending Change next Change ) throws IO Exception { return prepare Add Row ( row , row Id , new Add Row Pending Change ( next Change ) ) ; }
public org . smpte ra . schemas . st 2067 2 2013 . Digest Method Type build Default Digest Method Type ( ) { org . smpte ra . schemas . st 2067 2 2013 . Digest Method Type digest Method Type = new org . smpte ra . schemas . st 2067 2 2013 . Digest Method Type ( ) ; digest Method Type . set Algorithm ( Composition Playlist Builder 2013 . default Hash Algorithm ) ; return digest Method Type ; }
public static < V extends Sampled Vertex > Set < V > create Sampled Partition ( Collection < V > vertices , int iteration ) { Set < V > partition = new Hash Set < V > ( ) ; for ( V vertex : vertices ) { if ( vertex . is Sampled ( ) ) { if ( vertex . get Iteration Sampled ( ) == iteration ) partition . add ( vertex ) ; } } return partition ; }
public Barabasi Albert Generator ( Supplier < Graph < V , E > > graph Factory , Supplier < V > vertex Factory , Supplier < E > edge Factory , int init vertices , int num Edges To Attach , Set < V > seed Vertices ) { this ( graph Factory , vertex Factory , edge Factory , init vertices , num Edges To Attach , ( int ) System . current Time Millis ( ) , seed Vertices ) ; }
public Point 2 D calc Center ( final Point 2 D src , final Point 2 D tar ) { double source X = src . get X ( ) ; double source Y = src . get Y ( ) ; double target X = tar . get X ( ) ; double target Y = tar . get Y ( ) ; double x = Math . abs ( source X - target X ) ; double y = Math . abs ( source Y - target Y ) ; double alpha = Math . atan ( y / x ) ; double weight X = NUM ; double weight Y = NUM ; int neuron Offset = Neuron Node . get DIAMETER ( ) / NUM ; if ( source X < target X ) { weight X = target X - ( neuron Offset * Math . cos ( alpha ) ) ; } else { weight X = target X + ( neuron Offset * Math . cos ( alpha ) ) ; } if ( source Y < target Y ) { weight Y = target Y - ( neuron Offset * Math . sin ( alpha ) ) ; } else { weight Y = target Y + ( neuron Offset * Math . sin ( alpha ) ) ; } return new Point 2 D . Double ( weight X , weight Y ) ; }
public final Array List < Wifi Record > load Wifis Overview Within ( final int session , final Double min Lon , final Double max Lon , final Double min Lat , final Double max Lat ) { final Array List < Wifi Record > wifis = new Array List < > ( ) ; String selection = null ; String [ ] selection Args = null ; if ( min Lon != null && max Lon != null && min Lat != null && max Lat != null ) { selection = STRING + Schema . COL LONGITUDE + STRING + STRING + Schema . COL LONGITUDE + STRING + STRING + Schema . COL LATITUDE + STRING + STRING + Schema . COL LATITUDE + STRING ; selection Args = new String [ ] { String . value Of ( min Lon ) , String . value Of ( max Lon ) , String . value Of ( min Lat ) , String . value Of ( max Lat ) } ; } final Cursor cursor = content Resolver . query ( Content Uris . with Appended Id ( Uri . with Appended Path ( Content Provider . CONTENT URI WIFI , Content Provider . CONTENT URI OVERVIEW SUFFIX ) , session ) , null , selection , selection Args , null ) ; final int column Index = cursor . get Column Index ( Schema . COL BSSID ) ; final int column Index 2 = cursor . get Column Index ( Schema . COL SSID ) ; final int column Index 3 = cursor . get Column Index ( Schema . COL CAPABILITIES ) ; final int column Index 4 = cursor . get Column Index ( Schema . COL FREQUENCY ) ; final int column Index 5 = cursor . get Column Index ( Schema . COL MAX LEVEL ) ; final int column Index 6 = cursor . get Column Index ( Schema . COL TIMESTAMP ) ; final int column Index 7 = cursor . get Column Index ( Schema . COL BEGIN POSITION ID ) ; final int column Index 8 = cursor . get Column Index ( Schema . COL END POSITION ID ) ; final int column Index 9 = cursor . get Column Index ( Schema . COL KNOWN WIFI ) ; while ( cursor . move To Next ( ) ) { final Wifi Record wifi = new Wifi Record ( ) ; wifi . set Bssid ( cursor . get String ( column Index ) ) ; wifi . set Ssid ( cursor . get String ( column Index 2 ) ) ; wifi . set Capabilities ( cursor . get String ( column Index 3 ) ) ; wifi . set Frequency ( cursor . get Int ( column Index 4 ) ) ; wifi . set Level ( cursor . get Int ( column Index 5 ) ) ; wifi . set Open Bmap Timestamp ( cursor . get Long ( column Index 6 ) ) ; wifi . set Begin Position ( load Position By Id ( cursor . get String ( column Index 7 ) ) ) ; wifi . set End Position ( load Position By Id ( cursor . get String ( column Index 8 ) ) ) ; wifi . set Catalog Status ( Catalog Status . values ( ) [ cursor . get Int ( column Index 9 ) ] ) ; wifis . add ( wifi ) ; } cursor . close ( ) ; return wifis ; }
public void make Immutable ( ) { if ( is Mutable ) { if ( conditions != null ) { int length = conditions . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Condition condition = ( Condition ) conditions . get ( i ) ; condition . make Immutable ( ) ; } conditions = Collections . unmodifiable List ( conditions ) ; } if ( audience Restrictions != null ) { int length = audience Restrictions . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Audience Restriction ar = ( Audience Restriction ) audience Restrictions . get ( i ) ; ar . make Immutable ( ) ; } audience Restrictions = Collections . unmodifiable List ( audience Restrictions ) ; } if ( one Time Uses != null ) { int length = one Time Uses . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { One Time Use one Time Use = ( One Time Use ) one Time Uses . get ( i ) ; one Time Use . make Immutable ( ) ; } one Time Uses = Collections . unmodifiable List ( one Time Uses ) ; } if ( proxy Restrictions != null ) { int length = proxy Restrictions . size ( ) ; for ( int i = NUM ; i < length ; i ++ ) { Proxy Restriction pr = ( Proxy Restriction ) proxy Restrictions . get ( i ) ; pr . make Immutable ( ) ; } proxy Restrictions = Collections . unmodifiable List ( proxy Restrictions ) ; } is Mutable = BOOL ; } }
@ Override void inserted Text ( Character Data Impl node , int offset , int count ) { if ( ranges != null ) { notify Ranges Inserted Text ( node , offset , count ) ; } }
public Swagger Web App Fraction add Web Content ( String content ) { if ( content == null ) return this ; if ( content . equals ( STRING ) ) return this ; File maybe File = new File ( content ) ; if ( ! maybe File . exists ( ) ) { try { this . web Content = Swarm . artifact ( content ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } else if ( maybe File . is Directory ( ) ) { try { this . web Content = load From Directory ( maybe File ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } else { this . web Content = Shrink Wrap . create From Zip File ( JAR Archive . class , maybe File ) ; } return this ; }
public Completable Future < String > publish ( final String topic , final Message message ) { final Topic Queue queue = topics . compute If Absent ( topic , null ) ; final Completable Future < String > future = queue . send ( message ) ; listener . publishing Message ( this , topic , message , future ) ; return future ; }
public boolean is Simple Type Or Simple Object ( final Field field ) { Class < ? > type = field . get Type ( ) ; boolean simple Type = ( type . is Assignable From ( Short . class ) || type . is Assignable From ( Short . TYPE ) || type . is Assignable From ( Integer . class ) || type . is Assignable From ( Integer . TYPE ) || type . is Assignable From ( Float . class ) || type . is Assignable From ( Float . TYPE ) || type . is Assignable From ( Double . class ) || type . is Assignable From ( Double . TYPE ) || type . is Assignable From ( Long . class ) || type . is Assignable From ( Long . TYPE ) || type . is Assignable From ( Byte . class ) || type . is Assignable From ( Byte . TYPE ) || type . is Assignable From ( Character . class ) || type . is Assignable From ( Character . TYPE ) || type . is Assignable From ( Boolean . class ) || type . is Assignable From ( Boolean . TYPE ) || type . is Assignable From ( String . class ) ) || type . is Enum ( ) ; return simple Type ; }
private void load Org Access Add ( Array List < Org Access > list , Org Access oa ) { if ( list . contains ( oa ) ) return ; list . add ( oa ) ; if ( get AD Tree Org ID ( ) == NUM ) return ; M Org org = M Org . get ( get Ctx ( ) , oa . AD Org ID ) ; if ( ! org . is Summary ( ) ) return ; M Tree Base tree = M Tree Base . get ( get Ctx ( ) , get AD Tree Org ID ( ) , get Trx Name ( ) ) ; String sql = STRING + STRING + tree . get Node Table Name ( ) + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; pstmt . set Int ( NUM , tree . get AD Tree ID ( ) ) ; pstmt . set Int ( NUM , org . get AD Org ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int AD Client ID = rs . get Int ( NUM ) ; int AD Org ID = rs . get Int ( NUM ) ; load Org Access Add ( list , new Org Access ( AD Client ID , AD Org ID , oa . read Only ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
public Socket connect ( ) throws IO Exception , Configuration Exception { if ( use SSL ) { ssl Factory = SSL Socket Factory . get Default ( ) ; SSL Socket ssl Socket = ( SSL Socket ) ssl Factory . create Socket ( ) ; Security Helper . set Ciphers And Protocols To SSL Socket ( ssl Socket , Security Helper . get Ciphers ( ) , Security Helper . get Protocols ( ) ) ; socket = ssl Socket ; } else { Socket Channel channel = Socket Channel . open ( ) ; socket = channel . socket ( ) ; } set Socket ( socket ) ; try { socket . connect ( address , connect Timeout ) ; } catch ( IO Exception e ) { if ( done ) { throw new Socket Termination Exception ( STRING , e ) ; } else { throw e ; } } socket . set Tcp No Delay ( BOOL ) ; socket . set Keep Alive ( BOOL ) ; socket . set So Timeout ( read Timeout ) ; return socket ; }
public static boolean equals Double ( Read Only Vector 3 vec 0 , Read Only Vector 3 vec 1 ) { if ( vec 0 == vec 1 ) return ( BOOL ) ; if ( Math . abs ( vec 0 . get X ( ) - vec 1 . get X ( ) ) > epsilon D ) return ( BOOL ) ; if ( Math . abs ( vec 0 . get Y ( ) - vec 1 . get Y ( ) ) > epsilon D ) return ( BOOL ) ; if ( Math . abs ( vec 0 . get Z ( ) - vec 1 . get Z ( ) ) > epsilon D ) return ( BOOL ) ; return ( BOOL ) ; }
public static void wait For Process Output ( Process self , Appendable output , Appendable error ) { Thread tout = consume Process Output Stream ( self , output ) ; Thread terr = consume Process Error Stream ( self , error ) ; try { tout . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { terr . join ( ) ; } catch ( Interrupted Exception ignore ) { } try { self . wait For ( ) ; } catch ( Interrupted Exception ignore ) { } close Streams ( self ) ; }
@ Override final Node < K , V > find ( int h , Object k ) { if ( k != null ) { for ( Node < K , V > e = first ; e != null ; e = e . next ) { int s ; K ek ; if ( ( ( s = lock State ) & ( WAITER | WRITER ) ) != NUM ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } else if ( U . compare And Swap Int ( this , LOCKSTATE , s , s + READER ) ) { Tree Node < K , V > r , p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k , null ) ) ; } finally { Thread w ; int ls ; do { } while ( ! U . compare And Swap Int ( this , LOCKSTATE , ls = lock State , ls - READER ) ) ; if ( ls == ( READER | WAITER ) && ( w = waiter ) != null ) Lock Support . unpark ( w ) ; } return p ; } } } return null ; }
@ Override public Axis State draw ( Graphics 2 D g2 , double cursor , Rectangle 2 D plot Area , Rectangle 2 D data Area , Rectangle Edge edge , Plot Rendering Info plot State ) { if ( ! is Visible ( ) ) { Axis State state = new Axis State ( cursor ) ; List ticks = refresh Ticks ( g2 , state , data Area , edge ) ; state . set Ticks ( ticks ) ; return state ; } Axis State state = draw Tick Marks And Labels ( g2 , cursor , plot Area , data Area , edge ) ; if ( get Attributed Label ( ) != null ) { state = draw Attributed Label ( get Attributed Label ( ) , g2 , plot Area , data Area , edge , state ) ; } else { state = draw Label ( get Label ( ) , g2 , plot Area , data Area , edge , state ) ; } create And Add Entity ( cursor , state , data Area , edge , plot State ) ; return state ; }
public void test Filter ( ) throws IO Exception , Exception { Array List < URL Crawl Datum > list = new Array List < URL Crawl Datum > ( ) ; list . add ( create URL Crawl Datum ( STRING , NUM , NUM ) ) ; list . add ( create URL Crawl Datum ( STRING , NUM , NUM ) ) ; list . add ( create URL Crawl Datum ( STRING , NUM , NUM ) ) ; create Crawl DB ( list ) ; Configuration my Configuration = new Configuration ( conf ) ; my Configuration . set ( STRING , STRING ) ; Path generated Segment = generate Fetchlist ( Integer . MAX VALUE , my Configuration , BOOL ) ; assert Null ( STRING , generated Segment ) ; generated Segment = generate Fetchlist ( Integer . MAX VALUE , my Configuration , BOOL ) ; Path fetchlist Path = new Path ( new Path ( generated Segment , Crawl Datum . GENERATE DIR NAME ) , STRING ) ; Array List < URL Crawl Datum > fetch List = read Contents ( fetchlist Path ) ; assert Equals ( list . size ( ) , fetch List . size ( ) ) ; }
public static Color reduce Color Brightness ( Color color ) { int r , g , b ; float [ ] hsb = new float [ NUM ] ; r = color . get Red ( ) ; g = color . get Green ( ) ; b = color . get Blue ( ) ; Color . RG Bto HSB ( r , g , b , hsb ) ; hsb [ NUM ] *= NUM ; hsb [ NUM ] *= NUM ; return Color . get HSB Color ( hsb [ NUM ] , hsb [ NUM ] , hsb [ NUM ] ) ; }
private boolean is Category Visible In Shop ( final Long category Id ) { final Set < Long > cat Ids = shop Service . get Shop Categories Ids ( Shop Code Context . get Shop Id ( ) ) ; Category category = category Service . get By Id ( category Id ) ; final Date now = new Date ( ) ; while ( category != null && Domain Api Utils . is Object Available Now ( BOOL , category . get Availablefrom ( ) , category . get Availableto ( ) , now ) && category . get Category Id ( ) != category . get Parent Id ( ) ) { if ( cat Ids . contains ( category Id ) ) { return BOOL ; } category = category Service . get By Id ( category . get Parent Id ( ) ) ; } return BOOL ; }
public Reflective Property ( Class < T > property Holder , Class < V > value Type , String name ) { super ( value Type , name ) ; char first Letter = Character . to Upper Case ( name . char At ( NUM ) ) ; String the Rest = name . substring ( NUM ) ; String capitalized Name = first Letter + the Rest ; String getter Name = PREFIX GET + capitalized Name ; try { m Getter = property Holder . get Method ( getter Name , ( Class < ? > [ ] ) null ) ; } catch ( No Such Method Exception e ) { try { m Getter = property Holder . get Declared Method ( getter Name , ( Class < ? > [ ] ) null ) ; m Getter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception e2 ) { getter Name = PREFIX IS + capitalized Name ; try { m Getter = property Holder . get Method ( getter Name , ( Class < ? > [ ] ) null ) ; } catch ( No Such Method Exception e3 ) { try { m Getter = property Holder . get Declared Method ( getter Name , ( Class < ? > [ ] ) null ) ; m Getter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception e4 ) { try { m Field = property Holder . get Field ( name ) ; Class field Type = m Field . get Type ( ) ; if ( ! types Match ( value Type , field Type ) ) { throw new No Such Property Exception ( STRING + field Type + STRING + STRING + value Type + STRING ) ; } return ; } catch ( No Such Field Exception e5 ) { throw new No Such Property Exception ( STRING + STRING + name ) ; } } } } } Class getter Type = m Getter . get Return Type ( ) ; if ( ! types Match ( value Type , getter Type ) ) { throw new No Such Property Exception ( STRING + getter Type + STRING + STRING + value Type + STRING ) ; } String setter Name = PREFIX SET + capitalized Name ; try { m Setter = property Holder . get Declared Method ( setter Name , getter Type ) ; m Setter . set Accessible ( BOOL ) ; } catch ( No Such Method Exception ignored ) { } }
public static Web Element find Element Clickable After ( Search Context parent , By by , int timeout In Seconds ) { Preconditions . check Not Null ( parent ) ; Preconditions . check Not Null ( by ) ; try { Web Element Wait wait = new Web Element Wait ( parent , timeout In Seconds ) ; return wait . until ( null ) ; } catch ( Timeout Exception e ) { throw new Timeout Exception ( String . format ( STRING , by , timeout In Seconds ) , e ) ; } }
public synchronized void initialize ( ) { if ( m Initialized ) { return ; } m Initialized = BOOL ; if ( ! m Root Directory . exists ( ) ) { if ( ! m Root Directory . mkdirs ( ) ) { Volley Log . e ( STRING , m Root Directory . get Absolute Path ( ) ) ; } return ; } File [ ] files = m Root Directory . list Files ( ) ; if ( files == null ) { return ; } Volley Log . d ( STRING , files . length ) ; Executor Service executor = new Thread Pool Executor ( CACHE LOAD THREADS , CACHE LOAD THREADS , NUM , Time Unit . MILLISECONDS , m Queue ) ; for ( File file : files ) { Callable < Cache Header > callable = new Header Parser Callable ( file ) ; Runnable Future < Cache Header > submit = new Reordering Future Task ( callable ) ; m Loading Files . put ( file . get Name ( ) , submit ) ; executor . execute ( submit ) ; } }
public void remove CSP State Listener ( CSP State Listener listener ) { listeners . remove ( listener ) ; }
public void display Message And Usage Reference ( final Print Stream print Stream , final Localizable Message message ) { print Wrapped Text ( print Stream , message ) ; print Stream . println ( ) ; print Wrapped Text ( print Stream , get Help Usage Reference ( ) ) ; }
public boolean is Inside ( Entity entity ) { for ( Axis Aligned BB bounding Box : this . bounding Boxes ) { if ( bounding Box . is Vec Inside ( entity . get Position Vector ( ) ) ) { return BOOL ; } } return BOOL ; }
static Span read Span ( Message Unpacker unpacker ) throws IO Exception { int num Entries = unpacker . unpack Map Header ( ) ; Milli Span . Builder builder = new Milli Span . Builder ( ) ; while ( -- num Entries >= NUM ) { String key = unpacker . unpack String ( ) ; if ( key . length ( ) != NUM ) { throw new IO Exception ( STRING + key ) ; } switch ( key . char At ( NUM ) ) { case STRING : builder . span Id ( read Span Id ( unpacker ) ) ; break ; case STRING : builder . begin ( unpacker . unpack Long ( ) ) ; break ; case STRING : builder . end ( unpacker . unpack Long ( ) ) ; break ; case STRING : builder . description ( unpacker . unpack String ( ) ) ; break ; case STRING : builder . tracer Id ( unpacker . unpack String ( ) ) ; break ; case STRING : int num Parents = unpacker . unpack Array Header ( ) ; Span Id [ ] parents = new Span Id [ num Parents ] ; for ( int i = NUM ; i < num Parents ; i ++ ) { parents [ i ] = read Span Id ( unpacker ) ; } builder . parents ( parents ) ; break ; case STRING : int map Entries = unpacker . unpack Map Header ( ) ; Hash Map < String , String > entries = new Hash Map < String , String > ( map Entries ) ; for ( int i = NUM ; i < map Entries ; i ++ ) { String k = unpacker . unpack String ( ) ; String v = unpacker . unpack String ( ) ; entries . put ( k , v ) ; } builder . trace Info ( entries ) ; break ; case STRING : int list Entries = unpacker . unpack Array Header ( ) ; Array List < Timeline Annotation > list = new Array List < Timeline Annotation > ( list Entries ) ; for ( int i = NUM ; i < list Entries ; i ++ ) { int timeline Object Size = unpacker . unpack Map Header ( ) ; long time = NUM ; String msg = STRING ; for ( int j = NUM ; j < timeline Object Size ; j ++ ) { String tl Key = unpacker . unpack String ( ) ; if ( tl Key . length ( ) != NUM ) { throw new IO Exception ( STRING + tl Key ) ; } switch ( tl Key . char At ( NUM ) ) { case STRING : time = unpacker . unpack Long ( ) ; break ; case STRING : msg = unpacker . unpack String ( ) ; break ; default : throw new IO Exception ( STRING + tl Key ) ; } } list . add ( new Timeline Annotation ( time , msg ) ) ; } builder . timeline ( list ) ; break ; default : throw new IO Exception ( STRING + key ) ; } } return builder . build ( ) ; }
private boolean load Gs Logging Properties File From Classpath ( ) { return load Logging File From Classpath ( Common System Properties . GS LOGGING CONFIG FILE PATH ) ; }
private List < T > as List ( ) { if ( as List == null ) { List < T > smallest First List = Lists . new Array List With Capacity ( as Queue . size ( ) ) ; while ( ! as Queue . is Empty ( ) ) { smallest First List . add ( as Queue . poll ( ) ) ; } as List = Lists . reverse ( smallest First List ) ; as Queue = null ; } return as List ; }
private void fire Process Supervision Update ( final Supervision Event supervision Event ) { Set < Supervision Listener > listeners = process Supervision Listeners . get ( supervision Event . get Entity Id ( ) ) ; if ( listeners != null ) { for ( Supervision Listener listener : listeners ) { listener . on Supervision Update ( supervision Event ) ; } } }
@ Api Operation ( value = STRING ) @ Request Mapping ( value = STRING , method = Request Method . PUT ) @ Response Status ( Http Status . NO CONTENT ) @ Response Body public final void put Heartbeat ( @ Path Variable ( STRING ) String engine Name , @ Api Param ( value = STRING ) @ Request Param ( value = Web Constants . SECURITY TOKEN ) String security Token , @ Request Body Heartbeat heartbeat ) { I Symmetric Engine engine = get Symmetric Engine ( engine Name ) ; if ( security Verified ( heartbeat . get Node Id ( ) , engine , security Token ) ) { heartbeat Impl ( engine , heartbeat ) ; } else { throw new Not Allowed Exception ( ) ; } }
@ Override public String to String ( ) { String Builder sb = new String Builder ( ) ; sb . append ( serial Number . to String ( ) ) ; sb . append ( STRING + revocation Date . to String ( ) ) ; if ( cert Issuer != null ) { sb . append ( STRING + cert Issuer ) ; } if ( extensions != null ) { Collection < Extension > all Entry Exts = extensions . get All Extensions ( ) ; Extension [ ] exts = all Entry Exts . to Array ( new Extension [ NUM ] ) ; sb . append ( STRING + exts . length ) ; for ( int i = NUM ; i < exts . length ; i ++ ) { sb . append ( STRING + ( i + NUM ) + STRING ) ; Extension ext = exts [ i ] ; try { if ( OID Map . get Class ( ext . get Extension Id ( ) ) == null ) { sb . append ( ext . to String ( ) ) ; byte [ ] ext Value = ext . get Extension Value ( ) ; if ( ext Value != null ) { Der Output Stream out = new Der Output Stream ( ) ; out . put Octet String ( ext Value ) ; ext Value = out . to Byte Array ( ) ; Hex Dump Encoder enc = new Hex Dump Encoder ( ) ; sb . append ( STRING + STRING + enc . encode Buffer ( ext Value ) + STRING ) ; } } else sb . append ( ext . to String ( ) ) ; } catch ( Exception e ) { sb . append ( STRING ) ; } } } sb . append ( STRING ) ; return sb . to String ( ) ; }
public Builder delete Roles ( ) { delete Fields . add ( STRING ) ; return this ; }
public Query limit ( int limit , int offset ) { return limit ( limit < NUM ? NO LIMIT : Field . < Integer > field ( Integer . to String ( limit ) ) , offset < NUM ? NO OFFSET : Field . < Integer > field ( Integer . to String ( offset ) ) ) ; }
public boolean delete File From Tmp ( String filename ) { boolean result ; File file ; result = BOOL ; file = new File ( get Tmp Directory ( ) + File . separator + filename ) ; if ( file . exists ( ) ) result = file . delete ( ) ; return result ; }
public final void add Method 2 ( Method Info minfo ) { methods . add ( minfo ) ; }
public static String convert Charset ( String source , String src Charset Name , String new Charset Name ) { if ( src Charset Name . equals ( new Charset Name ) ) { return source ; } try { return new String ( source . get Bytes ( src Charset Name ) , new Charset Name ) ; } catch ( Unsupported Encoding Exception unex ) { throw new Illegal Argument Exception ( unex ) ; } }
private void copy Stream ( Input Stream is , Output Stream os ) throws IO Exception { try { byte [ ] buffer = new byte [ NUM ] ; int len ; while ( ( len = is . read ( buffer ) ) != - NUM ) { os . write ( buffer , NUM , len ) ; } } catch ( IO Exception e ) { throw new IO Exception ( STRING , e ) ; } }
public void assign Service ( Map map ) throws AM Console Exception { String [ ] params = { current Realm , service Name } ; log Event ( STRING , params ) ; try { AM Identity Repository repo = new AM Identity Repository ( get User SSO Token ( ) , current Realm ) ; AM Identity realm Identity = repo . get Realm Identity ( ) ; Set services From Id Repo = realm Identity . get Assignable Services ( ) ; if ( services From Id Repo . contains ( service Name ) ) { realm Identity . assign Service ( service Name , map ) ; } else { Organization Config Manager org Cfg Mgr = new Organization Config Manager ( get User SSO Token ( ) , current Realm ) ; org Cfg Mgr . assign Service ( service Name , map ) ; } log Event ( STRING , params ) ; } catch ( SSO Exception e ) { String str Error = get Error String ( e ) ; String [ ] params Ex = { current Realm , service Name , str Error } ; log Event ( STRING , params Ex ) ; throw new AM Console Exception ( str Error ) ; } catch ( Id Repo Exception e ) { String str Error = get Error String ( e ) ; String [ ] params Ex = { current Realm , service Name , str Error } ; log Event ( STRING , params Ex ) ; throw new AM Console Exception ( str Error ) ; } catch ( SMS Exception e ) { String str Error = get Error String ( e ) ; String [ ] params Ex = { current Realm , service Name , str Error } ; log Event ( STRING , params Ex ) ; throw new AM Console Exception ( str Error ) ; } }
public Writable Raster create Writable Child ( int x , int y , int width , int height , int x0 , int y0 , int [ ] band List ) { if ( x < this . min X ) { throw new Raster Format Exception ( STRING ) ; } if ( y < this . min Y ) { throw new Raster Format Exception ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . min X + this . width ) ) { throw new Raster Format Exception ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . min Y + this . height ) ) { throw new Raster Format Exception ( STRING ) ; } Sample Model sm ; if ( band List != null ) sm = sample Model . create Subset Sample Model ( band List ) ; else sm = sample Model ; int delta X = x0 - x ; int delta Y = y0 - y ; return new Byte Interleaved Raster ( sm , data Buffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sample Model Translate X + delta X , sample Model Translate Y + delta Y ) , this ) ; }
private void send Buffer If Full ( ) throws IO Exception { if ( buf . position ( ) >= buf Size ) send Buffer ( ) ; }
public Set < State > post Event ( Event Data event Data , Long state Machine Instance Id , String correlation Id ) { State Machine state Machine = null ; if ( state Machine Instance Id != null ) { state Machine = retrieve State Machine ( state Machine Instance Id ) ; } else if ( correlation Id != null ) { state Machine = retrieve State Machine By Correlation Id ( correlation Id ) ; state Machine Instance Id = ( state Machine == null ) ? null : state Machine . get Id ( ) ; } if ( state Machine == null ) throw new Unknown State Machine ( STRING + state Machine Instance Id + STRING + correlation Id + STRING ) ; Event event = events DAO . find By SM Id And Name ( state Machine Instance Id , event Data . get Name ( ) ) ; if ( event == null ) throw new Illegal Event Exception ( STRING + state Machine Instance Id + STRING + event Data . get Name ( ) + STRING ) ; event . set Status ( Event . Event Status . triggered ) ; event . set Event Data ( event Data . get Data ( ) ) ; event . set Event Source ( event Data . get Event Source ( ) ) ; events DAO . update Event ( event ) ; Context context = new RAM Context ( System . current Time Millis ( ) , null , state Machine ) ; final Set < State > dependant States = context . get Dependant States ( event Data . get Name ( ) ) ; logger . debug ( STRING , dependant States , event Data . get Name ( ) ) ; Set < State > executable States = get Executable States ( dependant States , state Machine Instance Id ) ; logger . debug ( STRING , executable States , event Data . get Name ( ) ) ; execute States ( state Machine Instance Id , executable States ) ; return executable States ; }
public static void fork Resource File ( @ Not Null Design Surface surface , @ Nullable String new Folder , boolean open ) { Configuration configuration = surface . get Configuration ( ) ; if ( configuration == null ) { assert BOOL ; return ; } final Virtual File file = configuration . get File ( ) ; if ( file == null ) { assert BOOL ; return ; } Module module = configuration . get Module ( ) ; if ( module == null ) { assert BOOL ; return ; } Xml File xml File = ( Xml File ) configuration . get Psi File ( ) ; Resource Folder Type folder Type = Resource Helper . get Folder Type ( xml File ) ; if ( folder Type == null ) { folder Type = Resource Folder Type . LAYOUT ; } fork Resource File ( module . get Project ( ) , folder Type , file , xml File , new Folder , configuration , open ) ; }
@ Override public int compare ( final String string 1 , final String string 2 ) { String string 1 Copy = string 1 . to Lower Case ( ) ; String string 2 Copy = string 2 . to Lower Case ( ) ; int len 1 = string 1 . length ( ) ; int len 2 = string 2 . length ( ) ; String liczba 1 = STRING ; String liczba 2 = STRING ; for ( int i = NUM ; i < ( ( len 1 > len 2 ) ? len 1 : len 2 ) ; i ++ ) { if ( i == len 1 && len 2 > len 1 ) { return - NUM ; } if ( i == len 2 && len 1 > len 2 ) { return NUM ; } Character c1 = string 1 Copy . char At ( i ) ; Character c2 = string 2 Copy . char At ( i ) ; if ( is Digit ( c1 ) && is Digit ( c2 ) ) { liczba 1 += c1 ; liczba 2 += c2 ; } else if ( is Digit ( c1 ) && liczba 1 . length ( ) > NUM ) { return NUM ; } else if ( is Digit ( c2 ) && liczba 1 . length ( ) > NUM ) { return - NUM ; } else { if ( ! liczba 1 . equals ( liczba 2 ) ) { return liczba 1 . compare To ( liczba 2 ) ; } liczba 1 = STRING ; liczba 2 = STRING ; if ( ! c1 . equals ( c2 ) ) { return c1 . compare To ( c2 ) ; } } } return string 1 Copy . compare To ( string 2 Copy ) ; }
protected boolean validate Blob ( int id , byte [ ] base Content , int required Size ) throws SQL Exception { Connection con = get Connection Via Driver Manager ( ) ; Callable Statement cstmt = null ; try { cstmt = con . prepare Call ( EXECUTE CHECK BINARY BLOB ) ; cstmt . set Int ( NUM , id ) ; cstmt . set Bytes ( NUM , base Content ) ; cstmt . set Int ( NUM , required Size ) ; cstmt . execute ( ) ; return cstmt . get Boolean ( NUM ) ; } finally { close Quietly ( cstmt ) ; close Quietly ( con ) ; } }
private List < String > update Status ( List < String > unsent Reg Ids , Map < String , Result > all Results , Multicast Result multicast Result ) { List < Result > results = multicast Result . get Results ( ) ; if ( results . size ( ) != unsent Reg Ids . size ( ) ) { throw new Runtime Exception ( STRING + STRING + results + STRING + unsent Reg Ids ) ; } List < String > new Unsent Reg Ids = new Array List < String > ( ) ; for ( int i = NUM ; i < unsent Reg Ids . size ( ) ; i ++ ) { String reg Id = unsent Reg Ids . get ( i ) ; Result result = results . get ( i ) ; all Results . put ( reg Id , result ) ; String error = result . get Error Code Name ( ) ; if ( error != null && ( error . equals ( Constants . ERROR UNAVAILABLE ) || error . equals ( Constants . ERROR INTERNAL SERVER ERROR ) ) ) { new Unsent Reg Ids . add ( reg Id ) ; } } return new Unsent Reg Ids ; }
public Statement is Not Null ( ) { statement . append ( STRING ) ; return this ; }
public void clear ( ) { process Queue ( ) ; map . clear ( ) ; }
public void delete Favorite ( ) { Fm Radio Station . update Station To Db ( m Context , m Dlg Station Name , Fm Radio Station . STATION TYPE SEARCHED , m Dlg Station Freq ) ; m Adapter . notify Data Set Changed ( ) ; }
@ Override public int add All Absent ( @ Not Null Collection < ? extends E > c ) { Object [ ] cs = c . to Array ( ) ; if ( cs . length == NUM ) { return NUM ; } Object [ ] uniq = new Object [ cs . length ] ; Object [ ] elements ; Object [ ] new Elements ; int added ; do { elements = array ; int len = elements . length ; added = NUM ; for ( Object e : cs ) { if ( index Of ( e , elements , NUM , len ) < NUM && index Of ( e , uniq , NUM , added ) < NUM ) { uniq [ added ++ ] = e ; } } if ( added == NUM ) { return NUM ; } new Elements = Arrays . copy Of ( elements , len + added , Object [ ] . class ) ; System . arraycopy ( uniq , NUM , new Elements , len , added ) ; } while ( ! replace Array ( elements , new Elements ) ) ; return added ; }
public Iterator < Capability > capabilities ( ) { return m Capabilities . iterator ( ) ; }
private void update Notification ( String content ) { String ticker = String . format ( get String ( R . string . media notif ticker ) , get String ( R . string . app name ) ) ; Intent show Details Intent = new Intent ( this , File Display Activity . class ) ; show Details Intent . put Extra ( File Activity . EXTRA FILE , m File ) ; show Details Intent . put Extra ( File Activity . EXTRA ACCOUNT , m Account ) ; show Details Intent . set Flags ( Intent . FLAG ACTIVITY CLEAR TOP ) ; m Notification Builder . set Content Intent ( Pending Intent . get Activity ( get Application Context ( ) , ( int ) System . current Time Millis ( ) , show Details Intent , Pending Intent . FLAG UPDATE CURRENT ) ) ; m Notification Builder . set When ( System . current Time Millis ( ) ) ; m Notification Builder . set Ticker ( ticker ) ; m Notification Builder . set Content Title ( ticker ) ; m Notification Builder . set Content Text ( content ) ; m Notification Manager . notify ( R . string . media notif ticker , m Notification Builder . build ( ) ) ; }
public static long find Number ( String str , int offset ) throws Tag Exception { if ( str == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ( offset < NUM ) || ( offset >= str . length ( ) ) ) { throw new Index Out Of Bounds Exception ( STRING + offset + STRING + str . length ( ) ) ; } int i ; int j ; long num ; i = offset ; while ( i < str . length ( ) ) { if ( ( ( str . char At ( i ) >= STRING ) && ( str . char At ( i ) <= STRING ) ) || ( str . char At ( i ) == STRING ) ) { break ; } i ++ ; } j = i + NUM ; while ( j < str . length ( ) ) { if ( ( ( str . char At ( j ) < STRING ) || ( str . char At ( j ) > STRING ) ) ) { break ; } j ++ ; } if ( ( j <= str . length ( ) ) && ( j > i ) ) { num = Long . parse Long ( str . substring ( i , j ) ) ; } else { throw new Tag Exception ( STRING + str ) ; } return num ; }
private < T extends Client Request Result > Collection < T > execute Name Request ( final Collection < String > regex List , final Class < T > clazz , final Client Request Report Listener report Listener , final String request Queue ) { LOGGER . debug ( STRING ) ; Client Request Impl < T > client Request = new Client Request Impl < T > ( clazz ) ; Iterator < String > it = regex List . iterator ( ) ; Collection < Future < Collection < T > > > results = new Array List < Future < Collection < T > > > ( ) ; int counter = NUM ; while ( it . has Next ( ) ) { while ( it . has Next ( ) && counter < max Request Size ) { client Request . add Regex ( it . next ( ) ) ; counter ++ ; } Request Values Task < T > task = new Request Values Task < T > ( client Request , report Listener , request Queue ) ; results . add ( executor . submit ( task ) ) ; client Request = new Client Request Impl < T > ( clazz ) ; counter = NUM ; } Collection < T > final Collection = new Array List < T > ( ) ; for ( Future < Collection < T > > result : results ) { try { final Collection . add All ( result . get ( ) ) ; } catch ( Interrupted Exception e ) { LOGGER . error ( STRING , e ) ; throw new Runtime Exception ( e ) ; } catch ( Execution Exception e ) { LOGGER . error ( STRING , e ) ; throw new Runtime Exception ( e ) ; } } LOGGER . debug ( STRING ) ; return final Collection ; }
private void send Request To Server ( Http URL Connection url Connection , String xml ) throws Request Failure Exception { try { Output Stream out = new Buffered Output Stream ( url Connection . get Output Stream ( ) ) ; Output Stream Writer writer = new Output Stream Writer ( out ) ; writer . write ( xml , NUM , xml . length ( ) ) ; writer . close ( ) ; check Server Response Code ( url Connection ) ; } catch ( IO Exception e ) { throw new Request Failure Exception ( STRING , e ) ; } }
public static void prepend Resource Source ( Resource Source source ) { ALL RESOURCE SOURCES . add First ( source ) ; }
private void commit Changes ( ) { network Properties Panel . commit Changes ( ) ; quick Connect Panel . commit Changes ( ) ; }
private boolean is obstacle clearance ( Brd Item curr item ) { boolean is obstacle = curr item . is obstacle ( this ) ; if ( ! is obstacle ) return BOOL ; if ( ! ( this instanceof Brd Tracep && curr item instanceof Brd Tracep ) ) return BOOL ; Brd Tracep this trace = ( Brd Tracep ) this ; boolean contact found = BOOL ; Pla Point contact point = this trace . corner first ( ) ; Collection < Brd Item > curr contacts = this trace . get normal contacts ( contact point , BOOL ) ; if ( curr contacts . contains ( curr item ) ) contact found = BOOL ; if ( ! contact found ) { contact point = this trace . corner last ( ) ; curr contacts = this trace . get normal contacts ( contact point , BOOL ) ; if ( curr contacts . contains ( curr item ) ) contact found = BOOL ; } if ( ! contact found ) return BOOL ; for ( Brd Item curr contact : curr contacts ) { if ( ! ( curr contact instanceof Brd Abit Pin ) ) continue ; if ( curr contact . shares net ( this ) && curr contact . shares net ( curr item ) ) return BOOL ; } return BOOL ; }
public boolean should Intercept Touch Event ( Motion Event ev ) { final int action = Motion Event Compat . get Action Masked ( ev ) ; final int action Index = Motion Event Compat . get Action Index ( ev ) ; if ( action == Motion Event . ACTION DOWN ) { cancel ( ) ; } if ( m Velocity Tracker == null ) { m Velocity Tracker = Velocity Tracker . obtain ( ) ; } m Velocity Tracker . add Movement ( ev ) ; switch ( action ) { case Motion Event . ACTION DOWN : { final float x = ev . get X ( ) ; final float y = ev . get Y ( ) ; final int pointer Id = Motion Event Compat . get Pointer Id ( ev , NUM ) ; save Initial Motion ( x , y , pointer Id ) ; final View to Capture = find Top Child Under ( ( int ) x , ( int ) y ) ; if ( to Capture == m Captured View && m Drag State == STATE SETTLING ) { try Capture View For Drag ( to Capture , pointer Id ) ; } final int edges Touched = m Initial Edges Touched [ pointer Id ] ; if ( ( edges Touched & m Tracking Edges ) != NUM ) { m Callback . on Edge Touched ( edges Touched & m Tracking Edges , pointer Id ) ; } break ; } case Motion Event Compat . ACTION POINTER DOWN : { final int pointer Id = Motion Event Compat . get Pointer Id ( ev , action Index ) ; final float x = Motion Event Compat . get X ( ev , action Index ) ; final float y = Motion Event Compat . get Y ( ev , action Index ) ; save Initial Motion ( x , y , pointer Id ) ; if ( m Drag State == STATE IDLE ) { final int edges Touched = m Initial Edges Touched [ pointer Id ] ; if ( ( edges Touched & m Tracking Edges ) != NUM ) { m Callback . on Edge Touched ( edges Touched & m Tracking Edges , pointer Id ) ; } } else if ( m Drag State == STATE SETTLING ) { final View to Capture = find Top Child Under ( ( int ) x , ( int ) y ) ; if ( to Capture == m Captured View ) { try Capture View For Drag ( to Capture , pointer Id ) ; } } break ; } case Motion Event . ACTION MOVE : { if ( m Initial Motion X == null || m Initial Motion Y == null ) { return BOOL ; } final int pointer Count = Motion Event Compat . get Pointer Count ( ev ) ; for ( int i = NUM ; i < pointer Count ; i ++ ) { final int pointer Id = Motion Event Compat . get Pointer Id ( ev , i ) ; final float x = Motion Event Compat . get X ( ev , i ) ; final float y = Motion Event Compat . get Y ( ev , i ) ; final float dx = x - m Initial Motion X [ pointer Id ] ; final float dy = y - m Initial Motion Y [ pointer Id ] ; final float slope = Math . abs ( dy / dx ) ; if ( slope >= NUM ) { break ; } report New Edge Drags ( dx , dy , pointer Id ) ; if ( m Drag State == STATE DRAGGING ) { break ; } final View to Capture = find Top Child Under ( ( int ) x , ( int ) y ) ; if ( to Capture != null && check Touch Slop ( to Capture , dx , dy ) && try Capture View For Drag ( to Capture , pointer Id ) ) { break ; } } save Last Motion ( ev ) ; break ; } case Motion Event Compat . ACTION POINTER UP : { final int pointer Id = Motion Event Compat . get Pointer Id ( ev , action Index ) ; clear Motion History ( pointer Id ) ; break ; } case Motion Event . ACTION UP : case Motion Event . ACTION CANCEL : { cancel ( ) ; break ; } } return m Drag State == STATE DRAGGING ; }
public boolean add Svf ( Owl Class target Class ) { target Class . add Svf Restriction ( this ) ; return svf Classes . add ( target Class ) ; }
public static XML Table Definition load ( Element definition ) { XML Table Definition answer = new XML Table Definition ( ) ; answer . set Row Expression ( definition . attribute Value ( STRING ) ) ; for ( Iterator < Element > iter = definition . element Iterator ( STRING ) ; iter . has Next ( ) ; ) { Element element = iter . next ( ) ; String expression = element . attribute Value ( STRING ) ; String name = element . get Text ( ) ; String type Name = element . attribute Value ( STRING , STRING ) ; String column X Path = element . attribute Value ( STRING ) ; int type = XML Table Column Definition . parse Type ( type Name ) ; if ( column X Path != null ) { answer . add Column With X Path Name ( column X Path , expression , type ) ; } else { answer . add Column ( name , expression , type ) ; } } return answer ; }
public static boolean is DWM Composition Enabled ( ) { return is DWM Composition Enabled ; }
private void serializable ( final Isolation Levels level ) throws Exception { clear ( store ) ; final Value Factory vf = store . get Value Factory ( ) ; final IRI subj = vf . create IRI ( STRING ) ; final IRI pred = vf . create IRI ( STRING ) ; Sail Connection prep = store . get Connection ( ) ; try { prep . begin ( level ) ; prep . add Statement ( subj , pred , vf . create Literal ( NUM ) ) ; prep . commit ( ) ; } finally { prep . close ( ) ; } final Count Down Latch start = new Count Down Latch ( NUM ) ; final Count Down Latch observed = new Count Down Latch ( NUM ) ; Thread t1 = increment By ( start , observed , level , vf , subj , pred , NUM ) ; Thread t2 = increment By ( start , observed , level , vf , subj , pred , NUM ) ; t2 . start ( ) ; t1 . start ( ) ; t2 . join ( ) ; t1 . join ( ) ; assert Not Failed ( ) ; Sail Connection check = store . get Connection ( ) ; try { check . begin ( level ) ; Literal lit = read Literal ( check , subj , pred ) ; int val = lit . int Value ( ) ; if ( val != NUM && val != NUM ) { Assert . assert Equals ( NUM , val ) ; } check . commit ( ) ; } finally { check . close ( ) ; } }
public static Array list To Array ( String list , char delimiter ) { if ( list . length ( ) == NUM ) return new Array Impl ( ) ; int len = list . length ( ) ; int last = NUM ; Array array = new Array Impl ( ) ; try { for ( int i = NUM ; i < len ; i ++ ) { if ( list . char At ( i ) == delimiter ) { array . append ( list . substring ( last , i ) ) ; last = i + NUM ; } } if ( last <= len ) array . append ( list . substring ( last ) ) ; } catch ( Page Exception e ) { } return array ; }
public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > collection ) { Iterator < ? extends T > it = collection . iterator ( ) ; T min = it . next ( ) ; while ( it . has Next ( ) ) { T next = it . next ( ) ; if ( min . compare To ( next ) > NUM ) { min = next ; } } return min ; }
Server Heartbeat create Server ( String server Id ) { int p = server Id . index Of ( STRING ) ; String address = server Id . substring ( NUM , p ) ; int port = Integer . parse Int ( server Id . substring ( p + NUM ) ) ; boolean is SSL = BOOL ; return heartbeat Service . create Server ( address , port , is SSL ) ; }
public void test To String ( ) { Linked Blocking Deque q = populated Deque ( SIZE ) ; String s = q . to String ( ) ; for ( int i = NUM ; i < SIZE ; ++ i ) { assert True ( s . index Of ( String . value Of ( i ) ) >= NUM ) ; } }
public static boolean show Confirmation Dialog ( @ Not Null final Project project , final String message , final String title , final Icon logo , final String ok Action Message , final String cancel Action Message ) { final int result = Messages . show Yes No Dialog ( project , message , title , ok Action Message , cancel Action Message , logo ) ; return result == NUM ? BOOL : BOOL ; }
public void test reallocate ( ) { final Journal store = ( Journal ) get Store ( ) ; try { final byte [ ] buf = new byte [ NUM ] ; r . next Bytes ( buf ) ; final Byte Buffer bb = Byte Buffer . wrap ( buf ) ; final RW Strategy bs = ( RW Strategy ) store . get Buffer Strategy ( ) ; final RW Store rw = bs . get Store ( ) ; long faddr 1 = bs . write ( bb ) ; bb . position ( NUM ) ; long faddr 2 = bs . write ( bb ) ; bb . position ( NUM ) ; Byte Buffer inbb 1 = bs . read ( faddr 1 ) ; Byte Buffer inbb 2 = bs . read ( faddr 2 ) ; assert Equals ( bb , inbb 1 ) ; assert Equals ( bb , inbb 2 ) ; store . commit ( ) ; inbb 1 = bs . read ( faddr 1 ) ; inbb 2 = bs . read ( faddr 2 ) ; assert Equals ( bb , inbb 1 ) ; assert Equals ( bb , inbb 2 ) ; rw . reset ( ) ; inbb 1 = bs . read ( faddr 1 ) ; inbb 2 = bs . read ( faddr 2 ) ; assert Equals ( bb , inbb 1 ) ; assert Equals ( bb , inbb 2 ) ; inbb 1 = bs . read ( faddr 1 ) ; inbb 2 = bs . read ( faddr 2 ) ; assert Equals ( bb , inbb 1 ) ; assert Equals ( bb , inbb 2 ) ; } finally { store . destroy ( ) ; } }
void incoming ( ) throws IO Exception { write Line ( String . format ( STRING , host Id ) ) ; String line = read Line ( ) ; if ( network Tracing ) { logger . info ( STRING , host Id , line ) ; } Matcher matcher = make Call Pattern . matcher ( line ) ; if ( matcher . find ( ) ) { make Call = BOOL ; from Member Id = Integer . parse Int ( matcher . group ( NUM ) ) ; to Member Id = Integer . parse Int ( matcher . group ( NUM ) ) ; } else { matcher = request Call Back Pattern . matcher ( line ) ; if ( matcher . find ( ) ) { from Member Id = Integer . parse Int ( matcher . group ( NUM ) ) ; to Member Id = Integer . parse Int ( matcher . group ( NUM ) ) ; } else { throw new Illegal State Exception ( STRING + line ) ; } } }
private Collection < Inet Socket Address > filter If Necessary ( Collection < Inet Socket Address > addrs , boolean filter ) { if ( ! filter ) return addrs ; List < Inet Socket Address > res = new Array List < > ( addrs . size ( ) ) ; for ( Inet Socket Address addr : addrs ) if ( ! addr . is Unresolved ( ) ) res . add ( addr ) ; return res ; }
public static void show Profile ( Fragment fragment , String pilot Id , @ Nullable Hash Map < String , String > extras ) { if ( ( pilot Id == null || pilot Id . is Empty ( ) ) && Air Map . has Valid Authenticated User ( ) ) { pilot Id = Air Map . get User Id ( ) ; } Intent intent = new Intent ( fragment . get Activity ( ) , Profile Activity . class ) ; intent . put Extra ( Profile Activity . ARG PILOT ID , pilot Id ) ; if ( extras != null ) { intent . put Extra ( Create Flight Activity . KEY VALUE EXTRAS , extras ) ; } fragment . start Activity ( intent ) ; }
public void action Performed ( Action Event ae ) { long current Time = System . nano Time ( ) / NUM ; long total Time = current Time - cycle Start ; if ( total Time > CYCLE TIME ) { cycle Start = current Time ; } float fraction = ( float ) total Time / CYCLE TIME ; fraction = Math . min ( NUM , fraction ) ; fraction = NUM - Math . abs ( NUM - ( NUM * fraction ) ) ; animate ( fraction ) ; }
public static Array List < Product Status Bean > search Products ( Properties ctx , int ad Org Id , String name Search , String desc Search , String trx Name ) throws Operation Exception { int price List Id = POS Terminal Manager . get SO Price List Id ( ctx ) ; int warehouse Id = POS Terminal Manager . get Warehouse Id ( ctx ) ; return search Products ( ctx , ad Org Id , name Search , desc Search , price List Id , warehouse Id , trx Name ) ; }
public C Module Configuration ( final I Navi Module module , final SQL Provider provider , final Listener Provider < I Module Listener > listeners , final int module Id , final String name , final String comment , final Date creation Date , final Date modification Date , final String md 5 , final String sha 1 , final I Address file Base , final I Address image Base , final Debugger Template debugger Template , final boolean is Stared , final I Navi Raw Module raw Module ) { m module = module ; m provider = provider ; m listeners = listeners ; m id = module Id ; m name = name ; m description = comment ; m creation Date = new Date ( creation Date . get Time ( ) ) ; m modification Date = new Date ( modification Date . get Time ( ) ) ; m md 5 = md 5 ; m sha 1 = sha 1 ; m file Base = file Base ; m image Base = image Base ; m debugger Template = debugger Template ; m is Stared = is Stared ; m raw Module = raw Module ; update Debugger ( debugger Template ) ; }
public List < Object > serialize ( ) { List < Object > serialized = new Array List < > ( ) ; serialized . add ( actions ) ; serialized . add ( timestamps ) ; List < Object > serialized Funnel Steps = new Array List < > ( ) ; for ( Set e : funnel Steps ) { serialized Funnel Steps . add All ( e ) ; serialized Funnel Steps . add ( null ) ; } serialized . add ( serialized Funnel Steps ) ; return serialized ; }
public static String rename ( String desc , String oldname , String newname ) { if ( desc . index Of ( oldname ) < NUM ) return desc ; String Buffer newdesc = new String Buffer ( ) ; int head = NUM ; int i = NUM ; for ( ; ; ) { int j = desc . index Of ( STRING , i ) ; if ( j < NUM ) break ; else if ( desc . starts With ( oldname , j + NUM ) && desc . char At ( j + oldname . length ( ) + NUM ) == STRING ) { newdesc . append ( desc . substring ( head , j ) ) ; newdesc . append ( STRING ) ; newdesc . append ( newname ) ; newdesc . append ( STRING ) ; head = i = j + oldname . length ( ) + NUM ; } else { i = desc . index Of ( STRING , j ) + NUM ; if ( i < NUM ) break ; } } if ( head == NUM ) return desc ; else { int len = desc . length ( ) ; if ( head < len ) newdesc . append ( desc . substring ( head , len ) ) ; return newdesc . to String ( ) ; } }
public Solr Query add Sort ( Sort Clause sort Clause ) { if ( sort Clauses == null ) sort Clauses = new Array List < > ( ) ; sort Clauses . add ( sort Clause ) ; serialize Sorts ( ) ; return this ; }
public static void stream Content To Browser ( Http Servlet Response response , byte [ ] bytes , String content Type , String file Name ) throws IO Exception { set Response Browser Proxy No Cache ( response ) ; response . set Content Length ( bytes . length ) ; if ( content Type != null ) { response . set Content Type ( content Type ) ; } if ( file Name != null ) { response . set Header ( STRING , STRING + file Name ) ; } Output Stream out = response . get Output Stream ( ) ; Input Stream in = new Byte Array Input Stream ( bytes ) ; try { stream Content ( out , in , bytes . length ) ; } catch ( IO Exception e ) { in . close ( ) ; out . close ( ) ; throw e ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; }
public void put And Unlock ( Object key , Object value ) { String uid = String . value Of ( key ) ; Transaction tr = locked UID Hash Map . get ( uid ) ; if ( tr == null ) { map . put ( key , value , null , Integer . MAX VALUE ) ; return ; } try { map . put ( key , value , tr , Integer . MAX VALUE ) ; tr . commit ( ) ; } catch ( Throwable t ) { logger . warn ( STRING + key + STRING , t ) ; } finally { locked UID Hash Map . remove ( uid ) ; } }
private List < Long > prune Bucket ( List < Long > bucket List , double prune Factor ) { int prune Start Index = NUM ; int start Size = bucket List . size ( ) ; int i = NUM ; while ( prune Start Index < bucket List . size ( ) ) { if ( i == NUM ) { prune Start Index = ( int ) ( start Size * prune Factor ) + prune Start Index ; } i ++ ; int num To Prune = i * i * NUM ; logger . debug ( STRING + num To Prune + STRING + prune Start Index + STRING + bucket List . size ( ) + STRING ) ; List < Long > new Bucket List = bucket List . sub List ( NUM , prune Start Index ) ; int end Prune = prune Start Index + num To Prune ; if ( end Prune > bucket List . size ( ) ) { new Bucket List . add ( bucket List . get ( bucket List . size ( ) - NUM ) ) ; prune Start Index = bucket List . size ( ) ; } else { new Bucket List . add All ( bucket List . sub List ( prune Start Index + num To Prune , bucket List . size ( ) ) ) ; } bucket List = new Bucket List ; prune Start Index ++ ; } int num Records Pruned = start Size - bucket List . size ( ) ; double percent Pruned = ( ( double ) num Records Pruned / ( double ) start Size ) * NUM ; logger . debug ( STRING + num Records Pruned + STRING + start Size + STRING + percent Pruned ) ; return bucket List ; }
public void wait For Schema Agreement ( String target Schema Version , int node Count ) { long start = System . current Time Millis ( ) ; Map < String , List < String > > versions = null ; while ( System . current Time Millis ( ) - start < MAX SCHEMA WAIT MS ) { log . info ( STRING , target Schema Version , node Count ) ; versions = get Schema Versions ( ) ; if ( versions . size ( ) == NUM ) { if ( ! versions . contains Key ( target Schema Version ) ) { log . warn ( STRING , versions , target Schema Version ) ; return ; } if ( node Count != - NUM ) { List < String > hosts = null ; for ( Entry < String , List < String > > entry : versions . entry Set ( ) ) { hosts = entry . get Value ( ) ; } if ( hosts != null && hosts . size ( ) == node Count ) { log . info ( STRING , target Schema Version , node Count ) ; return ; } } else { log . info ( STRING , target Schema Version ) ; return ; } } log . info ( STRING ) ; try { Thread . sleep ( SCHEMA RETRY SLEEP MILLIS ) ; } catch ( Interrupted Exception ex ) { } } log . warn ( STRING , versions ) ; }
public void clear Local Slots ( int start , int len ) { start += current Frame Bottom ; System . arraycopy ( m nulls , NUM , stack Frames , start , len ) ; }
@ Override protected void build Sprites ( Food entity , final Map < Object , Sprite > map ) { final Sprite Store store = Sprite Store . get ( ) ; Zone Info info = Zone Info . get ( ) ; final Sprite tiles = store . get Modified Sprite ( translate ( entity . get Type ( ) ) , info . get Zone Color ( ) , info . get Color Method ( ) ) ; final int theight = tiles . get Height ( ) ; int i = NUM ; for ( int y = NUM ; y < theight ; y += I Game Screen . SIZE UNIT PIXELS ) { map . put ( Integer . value Of ( i ++ ) , store . get Tile ( tiles , NUM , y , I Game Screen . SIZE UNIT PIXELS , I Game Screen . SIZE UNIT PIXELS ) ) ; } }
public static String comparable Qualifier ( String qualifier ) { int i = QUALIFIERS . index Of ( qualifier ) ; return i == - NUM ? ( QUALIFIERS . size ( ) + STRING + qualifier ) : String . value Of ( i ) ; }
public static Object evaluate ( Object context , Object self , String expr , List < String > engine Configs ) throws Draft 3 Expression Exception { String trimmed Expr = String Utils . trim ( expr ) ; if ( trimmed Expr . starts With ( STRING ) ) { trimmed Expr = trimmed Expr . substring ( NUM ) ; } String function = trimmed Expr ; if ( trimmed Expr . starts With ( STRING ) ) { function = STRING ; function = function . replace ( STRING , trimmed Expr ) ; } Context cx = Context . enter ( ) ; cx . set Optimization Level ( OPTIMIZATION LEVEL ) ; cx . set Maximum Interpreter Stack Depth ( MAX STACK DEPTH ) ; cx . set Class Shutter ( new Draft 3 Expression Deny All Class Shutter ( ) ) ; try { Scriptable global Scope = cx . init Standard Objects ( ) ; if ( engine Configs != null ) { for ( int i = NUM ; i < engine Configs . size ( ) ; i ++ ) { Reader engine Config Reader = new String Reader ( engine Configs . get ( i ) ) ; cx . evaluate Reader ( global Scope , engine Config Reader , STRING + i + STRING , NUM , null ) ; } } put To Scope ( EXPR CONTEXT NAME , context , cx , global Scope ) ; put To Scope ( EXPR SELF NAME , self , cx , global Scope ) ; Scriptable result Scope = cx . new Object ( global Scope ) ; result Scope . set Prototype ( global Scope ) ; result Scope . set Parent Scope ( global Scope ) ; Object result = cx . evaluate String ( result Scope , function , STRING , NUM , null ) ; if ( result == null || result instanceof Undefined ) { return null ; } Object wrapped Result = Context . java To JS ( result , global Scope ) ; put To Scope ( STRING , wrapped Result , cx , global Scope ) ; Scriptable Object . put Property ( global Scope , STRING , wrapped Result ) ; String final Function = STRING + STRING + STRING + STRING + STRING ; Scriptable wrap Scope = cx . new Object ( global Scope ) ; wrap Scope . set Prototype ( global Scope ) ; wrap Scope . set Parent Scope ( global Scope ) ; result = cx . evaluate String ( wrap Scope , final Function , STRING , NUM , null ) ; return cast Result ( result ) ; } catch ( Exception e ) { String msg = String . format ( STRING , expr ) ; throw new Draft 3 Expression Exception ( msg , e ) ; } finally { Context . exit ( ) ; } }
private Parse Node parse New Instance ( Entry in Entry ) throws Configuration Exception , IO Exception { int lineno = st . lineno ( ) ; String type Name = token ( STRING ) ; int t = st . next Token ( ) ; if ( t == STRING ) { token ( STRING ) ; token ( STRING ) ; return new Array Constructor ( type Name , parse Args ( in Entry , STRING ) , lineno ) ; } else if ( t != STRING ) { syntax ( STRING ) ; } return new Constructor Call ( type Name , parse Args ( in Entry , STRING ) , lineno ) ; }
public static boolean is File URL ( URL url ) { String protocol = url . get Protocol ( ) ; return ( URL PROTOCOL FILE . equals ( protocol ) || URL PROTOCOL VFSFILE . equals ( protocol ) || URL PROTOCOL VFS . equals ( protocol ) ) ; }
public boolean equals ( Object o ) { if ( o instanceof LDAP Groups ) { LDAP Groups g = ( LDAP Groups ) o ; if ( ( selected Group D Ns != null ) && ( g . selected Group D Ns != null ) && ( selected Group D Ns . equals ( g . selected Group D Ns ) ) ) { return BOOL ; } } return BOOL ; }
private void apply Set Timestamp ( Long timestamp ) throws SQL Exception { if ( timestamp != null && conn . supports Control Timestamp ( ) ) { if ( timestamp . long Value ( ) != current Timestamp ) { current Timestamp = timestamp . long Value ( ) ; statement . add Batch ( conn . get Control Timestamp Query ( timestamp ) ) ; } } }
public T build ( Application application ) throws IO Exception { this . application = application ; if ( handler == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( constructor Arg Types . length != constructor Arg Values . length ) { throw new Illegal Argument Exception ( STRING ) ; } Class < ? extends T > proxy Class = build Proxy Class ( ) ; if ( proxy Class == null ) { return null ; } Constructor < ? extends T > constructor = null ; try { constructor = proxy Class . get Constructor ( constructor Arg Types ) ; } catch ( No Such Method Exception e ) { Constructor [ ] constructors = proxy Class . get Constructors ( ) ; for ( Constructor constructor 2 : constructors ) { if ( constructor 2 . get Generic Parameter Types ( ) . length == constructor Arg Types . length ) { constructor = constructor 2 ; break ; } } } T result ; try { result = constructor . new Instance ( constructor Arg Values ) ; } catch ( Instantiation Exception e ) { throw new Assertion Error ( e ) ; } catch ( Illegal Access Exception e ) { throw new Assertion Error ( e ) ; } catch ( Invocation Target Exception e ) { throw launder Cause ( e ) ; } set Handler Instance Field ( result , handler ) ; return result ; }
public static List < Base Mqtt Message > process Message Log ( final List < Logged Mqtt Message > list , final Progress Updater progress , final long current , final long max ) { final List < Base Mqtt Message > mqtt Message List = new Array List < Base Mqtt Message > ( ) ; long item = NUM ; for ( final Logged Mqtt Message logged Message : list ) { if ( progress != null ) { if ( progress . is Cancelled ( ) ) { logger . info ( STRING ) ; return null ; } item ++ ; if ( item % NUM == NUM ) { progress . update ( current + item , max ) ; } } mqtt Message List . add ( convert To Base Mqtt Message ( logged Message ) ) ; } logger . info ( STRING , list . size ( ) ) ; return mqtt Message List ; }
public void finish ( ) { if ( ! is Finished ( ) ) { start Time = System . current Time Millis ( ) - duration ; current Motion Time = - NUM ; } }
public void add Row ( Object [ ] row ) throws Carbon Sort Key And Group By Exception { int current Size = entry Count ; if ( sort Buffer Size == current Size ) { LOGGER . debug ( STRING ) ; intermediate File Merger . start Merging If Possible ( ) ; Object [ ] [ ] record Holder List Local = record Holder List ; try { semaphore . acquire ( ) ; data Sorter And Writer Executor Service . submit ( new Data Sorter And Writer ( record Holder List Local ) ) ; } catch ( Interrupted Exception e ) { LOGGER . error ( STRING + e . get Message ( ) ) ; throw new Carbon Sort Key And Group By Exception ( e . get Message ( ) ) ; } this . record Holder List = new Object [ this . sort Buffer Size ] [ ] ; this . entry Count = NUM ; } record Holder List [ entry Count ++ ] = row ; }
public static void dump Stack ( Address fp ) { if ( VM . Verify Assertions ) { VM . assert ( VM . running VM ) ; } Address ip = Magic . get Return Address ( fp ) ; fp = Magic . get Caller Frame Pointer ( fp ) ; dump Stack ( ip , fp ) ; }
@ Override public Path Impl scheme Walk ( String user Path , Map < String , Object > attributes , String file Path , int offset ) { String canonical Path = file Path ; if ( offset < file Path . length ( ) && file Path . char At ( offset ) == STRING ) { } else { canonical Path = normalize Path ( pathname , file Path , offset , separator Char ) ; } return fs Walk ( user Path , attributes , canonical Path ) ; }
public static boolean is Image ( String mime Type ) { if ( mime Type != null ) { if ( mime Type . starts With ( STRING ) ) return BOOL ; else return BOOL ; } else return BOOL ; }
public FX Dialog ( final Stage parent , final Modality modality , final Parent content , final double width , final double height ) { init ( parent , modality , content ) ; dialog . set Width ( width ) ; dialog . set Height ( height ) ; final Scene scene = new Scene ( content , width , height ) ; set Scene ( scene ) ; }
public static Matrix construct With Copy ( double [ ] [ ] A ) { int m = A . length ; int n = A [ NUM ] . length ; Matrix X = new Matrix ( m , n ) ; double [ ] [ ] C = X . get Array ( ) ; for ( int i = NUM ; i < m ; i ++ ) { if ( A [ i ] . length != n ) { throw new Illegal Argument Exception ( STRING ) ; } for ( int j = NUM ; j < n ; j ++ ) { C [ i ] [ j ] = A [ i ] [ j ] ; } } return X ; }
public void remove Attribute ( String attr Name , String value ) throws SMS Exception { Set attr = null ; if ( ( attr Set == null ) || ( ( attr = ( Set ) attr Set . get ( attr Name ) ) == null ) || ( ! attr . contains ( value ) ) ) { throw ( new SMS Exception ( Ldap Exception . new Ldap Exception ( Result Code . ATTRIBUTE OR VALUE EXISTS , get Bundle String ( IUMS Constants . SMS ATTR OR VAL EXISTS ) ) , STRING ) ) ; } attr . remove ( value ) ; attr Set . put ( attr Name , attr ) ; if ( mod Set == null ) { mod Set = new Hash Set ( ) ; } mod Set . add ( new Modification Item ( Dir Context . REMOVE ATTRIBUTE , new Basic Attribute ( attr Name , value ) ) ) ; }
public void on Draw Frame ( GL 10 gl Unused ) { boolean is New Frame = BOOL ; int frame Number = NUM ; synchronized ( this ) { if ( update Surface ) { is New Frame = BOOL ; frame Number = m Frame Number ; m Surface . update Tex Image ( ) ; m Surface . get Transform Matrix ( mST Matrix ) ; update Surface = BOOL ; } } GLES 20 . gl Clear Color ( NUM , NUM , NUM , NUM ) ; GLES 20 . gl Clear ( GLES 20 . GL DEPTH BUFFER BIT | GLES 20 . GL COLOR BUFFER BIT ) ; GLES 20 . gl Use Program ( m Program ) ; check Gl Error ( STRING ) ; GLES 20 . gl Active Texture ( GLES 20 . GL TEXTURE 0 ) ; GLES 20 . gl Bind Texture ( GL TEXTURE EXTERNAL OES , m Texture ID ) ; m Triangle Vertices . position ( TRIANGLE VERTICES DATA POS OFFSET ) ; GLES 20 . gl Vertex Attrib Pointer ( ma Position Handle , NUM , GLES 20 . GL FLOAT , BOOL , TRIANGLE VERTICES DATA STRIDE BYTES , m Triangle Vertices ) ; check Gl Error ( STRING ) ; GLES 20 . gl Enable Vertex Attrib Array ( ma Position Handle ) ; check Gl Error ( STRING ) ; m Triangle Vertices . position ( TRIANGLE VERTICES DATA UV OFFSET ) ; GLES 20 . gl Vertex Attrib Pointer ( ma Texture Handle , NUM , GLES 20 . GL FLOAT , BOOL , TRIANGLE VERTICES DATA STRIDE BYTES , m Triangle Vertices ) ; check Gl Error ( STRING ) ; GLES 20 . gl Enable Vertex Attrib Array ( ma Texture Handle ) ; check Gl Error ( STRING ) ; Matrix . set Identity M ( mMVP Matrix , NUM ) ; GLES 20 . gl Uniform Matrix 4 fv ( mu MVP Matrix Handle , NUM , BOOL , mMVP Matrix , NUM ) ; GLES 20 . gl Uniform Matrix 4 fv ( mu ST Matrix Handle , NUM , BOOL , mST Matrix , NUM ) ; GLES 20 . gl Draw Arrays ( GLES 20 . GL TRIANGLE STRIP , NUM , NUM ) ; check Gl Error ( STRING ) ; GLES 20 . gl Finish ( ) ; if ( is New Frame ) { Log . d ( TAG , m Draw Number + STRING + frame Number + STRING + System . current Time Millis ( ) ) ; Dump To File ( frame Number ) ; Log . d ( TAG , m Draw Number + STRING + frame Number + STRING + System . current Time Millis ( ) ) ; m Draw Number ++ ; } }
private static Debugger Options parse Options Information ( final Node node ) throws Message Parser Exception { final Node List nodes = node . get Child Nodes ( ) ; final Debugger Options Builder builder = new Debugger Options Builder ( ) ; for ( int i = NUM ; i < nodes . get Length ( ) ; ++ i ) { final Node child = nodes . item ( i ) ; final String name = get Attribute ( child , STRING ) ; switch ( Target Information Debugger Options . get Enum ( name ) ) { case CAN DETACH : builder . can Detach ( parse Boolean Option ( child ) ) ; break ; case CAN ATTACH : builder . can Attach ( parse Boolean Option ( child ) ) ; break ; case CAN TERMINATE : builder . can Terminate ( parse Boolean Option ( child ) ) ; break ; case HAS STACK : builder . stack Available ( parse Boolean Option ( child ) ) ; break ; case CAN VALIDATE MEMORY : builder . can Validate Memory ( parse Boolean Option ( child ) ) ; break ; case CAN HALT : builder . can Halt ( parse Boolean Option ( child ) ) ; break ; case CAN HALT BEFORE COMMUNICATING : builder . can Halt Before Communicating ( parse Boolean Option ( child ) ) ; break ; case CAN MULTI THREAD : builder . can Multithread ( parse Boolean Option ( child ) ) ; break ; case CAN SOFTWARE BREAKPOINTS : builder . can Software Breakpoints ( parse Boolean Option ( child ) ) ; break ; case BREAKPOINT COUNT : builder . breakpoint Counter ( parse Int Option ( child , STRING ) ) ; break ; case PAGE SIZE : builder . page Size ( parse Int Option ( child , STRING ) ) ; break ; case CAN BREAK ON MODULE LOAD : builder . can Break On Module Load ( parse Boolean Option ( child ) ) ; break ; case CAN BREAK ON MODULE UNLOAD : builder . can Break On Module Unload ( parse Boolean Option ( child ) ) ; break ; case EXCEPTION : builder . add Exception ( parse Exception Option ( child ) ) ; break ; case CAN TRACE COUNT : builder . can Trace Counts ( parse Boolean Option ( child ) ) ; break ; case CAN MEMMAP : builder . can Memmap ( parse Boolean Option ( child ) ) ; break ; default : throw new Message Parser Exception ( String . format ( STRING , name ) ) ; } } return builder . build ( ) ; }
public Image rotate 90 Degrees ( Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = NUM ; y < height ; y ++ ) { for ( int x = NUM ; x < width ; x ++ ) { int dest X = height - y - NUM ; new RGB [ dest X + x * height ] = rgb [ x + y * width ] ; } } return Encoded Image . create From RGB ( new RGB , height , width , ! maintain Opacity ) ; }
public Big Decimal invoke ( M Depreciation Workfile assetwk , M Asset Acct asset Acct , int A Current Period , Big Decimal Accum Dep ) { String depreciation Type = get Depreciation Type ( ) ; Big Decimal ret Value = null ; if ( C Log Mgt . is Level Finest ( ) ) { log . fine ( STRING + depreciation Type + STRING + assetwk + STRING + asset Acct + STRING + A Current Period + STRING + Accum Dep ) ; } if ( ! can Invoke ( assetwk , asset Acct , A Current Period , Accum Dep ) ) { return Big Decimal . ZERO ; } if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply SL ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH VAR ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH AD 1 ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH AD 2 ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH ZERO ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else { throw new Asset Not Supported Exception ( COLUMNNAME Depreciation Type , depreciation Type ) ; } if ( ret Value == null ) { ret Value = Big Decimal . ZERO ; } ret Value = ret Value . set Scale ( get Precision ( ) , Rounding Mode . HALF UP ) ; if ( C Log Mgt . is Level Finest ( ) ) log . fine ( STRING + ret Value ) ; return ret Value ; }
private void fill Resource ( ) { Key Name Pair pp = ( Key Name Pair ) field Resource Type . get Selected Item ( ) ; if ( pp == null ) return ; int S Resource Type ID = pp . get Key ( ) ; Key Name Pair default Value = null ; m loading = BOOL ; field Resource . remove All Items ( ) ; String sql = STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM , S Resource Type ID ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { pp = new Key Name Pair ( rs . get Int ( NUM ) , rs . get String ( NUM ) ) ; if ( m m Assignment . get S Resource ID ( ) == pp . get Key ( ) ) default Value = pp ; field Resource . add Item ( pp ) ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( default Value != null ) field Resource . set Selected Item ( default Value ) ; m loading = BOOL ; }
private static Coordinate [ ] coordinates ( Edge component , Coordinate [ ] coordinates ) { for ( int i = NUM ; i < coordinates . length ; i ++ ) { coordinates [ i ] = ( component = component . next ) . coordinate ; } return coordinates ; }
@ Override public void close ( ) throws IO Exception { if ( closed . compare And Set ( BOOL , BOOL ) ) { close ( BOOL ) ; } }
@ Override public boolean connection Allowed ( String event Name ) { if ( ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) && ! event Name . equals ( STRING ) ) { return BOOL ; } if ( m listenee != null ) { return BOOL ; } return BOOL ; }
public void add Flakes ( int quantity ) { for ( int i = NUM ; i < quantity ; ++ i ) { flakes . add ( Flake . create Flake ( get Width ( ) , droid , get Context ( ) ) ) ; } set Num Flakes ( num Flakes + quantity ) ; }
public boolean not Required Resource Name ( Policy policy , String realm Name , String name ) { get Svc Type Name To Actions Map ( policy , realm Name ) ; return not Required Resource Name Service . contains ( name ) ; }
public static void main ( String [ ] args ) { String [ ] script Args = process Options ( args ) ; for ( Command cmd : scripts ) { cmd . run ( script Args ) ; } System . exit ( EXIT SUCCESS ) ; }
protected String r ( String s , String u ) throws Exception { Date dt = Date Math Parser . parse Math ( null , s + STRING + u ) ; return fmt . format ( dt . to Instant ( ) ) ; }
private static void unpack ( final File nar , final File working Directory , final byte [ ] hash ) throws IO Exception { try ( Jar File jar File = new Jar File ( nar ) ) { Enumeration < Jar Entry > jar Entries = jar File . entries ( ) ; while ( jar Entries . has More Elements ( ) ) { Jar Entry jar Entry = jar Entries . next Element ( ) ; String name = jar Entry . get Name ( ) ; File f = new File ( working Directory , name ) ; if ( jar Entry . is Directory ( ) ) { File Utils . ensure Directory Exist And Can Access ( f ) ; } else { make File ( jar File . get Input Stream ( jar Entry ) , f ) ; } } } final File hash File = new File ( working Directory , HASH FILENAME ) ; try ( final File Output Stream fos = new File Output Stream ( hash File ) ) { fos . write ( hash ) ; } }
private void init Contents ( ) { if ( null != initial Threshold ) { threshold Box . set Text ( String . value Of ( initial Threshold ) ) ; } lower Threshold Check Box . set Selection ( initial Lower Threshold ) ; timerange Spinner . set Selection ( ( int ) initial Timerange ) ; if ( null != initials Emails ) { String emails Text = STRING ; for ( String email : initials Emails ) { if ( ! emails Text . is Empty ( ) ) { emails Text += NEW LINE ; } emails Text += email ; } emails Box . set Text ( emails Text ) ; } }
public void log It ( String [ ] s , int type , String message Name , Hashtable sso Properties ) { if ( log Status && ( s != null ) ) { try { Log Message Provider Base provider = ( Log Message Provider Base ) Message Provider Factory . get Provider ( STRING ) ; com . sun . identity . log . Log Record lr = null ; SSO Token ssot = Access Controller . do Privileged ( Admin Token Action . get Instance ( ) ) ; if ( sso Properties == null ) { lr = provider . create Log Record ( message Name , s , ssot ) ; } else { lr = provider . create Log Record ( message Name , s , sso Properties ) ; } com . sun . identity . log . Logger logger ; switch ( type ) { case LOG ACCESS : logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( STRING ) ; logger . log ( lr , ssot ) ; break ; case LOG ERROR : logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( STRING ) ; logger . log ( lr , ssot ) ; break ; default : logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( STRING ) ; logger . log ( lr , ssot ) ; break ; } } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; debug . error ( STRING + ex . get Message ( ) ) ; } } }
public static boolean is Letter Or Digit ( Character self ) { return Character . is Letter Or Digit ( self ) ; }
@ Override public Cursor query ( Uri uri , String [ ] projection , String selection , String [ ] selection Args , String sort Order ) { if ( uri == null ) { Log Utils . log ( this , Log . WARN , NULL URI FORMAT STRING ) ; return null ; } final SQ Lite Query Builder query Builder = new SQ Lite Query Builder ( ) ; query Builder . set Tables ( Labels Table . TABLE NAME ) ; String group By = null ; switch ( s Uri Matcher . match ( uri ) ) { case LABELS : if ( Text Utils . is Empty ( sort Order ) ) { sort Order = Labels Table . KEY ID ; } break ; case LABELS ID : final String label Id String = uri . get Last Path Segment ( ) ; final int label Id ; try { label Id = Integer . parse Int ( label Id String ) ; } catch ( Number Format Exception e ) { Log Utils . log ( this , Log . WARN , UNKNOWN URI FORMAT STRING , uri ) ; return null ; } final String where = String . format ( STRING , Labels Table . KEY ID , label Id ) ; query Builder . append Where ( where ) ; break ; case PACKAGE SUMMARY : projection = new String [ ] { Labels Table . KEY PACKAGE NAME , STRING } ; group By = Labels Table . KEY PACKAGE NAME ; sort Order = Labels Table . KEY PACKAGE NAME ; break ; default : Log Utils . log ( this , Log . WARN , UNKNOWN URI FORMAT STRING , uri ) ; return null ; } initialize Database If Null ( ) ; return query Builder . query ( m Database , projection , selection , selection Args , group By , null , sort Order ) ; }
private Query Builder Kraken parse Watch ( ) { Watch Query Builder query = new Watch Query Builder ( table Manager , sql ) ; Token token ; String table Name = parse Table Name ( ) ; query . set Table Name ( table Name ) ; query = query ; Expr Kraken where Expr = null ; token = scan Token ( ) ; if ( token == Token . WHERE ) { where Expr = parse Expr ( ) ; } else if ( token != null ) { throw error ( STRING , token ) ; } Param Expr [ ] params = params . to Array ( new Param Expr [ params . size ( ) ] ) ; query . set Params ( params ) ; query . set Where Expr ( where Expr ) ; return query ; }
private int node List Get Length ( ) { if ( f Node List Cache == null ) { if ( needs Sync Children ( ) ) { synchronize Children ( ) ; } if ( first Child == null ) { return NUM ; } if ( first Child == last Child ( ) ) { return NUM ; } f Node List Cache = owner Document . get Node List Cache ( this ) ; } if ( f Node List Cache . f Length == - NUM ) { int l ; Child Node n ; if ( f Node List Cache . f Child Index != - NUM && f Node List Cache . f Child != null ) { l = f Node List Cache . f Child Index ; n = f Node List Cache . f Child ; } else { n = first Child ; l = NUM ; } while ( n != null ) { l ++ ; n = n . next Sibling ; } f Node List Cache . f Length = l ; } return f Node List Cache . f Length ; }
static Path Part from ( String encoded , String decoded ) { if ( encoded == null ) { return NULL ; } if ( encoded . length ( ) == NUM ) { return EMPTY ; } return new Path Part ( encoded , decoded ) ; }
public static Binary Field Accessor create ( Field field , int id ) { Binary Write Mode mode = Binary Utils . mode ( field . get Type ( ) ) ; switch ( mode ) { case P BYTE : return new Byte Primitive Accessor ( field , id ) ; case P BOOLEAN : return new Boolean Primitive Accessor ( field , id ) ; case P SHORT : return new Short Primitive Accessor ( field , id ) ; case P CHAR : return new Char Primitive Accessor ( field , id ) ; case P INT : return new Int Primitive Accessor ( field , id ) ; case P LONG : return new Long Primitive Accessor ( field , id ) ; case P FLOAT : return new Float Primitive Accessor ( field , id ) ; case P DOUBLE : return new Double Primitive Accessor ( field , id ) ; case BYTE : case BOOLEAN : case SHORT : case CHAR : case INT : case LONG : case FLOAT : case DOUBLE : case DECIMAL : case STRING : case UUID : case DATE : case TIMESTAMP : case BYTE ARR : case SHORT ARR : case INT ARR : case LONG ARR : case FLOAT ARR : case DOUBLE ARR : case CHAR ARR : case BOOLEAN ARR : case DECIMAL ARR : case STRING ARR : case UUID ARR : case DATE ARR : case TIMESTAMP ARR : case ENUM ARR : case OBJECT ARR : case BINARY OBJ : case BINARY : return new Default Final Class Accessor ( field , id , mode , BOOL ) ; default : return new Default Final Class Accessor ( field , id , mode , ! U . is Final ( field . get Type ( ) ) ) ; } }
@ Override public Vector what Can Go Here ( int [ ] state ) { int cur State = state [ NUM ] ; if ( cur State < NUM ) cur State = state [ NUM ] ; Occurence o = ( f Counting States != null ) ? f Counting States [ cur State ] : null ; int count = state [ NUM ] ; Vector ret = new Vector ( ) ; for ( int elem Index = NUM ; elem Index < f Elem Map Size ; elem Index ++ ) { int next State = f Trans Table [ cur State ] [ elem Index ] ; if ( next State != - NUM ) { if ( o != null ) { if ( cur State == next State ) { if ( count >= o . max Occurs && o . max Occurs != Schema Symbols . OCCURRENCE UNBOUNDED ) { continue ; } } else if ( count < o . min Occurs ) { continue ; } } ret . add Element ( f Elem Map [ elem Index ] ) ; } } return ret ; }
@ Suppress Warnings ( STRING ) @ Deprecated private static Template Sequence Model to Simple Sequence ( Template Model object , Object Wrapper object Wrapper ) throws Template Model Exception { if ( object instanceof Template Sequence Model ) { return ( Template Sequence Model ) object ; } else if ( object instanceof Wrapper Template Model ) { Wrapper Template Model wrapper Model = ( Wrapper Template Model ) object ; Object wrapped Object = wrapper Model . get Wrapped Object ( ) ; if ( wrapped Object instanceof List ) { return Default List Adapter . adapt ( ( List < Object > ) wrapped Object , ( Rich Object Wrapper ) object Wrapper ) ; } else if ( wrapped Object instanceof Object [ ] ) { return Default Array Adapter . adapt ( ( Object [ ] ) wrapped Object , ( Object Wrapper And Unwrapper ) object Wrapper ) ; } else if ( wrapped Object instanceof Set ) { throw new Unsupported Operation Exception ( STRING ) ; } else if ( wrapped Object instanceof Collection ) { throw new Unsupported Operation Exception ( STRING ) ; } else if ( wrapped Object instanceof Iterable ) { throw new Unsupported Operation Exception ( STRING ) ; } else { throw new Template Model Exception ( STRING + ( object != null ? object . get Class ( ) : STRING ) + STRING ) ; } } else if ( object instanceof Template Collection Model ) { Template Collection Model coll Model = ( Template Collection Model ) object ; Simple Sequence res = new Simple Sequence ( object Wrapper ) ; Template Model Iterator it = coll Model . iterator ( ) ; while ( it . has Next ( ) ) { res . add ( it . next ( ) ) ; } return res ; } else { throw new Template Model Exception ( STRING + ( object != null ? object . get Class ( ) : STRING ) + STRING ) ; } }
public Secure Random Pool ( String algorithm , int pool Size , Secure Random seed ) { if ( algorithm == null ) { throw new Illegal Argument Exception ( STRING ) ; } pool = new Array List < Secure Random > ( pool Size ) ; seed Source = get Seed Source ( algorithm , ( seed != null ) ? seed : new Secure Random ( ) ) ; try { for ( int i = NUM ; i < pool Size ; i ++ ) { byte [ ] seed Bytes = new byte [ NUM ] ; seed Source . next Bytes ( seed Bytes ) ; Secure Random random = Secure Random . get Instance ( algorithm ) ; random . set Seed ( seed Bytes ) ; pool . add ( random ) ; } } catch ( No Such Algorithm Exception e ) { String msg = STRING + algorithm + STRING ; log . error ( msg , e ) ; throw new Runtime Exception ( msg , e ) ; } }
public static void check Field Value From Enum ( final String value , final String field Name , Class < ? extends Enum > enum Type ) { if ( value != null ) { check Field Value From Enum ( value , field Name , Enum Set . all Of ( enum Type ) ) ; } }
public void remove Events ( ) { scene . set On Key Pressed ( null ) ; scene . set On Key Released ( null ) ; up = down = left = right = sprint = jump = shoot Fireball = BOOL ; }
public void write Collection State ( URI backup Loc , String backup Id , String collection Name , Doc Collection collection State ) throws IO Exception { URI dest = repository . resolve ( backup Loc , backup Id , ZK STATE DIR , COLLECTION PROPS FILE ) ; try ( Output Stream collection State Os = repository . create Output ( dest ) ) { collection State Os . write ( Utils . to JSON ( Collections . singleton Map ( collection Name , collection State ) ) ) ; } }
static public void fill Random Uniform ( I Double Vector vec , Random rand , double min , double max ) { final double delta = max - min ; for ( int i = NUM ; i < vec . get Length ( ) ; ++ i ) { vec . set ( i , min + rand . next Double ( ) * delta ) ; } }
public static synchronized Bean Info find Bean Info ( String bean Class Name ) { String [ ] bean Info Paths = Introspector . get Bean Info Search Path ( ) ; String info Class Name = bean Class Name + STRING ; Class info Class = null ; try { info Class = Class . for Name ( info Class Name ) ; return ( Bean Info ) info Class . new Instance ( ) ; } catch ( Exception ex ) { } for ( int i = NUM ; i < bean Info Paths . length ; i ++ ) { int index = bean Class Name . last Index Of ( STRING ) ; String class Name With Dot = bean Class Name . substring ( index ) ; info Class Name = bean Info Paths [ i ] + class Name With Dot + STRING ; try { info Class = Class . for Name ( info Class Name ) ; break ; } catch ( Class Not Found Exception ex ) { } } Object retval = null ; if ( info Class != null ) { try { retval = info Class . new Instance ( ) ; } catch ( Exception ex ) { } } return ( Bean Info ) retval ; }
@ Override public int compare To ( Rule Net p other ) { if ( p other == null ) return NUM ; return name . compare To Ignore Case ( p other . name ) ; }
protected void draw Range Markers ( Graphics 2 D g2 , Rectangle 2 D data Area , int index , Layer layer ) { Category Item Renderer r = get Renderer ( index ) ; if ( r == null ) { return ; } Collection markers = get Range Markers ( index , layer ) ; Value Axis axis = get Range Axis For Dataset ( index ) ; if ( markers != null && axis != null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . has Next ( ) ) { Marker marker = ( Marker ) iterator . next ( ) ; r . draw Range Marker ( g2 , this , axis , marker , data Area ) ; } } }
public VPF Feature Layer ( ) { set Projection Change Policy ( new com . bbn . openmap . layer . policy . List Reset PC Policy ( this ) ) ; set Mouse Mode I Ds For Events ( new String [ ] { STRING } ) ; warehouse = new VPF Auto Feature Graphic Warehouse ( ) ; }
protected void release ( Pooled Connection con ) { if ( con == null ) return ; try { con . lock ( ) ; if ( con . release ( ) ) { size . add And Get ( - NUM ) ; con . set Handler ( null ) ; } } finally { con . unlock ( ) ; } if ( waitcount . get ( ) > NUM ) { idle . offer ( create ( BOOL ) ) ; } }
private static float [ ] rgb To HLS ( int rgb , float [ ] hls ) { float r = ( ( rgb & NUM ) > > NUM ) / NUM ; float g = ( ( rgb & NUM ) > > NUM ) / NUM ; float b = ( rgb & NUM ) / NUM ; float max = Math . max ( Math . max ( r , g ) , b ) ; float min = Math . min ( Math . min ( r , g ) , b ) ; float l = ( max + min ) / NUM ; float s = NUM ; float h = NUM ; if ( max != min ) { float delta = max - min ; s = ( l <= NUM ) ? ( delta / ( max + min ) ) : ( delta / ( NUM - max - min ) ) ; if ( r == max ) { h = ( g - b ) / delta ; } else if ( g == max ) { h = NUM + ( b - r ) / delta ; } else { h = NUM + ( r - g ) / delta ; } h *= NUM ; if ( h < NUM ) { h += NUM ; } } if ( hls == null ) { hls = new float [ NUM ] ; } hls [ NUM ] = h ; hls [ NUM ] = l ; hls [ NUM ] = s ; return hls ; }
public static void exec And Check Output ( Process Builder builder , String expected Out , String expected Err ) throws Exception { Process process = builder . start ( ) ; Executor Service executor Service = Executors . new Fixed Thread Pool ( NUM ) ; try { Future < String > err Future = executor Service . submit ( stream To String Callable ( process . get Error Stream ( ) ) ) ; Future < String > out Future = executor Service . submit ( stream To String Callable ( process . get Input Stream ( ) ) ) ; assert Equals ( expected Out , out Future . get ( NUM , Time Unit . SECONDS ) ) ; assert Equals ( expected Err , err Future . get ( NUM , Time Unit . SECONDS ) ) ; } finally { executor Service . shutdown ( ) ; process . wait For ( ) ; } }
public long file Size ( String path ) throws Illegal State Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception { synchronized ( lock ) { if ( ! connected ) { throw new Illegal State Exception ( STRING ) ; } if ( ! authenticated ) { throw new Illegal State Exception ( STRING ) ; } communication . send FTP Command ( STRING ) ; FTP Reply r = communication . read FTP Reply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new FTP Exception ( r ) ; } communication . send FTP Command ( STRING + path ) ; r = communication . read FTP Reply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new FTP Exception ( r ) ; } String [ ] messages = r . get Messages ( ) ; if ( messages . length != NUM ) { throw new FTP Illegal Reply Exception ( ) ; } else { try { return Long . parse Long ( messages [ NUM ] ) ; } catch ( Throwable t ) { throw new FTP Illegal Reply Exception ( ) ; } } } }
String catalog Cond ( String column Name , String catalog ) { if ( catalog == null && connection . null Catalog Means Current ) { catalog = STRING ; } if ( catalog == null ) { return STRING ; } if ( catalog . equals ( STRING ) ) { return STRING + column Name + STRING ; } return STRING + column Name + STRING + escape Quote ( catalog ) + STRING ; }
public boolean compute Scroll Offset ( ) { if ( m Finished ) { return BOOL ; } final long time Passed = Animation Utils . current Animation Time Millis ( ) - m Start Time ; float time Passed Percent = time Passed * NUM / m Duration ; if ( time Passed >= m Duration ) { m Finished = BOOL ; time Passed Percent = NUM ; } m Curr Value = Math . round ( m Value Factor * m Path Points Holder . get Y ( time Passed Percent ) ) ; return BOOL ; }
public void report ( Quality Query qq , Top Docs td , String doc Name Field , Index Searcher searcher ) throws IO Exception { if ( logger == null ) { return ; } Score Doc sd [ ] = td . score Docs ; String sep = STRING ; Doc Name Extractor xt = new Doc Name Extractor ( doc Name Field ) ; for ( int i = NUM ; i < sd . length ; i ++ ) { String doc Name = xt . doc Name ( searcher , sd [ i ] . doc ) ; logger . println ( qq . get Query ID ( ) + sep + STRING + sep + format ( doc Name , NUM ) + sep + format ( STRING + i , NUM ) + sep + nf . format ( sd [ i ] . score ) + sep + name ) ; } }
public String num Folds Tip Text ( ) { return STRING ; }
@ Request Mapping ( value = STRING , method = POST ) public void start Job ( final @ Path Variable String job Type , final Http Servlet Request request , final Http Servlet Response response ) throws IO Exception { final Optional < String > job Id = job Service . start Async Job ( job Type ) ; if ( job Id . is Present ( ) ) { response . set Header ( STRING , base Uri Of ( request ) + STRING + job Id . get ( ) ) ; response . set Status ( SC NO CONTENT ) ; } else { response . send Error ( SC CONFLICT ) ; } }
public static Q Name value Of ( Char Sequence name ) { Q Name q Name = ( Q Name ) FULL NAME TO QNAME . get ( name ) ; return ( q Name != null ) ? q Name : Q Name . create No Namespace ( name . to String ( ) ) ; }
public final void open Fallback Output Stream ( ) throws Data Fallback Exception { if ( output == null ) { if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING + data File . get Name ( ) + STRING ) ; try { output = new Buffered Writer ( new File Writer ( data File , BOOL ) ) ; } catch ( IO Exception e ) { throw new Data Fallback Exception ( e . get Message ( ) ) ; } } }
public void add Memory Listener ( final I Memory Listener listener ) { Preconditions . check Not Null ( listener , STRING ) ; m listeners . add ( listener ) ; }
static public Serial Sensor Manager instance ( ) { if ( instance == null ) { instance = new Serial Sensor Manager ( ) ; } return instance ; }
private void copy Members ( Date Format Symbols src , Date Format Symbols dst ) { dst . locale = src . locale ; dst . eras = Arrays . copy Of ( src . eras , src . eras . length ) ; dst . months = Arrays . copy Of ( src . months , src . months . length ) ; dst . short Months = Arrays . copy Of ( src . short Months , src . short Months . length ) ; dst . weekdays = Arrays . copy Of ( src . weekdays , src . weekdays . length ) ; dst . short Weekdays = Arrays . copy Of ( src . short Weekdays , src . short Weekdays . length ) ; dst . ampms = Arrays . copy Of ( src . ampms , src . ampms . length ) ; if ( src . zone Strings != null ) { dst . zone Strings = src . get Zone Strings Impl ( BOOL ) ; } else { dst . zone Strings = null ; } dst . local Pattern Chars = src . local Pattern Chars ; dst . cached Hash Code = NUM ; }
private static String extract Top Item ( String search String , String schema , int start Idx ) { String extracted = null ; int prop Idx = schema . index Of ( STRING , start Idx ) ; if ( prop Idx == - NUM ) { prop Idx = Integer . MAX VALUE ; } int id Idx = schema . index Of ( STRING + search String + STRING , start Idx ) ; int second Id Idx = schema . index Of ( STRING + search String + STRING , id Idx + NUM ) ; if ( second Id Idx != - NUM && prop Idx > second Id Idx ) { id Idx = second Id Idx ; } if ( id Idx != - NUM && prop Idx > id Idx ) { int value Start Idx = schema . index Of ( STRING , id Idx + ( search String . length ( ) + NUM ) ) ; int value End Idx = schema . index Of ( STRING , value Start Idx + NUM ) ; extracted = schema . substring ( value Start Idx + NUM , value End Idx ) ; } return extracted ; }
public boolean is Used ( long pos , int length ) { int start = get Block ( pos ) ; int blocks = get Block Count ( length ) ; for ( int i = start ; i < start + blocks ; i ++ ) { if ( ! set . get ( i ) ) { return BOOL ; } } return BOOL ; }
public Cholesky Decomposition ( Matrix Arg ) { double [ ] [ ] A = Arg . get Array ( ) ; n = Arg . get Row Dimension ( ) ; L = new double [ n ] [ n ] ; isspd = ( Arg . get Column Dimension ( ) == n ) ; for ( int j = NUM ; j < n ; j ++ ) { double [ ] Lrowj = L [ j ] ; double d = NUM ; for ( int k = NUM ; k < j ; k ++ ) { double [ ] Lrowk = L [ k ] ; double s = NUM ; for ( int i = NUM ; i < k ; i ++ ) { s += Lrowk [ i ] * Lrowj [ i ] ; } Lrowj [ k ] = s = ( A [ j ] [ k ] - s ) / L [ k ] [ k ] ; d = d + s * s ; isspd = isspd & ( A [ k ] [ j ] == A [ j ] [ k ] ) ; } d = A [ j ] [ j ] - d ; isspd = isspd & ( d > NUM ) ; L [ j ] [ j ] = Math . sqrt ( Math . max ( d , NUM ) ) ; for ( int k = j + NUM ; k < n ; k ++ ) { L [ j ] [ k ] = NUM ; } } }
protected String read String UTF 16 Z ( int addr ) { if ( addr == NUM ) { return null ; } I Memory Reader memory Reader = Memory Reader . get Memory Reader ( addr , NUM ) ; String Builder s = new String Builder ( ) ; while ( BOOL ) { int char 16 = memory Reader . read Next ( ) ; if ( char 16 == NUM ) { break ; } byte [ ] bytes = new byte [ NUM ] ; bytes [ NUM ] = ( byte ) char 16 ; bytes [ NUM ] = ( byte ) ( char 16 > > NUM ) ; s . append ( new String ( bytes , charset 16 ) ) ; } return s . to String ( ) ; }
@ Override public void agg ( Object new Val ) { value Set . add ( new Val instanceof Double ? ( Double ) new Val : new Double ( new Val . to String ( ) ) ) ; first Time = BOOL ; }
private void change Announcement ( Player active Player , String announcement ) { if ( legion Restrictions . can Change Announcement ( active Player . get Legion Member ( ) , announcement ) ) { Legion legion = active Player . get Legion ( ) ; Timestamp current Time = new Timestamp ( System . current Time Millis ( ) ) ; store New Announcement ( legion . get Legion Id ( ) , current Time , announcement ) ; legion . add Announcement To List ( current Time , announcement ) ; Packet Send Utility . send Packet ( active Player , SM SYSTEM MESSAGE . STR GUILD WRITE NOTICE DONE ) ; Packet Send Utility . broadcast Packet To Legion ( legion , new SM LEGION EDIT ( NUM , ( int ) ( System . current Time Millis ( ) / NUM ) , announcement ) ) ; } }
public void characters ( String characters ) throws SAX Exception { final int len = characters . length ( ) ; if ( len > m chars Buff . length ) { m chars Buff = new char [ len * NUM + NUM ] ; } characters . get Chars ( NUM , len , m chars Buff , NUM ) ; characters ( m chars Buff , NUM , len ) ; }
protected void internal Transform ( Body b , String phase Name , Map options ) { Stmt Body stmt Body = ( Stmt Body ) b ; Chain < Unit > units = stmt Body . get Units ( ) ; Iterator < Unit > stmt It = units . snapshot Iterator ( ) ; Normal Unit Printer nup = new Normal Unit Printer ( b ) ; while ( stmt It . has Next ( ) ) { Stmt stmt = ( Stmt ) stmt It . next ( ) ; if ( ! stmt . contains Invoke Expr ( ) ) { continue ; } Invoke Expr expr = ( Invoke Expr ) stmt . get Invoke Expr ( ) ; Assign Stmt assign Stmt = null ; if ( stmt instanceof Assign Stmt ) { assign Stmt = ( Assign Stmt ) stmt ; } else { continue ; } inspect And Replace Calls ( units , assign Stmt , expr ) ; } }
public static String unescape HTML ( String str ) { String Builder rtn = new String Builder ( ) ; int pos Start = - NUM ; int pos Finish = - NUM ; while ( ( pos Start = str . index Of ( STRING , pos Start ) ) != - NUM ) { int last = pos Finish + NUM ; pos Finish = str . index Of ( STRING , pos Start ) ; if ( pos Finish == - NUM ) break ; rtn . append ( str . substring ( last , pos Start ) ) ; if ( pos Start + NUM < pos Finish ) { rtn . append ( unescape HTML Entity ( str . substring ( pos Start + NUM , pos Finish ) ) ) ; } else { rtn . append ( STRING ) ; } pos Start = pos Finish + NUM ; } rtn . append ( str . substring ( pos Finish + NUM ) ) ; return rtn . to String ( ) ; }
public synchronized void delete Closed Connections ( ) { final Iterator iter = free Connections . iterator ( ) ; while ( iter . has Next ( ) ) { final Http Connection conn = ( Http Connection ) iter . next ( ) ; if ( ! conn . is Open ( ) ) { iter . remove ( ) ; delete Connection ( conn ) ; } } }
public Gtfs Parser ( String network , String schedule ) { this . sc = parse Schedule ( schedule , network ) ; this . tr Config = new Transit Router Config ( sc . get Config ( ) ) ; this . tr Router = new Transit Router Impl ( this . tr Config , sc . get Transit Schedule ( ) ) ; }

void open ( int context Prec , int own Prec ) throws IO Exception { if ( own Prec < context Prec ) out . write ( STRING ) ; }
public void load Icon Callback ( byte [ ] data , int width , int height , int row Stride , int bps , int channels , boolean alpha ) { tmp Image = null ; Data Buffer data Buf = new Data Buffer Byte ( data , ( row Stride * height ) ) ; Writable Raster raster = Raster . create Interleaved Raster ( data Buf , width , height , row Stride , channels , ( alpha ? BAND OFFSETS ALPHA : BAND OFFSETS ) , null ) ; Color Model color Model = new Component Color Model ( Color Space . get Instance ( Color Space . CS sRGB ) , alpha , BOOL , Color Model . TRANSLUCENT , Data Buffer . TYPE BYTE ) ; tmp Image = new Buffered Image ( color Model , raster , BOOL , null ) ; }
public final void remove All ( ) { action List . clear ( ) ; constraints List . clear ( ) ; need Sorting = BOOL ; }
@ Override default Completable Future < Optional Double > average Long ( final To Long Function < ? super T > fn ) { return Completable Future . supply Async ( null , get Exec ( ) ) ; }
public static void filter Hidden Attributes ( Set attribute Schemas ) { remove Attribute Schema Without I 18 n Key ( attribute Schemas ) ; for ( Iterator iter = attribute Schemas . iterator ( ) ; iter . has Next ( ) ; ) { Attribute Schema as = ( Attribute Schema ) iter . next ( ) ; String any = as . get Any ( ) ; if ( ! has Any Attribute ( any , ANY REQUIRED ) && ! has Any Attribute ( any , ANY DISPLAY ) && ! has Any Attribute ( any , ANY ADMIN DISPLAY ) && ! has Any Attribute ( any , ANY DISPLAYRO ) && ! has Any Attribute ( any , ANY ADMIN DISPLAYRO ) ) { iter . remove ( ) ; } else if ( get Tag Class Name ( as ) == null ) { iter . remove ( ) ; } } }
private static Document load Prefs Doc ( Input Stream in ) throws SAX Exception , IO Exception { Document Builder Factory dbf = Document Builder Factory . new Instance ( ) ; dbf . set Ignoring Element Content Whitespace ( BOOL ) ; dbf . set Validating ( BOOL ) ; dbf . set Coalescing ( BOOL ) ; dbf . set Ignoring Comments ( BOOL ) ; try { Document Builder db = dbf . new Document Builder ( ) ; db . set Entity Resolver ( new Resolver ( ) ) ; db . set Error Handler ( new EH ( ) ) ; return db . parse ( new Input Source ( in ) ) ; } catch ( Parser Configuration Exception e ) { throw new Assertion Error ( e ) ; } }
public static List < JSON Object > create JSON Input ( File System fs ) { String input JSON File = System Configuration . get Property ( Distributed Test Driver . JSON PIR INPUT FILE PROPERTY ) ; logger . info ( STRING + input JSON File ) ; List < JSON Object > data Elements JSON = create JSON Data Elements ( ) ; HDFS . write File ( data Elements JSON , fs , input JSON File , BOOL ) ; logger . info ( STRING ) ; return data Elements JSON ; }
private static boolean is Valid Version Number ( final String version ) { if ( version == null ) { return BOOL ; } final String [ ] parts = version . split ( STRING ) ; if ( parts . length != NUM ) { return BOOL ; } for ( final String part : parts ) { if ( ! Convert . is Dec String ( part ) ) { return BOOL ; } } return BOOL ; }
private void on Location Changed Async ( Location location ) { try { if ( ! is Recording ( ) || is Paused ( ) ) { Log . w ( TAG , STRING ) ; return ; } Track track = my Tracks Provider Utils . get Track ( recording Track Id ) ; if ( track == null ) { Log . w ( TAG , STRING ) ; return ; } if ( ! Location Utils . is Valid Location ( location ) ) { Log . w ( TAG , STRING ) ; return ; } if ( ! location . has Accuracy ( ) || location . get Accuracy ( ) >= recording Gps Accuracy ) { Log . d ( TAG , STRING ) ; return ; } if ( location . get Time ( ) == NUM ) { location . set Time ( System . current Time Millis ( ) ) ; } Location last Valid Track Point = get Last Valid Track Point In Current Segment ( track . get Id ( ) ) ; long idle Time = NUM ; if ( last Valid Track Point != null && location . get Time ( ) > last Valid Track Point . get Time ( ) ) { idle Time = location . get Time ( ) - last Valid Track Point . get Time ( ) ; } location Listener Policy . update Idle Time ( idle Time ) ; if ( current Recording Interval != location Listener Policy . get Desired Polling Interval ( ) ) { register Location Listener ( ) ; } Sensor Data Set sensor Data Set = get Sensor Data Set ( ) ; if ( sensor Data Set != null ) { location = new My Tracks Location ( location , sensor Data Set ) ; } if ( ! current Segment Has Location ) { insert Location ( track , location , null ) ; current Segment Has Location = BOOL ; last Location = location ; return ; } if ( ! Location Utils . is Valid Location ( last Valid Track Point ) ) { insert Location ( track , location , null ) ; last Location = location ; return ; } double distance To Last Track Location = location . distance To ( last Valid Track Point ) ; if ( distance To Last Track Location > max Recording Distance ) { insert Location ( track , last Location , last Valid Track Point ) ; Location pause = new Location ( Location Manager . GPS PROVIDER ) ; pause . set Longitude ( NUM ) ; pause . set Latitude ( PAUSE LATITUDE ) ; pause . set Time ( last Location . get Time ( ) ) ; insert Location ( track , pause , null ) ; insert Location ( track , location , null ) ; is Idle = BOOL ; } else if ( sensor Data Set != null || distance To Last Track Location >= recording Distance Interval ) { insert Location ( track , last Location , last Valid Track Point ) ; insert Location ( track , location , null ) ; is Idle = BOOL ; } else if ( ! is Idle && location . has Speed ( ) && location . get Speed ( ) < MAX NO MOVEMENT SPEED ) { insert Location ( track , last Location , last Valid Track Point ) ; insert Location ( track , location , null ) ; is Idle = BOOL ; } else if ( is Idle && location . has Speed ( ) && location . get Speed ( ) >= MAX NO MOVEMENT SPEED ) { insert Location ( track , last Location , last Valid Track Point ) ; insert Location ( track , location , null ) ; is Idle = BOOL ; } else { Log . d ( TAG , STRING ) ; } last Location = location ; } catch ( Error e ) { Log . e ( TAG , STRING , e ) ; throw e ; } catch ( Runtime Exception e ) { Log . e ( TAG , STRING , e ) ; throw e ; } }
public State Monitor Tab ( GUI Frame main Frame ) { set Layout ( new Border Layout ( ) ) ; this . main Frame = main Frame ; states = new Hash Map < String , Dialogue State > ( ) ; J Panel left Panel = create Left Side ( ) ; visualisation = new State Viewer ( this ) ; log Area = create Log Area ( ) ; J Scroll Pane log Scroll = new J Scroll Pane ( log Area ) ; log Scroll . set Border ( Border Factory . create Empty Border ( ) ) ; J Split Pane top Panel = new J Split Pane ( J Split Pane . HORIZONTAL SPLIT , left Panel , visualisation . wrap With Scroll Pane ( ) ) ; top Panel . set Divider Location ( NUM ) ; J Split Pane full Panel = new J Split Pane ( J Split Pane . VERTICAL SPLIT , top Panel , log Scroll ) ; full Panel . set Divider Location ( NUM ) ; add ( full Panel ) ; configure Key Inputs ( ) ; record State ( new Dialogue State ( ) , CURRENT ) ; list Model . add ( NUM , STRING ) ; }
public Painter Chain add Painter ( Painter p ) { if ( chain . length != NUM ) { Painter [ ] new Chain = new Painter [ chain . length + NUM ] ; System . arraycopy ( chain , NUM , new Chain , NUM , chain . length ) ; new Chain [ chain . length ] = p ; return new Painter Chain ( new Chain ) ; } return new Painter Chain ( new Painter [ ] { p } ) ; }
private RMI Server find RMI Server JNDI ( String jndi URL , Map < String , ? > env , boolean is Iiop ) throws Naming Exception { Initial Context ctx = new Initial Context ( Env Help . map To Hashtable ( env ) ) ; Object objref = ctx . lookup ( jndi URL ) ; ctx . close ( ) ; if ( is Iiop ) return narrow IIOP Server ( objref ) ; else return narrow JRMP Server ( objref ) ; }

public Searcher ( ) throws IO Exception { searcher = new Index Searcher ( Directory Reader . open ( FS Directory . open ( Paths . get ( INDEX DIR ) ) ) ) ; parser = new Query Parser ( CONTENT FIELD , new Standard Analyzer ( ) ) ; }
public void test Set Attribute Node NS 1 ( ) throws Throwable { Document doc ; Element element ; Attr attribute 1 ; Attr attribute 2 ; Attr attr Node ; String attr Name ; String attr NS ; Named Node Map attributes ; int length ; doc = ( Document ) load ( STRING , builder ) ; element = doc . create Element NS ( STRING , STRING ) ; attribute 1 = doc . create Attribute NS ( STRING , STRING ) ; attribute 2 = doc . create Attribute NS ( STRING , STRING ) ; attribute 2 . set Value ( STRING ) ; element . set Attribute Node NS ( attribute 1 ) ; element . set Attribute Node NS ( attribute 2 ) ; attr Node = element . get Attribute Node NS ( STRING , STRING ) ; attr Name = attr Node . get Node Name ( ) ; attr NS = attr Node . get Namespace URI ( ) ; assert Equals ( STRING , STRING , attr Name ) ; assert Equals ( STRING , STRING , attr NS ) ; attributes = element . get Attributes ( ) ; length = ( int ) attributes . get Length ( ) ; assert Equals ( STRING , NUM , length ) ; }
public static void copy Bytes To Stream ( Input Stream input Stream , Output Stream output Stream , int length ) throws IO Exception { final int BUFFER SIZE = NUM ; byte [ ] buffer = new byte [ BUFFER SIZE ] ; int total Read = NUM ; do { int read Req Len = ( length == - NUM ) ? BUFFER SIZE : Math . min ( BUFFER SIZE , length - total Read ) ; int read = input Stream . read ( buffer , NUM , read Req Len ) ; if ( read == - NUM ) { if ( length != - NUM ) { throw create Failed To Read Expected ( length , total Read ) ; } else { return ; } } total Read += read ; output Stream . write ( buffer , NUM , read ) ; } while ( total Read != length ) ; }
public void add Branch Condition ( String class Name , String meth Name , int branch Index , Integer Constraint c ) { Constraint < ? > normalized Constraint = normalize Constraint ( c ) ; Linked List < Constraint < ? > > branch supporting constraints = new Linked List < Constraint < ? > > ( current Supporting Constraints ) ; Branch Condition new branch = new Branch Condition ( class Name , meth Name , branch Index , normalized Constraint , branch supporting constraints ) ; branch Conditions . add ( new branch ) ; current Supporting Constraints . clear ( ) ; }
public static String encrypt With Symmetric Key ( String data , String enc Algorithm , String secret ) throws Exception { try { String algorithm = enc Algorithm ; if ( ! algorithm . starts With ( STRING ) ) { algorithm = STRING + enc Algorithm ; } Secret Key Factory sk Factory = Secret Key Factory . get Instance ( algorithm ) ; PBE Key Spec pbe Key Spec = new PBE Key Spec ( secret . to Char Array ( ) ) ; Secret Key s Key = sk Factory . generate Secret ( pbe Key Spec ) ; Cipher cipher = Cipher . get Instance ( algorithm ) ; cipher . init ( Cipher . ENCRYPT MODE , s Key , pbe Parameter Spec ) ; byte [ ] enc Data = cipher . do Final ( data . get Bytes ( STRING ) ) ; enc Data = add Prefix ( enc Data ) ; return Base 64 . encode ( enc Data ) ; } catch ( No Such Algorithm Exception nse ) { throw new Exception ( nse . get Message ( ) ) ; } }
public static String left Pad ( String original , int length , char pad Char ) { if ( original . length ( ) >= length ) { return original ; } return string Of Char ( pad Char , length - original . length ( ) ) + original ; }
protected Array List < Folding Cell View > prepare Views For Animation ( Array List < Integer > view Heights , Bitmap title View Bitmap , Bitmap content View Bitmap ) { if ( view Heights == null || view Heights . is Empty ( ) ) throw new Illegal State Exception ( STRING ) ; Array List < Folding Cell View > parts List = new Array List < > ( ) ; int part Width = title View Bitmap . get Width ( ) ; int y Offset = NUM ; for ( int i = NUM ; i < view Heights . size ( ) ; i ++ ) { int part Height = view Heights . get ( i ) ; Bitmap part Bitmap = Bitmap . create Bitmap ( part Width , part Height , Bitmap . Config . ARGB 8888 ) ; Canvas canvas = new Canvas ( part Bitmap ) ; Rect src Rect = new Rect ( NUM , y Offset , part Width , y Offset + part Height ) ; Rect dest Rect = new Rect ( NUM , NUM , part Width , part Height ) ; canvas . draw Bitmap ( content View Bitmap , src Rect , dest Rect , null ) ; Image View back View = create Image View From Bitmap ( part Bitmap ) ; Image View front View = null ; if ( i < view Heights . size ( ) - NUM ) { front View = ( i == NUM ) ? create Image View From Bitmap ( title View Bitmap ) : create Back Side View ( view Heights . get ( i + NUM ) ) ; } parts List . add ( new Folding Cell View ( front View , back View , get Context ( ) ) ) ; y Offset = y Offset + part Height ; } return parts List ; }
void reset ( ) { System . arraycopy ( iv , NUM , counter , NUM , block Size ) ; used = block Size ; }
public void update View Matrix ( ) { m Device Position = m Model Mat Calculator . get Translation ( ) ; switch ( view Id ) { case FIRST PERSON : float [ ] invert Model Mat = new float [ MATRIX 4X 4 ] ; Matrix . set Identity M ( invert Model Mat , NUM ) ; float [ ] temporary Matrix = new float [ MATRIX 4X 4 ] ; Matrix . set Identity M ( temporary Matrix , NUM ) ; Matrix . set Identity M ( m View Matrix , NUM ) ; Matrix . invert M ( invert Model Mat , NUM , m Model Mat Calculator . get Model Matrix ( ) , NUM ) ; Matrix . multiply MM ( temporary Matrix , NUM , m View Matrix , NUM , invert Model Mat , NUM ) ; System . arraycopy ( temporary Matrix , NUM , m View Matrix , NUM , NUM ) ; break ; case THIRD PERSON : Matrix . set Look At M ( m View Matrix , NUM , m Device Position [ NUM ] + m Camera Position [ NUM ] , m Camera Position [ NUM ] + m Device Position [ NUM ] , m Camera Position [ NUM ] + m Device Position [ NUM ] , m Device Position [ NUM ] , m Device Position [ NUM ] , m Device Position [ NUM ] , NUM , NUM , NUM ) ; break ; case TOP DOWN : Matrix . set Look At M ( m View Matrix , NUM , m Device Position [ NUM ] + m Camera Position [ NUM ] , m Camera Position [ NUM ] , m Camera Position [ NUM ] + m Device Position [ NUM ] , m Device Position [ NUM ] + m Camera Position [ NUM ] , m Camera Position [ NUM ] - NUM , m Camera Position [ NUM ] + m Device Position [ NUM ] , NUM , NUM , - NUM ) ; break ; default : view Id = THIRD PERSON ; return ; } }
public static Proxy Session new Session ( Message Factory message Factory , Connection client Connection , Connection server Connection , Pdu Filter ... filters ) throws IO Exception { Proxy Session session = new Proxy Session ( message Factory , client Connection , server Connection , filters ) ; local Session . set ( session ) ; try { session . start ( ) ; session . await ( ) ; } catch ( Interrupted Exception e ) { session . shutdown ( ) ; } finally { local Session . set ( null ) ; } return session ; }
public C Action Select Same Function Type ( final Zy Graph graph , final Function Type function Type ) { super ( String . format ( STRING , function Type ) ) ; m graph = Preconditions . check Not Null ( graph , STRING ) ; m function Type = Preconditions . check Not Null ( function Type , STRING ) ; }
public void write Bytes ( final byte [ ] bytes , final int off , final int len ) { if ( len > remaining ( ) ) { write Bytes Slow ( bytes , off , len ) ; return ; } final Block block = current ; System . arraycopy ( bytes , off , block . data , block . limit , len ) ; block . limit += len ; }
public Permissions Activity with Permissions ( @ Non Null Permission ... permissions ) { Collections . add All ( this . permissions , permissions ) ; return this ; }
private Map < String , String > add Ivr Zones Strategy ( MDS Dialog dialog , List < Ivr Zone > ivr Zones ) throws Network Device Controller Exception { Map < String , String > added Ivr Zone Names = new Hash Map < String , String > ( ) ; Long time = System . current Time Millis ( ) ; for ( Ivr Zone ivr Zone : ivr Zones ) { if ( add Ivr Zone ( dialog , ivr Zone ) ) { added Ivr Zone Names . put ( ivr Zone . get Name ( ) , SUCCESS ) ; } else { added Ivr Zone Names . put ( ivr Zone . get Name ( ) , NO CHANGE ) ; } } time = System . current Time Millis ( ) - time ; log . info ( STRING + time . to String ( ) ) ; return added Ivr Zone Names ; }
private void println ( Level level , String msg ) { if ( log Level != Level . OFF ) { if ( config Logger == null ) { startup Log Records . add ( new Log Record ( level , msg ) ) ; } else { config Logger . log ( level , msg ) ; } } }
private List < Facet Result > facets With Search ( ) throws IO Exception { Directory Reader index Reader = Directory Reader . open ( index Dir ) ; Index Searcher searcher = new Index Searcher ( index Reader ) ; Taxonomy Reader taxo Reader = new Directory Taxonomy Reader ( taxo Dir ) ; Facets Collector fc = new Facets Collector ( ) ; Facets Collector . search ( searcher , new Match All Docs Query ( ) , NUM , fc ) ; List < Facet Result > results = new Array List < > ( ) ; Facets facets = new Fast Taxonomy Facet Counts ( taxo Reader , config , fc ) ; results . add ( facets . get Top Children ( NUM , STRING ) ) ; results . add ( facets . get Top Children ( NUM , STRING ) ) ; index Reader . close ( ) ; taxo Reader . close ( ) ; return results ; }
private void lazy Load ( ) { if ( major > NUM ) return ; try { if ( url == null ) throw new Illegal State Exception ( ) ; try ( Input Stream is = url . open Stream ( ) ) { major = NUM ; Byte Code Parser parser = new Byte Code Parser ( ) ; parser . set Class Loader ( loader ) ; parser . set Java Class ( this ) ; parser . parse ( is ) ; } } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
private void process Tag ( final String Builder builder ) { boolean started = BOOL ; while ( template Reader . has Next Character ( ) ) { final char tag Character = template Reader . next Character ( ) ; if ( ! started && Strings . is Whitespace ( tag Character ) ) { continue ; } started = BOOL ; if ( tag Character == syntax . get Argument Opening ( ) ) { process Argument ( ) ; } else if ( tag Character == syntax . get Tag Opening ( ) && is Next Character Comment Opening ( ) ) { process Comment ( ) ; } else if ( tag Character == syntax . get Tag Closing ( ) ) { process Tag Entity ( builder ) ; return ; } else { builder . append ( tag Character ) ; } } throw Error ( STRING + builder . to String ( ) ) ; }
protected Element insert Prosody Settings ( Element insert Here , Feature Set feature Set ) { if ( insert Here == null || feature Set == null ) throw new Null Pointer Exception ( STRING ) ; boolean have Prosody Info = BOOL ; for ( String att : XML 2 Utt Base . PROSODY ATTRIBUTES ) { if ( feature Set . get String ( att ) != null ) { have Prosody Info = BOOL ; break ; } } if ( ! have Prosody Info ) { return null ; } Document doc = insert Here . get Owner Document ( ) ; Element prosody = Mary XML . create Element ( doc , Mary XML . PROSODY ) ; insert Here . append Child ( prosody ) ; for ( String att : XML 2 Utt Base . PROSODY ATTRIBUTES ) { String val = feature Set . get String ( att ) ; if ( val != null ) { prosody . set Attribute ( att , val ) ; } } return prosody ; }
public synchronized boolean safe Count ( int partition , long offset ) throws IO Exception { Atomic Long counter = null ; if ( partition >= this . counters . length ) { this . counters = Arrays . copy Of ( this . counters , this . counters . length + GROWBY ) ; } counter = counters [ partition ] ; if ( null == counter ) { counter = new Atomic Long ( NUM ) ; counters [ partition ] = counter ; counter . set ( offset ) ; if ( null != committed Offsets && committed Offsets . length > partition && committed Offsets [ partition ] >= NUM && NUM < ( offset - committed Offsets [ partition ] ) ) { labels . clear ( ) ; labels . put ( Sensision Constants . SENSISION LABEL TOPIC , this . topic ) ; labels . put ( Sensision Constants . SENSISION LABEL GROUPID , this . groupid ) ; labels . put ( Sensision Constants . SENSISION LABEL PARTITION , Integer . to String ( partition ) ) ; Sensision . update ( Sensision Constants . SENSISION CLASS WARP KAFKA CONSUMER OFFSET FORWARD LEAPS , labels , NUM ) ; throw new IO Exception ( STRING + offset + STRING + committed Offsets [ partition ] ) ; } } else { long previous Offset = counter . get And Set ( offset ) ; if ( NUM < ( offset - previous Offset ) ) { labels . clear ( ) ; labels . put ( Sensision Constants . SENSISION LABEL TOPIC , this . topic ) ; labels . put ( Sensision Constants . SENSISION LABEL GROUPID , this . groupid ) ; labels . put ( Sensision Constants . SENSISION LABEL PARTITION , Integer . to String ( partition ) ) ; Sensision . update ( Sensision Constants . SENSISION CLASS WARP KAFKA CONSUMER OFFSET FORWARD LEAPS , labels , NUM ) ; throw new IO Exception ( STRING + offset + STRING + previous Offset ) ; } } if ( null != committed Offsets && committed Offsets . length > partition && offset <= committed Offsets [ partition ] ) { labels . clear ( ) ; labels . put ( Sensision Constants . SENSISION LABEL TOPIC , this . topic ) ; labels . put ( Sensision Constants . SENSISION LABEL GROUPID , this . groupid ) ; labels . put ( Sensision Constants . SENSISION LABEL PARTITION , Integer . to String ( partition ) ) ; Sensision . update ( Sensision Constants . SENSISION CLASS WARP KAFKA CONSUMER OFFSET BACKWARD LEAPS , labels , NUM ) ; return BOOL ; } return BOOL ; }
public Vector rotate ZY ( final double angle ) { return rotate ZY ( Math . sin ( angle ) , Math . cos ( angle ) ) ; }
public void disconnect ( ) { connected = BOOL ; synchronized ( conn Lost Wait ) { conn Lost Wait . notify ( ) ; } if ( mqtt != null ) { try { mqtt . disconnect ( ) ; } catch ( Exception ex ) { set Title Text ( STRING ) ; ex . print Stack Trace ( ) ; System . exit ( NUM ) ; } } if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } led . set Red ( ) ; set Connected ( BOOL ) ; synchronized ( this ) { write Logln ( STRING ) ; } }
public boolean contains Header Out ( String name ) { Array List < String > header Keys = header Keys Out ; int size = header Keys . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { String old Key = header Keys . get ( i ) ; if ( old Key . equals Ignore Case ( name ) ) { return BOOL ; } } if ( name . equals Ignore Case ( STRING ) ) { return content Type Out != null ; } if ( name . equals Ignore Case ( STRING ) ) { return content Length Out >= NUM ; } return BOOL ; }
protected Map < String , Set < String > > filter Query Params By Key ( Query Params Parser Context context , String query Key ) { Map < String , Set < String > > filtered Query Params = new Hash Map < > ( ) ; for ( String param Name : context . get Parameter Names ( ) ) { if ( param Name . starts With ( query Key ) ) { filtered Query Params . put ( param Name , context . get Parameter Value ( param Name ) ) ; } } return filtered Query Params ; }
public org . w3 c . dom . Element sign With SAML Token ( org . w3 c . dom . Document doc , java . security . cert . Certificate cert , String assertion ID , java . lang . String algorithm , java . util . List ids ) throws XML Signature Exception { return null ; }
private URL create Search URL ( URL url ) throws Malformed URL Exception { if ( url == null ) { return url ; } String protocol = url . get Protocol ( ) ; if ( is Directory ( url ) || protocol . equals ( STRING ) ) { return url ; } if ( factory == null ) { return new URL ( STRING , STRING , - NUM , url . to String ( ) + STRING ) ; } return new URL ( STRING , STRING , - NUM , url . to String ( ) + STRING , factory . create URL Stream Handler ( STRING ) ) ; }
void add ( int start , int end ) { final Map . Entry < Integer , Integer > floor = m Intervals . floor Entry ( start ) ; final Map . Entry < Integer , Integer > end Floor = m Intervals . lower Entry ( end ) ; final int actual Start ; final int actual End ; if ( floor != null && start >= floor . get Key ( ) && end <= floor . get Value ( ) ) { return ; } if ( floor == null || start > floor . get Value ( ) ) { actual Start = start ; } else { actual Start = Math . min ( floor . get Key ( ) , start ) ; } if ( end Floor == null ) { actual End = end ; } else { actual End = Math . max ( end Floor . get Value ( ) , end ) ; } remove Contained By ( actual Start , actual End ) ; m Intervals . put ( actual Start , actual End ) ; }
public void put Kth Nearest ( double d ) { if ( m Kth Nearest == null ) { m Kth Nearest = new My Heap Element [ init Size ] ; } if ( m Kth Nearest Size >= m Kth Nearest . length ) { init Size += init Size ; My Heap Element temp [ ] = new My Heap Element [ init Size ] ; System . arraycopy ( m Kth Nearest , NUM , temp , NUM , m Kth Nearest . length ) ; m Kth Nearest = temp ; } m Kth Nearest [ m Kth Nearest Size ++ ] = new My Heap Element ( d ) ; }
private static void load Page Pool ( Config Server config Server , Config config , Document doc ) { }
public void draw Shape ( int x , int y , int w , int h , Map < String , Object > style ) { Color pen Color = mx Utils . get Color ( style , mx Constants . STYLE STROKECOLOR ) ; float pen Width = mx Utils . get Float ( style , mx Constants . STYLE STROKEWIDTH , NUM ) ; int pw = ( int ) Math . ceil ( pen Width * scale ) ; if ( g . hit Clip ( x - pw , y - pw , w + NUM * pw , h + NUM * pw ) ) { boolean shadow = mx Utils . is True ( style , mx Constants . STYLE SHADOW , BOOL ) ; Color fill Color = mx Utils . get Style Fill Color ( style ) ; Paint fill Paint = get Fill Paint ( new Rectangle ( x , y , w , h ) , fill Color , style ) ; if ( pen Width > NUM ) { set Stroke ( pen Width , style ) ; } String shape = mx Utils . get String ( style , mx Constants . STYLE SHAPE , STRING ) ; if ( shape . equals ( mx Constants . SHAPE IMAGE ) ) { String img = get Image For Style ( style ) ; if ( img != null ) { draw Image ( x , y , w , h , img ) ; } } else if ( shape . equals ( mx Constants . SHAPE LINE ) ) { if ( pen Color != null ) { g . set Color ( pen Color ) ; String direction = mx Utils . get String ( style , mx Constants . STYLE DIRECTION , mx Constants . DIRECTION EAST ) ; if ( direction . equals ( mx Constants . DIRECTION EAST ) || direction . equals ( mx Constants . DIRECTION WEST ) ) { int mid = ( int ) ( y + h / NUM ) ; draw Line ( x , mid , x + w , mid ) ; } else { int mid = ( int ) ( x + w / NUM ) ; draw Line ( mid , y , mid , y + h ) ; } } } else if ( shape . equals ( mx Constants . SHAPE ELLIPSE ) ) { draw Oval ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants . SHAPE DOUBLE ELLIPSE ) ) { draw Oval ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; int inset = ( int ) ( ( NUM + pen Width ) * scale ) ; x += inset ; y += inset ; w -= NUM * inset ; h -= NUM * inset ; draw Oval ( x , y , w , h , null , null , pen Color , BOOL ) ; } else if ( shape . equals ( mx Constants . SHAPE RHOMBUS ) ) { draw Rhombus ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants . SHAPE CYLINDER ) ) { draw Cylinder ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants . SHAPE ACTOR ) ) { draw Actor ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants . SHAPE CLOUD ) ) { draw Cloud ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants . SHAPE TRIANGLE ) ) { String direction = mx Utils . get String ( style , mx Constants . STYLE DIRECTION , STRING ) ; draw Triangle ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , direction ) ; } else if ( shape . equals ( mx Constants . SHAPE HEXAGON ) ) { String direction = mx Utils . get String ( style , mx Constants . STYLE DIRECTION , STRING ) ; draw Hexagon ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , direction ) ; } else { draw Rect ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , mx Utils . is True ( style , mx Constants . STYLE ROUNDED ) ) ; if ( shape . equals ( mx Constants . SHAPE LABEL ) ) { String img = get Image For Style ( style ) ; if ( img != null ) { String img Align = mx Utils . get String ( style , mx Constants . STYLE IMAGE ALIGN , mx Constants . ALIGN CENTER ) ; String img Valign = mx Utils . get String ( style , mx Constants . STYLE IMAGE VERTICAL ALIGN , mx Constants . ALIGN MIDDLE ) ; int img Width = ( int ) ( mx Utils . get Int ( style , mx Constants . STYLE IMAGE WIDTH , mx Constants . DEFAULT IMAGESIZE ) * scale ) ; int img Height = ( int ) ( mx Utils . get Int ( style , mx Constants . STYLE IMAGE HEIGHT , mx Constants . DEFAULT IMAGESIZE ) * scale ) ; int spacing = ( int ) ( mx Utils . get Int ( style , mx Constants . STYLE SPACING , NUM ) * scale ) ; int img X = x ; if ( img Align . equals ( mx Constants . ALIGN LEFT ) ) { img X += spacing ; } else if ( img Align . equals ( mx Constants . ALIGN RIGHT ) ) { img X += w - img Width - spacing ; } else { img X += ( w - img Width ) / NUM ; } int img Y = y ; if ( img Valign . equals ( mx Constants . ALIGN TOP ) ) { img Y += spacing ; } else if ( img Valign . equals ( mx Constants . ALIGN BOTTOM ) ) { img Y += h - img Height - spacing ; } else { img Y += ( h - img Height ) / NUM ; } draw Image ( img X , img Y , img Width , img Height , img ) ; } } } } }
private boolean is Transient ( Field field ) { int modifier = field . get Modifiers ( ) ; if ( Modifier . is Transient ( modifier ) ) { return BOOL ; } return BOOL ; }
public void define Line Style ( int width , Color color ) throws IO Exception { line Styles . add ( new Line Style ( width , color ) ) ; outstanding Changes = BOOL ; }
public static void print ( final Print Stream out , final String name , final Percentile p ) { if ( p . is Ready ( ) ) { try { final String Builder sb = new String Builder ( NUM ) ; final float [ ] q = p . get Quantiles ( ) ; final float [ ] e = p . get Estimates ( ) ; final int SCREENWIDTH = NUM ; sb . append ( name ) ; sb . append ( STRING ) ; sb . append ( p . get Min ( ) ) ; sb . append ( STRING ) ; sb . append ( p . get Max ( ) ) ; sb . append ( STRING ) ; sb . append ( STRING ) ; final float max = e [ e . length - NUM ] ; for ( int i = NUM ; i < q . length ; i ++ ) { sb . append ( String . format ( STRING , q [ i ] ) ) ; sb . append ( STRING ) ; final int len = ( int ) ( e [ i ] / max * SCREENWIDTH ) ; for ( int j = NUM ; j < len ; j ++ ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( String . format ( STRING , e [ i ] ) ) ; } out . println ( sb . to String ( ) ) ; } catch ( Insufficient Samples Exception e ) { } } }
public void init ( String component Name ) throws Log Exception { access Logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( component Name + STRING ) ; error Logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( component Name + STRING ) ; try { msg Provider = Message Provider Factory . get Provider ( component Name ) ; } catch ( IO Exception e ) { debug . error ( STRING , e ) ; } }
private View fill Right ( int pos , int next Left ) { View selected View = null ; int end = ( get Right ( ) - get Left ( ) ) ; while ( next Left < end && pos < m Item Count ) { boolean selected = pos == m Selected Position ; View child = make And Add View ( pos , next Left , BOOL , m List Padding . top , selected ) ; next Left = child . get Right ( ) + m Divider Width ; if ( selected ) { selected View = child ; } pos ++ ; } set Visible Range Hint ( m First Position , m First Position + get Child Count ( ) - NUM ) ; return selected View ; }
public void add Default Value ( String value ) throws SMS Exception , SSO Exception { Set default Values = get Default Values ( ) ; if ( default Values != Collections . EMPTY SET ) { default Values . add ( value ) ; } else { default Values = new Hash Set ( ) ; default Values . add ( value ) ; } update Default Values ( default Values ) ; }
public static int key Binding Description To Key Modifier ( String key Binding Description ) { if ( String Utils . is Blank ( key Binding Description ) ) { return NUM ; } else if ( key Binding Description . starts With ( STRING ) ) { return SWT . ALT ; } else if ( key Binding Description . starts With ( STRING ) ) { return SWT . CTRL ; } else if ( key Binding Description . starts With ( STRING ) ) { return SWT . COMMAND ; } else { return NUM ; } }
public void test Partitioned Mixed ( ) throws Exception { mode = PARTITIONED ; near Enabled = BOOL ; filter = new Eviction Filter ( ) ; Ignite g = start Grid ( ) ; Ignite Cache < Object , Object > cache = g . cache ( null ) ; try { int id = NUM ; cache . put ( id ++ , NUM ) ; cache . put ( id ++ , NUM ) ; for ( int i = id + NUM ; i < NUM ; i ++ ) { cache . put ( id , id ) ; cache . put ( i , String . value Of ( i ) ) ; } info ( STRING + cache . get ( NUM ) ) ; info ( STRING + cache . get ( NUM ) ) ; info ( STRING + cache . get ( NUM ) ) ; } finally { stop Grid ( ) ; } }
public static Modifiable DBI Ds intersection ( DBI Ds first , DBI Ds second ) { if ( first . size ( ) > second . size ( ) ) { return intersection ( second , first ) ; } Modifiable DBI Ds inter = new Hash Set ( first . size ( ) ) ; for ( DBID Iter it = first . iter ( ) ; it . valid ( ) ; it . advance ( ) ) { if ( second . contains ( it ) ) { inter . add ( it ) ; } } return inter ; }
public Ignite Deployment Checked Exception ( Throwable cause ) { this ( cause . get Message ( ) , cause ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return BOOL ; if ( ! ( obj instanceof Channel Binding ) ) return BOOL ; Channel Binding cb = ( Channel Binding ) obj ; if ( ( initiator != null && cb . initiator == null ) || ( initiator == null && cb . initiator != null ) ) return BOOL ; if ( initiator != null && ! initiator . equals ( cb . initiator ) ) return BOOL ; if ( ( acceptor != null && cb . acceptor == null ) || ( acceptor == null && cb . acceptor != null ) ) return BOOL ; if ( acceptor != null && ! acceptor . equals ( cb . acceptor ) ) return BOOL ; return Arrays . equals ( app Data , cb . app Data ) ; }
private Option resolve Option ( String opt ) { opt = Util . strip Leading Hyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . has Next ( ) ; ) { Option option = ( Option ) it . next ( ) ; if ( opt . equals ( option . get Opt ( ) ) ) { return option ; } if ( opt . equals ( option . get Long Opt ( ) ) ) { return option ; } } return null ; }
protected void check Pause And Wait ( ) { pause Lock . lock ( ) ; try { while ( paused && ! stopped ) { paused Condition . await ( ) ; } } catch ( Interrupted Exception e ) { } finally { pause Lock . unlock ( ) ; } }
public void property Change ( Property Change Event pce ) { if ( pce . get Property Name ( ) == Map Bean . Background Property ) { map Bean . set Bckgrnd ( ( Paint ) pce . get New Value ( ) ) ; } }
public Section Builder add Frame ( int image Resource ) { m Frames . add ( image Resource ) ; return this ; }
public List < Class < ? > > find Available Classes ( String uri ) throws IO Exception { resources Not Loaded . clear ( ) ; List < Class < ? > > classes = new Array List < > ( ) ; List < String > strings = find Available Strings ( uri ) ; for ( String class Name : strings ) { try { Class < ? > clazz = class Loader . load Class ( class Name ) ; classes . add ( clazz ) ; } catch ( Exception not Available ) { resources Not Loaded . add ( class Name ) ; } } return classes ; }
private boolean diffuse Skylight In Block Column ( Cube cube , Mutable Block Pos pos , int min Block Y , int max Block Y , Int 2 Object Map < Fast Cube Block Access > block Access Map ) { I Cubic World world = cube . get Cubic World ( ) ; int cube Min Block Y = cube To Min Block ( cube . get Y ( ) ) ; int cube Max Block Y = cube To Max Block ( cube . get Y ( ) ) ; int max Block Y In Cube = Math . min ( cube Max Block Y , max Block Y ) ; int min Block Y In Cube = Math . max ( cube Min Block Y , min Block Y ) ; Fast Cube Block Access block Access = block Access Map . get ( cube . get Y ( ) ) ; if ( block Access == null ) { block Access = new Fast Cube Block Access ( this . cache , cube , UPDATE BUFFER RADIUS ) ; block Access Map . put ( cube . get Y ( ) , block Access ) ; } for ( int block Y = max Block Y In Cube ; block Y >= min Block Y In Cube ; -- block Y ) { pos . set Y ( block Y ) ; if ( ! needs Skylight Update ( block Access , pos ) ) { continue ; } if ( ! world . check Light For ( Enum Sky Block . SKY , pos ) ) { return BOOL ; } } return BOOL ; }
public String to String ( ) { String Buffer buffer = new String Buffer ( ) ; buffer . append ( to String ( get Class ( ) ) ) ; buffer . append ( STRING ) ; buffer . append ( is Use Default ( ) ) ; buffer . append ( STRING ) ; buffer . append ( use Locale Format ) ; if ( display Patterns != null ) { buffer . append ( STRING ) ; buffer . append ( display Patterns ) ; buffer . append ( STRING ) ; } if ( locale != null ) { buffer . append ( STRING ) ; buffer . append ( locale ) ; } if ( time Zone != null ) { buffer . append ( STRING ) ; buffer . append ( time Zone ) ; } buffer . append ( STRING ) ; return buffer . to String ( ) ; }
private Array DBI Ds compute M current ( DBI Ds m , DBI Ds m best , DBI Ds m bad , Random random ) { Array Modifiable DBI Ds m list = DBID Util . new Array ( m ) ; m list . remove DBI Ds ( m best ) ; DBID Array M Iter it = m list . iter ( ) ; Array Modifiable DBI Ds m current = DBID Util . new Array ( ) ; for ( DBID Iter iter = m best . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { if ( m bad . contains ( iter ) ) { int current Size = m current . size ( ) ; while ( m current . size ( ) == current Size ) { m current . add ( it . seek ( random . next Int ( m list . size ( ) ) ) ) ; it . remove ( ) ; } } else { m current . add ( iter ) ; } } return m current ; }
public double do Operation ( ) throws Operator Failed Exception { double logq ; final double alpha = ( arctan Transform ? Math . atan ( bias ) * SCALE ALPHA : Math . log ( bias ) ) ; final Node Ref root = tree . get Root ( ) ; double max Height = tree . get Node Height ( root ) ; Node Ref i ; Node Ref iP = null ; Node Ref Ci P = null ; Node Ref Pi P = null ; double height = Double . Na N ; List < Node Ref > destinations = null ; do { i = tree . get Node ( Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } while ( root == i || tree . get Parent ( i ) == root ) ; iP = tree . get Parent ( i ) ; Ci P = get Other Child ( tree , iP , i ) ; Pi P = tree . get Parent ( iP ) ; height = tree . get Node Height ( iP ) ; destinations = get Intersecting Edges ( tree , height ) ; if ( destinations . size ( ) == NUM ) { throw new Operator Failed Exception ( STRING ) ; } double [ ] pdf = get Destination Probabilities ( tree , i , height , max Height , destinations , alpha ) ; destinations . remove ( i ) ; destinations . remove ( Ci P ) ; int r = Math Utils . random Choice PDF ( pdf ) ; double forward Probability = pdf [ r ] ; final Node Ref j = destinations . get ( r ) ; final Node Ref jP = tree . get Parent ( j ) ; tree . begin Tree Edit ( ) ; tree . remove Child ( iP , Ci P ) ; tree . remove Child ( Pi P , iP ) ; tree . add Child ( Pi P , Ci P ) ; tree . remove Child ( jP , j ) ; tree . add Child ( iP , j ) ; tree . add Child ( jP , iP ) ; tree . end Tree Edit ( ) ; final List < Node Ref > reverse Destinations = get Intersecting Edges ( tree , height ) ; double reverse Probability = get Reverse Probability ( tree , Ci P , j , height , max Height , reverse Destinations , alpha ) ; logq = Math . log ( reverse Probability ) - Math . log ( forward Probability ) ; return logq ; }
protected boolean is Initialized ( ) { try { read Lock . lock ( ) ; return this . initialized ; } finally { read Lock . unlock ( ) ; } }
public String to String ( ) { return Double . to String ( get Value ( ) ) ; }
private static List < Size Pair > generate Valid Preview Size List ( Camera camera ) { Camera . Parameters parameters = camera . get Parameters ( ) ; List < android . hardware . Camera . Size > supported Preview Sizes = parameters . get Supported Preview Sizes ( ) ; List < android . hardware . Camera . Size > supported Picture Sizes = parameters . get Supported Picture Sizes ( ) ; List < Size Pair > valid Preview Sizes = new Array List < > ( ) ; for ( android . hardware . Camera . Size preview Size : supported Preview Sizes ) { float preview Aspect Ratio = ( float ) preview Size . width / ( float ) preview Size . height ; for ( android . hardware . Camera . Size picture Size : supported Picture Sizes ) { float picture Aspect Ratio = ( float ) picture Size . width / ( float ) picture Size . height ; if ( Math . abs ( preview Aspect Ratio - picture Aspect Ratio ) < ASPECT RATIO TOLERANCE ) { valid Preview Sizes . add ( new Size Pair ( preview Size , picture Size ) ) ; break ; } } } if ( valid Preview Sizes . size ( ) == NUM ) { Log . w ( TAG , STRING ) ; for ( android . hardware . Camera . Size preview Size : supported Preview Sizes ) { valid Preview Sizes . add ( new Size Pair ( preview Size , null ) ) ; } } return valid Preview Sizes ; }
public static String join ( List < ? > things , String delim ) { String Builder builder = new String Builder ( ) ; boolean first = BOOL ; for ( Object thing : things ) { if ( first ) { first = BOOL ; } else { builder . append ( delim ) ; } builder . append ( thing . to String ( ) ) ; } return builder . to String ( ) ; }
public static final byte [ ] inflate ( byte [ ] in ) throws IO Exception { Byte Array Output Stream out Stream = new Byte Array Output Stream ( EXPECTED COMPRESSION RATIO * in . length ) ; Inflater Input Stream in Stream = new Inflater Input Stream ( new Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [ BUF SIZE ] ; while ( BOOL ) { int size = in Stream . read ( buf ) ; if ( size <= NUM ) break ; out Stream . write ( buf , NUM , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
private void create Lookup Table Data ( Transform Context context ) { for ( String key : mapping Values . key Set ( ) ) { Value Mapping mapping = mapping Values . get ( key ) ; String lookup Table Name = mapping . get Lookup Table Name ( ) ; if ( ! lookup Table Cache . contains Key ( lookup Table Name ) ) { Lookup Table Config table Config = new Lookup Table Config ( Lookup Table Config . Table Type . DATASET ) ; Lookup < String > lookup Table = context . provide ( lookup Table Name , table Config . get Dataset Properties ( ) ) ; lookup Table Cache . put ( lookup Table Name , lookup Table ) ; } } }
public final void sample ( ) { synchronized ( lock ) { long count = total Count . get ( ) ; long last Count = last Avg Total Count ; last Avg Total Count = count ; long sum = sum . get ( ) ; double last Sum = last Avg Sum ; last Avg Sum = sum ; if ( count == last Count ) { avg = NUM ; } else { avg = scale * ( sum - last Sum ) / ( double ) ( count - last Count ) ; } } }
public static String [ ] split ( final Char Sequence char Sequence , final char separator ) { if ( is Empty ( char Sequence ) ) { return EMPTY ARRAY ; } final int original Separators Count = count Separated Char Appearances ( char Sequence , separator ) ; int separators Count = original Separators Count ; if ( starts With ( char Sequence , separator ) ) { separators Count -- ; } if ( char Sequence . length ( ) > NUM && ends With ( char Sequence , separator ) ) { separators Count -- ; } if ( separators Count <= NUM ) { if ( original Separators Count == NUM ) { return new String [ ] { char Sequence . to String ( ) } ; } else if ( is Same Char ( char Sequence ) ) { return EMPTY ARRAY ; } return new String [ ] { remove Character ( char Sequence . to String ( ) , separator ) } ; } final String [ ] result = new String [ separators Count + NUM ] ; int current Result Index = NUM ; final String Builder builder = new String Builder ( ) ; for ( int index = NUM , length = char Sequence . length ( ) ; index < length ; index ++ ) { final char character = char Sequence . char At ( index ) ; if ( character == separator ) { if ( is Not Empty ( builder ) ) { result [ current Result Index ++ ] = builder . to String ( ) ; clear Builder ( builder ) ; } } else { builder . append ( character ) ; } } if ( is Not Empty ( builder ) ) { result [ current Result Index ++ ] = builder . to String ( ) ; } return result ; }
public void execute ( String desc , Consumer < Mongo Client > operation ) { while ( BOOL ) { Mongo Client primary = primary Connection Supplier . get ( ) ; try { operation . accept ( primary ) ; return ; } catch ( Throwable t ) { error Handler . accept ( desc , t ) ; } } }
public void write ( char [ ] cbuf , int off , int len ) throws java . io . IO Exception { write ( new String ( cbuf , off , len ) ) ; }
private Control create Details Viewer ( final Composite parent ) { if ( details == null ) { return null ; } final Text text = new Text ( parent , SWT . MULTI | SWT . READ ONLY | SWT . BORDER | SWT . H SCROLL | SWT . V SCROLL ) ; text . set Layout Data ( new Grid Data ( Grid Data . FILL BOTH ) ) ; final String Writer writer = new String Writer ( NUM ) ; if ( details instanceof Throwable ) { append Exception ( new Print Writer ( writer ) , ( Throwable ) details ) ; } else if ( details instanceof I Status ) { append Command Status ( new Print Writer ( writer ) , ( I Status ) details , NUM ) ; } text . set Text ( writer . to String ( ) ) ; return text ; }
protected String XML Normalize ( String s Str ) { String Buffer s Str 2 = new String Buffer ( ) ; for ( int i Str = NUM ; i Str < s Str . length ( ) ; i Str ++ ) { char c = s Str . char At ( i Str ) ; switch ( c ) { case STRING : s Str 2 . append ( STRING ) ; break ; case STRING : s Str 2 . append ( STRING ) ; break ; case STRING : s Str 2 . append ( STRING ) ; break ; case STRING : s Str 2 . append ( STRING ) ; break ; case STRING : s Str 2 . append ( STRING ) ; break ; default : s Str 2 . append ( c ) ; } } return s Str 2 . to String ( ) ; }
protected boolean [ ] can Handle Missing ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing , int missing Level ) { if ( missing Level == NUM ) { print ( STRING ) ; } print ( STRING ) ; if ( predictor Missing ) { print ( STRING ) ; if ( class Missing ) { print ( STRING ) ; } } if ( class Missing ) { print ( STRING ) ; } print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; accepts . add ( STRING ) ; int num Train = get Num Instances ( ) , num Classes = NUM ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Classes , accepts ) ; }
private void disable Buttons ( ) { set Arty Enabled ( NUM ) ; but Done . set Enabled ( BOOL ) ; }
public Artifact load ( Artifact Name artifact Name , File path ) throws IO Exception { Preconditions . check Argument ( path . exists ( ) , STRING + path ) ; Preconditions . check Argument ( path . is File ( ) || path . is Directory ( ) , STRING + path ) ; if ( path . is File ( ) ) { return load From Jar ( artifact Name , path ) ; } return load From Directory ( artifact Name , path ) ; }
public static String mask Right ( String s , int len , char mask ch ) { if ( len <= NUM ) { return s ; } len = Math . min ( len , s . length ( ) ) ; String Builder sb = new String Builder ( ) ; sb . append ( s . substring ( NUM , s . length ( ) - len ) ) ; for ( int i = NUM ; i < len ; i ++ ) { sb . append ( mask ch ) ; } return sb . to String ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
public Monitor Train ( Transit Section Action tsa ) { tsa = tsa ; }
public D Authority Key Identifier ( J Dialog parent , byte [ ] value , Public Key authority Public Key ) throws IO Exception { super ( parent ) ; set Title ( res . get String ( STRING ) ) ; this . authority Public Key = authority Public Key ; init Components ( ) ; prepopulate With Value ( value ) ; }
public void add ( Dimensional Node dn ) { if ( in Progress ) { throw new Concurrent Modification Exception ( STRING ) ; } nodes . add ( dn ) ; }
private Verification Result verify Signature ( Auth Success auth Resp , Discovery Information discovered , Verification Result result ) throws Association Exception , Message Exception , Discovery Exception { if ( discovered == null || auth Resp == null ) { log . error ( STRING + STRING ) ; result . set Status Msg ( STRING + STRING ) ; return result ; } Identifier claimed Id = discovered . is Version 2 ( ) ? discovery . parse Identifier ( auth Resp . get Claimed ( ) ) : discovered . get Claimed Identifier ( ) ; String handle = auth Resp . get Handle ( ) ; URL op = discovered . get OP Endpoint ( ) ; Association assoc = associations . load ( op . to String ( ) , handle ) ; if ( assoc != null ) { log . info ( STRING + assoc . get Handle ( ) + STRING ) ; String text = auth Resp . get Signed Text ( ) ; String signature = auth Resp . get Signature ( ) ; if ( assoc . verify Signature ( text , signature ) ) { result . set Verified Id ( claimed Id ) ; if ( DEBUG ) log . debug ( STRING ) ; } else { result . set Status Msg ( STRING ) ; if ( DEBUG ) log . debug ( STRING ) ; } } else { log . info ( STRING + STRING ) ; Verify Request vrfy = Verify Request . create Verify Request ( auth Resp ) ; Parameter List response Params = new Parameter List ( ) ; int resp Code = call ( op . to String ( ) , vrfy , response Params ) ; if ( Http Status . SC OK == resp Code ) { Verify Response vrfy Resp = Verify Response . create Verify Response ( response Params ) ; vrfy Resp . validate ( ) ; if ( vrfy Resp . is Signature Verified ( ) ) { String invalidate Handle = vrfy Resp . get Invalidate Handle ( ) ; if ( invalidate Handle != null ) associations . remove ( op . to String ( ) , invalidate Handle ) ; result . set Verified Id ( claimed Id ) ; if ( DEBUG ) log . debug ( STRING + STRING + op ) ; } else { if ( DEBUG ) log . debug ( STRING + STRING + op ) ; result . set Status Msg ( STRING ) ; } } else { Direct Error err = Direct Error . create Direct Error ( response Params ) ; if ( DEBUG ) log . debug ( STRING + op + STRING + err . key Value Form Encoding ( ) ) ; result . set Status Msg ( STRING + err . get Error Msg ( ) ) ; } } Identifier verified ID = result . get Verified Id ( ) ; if ( verified ID != null ) log . info ( STRING + verified ID ) ; else log . error ( STRING + auth Resp . get Claimed ( ) + STRING + result . get Status Msg ( ) ) ; return result ; }
private void handle Json Report Response ( final Client Request Report report , final Client Request Report Listener report Listener ) { if ( report Listener == null ) { LOGGER . debug ( STRING ) ; return ; } if ( report . is Error Report ( ) ) { LOGGER . debug ( STRING ) ; report Listener . on Error Report Received ( ( Client Request Error Report ) report ) ; throw new Runtime Exception ( STRING + report . get Error Message ( ) ) ; } else if ( report . is Progress Report ( ) ) { LOGGER . debug ( STRING ) ; report Listener . on Progress Report Received ( ( Client Request Progress Report ) report ) ; } else LOGGER . warn ( STRING ) ; }
protected void build Profiles ( ) { m Current Profile View . set Visibility ( View . INVISIBLE ) ; m Account Header Text Section . set Visibility ( View . INVISIBLE ) ; m Account Switcher Arrow . set Visibility ( View . INVISIBLE ) ; m Profile First View . set Visibility ( View . GONE ) ; m Profile First View . set On Click Listener ( null ) ; m Profile Second View . set Visibility ( View . GONE ) ; m Profile Second View . set On Click Listener ( null ) ; m Profile Third View . set Visibility ( View . GONE ) ; m Profile Third View . set On Click Listener ( null ) ; m Current Profile Name . set Text ( STRING ) ; m Current Profile Email . set Text ( STRING ) ; handle Selection View ( m Current Profile , BOOL ) ; if ( m Current Profile != null ) { if ( m Profile Images Visible || m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Current Profile View , m Current Profile . get Icon ( ) ) ; if ( m Profile Images Clickable ) { m Current Profile View . set On Click Listener ( on Profile Click Listener ) ; m Current Profile View . disable Touch Feedback ( BOOL ) ; } else { m Current Profile View . disable Touch Feedback ( BOOL ) ; } m Current Profile View . set Visibility ( View . VISIBLE ) ; m Current Profile View . invalidate ( ) ; } else if ( m Compact Style ) { m Current Profile View . set Visibility ( View . GONE ) ; } m Account Header Text Section . set Visibility ( View . VISIBLE ) ; handle Selection View ( m Current Profile , BOOL ) ; m Account Switcher Arrow . set Visibility ( View . VISIBLE ) ; m Current Profile View . set Tag ( R . id . material drawer profile header , m Current Profile ) ; String Holder . apply To ( m Current Profile . get Name ( ) , m Current Profile Name ) ; String Holder . apply To ( m Current Profile . get Email ( ) , m Current Profile Email ) ; if ( m Profile First != null && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile First View , m Profile First . get Icon ( ) ) ; m Profile First View . set Tag ( R . id . material drawer profile header , m Profile First ) ; if ( m Profile Images Clickable ) { m Profile First View . set On Click Listener ( on Profile Click Listener ) ; m Profile First View . disable Touch Feedback ( BOOL ) ; } else { m Profile First View . disable Touch Feedback ( BOOL ) ; } m Profile First View . set Visibility ( View . VISIBLE ) ; m Profile First View . invalidate ( ) ; } if ( m Profile Second != null && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile Second View , m Profile Second . get Icon ( ) ) ; m Profile Second View . set Tag ( R . id . material drawer profile header , m Profile Second ) ; if ( m Profile Images Clickable ) { m Profile Second View . set On Click Listener ( on Profile Click Listener ) ; m Profile Second View . disable Touch Feedback ( BOOL ) ; } else { m Profile Second View . disable Touch Feedback ( BOOL ) ; } m Profile Second View . set Visibility ( View . VISIBLE ) ; m Profile Second View . invalidate ( ) ; } if ( m Profile Third != null && m Three Small Profile Images && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile Third View , m Profile Third . get Icon ( ) ) ; m Profile Third View . set Tag ( R . id . material drawer profile header , m Profile Third ) ; if ( m Profile Images Clickable ) { m Profile Third View . set On Click Listener ( on Profile Click Listener ) ; m Profile Third View . disable Touch Feedback ( BOOL ) ; } else { m Profile Third View . disable Touch Feedback ( BOOL ) ; } m Profile Third View . set Visibility ( View . VISIBLE ) ; m Profile Third View . invalidate ( ) ; } } else if ( m Profiles != null && m Profiles . size ( ) > NUM ) { I Profile profile = m Profiles . get ( NUM ) ; m Account Header Text Section . set Tag ( R . id . material drawer profile header , profile ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; handle Selection View ( m Current Profile , BOOL ) ; m Account Switcher Arrow . set Visibility ( View . VISIBLE ) ; if ( m Current Profile != null ) { String Holder . apply To ( m Current Profile . get Name ( ) , m Current Profile Name ) ; String Holder . apply To ( m Current Profile . get Email ( ) , m Current Profile Email ) ; } } if ( ! m Selection First Line Shown ) { m Current Profile Name . set Visibility ( View . GONE ) ; } if ( ! Text Utils . is Empty ( m Selection First Line ) ) { m Current Profile Name . set Text ( m Selection First Line ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; } if ( ! m Selection Second Line Shown ) { m Current Profile Email . set Visibility ( View . GONE ) ; } if ( ! Text Utils . is Empty ( m Selection Second Line ) ) { m Current Profile Email . set Text ( m Selection Second Line ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; } if ( ! m Selection List Enabled ) { m Account Switcher Arrow . set Visibility ( View . INVISIBLE ) ; handle Selection View ( null , BOOL ) ; } if ( ! m Selection List Enabled For Single Profile && m Profile First == null && ( m Profiles == null || m Profiles . size ( ) == NUM ) ) { m Account Switcher Arrow . set Visibility ( View . INVISIBLE ) ; handle Selection View ( null , BOOL ) ; } if ( m On Account Header Selection View Click Listener != null ) { handle Selection View ( m Current Profile , BOOL ) ; } }
public void commit If Prepared ( Ignite Internal Tx tx , Set < UUID > failed Node Ids ) { assert tx instanceof Grid Dht Tx Local || tx instanceof Grid Dht Tx Remote : tx ; assert ! F . is Empty ( tx . transaction Nodes ( ) ) : tx ; assert tx . near Xid Version ( ) != null : tx ; Grid Cache Tx Recovery Future fut = new Grid Cache Tx Recovery Future ( cctx , tx , failed Node Ids , tx . transaction Nodes ( ) ) ; cctx . mvcc ( ) . add Future ( fut , fut . future Id ( ) ) ; if ( log . is Debug Enabled ( ) ) log . debug ( STRING + tx + STRING + fut + STRING ) ; fut . prepare ( ) ; }
public static byte [ ] encode ( byte [ ] data , String pub key ) { try { Cipher cipher = Cipher . get Instance ( STRING ) ; java . security . Key k = get Public Key ( pub key ) ; cipher . init ( Cipher . ENCRYPT MODE , k ) ; byte [ ] en Bytes = cipher . do Final ( data ) ; return en Bytes ; } catch ( Exception e ) { log . error ( STRING + pub key + STRING + data . length , e ) ; } return null ; }
static int derive ARGB ( Color color 1 , Color color 2 , float mid Point ) { int r = color 1 . get Red ( ) + ( int ) ( ( color 2 . get Red ( ) - color 1 . get Red ( ) ) * mid Point + NUM ) ; int g = color 1 . get Green ( ) + ( int ) ( ( color 2 . get Green ( ) - color 1 . get Green ( ) ) * mid Point + NUM ) ; int b = color 1 . get Blue ( ) + ( int ) ( ( color 2 . get Blue ( ) - color 1 . get Blue ( ) ) * mid Point + NUM ) ; int a = color 1 . get Alpha ( ) + ( int ) ( ( color 2 . get Alpha ( ) - color 1 . get Alpha ( ) ) * mid Point + NUM ) ; return ( ( a & NUM ) << NUM ) | ( ( r & NUM ) << NUM ) | ( ( g & NUM ) << NUM ) | ( b & NUM ) ; }
static public Item Stack chisel Block ( final I Continuous Inventory selected , final Acting Player player , final Voxel Blob vb , final World world , final Block Pos pos , final Enum Facing side , final int x , final int y , final int z , Item Stack output , final List < Entity Item > spawnlist ) { final boolean is Creative = player . is Creative ( ) ; final int blk = vb . get ( x , y , z ) ; if ( blk == NUM ) { return output ; } if ( ! can Mine ( selected , Block . get State By Id ( blk ) , player . get Player ( ) , world , pos ) ) { return output ; } selected . use Item ( blk ) ; final boolean spawn Bit = Chisels And Bits . get Items ( ) . item Block Bit != null ; if ( ! world . is Remote && ! is Creative ) { double hit X = x * one 16 th ; double hit Y = y * one 16 th ; double hit Z = z * one 16 th ; final double offset = NUM ; hit X += side . get Front Offset X ( ) * offset ; hit Y += side . get Front Offset Y ( ) * offset ; hit Z += side . get Front Offset Z ( ) * offset ; if ( output == null || ! Item Chiseled Bit . same Bit ( output , blk ) || output . stack Size == NUM ) { output = Item Chiseled Bit . create Stack ( blk , NUM , BOOL ) ; if ( spawn Bit ) { spawnlist . add ( new Entity Item ( world , pos . get X ( ) + hit X , pos . get Y ( ) + hit Y , pos . get Z ( ) + hit Z , output ) ) ; } } else { output . stack Size ++ ; } } else { output = Item Chiseled Bit . create Stack ( blk , NUM , BOOL ) ; } vb . clear ( x , y , z ) ; return output ; }
private static Pair < String , String > parse Strategy ( String desc ) { String [ ] arg = desc . split ( STRING ) ; Pair < String , String > rval = new Pair < String , String > ( arg [ NUM ] , STRING ) ; if ( arg . length > NUM ) { rval . set Second ( arg [ NUM ] ) ; } return rval ; }
protected void notify Locator ( L locator ) { synchronized ( this ) { if ( ! known Locators . add ( locator . get Partition Id ( ) ) ) { throw new Illegal State Exception ( STRING + locator ) ; } } }
private boolean process Mouse Event ( Mouse Event e ) { int id = e . get ID ( ) ; Component mouse Over = native Container . get Mouse Event Target ( e . get X ( ) , e . get Y ( ) , Container . INCLUDE SELF ) ; track Mouse Enter Exit ( mouse Over , e ) ; Component met = mouse Event Target . get ( ) ; if ( ! is Mouse Grab ( e ) && id != Mouse Event . MOUSE CLICKED ) { met = ( mouse Over != native Container ) ? mouse Over : null ; mouse Event Target = new Weak Reference < > ( met ) ; } if ( met != null ) { switch ( id ) { case Mouse Event . MOUSE ENTERED : case Mouse Event . MOUSE EXITED : break ; case Mouse Event . MOUSE PRESSED : retarget Mouse Event ( met , id , e ) ; break ; case Mouse Event . MOUSE RELEASED : retarget Mouse Event ( met , id , e ) ; break ; case Mouse Event . MOUSE CLICKED : if ( mouse Over == met ) { retarget Mouse Event ( mouse Over , id , e ) ; } break ; case Mouse Event . MOUSE MOVED : retarget Mouse Event ( met , id , e ) ; break ; case Mouse Event . MOUSE DRAGGED : if ( is Mouse Grab ( e ) ) { retarget Mouse Event ( met , id , e ) ; } break ; case Mouse Event . MOUSE WHEEL : if ( event Log . is Loggable ( Platform Logger . Level . FINEST ) && ( mouse Over != null ) ) { event Log . finest ( STRING + mouse Over . get Name ( ) + STRING + mouse Over . get Class ( ) ) ; } retarget Mouse Event ( mouse Over , id , e ) ; break ; } if ( id != Mouse Event . MOUSE WHEEL ) { e . consume ( ) ; } } return e . is Consumed ( ) ; }
private void add Processor Options ( Map < Plugin Util . Checker Prop , Object > opts , I Preference Store store ) { String skip Uses = store . get String ( Checker Preferences . PREF CHECKER A SKIP CLASSES ) ; if ( ! skip Uses . is Empty ( ) ) { opts . put ( Plugin Util . Checker Prop . A SKIP , skip Uses ) ; } String lint Opts = store . get String ( Checker Preferences . PREF CHECKER A LINT ) ; if ( ! lint Opts . is Empty ( ) ) { opts . put ( Plugin Util . Checker Prop . A LINT , lint Opts ) ; } if ( store . get Boolean ( Checker Preferences . PREF CHECKER A WARNS ) ) { opts . put ( Plugin Util . Checker Prop . A WARNS , Boolean . TRUE ) ; } if ( store . get Boolean ( Checker Preferences . PREF CHECKER A NO MSG TEXT ) ) opts . put ( Plugin Util . Checker Prop . A NO MSG TXT , Boolean . TRUE ) ; if ( store . get Boolean ( Checker Preferences . PREF CHECKER A SHOW CHECKS ) ) opts . put ( Plugin Util . Checker Prop . A SHOW CHECKS , Boolean . TRUE ) ; if ( store . get Boolean ( Checker Preferences . PREF CHECKER A FILENAMES ) ) opts . put ( Plugin Util . Checker Prop . A FILENAMES , Boolean . TRUE ) ; }
public void merge Backend Notes ( List < Note > remote Notes ) { List < Note > to Merge Notes = new Array List < > ( ) ; Map < String , Note > remote Notes Map = new Hash Map < > ( ) ; for ( Note note : remote Notes ) { remote Notes Map . put ( note . get Backend Id ( ) , note ) ; } List < Note > local Notes = note Dao . query By Backend Ids ( remote Notes Map . key Set ( ) ) ; Map < String , Note > local Notes Map = new Hash Map < > ( ) ; for ( Note local Note : local Notes ) { local Notes Map . put ( local Note . get Backend Id ( ) , local Note ) ; } for ( Note remote Note : remote Notes ) { Note local Note = local Notes Map . get ( remote Note . get Backend Id ( ) ) ; if ( local Note != null ) { remote Note . set Id ( local Note . get Id ( ) ) ; } to Merge Notes . add ( remote Note ) ; } save Notes ( to Merge Notes ) ; }
public void list ( Print Writer out ) { out . println ( STRING ) ; Hashtable < String , Object > h = new Hashtable < > ( ) ; enumerate ( h ) ; for ( Enumeration < String > e = h . keys ( ) ; e . has More Elements ( ) ; ) { String key = e . next Element ( ) ; String val = ( String ) h . get ( key ) ; if ( val . length ( ) > NUM ) { val = val . substring ( NUM , NUM ) + STRING ; } out . println ( key + STRING + val ) ; } }
@ Nullable public static String file Md 5 ( @ Nullable File file , @ Nullable Ignite Logger log ) { String md 5 = null ; if ( file != null ) { if ( ! file . is File ( ) ) { U . warn ( log , STRING + file ) ; return null ; } Input Stream in = null ; try { in = new Buffered Input Stream ( new File Input Stream ( file ) ) ; md 5 = Digest Utils . md 5 Hex ( in ) ; } catch ( IO Exception e ) { U . warn ( log , STRING + e . get Message ( ) ) ; } finally { U . close Quiet ( in ) ; } } return md 5 ; }
@ Override public void add Scanned Result ( List < List Based Result Wrapper > list Based Result ) { this . current Row Pointer = list Based Result ; total Number Of Records = list Based Result . size ( ) ; all Rows Result . add ( list Based Result ) ; }
public void trim To Size ( ) { if ( names != null ) names . trim To Size ( ) ; if ( required Children != null ) { required Children . trim To Size ( ) ; for ( Gaz Entry nextkey : required Children . values ( ) ) { nextkey . trim To Size ( ) ; } } }
public void clear Sections ( ) { sections . clear ( ) ; fire Update Event ( SECTION EVENT ) ; }
public Node Set DTM ( Node List node List , X Path Context xctxt ) { super ( ) ; m manager = xctxt . get DTM Manager ( ) ; int n = node List . get Length ( ) ; for ( int i = NUM ; i < n ; i ++ ) { Node node = node List . item ( i ) ; int handle = xctxt . get DTM Handle From Node ( node ) ; add Node ( handle ) ; } }
public void test thread Safe ( ) throws Interrupted Exception , Execution Exception { final long event History Millis = NUM ; final Event B Tree event B Tree = Event B Tree . create Transient ( ) ; final Event Receiver event Receiver = new Event Receiver ( event History Millis , event B Tree ) ; final I Bigdata Federation fed = new Mock Federation ( event Receiver ) ; final Executor Service ex Service = Executors . new Cached Thread Pool ( Daemon Thread Factory . default Thread Factory ( ) ) ; final int nthreads = NUM ; final int nevents = NUM ; try { final List < Callable < Void > > tasks = new Linked List < Callable < Void > > ( ) ; for ( int i = NUM ; i < nthreads ; i ++ ) { tasks . add ( new Event Factory ( fed , nevents ) ) ; } tasks . add ( new Event Consumer ( event Receiver ) ) ; final List < Future < Void > > futures = ex Service . invoke All ( tasks ) ; for ( Future f : futures ) { f . get ( ) ; } } finally { ex Service . shutdown Now ( ) ; } }
public static List < Container > create Container List ( int broker Id , int containers Number ) { Array List < Container > containers = new Array List < Container > ( ) ; for ( int i = NUM ; i < containers Number ; ++ i ) { int container Type = i / ( int ) Math . ceil ( ( double ) containers Number / NUM ) ; containers . add ( new Power Container ( I Ds . poll Id ( Container . class ) , broker Id , ( double ) Constants Examples . CONTAINER MIPS [ container Type ] , Constants Examples . CONTAINER PES [ container Type ] , Constants Examples . CONTAINER RAM [ container Type ] , Constants Examples . CONTAINER BW , NUM , STRING , new Container Cloudlet Scheduler Dynamic Workload ( Constants Examples . CONTAINER MIPS [ container Type ] , Constants Examples . CONTAINER PES [ container Type ] ) , Constants Examples . SCHEDULING INTERVAL ) ) ; } return containers ; }
private List < Storage Port > sort Ports ( List < Storage Port > storage Ports , Map < Initiator , List < Storage Port > > existing Assignments , List < Storage Port > new Ports ) { Set < URI > included Ports = new Hash Set < URI > ( ) ; List < Storage Port > sorted Ports = new Array List < Storage Port > ( ) ; Map < URI , Storage Port > ports Map = Data Object Utils . to Map ( storage Ports ) ; for ( int num Ports = NUM ; num Ports >= NUM ; num Ports -- ) { for ( List < Storage Port > ports : existing Assignments . values ( ) ) { if ( ports . size ( ) >= num Ports ) { for ( Storage Port port : ports ) { if ( ! included Ports . contains ( port . get Id ( ) ) && ports Map . contains Key ( port . get Id ( ) ) ) { sorted Ports . add ( port ) ; included Ports . add ( port . get Id ( ) ) ; } } } } } for ( Storage Port port : storage Ports ) { if ( ! included Ports . contains ( port . get Id ( ) ) ) { sorted Ports . add ( port ) ; included Ports . add ( port . get Id ( ) ) ; new Ports . add ( port ) ; } } if ( sorted Ports . size ( ) != storage Ports . size ( ) ) { log . error ( STRING ) ; log . error ( sorted Ports . to String ( ) ) ; log . error ( storage Ports . to String ( ) ) ; return null ; } return sorted Ports ; }
protected void evict With Freezer ( ) { int elems To Remove Pre Check = elements To Remove ( ) ; if ( elems To Remove Pre Check <= NUM ) { return ; } int i = NUM ; Set < Entry < K , Access Time Object Holder < V > > > entry Set = objects . entry Set ( ) ; int size = entry Set . size ( ) ; Array List < Holder Freezer < K , V > > to Check L = new Array List < > ( size ) ; for ( Entry < K , Access Time Object Holder < V > > entry : entry Set ) { if ( i == size ) { break ; } K key = entry . get Key ( ) ; Access Time Object Holder < V > holder = entry . get Value ( ) ; long frozen Value = eviction Class . get Freeze Value ( key , holder ) ; Holder Freezer < K , V > frozen = new Holder Freezer < > ( key , holder , frozen Value ) ; to Check L . add ( i , frozen ) ; i ++ ; } @ Suppress Warnings ( STRING ) Holder Freezer < K , V > [ ] to Check = to Check L . to Array ( new Holder Freezer [ to Check L . size ( ) ] ) ; Arrays . sort ( to Check , eviction Class . eviction Comparator ( ) ) ; int removed Count = NUM ; int elems To Remove = elements To Remove ( ) ; for ( Holder Freezer < K , V > entry To Remove : to Check ) { K key = entry To Remove . get Key ( ) ; V old Value = remove ( key ) ; if ( old Value != null ) { ++ removed Count ; if ( expiry Notification ) evicted Elements . put ( key , old Value ) ; if ( removed Count >= elems To Remove ) break ; } } eviction Count . add And Get ( removed Count ) ; statistics Calculator . increment Remove Count ( removed Count ) ; eviction Rate Counter . register Events ( millis Estimator . seconds ( ) , removed Count ) ; }
public void add Model Change ( String table Name , Model Validator listener ) { if ( table Name == null || listener == null ) return ; String property Name = m global Validators . contains ( listener ) ? table Name + STRING : table Name + listener . get AD Client ID ( ) ; Array List < Model Validator > list = ( Array List < Model Validator > ) m model Change Listeners . get ( property Name ) ; if ( list == null ) { list = new Array List < Model Validator > ( ) ; list . add ( listener ) ; m model Change Listeners . put ( property Name , list ) ; } else list . add ( listener ) ; }
public LDAP Url ( final boolean is Secured , final String host , final Integer port , final DN name , final Search Scope scope , final Filter filter , final String ... attributes ) { final String Builder url Buffer = new String Builder ( ) ; this . is Secured = is Secured ; if ( this . is Secured ) { url Buffer . append ( SSL URL SCHEME ) ; } else { url Buffer . append ( DEFAULT URL SCHEME ) ; } url Buffer . append ( STRING ) ; if ( host == null ) { this . host = DEFAULT HOST ; } else { this . host = host ; url Buffer . append ( this . host ) ; } int listen Port = DEFAULT PORT ; if ( port == null ) { listen Port = is Secured ? DEFAULT SSL PORT : DEFAULT PORT ; } else { listen Port = port . int Value ( ) ; if ( listen Port < NUM || listen Port > NUM ) { final Localizable Message msg = ERR LDAPURL BAD PORT . get ( listen Port ) ; throw new Localized Illegal Argument Exception ( msg ) ; } url Buffer . append ( COLON CHAR ) ; url Buffer . append ( listen Port ) ; } this . port = listen Port ; url Buffer . append ( SLASH CHAR ) ; if ( name != null ) { this . name = name ; percent Encoder ( name . to String ( ) , url Buffer ) ; } else { this . name = DEFAULT DN ; } url Buffer . append ( QUESTION CHAR ) ; switch ( attributes . length ) { case NUM : this . attributes = Collections . empty List ( ) ; break ; case NUM : this . attributes = Collections . singleton List ( attributes [ NUM ] ) ; url Buffer . append ( attributes [ NUM ] ) ; break ; default : this . attributes = Collections . unmodifiable List ( Arrays . as List ( attributes ) ) ; url Buffer . append ( attributes [ NUM ] ) ; for ( int i = NUM ; i < attributes . length ; i ++ ) { url Buffer . append ( COMMA CHAR ) ; url Buffer . append ( attributes [ i ] ) ; } break ; } url Buffer . append ( QUESTION CHAR ) ; if ( scope != null ) { this . scope = scope ; url Buffer . append ( scope ) ; } else { this . scope = DEFAULT SCOPE ; } url Buffer . append ( QUESTION CHAR ) ; if ( filter != null ) { this . filter = filter ; url Buffer . append ( this . filter ) ; } else { this . filter = DEFAULT FILTER ; } url String = url Buffer . to String ( ) ; }
private Object execute Plus ( Page Context pc , SQL sql , Query qr , Operation 2 expression , int row ) throws Page Exception { Object left = execute Exp ( pc , sql , qr , expression . get Left ( ) , row ) ; Object right = execute Exp ( pc , sql , qr , expression . get Right ( ) , row ) ; try { return new Double ( Caster . to Double Value ( left ) + Caster . to Double Value ( right ) ) ; } catch ( Page Exception e ) { return Caster . to String ( left ) + Caster . to String ( right ) ; } }
@ POST @ Consumes ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Path ( STRING ) @ Check Permission ( roles = { Role . TENANT ADMIN } ) public Task List discover Array Affinity For Hosts ( Array Affinity Host Param param ) { List < URI > host Ids = param . get Hosts ( ) ; Arg Validator . check Field Not Empty ( host Ids , STRING ) ; for ( URI host Id : host Ids ) { Arg Validator . check Field Uri Type ( host Id , Host . class , STRING ) ; query Object ( Host . class , host Id , BOOL ) ; } return create Host Array Affinity Tasks ( host Ids ) ; }
public int read ( byte [ ] b , int off , int len ) throws IO Exception { ensure Open ( ) ; if ( b == null ) { throw new Null Pointer Exception ( STRING ) ; } else if ( off < NUM || len < NUM || len > b . length - off ) { throw new Index Out Of Bounds Exception ( ) ; } else if ( len == NUM ) { return NUM ; } int cnt = NUM ; while ( len > NUM && ! def . finished ( ) ) { int n ; if ( def . needs Input ( ) ) { n = in . read ( buf , NUM , buf . length ) ; if ( n < NUM ) { def . finish ( ) ; } else if ( n > NUM ) { def . set Input ( buf , NUM , n ) ; } } n = def . deflate ( b , off , len ) ; cnt += n ; off += n ; len -= n ; } if ( cnt == NUM && def . finished ( ) ) { reach EOF = BOOL ; cnt = - NUM ; } return cnt ; }
private void draw Line To Touch Point ( Canvas canvas ) { if ( touch Point . height ( ) > NUM && touch Point . width ( ) > NUM ) { draw Line ( canvas , circles [ connection Order . get ( connection Order . size ( ) - NUM ) ] , touch Point ) ; } }
public static Java File Object to Java File Object ( Java File Manager file Manager , File source File ) throws IO Exception { List < Java File Object > java File Objects = to Java File Objects ( file Manager , as List ( source File ) ) ; return java File Objects . is Empty ( ) ? null : java File Objects . get ( NUM ) ; }
public Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= NUM || h <= NUM ) { throw new Raster Format Exception ( STRING + ( ( w <= NUM ) ? STRING : STRING ) ) ; } Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new Short Interleaved Raster ( sm , new Point ( NUM , NUM ) ) ; }
public static Left Indexed Power Law Multi Segment Bipartite Graph build Random Multi Segment Bipartite Graph ( int max Num Segments , int max Num Edges Per Segment , int left Size , int right Size , double edge Probability , Random random ) { Left Indexed Power Law Multi Segment Bipartite Graph multi Segment Left Indexed Power Law Bipartite Graph = new Left Indexed Power Law Multi Segment Bipartite Graph ( max Num Segments , max Num Edges Per Segment , left Size / NUM , ( int ) ( right Size * edge Probability / NUM ) , NUM , right Size / NUM , new Identity Edge Type Mask ( ) , new Null Stats Receiver ( ) ) ; for ( int i = NUM ; i < left Size ; i ++ ) { for ( int j = NUM ; j < right Size ; j ++ ) { if ( random . next Double ( ) < edge Probability ) { multi Segment Left Indexed Power Law Bipartite Graph . add Edge ( i , j , ( byte ) NUM ) ; } } } return multi Segment Left Indexed Power Law Bipartite Graph ; }
public static String execute ( String command ) { return execute ( command , null ) ; }
private void test Email ( ) { final Progress Window progress Window = new Progress Window ( Main Frame . get Instance ( ) , STRING ) ; progress Window . set Visible ( BOOL ) ; final Runnable runnable = null ; final Thread t = new Thread ( runnable ) ; t . start ( ) ; }
@ Suppress Warnings ( STRING ) protected Context Handler create Context ( String filename ) throws Exception { Resource resource = Resource . new Resource ( filename ) ; if ( ! resource . exists ( ) ) { return null ; } Xml Configuration xml Configuration = new Xml Configuration ( resource . get URL ( ) ) ; Hash Map properties = new Hash Map ( ) ; properties . put ( STRING , contexts . get Server ( ) ) ; if ( config Mgr != null ) { properties . put All ( config Mgr . get Properties ( ) ) ; } xml Configuration . set Properties ( properties ) ; Context Handler context = ( Context Handler ) xml Configuration . configure ( ) ; Enumeration < ? > names = attributes . get Attribute Names ( ) ; while ( names . has More Elements ( ) ) { String name = ( String ) names . next Element ( ) ; context . set Attribute ( name , attributes . get Attribute ( name ) ) ; } return context ; }
public boolean starts With ( java . lang . String prefix ) { return starts With ( prefix , NUM ) ; }
private native static boolean has Static Initializer ( Class < ? > cl ) ;
public static Temp Path create Directory ( Path dir ) throws IO Exception { return wrap ( Files . create Temp Directory ( dir , PREFIX ) ) ; }
@ Override public String to String ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STRING ) ; final int end = offset + length ; for ( int i = offset ; i < end ; i ++ ) { if ( i > offset ) { sb . append ( STRING ) ; } sb . append ( Integer . to Hex String ( bytes [ i ] & NUM ) ) ; } sb . append ( STRING ) ; return sb . to String ( ) ; }
public static boolean is Category Contains Product ( Servlet Request request , String product Category Id , String product Id ) { return is Category Contains Product ( ( Delegator ) request . get Attribute ( STRING ) , ( Local Dispatcher ) request . get Attribute ( STRING ) , product Category Id , product Id ) ; }
@ Override public boolean input ( Instance instance ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STRING ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = BOOL ; } if ( is First Batch Done ( ) ) { push ( instance ) ; return BOOL ; } else { buffer Input ( instance ) ; return BOOL ; } }
public Collection < String > list Tables ( ) throws Database Exception { Collection < String > result = new Array List < String > ( ) ; Result Set rs = null ; try { Database Meta Data dbm = connection . get Meta Data ( ) ; String types [ ] = { STRING } ; rs = dbm . get Tables ( null , null , null , types ) ; while ( rs . next ( ) ) { String str = rs . get String ( STRING ) ; result . add ( str ) ; } } catch ( SQL Exception e ) { throw ( new Database Exception ( e ) ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQL Exception e ) { } } } return result ; }
private Set < String > find Resource Names ( String path , String prefix , String suffix ) throws IO Exception { Set < String > resource Names = new Tree Set < String > ( ) ; List < URL > locations Urls = get Location Urls For Path ( path ) ; for ( URL location Url : locations Urls ) { LOG . debug ( STRING + location Url . to External Form ( ) ) ; Url Resolver url Resolver = create Url Resolver ( location Url . get Protocol ( ) ) ; URL resolved Url = url Resolver . to Standard Java Url ( location Url ) ; String protocol = resolved Url . get Protocol ( ) ; Class Path Location Scanner class Path Location Scanner = create Location Scanner ( protocol ) ; if ( class Path Location Scanner == null ) { String scan Root = Url Utils . to File Path ( resolved Url ) ; LOG . warn ( STRING + scan Root + STRING + protocol + STRING ) ; } else { resource Names . add All ( class Path Location Scanner . find Resource Names ( path , resolved Url ) ) ; } } return filter Resource Names ( resource Names , prefix , suffix ) ; }
public void wait For Event ( long timeout ) { Thread thread = Thread . current Thread ( ) ; Semaphore semaphore = semaphores . get ( thread ) ; if ( semaphore == null ) { semaphore = new Semaphore ( NUM , BOOL ) ; semaphore . drain Permits ( ) ; semaphores . put If Absent ( thread , semaphore ) ; } semaphore = semaphores . get ( thread ) ; try { semaphore . try Acquire ( timeout , Time Unit . MILLISECONDS ) ; } catch ( Interrupted Exception exception ) { logger . log ( Level . FINER , STRING , exception ) ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return BOOL ; } if ( ! ( obj instanceof Keyed Values ) ) { return BOOL ; } Keyed Values that = ( Keyed Values ) obj ; int count = get Item Count ( ) ; if ( count != that . get Item Count ( ) ) { return BOOL ; } for ( int i = NUM ; i < count ; i ++ ) { Comparable k1 = get Key ( i ) ; Comparable k2 = that . get Key ( i ) ; if ( ! k1 . equals ( k2 ) ) { return BOOL ; } Number v1 = get Value ( i ) ; Number v2 = that . get Value ( i ) ; if ( v1 == null ) { if ( v2 != null ) { return BOOL ; } } else { if ( ! v1 . equals ( v2 ) ) { return BOOL ; } } } return BOOL ; }
protected boolean are All Dbsvc Active ( ) { Coordinator Client coordinator Client = coordinator . get Coordinator Client ( ) ; List < Service > active Dbsvcs = coordinator Client . locate All Svcs All Vers ( Constants . DBSVC NAME ) ; List < String > active Dbsvc Ids = new Array List < > ( active Dbsvcs . size ( ) ) ; for ( Service active Dbsvc : active Dbsvcs ) { active Dbsvc Ids . add ( active Dbsvc . get Id ( ) ) ; } log . info ( STRING , active Dbsvc Ids , node Count ) ; boolean all Active = active Dbsvcs . size ( ) == node Count ; if ( ! all Active ) { log . info ( STRING ) ; } return all Active ; }
public static void schedule Linear ( Context context , int delay ) { Intent intent = new Intent ( context , Heartbeat Receiver . class ) ; intent . put Extra ( KEY DELAY , delay ) ; intent . put Extra ( KEY TYPE , TYPE LINEAR ) ; long time Gap = delay * NUM * NUM ; Pending Intent alarm Intent = Pending Intent . get Broadcast ( context , delay , intent , Pending Intent . FLAG CANCEL CURRENT ) ; Alarm Manager alarm Manager = ( Alarm Manager ) context . get System Service ( Context . ALARM SERVICE ) ; alarm Manager . set Repeating ( Alarm Manager . RTC WAKEUP , System . current Time Millis ( ) + time Gap , time Gap , alarm Intent ) ; Log . d ( STRING , STRING ) ; }
public boolean is Stop Requested ( ) { if ( stop Requested . get ( ) == BOOL ) return BOOL ; else return BOOL ; }
@ Suppress Warnings ( { STRING } ) public static < T > T [ ] join ( Class < T > component Type , T [ ] [ ] arrays ) { if ( arrays . length == NUM ) { return arrays [ NUM ] ; } int length = NUM ; for ( T [ ] array : arrays ) { length += array . length ; } T [ ] result = ( T [ ] ) Array . new Instance ( component Type , length ) ; length = NUM ; for ( T [ ] array : arrays ) { System . arraycopy ( array , NUM , result , length , array . length ) ; length += array . length ; } return result ; }
public Map < String , Set < String > > evaluate ( Subject admin Subject , String realm , Subject subject , String resource Name , Map < String , Set < String > > environment ) throws Entitlement Exception { Subject Attributes Manager sac = Subject Attributes Manager . get Instance ( admin Subject , realm ) ; Set < String > names = new Hash Set < String > ( ) ; if ( ( property Values == null ) || property Values . is Empty ( ) ) { names . add ( property Name ) ; } else { names . add All ( property Values ) ; } Map < String , Set < String > > values = sac . get User Attributes ( subject , names ) ; Set < String > tmp = new Hash Set < String > ( ) ; if ( ( values != null ) && ! values . is Empty ( ) ) { for ( String k : values . key Set ( ) ) { tmp . add All ( values . get ( k ) ) ; } } Map < String , Set < String > > results = new Hash Map < String , Set < String > > ( ) ; results . put ( property Name , tmp ) ; return results ; }
public void buscar Procedimiento Rapida Execute Logic ( Action Mapping mappings , Action Form form , Http Servlet Request request , Http Servlet Response response ) { Busquedas Helper . buscar Procedimiento Comun Logic ( mappings , ( Busqueda Elementos Form ) form , request , response ) ; set Return Action Fordward ( request , mappings . find Forward ( STRING ) ) ; }
protected void notify ( final I Change Record record ) { final Bigdata Graph Edit edit = to Graph Edit ( record ) ; if ( edit != null ) { for ( Bigdata Graph Listener listener : listeners ) { listener . graph Edited ( edit , record . to String ( ) ) ; } } }
public synchronized void notify Done ( Job done Job ) { LOG . debug ( STRING + done Job ) ; Set < Job > new Ready Jobs = dag Manager . remove Job ( done Job ) ; for ( Job job To Run : new Ready Jobs ) { LOG . debug ( STRING + job To Run + STRING ) ; jobs To Run . add ( job To Run ) ; } increment Done Job Count ( ) ; count Lock . lock ( ) ; try { LOG . debug ( STRING + submitted Job Count + STRING + ( submitted Job Count - done Job Count ) + STRING + done Job Count ) ; } finally { count Lock . unlock ( ) ; } }
public Class Constant add Class ( String name ) { Class Constant entry = get Class ( name ) ; if ( entry != null ) return entry ; Utf 8 Constant utf 8 = add UTF 8 ( name ) ; entry = new Class Constant ( this , entries . size ( ) , utf 8 . get Index ( ) ) ; add Constant ( entry ) ; return entry ; }
void write External ( Data Output out ) throws IO Exception { final int time Secs = ( time End Of Day ? NUM : time . to Second Of Day ( ) ) ; final int std Offset = standard Offset . get Total Seconds ( ) ; final int before Diff = offset Before . get Total Seconds ( ) - std Offset ; final int after Diff = offset After . get Total Seconds ( ) - std Offset ; final int time Byte = ( time Secs % NUM == NUM ? ( time End Of Day ? NUM : time . get Hour ( ) ) : NUM ) ; final int std Offset Byte = ( std Offset % NUM == NUM ? std Offset / NUM + NUM : NUM ) ; final int before Byte = ( before Diff == NUM || before Diff == NUM || before Diff == NUM ? before Diff / NUM : NUM ) ; final int after Byte = ( after Diff == NUM || after Diff == NUM || after Diff == NUM ? after Diff / NUM : NUM ) ; final int dow Byte = ( dow == null ? NUM : dow . get Value ( ) ) ; int b = ( month . get Value ( ) << NUM ) + ( ( dom + NUM ) << NUM ) + ( dow Byte << NUM ) + ( time Byte << NUM ) + ( time Definition . ordinal ( ) << NUM ) + ( std Offset Byte << NUM ) + ( before Byte << NUM ) + after Byte ; out . write Int ( b ) ; if ( time Byte == NUM ) { out . write Int ( time Secs ) ; } if ( std Offset Byte == NUM ) { out . write Int ( std Offset ) ; } if ( before Byte == NUM ) { out . write Int ( offset Before . get Total Seconds ( ) ) ; } if ( after Byte == NUM ) { out . write Int ( offset After . get Total Seconds ( ) ) ; } }
@ Suppress Warnings ( { STRING } ) public static < T extends Serializable > T deserialize Jdk ( byte [ ] bytes ) throws IO Exception , Class Not Found Exception { Object Input Stream in = null ; try { in = new Object Input Stream ( new Byte Array Input Stream ( bytes ) ) ; return ( T ) in . read Object ( ) ; } finally { close ( in ) ; } }
public void test Remainder Knuth One Digit By One Digit ( ) { byte a Bytes [ ] = { NUM , - NUM , NUM , - NUM } ; byte b Bytes [ ] = { NUM , - NUM , - NUM , - NUM } ; int a Sign = NUM ; int b Sign = - NUM ; byte r Bytes [ ] = { NUM , - NUM , - NUM , NUM } ; Big Integer a Number = new Big Integer ( a Sign , a Bytes ) ; Big Integer b Number = new Big Integer ( b Sign , b Bytes ) ; Big Integer result = a Number . remainder ( b Number ) ; byte res Bytes [ ] = new byte [ r Bytes . length ] ; res Bytes = result . to Byte Array ( ) ; for ( int i = NUM ; i < res Bytes . length ; i ++ ) { assert True ( res Bytes [ i ] == r Bytes [ i ] ) ; } assert Equals ( STRING , NUM , result . signum ( ) ) ; }
static void show Message Dialog ( String message , String title , int message Type ) { J Option Pane pane = new J Option Pane ( new Selectable Label ( message ) , message Type ) ; J Dialog dialog = pane . create Dialog ( title ) ; dialog . set Default Close Operation ( J Dialog . HIDE ON CLOSE ) ; set Location ( dialog ) ; dialog . set Visible ( BOOL ) ; dialog . dispose ( ) ; }
public void decrypt ( byte [ ] in , int length ) { int pos = NUM ; while ( pos < in . length && pos < length ) { decrypt Block ( in , pos , length ) ; pos += block Size ; } }
private static Class register Type Mapping ( RPC Server server , Class clazz ) { java . lang . reflect . Method [ ] methods = clazz . get Methods ( ) ; java . lang . reflect . Method method ; Class [ ] params ; for ( int i = NUM ; i < methods . length ; i ++ ) { method = methods [ i ] ; if ( method . get Declaring Class ( ) == clazz ) { register Type Mapping ( server , method . get Return Type ( ) ) ; params = method . get Parameter Types ( ) ; for ( int y = NUM ; y < params . length ; y ++ ) { register Type Mapping ( server , params [ y ] ) ; } } } return clazz ; }
private void name Based Stuff ( String cmd , String name ) { Collection < String > list = new Array List < > ( ) ; list . add ( name ) ; stream Stuff ( cmd , list ) ; }
public static long determine Ceiling From Max Value ( long number , int y Num Of Divs ) { long temp Int = number ; temp Int = temp Int / NUM + temp Int ; if ( temp Int < NUM ) { while ( temp Int % y Num Of Divs != NUM ) { temp Int ++ ; } return temp Int ; } else { int counter = NUM ; String num Str = STRING + number ; for ( int i = NUM ; i < num Str . length ( ) - NUM ; i ++ ) { temp Int = temp Int / NUM ; counter ++ ; } temp Int ++ ; while ( temp Int % y Num Of Divs != NUM ) { temp Int ++ ; } return ( long ) Math . pow ( NUM , counter ) * temp Int ; } }
public Cut Action ( final Network Panel network Panel ) { super ( network Panel , STRING , Enabling Condition . NEURONS ) ; Toolkit toolkit = Toolkit . get Default Toolkit ( ) ; Key Stroke key Stroke = Key Stroke . get Key Stroke ( Key Event . VK X , toolkit . get Menu Shortcut Key Mask ( ) ) ; put Value ( ACCELERATOR KEY , key Stroke ) ; put Value ( SMALL ICON , Resource Manager . get Image Icon ( STRING ) ) ; put Value ( SHORT DESCRIPTION , STRING ) ; }
public static boolean place Image Url ( Link link ) { String url = link . get Url ( ) ; if ( ! url . starts With ( STRING ) ) { url += STRING ; } String domain = link . get Domain ( ) ; if ( domain . contains ( STRING ) ) { if ( url . contains ( STRING ) ) { return BOOL ; } else if ( ends With Image Extension ( url , GIFV ) ) { return BOOL ; } else if ( url . contains ( STRING ) ) { return BOOL ; } else if ( url . contains ( STRING ) ) { return BOOL ; } else if ( ! check Is Image Url ( url ) ) { if ( url . char At ( url . length ( ) - NUM ) == STRING ) { url = url . substring ( NUM , url . length ( ) - NUM ) ; } url += STRING ; } } boolean is Image = check Is Image Url ( url ) ; if ( ! is Image ) { return BOOL ; } link . set Url ( url ) ; return BOOL ; }
protected boolean is Transaction A Late Repayment On Installment ( final int installment Index , final List < Loan Repayment Schedule Installment > installments , final Local Date transaction Date ) { final Loan Repayment Schedule Installment current Installment = installments . get ( installment Index ) ; return transaction Date . is After ( current Installment . get Due Date ( ) ) ; }
public static boolean is Email Id Valid ( String email ) { String expression = STRING ; Pattern pattern = Pattern . compile ( expression , Pattern . CASE INSENSITIVE ) ; Matcher matcher = pattern . matcher ( email ) ; return matcher . matches ( ) ; }
public void traverse ( Object vertex , boolean directed , mx I Cell Visitor visitor , Object edge , Set < Object > visited ) { if ( vertex != null && visitor != null ) { if ( visited == null ) { visited = new Hash Set < Object > ( ) ; } if ( ! visited . contains ( vertex ) ) { visited . add ( vertex ) ; if ( visitor . visit ( vertex , edge ) ) { int edge Count = model . get Edge Count ( vertex ) ; if ( edge Count > NUM ) { for ( int i = NUM ; i < edge Count ; i ++ ) { Object e = model . get Edge At ( vertex , i ) ; boolean is Source = model . get Terminal ( e , BOOL ) == vertex ; if ( ! directed || is Source ) { Object next = model . get Terminal ( e , ! is Source ) ; traverse ( next , directed , visitor , e , visited ) ; } } } } } } }
public static Web Xml parse Web Xml From File ( File the File , Entity Resolver the Entity Resolver ) throws IO Exception , JDOM Exception { Input Stream in = null ; try { in = new File Input Stream ( the File ) ; return parse Web Xml ( in , the Entity Resolver ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IO Exception ioe ) { } } } }
protected void close Channel ( Socket Channel channel ) { if ( channel == null ) return ; Socket socket = channel . socket ( ) ; try { socket . shutdown Input ( ) ; socket . shutdown Output ( ) ; socket . close ( ) ; } catch ( IO Exception ex ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING , ex ) ; } } finally { try { channel . close ( ) ; } catch ( IO Exception ex ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING , ex ) ; } } } }
@ Override public String to String ( ) { String Buffer sb = new String Buffer ( bits . length / NUM ) ; int bit Count = NUM ; sb . append ( STRING ) ; boolean comma = BOOL ; for ( int i = NUM ; i < bits . length ; i ++ ) { if ( bits [ i ] == NUM ) { bit Count += ELM SIZE ; continue ; } for ( int j = NUM ; j < ELM SIZE ; j ++ ) { if ( ( ( bits [ i ] & ( TWO N ARRAY [ j ] ) ) != NUM ) ) { if ( comma ) { sb . append ( STRING ) ; } sb . append ( bit Count ) ; comma = BOOL ; } bit Count ++ ; } } sb . append ( STRING ) ; return sb . to String ( ) ; }
public void add Subscription To Store ( final String topic , final String client Id ) { final Client Topic Couple subscription = new Client Topic Couple ( client Id , topic ) ; if ( ! topics . contains ( topic ) ) { logger . debug ( STRING + topic + STRING + client Id + STRING ) ; subscriptions Store . add ( subscription ) ; topics . add ( topic ) ; } }
public static void create Zip ( Path zip File , Path to Be Added , String internal Path ) { Map < String , String > env = new Hash Map < > ( ) ; try { env . put ( STRING , String . value Of ( ! Files . exists ( zip File ) ) ) ; URI file Uri = zip File . to Uri ( ) ; URI zip Uri = new URI ( STRING + file Uri . get Scheme ( ) , file Uri . get Path ( ) , null ) ; try ( File System zipfs = File Systems . new File System ( zip Uri , env ) ) { Path internal Target Path = zipfs . get Path ( internal Path ) ; if ( ! Files . exists ( internal Target Path . get Parent ( ) ) ) { Files . create Directory ( internal Target Path . get Parent ( ) ) ; } Files . copy ( to Be Added , internal Target Path , Standard Copy Option . REPLACE EXISTING ) ; } } catch ( Exception e ) { LOGGER . error ( STRING + e . get Message ( ) ) ; } }
private Hash Map < Integer , Boolean > generate Expanded State Map ( List < Object > item List ) { Hash Map < Integer , Boolean > parent Object Hash Map = new Hash Map < > ( ) ; int child Count = NUM ; for ( int i = NUM ; i < item List . size ( ) ; i ++ ) { if ( item List . get ( i ) != null ) { Object helper Item = get Helper Item ( i ) ; if ( helper Item instanceof Parent Wrapper ) { Parent Wrapper parent Wrapper = ( Parent Wrapper ) helper Item ; parent Object Hash Map . put ( i - child Count , parent Wrapper . is Expanded ( ) ) ; } else { child Count ++ ; } } } return parent Object Hash Map ; }
public void queue Sound ( Uri uri , Media Player . On Completion Listener listener ) { m Audio Queue . offer ( new Audio Queue Item ( uri , listener ) ) ; }
public Freshest CRL Extension ( Boolean critical , Object value ) throws IO Exception { super ( PKIX Extensions . Freshest CRL Id , critical . boolean Value ( ) , value , NAME ) ; }
public static String find Java Executable For Eclipse ( ) throws Core Exception { String java Home Prop = System . get Property ( STRING ) ; File java Home Dir = null ; if ( java Home Prop != null ) { java Home Dir = new File ( java Home Prop ) ; } if ( java Home Dir == null || ! java Home Dir . exists ( ) ) { throw new Core Exception ( new Status ( Status . ERROR , Core Plugin . PLUGIN ID , STRING ) ) ; } File java Executable = Standard VM Type . find Java Executable ( java Home Dir ) ; if ( java Executable == null || ! java Executable . exists ( ) ) { throw new Core Exception ( new Status ( Status . ERROR , Core Plugin . PLUGIN ID , STRING + java Home Dir . get Absolute Path ( ) + STRING ) ) ; } return java Executable . get Absolute Path ( ) ; }
private String print O Format ( long x ) { String sx = null ; if ( x == Long . MIN VALUE ) sx = STRING ; else if ( x < NUM ) { String t = Long . to String ( ( ~ ( - x - NUM ) ) ^ Long . MIN VALUE , NUM ) ; switch ( t . length ( ) ) { case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; case NUM : sx = STRING + t ; break ; } } else sx = Long . to String ( x , NUM ) ; return print O Format ( sx ) ; }
void remove Callback ( JS Object source , String method , boolean async ) { String key = source . to JS Pointer ( ) + STRING + method ; callbacks . remove ( key ) ; String js = STRING + source . to JS Pointer ( ) + STRING + method ; exec ( js , async ) ; }
public void remove From Dragging Connections ( Block root Block ) { if ( m Pending Drag == null ) { return ; } m Temp Connections . clear ( ) ; root Block . get All Connections Recursive ( m Temp Connections ) ; for ( int i = NUM ; i < m Temp Connections . size ( ) ; i ++ ) { Connection conn = m Temp Connections . get ( i ) ; m Dragged Connections . remove ( conn ) ; conn . set Drag Mode ( BOOL ) ; } }
public static String read File To String ( Path file ) throws IO Exception { byte [ ] file Array = Files . read All Bytes ( file ) ; return new String ( file Array , Standard Charsets . UTF 8 ) ; }
private static void collect ( final I Navi Operand Tree Node current Node , final List < I Navi Operand Tree Node > nodes ) { nodes . add ( current Node ) ; for ( final I Navi Operand Tree Node child : current Node . get Children ( ) ) { collect ( child , nodes ) ; } }
@ Override public void on Value Selected ( int picker Index , int new Value , boolean auto Advance ) { if ( picker Index == HOUR INDEX ) { set Hour ( new Value , BOOL ) ; String announcement = String . format ( STRING , new Value ) ; if ( m Allow Auto Advance && auto Advance ) { set Current Item Showing ( MINUTE INDEX , BOOL , BOOL , BOOL ) ; announcement += STRING + m Select Minutes ; } else { m Time Picker . set Content Description ( m Hour Picker Description + STRING + new Value ) ; } Utils . try Accessibility Announce ( m Time Picker , announcement ) ; } else if ( picker Index == MINUTE INDEX ) { set Minute ( new Value ) ; m Time Picker . set Content Description ( m Minute Picker Description + STRING + new Value ) ; } else if ( picker Index == AMPM INDEX ) { update Half Day ( new Value ) ; } else if ( picker Index == ENABLE PICKER INDEX ) { if ( ! is Typed Time Fully Legal ( ) ) { m Typed Times . clear ( ) ; } } }
private static Geo Polygon from Polygon ( final Polygon polygon ) { final Polygon [ ] the Holes = polygon . get Holes ( ) ; final List < Geo Polygon > hole List = new Array List < > ( the Holes . length ) ; for ( final Polygon hole : the Holes ) { final Geo Polygon component = from Polygon ( hole ) ; if ( component != null ) { hole List . add ( component ) ; } } final double [ ] poly Lats = polygon . get Poly Lats ( ) ; final double [ ] poly Lons = polygon . get Poly Lons ( ) ; final List < Geo Point > points = new Array List < > ( poly Lats . length - NUM ) ; for ( int i = NUM ; i < poly Lats . length - NUM ; i ++ ) { final int index = poly Lats . length - NUM - i ; points . add ( new Geo Point ( Planet Model . WGS 84 , from Degrees ( poly Lats [ index ] ) , from Degrees ( poly Lons [ index ] ) ) ) ; } final Geo Polygon rval = Geo Polygon Factory . make Geo Polygon ( Planet Model . WGS 84 , points , hole List ) ; return rval ; }
public void add Action ( Network Update Action action ) { action List . add ( action ) ; for ( Update Manager Listener listener : listeners ) { listener . action Added ( action ) ; } }
private void load ( Byte Buffer bb ) throws Buffer Underflow Exception , Mary Configuration Exception { int num Idx = bb . get Int ( ) ; idx Interval = bb . get Int ( ) ; if ( idx Interval <= NUM ) { throw new Mary Configuration Exception ( STRING ) ; } byte Ptrs = new long [ num Idx ] ; time Ptrs = new long [ num Idx ] ; for ( int i = NUM ; i < num Idx ; i ++ ) { byte Ptrs [ i ] = bb . get Long ( ) ; time Ptrs [ i ] = bb . get Long ( ) ; if ( i > NUM ) { if ( byte Ptrs [ i ] < byte Ptrs [ i - NUM ] || time Ptrs [ i ] < time Ptrs [ i - NUM ] ) { throw new Mary Configuration Exception ( STRING ) ; } } } bb . get Long ( ) ; bb . get Long ( ) ; }
protected boolean before Save ( boolean new Record ) { if ( get C Location ID ( ) == NUM ) return BOOL ; if ( ! new Record ) return BOOL ; M Location address = get Location ( BOOL ) ; m unique Name = get Name ( ) ; m unique = M Sys Config . get Int Value ( STRING , NUM , get AD Client ID ( ) , get AD Org ID ( ) ) ; if ( m unique < NUM || m unique > NUM ) m unique = NUM ; if ( m unique Name != null && m unique Name . equals ( STRING ) ) { m unique Name = null ; make Unique ( address ) ; } MB Partner Location [ ] locations = get For B Partner ( get Ctx ( ) , get C B Partner ID ( ) ) ; boolean unique = locations . length == NUM ; while ( ! unique ) { unique = BOOL ; for ( int i = NUM ; i < locations . length ; i ++ ) { MB Partner Location location = locations [ i ] ; if ( location . get C B Partner Location ID ( ) == get ID ( ) ) continue ; if ( m unique Name . equals ( location . get Name ( ) ) ) { m unique ++ ; make Unique ( address ) ; unique = BOOL ; break ; } } } set Name ( m unique Name ) ; return BOOL ; }
private String create Non CG Srdf Pair Steps On Populated Group ( List < Volume Descriptor > source Descriptors , List < Volume Descriptor > target Descriptors , Remote Director Group group , Map < URI , Volume > uri Volume Map , String wait For , Workflow workflow ) { Storage System system = db Client . query Object ( Storage System . class , group . get Source Storage System Uri ( ) ) ; URI vpool Change Uri = get Virtual Pool Change Volume ( source Descriptors ) ; log . info ( STRING , vpool Change Uri ) ; List < URI > source UR Is = Volume Descriptor . get Volume UR Is ( source Descriptors ) ; List < URI > target UR Is = new Array List < > ( ) ; for ( URI source URI : source UR Is ) { Volume source = uri Volume Map . get ( source URI ) ; String Set srdf Targets = source . get Srdf Targets ( ) ; for ( String target Str : srdf Targets ) { URI target URI = URI . create ( target Str ) ; target UR Is . add ( target URI ) ; } } Method suspend Group Method = suspend SRDF Group Method ( system . get Id ( ) , group , source UR Is , target UR Is ) ; Method resume Rollback Method = resume SRDF Group Method ( system . get Id ( ) , group , source UR Is , target UR Is ) ; String suspend Group Step = workflow . create Step ( CREATE SRDF ACTIVE VOLUME PAIR STEP GROUP , SUSPEND SRDF MIRRORS STEP DESC , wait For , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , suspend Group Method , resume Rollback Method , null ) ; Method create List Method = create List Replicas Method ( system . get Id ( ) , source UR Is , target UR Is , vpool Change Uri , BOOL ) ; Method rollback Method = rollback SRDF Links Method ( system . get Id ( ) , source UR Is , target UR Is , BOOL ) ; String create List Replica Step = workflow . create Step ( CREATE SRDF ACTIVE VOLUME PAIR STEP GROUP , CREATE SRDF ACTIVE VOLUME PAIR STEP DESC , suspend Group Step , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , create List Method , rollback Method , null ) ; Method resume Group Method = resume SRDF Group Method ( system . get Id ( ) , group , source UR Is , target UR Is ) ; String resume Group Step = workflow . create Step ( CREATE SRDF ACTIVE VOLUME PAIR STEP GROUP , RESUME SRDF MIRRORS STEP DESC , create List Replica Step , system . get Id ( ) , system . get System Type ( ) , get Class ( ) , resume Group Method , rollback Method Null Method ( ) , null ) ; return resume Group Step ; }
void collect Db Stats ( Array List < Db Stats > db Stats List ) { int lookaside = native Get Db Lookaside ( m Connection Ptr ) ; long page Count = NUM ; long page Size = NUM ; try { page Count = execute For Long ( STRING , null ) ; page Size = execute For Long ( STRING , null ) ; } catch ( SQ Lite Exception ex ) { } db Stats List . add ( get Main Db Stats Unsafe ( lookaside , page Count , page Size ) ) ; Cursor Window window = new Cursor Window ( STRING ) ; try { execute For Cursor Window ( STRING , null , window , NUM , NUM , BOOL ) ; for ( int i = NUM ; i < window . get Num Rows ( ) ; i ++ ) { String name = window . get String ( i , NUM ) ; String path = window . get String ( i , NUM ) ; page Count = NUM ; page Size = NUM ; try { page Count = execute For Long ( STRING + name + STRING , null ) ; page Size = execute For Long ( STRING + name + STRING , null ) ; } catch ( SQ Lite Exception ex ) { } String label = STRING + name ; if ( ! path . is Empty ( ) ) { label += STRING + path ; } db Stats List . add ( new Db Stats ( label , page Count , page Size , NUM , NUM , NUM , NUM ) ) ; } } catch ( SQ Lite Exception ex ) { } finally { window . close ( ) ; } }
public String print List ( My Idx List points ) { if ( points == null || points . length ( ) == NUM ) { return STRING ; } String Buffer bf = new String Buffer ( ) ; try { List Node temp ; for ( int i = NUM ; i < points . size ( ) ; i ++ ) { temp = points . get ( i ) ; if ( i == NUM ) { bf . append ( STRING + temp . idx ) ; } else { bf . append ( STRING + temp . idx ) ; } } } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } return bf . to String ( ) ; }
public void copy Zip ( final String src File , final String dest File ) throws Exception { load Default Exclude Pattern ( get Root Folder In Zip ( src File ) ) ; final Zip File zip Src = new Zip File ( src File ) ; final Zip Output Stream out = new Zip Output Stream ( new File Output Stream ( dest File ) ) ; try { final Enumeration < ? extends Zip Entry > entries = zip Src . entries ( ) ; while ( entries . has More Elements ( ) ) { final Zip Entry entry = entries . next Element ( ) ; if ( ! is Excluded ( Local Path . combine ( src File , entry . get Name ( ) ) , BOOL , src File ) ) { final Zip Entry new Entry = new Zip Entry ( entry . get Name ( ) ) ; out . put Next Entry ( new Entry ) ; final Buffered Input Stream in = new Buffered Input Stream ( zip Src . get Input Stream ( entry ) ) ; int len ; final byte [ ] buf = new byte [ NUM ] ; while ( ( len = in . read ( buf ) ) > NUM ) { out . write ( buf , NUM , len ) ; } out . close Entry ( ) ; in . close ( ) ; } } out . finish ( ) ; } catch ( final IO Exception e ) { error Msg = Messages . get String ( STRING ) ; log . error ( STRING , e ) ; throw e ; } finally { out . close ( ) ; zip Src . close ( ) ; } }
public int scan ( String table , String startkey , int recordcount , Set < String > fields , Vector < Hash Map < String , Byte Iterator > > result ) { long st = System . nano Time ( ) ; int res = db . scan ( table , startkey , recordcount , fields , result ) ; long en = System . nano Time ( ) ; measurements . measure ( STRING , ( int ) ( ( en - st ) / NUM ) ) ; measurements . report Return Code ( STRING , res ) ; return res ; }
private String normalize ( String str ) { String rpt 3 = STRING ; String rpt 4 = STRING ; String rpt 5 = STRING ; String rpt 6 = STRING ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( STRING , STRING ) ; str = str . replace All ( rpt 4 , STRING ) ; str = str . replace All ( rpt 3 , STRING ) ; str = str . replace All ( rpt 5 , STRING ) ; str = str . replace All ( rpt 6 , STRING ) ; str = replace Inlist ( str ) ; return str ; }
public static long spooky 4 ( final Bit Vector bv , final long prefix Length , final long seed , final long [ ] state ) { long h0 , h1 , h2 , h3 ; h0 = seed ; h1 = seed ; h2 = ARBITRARY BITS ; h3 = ARBITRARY BITS ; long pos ; if ( prefix Length >= NUM * Long . SIZE ) { final int p = NUM * ( int ) ( ( prefix Length - NUM * Long . SIZE ) / ( NUM * Long . SIZE ) ) ; h0 = state [ p + NUM ] ; h1 = state [ p + NUM ] ; h2 = state [ p + NUM ] ; h3 = state [ p + NUM ] ; pos = p * Long . SIZE + NUM * Long . SIZE ; } else pos = NUM ; long remaining = prefix Length - pos ; if ( remaining >= Long . SIZE * NUM ) { h0 += bv . get Long ( pos + NUM * Long . SIZE , pos + NUM * Long . SIZE ) ; h1 += bv . get Long ( pos + NUM * Long . SIZE , pos + NUM * Long . SIZE ) ; remaining -= NUM * Long . SIZE ; pos += NUM * Long . SIZE ; } if ( remaining > Long . SIZE ) { h2 += bv . get Long ( pos + NUM * Long . SIZE , pos + NUM * Long . SIZE ) ; h3 += bv . get Long ( pos + NUM * Long . SIZE , prefix Length ) ; } else if ( remaining > NUM ) { h2 += bv . get Long ( pos , prefix Length ) ; } else { h2 += ARBITRARY BITS ; h3 += ARBITRARY BITS ; } h0 += prefix Length ; h3 ^= h2 ; h2 = Long . rotate Left ( h2 , NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 = Long . rotate Left ( h3 , NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 = Long . rotate Left ( h0 , NUM ) ; h1 += h0 ; h2 ^= h1 ; h1 = Long . rotate Left ( h1 , NUM ) ; h2 += h1 ; h3 ^= h2 ; h2 = Long . rotate Left ( h2 , NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 = Long . rotate Left ( h3 , NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 = Long . rotate Left ( h0 , NUM ) ; h1 += h0 ; h2 ^= h1 ; h1 = Long . rotate Left ( h1 , NUM ) ; h2 += h1 ; h3 ^= h2 ; h2 = Long . rotate Left ( h2 , NUM ) ; h3 += h2 ; h0 ^= h3 ; h3 = Long . rotate Left ( h3 , NUM ) ; h0 += h3 ; h1 ^= h0 ; h0 = Long . rotate Left ( h0 , NUM ) ; h1 += h0 ; return h0 ; }
public Free Cell Node next ( ) { String line = sc . next Line ( ) ; String Tokenizer st = new String Tokenizer ( line , STRING ) ; int val = Integer . value Of ( st . next Token ( ) ) ; if ( val != deal ) { throw new No Such Element Exception ( STRING + deal + STRING ) ; } int [ ] deals = new int [ NUM ] ; int idx = NUM ; while ( st . has More Tokens ( ) ) { deals [ idx ++ ] = Integer . value Of ( st . next Token ( ) ) ; } deal ++ ; return Deal . initialize ( deals ) ; }
private void add To Map ( Map < String , Collection < Cluster Node > > cache Map , String cache Name , Cluster Node rich ) { Collection < Cluster Node > cache Nodes = cache Map . get ( cache Name ) ; if ( cache Nodes == null ) { cache Nodes = new Array List < > ( all Nodes . size ( ) ) ; cache Map . put ( cache Name , cache Nodes ) ; } cache Nodes . add ( rich ) ; }
private static void adjust ( Object [ ] array , Comparator c , int lower , int upper ) { int j , k ; Object temp ; j = lower ; k = lower * NUM ; while ( k <= upper ) { if ( ( k < upper ) && ( c . compare ( array [ k - NUM ] , array [ k ] ) < NUM ) ) { k += NUM ; } if ( c . compare ( array [ j - NUM ] , array [ k - NUM ] ) < NUM ) { temp = array [ j - NUM ] ; array [ j - NUM ] = array [ k - NUM ] ; array [ k - NUM ] = temp ; } j = k ; k *= NUM ; } }
public synchronized int index Of ( I Audio Processor processor ) { return processors . index Of ( processor ) ; }
public Trie Node find ( String suffix ) { Trie Node result ; Character c ; String new Suffix ; Trie Node child ; c = suffix . char At ( NUM ) ; new Suffix = suffix . substring ( NUM ) ; child = m Children . get ( c ) ; if ( child == null ) { result = null ; } else if ( new Suffix . length ( ) == NUM ) { result = child ; } else { result = child . find ( new Suffix ) ; } return result ; }
protected void notify Locator ( L locator ) { synchronized ( this ) { if ( ! known Locators . add ( locator . get Partition Id ( ) ) ) { throw new Illegal State Exception ( STRING + locator ) ; } } }
private static void task Queued ( Progress Thread task ) { for ( Progress Thread State Listener l : listener . get Listeners ( Progress Thread State Listener . class ) ) { l . progress Thread Queued ( task ) ; } }
public static final void is XML Char WF ( DOM Error Handler error Handler , DOM Error Impl error , DOM Locator Impl locator , String datavalue , boolean is XML 11 Version ) { if ( datavalue == null || ( datavalue . length ( ) == NUM ) ) { return ; } char [ ] dataarray = datavalue . to Char Array ( ) ; int datalength = dataarray . length ; if ( is XML 11 Version ) { int i = NUM ; while ( i < datalength ) { if ( XML 11 Char . is XML 11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM ] ; if ( XML Char . is High Surrogate ( ch ) && i < datalength ) { char ch 2 = dataarray [ i ++ ] ; if ( XML Char . is Low Surrogate ( ch 2 ) && XML Char . is Supplemental ( XML Char . supplemental ( ch , ch 2 ) ) ) { continue ; } } String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , new Object [ ] { Integer . to String ( dataarray [ i - NUM ] , NUM ) } ) ; report DOM Error ( error Handler , error , locator , msg , DOM Error . SEVERITY ERROR , STRING ) ; } } } else { int i = NUM ; while ( i < datalength ) { if ( XML Char . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM ] ; if ( XML Char . is High Surrogate ( ch ) && i < datalength ) { char ch 2 = dataarray [ i ++ ] ; if ( XML Char . is Low Surrogate ( ch 2 ) && XML Char . is Supplemental ( XML Char . supplemental ( ch , ch 2 ) ) ) { continue ; } } String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STRING , new Object [ ] { Integer . to String ( dataarray [ i - NUM ] , NUM ) } ) ; report DOM Error ( error Handler , error , locator , msg , DOM Error . SEVERITY ERROR , STRING ) ; } } } }
void release If Locked ( Object name , Internal Distributed Member owner , int lock Id ) throws Interrupted Exception { wait While Initializing ( ) ; if ( ! acquire Destroy Read Lock ( NUM ) ) { wait Until Destroyed ( ) ; check Destroyed ( ) ; } try { check Destroyed ( ) ; get And Release Grant If Locked By ( name , owner , lock Id ) ; } finally { release Destroy Read Lock ( ) ; } }
public Properties load Properties ( String artifact , String version ) throws IO Exception { Properties props = new Properties ( ) ; Path properties File = get Properties File ( artifact , version ) ; if ( ! Files . exists ( properties File ) ) { throw new Artifact Not Found Exception ( artifact , version ) ; } try ( Input Stream in = new Buffered Input Stream ( Files . new Input Stream ( properties File ) ) ) { props . load ( in ) ; } return props ; }
public Long File Getter In Memory ( File file ) throws IO Exception { limit = file . length ( ) / NUM ; data = new long [ ( int ) ( ( limit > > > BITS ) ) + NUM ] [ ] ; final int length 0 = ( NUM << BITS ) ; for ( int i = NUM ; i < data . length ; i ++ ) { int length = ( i < data . length - NUM ? length 0 : ( int ) ( limit & BIT MASK ) + NUM ) ; data [ i ] = new long [ length ] ; } try ( Buffered Input Stream ins = new Buffered Input Stream ( new File Input Stream ( file ) ) ; Progress Percentage progress = new Progress Percentage ( STRING + file , limit ) ) { int which Array = NUM ; int index In Array = NUM ; for ( long index = NUM ; index < limit ; index ++ ) { data [ which Array ] [ index In Array ] = ( ( ( long ) ins . read ( ) ) << NUM ) | ( ( ( long ) ins . read ( ) ) << NUM ) | ( ( ( long ) ins . read ( ) ) << NUM ) | ( ( ( long ) ins . read ( ) ) << NUM ) | ( ( ( long ) ins . read ( ) ) << NUM ) | ( ( ( long ) ins . read ( ) & NUM ) << NUM ) | ( ( ( long ) ins . read ( ) & NUM ) << NUM ) | ( ( ( long ) ins . read ( ) & NUM ) ) ; if ( ++ index In Array == length 0 ) { which Array ++ ; index In Array = NUM ; } progress . set Progress ( index ) ; } } }
static int accum Single ( int counts [ ] , int doc Base , Field Facet Stats [ ] facet Stats , Sorted Doc Values si , Doc Id Set Iterator disi , int sub Index , Ordinal Map map ) throws IO Exception { final Long Values ord Map = map == null ? null : map . get Global Ords ( sub Index ) ; int missing Doc Count = NUM ; int doc ; while ( ( doc = disi . next Doc ( ) ) != Doc Id Set Iterator . NO MORE DOCS ) { int term = si . get Ord ( doc ) ; if ( term >= NUM ) { if ( map != null ) { term = ( int ) ord Map . get ( term ) ; } counts [ term ] ++ ; for ( Field Facet Stats f : facet Stats ) { f . facet Term Num ( doc Base + doc , term ) ; } } else { for ( Field Facet Stats f : facet Stats ) { f . facet Missing Num ( doc Base + doc ) ; } missing Doc Count ++ ; } } return missing Doc Count ; }
public static void circumvent Bug 2650 ( Document doc ) { Element document Element = doc . get Document Element ( ) ; Attr xmlns Attr = document Element . get Attribute Node NS ( Constants . Namespace Spec NS , STRING ) ; if ( xmlns Attr == null ) { document Element . set Attribute NS ( Constants . Namespace Spec NS , STRING , STRING ) ; } XML Utils . circumvent Bug 2650 internal ( doc ) ; }
public void mouse Release ( int x , int y , int mouse Button ) { mouse X = x ; mouse Y = y ; if ( Math . abs ( velocity ) > NUM ) { amplitude = NUM * velocity ; timestamp = System . current Time Millis ( ) ; double length = Math . sqrt ( last Dx * last Dx + last Dy * last Dy ) ; last Dx /= length ; last Dy /= length ; } else { amplitude = NUM ; update Look At ( ) ; } }
@ Override public Multivariate Table to Discrete ( ) { if ( discrete Cache == null ) { Multivariate Table . Builder probs = new Multivariate Table . Builder ( ) ; double incr = NUM / samples . size ( ) ; for ( Assignment sample : samples ) { Assignment trimmed = sample . get Trimmed ( variables ) ; probs . increment Row ( trimmed , incr ) ; } discrete Cache = probs . build ( ) ; } return discrete Cache ; }
@ Suppress Warnings ( STRING ) public static Collection < X509 Certificate > read Certificates ( String base 64 data ) throws Exception { try ( Input Stream is = new Byte Array Input Stream ( decode Base 64 ( base 64 data ) ) ) { return ( Collection < X509 Certificate > ) CERT FACTORY . generate Certificates ( is ) ; } }
public Hash Token Session Map ( Environment environment ) { int session Timeout Value ; try { session Timeout Value = environment . get Property ( API SESSION TIMEOUT , NUM ) ; } catch ( Guacamole Exception e ) { logger . error ( STRING , e . get Message ( ) ) ; logger . debug ( STRING , e ) ; session Timeout Value = NUM ; } logger . info ( STRING , session Timeout Value ) ; executor . schedule At Fixed Rate ( new Session Eviction Task ( session Timeout Value * NUM ) , NUM , NUM , Time Unit . MINUTES ) ; }
default B with Default ( String key , Class < ? > value ) { return with Default ( key , value != null ? value . get Name ( ) : null ) ; }
public static Table Meta create Temp ODPS Table ( Table Info table Meta , int life Cycle ) { Table Meta temp Table = new Table Meta ( ) ; temp Table . set Comment ( table Meta . get Comments ( ) ) ; temp Table . set Life Cycle ( life Cycle ) ; String table Schema = table Meta . get Table Schema ( ) ; String table Name = table Meta . get Table Name ( ) ; temp Table . set Table Name ( generate Temp Table Name ( table Schema , table Name ) ) ; List < Field Schema > temp Columns = new Array List < Field Schema > ( ) ; List < Column Info > columns = table Meta . get Columns ( ) ; for ( Column Info column : columns ) { Field Schema temp Column = new Field Schema ( ) ; temp Column . set Name ( column . get Name ( ) ) ; temp Column . set Type ( to ODPS Data Type ( column . get Data Type ( ) ) ) ; temp Column . set Comment ( column . get Comment ( ) ) ; temp Columns . add ( temp Column ) ; } temp Table . set Cols ( temp Columns ) ; temp Table . set Partition Keys ( null ) ; return temp Table ; }
public static String last ( String list , char delimiter ) { int len = list . length ( ) ; if ( len == NUM ) return STRING ; int index = NUM ; while ( BOOL ) { index = list . last Index Of ( delimiter ) ; if ( index == - NUM ) { return list ; } else if ( index + NUM == len ) { list = list . substring ( NUM , len - NUM ) ; len -- ; } else { return list . substring ( index + NUM ) ; } } }
private void apply Layout ( ) { layout Panel . commit Changes ( ) ; neuron Group . set Layout ( layout Panel . get Current Layout ( ) ) ; neuron Group . apply Layout ( ) ; }
private void determine Global Extremum Type ( ) { final double f = function ( alpha Extremum ) ; double [ ] alpha 1 = new double [ alpha Extremum . length ] ; double [ ] alpha 2 = new double [ alpha Extremum . length ] ; for ( int i = NUM ; i < alpha Extremum . length ; i ++ ) { alpha 1 [ i ] = Math . random ( ) * Math . PI ; alpha 2 [ i ] = Math . random ( ) * Math . PI ; } double f1 = function ( alpha 1 ) ; double f2 = function ( alpha 2 ) ; if ( f1 < f && f2 < f ) { extremum Type = Extremum Type . MAXIMUM ; } else if ( f1 > f && f2 > f ) { extremum Type = Extremum Type . MINIMUM ; } else if ( Math . abs ( f1 - f ) < DELTA && Math . abs ( f2 - f ) < DELTA ) { extremum Type = Extremum Type . CONSTANT ; } else { throw new Illegal State Exception ( STRING + STRING + this + STRING + Format Util . format ( alpha Extremum ) + STRING + f + STRING + f1 + STRING + f2 ) ; } }
public static Method find Instance Method ( Class < ? > type , String name , Class < ? > ... args ) throws No Such Method Exception { Method method = find Method ( type , name , args ) ; if ( Modifier . is Static ( method . get Modifiers ( ) ) ) { throw new No Such Method Exception ( STRING + name + STRING ) ; } return method ; }
private void fetch Search Service Cards From Server ( String keyword ) { final Map < String , String > params = new Hash Map < String , String > ( NUM ) ; params . put ( Http Constants . LATITUDE , Shared Preference Helper . get String ( R . string . pref latitude ) ) ; params . put ( Http Constants . LONGITUDE , Shared Preference Helper . get String ( R . string . pref longitude ) ) ; params . put ( Http Constants . TYPE , Http Constants . Search Type . SERVICE CARD ) ; params . put ( Http Constants . PER , STRING ) ; params . put ( Http Constants . RADIUS , STRING ) ; params . put ( Http Constants . TITLE , keyword ) ; Retro Callback retro Callback ; retro Callback = new Retro Callback ( this ) ; retro Callback . set Request Id ( Http Constants . Api Response Codes . SEARCH SERVICES ) ; retro Callback List . add ( retro Callback ) ; params . put ( Http Constants . PAGE , STRING ) ; m Yelo Api . get Service Cards ( params , retro Callback ) ; m Swipe Refresh Layout . set Refreshing ( BOOL ) ; }
private String number To National ( String number ) { final Phone Number Util util = Phone Number Util . get Instance ( ) ; try { final Phonenumber . Phone Number phone Number = util . parse ( number , m Country Code ) ; return String . value Of ( phone Number . get National Number ( ) ) ; } catch ( Number Parse Exception e ) { return STRING ; } }
public static final String digits And Plus Only ( Matcher Compat matcher ) { String Builder buffer = new String Builder ( ) ; String matching Region = matcher . group ( ) ; for ( int i = NUM , size = matching Region . length ( ) ; i < size ; i ++ ) { char character = matching Region . char At ( i ) ; if ( character == STRING || Character . is Digit ( character ) ) { buffer . append ( character ) ; } } return buffer . to String ( ) ; }
static boolean objects Equality ( Object a , Object b ) { if ( a == null ) return b == null ; if ( a == b ) return BOOL ; return ( a . equals ( b ) ) ; }
private int find Marker Segment Position ( Class cls , boolean first ) { if ( first ) { List Iterator iter = marker Sequence . list Iterator ( ) ; for ( int i = NUM ; iter . has Next ( ) ; i ++ ) { Marker Segment seg = ( Marker Segment ) iter . next ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } else { List Iterator iter = marker Sequence . list Iterator ( marker Sequence . size ( ) ) ; for ( int i = marker Sequence . size ( ) - NUM ; iter . has Previous ( ) ; i -- ) { Marker Segment seg = ( Marker Segment ) iter . previous ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } return - NUM ; }
protected < V > V parse Json ( Input Stream stream , Type type , Type list Type ) throws IO Exception { Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( stream , CHARSET UTF 8 ) , buffer Size ) ; if ( list Type == null ) try { return gson . from Json ( reader , type ) ; } catch ( Json Parse Exception jpe ) { L . e ( jpe ) ; IO Exception ioe = new IO Exception ( STRING ) ; ioe . init Cause ( jpe ) ; throw ioe ; } finally { try { reader . close ( ) ; } catch ( IO Exception ignored ) { } } else { Json Reader json Reader = new Json Reader ( reader ) ; try { if ( json Reader . peek ( ) == BEGIN ARRAY ) return gson . from Json ( json Reader , list Type ) ; else return gson . from Json ( json Reader , type ) ; } catch ( Json Parse Exception jpe ) { L . e ( jpe ) ; IO Exception ioe = new IO Exception ( STRING ) ; ioe . init Cause ( jpe ) ; throw ioe ; } finally { try { json Reader . close ( ) ; } catch ( IO Exception ignored ) { } } } }
public Publisher Concat Array < T > concat Additional Source Last ( Publisher < ? extends T > source ) { int n = array . length ; @ Suppress Warnings ( STRING ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , n ) ; new Array [ n ] = source ; return new Publisher Concat Array < > ( delay Error , new Array ) ; }
Binary Class load File ( Class File file ) throws IO Exception { long tm = System . current Time Millis ( ) ; Input Stream input = file . get Input Stream ( ) ; Binary Class c = null ; if ( tracing ) dt Enter ( STRING + file ) ; try { Data Input Stream is = new Data Input Stream ( new Buffered Input Stream ( input ) ) ; c = Binary Class . load ( new Environment ( this , file ) , is , load File Flags ( ) ) ; } catch ( Class Format Error e ) { error ( NUM , STRING , file . get Path ( ) , e . get Message ( ) ) ; if ( tracing ) dt Exit ( STRING + file ) ; return null ; } catch ( java . io . EOF Exception e ) { error ( NUM , STRING , file . get Path ( ) ) ; return null ; } input . close ( ) ; if ( verbose ( ) ) { tm = System . current Time Millis ( ) - tm ; output ( Main . get Text ( STRING , file . get Path ( ) , Long . to String ( tm ) ) ) ; } if ( tracing ) dt Exit ( STRING + file ) ; return c ; }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case S Runtime Package . EXECUTION SLOT VALUE : return VALUE EDEFAULT == null ? value != null : ! VALUE EDEFAULT . equals ( value ) ; case S Runtime Package . EXECUTION SLOT FQ NAME : return FQ NAME EDEFAULT == null ? fq Name != null : ! FQ NAME EDEFAULT . equals ( fq Name ) ; case S Runtime Package . EXECUTION SLOT WRITABLE : return writable != WRITABLE EDEFAULT ; case S Runtime Package . EXECUTION SLOT TYPE : return type != null ; } return super . e Is Set ( feature ID ) ; }
protected void parse URI ( String uri String ) throws URI Syntax Exception { String s = uri String ; int index = s . index Of ( FRAGMENT SEPARATOR ) ; if ( index != - NUM ) { set Fragment ( s . substring ( index + NUM ) , BOOL ) ; s = s . substring ( NUM , index ) ; } index = s . index Of ( SCHEME SEPARATOR ) ; if ( index != - NUM ) { String scheme = s . substring ( NUM , index ) ; if ( is Valid Scheme ( scheme ) ) { set Scheme ( scheme ) ; s = s . substring ( index + NUM ) ; } } parse Scheme Specific Part ( s , BOOL ) ; }
public Policy Constraints Extension ( Boolean critical , Object value ) throws IO Exception { this . extension Id = PKIX Extensions . Policy Constraints Id ; this . critical = critical . boolean Value ( ) ; this . extension Value = ( byte [ ] ) value ; Der Value val = new Der Value ( this . extension Value ) ; if ( val . tag != Der Value . tag Sequence ) { throw new IO Exception ( STRING ) ; } Der Input Stream in = val . data ; while ( in != null && in . available ( ) != NUM ) { Der Value next = in . get Der Value ( ) ; if ( next . is Context Specific ( TAG REQUIRE ) && ! next . is Constructed ( ) ) { if ( this . require != - NUM ) throw new IO Exception ( STRING + STRING ) ; next . reset Tag ( Der Value . tag Integer ) ; this . require = next . get Integer ( ) ; } else if ( next . is Context Specific ( TAG INHIBIT ) && ! next . is Constructed ( ) ) { if ( this . inhibit != - NUM ) throw new IO Exception ( STRING + STRING ) ; next . reset Tag ( Der Value . tag Integer ) ; this . inhibit = next . get Integer ( ) ; } else throw new IO Exception ( STRING ) ; } }
public static Secret Key generate Key ( String algorithm ) throws Encoding Exception { try { Key Generator kgen = Key Generator . get Instance ( algorithm ) ; kgen . init ( NUM ) ; Secret Key key = kgen . generate Key ( ) ; return key ; } catch ( Exception e ) { throw new Encoding Exception ( e ) ; } }
@ Override public void property Change ( java . beans . Property Change Event e ) { log . debug ( STRING + e . get Property Name ( ) + STRING + e . get Old Value ( ) + STRING + e . get New Value ( ) ) ; }
public Spy Versions load Versions ( ) throws XML Exception { set Loading ( BOOL ) ; try { final URL url = new URL ( property Loader . get Property ( Base Property Names . VERSION INFO URL ) ) ; versions = ( Spy Versions ) load From Input Stream ( url . open Stream ( ) ) ; } catch ( IO Exception | Null Pointer Exception e ) { throw new XML Exception ( STRING + property Loader . get Property ( Base Property Names . VERSION INFO URL ) , e ) ; } set Loading ( BOOL ) ; return versions ; }
@ Request Mapping ( value = STRING , method = POST , produces = APPLICATION JSON VALUE ) public Response Entity < Page Response < Role DTO > > find All ( @ Request Body Page Request By Example < Role DTO > prbe ) throws URI Syntax Exception { Page Response < Role DTO > page Response = role DTO Service . find All ( prbe ) ; return new Response Entity < > ( page Response , new Http Headers ( ) , Http Status . OK ) ; }
public void add Footer View ( View view ) { m Footer Views . add ( view ) ; }
public void component ( int M Product ID ) throws Exception { if ( p implosion ) { Level No += NUM ; Prepared Statement stmt = null ; Result Set rs = null ; String sql = STRING + STRING ; try { stmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; stmt . set Int ( NUM , M Product ID ) ; rs = stmt . execute Query ( ) ; while ( rs . next ( ) ) { parent Implotion ( rs . get Int ( NUM ) ) ; } rs . close ( ) ; stmt . close ( ) ; Level No -= NUM ; return ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , e . get Localized Message ( ) + sql , e ) ; throw new Exception ( STRING + e . get Localized Message ( ) ) ; } finally { DB . close ( rs , stmt ) ; rs = null ; stmt = null ; } } else { String sql = STRING + STRING ; Prepared Statement stmt = null ; Result Set rs = null ; try { String Value = DB . get SQL Value String ( get Trx Name ( ) , STRING , M Product ID ) ; if ( Value == null ) { throw new Exception ( C Logger . retrieve Error String ( STRING ) ) ; } stmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; stmt . set String ( NUM , Value ) ; rs = stmt . execute Query ( ) ; boolean level = BOOL ; while ( rs . next ( ) ) { if ( ! level ) Level No += NUM ; level = BOOL ; parent Explotion ( rs . get Int ( NUM ) ) ; Level No -= NUM ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , e . get Localized Message ( ) + sql , e ) ; throw new Exception ( STRING + e . get Localized Message ( ) ) ; } finally { DB . close ( rs , stmt ) ; rs = null ; stmt = null ; } } return ; }
public void test Recovered Handled Dropped Offer ( ) { Atomic Integer calls = new Atomic Integer ( ) ; Submission Publisher < Integer > p = new Submission Publisher < Integer > ( basic Executor , NUM ) ; Test Subscriber s1 = new Test Subscriber ( ) ; s1 . request = BOOL ; Test Subscriber s2 = new Test Subscriber ( ) ; s2 . request = BOOL ; p . subscribe ( s1 ) ; p . subscribe ( s2 ) ; s2 . await Subscribe ( ) ; s1 . await Subscribe ( ) ; int n = NUM ; for ( int i = NUM ; i <= NUM ; ++ i ) { int d = p . offer ( i , null ) ; n = n + NUM + ( d < NUM ? d : NUM ) ; } p . close ( ) ; s2 . await Complete ( ) ; s1 . await Complete ( ) ; assert Equals ( n , s1 . nexts + s2 . nexts ) ; assert True ( calls . get ( ) >= NUM ) ; }
public Sequences Writer ( Sequence Data Source source , File output Dir , long size Limit , Collection < String > names To Exclude , Preread Type type , boolean compressed , Integer trim Quality Threshold ) { m Data Source = source ; m Output Dir = output Dir ; m Preread Type = type ; m Sdf Id = new Sdf Id ( ) ; if ( m Data Source == null ) { throw new Null Pointer Exception ( STRING ) ; } File Utils . ensure Output Directory ( m Output Dir ) ; m Size Limit = size Limit ; m Names To Exclude = names To Exclude == null ? new Array List < > ( ) : names To Exclude ; m Compressed = compressed ; if ( trim Quality Threshold != null ) { if ( System . get Property ( STRING ) != null ) { final int window Size = Integer . parse Int ( System . get Property ( STRING ) ) ; m Read Trimmer = new Default Read Trimmer ( window Size , trim Quality Threshold ) ; Diagnostic . user Log ( STRING + trim Quality Threshold + STRING + window Size ) ; } else { m Read Trimmer = new Best Sum Read Trimmer ( trim Quality Threshold ) ; Diagnostic . user Log ( STRING + trim Quality Threshold ) ; } } else { m Read Trimmer = new Null Read Trimmer ( ) ; } }
public void display Message And Usage Reference ( final Print Stream print Stream , final Localizable Message message ) { print Wrapped Text ( print Stream , message ) ; print Stream . println ( ) ; print Wrapped Text ( print Stream , get Help Usage Reference ( ) ) ; }
private int test In Range ( long actual , long expected , long epsilon ) { long min = expected - epsilon ; long max = expected + epsilon ; return actual < min ? - NUM : actual > max ? NUM : NUM ; }
public Spider Html Parser ( Spider Param params ) { super ( ) ; if ( params == null ) { throw new Illegal Argument Exception ( STRING ) ; } this . params = params ; }
public void print ( boolean x ) { out . print ( x ) ; out . flush ( ) ; }
public static void add Entity ( Sim Entity e ) { Sim Event evt ; if ( running ) { evt = new Sim Event ( Sim Event . CREATE , clock , NUM , NUM , NUM , e ) ; future . add Event ( evt ) ; } if ( e . get Id ( ) == - NUM ) { int id = entities . size ( ) ; e . set Id ( id ) ; entities . add ( e ) ; entities By Name . put ( e . get Name ( ) , e ) ; } }
protected boolean [ ] dataset Integrity ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type , boolean predictor Missing , boolean class Missing ) { print ( STRING ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STRING ) ; int num Train = get Num Instances ( ) , num Test = get Num Instances ( ) , num Classes = NUM , missing Level = NUM ; boolean [ ] result = new boolean [ NUM ] ; Instances train = null ; Instances test = null ; Classifier classifier = null ; Evaluation evaluation = null ; boolean built = BOOL ; try { train = make Test Dataset ( NUM , num Train , nominal Predictor ? get Num Nominal ( ) : NUM , numeric Predictor ? get Num Numeric ( ) : NUM , string Predictor ? get Num String ( ) : NUM , date Predictor ? get Num Date ( ) : NUM , relational Predictor ? get Num Relational ( ) : NUM , num Classes , class Type , multi Instance ) ; test = make Test Dataset ( NUM , num Test , nominal Predictor ? get Num Nominal ( ) : NUM , numeric Predictor ? get Num Numeric ( ) : NUM , string Predictor ? get Num String ( ) : NUM , date Predictor ? get Num Date ( ) : NUM , relational Predictor ? get Num Relational ( ) : NUM , num Classes , class Type , multi Instance ) ; if ( missing Level > NUM ) { add Missing ( train , missing Level , predictor Missing , class Missing ) ; add Missing ( test , Math . min ( missing Level , NUM ) , predictor Missing , class Missing ) ; } classifier = Abstract Classifier . make Copies ( get Classifier ( ) , NUM ) [ NUM ] ; evaluation = new Evaluation ( train ) ; } catch ( Exception ex ) { throw new Error ( STRING + ex . get Message ( ) ) ; } try { Instances train Copy = new Instances ( train ) ; Instances test Copy = new Instances ( test ) ; classifier . build Classifier ( train Copy ) ; compare Datasets ( train , train Copy ) ; built = BOOL ; test WRT Zero R ( classifier , evaluation , train Copy , test Copy ) ; compare Datasets ( test , test Copy ) ; println ( STRING ) ; result [ NUM ] = BOOL ; } catch ( Exception ex ) { println ( STRING ) ; result [ NUM ] = BOOL ; if ( m Debug ) { println ( STRING ) ; print ( STRING ) ; if ( built ) { print ( STRING ) ; } else { print ( STRING ) ; } println ( STRING + ex . get Message ( ) + STRING ) ; println ( STRING ) ; println ( STRING + train . to String ( ) + STRING ) ; println ( STRING + test . to String ( ) + STRING ) ; } } return result ; }
public Remote Interpreter Event poll Event ( ) { synchronized ( event Queue ) { if ( event Queue . is Empty ( ) ) { try { event Queue . wait ( NUM ) ; } catch ( Interrupted Exception e ) { } } if ( event Queue . is Empty ( ) ) { return new Remote Interpreter Event ( Remote Interpreter Event Type . NO OP , STRING ) ; } else { Remote Interpreter Event event = event Queue . remove ( NUM ) ; logger . debug ( STRING , event . get Type ( ) ) ; return event ; } } }
private Variable Reference add Primitive ( Test Case test , Primitive Statement < ? > old , int position ) throws Construction Failed Exception { logger . debug ( STRING ) ; Statement st = old . clone ( test ) ; return test . add Statement ( st , position ) ; }
private void debug Segment Entries ( Write Stream out , Read Stream is , Segment Extent extent , Table Entry table ) throws IO Exception { Temp Buffer t Buf = Temp Buffer . create ( ) ; byte [ ] buffer = t Buf . buffer ( ) ; for ( long ptr = extent . length ( ) - BLOCK SIZE ; ptr > NUM ; ptr -= BLOCK SIZE ) { is . position ( ptr ) ; is . read All ( buffer , NUM , BLOCK SIZE ) ; long seq = Bits Util . read Long ( buffer , NUM ) ; int head = NUM ; byte [ ] table Key = new byte [ NUM ] ; System . arraycopy ( buffer , head , table Key , NUM , table Key . length ) ; is . read All ( table Key , NUM , table Key . length ) ; head += table Key . length ; int offset = BLOCK SIZE - NUM ; int tail = Bits Util . read Int 16 ( buffer , offset ) ; offset += NUM ; boolean is Cont = buffer [ offset ] == NUM ; if ( seq <= NUM || tail <= NUM ) { return ; } while ( ( head = debug Segment Index ( out , is , buffer , extent . address ( ) , ptr , head , table ) ) < tail ) { } if ( ! is Cont ) { break ; } } }
public static void test VNX 2 Net Alloc Assign ( Map < URI , List < Initiator > > net 2 Initiators Map A , Map < URI , List < Initiator > > net 2 Initiators Map B , Map < URI , List < Initiator > > net 2 Initiators Map C , Map < URI , List < Initiator > > net 2 Initiators Map D , int max Paths , int min Paths , int paths Per Initiator , int initiators Per Port ) throws Exception { Map < URI , Map < URI , List < Initiator > > > host To Net To Initiators Map = new Hash Map < URI , Map < URI , List < Initiator > > > ( ) ; URI host A = get Host URI ( net 2 Initiators Map A ) ; host To Net To Initiators Map . put ( host A , net 2 Initiators Map A ) ; if ( net 2 Initiators Map B != null ) { URI host B = get Host URI ( net 2 Initiators Map B ) ; host To Net To Initiators Map . put ( host B , net 2 Initiators Map B ) ; } if ( net 2 Initiators Map C != null ) { URI host C = get Host URI ( net 2 Initiators Map C ) ; host To Net To Initiators Map . put ( host C , net 2 Initiators Map C ) ; } if ( net 2 Initiators Map D != null ) { URI host D = get Host URI ( net 2 Initiators Map D ) ; host To Net To Initiators Map . put ( host D , net 2 Initiators Map D ) ; } Port Allocation Context net 1 ctx = create VNX Net 1 ( ) ; Port Allocation Context net 2 ctx = create VNX Net 2 ( ) ; Port Allocation Context [ ] contexts = new Port Allocation Context [ ] { net 1 ctx , net 2 ctx } ; test Allocation Assignment ( contexts , host To Net To Initiators Map , max Paths , min Paths , paths Per Initiator , initiators Per Port , STRING , null ) ; }
protected void process Converts ( List < Convert Metadata > converts , Database Mapping mapping , Metadata Class reference Class , boolean is For Map Key ) { if ( converts != null ) { for ( Convert Metadata convert : converts ) { convert . process ( mapping , reference Class , get Class Accessor ( ) , is For Map Key ) ; } } }
protected void end Prefix Mapping ( Namespace Stack stack , int stack Size ) throws SAX Exception { while ( stack . size ( ) > stack Size ) { Namespace namespace = stack . pop ( ) ; if ( namespace != null ) { content Handler . end Prefix Mapping ( namespace . get Prefix ( ) ) ; } } }
public static boolean contains ( Data Flavor [ ] array , Data Flavor flavor ) { for ( int i = NUM ; i < array . length ; i ++ ) { if ( flavor . equals ( array [ i ] ) ) { return BOOL ; } } return BOOL ; }
public void test Choice Missing Icon Error Handling ( ) { String xml = STRING ; xml += create Start Mission Xml ( STRING , STRING ) ; xml += create Start Choice Moment Xml ( STRING , NUM , STRING , STRING ) ; xml += create Choice Xml ( STRING , STRING , STRING , BOOL , BOOL , STRING ) ; xml += create Choice Xml ( STRING , STRING , STRING , BOOL , BOOL , null ) ; xml += create End Choice Moment Xml ( ) ; xml += create End Mission Xml ( ) ; Utils . log Debug ( TAG , xml ) ; Input Stream moment Input Stream = new Byte Array Input Stream ( xml . get Bytes ( ) ) ; m Mission = new Mission ( m Mission Data ) ; boolean did Mission Parse Fail = BOOL ; try { m Mission . read Moments ( moment Input Stream ) ; } catch ( Mission Parse Exception e ) { e . print Stack Trace ( ) ; did Mission Parse Fail = BOOL ; } Assert . assert Equals ( BOOL , did Mission Parse Fail ) ; }
String decompile ( int indent , int flags ) { String Buffer sb = new String Buffer ( ) ; boolean justbody = ( NUM != ( flags & Decompiler . ONLY BODY FLAG ) ) ; if ( ! justbody ) { sb . append ( STRING ) ; sb . append ( get Function Name ( ) ) ; sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( get Arity ( ) ) ; sb . append ( STRING ) ; if ( ! justbody ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
public int register ( Advice advice ) { int advice Id = advice Id Seed . get And Increment ( ) ; Active Instances current , next ; do { current = active . get ( ) ; next = current . add ( advice , advice Id ) ; } while ( ! active . compare And Set ( current , next ) ) ; return advice Id ; }
private void fill Field Values ( ) { if ( is Creation Panel ) { phrase . set Text ( STRING + Speech . DEFAULT PHRASE ) ; threshold . set Text ( STRING + Speech . DEFAULT THRESHOLD ) ; } else { phrase . set Text ( STRING + speech Effector . get Phrase ( ) ) ; threshold . set Text ( STRING + speech Effector . get Threshold ( ) ) ; } }
public void connect ( Socket Address endpoint , int timeout ) throws IO Exception { if ( endpoint == null ) throw new Illegal Argument Exception ( STRING ) ; if ( timeout < NUM ) throw new Illegal Argument Exception ( STRING ) ; if ( is Closed ( ) ) throw new Socket Exception ( STRING ) ; if ( ! old Impl && is Connected ( ) ) throw new Socket Exception ( STRING ) ; if ( ! ( endpoint instanceof Inet Socket Address ) ) throw new Illegal Argument Exception ( STRING ) ; Inet Socket Address epoint = ( Inet Socket Address ) endpoint ; Inet Address addr = epoint . get Address ( ) ; int port = epoint . get Port ( ) ; check Address ( addr , STRING ) ; Security Manager security = System . get Security Manager ( ) ; if ( security != null ) { if ( epoint . is Unresolved ( ) ) security . check Connect ( epoint . get Host Name ( ) , port ) ; else security . check Connect ( addr . get Host Address ( ) , port ) ; } if ( ! created ) create Impl ( BOOL ) ; if ( ! old Impl ) impl . connect ( epoint , timeout ) ; else if ( timeout == NUM ) { if ( epoint . is Unresolved ( ) ) impl . connect ( addr . get Host Name ( ) , port ) ; else impl . connect ( addr , port ) ; } else throw new Unsupported Operation Exception ( STRING ) ; connected = BOOL ; bound = BOOL ; }
public boolean retain All ( Abstract Long List other ) { if ( other . size ( ) == NUM ) { if ( size == NUM ) return BOOL ; set Size ( NUM ) ; return BOOL ; } int limit = other . size ( ) - NUM ; int j = NUM ; for ( int i = NUM ; i < size ; i ++ ) { if ( other . index Of From To ( get Quick ( i ) , NUM , limit ) >= NUM ) set Quick ( j ++ , get Quick ( i ) ) ; } boolean modified = ( j != size ) ; set Size ( j ) ; return modified ; }
public static Array List < Byte > byte Array To Array List ( byte [ ] byte Array , int offset ) { Array List < Byte > list = new Array List < Byte > ( byte Array . length ) ; for ( int i = offset ; i < byte Array . length ; i ++ ) { list . add ( Byte . value Of ( byte Array [ i ] ) ) ; } return list ; }
public synchronized Future < ? > add Indexed Column ( Column Definition cdef ) { if ( indexes By Column . contains Key ( cdef . name . bytes ) ) return null ; assert cdef . get Index Type ( ) != null ; Secondary Index index = Secondary Index . create Instance ( base Cfs , cdef ) ; if ( index instanceof Per Row Secondary Index ) { Secondary Index current Index = row Level Index Map . get ( index . get Class ( ) ) ; if ( current Index == null ) { row Level Index Map . put ( index . get Class ( ) , index ) ; index . init ( ) ; } else { index = current Index ; index . add Column Def ( cdef ) ; logger . info ( STRING , cdef ) ; } } else { if ( cdef . get Index Type ( ) == Index Type . CUSTOM && index instanceof Abstract Simple Per Column Secondary Index ) throw new Runtime Exception ( STRING ) ; index . init ( ) ; } indexes By Column . put ( cdef . name . bytes , index ) ; indexes By Name . put ( index . get Index Name ( ) , index ) ; return index . build Index Async ( ) ; }
public Builder with Key Store Path ( String key Store Path ) { properties . set Property ( Netty Options . SSL KEY STORE PATH , Assert . not Null ( key Store Path , STRING ) ) ; return this ; }
public Distributed Data Manager Impl ( Zk Connection conn , String base Path , long max Nodes ) { zk Client = conn . curator ( ) ; if ( String Utils . is Empty ( base Path ) || ! base Path . starts With ( STRING ) || ( base Path . length ( ) < NUM ) || base Path . ends With ( STRING ) ) { throw new Illegal Argument Exception ( STRING ) ; } base Path = base Path ; max Nodes = max Nodes ; log . info ( STRING , base Path , max Nodes ) ; ensure Cache Started ( ) ; }
private static String extract Shortcut ( String pattern ) { char [ ] wildcard Chars = new char [ ] { STRING , STRING } ; int start Index = NUM ; int end Index = String Utils . index Of Any ( pattern , wildcard Chars ) ; if ( end Index < NUM ) { return pattern ; } String shortcut = end Index == start Index ? String Utils . EMPTY : pattern . substring ( start Index , end Index - start Index ) ; while ( end Index >= NUM ) { start Index = start Index + end Index + NUM ; if ( pattern . length ( ) <= start Index ) { break ; } end Index = String Utils . index Of Any ( pattern . substring ( start Index ) , wildcard Chars ) ; String tmp Shortcut = end Index < NUM ? pattern . substring ( start Index ) : pattern . substring ( start Index , end Index + start Index ) ; if ( tmp Shortcut . length ( ) > shortcut . length ( ) ) { shortcut = tmp Shortcut ; } } return shortcut ; }
public void clean Result ( ) { cons G . clear ( ) ; pointers . clear ( ) ; allocations . clear ( ) ; constraints . clear ( ) ; func 2 int . clear ( ) ; int 2 func . clear ( ) ; edge Mapping . clear ( ) ; has Transformed = BOOL ; has Executed = BOOL ; System . gc ( ) ; System . gc ( ) ; System . gc ( ) ; System . gc ( ) ; }
private Node delete ( Node x , Key key ) { int cmp = key . compare To ( x . key ) ; if ( cmp < NUM ) { x . left = delete ( x . left , key ) ; } else if ( cmp > NUM ) { x . right = delete ( x . right , key ) ; } else { if ( x . left == null ) { return x . right ; } else if ( x . right == null ) { return x . left ; } else { Node y = x ; x = min ( y . right ) ; x . right = delete Min ( y . right ) ; x . left = y . left ; } } x . size = NUM + size ( x . left ) + size ( x . right ) ; x . height = NUM + Math . max ( height ( x . left ) , height ( x . right ) ) ; return balance ( x ) ; }
public static void statistics ( ) { String Buffer line = new String Buffer ( errors + STRING ) ; if ( errors != NUM ) line . append ( STRING ) ; line . append ( STRING + warnings + STRING ) ; if ( warnings != NUM ) line . append ( STRING ) ; line . append ( STRING ) ; err ( line . to String ( ) ) ; }
public static void copy ( String source , String target ) { Input Stream in = null ; Output Stream out = null ; try { in = new Buffered Input Stream ( new File Input Stream ( source ) ) ; out = new Buffered Output Stream ( new File Output Stream ( target ) ) ; for ( int c = read ( in ) ; c != - NUM ; c = read ( in ) ) { write ( out , c ) ; } } catch ( File Not Found Exception e ) { throw new Runtime Exception ( e . get Message ( ) , e ) ; } finally { close ( in ) ; close ( out ) ; } close ( in ) ; close ( out ) ; }
private static boolean contains Anno Of Type ( List < Attribute . Compound > annos , Type type ) { for ( Attribute . Compound anno : annos ) { if ( anno . type . tsym == type . tsym ) return BOOL ; } return BOOL ; }
private void stop Timer ( Timer timer ) { if ( timer != null && timer . is Running ( ) ) { timer . stop ( ) ; } }
@ Override public int compare To ( Entrant o ) { if ( place > o . place ) { return NUM ; } else if ( place < o . place ) { return - NUM ; } return name . compare To ( o . name ) ; }
public void add Property Change Listener ( Property Change Listener listener ) { if ( property Change Support == null ) { property Change Support = new Property Change Support ( this ) ; } property Change Support . add Property Change Listener ( listener ) ; }
public void add Data ( double [ ] hist Data , Integer index ) { data . remove ( index . int Value ( ) ) ; data . add ( index . int Value ( ) , hist Data ) ; redraw ( ) ; }
private void connect ( final String database Url , final Properties properties ) throws SQL Exception { if ( m connection != null ) { close Connection ( ) ; } try { m connection = Driver Manager . get Connection ( database Url , properties ) ; } catch ( final SQL Exception exception ) { Navi Logger . severe ( STRING , exception ) ; throw exception ; } }
public Bayes Estimator Editor ( Bayes Estimator Wrapper bayes Est Wrapper ) { this ( bayes Est Wrapper . get Estimated Bayes Im ( ) , bayes Est Wrapper . get Data Set ( ) ) ; }
public void remove Action Listener ( Action Listener al ) { if ( back Button != null && forward Button != null ) { back Button . remove Action Listener ( al ) ; forward Button . remove Action Listener ( al ) ; } else if ( listeners != null ) { listeners . remove ( al ) ; } }
public String remove Mask ( String mask , String value ) { if ( mask == null || value == null ) { return null ; } value = apply Mask ( mask , value ) ; String new Value = STRING ; Integer is In Mask = NUM ; Integer index = NUM ; for ( Integer i = NUM ; i < mask . length ( ) ; i ++ ) { Character mask Character = mask . char At ( i ) ; if ( mask Character . equals ( STRING ) ) { is In Mask -- ; } else if ( mask Character . equals ( STRING ) ) { is In Mask ++ ; } else { if ( is In Mask == NUM ) { if ( index >= value . length ( ) ) { break ; } new Value += value . char At ( index ) ; } index ++ ; } } return new Value ; }
protected Granularity generate Granularity ( @ Not Null String granularity , @ Not Null Date Time Zone date Time Zone , @ Not Null Granularity Parser granularity Parser ) throws Bad Api Request Exception { try { return granularity Parser . parse Granularity ( granularity , date Time Zone ) ; } catch ( Granularity Parse Exception e ) { LOG . error ( UNKNOWN GRANULARITY . log Format ( granularity ) , granularity ) ; throw new Bad Api Request Exception ( e . get Message ( ) ) ; } }
public Word Iterator ( Locale locale ) { m Iterator = Break Iterator . get Word Instance ( locale ) ; }
void save Resource Index ( String resource Type , String index XML ) throws Policy Exception , SSO Exception { Map new Attrs = new Hash Map ( ) ; Set new Set = new Hash Set ( ) ; new Set . add ( index XML ) ; new Attrs . put ( RESOURCES XML , new Set ) ; Service Config resources = get Resources Service Config ( BOOL ) ; if ( resources != null ) { Service Config leaf Config = null ; try { leaf Config = resources . get Sub Config ( resource Type ) ; if ( leaf Config == null ) { resources . add Sub Config ( resource Type , Policy Manager . RESOURCES POLICY ID , NUM , new Attrs ) ; } else { leaf Config . set Attributes ( new Attrs ) ; } } catch ( SMS Exception e1 ) { throw new Policy Exception ( e1 ) ; } } }
private void do Pull File ( String remote Path , String local Path , I Sync Progress Monitor monitor ) throws IO Exception , Sync Exception , Timeout Exception { byte [ ] msg ; byte [ ] pull Result = new byte [ NUM ] ; final int time Out = Ddm Preferences . get Time Out ( ) ; try { byte [ ] remote Path Content = remote Path . get Bytes ( Adb Helper . DEFAULT ENCODING ) ; if ( remote Path Content . length > REMOTE PATH MAX LENGTH ) { throw new Sync Exception ( Sync Error . REMOTE PATH LENGTH ) ; } msg = create File Req ( ID RECV , remote Path Content ) ; Adb Helper . write ( m Channel , msg , - NUM , time Out ) ; Adb Helper . read ( m Channel , pull Result , - NUM , time Out ) ; if ( ! check Result ( pull Result , ID DATA ) && ! check Result ( pull Result , ID DONE ) ) { throw new Sync Exception ( Sync Error . TRANSFER PROTOCOL ERROR , read Error Message ( pull Result , time Out ) ) ; } } catch ( Unsupported Encoding Exception e ) { throw new Sync Exception ( Sync Error . REMOTE PATH ENCODING , e ) ; } File f = new File ( local Path ) ; try ( File Output Stream fos = new File Output Stream ( f ) ) { byte [ ] data = new byte [ SYNC DATA MAX ] ; while ( BOOL ) { if ( monitor . is Canceled ( ) ) { throw new Sync Exception ( Sync Error . CANCELED ) ; } if ( check Result ( pull Result , ID DONE ) ) { break ; } if ( ! check Result ( pull Result , ID DATA ) ) { throw new Sync Exception ( Sync Error . TRANSFER PROTOCOL ERROR , read Error Message ( pull Result , time Out ) ) ; } int length = Array Helper . swap 32 bit From Array ( pull Result , NUM ) ; if ( length > SYNC DATA MAX ) { throw new Sync Exception ( Sync Error . BUFFER OVERRUN ) ; } Adb Helper . read ( m Channel , data , length , time Out ) ; Adb Helper . read ( m Channel , pull Result , - NUM , time Out ) ; fos . write ( data , NUM , length ) ; monitor . advance ( length ) ; } fos . flush ( ) ; } catch ( IO Exception e ) { Log . e ( STRING , String . format ( STRING , f . get Absolute Path ( ) , e . to String ( ) ) ) ; throw new Sync Exception ( Sync Error . FILE WRITE ERROR ) ; } }
private void map ( int seg , double a , double o , Point 2 D pt ) { double dx = data [ seg ] - data [ seg - NUM ] ; double dy = data [ seg + NUM ] - data [ seg - NUM ] ; double dl = data [ seg + NUM ] - data [ seg - NUM ] ; double ux = dx / dl ; double uy = dy / dl ; a -= data [ seg - NUM ] ; pt . set Location ( data [ seg - NUM ] + a * ux - o * uy , data [ seg - NUM ] + a * uy + o * ux ) ; }
public T File Index ( int entry Count , Data Input in , Bytes Comparator comparator ) throws IO Exception { index = new Array List < T File Index Entry > ( entry Count ) ; record Num Index = new Array List < Long > ( entry Count ) ; int size = Utils . read V Int ( in ) ; if ( size > NUM ) { byte [ ] buffer = new byte [ size ] ; in . read Fully ( buffer ) ; Data Input Stream first Key Input Stream = new Data Input Stream ( new Byte Array Input Stream ( buffer , NUM , size ) ) ; int first Key Length = Utils . read V Int ( first Key Input Stream ) ; first Key = new Byte Array ( new byte [ first Key Length ] ) ; first Key Input Stream . read Fully ( first Key . buffer ( ) ) ; for ( int i = NUM ; i < entry Count ; i ++ ) { size = Utils . read V Int ( in ) ; if ( buffer . length < size ) { buffer = new byte [ size ] ; } in . read Fully ( buffer , NUM , size ) ; T File Index Entry idx = new T File Index Entry ( new Data Input Stream ( new Byte Array Input Stream ( buffer , NUM , size ) ) ) ; index . add ( idx ) ; sum += idx . entries ( ) ; record Num Index . add ( sum ) ; } } else { if ( entry Count != NUM ) { throw new Runtime Exception ( STRING ) ; } } this . comparator = comparator ; }
public static Collection < File > list Files And Dirs ( File directory , IO File Filter file Filter , IO File Filter dir Filter ) { validate List Files Parameters ( directory , file Filter ) ; IO File Filter eff File Filter = set Up Effective File Filter ( file Filter ) ; IO File Filter eff Dir Filter = set Up Effective Dir Filter ( dir Filter ) ; Collection < File > files = new java . util . Linked List < File > ( ) ; if ( directory . is Directory ( ) ) { files . add ( directory ) ; } inner List Files ( files , directory , File Filter Utils . or ( eff File Filter , eff Dir Filter ) , BOOL ) ; return files ; }
public void remove Bandwidth ( String name ) { if ( name == null ) { throw new Null Pointer Exception ( STRING ) ; } else { int i = NUM ; for ( i = NUM ; i < bandwidth Fields . size ( ) ; i ++ ) { Bandwidth Field bandwidth Field = ( Bandwidth Field ) bandwidth Fields . element At ( i ) ; String type = bandwidth Field . get Bwtype ( ) ; if ( type != null && type . equals ( name ) ) break ; } if ( i < bandwidth Fields . size ( ) ) bandwidth Fields . remove Element At ( i ) ; } }
public static long now In Millis ( ) { return System . current Time Millis ( ) ; }
public static String Buffer string Substitution ( String arg Str , Map vars ) { String Buffer arg Buf = new String Buffer ( ) ; for ( int c Idx = NUM ; c Idx < arg Str . length ( ) ; ) { char ch = arg Str . char At ( c Idx ) ; switch ( ch ) { case STRING : String Buffer name Buf = new String Buffer ( ) ; for ( ++ c Idx ; c Idx < arg Str . length ( ) ; ++ c Idx ) { ch = arg Str . char At ( c Idx ) ; if ( ch == STRING || Character . is Letter Or Digit ( ch ) ) name Buf . append ( ch ) ; else break ; } if ( name Buf . length ( ) > NUM ) { String value = ( String ) vars . get ( name Buf . to String ( ) ) ; if ( value != null ) { arg Buf . append ( value ) ; } } break ; default : arg Buf . append ( ch ) ; ++ c Idx ; break ; } } return arg Buf ; }
public Trie Node find ( String suffix ) { Trie Node result ; Character c ; String new Suffix ; Trie Node child ; c = suffix . char At ( NUM ) ; new Suffix = suffix . substring ( NUM ) ; child = m Children . get ( c ) ; if ( child == null ) { result = null ; } else if ( new Suffix . length ( ) == NUM ) { result = child ; } else { result = child . find ( new Suffix ) ; } return result ; }
@ Override protected int eof Check ( EOF Exception e , int start , int index , int length ) throws EOF Exception { if ( start == index ) { throw e ; } else { return ( index - start ) * length ; } }
public Properties strip Prefix ( Properties props ) { Properties result = new Properties ( ) ; for ( String name : props . string Property Names ( ) ) { validate Namespaced ( name ) ; String val = props . get Property ( name ) ; name = strip Prefix ( name ) ; result . set Property ( name , val ) ; } return result ; }
public Inline Menu Row Builder < T > new Row ( ) { return new Inline Menu Row Builder < > ( instance ( ) , rows . size ( ) ) ; }
public void init ( String component Name ) throws Log Exception { access Logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( component Name + STRING ) ; error Logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( component Name + STRING ) ; try { msg Provider = Message Provider Factory . get Provider ( component Name ) ; } catch ( IO Exception e ) { debug . error ( STRING , e ) ; } }
@ Override public Json Object convert ( I Feature Renderer renderer ) { Representation Renderer representation Renderer = ( Representation Renderer ) renderer ; logger . info ( Representation Renderer Keys . REPRESENTATION RENDERER ) ; String value = null ; String reference Value = null ; int index = - NUM ; try { Json Object json Object = new Json Object ( ) ; Json Object renderer Object = new Json Object ( ) ; Json Array field Array = new Json Array ( ) ; I Name data Source Name = representation Renderer . get Data Source Name ( ) ; if ( data Source Name != null ) { renderer Object . add Property ( Representation Renderer Keys . DATA SOURCE NAME , data Source Name . get Name String ( ) ) ; } Json Object invalid Rule Colour = Common Objects . create Colour ( representation Renderer . get Invalid Rule Color ( ) ) ; if ( invalid Rule Colour != null ) { renderer Object . add ( Representation Renderer Keys . INVALID RULE COLOUR , invalid Rule Colour ) ; } Json Object invisible Rule Colour = Common Objects . create Colour ( representation Renderer . get Invisible Color ( ) ) ; if ( invisible Rule Colour != null ) { renderer Object . add ( Representation Renderer Keys . INVISIBLE RULE COLOUR , invisible Rule Colour ) ; } renderer Object . add Property ( Representation Renderer Keys . RELATIVE BASE , representation Renderer . get Relative Base ( ) ) ; Json Object representation Class Object = get Representation Class ( representation Renderer . get Representation Class ( ) ) ; if ( representation Class Object != null ) { renderer Object . add ( Representation Renderer Keys . REPRESENTATION CLASS , representation Class Object ) ; } for ( int field Index = NUM ; field Index < representation Renderer . get Field Count ( ) ; field Index ++ ) { Json Object json Value Object = new Json Object ( ) ; json Value Object . add Property ( Representation Renderer Keys . FIELD NAME , representation Renderer . get Field ( field Index ) ) ; I Table table = null ; json Value Object . add Property ( Representation Renderer Keys . WHERE CLAUSE , representation Renderer . get Where Clause ( field Index , table ) ) ; field Array . add ( json Value Object ) ; } renderer Object . add Property ( Representation Renderer Keys . DRAW INVALID RULE , representation Renderer . is Draw Invalid Rule ( ) ) ; renderer Object . add Property ( Representation Renderer Keys . DRAW INVISIBLE , representation Renderer . is Draw Invisible ( ) ) ; renderer Object . add Property ( Common Renderer Keys . GRADUATED SYMBOLS , representation Renderer . is Symbols Are Graduated ( ) ) ; renderer Object . add ( Representation Renderer Keys . FIELDS , field Array ) ; json Object . add ( Representation Renderer Keys . REPRESENTATION RENDERER , renderer Object ) ; return json Object ; } catch ( Automation Exception e ) { logger . error ( String . format ( STRING , value , reference Value , index ) ) ; e . print Stack Trace ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; logger . error ( e . get Message ( ) ) ; } return null ; }
public Standard Pie Section Label Generator ( String label Format , Locale locale ) { this ( label Format , Number Format . get Number Instance ( locale ) , Number Format . get Percent Instance ( locale ) ) ; }
public static void ensure Credentials Have Been Loaded From Properties ( ) { if ( ! loaded ) { final String [ ] credentials = Program Properties . get ( STRING , new String [ NUM ] ) ; for ( String line : credentials ) { String [ ] tokens = line . split ( STRING ) ; if ( tokens . length > NUM ) { server 2 Credentials . put ( tokens [ NUM ] , new Pair < > ( tokens . length > NUM ? tokens [ NUM ] : STRING , Basic . to String ( Base 64 . decode Base 64 ( ( tokens . length > NUM ? tokens [ NUM ] : STRING ) ) ) ) ) ; } } loaded = BOOL ; } }
protected CC Call Func ( Object t , String s , Class < ? > [ ] p ) { target Callback = t ; selector = s ; partypes = p ; if ( partypes == null ) { try { Class < ? > cls = target Callback . get Class ( ) ; invocation = cls . get Method ( selector ) ; } catch ( No Such Method Exception e ) { e . print Stack Trace ( ) ; } } else { try { Class < ? > cls = target Callback . get Class ( ) ; invocation = cls . get Method ( selector , partypes ) ; } catch ( No Such Method Exception e ) { e . print Stack Trace ( ) ; } } }
private static Map < String , Set < Integer > > read Config File ( File config File ) throws IO Exception { Map < String , Set < Integer > > entries = new Hash Map < > ( ) ; for ( String line : File Utils . read Lines ( config File ) ) { String [ ] fields = line . split ( FIELDSEPARATOR CONFIGFILE ) ; if ( fields . length < NUM ) { throw new Illegal State Exception ( String . format ( STRING , config File , line ) ) ; } if ( entries . contains Key ( fields [ NUM ] ) ) { throw new Illegal State Exception ( String . format ( STRING , config File , fields [ NUM ] ) ) ; } Set < Integer > topic Counts = new Hash Set < > ( fields . length - NUM ) ; for ( int i = NUM ; i < fields . length ; i ++ ) { try { topic Counts . add ( Integer . parse Int ( fields [ i ] ) ) ; } catch ( Number Format Exception e ) { throw new Illegal State Exception ( String . format ( STRING , config File , fields [ i ] ) ) ; } } entries . put ( fields [ NUM ] , topic Counts ) ; } return entries ; }
private String compute ( double left , String right , boolean is Integer ) { if ( Double . is Na N ( left ) && right == null ) { return null ; } if ( is Integer && left == ( int ) left ) { return ( int ) left + ( right == null ? STRING : right ) ; } else if ( Double . is Infinite ( left ) ) { return Tools . format Number ( left ) + ( right == null ? STRING : right ) ; } else { return ( Double . is Na N ( left ) ? STRING : left ) + ( right == null ? STRING : right ) ; } }
public void remove Property Change Listener ( final String property Name , final Property Change Listener listener ) { property Change Support . remove Property Change Listener ( property Name , listener ) ; }
public void load XML ( Node stepnode , List < Database Meta > databases , Map < String , Counter > counters ) throws Kettle XML Exception { try { this . tabel Name = XML Handler . get Tag Value ( stepnode , STRING ) ; this . output Row Size = XML Handler . get Tag Value ( stepnode , STRING ) ; this . fact Dim Lens String = XML Handler . get Tag Value ( stepnode , STRING ) ; this . cube Name = XML Handler . get Tag Value ( stepnode , STRING ) ; this . schema Name = XML Handler . get Tag Value ( stepnode , STRING ) ; this . dimension Count = XML Handler . get Tag Value ( stepnode , STRING ) ; this . no Dictionary Dims = XML Handler . get Tag Value ( stepnode , STRING ) ; this . no Dictionary Dims Mapping = XML Handler . get Tag Value ( stepnode , STRING ) ; this . complex Dimension Count = XML Handler . get Tag Value ( stepnode , STRING ) ; this . measure Count = XML Handler . get Tag Value ( stepnode , STRING ) ; this . update Member Request = XML Handler . get Tag Value ( stepnode , STRING ) ; this . measure Data Type = XML Handler . get Tag Value ( stepnode , STRING ) ; current Restruct Number = Integer . parse Int ( XML Handler . get Tag Value ( stepnode , STRING ) ) ; this . partition ID = XML Handler . get Tag Value ( stepnode , STRING ) ; this . segment Id = XML Handler . get Tag Value ( stepnode , STRING ) ; this . task No = XML Handler . get Tag Value ( stepnode , STRING ) ; } catch ( Exception e ) { throw new Kettle XML Exception ( STRING , e ) ; } }
public static long generate ( long hash , final Char Sequence value ) { final long m = NUM ; final int r = NUM ; int strlen = value . length ( ) ; int length = NUM * strlen ; hash ^= length * m ; int len 4 = strlen / NUM ; int offset = NUM ; for ( int i = NUM ; i < len 4 ; i ++ ) { final int index = i * NUM + offset ; long k = ( value . char At ( index + NUM ) | ( ( long ) value . char At ( index + NUM ) << NUM ) | ( ( long ) value . char At ( index + NUM ) << NUM ) | ( ( long ) value . char At ( index + NUM ) << NUM ) ) ; k *= m ; k ^= k > > > r ; k *= m ; hash ^= k ; hash *= m ; } final int off = offset + ( strlen & ~ NUM ) ; switch ( strlen % NUM ) { case NUM : hash ^= ( long ) value . char At ( off + NUM ) << NUM ; case NUM : hash ^= ( long ) value . char At ( off + NUM ) << NUM ; case NUM : hash ^= ( long ) value . char At ( off + NUM ) << NUM ; hash *= m ; } hash ^= hash > > > r ; hash *= m ; hash ^= hash > > > r ; return hash ; }
public static Insn List cast ( final Type from , final Type to ) { Insn List list = new Insn List ( ) ; if ( from != to ) { if ( from == Type . DOUBLE TYPE ) { if ( to == Type . FLOAT TYPE ) { list . add ( new Insn Node ( Opcodes . D2 F ) ) ; } else if ( to == Type . LONG TYPE ) { list . add ( new Insn Node ( Opcodes . D2 L ) ) ; } else { list . add ( new Insn Node ( Opcodes . D2 I ) ) ; list . add ( cast ( Type . INT TYPE , to ) ) ; } } else if ( from == Type . FLOAT TYPE ) { if ( to == Type . DOUBLE TYPE ) { list . add ( new Insn Node ( Opcodes . F2 D ) ) ; } else if ( to == Type . LONG TYPE ) { list . add ( new Insn Node ( Opcodes . F2 L ) ) ; } else { list . add ( new Insn Node ( Opcodes . F2 I ) ) ; list . add ( cast ( Type . INT TYPE , to ) ) ; } } else if ( from == Type . LONG TYPE ) { if ( to == Type . DOUBLE TYPE ) { list . add ( new Insn Node ( Opcodes . L2 D ) ) ; } else if ( to == Type . FLOAT TYPE ) { list . add ( new Insn Node ( Opcodes . L2 F ) ) ; } else { list . add ( new Insn Node ( Opcodes . L2 I ) ) ; list . add ( cast ( Type . INT TYPE , to ) ) ; } } else { if ( to == Type . BYTE TYPE ) { list . add ( new Insn Node ( Opcodes . I2 B ) ) ; } else if ( to == Type . CHAR TYPE ) { list . add ( new Insn Node ( Opcodes . I2 C ) ) ; } else if ( to == Type . DOUBLE TYPE ) { list . add ( new Insn Node ( Opcodes . I2 D ) ) ; } else if ( to == Type . FLOAT TYPE ) { list . add ( new Insn Node ( Opcodes . I2 F ) ) ; } else if ( to == Type . LONG TYPE ) { list . add ( new Insn Node ( Opcodes . I2 L ) ) ; } else if ( to == Type . SHORT TYPE ) { list . add ( new Insn Node ( Opcodes . I2 S ) ) ; } } } return list ; }
public static void Add Agent To Group ( AM Identity group , AM Identity agent ) throws Id Repo Exception , SSO Exception , Configuration Exception { if ( ! group . is Exists ( ) ) { String [ ] param = { group . get Name ( ) } ; throw new Configuration Exception ( STRING , param ) ; } if ( ! agent . is Exists ( ) ) { String [ ] param = { agent . get Name ( ) } ; throw new Configuration Exception ( STRING , param ) ; } String agent Type = get Agent Type ( agent ) ; String agent Group Type = get Agent Type ( group ) ; if ( support Local Properties ( agent Type ) && is Properties Locally Stored ( agent ) ) { String agent Name = agent . get Name ( ) ; String [ ] param = { agent Name } ; throw new Configuration Exception ( STRING , param ) ; } if ( ! agent Type . equals ( agent Group Type ) ) { String agent Name = agent . get Name ( ) ; String group Name = group . get Name ( ) ; String [ ] param = { agent Name , group Name } ; throw new Configuration Exception ( STRING , param ) ; } group . add Member ( agent ) ; }
private String process Scanned Files ( final String path , final String file Name ) throws Exception { if ( ! is Error ) { if ( scan Mode == Scan Mode Constants . SCAN MODE FILE ) { if ( ( temp Files != null ) && ! temp Files . is Empty ( ) ) { File file = ( File ) temp Files . get ( NUM ) ; File new File = new File ( path , this . prefix ) ; if ( new File . exists ( ) ) { new File . delete ( ) ; } file . rename To ( new File ) ; clear Temp Files ( ) ; return file Name ; } else { return null ; } } else if ( ( scan Mode == Scan Mode Constants . SCAN MODE NATIVE ) || ( scan Mode == Scan Mode Constants . SCAN MODE MEMORY ) ) { if ( ( temp Files != null ) && ! temp Files . is Empty ( ) ) { File new File = new File ( path , this . prefix ) ; if ( new File . exists ( ) ) { new File . delete ( ) ; } File Output Stream fos = null ; Document document = null ; try { fos = new File Output Stream ( new File ) ; document = new Document ( ) ; Pdf Writer . get Instance ( document , fos ) ; document . open ( ) ; File file Properties = ( File ) temp Files . get ( NUM ) ; Image image Properties = Image . get Instance ( file Properties . get Path ( ) ) ; document . set Page Size ( image Properties ) ; document . set Margins ( NUM , NUM , NUM , NUM ) ; File file = null ; Image image = null ; Iterator it = temp Files . iterator ( ) ; while ( it . has Next ( ) ) { file = ( File ) it . next ( ) ; document . new Page ( ) ; image = Image . get Instance ( file . get Path ( ) ) ; document . add ( image ) ; } } catch ( Exception e ) { throw e ; } finally { if ( document != null ) { document . close ( ) ; } if ( fos != null ) { fos . close ( ) ; } } clear Temp Files ( ) ; return new File . get Path ( ) ; } else { return null ; } } } else { clear Temp Files ( ) ; } return null ; }
@ Override public boolean truncate ( String file Name , long valid Data End Offset ) { Data Output Stream data Output Stream = null ; Data Input Stream data Input Stream = null ; boolean file Truncated Successfully = BOOL ; int buffer Size = valid Data End Offset > Carbon Common Constants . BYTE TO KB CONVERSION FACTOR ? Carbon Common Constants . BYTE TO KB CONVERSION FACTOR : ( int ) valid Data End Offset ; String temp Write File Path = file Name + Carbon Common Constants . TEMPWRITEFILEEXTENSION ; File Factory . File Type file Type = File Factory . get File Type ( file Name ) ; try { Carbon File temp File = null ; if ( File Factory . is File Exist ( temp Write File Path , file Type ) ) { temp File = File Factory . get Carbon File ( temp Write File Path , file Type ) ; temp File . delete ( ) ; } File Factory . create New File ( temp Write File Path , file Type ) ; temp File = File Factory . get Carbon File ( temp Write File Path , file Type ) ; byte [ ] buff = new byte [ buffer Size ] ; data Input Stream = File Factory . get Data Input Stream ( file Name , file Type ) ; int read = data Input Stream . read ( buff , NUM , buff . length ) ; data Output Stream = File Factory . get Data Output Stream ( temp Write File Path , file Type ) ; data Output Stream . write ( buff , NUM , read ) ; long remaining = valid Data End Offset - read ; while ( remaining > NUM ) { if ( remaining > buffer Size ) { buff = new byte [ buffer Size ] ; } else { buff = new byte [ ( int ) remaining ] ; } read = data Input Stream . read ( buff , NUM , buff . length ) ; data Output Stream . write ( buff , NUM , read ) ; remaining = remaining - read ; } Carbon Util . close Streams ( data Input Stream , data Output Stream ) ; temp File . rename Force ( file Name ) ; file Truncated Successfully = BOOL ; } catch ( IO Exception e ) { LOGGER . error ( STRING + e . get Message ( ) ) ; } finally { Carbon Util . close Streams ( data Output Stream , data Input Stream ) ; } return file Truncated Successfully ; }
public void test Submit Runnable 2 ( ) throws Throwable { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; Future < String > future = e . submit ( new No Op Runnable ( ) , TEST STRING ) ; assert Same ( TEST STRING , future . get ( ) ) ; assert True ( future . is Done ( ) ) ; assert False ( future . is Cancelled ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public Rectangle 2 D expand ( Rectangle 2 D area , Rectangle 2 D result ) { if ( result == null ) { result = new Rectangle 2 D . Double ( ) ; } result . set Rect ( area . get X ( ) - this . left , area . get Y ( ) - this . top , area . get Width ( ) + this . left + this . right , area . get Height ( ) + this . top + this . bottom ) ; return result ; }
protected void assert Func Equals ( final String ... inputs ) throws Exception { Solr Query Request req = req ( ) ; try { assert Func Equals ( req , inputs ) ; } finally { req . close ( ) ; } }
private void persist Stats In DB ( List < Stat > stats ) throws Base Collection Exception { if ( ! stats . is Empty ( ) ) { key Map . put ( Constants . Stats , stats ) ; dump Stat Records ( ) ; inject Stats ( ) ; stats . clear ( ) ; } }

protected void do Print Classification ( Classifier classifier , Instance inst , int index ) throws Exception { double [ ] d = classifier . distribution For Instance ( inst ) ; do Print Classification ( d , inst , index ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return BEGIN IN BOTH ; case NUM : return OLD STRING ; case NUM : return END IN BOTH ; default : return null ; } }
protected Size 2 D arrange NN ( Block Container container , Graphics 2 D g2 ) { double max W = NUM ; double max H = NUM ; List blocks = container . get Blocks ( ) ; Iterator iterator = blocks . iterator ( ) ; while ( iterator . has Next ( ) ) { Block b = ( Block ) iterator . next ( ) ; if ( b != null ) { Size 2 D s = b . arrange ( g2 , Rectangle Constraint . NONE ) ; max W = Math . max ( max W , s . width ) ; max H = Math . max ( max H , s . height ) ; } } double width = this . columns * max W ; double height = this . rows * max H ; Rectangle Constraint c = new Rectangle Constraint ( width , height ) ; return arrange FF ( container , g2 , c ) ; }
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { return invoke ( proxy , new Standard Method ( method ) , args ) ; }
public static String remove Char ( char c , String string ) { int next Char = string . index Of ( c ) ; if ( next Char == - NUM ) return string ; int start = NUM ; String Builder ret = new String Builder ( string . length ( ) - NUM ) ; while ( next Char != - NUM ) { ret . append ( string , start , next Char ) ; start = next Char + NUM ; next Char = string . index Of ( c , start ) ; } ret . append ( string , start , string . length ( ) ) ; return ret . to String ( ) ; }
int use Cache ( Solr Cache sc , int num Gets , int max Key , int seed ) { int ret = NUM ; Random r = new Random ( seed ) ; for ( int i = NUM ; i < num Gets ; i ++ ) { Integer k = r . next Int ( max Key ) ; Integer v = ( Integer ) sc . get ( k ) ; if ( v == null ) { sc . put ( k , k ) ; ret ++ ; } } return ret ; }
public void send ( final byte [ ] the Bytes , final String the Address , final int the Port ) { try { Inet Address my Inet Address = Inet Address . get By Name ( the Address ) ; send ( the Bytes , my Inet Address , the Port ) ; } catch ( Unknown Host Exception e ) { Logger . print Error ( STRING , STRING + the Address + STRING + e ) ; } }
public void key Typed ( Key Event evt ) { int modifiers = evt . get Modifiers ( ) ; char c = evt . get Key Char ( ) ; if ( c != Key Event . CHAR UNDEFINED && ( modifiers & Key Event . ALT MASK ) == NUM ) { if ( c >= NUM && c != NUM ) { Key Stroke key Stroke = Key Stroke . get Key Stroke ( Character . to Upper Case ( c ) ) ; Object o = current Bindings . get ( key Stroke ) ; if ( o instanceof Hashtable ) { current Bindings = ( Hashtable ) o ; return ; } else if ( o instanceof Action Listener ) { current Bindings = bindings ; execute Action ( ( Action Listener ) o , evt . get Source ( ) , String . value Of ( c ) , modifiers ) ; return ; } current Bindings = bindings ; if ( grab Action != null ) { handle Grab Action ( evt ) ; return ; } if ( repeat && Character . is Digit ( c ) ) { repeat Count *= NUM ; repeat Count += ( c - STRING ) ; return ; } execute Action ( INSERT CHAR , evt . get Source ( ) , String . value Of ( evt . get Key Char ( ) ) , modifiers ) ; repeat Count = NUM ; repeat = BOOL ; } } }
public static Map < String , Mapped Class > mappings From Enigma ( File file , Map < String , Class Node > nodes ) { Map < String , Mapped Class > base = mappings From Nodes ( nodes ) ; Mapping Loader loader = new Enigma Loader ( nodes ) ; try { Map < String , Mapped Class > new Mappings = loader . read ( new File Reader ( file ) ) ; for ( Mapped Class mapped Class : new Mappings . values ( ) ) { new Mappings = link Mappings ( mapped Class , new Mappings ) ; } base = fix From Mappings Text ( base , new Mappings ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } return base ; }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; try { init ( ) ; } catch ( Runtime Exception e ) { if ( e instanceof Null Pointer Exception || e instanceof Illegal Argument Exception ) { Invalid Object Exception ee = new Invalid Object Exception ( e . get Message ( ) ) ; ee . init Cause ( e ) ; throw ee ; } throw e ; } }
public static Script create Multi Sig Input Script Bytes ( List < byte [ ] > signatures , @ Nullable byte [ ] multisig Program Bytes ) { check Argument ( signatures . size ( ) <= NUM ) ; Script Builder builder = new Script Builder ( ) ; builder . small Num ( NUM ) ; for ( byte [ ] signature : signatures ) builder . data ( signature ) ; if ( multisig Program Bytes != null ) builder . data ( multisig Program Bytes ) ; return builder . build ( ) ; }
public static void lsp 2 lpc ( double lsp [ ] , double a [ ] , int m ) { int i , k , mh 1 , mh 2 , flag odd ; double xx , xf , xff ; int p , q ; int a0 , a1 , a2 , b0 , b1 , b2 ; flag odd = NUM ; if ( m % NUM == NUM ) mh 1 = mh 2 = m / NUM ; else { mh 1 = ( m + NUM ) / NUM ; mh 2 = ( m - NUM ) / NUM ; flag odd = NUM ; } double [ ] lsp 2 lpc buff = new double [ ( NUM * m + NUM ) ] ; int lsp 2 lpc size = m ; p = m ; q = p + mh 1 ; a0 = q + mh 2 ; a1 = a0 + ( mh 1 + NUM ) ; a2 = a1 + ( mh 1 + NUM ) ; b0 = a2 + ( mh 1 + NUM ) ; b1 = b0 + ( mh 2 + NUM ) ; b2 = b1 + ( mh 2 + NUM ) ; System . arraycopy ( lsp , NUM , lsp 2 lpc buff , NUM , m ) ; for ( i = NUM ; i < mh 1 + NUM ; i ++ ) lsp 2 lpc buff [ a0 + i ] = NUM ; for ( i = NUM ; i < mh 1 + NUM ; i ++ ) lsp 2 lpc buff [ a1 + i ] = NUM ; for ( i = NUM ; i < mh 1 + NUM ; i ++ ) lsp 2 lpc buff [ a2 + i ] = NUM ; for ( i = NUM ; i < mh 2 + NUM ; i ++ ) lsp 2 lpc buff [ b0 + i ] = NUM ; for ( i = NUM ; i < mh 2 + NUM ; i ++ ) lsp 2 lpc buff [ b1 + i ] = NUM ; for ( i = NUM ; i < mh 2 + NUM ; i ++ ) lsp 2 lpc buff [ b2 + i ] = NUM ; for ( i = k = NUM ; i < mh 1 ; i ++ , k += NUM ) lsp 2 lpc buff [ p + i ] = - NUM * Math . cos ( lsp 2 lpc buff [ k ] ) ; for ( i = k = NUM ; i < mh 2 ; i ++ , k += NUM ) lsp 2 lpc buff [ q + i ] = - NUM * Math . cos ( lsp 2 lpc buff [ k + NUM ] ) ; xx = NUM ; xf = xff = NUM ; for ( k = NUM ; k <= m ; k ++ ) { if ( flag odd == NUM ) { lsp 2 lpc buff [ a0 + NUM ] = xx ; lsp 2 lpc buff [ b0 + NUM ] = xx - xff ; xff = xf ; xf = xx ; } else { lsp 2 lpc buff [ a0 + NUM ] = xx + xf ; lsp 2 lpc buff [ b0 + NUM ] = xx - xf ; xf = xx ; } for ( i = NUM ; i < mh 1 ; i ++ ) { lsp 2 lpc buff [ a0 + i + NUM ] = lsp 2 lpc buff [ a0 + i ] + lsp 2 lpc buff [ p + i ] * lsp 2 lpc buff [ a1 + i ] + lsp 2 lpc buff [ a2 + i ] ; lsp 2 lpc buff [ a2 + i ] = lsp 2 lpc buff [ a1 + i ] ; lsp 2 lpc buff [ a1 + i ] = lsp 2 lpc buff [ a0 + i ] ; } for ( i = NUM ; i < mh 2 ; i ++ ) { lsp 2 lpc buff [ b0 + i + NUM ] = lsp 2 lpc buff [ b0 + i ] + lsp 2 lpc buff [ q + i ] * lsp 2 lpc buff [ b1 + i ] + lsp 2 lpc buff [ b2 + i ] ; lsp 2 lpc buff [ b2 + i ] = lsp 2 lpc buff [ b1 + i ] ; lsp 2 lpc buff [ b1 + i ] = lsp 2 lpc buff [ b0 + i ] ; } if ( k != NUM ) a [ k - NUM ] = - NUM * ( lsp 2 lpc buff [ a0 + mh 1 ] + lsp 2 lpc buff [ b0 + mh 2 ] ) ; xx = NUM ; } for ( i = m - NUM ; i >= NUM ; i -- ) a [ i + NUM ] = - a [ i ] ; a [ NUM ] = NUM ; }
public static boolean strictly Between ( Date base Date , Date start Date , Date end Date ) { if ( start Date . equals ( end Date ) || end Date . before ( start Date ) ) { return BOOL ; } if ( start Date . before ( base Date ) && end Date . after ( base Date ) ) { return BOOL ; } return BOOL ; }
private void raise Error Event ( int dialog Timeout Error ) { SIP Dialog Error Event new Error Event ; Iterator < SIP Dialog Event Listener > listener Iterator ; SIP Dialog Event Listener next Listener ; new Error Event = new SIP Dialog Error Event ( this , dialog Timeout Error ) ; synchronized ( event Listeners ) { listener Iterator = event Listeners . iterator ( ) ; while ( listener Iterator . has Next ( ) ) { next Listener = ( SIP Dialog Event Listener ) listener Iterator . next ( ) ; next Listener . dialog Error Event ( new Error Event ) ; } } event Listeners . clear ( ) ; if ( dialog Timeout Error != SIP Dialog Error Event . DIALOG ACK NOT SENT TIMEOUT && dialog Timeout Error != SIP Dialog Error Event . DIALOG ACK NOT RECEIVED TIMEOUT && dialog Timeout Error != SIP Dialog Error Event . DIALOG REINVITE TIMEOUT ) { delete ( ) ; } stop Timer ( ) ; }
private static String text 2 Simple Html ( String html Text ) { if ( html Text == null ) { return null ; } String replace String = html Text ; String Buffer result = new String Buffer ( ) ; boolean after Close = BOOL ; int current Line Length = NUM ; for ( int i = NUM ; i < replace String . length ( ) ; i ++ ) { char c = replace String . char At ( i ) ; if ( after Close ) { if ( c == STRING ) { continue ; } } if ( c == STRING ) { if ( ! after Close ) { result . append ( Tools . get Line Separator ( ) ) ; current Line Length = NUM ; } } after Close = BOOL ; result . append ( c ) ; current Line Length ++ ; if ( current Line Length > NUM && c == STRING ) { result . append ( Tools . get Line Separator ( ) ) ; current Line Length = NUM ; } if ( c == STRING ) { result . append ( Tools . get Line Separator ( ) ) ; current Line Length = NUM ; after Close = BOOL ; } } return result . to String ( ) ; }
@ Override public void write ( byte [ ] buf , int offset , int length ) throws IO Exception { final byte [ ] buffer = write Buffer ; final int buffer Length = buffer . length ; Stream Impl source = source ; while ( BOOL ) { final int write Length = write Length ; if ( write Length == NUM && buffer Length <= length ) { if ( source != null ) { source . write ( buf , offset , length , BOOL ) ; position += length ; return ; } } final int sublen = Math . min ( length , buffer Length - write Length ) ; System . arraycopy ( buf , offset , buffer , write Length , sublen ) ; if ( length == sublen ) { write Length = write Length + length ; if ( implicit Flush ) { flush ( ) ; } return ; } if ( source == null ) { return ; } source . write ( buffer , NUM , buffer Length , BOOL ) ; position += buffer Length ; write Length = NUM ; length -= sublen ; offset += sublen ; if ( buffer Length <= length ) { source . write ( buf , offset , length , BOOL ) ; position += length ; return ; } } }
private boolean configure Connection For Http Post ( Http URL Connection connection ) throws IO Exception { String boundary = read Boundary ( ) ; if ( boundary == null ) { return BOOL ; } connection . set Do Output ( BOOL ) ; connection . set Request Property ( STRING , STRING ) ; connection . set Request Property ( STRING , STRING ) ; connection . set Request Property ( STRING , String . format ( CONTENT TYPE TMPL , boundary ) ) ; return BOOL ; }
public static String decompress XML ( byte [ ] xml ) { String Builder result Xml = new String Builder ( ) ; int numb Strings = LEW ( xml , NUM * NUM ) ; int sit Off = NUM ; int st Off = sit Off + numb Strings * NUM ; int xml Tag Off = LEW ( xml , NUM * NUM ) ; for ( int ii = xml Tag Off ; ii < xml . length - NUM ; ii += NUM ) { if ( LEW ( xml , ii ) == start Tag ) { xml Tag Off = ii ; break ; } } int off = xml Tag Off ; int indent = NUM ; while ( off < xml . length ) { int tag 0 = LEW ( xml , off ) ; int line No = LEW ( xml , off + NUM * NUM ) ; int name Ns Si = LEW ( xml , off + NUM * NUM ) ; int name Si = LEW ( xml , off + NUM * NUM ) ; if ( tag 0 == start Tag ) { int tag 6 = LEW ( xml , off + NUM * NUM ) ; int numb Attrs = LEW ( xml , off + NUM * NUM ) ; off += NUM * NUM ; String name = comp Xml String ( xml , sit Off , st Off , name Si ) ; String Buffer sb = new String Buffer ( ) ; for ( int ii = NUM ; ii < numb Attrs ; ii ++ ) { int attr Name Ns Si = LEW ( xml , off ) ; int attr Name Si = LEW ( xml , off + NUM * NUM ) ; int attr Value Si = LEW ( xml , off + NUM * NUM ) ; int attr Flags = LEW ( xml , off + NUM * NUM ) ; int attr Res Id = LEW ( xml , off + NUM * NUM ) ; off += NUM * NUM ; String attr Name = comp Xml String ( xml , sit Off , st Off , attr Name Si ) ; String attr Value = attr Value Si != - NUM ? comp Xml String ( xml , sit Off , st Off , attr Value Si ) : M . e ( STRING ) + Integer . to Hex String ( attr Res Id ) ; sb . append ( STRING + attr Name + STRING + attr Value + STRING ) ; } result Xml . append ( prt Indent ( indent , STRING + name + sb + STRING ) ) ; indent ++ ; } else if ( tag 0 == end Tag ) { indent -- ; off += NUM * NUM ; String name = comp Xml String ( xml , sit Off , st Off , name Si ) ; result Xml . append ( prt Indent ( indent , STRING + name + STRING ) ) ; } else if ( tag 0 == end Doc Tag ) { break ; } else { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + Integer . to Hex String ( tag 0 ) + STRING + off ) ; } break ; } } if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + off ) ; } return result Xml . to String ( ) ; }
public Certificate Token ( X509 Certificate x509 Certificate ) { if ( x509 Certificate == null ) { throw new Null Pointer Exception ( STRING ) ; } this . x509 Certificate = x509 Certificate ; this . issuer X 500 Principal = x509 Certificate . get Issuer X 500 Principal ( ) ; this . signature Algorithm = Signature Algorithm . for OID ( x509 Certificate . get Sig Alg OID ( ) ) ; this . digest Algorithm = signature Algorithm . get Digest Algorithm ( ) ; this . encryption Algorithm = signature Algorithm . get Encryption Algorithm ( ) ; super . extra Info = this . extra Info = new Certificate Token Validation Extra Info ( ) ; }
public void normalize ( ) { List < Wb Xml Content > new Contents = new Array List < Wb Xml Content > ( ) ; String Builder sb = new String Builder ( ) ; for ( Wb Xml Content content : contents ) { if ( content . is String ( ) && ! content . is Entity ( ) ) { sb . append ( content . get String ( ) ) ; } else { if ( sb . length ( ) > NUM ) { new Contents . add ( new Wb Xml Content ( sb . to String ( ) ) ) ; sb . set Length ( NUM ) ; } new Contents . add ( content ) ; } } if ( sb . length ( ) > NUM ) { new Contents . add ( new Wb Xml Content ( sb . to String ( ) ) ) ; } contents = new Contents ; compacted = BOOL ; }
private void init Sql Queries ( Connection conn , String sql File Url ) throws Exception { try { File sql File ; try { sql File = file System . get File ( sql File Url ) ; sql File Url = null ; } catch ( Exception e ) { service Log . error ( e . get Message ( ) , e ) ; throw e ; } sql Queries . init ( sql File . get Canonical File ( ) , STRING , conn , sql Parameters ) ; select Query = sql Queries . get Sql String ( STRING , BOOL ) ; insert Query = sql Queries . get Sql String ( STRING , BOOL ) ; delete Query = sql Queries . get Sql String ( STRING , BOOL ) ; delete Auto White List Query = sql Queries . get Sql String ( STRING , BOOL ) ; update Query = sql Queries . get Sql String ( STRING , BOOL ) ; } finally { the JDBC Util . close JDBC Connection ( conn ) ; } }
public void write Raw Bytes ( final byte [ ] value , int offset , int length ) throws IO Exception { if ( buffer . remaining ( ) >= length ) { buffer . put ( value , offset , length ) ; } else { throw new Out Of Space Exception ( buffer . position ( ) , buffer . limit ( ) ) ; } }
private Resource Index refresh Resource Index From Data Store ( Service Type resource Type ) throws Policy Exception { Resource Index resource Index = get Resource Index From Data Store ( resource Type ) ; resource Indices . put ( resource Type . get Name ( ) , resource Index ) ; return resource Index ; }
public void test Set Date int Date ( ) throws SQL Exception { Calendar cal = new Gregorian Calendar ( NUM , NUM , NUM ) ; Date [ ] dates = { new Date ( cal . get Time In Millis ( ) ) , new Date ( Integer . MAX VALUE ) , new Date ( NUM ) } ; Prepared Statement ps = null ; Prepared Statement ps 1 = null ; try { String query = STRING ; ps = conn . prepare Statement ( query ) ; for ( int i = NUM ; i < dates . length ; i ++ ) { ps . set Date ( NUM , dates [ i ] ) ; assert False ( ps . execute ( ) ) ; assert True ( ps . get Update Count ( ) > NUM ) ; } try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { } String query 1 = STRING ; ps 1 = conn . prepare Statement ( query 1 ) ; try { ps 1 . set Date ( NUM , dates [ NUM ] ) ; fail ( STRING ) ; } catch ( SQL Exception sqle ) { assert Equals ( STRING , sqle . get Message ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps 1 != null ) ps 1 . close ( ) ; } catch ( SQL Exception ee ) { } } }
public static int index Of That Starts With ( List < String > list , String starts With , int start Index ) { for ( int i = start Index ; i < list . size ( ) ; i ++ ) { String cur Str = list . get ( i ) ; if ( cur Str != null && cur Str . starts With ( starts With ) ) { return i ; } } return - NUM ; }
public final Bean Event Type create Bean Type ( String name , Class clazz , boolean is Preconfigured Static , boolean is Preconfigured , boolean is Configured ) { if ( clazz == null ) { throw new Illegal Argument Exception ( STRING ) ; } Bean Event Type event Type = null ; types Per Java Bean Lock . lock ( ) ; try { event Type = types Per Java Bean . get ( clazz ) ; if ( event Type != null ) { event Type Id Generator . assigned Type ( name , event Type ) ; return event Type ; } Configuration Event Type Legacy legacy Def = class To Legacy Configs . get ( clazz . get Name ( ) ) ; if ( ( legacy Def == null ) && ( default Accessor Style != Configuration Event Type Legacy . Accessor Style . JAVABEAN ) ) { legacy Def = new Configuration Event Type Legacy ( ) ; legacy Def . set Accessor Style ( default Accessor Style ) ; } int type Id = event Type Id Generator . get Type Id ( name ) ; Event Type Metadata metadata = Event Type Metadata . create Bean Type ( name , clazz , is Preconfigured Static , is Preconfigured , is Configured , Event Type Metadata . Type Class . APPLICATION ) ; event Type = new Bean Event Type ( metadata , type Id , clazz , event Adapter Service , legacy Def ) ; types Per Java Bean . put ( clazz , event Type ) ; } catch ( Runtime Exception ex ) { throw ex ; } finally { types Per Java Bean Lock . unlock ( ) ; } return event Type ; }
public boolean calculate Tax Total ( ) { log . fine ( STRING ) ; DB . execute Update Ex ( STRING + get C Order ID ( ) , get Trx Name ( ) ) ; m taxes = null ; Big Decimal total Lines = Env . ZERO ; Array List < Integer > tax List = new Array List < Integer > ( ) ; M Order Line [ ] lines = get Lines ( ) ; for ( int i = NUM ; i < lines . length ; i ++ ) { M Order Line line = lines [ i ] ; Integer tax ID = new Integer ( line . get C Tax ID ( ) ) ; if ( ! tax List . contains ( tax ID ) ) { M Order Tax o Tax = M Order Tax . get ( line , get Precision ( ) , BOOL , get Trx Name ( ) ) ; o Tax . set Is Tax Included ( is Tax Included ( ) ) ; if ( ! o Tax . calculate Tax From Lines ( ) ) return BOOL ; if ( ! o Tax . save ( get Trx Name ( ) ) ) return BOOL ; tax List . add ( tax ID ) ; } total Lines = total Lines . add ( line . get Line Net Amt ( ) ) ; } Big Decimal grand Total = total Lines ; M Order Tax [ ] taxes = get Taxes ( BOOL ) ; for ( int i = NUM ; i < taxes . length ; i ++ ) { M Order Tax o Tax = taxes [ i ] ; M Tax tax = o Tax . get Tax ( ) ; if ( tax . is Summary ( ) ) { M Tax [ ] c Taxes = tax . get Child Taxes ( BOOL ) ; for ( int j = NUM ; j < c Taxes . length ; j ++ ) { M Tax c Tax = c Taxes [ j ] ; Big Decimal tax Amt = c Tax . calculate Tax ( o Tax . get Tax Base Amt ( ) , is Tax Included ( ) , get Precision ( ) ) ; M Order Tax new O Tax = new M Order Tax ( get Ctx ( ) , NUM , get Trx Name ( ) ) ; new O Tax . set Client Org ( this ) ; new O Tax . set C Order ID ( get C Order ID ( ) ) ; new O Tax . set C Tax ID ( c Tax . get C Tax ID ( ) ) ; new O Tax . set Precision ( get Precision ( ) ) ; new O Tax . set Is Tax Included ( is Tax Included ( ) ) ; new O Tax . set Tax Base Amt ( o Tax . get Tax Base Amt ( ) ) ; new O Tax . set Tax Amt ( tax Amt ) ; if ( ! new O Tax . save ( get Trx Name ( ) ) ) return BOOL ; if ( ! is Tax Included ( ) ) grand Total = grand Total . add ( tax Amt ) ; } if ( ! o Tax . delete ( BOOL , get Trx Name ( ) ) ) return BOOL ; if ( ! o Tax . save ( get Trx Name ( ) ) ) return BOOL ; } else { if ( ! is Tax Included ( ) ) grand Total = grand Total . add ( o Tax . get Tax Amt ( ) ) ; } } set Total Lines ( total Lines ) ; set Grand Total ( grand Total ) ; return BOOL ; }
public static boolean use MS Interop ( ) { String prop Value = Access Controller . do Privileged ( new Get Property Action ( STRING , STRING ) ) ; return ( ! prop Value . equals Ignore Case ( STRING ) ) ; }
public void close Storage ( Storage Data storage Data ) throws Business Exception , IO Exception , Serialization Exception { Storage Data local = get Local Storage Data Object ( storage Data ) ; synchronized ( local ) { if ( ( storage Recorder . is Recording On ( ) || storage Recorder . is Recording Scheduled ( ) ) && Objects . equals ( local , recorder Storage Data ) ) { throw new Business Exception ( STRING + local + STRING , Storage Error Code Enum . STORAGE CAN NOT BE CLOSED ) ; } else if ( is Storage Closed ( local ) ) { throw new Business Exception ( STRING + local + STRING , Storage Error Code Enum . STORAGE ALREADY CLOSED ) ; } Storage Writer writer = opened Storages Map . get ( local ) ; if ( writer != null ) { writer . close Storage Writer ( ) ; } opened Storages Map . remove ( local ) ; local . set Disk Size ( get Disk Size For Storage ( local ) ) ; local . mark Closed ( ) ; write Storage Data To Disk ( local ) ; } }
private void do Get Helper ( Http Servlet Request request , Http Servlet Response response ) throws Servlet Exception , IO Exception { logger . log ( Level . INFO , STRING + request . get Request URI ( ) ) ; final Request And Response request And Response = new Request And Response ( request , response ) ; standard Response Stuff ( request And Response ) ; final String full Uri = request . get Request URI ( ) ; request And Response . set Override Uri ( full Uri ) ; if ( full Uri . equals ( STRING ) ) { handle Html Index Page ( request And Response ) ; return ; } if ( full Uri . equals ( STRING ) ) { handle Robots Txt ( request And Response ) ; return ; } final Array List < String > uris = split Uris ( full Uri ) ; if ( uris == null ) { return Html 404 ( request And Response ) ; return ; } request And Response . more Than One Uri = uris . size ( ) > NUM ; if ( uris . size ( ) > NUM ) { request And Response . just Get Title = BOOL ; for ( int i = NUM ; i < uris . size ( ) ; ++ i ) { final String uri = uris . get ( i ) ; request And Response . set Override Uri ( uri ) ; route Single Get Request ( request And Response , uri ) ; } request And Response . just Get Title = BOOL ; request And Response . title Already Formed = BOOL ; } for ( int i = NUM ; i < uris . size ( ) ; ++ i ) { final String uri = uris . get ( i ) ; request And Response . set Override Uri ( uri ) ; if ( uris . size ( ) > NUM ) { if ( i == NUM ) { request And Response . skip Footer = BOOL ; } else if ( i == uris . size ( ) - NUM ) { request And Response . skip Header = BOOL ; request And Response . skip Footer = BOOL ; } else { request And Response . skip Header = BOOL ; } } route Single Get Request ( request And Response , uri ) ; } }
@ Deprecated public static boolean check And Convert Identifier ( Psi Builder b , int l , @ Not Null String identifier Value , @ Not Null I Element Type token Type ) { if ( CONVERTABLE TOKENS . contains ( b . get Token Type ( ) ) && identifier Value . equals ( b . get Token Text ( ) ) ) { Psi Builder . Marker m = b . mark ( ) ; b . advance Lexer ( ) ; m . collapse ( token Type ) ; return BOOL ; } return BOOL ; }
public static double correlation ( Example Set example Set , Attribute first Attribute , Attribute second Attribute , boolean squared ) { double sum Prod = NUM ; double sum First = NUM ; double sum Second = NUM ; double sum First Squared = NUM ; double sum Second Squared = NUM ; int counter = NUM ; Iterator < Example > reader = example Set . iterator ( ) ; while ( reader . has Next ( ) ) { Example example = reader . next ( ) ; double first = example . get Value ( first Attribute ) ; double second = example . get Value ( second Attribute ) ; double prod = first * second ; if ( ! Double . is Na N ( prod ) ) { sum Prod += prod ; sum First += first ; sum First Squared += first * first ; sum Second += second ; sum Second Squared += second * second ; counter ++ ; } } double divisor = Math . sqrt ( ( counter * sum First Squared - sum First * sum First ) * ( counter * sum Second Squared - sum Second * sum Second ) ) ; double r ; if ( divisor == NUM ) { r = Double . Na N ; } else { r = ( counter * sum Prod - sum First * sum Second ) / divisor ; } if ( squared ) { return r * r ; } else { return r ; } }
private void load Binary Index ( URL url ) { diphone Index = new Hash Map ( ) ; try { Input Stream is = Utilities . get Input Stream ( url ) ; Data Input Stream dis = new Data Input Stream ( is ) ; if ( dis . read Int ( ) != INDEX MAGIC ) { throw new Error ( STRING ) ; } int size = dis . read Int ( ) ; for ( int i = NUM ; i < size ; i ++ ) { String diphone Name = dis . read UTF ( ) ; int pos = dis . read Int ( ) ; diphone Index . put ( diphone Name , new Integer ( pos ) ) ; } dis . close ( ) ; } catch ( File Not Found Exception fe ) { throw new Error ( STRING + fe . get Message ( ) ) ; } catch ( IO Exception ioe ) { throw new Error ( STRING + ioe . get Message ( ) ) ; } }
public VN Xe Command Result delete Luns From Consistency Group ( String cg Id , List < String > luns ) { Lun Group Modify Param param = new Lun Group Modify Param ( ) ; List < Lun Add Param > lun Delete = new Array List < Lun Add Param > ( ) ; for ( String lun Id : luns ) { VN Xe Base lun = new VN Xe Base ( lun Id ) ; Lun Add Param lun Add = new Lun Add Param ( ) ; lun Add . set Lun ( lun ) ; lun Delete . add ( lun Add ) ; } param . set Lun Delete ( lun Delete ) ; Consistency Group Requests req = new Consistency Group Requests ( kh Client ) ; return req . modify Consistency Group Sync ( cg Id , param ) ; }
public void add Discovery Listener ( Discovery Listener l ) { if ( l == null ) { throw new Null Pointer Exception ( STRING ) ; } synchronized ( this ) { if ( terminated ) { throw new Illegal State Exception ( STRING ) ; } if ( listeners . contains ( l ) ) return ; listeners . add ( l ) ; if ( ! discovered Locators . is Empty ( ) ) { Hash Map groups Map = new Hash Map ( discovered Locators . size ( ) ) ; Iterator iter = discovered Locators . iterator ( ) ; for ( int i = NUM ; iter . has Next ( ) ; i ++ ) { Locator Reg reg = ( Locator Reg ) iter . next ( ) ; groups Map . put ( reg . proxy , reg . member Groups ) ; } Array List list = new Array List ( NUM ) ; list . add ( l ) ; add Notify ( list , groups Map , BOOL ) ; } } }
public static int choice ( final String title , final String text , final int default Selection , final Choice Item ... items ) { return choice ( null , title , text , default Selection , items ) ; }
private void update Chart ( ) { main Panel . remove All ( ) ; Grid Bag Constraints constraints = new Grid Bag Constraints ( ) ; constraints . fill = Grid Bag Constraints . BOTH ; constraints . gridx = NUM ; constraints . gridy = NUM ; constraints . gridwidth = NUM ; constraints . weightx = NUM ; constraints . weighty = NUM ; constraints . anchor = Grid Bag Constraints . CENTER ; J Panel chart Panel = create Chart Panel ( ) ; chart Panel . set Opaque ( BOOL ) ; chart Panel . set Background ( Color And Font Constants . BACKGROUND COLOR ) ; chart Panel . set Foreground ( Color And Font Constants . TEXT COLOR ) ; main Panel . add ( chart Panel , constraints ) ; }
@ Override public < T > Provider < T > provider ( Key < T > key ) { Objects . require Non Null ( key ) ; Provider < T > provider = ( Provider ) provider Map . get ( key ) ; if ( provider == null ) { provider = lookup Provider ( key ) ; if ( provider == null ) { provider = auto Provider ( key ) ; } provider Map . put If Absent ( key , provider ) ; provider = ( Provider ) provider Map . get ( key ) ; } return provider ; }
public static List < Response > execute Batch And Wait ( Request Batch requests ) { Validate . not Empty And Contains No Nulls ( requests , STRING ) ; Http URL Connection connection = null ; try { connection = to Http Connection ( requests ) ; } catch ( Exception ex ) { List < Response > responses = Response . construct Error Responses ( requests . get Requests ( ) , null , new Facebook Exception ( ex ) ) ; run Callbacks ( requests , responses ) ; return responses ; } List < Response > responses = execute Connection And Wait ( connection , requests ) ; return responses ; }
private static float determine Enemy Blitz Strength ( final Territory blitz Here , final List < Route > blitz Terr Routes , final List < Territory > block Terr , final Game Data data , final Player ID e Player ) { final Hash Set < Integer > ignore = new Hash Set < > ( ) ; ignore . add ( NUM ) ; final Composite Match < Unit > blitz Unit = new Composite Match And < > ( Matches . unit Is Owned By ( e Player ) , Matches . Unit Can Blitz , Matches . Unit Can Move ) ; final Composite Match < Territory > valid Blitz Route = new Composite Match And < > ( Matches . territory Has No Enemy Units ( e Player , data ) , Matches . Territory Is Not Impassable To Land Units ( e Player , data ) ) ; final List < Route > routes = new Array List < > ( ) ; final List < Unit > blitz Units = find Attackers ( blitz Here , NUM , ignore , e Player , data , blitz Unit , valid Blitz Route , block Terr , routes , BOOL ) ; for ( final Route r : routes ) { if ( r . number Of Steps ( ) == NUM ) { blitz Terr Routes . add ( r ) ; } } return strength ( blitz Units , BOOL , BOOL , BOOL ) ; }
public static TCP Endpoint read Host Port Format ( Data Input in ) throws IO Exception { String host = in . read UTF ( ) ; int port = in . read Int ( ) ; return new TCP Endpoint ( host , port ) ; }
public void test Bug 12753 ( ) throws Exception { if ( version Meets Minimum ( NUM , NUM ) ) { Properties props = new Properties ( ) ; props . set Property ( STRING , STRING ) ; Connection session Conn = null ; try { session Conn = get Connection With Props ( props ) ; String sql Mode = get Mysql Variable ( session Conn , STRING ) ; assert True ( sql Mode . index Of ( STRING ) != - NUM ) ; } finally { if ( session Conn != null ) { session Conn . close ( ) ; session Conn = null ; } } } }
public Program Rewriter ( Hop Rewrite Rule rewrite ) { dag Rule Set = new Array List < Hop Rewrite Rule > ( ) ; dag Rule Set . add ( rewrite ) ; sb Rule Set = new Array List < Statement Block Rewrite Rule > ( ) ; }
private J Menu create Bin Navi Menu ( ) { final J Menu menu = new J Menu ( STRING ) ; menu . set Mnemonic ( STRING ) ; menu . add ( C Action Proxy . proxy ( new C Add Database Action ( m project Tree ) ) ) ; menu . add Separator ( ) ; menu . add ( C Action Proxy . proxy ( new C Action Exit ( get Parent ( ) ) ) ) ; return menu ; }
void dump Binary ( Data Output Stream os ) throws IO Exception { os . write Int ( type ) ; os . write Int ( phone ) ; os . write Int ( start ) ; os . write Int ( end ) ; os . write Int ( prev ) ; os . write Int ( next ) ; }
public static boolean is Java Identifier ( final String str ) { if ( str == null || str . length ( ) < NUM ) { return BOOL ; } if ( ! Character . is Java Identifier Start ( str . char At ( NUM ) ) ) { return BOOL ; } for ( int i = NUM ; i < str . length ( ) ; i ++ ) { if ( ! Character . is Java Identifier Part ( str . char At ( i ) ) ) { return BOOL ; } } return BOOL ; }
private void handle Channel ( String [ ] args , Buffered Reader reader ) throws IO Exception { Tuple < String , String > initial Payload = new Tuple < > ( args [ NUM ] , args [ NUM ] ) ; if ( args . length == NUM ) { request Channel Fail . add ( initial Payload ) ; } String line = reader . read Line ( ) ; List < String > commands = new Array List < > ( ) ; while ( ! line . equals ( STRING ) ) { commands . add ( line ) ; line = reader . read Line ( ) ; } request Channel Commands . put ( initial Payload , commands ) ; }
public void add Scripts ( final String directory ) { final List < File > files = new Array List < File > ( ) ; if ( directory != null && ! directory . is Empty ( ) ) { files . add All ( File Utils . get File Names For Directory ( directory , SCRIPT EXTENSION ) ) ; } else { logger . error ( STRING ) ; } populate Scripts From File List ( files ) ; }
public static Thread consume Process Output Stream ( Process self , Appendable output ) { Thread thread = new Thread ( new Text Dumper ( self . get Input Stream ( ) , output ) ) ; thread . start ( ) ; return thread ; }
public Str Builder delete All ( final String str ) { final int len = ( str == null ? NUM : str . length ( ) ) ; if ( len > NUM ) { int index = index Of ( str , NUM ) ; while ( index >= NUM ) { delete Impl ( index , index + len , len ) ; index = index Of ( str , index ) ; } } return this ; }
@ Reference ( authors = STRING , title = STRING , booktitle = STRING , url = STRING ) public static < V extends Number Vector > double log Likelihood Alternate ( Relation < V > relation , Clustering < ? extends Mean Model > clustering , Number Vector Distance Function < ? super V > distance Function ) { List < ? extends Cluster < ? extends Mean Model > > clusters = clustering . get All Clusters ( ) ; final int dim = Relation Util . dimensionality ( relation ) ; final int m = clusters . size ( ) ; int n = NUM ; int [ ] n i = new int [ m ] ; double [ ] d i = new double [ m ] ; Iterator < ? extends Cluster < ? extends Mean Model > > it = clusters . iterator ( ) ; for ( int i = NUM ; it . has Next ( ) ; ++ i ) { Cluster < ? extends Mean Model > cluster = it . next ( ) ; n += n i [ i ] = cluster . size ( ) ; d i [ i ] = variance Of Cluster ( cluster , distance Function , relation ) ; } double log Likelihood = NUM ; for ( int i = NUM ; i < m ; i ++ ) { log Likelihood += n i [ i ] * Math . log ( n i [ i ] / ( double ) n ) - n i [ i ] * dim * NUM * Math Util . LOGTWOPI - n i [ i ] * NUM * Math . log ( d i [ i ] ) - ( n i [ i ] - m ) * NUM ; } return log Likelihood ; }
public static String append ( final Char Sequence url , final Object ... params ) { final String base Url = url . to String ( ) ; if ( params == null || params . length == NUM ) return base Url ; if ( params . length % NUM != NUM ) throw new Illegal Argument Exception ( STRING ) ; final String Builder result = new String Builder ( base Url ) ; add Path Separator ( base Url , result ) ; add Param Prefix ( base Url , result ) ; add Param ( params [ NUM ] , params [ NUM ] , result ) ; for ( int i = NUM ; i < params . length ; i += NUM ) { result . append ( STRING ) ; add Param ( params [ i ] , params [ i + NUM ] , result ) ; } return result . to String ( ) ; }
public static void encode Multicast Announcement ( Multicast Announcement announcement , Datagram Buffer Factory bufs ) throws IO Exception { try { Linked List groups = new Linked List ( ) ; groups . add All ( Arrays . as List ( announcement . get Groups ( ) ) ) ; do { Byte Buffer buf = bufs . new Buffer ( ) ; int slim = buf . limit ( ) ; buf . limit ( slim - SERVICE ID LEN ) ; buf . put Long ( announcement . get Sequence Number ( ) ) ; put Utf ( buf , announcement . get Host ( ) ) ; buf . put Short ( int To Ushort ( announcement . get Port ( ) ) ) ; int ngroups = NUM ; int ngroups Pos = buf . position ( ) ; buf . put Short ( ( short ) NUM ) ; try { while ( ! groups . is Empty ( ) && ngroups < MAX USHORT ) { put Utf ( buf , ( String ) groups . get First ( ) ) ; groups . remove First ( ) ; ngroups ++ ; } } catch ( Buffer Overflow Exception e ) { if ( ngroups == NUM ) { throw e ; } } buf . put Short ( ngroups Pos , int To Ushort ( ngroups ) ) ; Service ID id = announcement . get Service ID ( ) ; buf . limit ( slim ) ; buf . put Long ( id . get Most Significant Bits ( ) ) ; buf . put Long ( id . get Least Significant Bits ( ) ) ; } while ( ! groups . is Empty ( ) ) ; } catch ( Runtime Exception e ) { throw new Discovery Protocol Exception ( null , e ) ; } }
public void trim To Size ( ) { if ( names != null ) names . trim To Size ( ) ; if ( required Children != null ) { required Children . trim To Size ( ) ; for ( Gaz Entry nextkey : required Children . values ( ) ) { nextkey . trim To Size ( ) ; } } }
public boolean contains None ( ) { return prompts . contains ( PROMPT NONE ) ; }
static void sort ( float [ ] a , int left , int right , float [ ] work , int work Base , int work Len ) { while ( left <= right && Float . is Na N ( a [ right ] ) ) { -- right ; } for ( int k = right ; -- k >= left ; ) { float ak = a [ k ] ; if ( ak != ak ) { a [ k ] = a [ right ] ; a [ right ] = ak ; -- right ; } } do Sort ( a , left , right , work , work Base , work Len ) ; int hi = right ; while ( left < hi ) { int middle = ( left + hi ) > > > NUM ; float middle Value = a [ middle ] ; if ( middle Value < NUM ) { left = middle + NUM ; } else { hi = middle ; } } while ( left <= right && Float . float To Raw Int Bits ( a [ left ] ) < NUM ) { ++ left ; } for ( int k = left , p = left - NUM ; ++ k <= right ; ) { float ak = a [ k ] ; if ( ak != NUM ) { break ; } if ( Float . float To Raw Int Bits ( ak ) < NUM ) { a [ k ] = NUM ; a [ ++ p ] = - NUM ; } } }
public Image rotate 270 Degrees ( Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = NUM ; y < height ; y ++ ) { for ( int x = NUM ; x < width ; x ++ ) { new RGB [ y + x * height ] = rgb [ x + y * width ] ; } } return Encoded Image . create From RGB ( new RGB , height , width , ! maintain Opacity ) ; }
public static boolean is File Transfer Over Http ( Sip Request request ) { Cpim Message message = extract Cpim Message ( request ) ; if ( message == null ) { return BOOL ; } String content Type = message . get Content Type ( ) ; return content Type != null && content Type . starts With ( File Transfer Http Info Document . MIME TYPE ) ; }
private void debug Segment ( Write Stream out , Segment Service Impl segment Service , Segment Extent extent , byte [ ] debug Table Key ) throws IO Exception { int length = extent . length ( ) ; try ( In Segment in = segment Service . open Read ( extent ) ) { Read Stream is = new Read Stream ( in ) ; is . position ( length - BLOCK SIZE ) ; long seq = Bits Util . read Long ( is ) ; if ( seq <= NUM ) { return ; } byte [ ] table Key = new byte [ NUM ] ; is . read All ( table Key , NUM , table Key . length ) ; Table Entry table = segment Service . find Table ( table Key ) ; if ( table == null ) { return ; } if ( debug Table Key != null && ! Arrays . equals ( debug Table Key , table Key ) ) { return ; } out . println ( ) ; String Builder sb = new String Builder ( ) ; Base 64 Util . encode ( sb , seq ) ; long time = id Gen . time ( seq ) ; out . println ( STRING + extent . get Id ( ) + STRING + sb + STRING + Hex . to Short Hex ( table Key ) + STRING + Long . to Hex String ( extent . address ( ) ) + STRING + Integer . to Hex String ( length ) + STRING + Local Date Time . of Epoch Second ( time / NUM , NUM , Zone Offset . UTC ) + STRING ) ; debug Segment Entries ( out , is , extent , table ) ; } }
public int [ ] time 2 LMST ( long time ) { int [ ] result = new int [ NUM ] ; long mars Time = Math . round ( ( time - epoch ) / NUM / to Earth ) ; result [ NUM ] = ( int ) ( mars Time / ( seconds In A Day ) ) ; mars Time = ( int ) ( mars Time % seconds In A Day ) ; result [ NUM ] = Math . abs ( ( int ) ( mars Time / seconds In An Hr ) ) ; mars Time = ( int ) ( mars Time % seconds In An Hr ) ; result [ NUM ] = Math . abs ( ( int ) ( mars Time / seconds In A Min ) ) ; result [ NUM ] = Math . abs ( ( int ) ( mars Time % seconds In A Min ) ) ; return ( result ) ; }
private static List < Object > generate Collection Configs ( Map < String , String > name Map ) { List < Object > output = new Linked List < Object > ( ) ; for ( String resource Name String : name Map . key Set ( ) ) { Map < String , Object > collection Map = new Linked Hash Map < String , Object > ( ) ; collection Map . put ( CONFIG KEY NAME PATTERN , resource Name String ) ; collection Map . put ( CONFIG KEY ENTITY NAME , name Map . get ( resource Name String ) ) ; output . add ( collection Map ) ; } return output ; }
private Array deserialize Array ( Element el ) throws Converter Exception { Array array = new Array Impl ( ) ; Node List list = el . get Child Nodes ( ) ; int len = list . get Length ( ) ; for ( int i = NUM ; i < len ; i ++ ) { Node node = list . item ( i ) ; if ( node instanceof Element ) try { array . append ( deserialize ( ( Element ) node ) ) ; } catch ( Page Exception e ) { throw to Converter Exception ( e ) ; } } return array ; }
public Distributed Test CLI ( String [ ] args ) { cli Options = create Options ( ) ; try { Command Line Parser parser = new Gnu Parser ( ) ; command Line = parser . parse ( cli Options , args , BOOL ) ; if ( has Option ( STRING ) ) { print Help ( ) ; System . exit ( NUM ) ; } if ( ! has Option ( STRING ) ) { logger . info ( STRING ) ; System . exit ( NUM ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; System . exit ( NUM ) ; } }
private static byte [ ] concat Bytes ( byte [ ] array 1 , byte [ ] array 2 ) { byte [ ] c Bytes = new byte [ array 1 . length + array 2 . length ] ; try { System . arraycopy ( array 1 , NUM , c Bytes , NUM , array 1 . length ) ; System . arraycopy ( array 2 , NUM , c Bytes , array 1 . length , array 2 . length ) ; } catch ( Exception e ) { throw new Faces Exception ( e ) ; } return c Bytes ; }
protected void create ( String full Id , String type , String local Id , Map < String , Object > obj , Connection connection , Prepared Statement create Statement , boolean batch Create ) throws SQL Exception , IO Exception { logger . debug ( STRING , full Id ) ; String rev = STRING ; obj . put ( STRING , local Id ) ; obj . put ( STRING , rev ) ; Json Value obj Val = new Json Value ( obj ) ; logger . debug ( STRING , create Statement , type , local Id , rev ) ; populate Prep Statement Columns ( create Statement , obj Val , token Replacement Prop Pointers ) ; if ( ! batch Create ) { logger . debug ( STRING , create Statement ) ; int val = create Statement . execute Update ( ) ; logger . debug ( STRING , full Id , rev ) ; } else { create Statement . add Batch ( ) ; logger . debug ( STRING , full Id , rev ) ; } }
private final double conditional Survival Probability ( int x , double v , int y , double t , double [ ] m ) { double mt = m [ NUM ] + m [ NUM ] ; if ( v < NUM || v > t ) { throw new Illegal Argument Exception ( STRING + v + STRING + t ) ; } else { double a , b , c , d ; if ( x == y ) { a = m [ NUM ] * m [ NUM ] ; b = - a ; c = m [ NUM - x ] ; d = m [ x ] ; } else { a = m [ NUM - y ] ; b = m [ NUM - x ] ; c = NUM ; d = - NUM ; } double exponent = ( b * c - a * d ) / ( c * d * - mt ) ; double C = Math . pow ( c * Math . exp ( - mt * t ) + d , - exponent ) ; return C * Math . exp ( b * v / d ) * Math . pow ( d + c * Math . exp ( - mt * ( t - v ) ) , exponent ) ; } }
public void clear Results ( ) { if ( m Result List != null ) { m Result List . clear ( ) ; m Adapter . notify Data Set Changed ( ) ; } m Listener . on Search Cleared ( ) ; }
public void remove Item Listener ( Item Listener a Listener ) { listener List . remove ( Item Listener . class , a Listener ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING + default Min Inst Num ( ) + STRING + default Max Inst Num ( ) + STRING , STRING , NUM , STRING ) ) ; result . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return result . elements ( ) ; }
public static Mosaic Levy create Mosaic Levy ( ) { return create Mosaic Levy ( Utils . create Mosaic Id ( NUM ) ) ; }
public String construct Property Value ( String prop ) { String ret String = null ; if ( prop . equals ( STRING ) ) { int num Addrs = ip Address . get Item Count ( ) ; if ( num Addrs > NUM ) { ret String = STRING ; } else { ret String = DEFAULT IP ADDRESS ; } for ( int i = NUM ; i < num Addrs ; i ++ ) { ret String += ip Address . get Item At ( i ) ; if ( i != num Addrs - NUM ) { ret String += PROP DELIM ; } } } else if ( prop . equals ( STRING ) ) { int num Ports = port . get Item Count ( ) ; if ( num Ports > NUM ) { ret String = STRING ; } else { ret String = DEFAULT PORT NUMBER ; } for ( int i = NUM ; i < num Ports ; i ++ ) { ret String += port . get Item At ( i ) ; if ( i != num Ports - NUM ) { ret String += PROP DELIM ; } } } else if ( prop . equals ( STRING ) ) { ret String = options Comp . get Client ID ( ) ; } else if ( prop . equals ( STRING ) ) { ret String = String . value Of ( options Comp . is Persistence Selected ( ) ) ; } else if ( prop . equals ( STRING ) ) { ret String = options Comp . get Persistence Directory ( ) ; } return ret String ; }
public final Parallel Flux < T > filter ( Predicate < ? super T > predicate ) { Objects . require Non Null ( predicate , STRING ) ; return on Assembly ( new Parallel Unordered Filter < > ( this , predicate ) ) ; }
private static void remove Margin Top Of Content Child ( View m Content Child , int status Bar Height ) { if ( m Content Child == null ) { return ; } if ( TAG MARGIN ADDED . equals ( m Content Child . get Tag ( ) ) ) { Frame Layout . Layout Params lp = ( Frame Layout . Layout Params ) m Content Child . get Layout Params ( ) ; lp . top Margin -= status Bar Height ; m Content Child . set Layout Params ( lp ) ; m Content Child . set Tag ( null ) ; } }
public static byte [ ] hex String To Byte Array ( String s ) { int len = s . length ( ) ; byte [ ] data = new byte [ len / NUM ] ; for ( int i = NUM ; i < len ; i += NUM ) { data [ i / NUM ] = ( byte ) ( ( Character . digit ( s . char At ( i ) , NUM ) << NUM ) + Character . digit ( s . char At ( i + NUM ) , NUM ) ) ; } return data ; }
private void fetch Features ( Gapis Features features ) throws Execution Exception , Rpc Exception , Timeout Exception { String [ ] list = Rpc . get ( my Client . get Features ( ) , FETCH FEATURES TIMEOUT MS , Time Unit . MILLISECONDS ) ; features . set Feature List ( list ) ; LOG . info ( STRING + Arrays . to String ( list ) ) ; }
public String dump ( ) { String [ ] names = get Source Names ( ) ; double [ ] [ ] values = get Values ( ) ; String Builder buffer = new String Builder ( ) ; buffer . append ( format ( STRING , NUM ) ) ; for ( String name : names ) { buffer . append ( format ( name , NUM ) ) ; } buffer . append ( STRING ) ; for ( int i = NUM ; i < timestamps . length ; i ++ ) { buffer . append ( format ( Long . to String ( timestamps [ i ] ) , NUM ) ) ; for ( int j = NUM ; j < names . length ; j ++ ) { buffer . append ( format ( Util . format Double ( values [ j ] [ i ] ) , NUM ) ) ; } buffer . append ( STRING ) ; } return buffer . to String ( ) ; }
Matlab Number Array ( Class < L > linear Array Type , L real , L imag , int [ ] dimensions ) { real = linear Array Type . cast ( real ) ; imag = linear Array Type . cast ( imag ) ; linear Length = Array . get Length ( real ) ; dimensions = dimensions ; base Component Type = linear Array Type . get Component Type ( ) ; linear Array Type = linear Array Type ; output Array Type = ( Class < T > ) Array Utils . get Array Class ( base Component Type , dimensions . length ) ; }
public void validate ( List < Path > parts , Partitioner Type partitioner Type , int num Shards ) throws IO Exception { boolean has Non Empty Partition = BOOL ; H Column Descriptor column Descriptor = new H Column Descriptor ( ) ; column Descriptor . set Block Cache Enabled ( BOOL ) ; for ( int shard Index = NUM ; shard Index < parts . size ( ) ; shard Index ++ ) { Path file To Be Validated = parts . get ( shard Index ) ; H File . Reader reader = null ; try { File System fs = File System . new Instance ( file To Be Validated . to Uri ( ) , conf ) ; Cache Config cc = new Cache Config ( conf , column Descriptor ) ; reader = H File . create Reader ( fs , file To Be Validated , cc ) ; Partitioner partitioner = Partitioner Factory . get Partitioner ( partitioner Type ) ; byte [ ] row Key = reader . get First Row Key ( ) ; if ( row Key == null ) { LOG . warn ( String . format ( STRING , file To Be Validated . to String ( ) ) ) ; reader . close ( ) ; continue ; } has Non Empty Partition = BOOL ; Bytes Writable key = new Bytes Writable ( row Key ) ; int partition = partitioner . get Partition ( key , null , num Shards ) ; if ( partition != shard Index ) { throw new Illegal Argument Exception ( String . format ( STRING , partitioner Type . to String ( ) , new String ( key . get Bytes ( ) ) , shard Index , partition ) ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } } } if ( ! has Non Empty Partition ) { throw new Illegal Argument Exception ( STRING ) ; } }
public boolean wait For Applied Event ( String event , long timeout ) throws Exception { long seqno = new Long ( event ) ; if ( pipeline == null ) throw new Replicator Exception ( STRING + seqno + STRING ) ; Future < Repl DBMS Header > expected Event = pipeline . watch For Committed Sequence Number ( seqno , BOOL ) ; Repl DBMS Header repl Event = null ; try { if ( timeout <= NUM ) repl Event = expected Event . get ( ) ; else repl Event = expected Event . get ( timeout , Time Unit . SECONDS ) ; logger . info ( STRING + seqno + STRING + repl Event . get Seqno ( ) ) ; } catch ( Timeout Exception e ) { return BOOL ; } finally { expected Event . cancel ( BOOL ) ; } return BOOL ; }
public void add Slide ( @ Non Null Fragment fragment , @ Color Int int color ) { fragments . add ( fragment ) ; add Background Color ( color ) ; pager Adapter . notify Data Set Changed ( ) ; }
public String process ( Item item ) throws Process Exception { int count = NUM ; Item ss = item . get Item As ( Relation . SYLLABLE ) ; Item first Syllable = FIRST SYLLABLE PATH . find Item ( item ) ; for ( Item p = ss ; p != null ; p = p . get Previous ( ) , count ++ ) { if ( p . equals Shared ( first Syllable ) ) { break ; } } return Integer . to String ( rail ( count ) ) ; }
public E remove LRU Entry ( ) { if ( is Empty ( ) ) return null ; Iterator < E > i = iterator ( ) ; E value = i . next ( ) ; i . remove ( ) ; return value ; }
public static void viterbi Walk ( final HG Node node , final Walker Function walker , final int node Index ) { walker . apply ( node , node Index ) ; final Hyper Edge best Edge = node . best Hyperedge ; final List < HG Node > tail Nodes = best Edge . get Tail Nodes ( ) ; if ( tail Nodes != null ) { for ( int tail Node Index = NUM ; tail Node Index < tail Nodes . size ( ) ; tail Node Index ++ ) { viterbi Walk ( tail Nodes . get ( tail Node Index ) , walker , tail Node Index ) ; } } }
public static void create Response ( Http Servlet Request request , Http Servlet Response response , Http Servlet servlet , Properties cookie Properties , Mobile Doc doc , boolean debug ) throws IO Exception { response . set Header ( STRING , STRING ) ; response . set Content Type ( STRING ) ; if ( cookie Properties != null ) { Cookie cookie = new Cookie ( Mobile Env . COOKIE INFO , properties Encode ( cookie Properties ) ) ; cookie . set Comment ( STRING ) ; cookie . set Secure ( BOOL ) ; cookie . set Path ( STRING ) ; if ( cookie Properties . size ( ) == NUM ) cookie . set Max Age ( NUM ) ; else cookie . set Max Age ( NUM ) ; response . add Cookie ( cookie ) ; } if ( debug && Mobile Env . DEBUG ) { Mobile Env . add Footer ( request , response , servlet , doc . get Body ( ) ) ; } Print Writer out = response . get Writer ( ) ; doc . output ( out ) ; out . flush ( ) ; if ( out . check Error ( ) ) log . log ( Level . SEVERE , STRING ) ; out . close ( ) ; }
public static Long to Long ( Object o , Long default Value ) { if ( o instanceof Long ) return ( Long ) o ; if ( default Value != null ) return Long . value Of ( to Long Value ( o , default Value . long Value ( ) ) ) ; long res = to Long Value ( o , Long . MIN VALUE ) ; if ( res == Long . MIN VALUE ) return default Value ; return Long . value Of ( res ) ; }
private J Label create Status Indicator ( String identifier ) { Icon icon = new Image Icon ( Data Loader . get Resource ( icon Folder + identifier + STRING ) ) ; J Label label = new J Label ( icon ) ; label . set Visible ( BOOL ) ; add ( label ) ; return label ; }
private Android Debug Bridge ( String os Location ) throws Invalid Parameter Exception { if ( os Location == null || os Location . is Empty ( ) ) { throw new Invalid Parameter Exception ( ) ; } m Adb Os Location = os Location ; check Adb Version ( ) ; }
private void stats ( ) { long now Ms Since Epoch = now ( ) ; if ( last Log Timestamp Ms Since Epoch < NUM ) { last Log Timestamp Ms Since Epoch = now Ms Since Epoch ; return ; } long delta Ms = now Ms Since Epoch - last Log Timestamp Ms Since Epoch ; if ( delta Ms < LOG PERIOD . get Millis ( ) ) { return ; } String message Skew = STRING ; long min Timestamp = min Received Timestamp Ms Since Epoch . get ( now Ms Since Epoch ) ; long max Timestamp = max Received Timestamp Ms Since Epoch . get ( now Ms Since Epoch ) ; if ( min Timestamp < Long . MAX VALUE && max Timestamp > Long . MIN VALUE ) { message Skew = ( max Timestamp - min Timestamp ) + STRING ; } String watermark Skew = STRING ; long min Watermark = min Watermark Ms Since Epoch . get ( now Ms Since Epoch ) ; long max Watermark = max Watermark Ms Since Epoch . get ( now Ms Since Epoch ) ; if ( min Watermark < Long . MAX VALUE && max Watermark > Long . MIN VALUE ) { watermark Skew = ( max Watermark - min Watermark ) + STRING ; } String oldest In Flight = STRING ; String oldest Ack Id = Iterables . get First ( in Flight . key Set ( ) , null ) ; if ( oldest Ack Id != null ) { oldest In Flight = ( now Ms Since Epoch - in Flight . get ( oldest Ack Id ) . request Time Ms Since Epoch ) + STRING ; } LOG . info ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , outer . outer . subscription , num Received , not Yet Read . size ( ) , not Yet Read Bytes , in Flight . size ( ) , oldest In Flight , num In Flight Checkpoints . get ( ) , max In Flight Checkpoints , num Read Bytes . get ( now Ms Since Epoch ) / ( SAMPLE PERIOD . get Millis ( ) / NUM ) , num Received Recently . get ( now Ms Since Epoch ) , num Extended Deadlines . get ( now Ms Since Epoch ) , num Late Deadlines . get ( now Ms Since Epoch ) , num Acked . get ( now Ms Since Epoch ) , num Nacked . get ( now Ms Since Epoch ) , num Expired . get ( now Ms Since Epoch ) , message Skew , watermark Skew , num Late Messages . get ( now Ms Since Epoch ) , new Instant ( last Watermark Ms Since Epoch ) ) ; last Log Timestamp Ms Since Epoch = now Ms Since Epoch ; }
@ Override public int hash Code ( ) { int result = NUM ; Iterator < ? > it = iterator ( ) ; while ( it . has Next ( ) ) { Object object = it . next ( ) ; result = ( NUM * result ) + ( object == null ? NUM : object . hash Code ( ) ) ; } return result ; }
@ Override public synchronized void reset ( ) throws IO Exception { try { buffer . reset ( ) ; } catch ( Invalid Mark Exception e ) { throw new IO Exception ( STRING ) ; } }
public void init ( int max Char Code , Lex Scan scanner ) { if ( max Char Code < NUM ) { throw new Illegal Argument Exception ( STRING + max Char Code + STRING ) ; } else if ( max Char Code > max Char ) { throw new Illegal Argument Exception ( STRING + Integer . to Hex String ( max Char Code ) + STRING + Integer . to Hex String ( max Char ) ) ; } max Char Used = max Char Code ; this . scanner = scanner ; classes = new Array List < Int Char Set > ( ) ; classes . add ( new Int Char Set ( new Interval ( NUM , max Char Code ) ) ) ; }
protected void assert Has Header Value ( String name , String value ) { Multivalued Map < String , String > headers = get Last Received Headers ( ) ; Assert . assert Not Null ( headers ) ; List < String > values = headers . get ( name ) ; Assert . assert Not Null ( values ) ; Assert . assert True ( values . contains ( value ) ) ; }
public Trust Manager Builder add ( Trust Manager ... mgrs ) { for ( Trust Manager tm : mgrs ) { if ( tm instanceof X509 Trust Manager ) { mgr . add ( ( X509 Trust Manager ) tm ) ; } } return ( this ) ; }
public void add Sub Tree ( int index , List < Node > children ) { List < Node Descriptor > node Descriptors = convert Tree Nodes Helper ( children ) ; roots . add Children ( index , node Descriptors ) ; List < Node > nodes = new Array List < > ( ) ; for ( Node Descriptor child : node Descriptors ) { nodes . add ( child . get Node ( ) ) ; } if ( ! nodes . is Empty ( ) ) { fire Event ( new Store Add Event ( index , nodes ) ) ; } }
public static double I ( int C [ ] [ ] , int j , int k , int Ncount ) { double N = ( double ) Ncount ; double N j = Math . max ( C [ j ] [ j ] , NUM ) ; double N k = Math . max ( C [ k ] [ k ] , NUM ) ; double p 5 = ( N - N j ) ; double p 6 = ( N - N k ) ; double p 7 = ( N - ( N j + N k ) ) ; return NUM / N * ( - p 5 * Math . log ( p 5 ) - p 6 * Math . log ( p 6 ) + p 7 * Math . log ( p 7 ) + N * Math . log ( N ) ) ; }
@ Override public Result do Comparison Test ( final Properties properties ) throws Exception { final long timeout = Long . parse Long ( properties . get Property ( Test Options . TIMEOUT ) ) ; final int nclients = Integer . parse Int ( properties . get Property ( Test Options . NCLIENTS ) ) ; final int ntrials = Integer . parse Int ( properties . get Property ( Test Options . NTRIALS ) ) ; final int key Len = Integer . parse Int ( properties . get Property ( Test Options . KEYLEN ) ) ; final int nops = Integer . parse Int ( properties . get Property ( Test Options . NOPS ) ) ; final double abort Rate = Double . parse Double ( properties . get Property ( Test Options . ABORT RATE ) ) ; final Result result = do Concurrent Client Test ( journal , timeout , nclients , ntrials , key Len , nops , abort Rate ) ; return result ; }
static String value To String ( Object value ) { if ( value == null || value . equals ( null ) ) { return STRING ; } if ( value instanceof String ) { return ( String ) value ; } if ( value instanceof Float || value instanceof Double || value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long ) { return number To String ( value ) ; } if ( value instanceof Boolean || value instanceof Map || value instanceof List ) { return value . to String ( ) ; } return quote ( value . to String ( ) ) ; }
public boolean is Annotation Present ( Class < ? extends Annotation > annotation Type ) { return get Annotation ( annotation Type ) != null ; }
public void test Process Msg 6 ( ) { byte [ ] pdu = create PDU ( NUM ) ; int header Len = pdu . length - ( m Gsm Header . length + m User Data Header . length + m Message Body . length ) ; int pdu Type = NUM ; int tran Id = NUM ; String original Package Name = m Package Name ; String original Class Name = m Class Name ; try { m Class Name = STRING ; I Wap Push Manager iwapman = get Interface ( ) ; iwapman . add Package ( Integer . to String ( m App Id Value ) , Integer . to String ( m Content Type Value ) , m Package Name , m Class Name , Wap Push Manager Params . APP TYPE ACTIVITY , BOOL , BOOL ) ; assert False ( ( iwapman . process Message ( Integer . to String ( m App Id Value ) , Integer . to String ( m Content Type Value ) , create Intent ( pdu Type , tran Id ) ) & Wap Push Manager Params . MESSAGE HANDLED ) == Wap Push Manager Params . MESSAGE HANDLED ) ; iwapman . delete Package ( Integer . to String ( m App Id Value ) , Integer . to String ( m Content Type Value ) , m Package Name , m Class Name ) ; iwapman . add Package ( Integer . to String ( m App Id Value ) , Integer . to String ( m Content Type Value ) , m Package Name , m Class Name , Wap Push Manager Params . APP TYPE SERVICE , BOOL , BOOL ) ; assert False ( ( iwapman . process Message ( Integer . to String ( m App Id Value ) , Integer . to String ( m Content Type Value ) , create Intent ( pdu Type , tran Id ) ) & Wap Push Manager Params . MESSAGE HANDLED ) == Wap Push Manager Params . MESSAGE HANDLED ) ; iwapman . delete Package ( Integer . to String ( m App Id Value ) , Integer . to String ( m Content Type Value ) , m Package Name , m Class Name ) ; } catch ( Remote Exception e ) { assert True ( BOOL ) ; } m Package Name = original Package Name ; m Class Name = original Class Name ; }
@ Override public Path Impl scheme Walk ( String user Path , Map < String , Object > attributes , String file Path , int offset ) { int length = file Path . length ( ) ; if ( length <= offset || file Path . char At ( offset ) != STRING ) return super . scheme Walk ( user Path , attributes , file Path , offset ) ; Merge Path merge Path = create Merge Path ( ) ; merge Path . set User Path ( user Path ) ; int head = ++ offset ; int tail = head ; while ( tail < length ) { int ch = file Path . char At ( tail ) ; if ( ch == STRING ) { if ( head + NUM != tail ) { String sub Path = file Path . substring ( head , tail ) ; if ( sub Path . starts With ( STRING ) && sub Path . ends With ( STRING ) ) sub Path = sub Path . substring ( NUM , sub Path . length ( ) - NUM ) ; merge Path . add Merge Path ( Vfs Old . lookup ( sub Path ) ) ; } if ( tail + NUM == length ) return merge Path ; else return merge Path . fs Walk ( user Path , attributes , file Path . substring ( tail + NUM ) ) ; } else if ( ch == STRING ) { String sub Path = file Path . substring ( head , tail ) ; if ( sub Path . starts With ( STRING ) && sub Path . ends With ( STRING ) ) sub Path = sub Path . substring ( NUM , sub Path . length ( ) - NUM ) ; merge Path . add Merge Path ( Vfs Old . lookup ( sub Path ) ) ; head = ++ tail ; } else if ( ch == STRING ) { int depth = NUM ; for ( tail ++ ; tail < length ; tail ++ ) { if ( file Path . char At ( tail ) == STRING ) depth ++ ; else if ( file Path . char At ( tail ) == STRING ) { tail ++ ; depth -- ; if ( depth == NUM ) break ; } } if ( depth != NUM ) return new Not Found Path ( get Scheme Map ( ) , file Path ) ; } else tail ++ ; } return new Not Found Path ( get Scheme Map ( ) , file Path ) ; }
@ Singleton public static synchronized void load License Maps ( String first Option ) throws Invalid Config Exception { if ( licenses == null || license Texts == null ) { licenses = new Tree Map < String , String > ( ) ; licenses . put ( STRING , ( first Option == null ) ? STRING : first Option ) ; license Texts = new Tree Map < String , String > ( ) ; Properties properties = license Properties ( ) ; for ( Map . Entry < Object , Object > entry : properties . entry Set ( ) ) { String key = String Utils . trim ( ( String ) entry . get Key ( ) ) ; String value = String Utils . trim ( ( String ) entry . get Value ( ) ) ; if ( key != null && key . starts With ( LICENSE NAME PROPERTY PREFIX ) && value != null ) { String key Minus Prefix = String Utils . trim To Null ( key . replace ( LICENSE NAME PROPERTY PREFIX , STRING ) ) ; if ( key Minus Prefix != null ) { String license Text = String Utils . trim To Null ( ( properties . get Property ( LICENSE TEXT PROPERTY PREFIX + key Minus Prefix ) ) ) ; if ( license Text != null ) { licenses . put ( key Minus Prefix , value ) ; license Texts . put ( key Minus Prefix , license Text ) ; } } else { String error = LICENSES PROPFILE PATH + STRING ; LOG . error ( error ) ; throw new Invalid Config Exception ( Invalid Config Exception . TYPE . INVALID PROPERTIES FILE , error ) ; } } } if ( ( licenses . size ( ) - NUM ) == NUM ) { String error = STRING + LICENSES PROPFILE PATH + STRING ; LOG . error ( error ) ; throw new Invalid Config Exception ( Invalid Config Exception . TYPE . INVALID PROPERTIES FILE , error ) ; } } }
private Array List < Individuum > initial Population ( int popsize ) { Array List < Individuum > population = new Array List < > ( popsize ) ; for ( int i = NUM ; i < popsize ; i ++ ) { short [ ] gene = new short [ dim ] ; Arrays . fill ( gene , DONT CARE ) ; int count Dim = k ; while ( count Dim > NUM ) { int z = random . next Int ( dim ) ; if ( gene [ z ] != DONT CARE ) { continue ; } gene [ z ] = ( short ) ( random . next Int ( phi ) + GENE OFFSET ) ; count Dim -- ; } population . add ( make Individuum ( gene ) ) ; } return population ; }
public List < Class < ? > > find Available Classes ( String uri ) throws IO Exception { resources Not Loaded . clear ( ) ; List < Class < ? > > classes = new Array List < > ( ) ; List < String > strings = find Available Strings ( uri ) ; for ( String class Name : strings ) { try { Class < ? > clazz = class Loader . load Class ( class Name ) ; classes . add ( clazz ) ; } catch ( Exception not Available ) { resources Not Loaded . add ( class Name ) ; } } return classes ; }
public boolean matches ( Inventory Crafting inv , World world In ) { Item Stack itemstack = null ; List < Item Stack > list = Lists . < Item Stack > new Array List ( ) ; for ( int i = NUM ; i < inv . get Size Inventory ( ) ; ++ i ) { Item Stack itemstack 1 = inv . get Stack In Slot ( i ) ; if ( itemstack 1 != null ) { if ( itemstack 1 . get Item ( ) instanceof Item Armor ) { Item Armor itemarmor = ( Item Armor ) itemstack 1 . get Item ( ) ; if ( itemarmor . get Armor Material ( ) != Cyberware Content . trench Mat || itemstack != null ) { return BOOL ; } itemstack = itemstack 1 ; } else { if ( itemstack 1 . get Item ( ) != Items . DYE ) { return BOOL ; } list . add ( itemstack 1 ) ; } } } return itemstack != null && ! list . is Empty ( ) ; }
@ Override public String format ( double value , int format Number ) { return format . format ( value ) ; }
public static Dalv Insn List make Immutable ( Array List < Dalv Insn > list , int reg Count ) { int size = list . size ( ) ; Dalv Insn List result = new Dalv Insn List ( size , reg Count ) ; for ( int i = NUM ; i < size ; i ++ ) { result . set ( i , list . get ( i ) ) ; } result . set Immutable ( ) ; return result ; }
public static boolean register Canonicalizer ( final String c14 n Algorithm URI ) { final boolean added = canonicalizers . add ( c14 n Algorithm URI ) ; return added ; }
public OR Condition ( Condition ... conditions ) { Reject . if Null ( conditions ) ; this . conditions = Arrays . as List ( conditions ) ; }
@ Override public void on Item Click ( Adapter View < ? > parent , View view , int position , long id ) { Check Box enable Component Checkbox = ( Check Box ) view . find View By Id ( R . id . enable component checkbox ) ; enable Component Checkbox . perform Click ( ) ; }
public static void copy ( String source , String target ) { Input Stream in = null ; Output Stream out = null ; try { in = new Buffered Input Stream ( new File Input Stream ( source ) ) ; out = new Buffered Output Stream ( new File Output Stream ( target ) ) ; for ( int c = read ( in ) ; c != - NUM ; c = read ( in ) ) { write ( out , c ) ; } } catch ( File Not Found Exception e ) { throw new Runtime Exception ( e . get Message ( ) , e ) ; } finally { close ( in ) ; close ( out ) ; } close ( in ) ; close ( out ) ; }
final int rllong ( Data Input Stream dis ) throws IO Exception { int b1 , b2 , b3 , b4 ; int i = NUM ; i = dis . read Int ( ) ; b1 = ( i & NUM ) << NUM ; b2 = ( i & NUM ) << NUM ; b3 = ( i & NUM ) > > NUM ; b4 = ( i & NUM ) > > > NUM ; i = ( b1 | b2 | b3 | b4 ) ; return i ; }
public Long call ( ) throws Exception { for ( int i = NUM ; i < nops ; i ++ ) { Record record = writer . get Random Ground Truth Record ( ) ; Byte Buffer buf ; if ( r . next Int ( NUM ) > NUM ) { buf = store . read ( record . addr ) ; } else { buf = Byte Buffer . allocate ( store . get Byte Count ( record . addr ) ) ; buf = store . read ( record . addr ) ; } assert Equals ( record . data , buf ) ; } return NUM ; }
public boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { log . warn ( system Name + STRING ) ; return BOOL ; } return BOOL ; }
public void write Field ( final String name , final long value ) throws java . io . IO Exception { write Field ( name , Long . to String ( value ) ) ; }
public static double ln Factorial ( double x ) { return Statistics . ln Gamma ( x + NUM ) ; }
public void sync ( long amount , Time Unit unit ) throws IO Exception { try { latch . await ( amount , unit ) ; } catch ( Interrupted Exception e ) { Thread . interrupted ( ) ; throw IO Exception Support . create ( e ) ; } fail On Error ( ) ; }
public static void close Quietly ( Auto Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( Runtime Exception rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
public synchronized boolean write ( final byte [ ] data , final int offset , final boolean append ) { Output Stream out = null ; try { out = new Buffered Output Stream ( new File Output Stream ( file , append ) , data . length - offset ) ; out . write ( data , offset , data . length - offset ) ; out . flush ( ) ; return BOOL ; } catch ( final Exception ex ) { if ( Cfg . EXCEPTION ) { Check . log ( ex ) ; } return BOOL ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( final IO Exception e ) { if ( Cfg . EXCEPTION ) { Check . log ( e ) ; } if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + e . to String ( ) ) ; } } } } }
public void add Listener ( Listener a Listener ) { if ( a Listener == null ) return ; if ( hex Edit Control == null ) { if ( list Of Status Changed Listeners == null ) list Of Status Changed Listeners = new Array List < > ( ) ; list Of Status Changed Listeners . add ( a Listener ) ; } else { hex Edit Control . add Listener ( SWT . Modify , a Listener ) ; } }
public static Inet Address int To Inet Address ( int host Address ) { byte [ ] address Bytes = { ( byte ) ( NUM & host Address ) , ( byte ) ( NUM & ( host Address > > NUM ) ) , ( byte ) ( NUM & ( host Address > > NUM ) ) , ( byte ) ( NUM & ( host Address > > NUM ) ) } ; try { return Inet Address . get By Address ( address Bytes ) ; } catch ( Unknown Host Exception e ) { throw new Assertion Error ( ) ; } }
private AFTP Client action Remove ( ) throws IO Exception , Page Exception { required ( STRING , item ) ; AFTP Client client = get Client ( ) ; client . delete File ( item ) ; write Cfftp ( client ) ; return client ; }
public void test Negate Math Context Positive ( ) { String a = STRING ; int a Scale = NUM ; int precision = NUM ; Rounding Mode rm = Rounding Mode . FLOOR ; Math Context mc = new Math Context ( precision , rm ) ; String c = STRING ; int c Scale = NUM ; Big Decimal a Number = new Big Decimal ( new Big Integer ( a ) , a Scale ) ; Big Decimal res = a Number . negate ( mc ) ; assert Equals ( STRING , c , res . to String ( ) ) ; assert Equals ( STRING , c Scale , res . scale ( ) ) ; }
@ Override public V put If Absent ( final K k , final V v ) { try { final Weak Reference < V > ref = new Weak Ref ( k , v , reference Queue ) ; final Weak Reference < V > old Ref = map . put If Absent ( k , ref ) ; final V old Val = old Ref == null ? null : old Ref . get ( ) ; if ( old Ref != null && old Val == null ) { if ( map . replace ( k , old Ref , ref ) ) { if ( queue != null ) { synchronized ( queue ) { if ( queue . add ( v ) && DEBUG ) { log . debug ( STRING + k + STRING + v ) ; } } } did Update ( k , ref , old Ref ) ; return null ; } else { return put If Absent ( k , v ) ; } } if ( old Val == null ) { if ( queue != null ) { synchronized ( queue ) { if ( queue . add ( v ) && DEBUG ) { log . debug ( STRING + k + STRING + v ) ; } } } did Update ( k , ref , null ) ; return null ; } return old Val ; } finally { remove Cleared Entries ( ) ; } }
public void dispose ( ) { set Layer Removal Delayed ( BOOL ) ; if ( projection Support != null ) { projection Support . dispose ( ) ; projection Support = null ; } if ( painters != null ) { painters . clear ( ) ; painters = null ; } if ( added Layers != null ) { added Layers . remove All Elements ( ) ; added Layers = null ; } current Layers = null ; projection Factory = null ; remove Component Listener ( this ) ; remove Container Listener ( this ) ; remove All ( ) ; purge And Notify Removed Layers ( ) ; }
private void start Monitor Thread ( ) { monitor Thread = new Thread ( new Queue Monitor ( resource Manager ) ) ; monitor Thread . start ( ) ; LOG . debug ( STRING ) ; }
@ HLE Unimplemented @ HLE Function ( nid = NUM , version = NUM ) public int sce Usb Cam Setup Video ( psp Usb Cam Setup Video Param usb Cam Setup Video Param , T Pointer work Area , int work Area Size ) { this . work Area = work Area . get Address ( ) ; this . work Area Size = work Area Size ; resolution = usb Cam Setup Video Param . resolution ; frame Rate = usb Cam Setup Video Param . framerate ; white Balance = usb Cam Setup Video Param . wb ; saturation = usb Cam Setup Video Param . saturation ; brightness = usb Cam Setup Video Param . brightness ; contrast = usb Cam Setup Video Param . contrast ; sharpness = usb Cam Setup Video Param . sharpness ; image Effect Mode = usb Cam Setup Video Param . effectmode ; frame Size = usb Cam Setup Video Param . framesize ; ev Level = usb Cam Setup Video Param . evlevel ; if ( ! setup Video ( ) ) { log . warn ( String . format ( STRING ) ) ; return Sce Kernel Errors . ERROR USBCAM NOT READY ; } return NUM ; }
protected Flashing Icon ( Icon icon ) { this . icon = icon ; Dimension d = new Dimension ( icon . get Icon Width ( ) , icon . get Icon Height ( ) ) ; set Minimum Size ( d ) ; set Maximum Size ( d ) ; set Preferred Size ( d ) ; set Visible ( BOOL ) ; add Mouse Listener ( this ) ; }
private void read Object ( Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; try { init ( ) ; } catch ( Runtime Exception e ) { if ( e instanceof Null Pointer Exception || e instanceof Illegal Argument Exception ) { Invalid Object Exception ee = new Invalid Object Exception ( e . get Message ( ) ) ; ee . init Cause ( e ) ; throw ee ; } throw e ; } }
public static Name lower Camel ( String ... pieces ) { List < Name Piece > name Pieces = new Array List < > ( ) ; for ( String piece : pieces ) { validate Camel ( piece , Check Case . LOWER ) ; name Pieces . add ( new Name Piece ( piece , Case Format . LOWER CAMEL ) ) ; } return new Name ( name Pieces ) ; }
public static Map < URI , Block Object > verify Source And Full Copy ( URI source URI , URI full Copy URI , Uri Info uri Info , Db Client db Client ) { Block Object fc Source Obj = query Full Copy Resource ( source URI , uri Info , BOOL , db Client ) ; Volume full Copy Volume = ( Volume ) query Full Copy Resource ( full Copy URI , uri Info , BOOL , db Client ) ; verify Volume Is Full Copy ( full Copy Volume ) ; verify Copy Is For Source ( full Copy Volume , source URI ) ; Map < URI , Block Object > resource Map = new Hash Map < URI , Block Object > ( ) ; resource Map . put ( source URI , fc Source Obj ) ; resource Map . put ( full Copy URI , full Copy Volume ) ; return resource Map ; }
public Movie Set Remove Action ( boolean with Title ) { if ( with Title ) { put Value ( NAME , BUNDLE . get String ( STRING ) ) ; } put Value ( LARGE ICON KEY , Icon Manager . LIST REMOVE ) ; put Value ( SMALL ICON , Icon Manager . LIST REMOVE ) ; put Value ( SHORT DESCRIPTION , BUNDLE . get String ( STRING ) ) ; }
public static Process Registry locate Registry ( int port ) throws Registry Exception { try { Registry registry = Locate Registry . get Registry ( port ) ; Process Registry process Registry = new Process Registry ( port , registry ) ; return process Registry ; } catch ( Remote Exception e ) { throw new Registry Exception ( STRING + port + STRING , e ) ; } }
public void poll ( final Snmp Udp Statistics Handler snmp Udp Statistics Handler ) { this . statistics Handler = snmp Udp Statistics Handler ; try { file Loader . load ( ) ; final Byte Buffer buffer = file Loader . get Buffer ( ) ; line Parser . reset ( ) ; line Parser . handle Token ( buffer , buffer . position ( ) , buffer . limit ( ) ) ; } finally { this . statistics Handler = null ; } }
public static String remove Duplicate Whitespace ( String s ) { String Builder result = new String Builder ( ) ; int length = s . length ( ) ; boolean is Previous White Space = BOOL ; for ( int i = NUM ; i < length ; i ++ ) { char c = s . char At ( i ) ; boolean this Char White Space = Character . is Whitespace ( c ) ; if ( ! ( is Previous White Space && this Char White Space ) ) { result . append ( c ) ; } is Previous White Space = this Char White Space ; } return result . to String ( ) ; }
public void handle Tbl Request Handler List Href Dup Action Request ( Request Invocation Event event ) throws Model Control Exception { try { Map values = get Values ( ) ; on Before Save Profile ( values ) ; set Page Session Attribute ( PROPERTY ATTRIBUTE , ( Hash Map ) values ) ; SCSAML 2 SOAP Binding Request Handler List Dup View Bean vb = ( SCSAML 2 SOAP Binding Request Handler List Dup View Bean ) get View Bean ( SCSAML 2 SOAP Binding Request Handler List Dup View Bean . class ) ; unlock Page Trail ( ) ; pass Pg Session Map ( vb ) ; int idx = Integer . parse Int ( ( String ) get Display Field Value ( TBL REQUEST HANDLER LIST HREF DUP ACTION ) ) ; vb . set Dup Index ( idx ) ; vb . forward To ( get Request Context ( ) ) ; } catch ( AM Console Exception e ) { set Inline Alert Message ( CC Alert . TYPE ERROR , STRING , e . get Message ( ) ) ; } }
public boolean is Open ( ) { if ( secure Channel Id == - NUM ) return BOOL ; long expire Time = ( ( long ) ( token Lifetime * NUM ) ) + token Issue Time ; long current Time = System . current Time Millis ( ) ; return expire Time > current Time ; }
protected void process Tuple ( T tuple ) { Future < Slice > val Future = get Async Managed State ( tuple ) ; if ( val Future . is Done ( ) ) { try { process Event ( tuple , val Future . get ( ) ) ; } catch ( Interrupted Exception | Execution Exception e ) { throw new Runtime Exception ( e ) ; } } else { process Waiting Event ( tuple , val Future ) ; } }
void refresh ( String filter , Set < Identity > selected Participants ) { Set < Identity > filtered Identities = filter ( filter ) ; for ( Identity selected Participant : selected Participants ) { filtered Identities . remove ( selected Participant ) ; } m Participants . clear ( ) ; m Participants . add All ( filtered Identities ) ; Collections . sort ( m Participants , new Identity Display Name Comparator ( ) ) ; notify Data Set Changed ( ) ; if ( m Show Conversations ) { query Conversations ( selected Participants ) ; } }
public final double do Operation ( ) throws Operator Failed Exception { final int dim = indicator Parameter . get Dimension ( ) ; double sum = NUM ; for ( int i = NUM ; i < dim ; i ++ ) { sum += indicator Parameter . get Parameter Value ( i ) ; } final int pos = Math Utils . next Int ( dim ) ; final int value = ( int ) indicator Parameter . get Parameter Value ( pos ) ; double rand = NUM ; if ( rate Parameter != null ) rand = Math Utils . next Double ( ) ; double logq ; if ( value == NUM ) { indicator Parameter . set Parameter Value ( pos , NUM ) ; logq = - Math . log ( ( dim - sum ) / ( sum + NUM ) ) ; } else if ( value == NUM ) { indicator Parameter . set Parameter Value ( pos , NUM ) ; logq = - Math . log ( sum / ( dim - sum + NUM ) ) ; rand *= - NUM ; } else { throw new Runtime Exception ( STRING ) ; } if ( rate Parameter != null ) { final double scale = Math . exp ( ( rand ) * scale Factor ) ; logq += Math . log ( scale ) ; final double old Value = rate Parameter . get Parameter Value ( NUM ) ; final double new Value = scale * old Value ; rate Parameter . set Parameter Value ( NUM , new Value ) ; } return logq ; }
@ Suppress Warnings ( STRING ) private boolean execute Reveal ( @ Non Null Deco Event event ) { if ( ( event . get Event Type ( ) != Deco Event . Event Type . EVENT SHOW ) && ( event . get Event Type ( ) != Deco Event . Event Type . EVENT HIDE ) ) { return BOOL ; } if ( event . get Event Type ( ) == Deco Event . Event Type . EVENT SHOW ) { set Visibility ( View . VISIBLE ) ; } if ( m Chart Series != null ) { for ( int i = NUM ; i < m Chart Series . size ( ) ; i ++ ) { if ( ( event . get Index Position ( ) == i ) || ( event . get Index Position ( ) < NUM ) ) { Chart Series chart Series = m Chart Series . get ( i ) ; chart Series . start Animate Hide Show ( event , event . get Event Type ( ) == Deco Event . Event Type . EVENT SHOW ) ; } } } return BOOL ; }
public Source < Local Date > with Days Between ( long days From Epoch Start Inclusive , long days From Epoch End Inclusive ) { acceptable Interval For Long Local Date ( days From Epoch Start Inclusive , days From Epoch End Inclusive ) ; max GEQ Min ( days From Epoch Start Inclusive , days From Epoch End Inclusive ) ; return Compositions . weight With Values ( Local Dates . with Days Between ( days From Epoch Start Inclusive , days From Epoch End Inclusive ) , Local Date . of Epoch Day ( days From Epoch End Inclusive ) , Local Date . of Epoch Day ( days From Epoch Start Inclusive ) ) ; }

private void evict All ( Ignite Cache < Integer , Cache Value > cache ) throws Exception { reset Counters ( ) ; assert Equals ( ENTRY CNT , cache . size ( ) ) ; assert Equals ( NUM , cache . local Size ( Cache Peek Mode . OFFHEAP ) ) ; for ( int i = NUM ; i < ENTRY CNT ; i ++ ) { cache . local Evict ( Collections . singleton ( i ) ) ; assert Equals ( ENTRY CNT - i - NUM , cache . local Size ( Cache Peek Mode . ONHEAP ) ) ; assert Equals ( i + NUM , cache . local Size ( Cache Peek Mode . OFFHEAP ) ) ; } assert Equals ( NUM , cache . local Size ( Cache Peek Mode . ONHEAP ) ) ; assert Equals ( ENTRY CNT , cache . local Size ( Cache Peek Mode . OFFHEAP ) ) ; for ( int i = NUM ; i < ENTRY CNT ; i ++ ) assert Null ( cache . local Peek ( i , Cache Peek Mode . ONHEAP ) ) ; assert Equals ( ENTRY CNT , swap Cnt . get ( ) ) ; assert Equals ( NUM , unswap Cnt . get ( ) ) ; }
Node < K , V > find ( int h , Object k ) { Node < K , V > e = this ; if ( k != null ) { do { K ek ; if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } while ( ( e = e . next ) != null ) ; } return null ; }
public static void process Defined Packages For Psi Element ( Psi Element element , Processor < Collection < Perl Namespace Definition > > processor ) { if ( element == null ) { return ; } final Project project = element . get Project ( ) ; final Global Search Scope element Resolve Scope = element . get Resolve Scope ( ) ; for ( String package Name : Perl Package Util . get Defined Package Names ( project ) ) { if ( package Name . length ( ) > NUM && Character . is Letter Or Digit ( package Name . char At ( NUM ) ) ) { Collection < Perl Namespace Definition > namespace Definitions = Perl Package Util . get Namespace Definitions ( project , package Name , element Resolve Scope ) ; if ( namespace Definitions . size ( ) > NUM ) { processor . process ( namespace Definitions ) ; } } } }
public static void display Supported Languages ( Print Stream out , Optional < String > tgt Lang ) { Translate translate = create Translate Service ( ) ; Language List Option target = Language List Option . target Language ( tgt Lang . or Else ( STRING ) ) ; List < Language > languages = translate . list Supported Languages ( target ) ; for ( Language language : languages ) { out . printf ( STRING , language . name ( ) , language . code ( ) ) ; } }
protected void do Update User ( User user ) throws Users Repository Exception { Connection conn = null ; Prepared Statement update User Statement = null ; try { conn = open Connection ( ) ; update User Statement = conn . prepare Statement ( m update User Sql ) ; set User For Update Statement ( user , update User Statement ) ; update User Statement . execute ( ) ; } catch ( SQL Exception sql Exc ) { sql Exc . print Stack Trace ( ) ; throw new Users Repository Exception ( STRING , sql Exc ) ; } finally { the JDBC Util . close JDBC Statement ( update User Statement ) ; the JDBC Util . close JDBC Connection ( conn ) ; } }
@ Suppress Warnings ( STRING ) static void murmurhash 3 x64 128 ( byte [ ] key , int offset , int len , int seed , Long Pair out ) { long h1 = seed & NUM ; long h2 = seed & NUM ; final long c1 = NUM ; final long c2 = NUM ; int rounded End = offset + ( len & NUM ) ; for ( int i = offset ; i < rounded End ; i += NUM ) { long k1 = get Long Little Endian ( key , i ) ; long k2 = get Long Little Endian ( key , i + NUM ) ; k1 *= c1 ; k1 = Long . rotate Left ( k1 , NUM ) ; k1 *= c2 ; h1 ^= k1 ; h1 = Long . rotate Left ( h1 , NUM ) ; h1 += h2 ; h1 = h1 * NUM + NUM ; k2 *= c2 ; k2 = Long . rotate Left ( k2 , NUM ) ; k2 *= c1 ; h2 ^= k2 ; h2 = Long . rotate Left ( h2 , NUM ) ; h2 += h1 ; h2 = h2 * NUM + NUM ; } long k1 = NUM ; long k2 = NUM ; switch ( len & NUM ) { case NUM : k2 = ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k2 |= ( key [ rounded End + NUM ] & NUM ) ; k2 *= c2 ; k2 = Long . rotate Left ( k2 , NUM ) ; k2 *= c1 ; h2 ^= k2 ; case NUM : k1 = ( ( long ) key [ rounded End + NUM ] ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End + NUM ] & NUM ) << NUM ; case NUM : k1 |= ( key [ rounded End ] & NUM ) ; k1 *= c1 ; k1 = Long . rotate Left ( k1 , NUM ) ; k1 *= c2 ; h1 ^= k1 ; } h1 ^= len ; h2 ^= len ; h1 += h2 ; h2 += h1 ; h1 = fmix 64 ( h1 ) ; h2 = fmix 64 ( h2 ) ; h1 += h2 ; h2 += h1 ; out . val 1 = h1 ; out . val 2 = h2 ; }
protected void process Ping Request ( Sim Event ev ) { Info Packet pkt = ( Info Packet ) ev . get Data ( ) ; pkt . set Tag ( Cloud Sim Tags . INFOPKT RETURN ) ; pkt . set Dest Id ( pkt . get Src Id ( ) ) ; send Now ( pkt . get Src Id ( ) , Cloud Sim Tags . INFOPKT RETURN , pkt ) ; }
public Format ( String p Format String ) { String l Format Vars [ ] = p Format String . split ( STRING ) ; m Id = Integer . parse Int ( l Format Vars [ NUM ] ) ; }
public void write Jar From Content ( final String class Name , final String content , final Output Stream out Stream ) throws IO Exception { Jar Output Stream jar Output Stream = new Jar Output Stream ( out Stream ) ; String formatted Name = class Name ; if ( ! formatted Name . ends With ( STRING ) ) { formatted Name = formatted Name . concat ( STRING ) ; } if ( class Name . contains ( STRING ) ) { Jar Entry entry = new Jar Entry ( class Name . substring ( NUM , class Name . last Index Of ( STRING ) ) ) ; entry . set Time ( System . current Time Millis ( ) ) ; jar Output Stream . put Next Entry ( entry ) ; } Jar Entry entry = new Jar Entry ( formatted Name ) ; entry . set Time ( System . current Time Millis ( ) ) ; jar Output Stream . put Next Entry ( entry ) ; jar Output Stream . write ( compile Class ( class Name , content ) ) ; jar Output Stream . close Entry ( ) ; jar Output Stream . close ( ) ; }
public void append Cell ( byte value ) { append Cell ( String . value Of ( value ) ) ; }
public void expect Server Proxy Failed ( Message Info message Info ) { expected Api Calls . add ( new Api Call ( SERVER PROXY FAILED , new Object [ ] { message Info . get Origin ( ) , message Info . get Client ( ) , message Info . get Service ( ) } ) ) ; }
public static Optional < Object [ ] > remove ( final String key To Remove , final Object ... key Values ) { return Element Helper . remove ( ( Object ) key To Remove , key Values ) ; }
@ Not Null public static List < Attribute Snapshot > create Attributes For Tag ( @ Not Null Xml Tag tag ) { Xml Attribute [ ] psi Attributes = tag . get Attributes ( ) ; List < Attribute Snapshot > attributes = Lists . new Array List With Expected Size ( psi Attributes . length ) ; for ( Xml Attribute psi Attribute : psi Attributes ) { Attribute Snapshot attribute = create Attribute Snapshot ( psi Attribute ) ; if ( attribute != null ) { attributes . add ( attribute ) ; } } return attributes ; }
public boolean is Empty ( ) { return children == null || children . is Empty ( ) ; }
public void insert Row ( int row Index , Row Spec row Spec ) { if ( row Index < NUM || row Index > get Row Count ( ) ) { throw new Index Out Of Bounds Exception ( STRING + row Index + STRING + get Row Count ( ) + STRING ) ; } row Specs . add ( row Index - NUM , row Spec ) ; shift Components Vertically ( row Index , BOOL ) ; adjust Group Indices ( row Group Indices , row Index , BOOL ) ; }
private Object do Index ( Object obj , boolean to LHS , Call Stack callstack , Interpreter interpreter ) throws Eval Error , Reflect Error { int index = get Index Aux ( obj , callstack , interpreter , this ) ; if ( to LHS ) return new LHS ( obj , index ) ; else try { return Reflect . get Index ( obj , index ) ; } catch ( Util Eval Error e ) { throw e . to Eval Error ( this , callstack ) ; } }
protected static Method resolve Java Method ( Bsh Class Manager bcm , Class clas , String name , Class [ ] types , boolean static Only ) throws Util Eval Error { if ( clas == null ) throw new Interpreter Error ( STRING ) ; Method method = null ; if ( bcm == null ) Interpreter . debug ( STRING ) ; else method = bcm . get Resolved Method ( clas , name , types , static Only ) ; if ( method == null ) { boolean public Only = ! Capabilities . have Accessibility ( ) ; try { method = find Overloaded Method ( clas , name , types , public Only ) ; } catch ( Security Exception e ) { throw new Util Target Error ( STRING + clas , e ) ; } check Found Static Method ( method , static Only , clas ) ; if ( method != null && ! public Only ) { try { Reflect Manager . RM Set Accessible ( method ) ; } catch ( Util Eval Error e ) { } } if ( method != null && bcm != null ) bcm . cache Resolved Method ( clas , types , method ) ; } return method ; }
private Object do Index ( Object obj , boolean to LHS , Call Stack callstack , Interpreter interpreter ) throws Eval Error , Reflect Error { int index = get Index Aux ( obj , callstack , interpreter , this ) ; if ( to LHS ) return new LHS ( obj , index ) ; else try { return Reflect . get Index ( obj , index ) ; } catch ( Util Eval Error e ) { throw e . to Eval Error ( this , callstack ) ; } }
private void fft ( double re [ ] , double im [ ] , int direction ) { int n = re . length ; int bits = ( int ) Math . rint ( Math . log ( n ) / Math . log ( NUM ) ) ; if ( n != ( NUM << bits ) ) throw new Illegal Argument Exception ( STRING ) ; int local N ; int j = NUM ; for ( int i = NUM ; i < n - NUM ; i ++ ) { if ( i < j ) { double temp = re [ j ] ; re [ j ] = re [ i ] ; re [ i ] = temp ; temp = im [ j ] ; im [ j ] = im [ i ] ; im [ i ] = temp ; } int k = n / NUM ; while ( ( k >= NUM ) && ( k - NUM < j ) ) { j = j - k ; k = k / NUM ; } j = j + k ; } for ( int m = NUM ; m <= bits ; m ++ ) { local N = NUM << m ; double Wjk r = NUM ; double Wjk i = NUM ; double theta = two PI / local N ; double Wj r = Math . cos ( theta ) ; double Wj i = direction * Math . sin ( theta ) ; int nby 2 = local N / NUM ; for ( j = NUM ; j < nby 2 ; j ++ ) { for ( int k = j ; k < n ; k += local N ) { int id = k + nby 2 ; double tempr = Wjk r * re [ id ] - Wjk i * im [ id ] ; double tempi = Wjk r * im [ id ] + Wjk i * re [ id ] ; re [ id ] = re [ k ] - tempr ; im [ id ] = im [ k ] - tempi ; re [ k ] += tempr ; im [ k ] += tempi ; } double wtemp = Wjk r ; Wjk r = Wj r * Wjk r - Wj i * Wjk i ; Wjk i = Wj r * Wjk i + Wj i * wtemp ; } } }
public Client add Client ( SSO Token token , String client Type , Map c Map , boolean store ) throws AM Client Cap Exception { Client client = null ; if ( ( c Map == null ) || ( c Map . is Empty ( ) ) ) { return client ; } if ( debug . message Enabled ( ) ) { debug . message ( CLASS + STRING + c Map ) ; } if ( store ) { synchronized ( internal Client Data ) { int Cap Instance . add Client ( token , c Map ) ; c Map = merge With Parent ( c Map ) ; internal Client Data . put ( client Type , c Map ) ; } } else { c Map = merge With Parent ( c Map ) ; } client = add To Indexes ( client Type , c Map , store ) ; if ( ! store ) { loaded Clients Map . put ( client Type , client ) ; } return client ; }
private void delete Current File ( File file To Delete ) throws IO Exception { logger . info ( STRING , file To Delete ) ; if ( ! file To Delete . exists ( ) ) { logger . warn ( STRING , file To Delete ) ; return ; } if ( ! file To Delete . delete ( ) ) { throw new IO Exception ( STRING + file To Delete ) ; } delete Meta File ( ) ; }
private void add Export Add Volume Steps ( Workflow workflow , Protection System rp System , URI export Group ID , Map < URI , Integer > snapshots ) throws Internal Exception { Export Group export Group = db Client . query Object ( Export Group . class , export Group ID ) ; String export Step = workflow . create Step Id ( ) ; init Task Status ( export Group , export Step , Operation . Status . pending , STRING ) ; Map < URI , Map < URI , Integer > > storage To Block Objects = get Storage To Block Objects ( snapshots ) ; for ( Map . Entry < URI , Map < URI , Integer > > entry : storage To Block Objects . entry Set ( ) ) { log . info ( String . format ( STRING , export Group . get Id ( ) , entry . get Key ( ) , entry . get Value ( ) ) ) ; export Wf Utils . generate Export Group Add Volumes ( workflow , null , STEP ENABLE IMAGE ACCESS , entry . get Key ( ) , export Group ID , entry . get Value ( ) ) ; } log . info ( STRING + export Group . get Id ( ) ) ; }
public Hessian Debug State ( Print Writer dbg ) { dbg = dbg ; state = new Initial State ( ) ; }
private boolean are Swc File Checksums Equal ( ) { if ( swc File Checksums == null ) { if ( Trace . swc Checksum ) { Trace . trace ( STRING ) ; } return BOOL ; } Map < String , Virtual File > swc Files = swc Context . get Files ( ) ; Set < Map . Entry < String , Long > > data Set = swc File Checksums . entry Set ( ) ; if ( swc Files . size ( ) < data Set . size ( ) ) { if ( Trace . swc Checksum ) { Trace . trace ( STRING ) ; } return BOOL ; } for ( Map . Entry < String , Long > entry : data Set ) { String filename = entry . get Key ( ) ; Long data File Last Modified = entry . get Value ( ) ; Long swc File Last Modified = null ; Virtual File swc File = swc Files . get ( filename ) ; if ( swc File != null ) { swc File Last Modified = new Long ( swc File . get Last Modified ( ) ) ; } if ( ! data File Last Modified . equals ( swc File Last Modified ) ) { if ( Trace . swc Checksum ) { Trace . trace ( STRING ) ; Trace . trace ( STRING + filename ) ; Trace . trace ( STRING + data File Last Modified ) ; Trace . trace ( STRING + swc File Last Modified ) ; } return BOOL ; } } if ( Trace . swc Checksum ) { Trace . trace ( STRING ) ; } return BOOL ; }
private void adjust Min Pref For Spanning Comps ( Dim Constraint [ ] specs , Float [ ] def Push , Flow Size Spec fss , Array List < Linked Dim Group > [ ] groups Lists ) { for ( int r = groups Lists . length - NUM ; r >= NUM ; r -- ) { Array List < Linked Dim Group > groups = groups Lists [ r ] ; for ( Linked Dim Group group : groups ) { if ( group . span == NUM ) continue ; int [ ] sizes = group . get Min Pref Max ( ) ; for ( int s = Layout Util . MIN ; s <= Layout Util . PREF ; s ++ ) { int c Size = sizes [ s ] ; if ( c Size == Layout Util . NOT SET ) continue ; int row Size = NUM ; int s Ix = ( r << NUM ) + NUM ; int len = Math . min ( ( group . span << NUM ) , fss . sizes . length - s Ix ) - NUM ; for ( int j = s Ix ; j < s Ix + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != Layout Util . NOT SET ) row Size += sz ; } if ( row Size < c Size && len > NUM ) { for ( int eagerness = NUM , new Row Size = NUM ; eagerness < NUM && new Row Size < c Size ; eagerness ++ ) new Row Size = fss . expand Sizes ( specs , def Push , c Size , s Ix , len , s , eagerness ) ; } } } } }
public static String to HEX String ( String input ) { String hex Tab = STRING ; String Builder output = new String Builder ( ) ; int x ; for ( int i = NUM ; i < input . length ( ) ; i ++ ) { x = char Code At ( input , i ) ; output . append ( hex Tab . char At ( ( x > > > NUM ) & NUM ) ) ; output . append ( hex Tab . char At ( x & NUM ) ) ; } return output . to String ( ) ; }
public static String read File To String ( File file ) { if ( file == null ) { return null ; } Buffered Reader reader = null ; try { reader = new Buffered Reader ( new File Reader ( file ) ) ; String Builder file Contents = new String Builder ( STRING ) ; boolean is First Line = BOOL ; String current Line = reader . read Line ( ) ; while ( current Line != null ) { if ( is First Line ) is First Line = BOOL ; else file Contents . append ( System . line Separator ( ) ) ; file Contents . append ( current Line ) ; current Line = reader . read Line ( ) ; } return file Contents . to String ( ) ; } catch ( Exception e ) { logger . debug ( e . to String ( ) + System . line Separator ( ) + Stack Trace . get String From Stack Trace ( e ) ) ; return null ; } finally { try { if ( reader != null ) { reader . close ( ) ; } } catch ( Exception e ) { logger . debug ( e . to String ( ) + System . line Separator ( ) + Stack Trace . get String From Stack Trace ( e ) ) ; } } }
private Coder Result control Sequence ( short new Byte ) { if ( new Byte >= NUM && new Byte <= NUM ) { if ( state == CONTROL SEQUENCE IF ) { return malformed Input ( ERR CTRLPI ) ; } queue . write ( new Byte ) ; } else if ( new Byte >= NUM && new Byte <= NUM ) { state = CONTROL SEQUENCE IF ; queue . write ( new Byte ) ; } else if ( new Byte >= NUM && new Byte <= NUM ) { state = NORMAL BYTES ; queue . reset ( ) ; } else { return malformed Input ( ERR CTRLBYTE ) ; } return Coder Result . UNDERFLOW ; }
@ Nullable public static Network Parameters from Pmt Protocol ID ( String pmt Protocol Id ) { if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID MAINNET ) ) { return Main Net Params . get ( ) ; } else if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID TESTNET ) ) { return Test Net 3 Params . get ( ) ; } else if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID UNIT TESTS ) ) { return Unit Test Params . get ( ) ; } else if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID REGTEST ) ) { return Reg Test Params . get ( ) ; } else if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID ALPHANET ) ) { return Alpha Net Params . get ( ) ; } else { return null ; } }
public void add Certificates ( Store cert Store ) throws CMS Exception { certs . add All ( CMS Utils . get Certificates From Store ( cert Store ) ) ; }
private static void store Constant Pool ( Data Output Stream dos , List < Constant Pool Info > constant Pool ) throws IO Exception { dos . write Short ( constant Pool . size ( ) ) ; for ( int i = NUM ; i < constant Pool . size ( ) ; ++ i ) { Constant Pool Info cpi = ( Constant Pool Info ) constant Pool . get ( i ) ; if ( cpi == null ) continue ; cpi . store ( dos ) ; } }
protected double angle Between ( Point 2 D v1 , Point 2 D v2 ) { double x1 = v1 . get X ( ) ; double y1 = v1 . get Y ( ) ; double x2 = v2 . get X ( ) ; double y2 = v2 . get Y ( ) ; double cross = x1 * y2 - x2 * y1 ; int cw = NUM ; if ( cross > NUM ) { cw = - NUM ; } double angle = cw * Math . acos ( ( x1 * x2 + y1 * y2 ) / ( Math . sqrt ( x1 * x1 + y1 * y1 ) * Math . sqrt ( x2 * x2 + y2 * y2 ) ) ) ; if ( Double . is Na N ( angle ) ) { angle = NUM ; } return angle ; }
boolean add Index Entry ( Service Type resource Type , String resource Name , String policy Name ) { boolean processed = BOOL ; Resource Match resource Match = resource Type . compare ( this . resource Name , resource Name , BOOL ) ; if ( resource Match . equals ( Resource Match . EXACT MATCH ) ) { policy Names . add ( policy Name ) ; processed = BOOL ; } else if ( resource Match . equals ( Resource Match . SUB RESOURCE MATCH ) ) { Iterator iter = child Entries . iterator ( ) ; while ( ! processed && ( iter . has Next ( ) ) ) { Resource Index Entry resource Index Entry = ( Resource Index Entry ) iter . next ( ) ; if ( resource Index Entry . add Index Entry ( resource Type , resource Name , policy Name ) ) { processed = BOOL ; } } if ( ! processed ) { Resource Index Entry resource Index Entry = new Resource Index Entry ( resource Name , policy Name ) ; Set children = new Hash Set ( ) ; children . add All ( child Entries ) ; Iterator iter 1 = children . iterator ( ) ; while ( iter 1 . has Next ( ) ) { Resource Index Entry rie = ( Resource Index Entry ) iter 1 . next ( ) ; Resource Match rm = resource Type . compare ( resource Name , rie . resource Name , BOOL ) ; if ( rm . equals ( Resource Match . SUB RESOURCE MATCH ) ) { rie . set Parent ( resource Index Entry ) ; } } child Entries . add ( resource Index Entry ) ; processed = BOOL ; } } return processed ; }
public byte [ ] bitcoin Serialize ( ) { if ( header Bytes Valid && transaction Bytes Valid ) { Preconditions . check Not Null ( bytes , STRING ) ; if ( length == bytes . length ) { return bytes ; } else { byte [ ] buf = new byte [ length ] ; System . arraycopy ( bytes , offset , buf , NUM , length ) ; return buf ; } } Byte Array Output Stream stream = new Unsafe Byte Array Output Stream ( length == UNKNOWN LENGTH ? HEADER SIZE + guess Transactions Length ( ) : length ) ; try { write Header ( stream ) ; write Transactions ( stream ) ; } catch ( IO Exception e ) { } return stream . to Byte Array ( ) ; }
@ Override public List < Period > generate Periods ( Date Time Unit date Time Unit ) { Calendar calendar = get Calendar ( ) ; date Time Unit = calendar . minus Years ( date Time Unit , NUM ) ; date Time Unit . set Day ( NUM ) ; date Time Unit . set Month ( NUM ) ; List < Period > periods = Lists . new Array List ( ) ; for ( int i = NUM ; i < NUM ; ++ i ) { periods . add ( create Period ( date Time Unit , calendar ) ) ; date Time Unit = calendar . plus Years ( date Time Unit , NUM ) ; } return periods ; }
@ Override public Set < String > vertex Match Pattern Labels ( ) { return labels . size ( ) == NUM ? labels : Collections . empty Set ( ) ; }
public void move Child View ( int from Group Position , int from Child Position , int to Group Position , int to Child Position ) { Array List < Room Summary > from List = m Summary List By Group Position . get ( from Group Position ) ; Array List < Room Summary > to List = m Summary List By Group Position . get ( to Group Position ) ; Room Summary summary = from List . get ( from Child Position ) ; from List . remove ( from Child Position ) ; if ( to Child Position >= to List . size ( ) ) { to List . add ( summary ) ; } else { to List . add ( to Child Position , summary ) ; } }
public void add Category ( Category category ) { if ( categories == null ) { categories = new Array List < Category > ( ) ; } categories . add ( category ) ; }
private static int Call Object Method V ( JNI Environment env , int obj JREF , int method ID , Address arg Address ) throws Exception { if ( trace JNI ) VM . sys Write ( STRING ) ; Runtime Entrypoints . check JNI Count Down To GC ( ) ; try { Object obj = env . get JNI Ref ( obj JREF ) ; Object return Obj = JNI Helpers . invoke With Var Arg ( obj , method ID , arg Address , null , BOOL ) ; return env . push JNI Ref ( return Obj ) ; } catch ( Throwable unexpected ) { if ( trace JNI ) unexpected . print Stack Trace ( System . err ) ; env . record Exception ( unexpected ) ; return NUM ; } }
private Tuple < Message , Connection > try Other Messages ( ) { List < Tuple < Message , Connection > > messages = new Array List < Tuple < Message , Connection > > ( ) ; Collection < Message > msg Collection = get Message Collection ( ) ; for ( Connection con : get Connections ( ) ) { DTN Host other = con . get Other Node ( get Host ( ) ) ; Prophet Router oth Router = ( Prophet Router ) other . get Router ( ) ; if ( oth Router . is Transferring ( ) ) { continue ; } for ( Message m : msg Collection ) { if ( oth Router . has Message ( m . get Id ( ) ) ) { continue ; } if ( oth Router . get Pred For ( m . get To ( ) ) > get Pred For ( m . get To ( ) ) ) { messages . add ( new Tuple < Message , Connection > ( m , con ) ) ; } } } if ( messages . size ( ) == NUM ) { return null ; } Collections . sort ( messages , new Tuple Comparator ( ) ) ; return try Messages For Connected ( messages ) ; }
private void analyze Seed Document ( Document input Document , Map < String , List < String [ ] > > field Name 2 tokens Array , Map < String , Float > field Name 2 boost ) throws IO Exception { for ( int i = NUM ; i < text Field Names . length ; i ++ ) { String field Name = text Field Names [ i ] ; float boost = NUM ; List < String [ ] > tokenized Values = new Linked List < > ( ) ; if ( field Name . contains ( STRING ) ) { String [ ] field 2 boost = field Name . split ( STRING ) ; field Name = field 2 boost [ NUM ] ; boost = Float . parse Float ( field 2 boost [ NUM ] ) ; } Indexable Field [ ] field Values = input Document . get Fields ( field Name ) ; for ( Indexable Field field Value : field Values ) { Token Stream field Tokens = field Value . token Stream ( field 2 analyzer . get ( field Name ) , null ) ; String [ ] field Tokens Array = get Token Array ( field Tokens ) ; tokenized Values . add ( field Tokens Array ) ; } field Name 2 tokens Array . put ( field Name , tokenized Values ) ; field Name 2 boost . put ( field Name , boost ) ; text Field Names [ i ] = field Name ; } }
public static void cache Internal Item Id ( Consumer Bean consumer Bean , String client Id , Long internal Id ) { final String client Id Key = Mem Cache Keys . get Item Internal Id ( consumer Bean . get Short name ( ) , client Id ) ; Mem Cache Peer . put ( client Id Key , internal Id , Constants . CACHING TIME ) ; }
protected void process Ignore Section ( IXML Reader reader , IXML Entity Resolver entity Resolver ) throws Exception { if ( ! XML Util . check Literal ( reader , STRING ) ) { XML Util . skip Tag ( reader ) ; return ; } XML Util . skip Whitespace ( reader , null ) ; String str = XML Util . read ( reader , STRING ) ; char ch = str . char At ( NUM ) ; if ( ch != STRING ) { XML Util . skip Tag ( reader ) ; return ; } Reader subreader = new CDATA Reader ( reader ) ; subreader . close ( ) ; }
@ Override final Node < K , V > find ( int h , Object k ) { if ( k != null ) { for ( Node < K , V > e = first ; e != null ; e = e . next ) { int s ; K ek ; if ( ( ( s = lock State ) & ( WAITER | WRITER ) ) != NUM ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } else if ( U . compare And Swap Int ( this , LOCKSTATE , s , s + READER ) ) { Tree Node < K , V > r , p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k , null ) ) ; } finally { Thread w ; int ls ; do { } while ( ! U . compare And Swap Int ( this , LOCKSTATE , ls = lock State , ls - READER ) ) ; if ( ls == ( READER | WAITER ) && ( w = waiter ) != null ) Lock Support . unpark ( w ) ; } return p ; } } } return null ; }
public static boolean is Public Static Final ( Field field ) { int modifiers = field . get Modifiers ( ) ; return ( Modifier . is Public ( modifiers ) && Modifier . is Static ( modifiers ) && Modifier . is Final ( modifiers ) ) ; }
@ Override public boolean receive Image ( Image To Process img , Set < Task Image Container > tasks , boolean block Until Image Release , boolean close On Image Release , Optional < Runnable > runnable When Done ) throws Interrupted Exception { if ( tasks == null || tasks . size ( ) <= NUM ) { return BOOL ; } if ( img == null ) { throw new Runtime Exception ( STRING ) ; } int count Image Refs = num Propagated Image References ( img , tasks ) ; initialize Task Done ( tasks , runnable When Done ) ; Image Release Protocol protocol = set Semaphore Reference Count ( img , count Image Refs , block Until Image Release , close On Image Release ) ; schedule Tasks ( tasks ) ; if ( protocol . block Until Release ) { protocol . block ( ) ; } return BOOL ; }
private int create Revenue Recognition ( int C Revenue Recognition ID , int C Invoice Line ID , int AD Client ID , int AD Org ID , int AD User ID , int Account ID , int C Sub Acct ID , int M Product ID , int C B Partner ID , int AD Org Trx ID , int C Loc From ID , int C Loc To ID , int C S Region ID , int C Project ID , int C Campaign ID , int C Activity ID , int User 1 ID , int User 2 ID , int User Element 1 ID , int User Element 2 ID ) { log . fine ( STRING + Account ID ) ; M Account revenue = M Account . get ( get Ctx ( ) , AD Client ID , AD Org ID , get C Acct Schema ID ( ) , Account ID , C Sub Acct ID , M Product ID , C B Partner ID , AD Org Trx ID , C Loc From ID , C Loc To ID , C S Region ID , C Project ID , C Campaign ID , C Activity ID , User 1 ID , User 2 ID , User Element 1 ID , User Element 2 ID , null ) ; if ( revenue != null && revenue . get ID ( ) == NUM ) revenue . save Ex ( ) ; if ( revenue == null || revenue . get ID ( ) == NUM ) { log . severe ( STRING ) ; return Account ID ; } int P Revenue Acct = revenue . get ID ( ) ; int Unearned Revenue Acct = NUM ; int new Account ID = NUM ; String sql = STRING + STRING + STRING + STRING + STRING ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; pstmt . set Int ( NUM , get C Acct Schema ID ( ) ) ; pstmt . set Int ( NUM , C B Partner ID ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { Unearned Revenue Acct = rs . get Int ( NUM ) ; new Account ID = rs . get Int ( NUM ) ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( new Account ID == NUM ) { log . severe ( STRING ) ; return Account ID ; } M Revenue Recognition Plan plan = new M Revenue Recognition Plan ( get Ctx ( ) , NUM , null ) ; plan . set C Revenue Recognition ID ( C Revenue Recognition ID ) ; plan . set C Acct Schema ID ( get C Acct Schema ID ( ) ) ; plan . set C Invoice Line ID ( C Invoice Line ID ) ; plan . set Un Earned Revenue Acct ( Unearned Revenue Acct ) ; plan . set P Revenue Acct ( P Revenue Acct ) ; plan . set C Currency ID ( get C Currency ID ( ) ) ; plan . set Total Amt ( get Acct Balance ( ) ) ; if ( ! plan . save ( get Trx Name ( ) ) ) { log . severe ( STRING ) ; return Account ID ; } log . fine ( STRING + Account ID + STRING + new Account ID + STRING + Unearned Revenue Acct + STRING + P Revenue Acct ) ; return new Account ID ; }
private static S2 Cell Id from Face IJ Wrap ( int face , int i , int j ) { i = Math . max ( - NUM , Math . min ( MAX SIZE , i ) ) ; j = Math . max ( - NUM , Math . min ( MAX SIZE , j ) ) ; final double k Scale = NUM / MAX SIZE ; double s = k Scale * ( ( i << NUM ) + NUM - MAX SIZE ) ; double t = k Scale * ( ( j << NUM ) + NUM - MAX SIZE ) ; S2 Point p = S2 Projections . face Uv To Xyz ( face , s , t ) ; face = S2 Projections . xyz To Face ( p ) ; R2 Vector st = S2 Projections . valid Face Xyz To Uv ( face , p ) ; return from Face IJ ( face , st To IJ ( st . x ( ) ) , st To IJ ( st . y ( ) ) ) ; }
public C Module Node Component ( final J Tree project Tree , final I Database database , final I Navi Address Space address Space , final I Navi Module module , final I View Container container ) { super ( new Border Layout ( ) ) ; Preconditions . check Not Null ( database , STRING ) ; this . module = Preconditions . check Not Null ( module , STRING ) ; tabbed Pane . add Tab ( STRING , OVERVIEW ICON , overview Panel = new C Module Overview Panel ( project Tree , database , address Space , module , container ) ) ; tabbed Pane . add Tab ( STRING + String . format ( STRING , module . get Function Count ( ) ) , FUNCTIONS ICON , functions Panel = new C Native Function Views Node Component ( project Tree , database , module , container ) ) ; tabbed Pane . add Tab ( STRING + String . format ( STRING , module . get Custom View Count ( ) ) , VIEWS ICON , views Panel = new C Module Views Container Component ( project Tree , container ) ) ; tabbed Pane . add Tab ( STRING , TRACES ICON , traces Panel = new C Traces Node Component ( project Tree , container ) ) ; tabbed Pane . add Tab ( STRING , DATA ICON , data Panel = new C Data Node Component ( module , container ) ) ; tabbed Pane . set Enabled At ( NUM , module . is Loaded ( ) ) ; tabbed Pane . set Enabled At ( NUM , module . is Loaded ( ) ) ; tabbed Pane . set Enabled At ( NUM , module . is Loaded ( ) ) ; tabbed Pane . set Enabled At ( NUM , module . is Loaded ( ) ) ; module . add Listener ( internal Module Listener ) ; add ( tabbed Pane ) ; lookup . put ( module , this ) ; }
public void close ( ) throws IO Exception { if ( stream != null ) { stream . close ( ) ; } else { reader . close ( ) ; } }
private void build National Number For Parsing ( String number To Parse , String Builder national Number ) { int index Of Phone Context = number To Parse . index Of ( RFC 3966 PHONE CONTEXT ) ; if ( index Of Phone Context > NUM ) { int phone Context Start = index Of Phone Context + RFC 3966 PHONE CONTEXT . length ( ) ; if ( number To Parse . char At ( phone Context Start ) == PLUS SIGN ) { int phone Context End = number To Parse . index Of ( STRING , phone Context Start ) ; if ( phone Context End > NUM ) { national Number . append ( number To Parse . substring ( phone Context Start , phone Context End ) ) ; } else { national Number . append ( number To Parse . substring ( phone Context Start ) ) ; } } int index Of Rfc 3966 Prefix = number To Parse . index Of ( RFC 3966 PREFIX ) ; int index Of National Number = ( index Of Rfc 3966 Prefix >= NUM ) ? index Of Rfc 3966 Prefix + RFC 3966 PREFIX . length ( ) : NUM ; national Number . append ( number To Parse . substring ( index Of National Number , index Of Phone Context ) ) ; } else { national Number . append ( extract Possible Number ( number To Parse ) ) ; } int index Of Isdn = national Number . index Of ( RFC 3966 ISDN SUBADDRESS ) ; if ( index Of Isdn > NUM ) { national Number . delete ( index Of Isdn , national Number . length ( ) ) ; } }
public static void reset Time Comparison Epsilon Micros ( ) { time Comparison Epsilon = initialize Time Epsilon ( ) ; }
public Optional < String > string Value ( ) { return Optional . empty ( ) ; }
private void stat Init ( ) { label 1 . set Label For ( text Field 1 ) ; label 1 . set Text ( STRING ) ; label 1 . set Horizontal Alignment ( J Label . LEADING ) ; text Field 1 . set Background ( Adempiere PLAF . get Info Background ( ) ) ; label 2 . set Label For ( text Field 2 ) ; label 2 . set Text ( STRING ) ; label 2 . set Horizontal Alignment ( J Label . LEADING ) ; text Field 2 . set Background ( Adempiere PLAF . get Info Background ( ) ) ; label 3 . set Label For ( text Field 3 ) ; label 3 . set Text ( STRING ) ; label 3 . set Horizontal Alignment ( J Label . LEADING ) ; text Field 3 . set Background ( Adempiere PLAF . get Info Background ( ) ) ; label 4 . set Label For ( text Field 4 ) ; label 4 . set Text ( STRING ) ; label 4 . set Horizontal Alignment ( J Label . LEADING ) ; text Field 4 . set Background ( Adempiere PLAF . get Info Background ( ) ) ; p criteria Grid . set Layout ( new A Layout ( ) ) ; p criteria Grid . add ( label 1 , new A Layout Constraint ( NUM , NUM ) ) ; p criteria Grid . add ( label 2 , null ) ; p criteria Grid . add ( label 3 , null ) ; p criteria Grid . add ( label 4 , null ) ; p criteria Grid . add ( text Field 1 , new A Layout Constraint ( NUM , NUM ) ) ; p criteria Grid . add ( text Field 2 , null ) ; p criteria Grid . add ( text Field 3 , null ) ; p criteria Grid . add ( text Field 4 , null ) ; }
@ Nullable public Virtual File find File By Relative Path ( @ Not Null @ Non Nls String rel Path ) { if ( rel Path . is Empty ( ) ) return this ; rel Path = String Util . trim Start ( rel Path , STRING ) ; int index = rel Path . index Of ( STRING ) ; if ( index < NUM ) index = rel Path . length ( ) ; String name = rel Path . substring ( NUM , index ) ; Virtual File child ; if ( name . equals ( STRING ) ) { child = this ; } else if ( name . equals ( STRING ) ) { if ( is ( V File Property . SYMLINK ) ) { final Virtual File canonical File = get Canonical File ( ) ; child = canonical File != null ? canonical File . get Parent ( ) : null ; } else { child = get Parent ( ) ; } } else { child = find Child ( name ) ; } if ( child == null ) return null ; if ( index < rel Path . length ( ) ) { return child . find File By Relative Path ( rel Path . substring ( index + NUM ) ) ; } return child ; }
private static String strip Dot Suffix ( final String value ) { if ( value == null ) { return null ; } final int index = value . index Of ( STRING ) ; if ( index != - NUM ) return value . substring ( NUM , index ) ; return value ; }
public void test Execute Null Runnable ( ) { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; try { @ Suppress Warnings ( STRING ) Future < ? > future = e . submit ( ( Runnable ) null ) ; should Throw ( ) ; } catch ( Null Pointer Exception success ) { } } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
private static long read Long ( Input Stream in ) throws IO Exception { int b0 = in . read ( ) ; int b1 = in . read ( ) ; int b2 = in . read ( ) ; int b3 = in . read ( ) ; if ( ( b0 | b1 | b2 | b3 ) == - NUM ) { throw new EOF Exception ( ) ; } int upper = ( b0 << NUM ) | ( b1 << NUM ) | ( b2 << NUM ) | b3 ; b0 = in . read ( ) ; b1 = in . read ( ) ; b2 = in . read ( ) ; b3 = in . read ( ) ; if ( ( b0 | b1 | b2 | b3 ) == - NUM ) { throw new EOF Exception ( ) ; } int lower = ( b0 << NUM ) | ( b1 << NUM ) | ( b2 << NUM ) | b3 ; return ( ( long ) upper << NUM ) | ( lower & NUM ) ; }
public synchronized String format ( long in Date ) { long seconds = in Date / NUM ; if ( seconds < last Seconds || last Seconds > NUM && seconds > last Seconds + hit Window ) { Date d = new Date ( in Date ) ; return tz Format . format ( d ) ; } if ( last Seconds == seconds ) return last Result ; Date d = new Date ( in Date ) ; long minutes = seconds / NUM ; if ( last Minutes != minutes ) { last Minutes = minutes ; sec Format String = min Format . format ( d ) ; int i = sec Format String . index Of ( STRING ) ; int l = NUM ; sec Format String 0 = sec Format String . substring ( NUM , i ) ; sec Format String 1 = sec Format String . substring ( i + l ) ; } last Seconds = seconds ; String Builder sb = new String Builder ( sec Format String . length ( ) ) ; sb . append ( sec Format String 0 ) ; int s = ( int ) ( seconds % NUM ) ; if ( s < NUM ) sb . append ( STRING ) ; sb . append ( s ) ; sb . append ( sec Format String 1 ) ; last Result = sb . to String ( ) ; return last Result ; }
public void clear Results ( ) { m Results . clear ( ) ; m Model . clear ( ) ; m Objs . clear ( ) ; System . gc ( ) ; }
@ Override public Graph Query has ( final String key , final Predicate predicate , final Object value ) { if ( ! known Predicates . contains ( predicate . get Class ( ) ) ) { throw new Illegal Argument Exception ( ) ; } criteria . add ( new Has ( key , value , Bigdata Predicate . to Bigdata Predicate ( predicate ) ) ) ; return this ; }
public Attr Set read ( java . security . Principal principal , Guid guid ) throws UMS Exception { return read ( principal , guid , null ) ; }
private static void write Input Stream To Output Stream ( Input Stream input Stream , Output Stream output Stream ) { try { try { final byte [ ] buffer = new byte [ NUM ] ; int read ; while ( ( read = input Stream . read ( buffer ) ) != - NUM ) { output Stream . write ( buffer , NUM , read ) ; } output Stream . flush ( ) ; } catch ( final Exception e ) { e . print Stack Trace ( ) ; } finally { output Stream . close ( ) ; input Stream . close ( ) ; } } catch ( final Exception e ) { e . print Stack Trace ( ) ; } }
public void add Members To Relation ( Relation relation , Array List < Osm Element > members ) { dirty = BOOL ; for ( Osm Element e : members ) { undo . save ( e ) ; Relation Member rm = new Relation Member ( STRING , e ) ; relation . add Member ( rm ) ; e . add Parent Relation ( relation ) ; } relation . update State ( Osm Element . STATE MODIFIED ) ; insert Element Safe ( relation ) ; }
protected void drop Phase 1 Objective ( ) { if ( get Num Objective Functions ( ) == NUM ) { return ; } final Set < Integer > columns To Drop = new Tree Set < Integer > ( ) ; columns To Drop . add ( NUM ) ; for ( int i = get Num Objective Functions ( ) ; i < get Artificial Variable Offset ( ) ; i ++ ) { final double entry = get Entry ( NUM , i ) ; if ( Precision . compare To ( entry , NUM , epsilon ) > NUM ) { columns To Drop . add ( i ) ; } } for ( int i = NUM ; i < get Num Artificial Variables ( ) ; i ++ ) { int col = i + get Artificial Variable Offset ( ) ; if ( get Basic Row ( col ) == null ) { columns To Drop . add ( col ) ; } } final double [ ] [ ] matrix = new double [ get Height ( ) - NUM ] [ get Width ( ) - columns To Drop . size ( ) ] ; for ( int i = NUM ; i < get Height ( ) ; i ++ ) { int col = NUM ; for ( int j = NUM ; j < get Width ( ) ; j ++ ) { if ( ! columns To Drop . contains ( j ) ) { matrix [ i - NUM ] [ col ++ ] = get Entry ( i , j ) ; } } } Integer [ ] drop = columns To Drop . to Array ( new Integer [ columns To Drop . size ( ) ] ) ; for ( int i = drop . length - NUM ; i >= NUM ; i -- ) { column Labels . remove ( ( int ) drop [ i ] ) ; } this . tableau = new Array 2 D Row Real Matrix ( matrix ) ; this . num Artificial Variables = NUM ; initialize Basic Variables ( get Num Objective Functions ( ) ) ; }
@ Override public void mouse Released ( Mouse Event e ) { synchronized ( mouse Lock ) { mouse Pressed = BOOL ; } if ( e . get Button ( ) == Mouse Event . BUTTON 1 ) { for ( Draw Listener listener : listeners ) listener . mouse Released ( user X ( e . get X ( ) ) , user Y ( e . get Y ( ) ) ) ; } }
public SIP Response create Response ( int status Code , String reason Phrase ) { SIP Response new Response ; new Response = new SIP Response ( ) ; try { new Response . set Status Code ( status Code ) ; } catch ( Parse Exception ex ) { throw new Illegal Argument Exception ( STRING + status Code ) ; } if ( reason Phrase != null ) new Response . set Reason Phrase ( reason Phrase ) ; else new Response . set Reason Phrase ( SIP Response . get Reason Phrase ( status Code ) ) ; for ( String header Name : headers To Include In Response ) { SIP Header next Header = header Table . get ( header Name ) ; if ( next Header != null ) { if ( ! ( next Header instanceof Record Route List ) || ( next Header instanceof Record Route List && must Copy RR ( status Code ) ) ) { try { new Response . attach Header ( ( SIP Header ) next Header . clone ( ) , BOOL ) ; } catch ( SIP Duplicate Header Exception e ) { e . print Stack Trace ( ) ; } } } } if ( Message Factory Impl . get Default Server Header ( ) != null ) { new Response . set Header ( Message Factory Impl . get Default Server Header ( ) ) ; } Server Header server = Message Factory Impl . get Default Server Header ( ) ; if ( server != null ) { new Response . set Header ( server ) ; } return new Response ; }
public static String encode XML ( String text ) { if ( text == null ) { return null ; } final String Builder result = new String Builder ( ) ; final String Character Iterator iterator = new String Character Iterator ( text ) ; char character = iterator . current ( ) ; while ( character != Character Iterator . DONE ) { if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else if ( character == STRING ) { result . append ( STRING ) ; } else { result . append ( character ) ; } character = iterator . next ( ) ; } return result . to String ( ) ; }
protected void exit ( int code ) { System . exit ( code ) ; }
public void test ( int event Type ) throws Math Illegal Argument Exception , Math Illegal State Exception { double e = NUM ; ODE Integrator integrator = new Dormand Prince 853 Integrator ( e , NUM , NUM , NUM ) ; Base Secant Solver root Solver = new Pegasus Solver ( e , e ) ; ODE Event Handler evt 1 = new Event ( NUM , event Type ) ; ODE Event Handler evt 2 = new Event ( NUM , event Type ) ; integrator . add Event Handler ( evt 1 , NUM , e , NUM , root Solver ) ; integrator . add Event Handler ( evt 2 , NUM , e , NUM , root Solver ) ; double t = NUM ; double t End = NUM ; double [ ] y = { NUM , NUM } ; List < Double > events 1 = new Array List < Double > ( ) ; List < Double > events 2 = new Array List < Double > ( ) ; while ( t < t End ) { final ODE State And Derivative final State = integrator . integrate ( this , new ODE State ( t , y ) , t End ) ; t = final State . get Time ( ) ; y = final State . get Primary State ( ) ; if ( y [ NUM ] >= NUM ) { y [ NUM ] = NUM ; events 1 . add ( t ) ; } if ( y [ NUM ] >= NUM ) { y [ NUM ] = NUM ; events 2 . add ( t ) ; } } Assert . assert Equals ( EVENT TIMES 1 . length , events 1 . size ( ) ) ; Assert . assert Equals ( EVENT TIMES 2 . length , events 2 . size ( ) ) ; for ( int i = NUM ; i < EVENT TIMES 1 . length ; i ++ ) { Assert . assert Equals ( EVENT TIMES 1 [ i ] , events 1 . get ( i ) , NUM ) ; } for ( int i = NUM ; i < EVENT TIMES 2 . length ; i ++ ) { Assert . assert Equals ( EVENT TIMES 2 [ i ] , events 2 . get ( i ) , NUM ) ; } }
public static final void write Int Array Xml ( int [ ] val , String name , Xml Serializer out ) throws Xml Pull Parser Exception , java . io . IO Exception { if ( val == null ) { out . start Tag ( null , STRING ) ; out . end Tag ( null , STRING ) ; return ; } out . start Tag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int n = val . length ; out . attribute ( null , STRING , Integer . to String ( n ) ) ; for ( int i = NUM ; i < n ; i ++ ) { out . start Tag ( null , STRING ) ; out . attribute ( null , STRING , Integer . to String ( val [ i ] ) ) ; out . end Tag ( null , STRING ) ; } out . end Tag ( null , STRING ) ; }
private Spannable highlight User Handles ( Spannable text ) { if ( text == null ) { return null ; } final Matcher matcher = PATTERN USER HANDLES . matcher ( text ) ; while ( matcher . find ( ) ) { final int start = matcher . start ( NUM ) ; final int end = matcher . end ( NUM ) ; text . set Span ( new Foreground Color Span ( m Highlight Color ) , start , end , Spanned . SPAN EXCLUSIVE EXCLUSIVE ) ; text . set Span ( new Style Span ( android . graphics . Typeface . BOLD ) , start , end , Spanned . SPAN EXCLUSIVE EXCLUSIVE ) ; } return text ; }
protected int read Block ( ) { block Size = read ( ) ; int n = NUM ; if ( block Size > NUM ) { try { int count = NUM ; while ( n < block Size ) { count = in . read ( block , n , block Size - n ) ; if ( count == - NUM ) break ; n += count ; } } catch ( IO Exception e ) { } if ( n < block Size ) { status = STATUS FORMAT ERROR ; } } return n ; }
protected Action Argument Value [ ] read Argument Values ( Node List node List , Action Argument [ ] args ) throws Action Exception { List < Node > nodes = get Matching Nodes ( node List , args ) ; Action Argument Value [ ] values = new Action Argument Value [ args . length ] ; for ( int i = NUM ; i < args . length ; i ++ ) { Action Argument arg = args [ i ] ; Node node = find Action Argument Node ( nodes , arg ) ; if ( node == null ) { throw new Action Exception ( Error Code . ARGUMENT VALUE INVALID , STRING + arg . get Name ( ) + STRING ) ; } log . fine ( STRING + arg . get Name ( ) ) ; String value = XML Util . get Text Content ( node ) ; values [ i ] = create Value ( arg , value ) ; } return values ; }
private Http Entity execute Post ( String url , String [ ] [ ] post Params , String [ ] [ ] header Params ) throws IO Exception { List < Name Value Pair > formparams = new Array List < Name Value Pair > ( ) ; for ( String [ ] param : post Params ) { if ( param [ NUM ] != null && param [ NUM ] != null ) { formparams . add ( new Basic Name Value Pair ( param [ NUM ] , param [ NUM ] ) ) ; } } Url Encoded Form Entity entity = new Url Encoded Form Entity ( formparams , STRING ) ; return execute Post ( url , entity , header Params ) ; }
public Image rotate 270 Degrees ( Image image , boolean maintain Opacity ) { int [ ] rgb = image . get RGB ( ) ; int [ ] new RGB = new int [ rgb . length ] ; int width = image . get Width ( ) ; int height = image . get Height ( ) ; for ( int y = NUM ; y < height ; y ++ ) { for ( int x = NUM ; x < width ; x ++ ) { new RGB [ y + x * height ] = rgb [ x + y * width ] ; } } return Encoded Image . create From RGB ( new RGB , height , width , ! maintain Opacity ) ; }
public Serbian Normalization Filter Factory ( Map < String , String > args ) { super ( args ) ; this . haircut = get ( args , STRING , Arrays . as List ( STRING , STRING ) , STRING ) ; if ( ! args . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING + args ) ; } }
public static < T > T wrap Throw ( Callable < T > callable ) { try { return callable . call ( ) ; } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
public static String pad ( String str , int total Chars ) { if ( str == null ) str = STRING ; int slen = str . length ( ) ; String Buffer sb = new String Buffer ( str ) ; for ( int i = NUM ; i < total Chars - slen ; i ++ ) { sb . append ( STRING ) ; } return sb . to String ( ) ; }
protected void decode Image Data ( ) { int Null Code = - NUM ; int npix = iw * ih ; int available , clear , code mask , code size , end of information , in code , old code , bits , code , count , i , datum , data size , first , top , bi , pi ; if ( ( pixels == null ) || ( pixels . length < npix ) ) { pixels = new byte [ npix ] ; } if ( prefix == null ) prefix = new short [ Max Stack Size ] ; if ( suffix == null ) suffix = new byte [ Max Stack Size ] ; if ( pixel Stack == null ) pixel Stack = new byte [ Max Stack Size + NUM ] ; data size = read ( ) ; clear = NUM << data size ; end of information = clear + NUM ; available = clear + NUM ; old code = Null Code ; code size = data size + NUM ; code mask = ( NUM << code size ) - NUM ; for ( code = NUM ; code < clear ; code ++ ) { prefix [ code ] = NUM ; suffix [ code ] = ( byte ) code ; } datum = bits = count = first = top = pi = bi = NUM ; for ( i = NUM ; i < npix ; ) { if ( top == NUM ) { if ( bits < code size ) { if ( count == NUM ) { count = read Block ( ) ; if ( count <= NUM ) break ; bi = NUM ; } datum += ( block [ bi ] & NUM ) << bits ; bits += NUM ; bi ++ ; count -- ; continue ; } code = datum & code mask ; datum >>= code size ; bits -= code size ; if ( ( code > available ) || ( code == end of information ) ) break ; if ( code == clear ) { code size = data size + NUM ; code mask = ( NUM << code size ) - NUM ; available = clear + NUM ; old code = Null Code ; continue ; } if ( old code == Null Code ) { pixel Stack [ top ++ ] = suffix [ code ] ; old code = code ; first = code ; continue ; } in code = code ; if ( code == available ) { pixel Stack [ top ++ ] = ( byte ) first ; code = old code ; } while ( code > clear ) { pixel Stack [ top ++ ] = suffix [ code ] ; code = prefix [ code ] ; } first = suffix [ code ] & NUM ; if ( available >= Max Stack Size ) break ; pixel Stack [ top ++ ] = ( byte ) first ; prefix [ available ] = ( short ) old code ; suffix [ available ] = ( byte ) first ; available ++ ; if ( ( ( available & code mask ) == NUM ) && ( available < Max Stack Size ) ) { code size ++ ; code mask += available ; } old code = in code ; } top -- ; pixels [ pi ++ ] = pixel Stack [ top ] ; i ++ ; } for ( i = pi ; i < npix ; i ++ ) { pixels [ i ] = NUM ; } }
public int hash Code ( ) { if ( myhash == - NUM ) { myhash = NUM + ( party == null ? NUM : party . hash Code ( ) ) ; if ( assigner != null ) { myhash = NUM * myhash + assigner . hash Code ( ) ; } } return myhash ; }
public Cygwin Terminal ( Input Stream terminal Input , Output Stream terminal Output , Charset terminal Charset ) throws IO Exception { super ( null , terminal Input , terminal Output , terminal Charset , Ctrl C Behaviour . TRAP ) ; }
public boolean has Value Been Updated ( int row Index , int column Index ) { Scale SLD Data data = scale List . get ( row Index ) ; if ( column Index == COL MIN SCALE ) { return data . is Minimum Scale Updated ( ) ; } if ( column Index == COL MAX SCALE ) { return data . is Maximum Scale Updated ( ) ; } return BOOL ; }
public void check Token ( String token ) { if ( token != null && ! token . is Empty ( ) && ( System . current Time Millis ( ) - token Last Checked ) / NUM > TOKEN CHECK DELAY ) { LOGGER . info ( STRING ) ; token Last Checked = Long . value Of ( System . current Time Millis ( ) ) ; verify Token ( token ) ; } }
protected Package define Package ( String name , String spec Title , String spec Version , String spec Vendor , String impl Title , String impl Version , String impl Vendor , URL seal Base ) throws Illegal Argument Exception { synchronized ( defined Packages ) { if ( get Package ( name ) != null ) { throw new Illegal Argument Exception ( STRING + name + STRING ) ; } Package pkg = new Package ( this , name , spec Title , spec Version , spec Vendor , impl Title , impl Version , impl Vendor , seal Base ) ; defined Packages . put ( name , pkg ) ; return pkg ; } }
@ Override public void action Performed ( Action Event ev ) { final megan . remote . Remote Service Browser remote Service Browser = ( megan . remote . Remote Service Browser ) get Viewer ( ) ; if ( remote Service Browser != null ) { String url = remote Service Browser . get URL ( ) ; if ( url . length ( ) > NUM ) { execute ( STRING + url + STRING ) ; } } }
public static List < Verification Exception > verify Certificates ( Certificate [ ] certs , Key Store keystore , Collection < CRL > crls , Calendar calendar ) { List < Verification Exception > result = new Array List < > ( ) ; for ( int k = NUM ; k < certs . length ; ++ k ) { X509 Certificate cert = ( X509 Certificate ) certs [ k ] ; String err = verify Certificate ( cert , crls , calendar ) ; if ( err != null ) result . add ( new Verification Exception ( cert , err ) ) ; try { for ( X509 Certificate cert Store X 509 : Sign Utils . get Certificates ( keystore ) ) { try { if ( verify Certificate ( cert Store X 509 , crls , calendar ) != null ) continue ; try { cert . verify ( cert Store X 509 . get Public Key ( ) ) ; return result ; } catch ( Exception e ) { continue ; } } catch ( Exception ex ) { } } } catch ( Exception e ) { } int j ; for ( j = NUM ; j < certs . length ; ++ j ) { if ( j == k ) continue ; X509 Certificate cert Next = ( X509 Certificate ) certs [ j ] ; try { cert . verify ( cert Next . get Public Key ( ) ) ; break ; } catch ( Exception e ) { } } if ( j == certs . length ) { result . add ( new Verification Exception ( cert , STRING ) ) ; } } if ( result . size ( ) == NUM ) result . add ( new Verification Exception ( ( Certificate ) null , STRING ) ) ; return result ; }
public static void compress ( ) { String input = Binary Std In . read String ( ) ; TST < Integer > st = new TST < Integer > ( ) ; for ( int i = NUM ; i < R ; i ++ ) st . put ( STRING + ( char ) i , i ) ; int code = R + NUM ; while ( input . length ( ) > NUM ) { String s = st . longest Prefix Of ( input ) ; Binary Std Out . write ( st . get ( s ) , W ) ; int t = s . length ( ) ; if ( t < input . length ( ) && code < L ) st . put ( input . substring ( NUM , t + NUM ) , code ++ ) ; input = input . substring ( t ) ; } Binary Std Out . write ( R , W ) ; Binary Std Out . close ( ) ; }
@ Override public Axis Space reserve Space ( Graphics 2 D g2 , Plot plot , Rectangle 2 D plot Area , Rectangle Edge edge , Axis Space space ) { if ( space == null ) { space = new Axis Space ( ) ; } if ( ! is Visible ( ) ) { return space ; } double dimension = get Fixed Dimension ( ) ; if ( dimension > NUM ) { space . add ( dimension , edge ) ; return space ; } double tick Label Height = NUM ; double tick Label Width = NUM ; if ( is Tick Labels Visible ( ) ) { g2 . set Font ( get Tick Label Font ( ) ) ; List ticks = refresh Ticks ( g2 , new Axis State ( ) , plot Area , edge ) ; if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { tick Label Height = find Maximum Tick Label Height ( ticks , g2 , plot Area , is Vertical Tick Labels ( ) ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { tick Label Width = find Maximum Tick Label Width ( ticks , g2 , plot Area , is Vertical Tick Labels ( ) ) ; } } Rectangle 2 D label Enclosure = get Label Enclosure ( g2 , edge ) ; if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { double label Height = label Enclosure . get Height ( ) ; space . add ( label Height + tick Label Height , edge ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { double label Width = label Enclosure . get Width ( ) ; space . add ( label Width + tick Label Width , edge ) ; } return space ; }
static String sanitize File Name ( String name ) { String Buffer buffer = new String Buffer ( name . length ( ) ) ; for ( int i = NUM ; i < name . length ( ) ; i ++ ) { int code Point = name . code Point At ( i ) ; char character = name . char At ( i ) ; if ( Character . is Letter Or Digit ( character ) || code Point > NUM || is Special Fat 32 ( character ) ) { buffer . append Code Point ( code Point ) ; } else { buffer . append ( STRING ) ; } } String result = buffer . to String ( ) ; return result . replace All ( STRING , STRING ) ; }
@ Override public double [ ] make Inverse Cumulative Test Points ( ) { double [ ] points = make Cumulative Test Values ( ) ; double [ ] points 2 = new double [ points . length - NUM ] ; System . arraycopy ( points , NUM , points 2 , NUM , points 2 . length ) ; return points 2 ; }
public java . lang . String Buffer append ( boolean b ) { internal . append ( b ) ; return this ; }
public void update Server Config Inheritance ( String server Name , Set to Inherit , Set not To Inherit ) throws AM Console Exception { String [ ] param = { server Name } ; log Event ( STRING , param ) ; try { SSO Token sso Token = get User SSO Token ( ) ; Map default Values = Server Configuration . get Defaults ( sso Token ) ; Map svr Properties = Server Configuration . get Server Instance ( sso Token , server Name ) ; if ( ( to Inherit != null ) && ! to Inherit . is Empty ( ) ) { Set to Remove = new Hash Set ( ) ; for ( Iterator i = to Inherit . iterator ( ) ; i . has Next ( ) ; ) { String name = ( String ) i . next ( ) ; if ( svr Properties . contains Key ( name ) ) { to Remove . add ( name ) ; } } if ( ! to Remove . is Empty ( ) ) { Server Configuration . remove Server Configuration ( sso Token , server Name , to Remove ) ; } } if ( ( not To Inherit != null ) && ! not To Inherit . is Empty ( ) ) { Map to Add = new Hash Map ( ) ; for ( Iterator i = not To Inherit . iterator ( ) ; i . has Next ( ) ; ) { String name = ( String ) i . next ( ) ; if ( ! svr Properties . contains Key ( name ) ) { to Add . put ( name , default Values . get ( name ) ) ; } } if ( ! to Add . is Empty ( ) ) { try { Server Configuration . set Server Instance ( sso Token , server Name , to Add ) ; } catch ( Unknown Property Name Exception ex ) { } } } log Event ( STRING , param ) ; } catch ( Configuration Exception e ) { String [ ] params = { server Name , e . get Message ( ) } ; log Event ( STRING , params ) ; throw new AM Console Exception ( get Error String ( e ) ) ; } catch ( IO Exception e ) { String [ ] params = { server Name , e . get Message ( ) } ; log Event ( STRING , params ) ; throw new AM Console Exception ( get Error String ( e ) ) ; } catch ( SMS Exception e ) { String [ ] params = { server Name , e . get Message ( ) } ; log Event ( STRING , params ) ; throw new AM Console Exception ( get Error String ( e ) ) ; } catch ( SSO Exception e ) { String [ ] params = { server Name , e . get Message ( ) } ; log Event ( STRING , params ) ; throw new AM Console Exception ( get Error String ( e ) ) ; } }
public synchronized void return Buf ( byte [ ] buf ) { if ( buf == null || buf . length > m Size Limit ) { return ; } m Buffers By Last Use . add ( buf ) ; int pos = Collections . binary Search ( m Buffers By Size , buf , BUF COMPARATOR ) ; if ( pos < NUM ) { pos = - pos - NUM ; } m Buffers By Size . add ( pos , buf ) ; m Current Size += buf . length ; trim ( ) ; }
public boolean contains ( terminal sym ) throws internal error { not null ( sym ) ; return elements . get ( sym . index ( ) ) ; }
private void create Base Node ( ) throws Keeper Exception , Interrupted Exception { if ( null == zk . exists ( zoo Keeper Location , BOOL ) ) { zk . create ( zoo Keeper Location , new byte [ NUM ] , Ids . OPEN ACL UNSAFE , Create Mode . PERSISTENT ) ; } }
private void enqueue Final Update ( ) { update Handler . remove Messages ( MSG FINAL UPDATE ) ; update Handler . send Message Delayed ( update Handler . obtain Message ( MSG FINAL UPDATE , last Start Id , - NUM ) , NUM * MINUTE IN MILLIS ) ; }
public void tag ( int tag Type 2 , boolean long Tag 3 , byte [ ] contents 2 ) throws IO Exception { byte [ ] contents = contents 2 ; int length = ( contents != null ) ? contents . length : NUM ; boolean long Tag 2 = ( length > NUM ) || long Tag 3 ; int hdr = ( tag Type 2 << NUM ) + ( long Tag 2 ? NUM : length ) ; out . write UI 16 ( hdr ) ; if ( long Tag 2 ) { out . write UI 32 ( length ) ; } if ( contents != null ) { out . write ( contents ) ; } if ( tag Type 2 == SWF Constants . TAG SHOWFRAME ) { frame Count ++ ; } if ( tag Type 2 == SWF Constants . TAG END ) { out . flush ( ) ; contents = bytes . to Byte Array ( ) ; out = null ; bytes = null ; byte [ ] fc = Out Stream . uint To 2 Bytes ( frame Count ) ; contents [ NUM ] = fc [ NUM ] ; contents [ NUM ] = fc [ NUM ] ; tags . tag ( tag Type , long Tag , contents ) ; } }
public int hash Code ( ) { if ( myhash == - NUM ) { myhash = timestamp . hash Code ( ) + signer Cert Path . hash Code ( ) ; } return myhash ; }
public Type Variable BV type Variable ( Type Node type Node ) { Type Variable BV result = type Variable Map . get ( type Node ) ; if ( result == null ) { int id = type Variable List . size ( ) ; type Variable List . add ( null ) ; result = new Type Variable BV ( id , this , type Node ) ; type Variable List . set ( id , result ) ; type Variable Map . put ( type Node , result ) ; } return result ; }
public int process ( Callback [ ] callbacks , int state ) throws Auth Login Exception { debug . message ( STRING ) ; if ( error Msg Key != null ) { debug . message ( STRING ) ; throw new Auth Login Exception ( am Auth MSISDN , error Msg Key , null ) ; } Http Servlet Request req = get Http Servlet Request ( ) ; String gateway = null ; String msisdn Number = null ; if ( req != null ) { gateway = Client Utils . get Client IP Address ( req ) ; msisdn Number = get MSISDN Number From Request ( req ) ; } else { debug . message ( STRING ) ; Map map = send Callback ( ) ; if ( map != null ) { msisdn Number = ( String ) map . get ( STRING ) ; gateway = ( String ) map . get ( STRING ) ; } } if ( is Valid Gateway ( gateway ) && ( msisdn Number != null ) ) { MSISDN Validation msisdn Validation = new MSISDN Validation ( options , debug , bundle , locale ) ; user Token Id = msisdn Validation . get User Id ( msisdn Number ) ; store Username Passwd ( user Token Id , null ) ; } else { debug . error ( STRING ) ; throw new Auth Login Exception ( am Auth MSISDN , STRING , null ) ; } return IS Auth Constants . LOGIN SUCCEED ; }
public static void downto ( Double self , Number to , @ Closure Params ( First Param . class ) Closure closure ) { double to 1 = to . double Value ( ) ; if ( self >= to 1 ) { for ( double i = self ; i >= to 1 ; i -- ) { closure . call ( i ) ; } } else throw new Groovy Runtime Exception ( STRING + to + STRING + self + STRING ) ; }
public void add All ( Collection < Select Clause Element Raw > elements ) { select Clause Elements . add All ( elements ) ; }
public synchronized void remove Pv Change Listener ( Pv Change Listener l ) { ensure Pv Change Listeners ( ) ; Pv Change Listeners . remove ( l ) ; allow Events = ! Pv Change Listeners . is Empty ( ) ; log . trace ( STRING + to String ( ) + STRING + String . value Of ( l ) ) ; }
public static Geo Time Serie normalize ( Geo Time Serie gts ) { if ( ( TYPE . DOUBLE != gts . get Type ( ) && TYPE . LONG != gts . get Type ( ) ) || NUM == gts . values ) { return gts . clone ( ) ; } double dmin = Double . POSITIVE INFINITY ; double dmax = Double . NEGATIVE INFINITY ; long lmin = Long . MAX VALUE ; long lmax = Long . MIN VALUE ; if ( TYPE . LONG == gts . get Type ( ) ) { for ( int i = NUM ; i < gts . values ; i ++ ) { long value = ( long ) GTS Helper . value At Index ( gts , i ) ; if ( value > lmax ) { lmax = value ; } if ( value < lmin ) { lmin = value ; } } } else { for ( int i = NUM ; i < gts . values ; i ++ ) { double value = ( double ) GTS Helper . value At Index ( gts , i ) ; if ( value > dmax ) { dmax = value ; } if ( value < dmin ) { dmin = value ; } } } boolean constant = BOOL ; if ( lmin == lmax || dmin == dmax ) { constant = BOOL ; } Geo Time Serie normalized = new Geo Time Serie ( gts . lastbucket , gts . bucketcount , gts . bucketspan , gts . values ) ; normalized . set Name ( gts . get Name ( ) ) ; normalized . set Labels ( gts . get Labels ( ) ) ; for ( int i = NUM ; i < gts . values ; i ++ ) { Object value ; if ( constant ) { value = NUM ; } else if ( TYPE . LONG == gts . get Type ( ) ) { value = ( ( long ) GTS Helper . value At Index ( gts , i ) - lmin ) / ( double ) ( lmax - lmin ) ; } else { value = ( ( double ) GTS Helper . value At Index ( gts , i ) - dmin ) / ( double ) ( dmax - dmin ) ; } GTS Helper . set Value ( normalized , gts . ticks [ i ] , GTS Helper . location At Index ( gts , i ) , GTS Helper . elevation At Index ( gts , i ) , value , BOOL ) ; } return normalized ; }
public void save To Properties ( Properties properties ) { properties . set Property ( STRING , Boolean . to String ( projected ) ) ; properties . set Property ( STRING , String Util . double Array To String ( tie Point ) ) ; properties . set Property ( STRING , String Util . double Array To String ( scale ) ) ; if ( globe == null ) { globe = Layer Factory . default Globe ; } properties . set Property ( STRING , globe ) ; properties . set Property ( STRING , Integer . to String ( raster Width ) ) ; properties . set Property ( STRING , Integer . to String ( raster Length ) ) ; properties . set Property ( STRING , proj Linear Units ) ; if ( datum Code > NUM ) { properties . set Property ( STRING , Integer . to String ( datum Code ) ) ; } if ( ellipsoid Code > NUM ) { properties . set Property ( STRING , Integer . to String ( ellipsoid Code ) ) ; } if ( ! Double . is Na N ( semi Major Axis ) ) { properties . set Property ( STRING , Double . to String ( semi Major Axis ) ) ; } if ( ! Double . is Na N ( semi Minor Axis ) ) { properties . set Property ( STRING , Double . to String ( semi Minor Axis ) ) ; } if ( ! Double . is Na N ( inverse Flattening ) ) { properties . set Property ( STRING , Double . to String ( inverse Flattening ) ) ; } if ( ! Double . is Na N ( gcs Prime Meridian Lon ) ) { properties . set Property ( STRING , Double . to String ( gcs Prime Meridian Lon ) ) ; } if ( proj Code > NUM ) { properties . set Property ( STRING , Integer . to String ( proj Code ) ) ; } if ( pcs Code > NUM ) { properties . set Property ( STRING , Integer . to String ( pcs Code ) ) ; } if ( coord Transform Code > NUM ) { properties . set Property ( STRING , Integer . to String ( coord Transform Code ) ) ; } if ( ! Double . is Na N ( std Parallel 1 ) ) { properties . set Property ( STRING , Double . to String ( std Parallel 1 ) ) ; } if ( ! Double . is Na N ( std Parallel 2 ) ) { properties . set Property ( STRING , Double . to String ( std Parallel 2 ) ) ; } if ( ! Double . is Na N ( natural Origin Lon ) ) { properties . set Property ( STRING , Double . to String ( natural Origin Lon ) ) ; } if ( ! Double . is Na N ( natural Origin Lat ) ) { properties . set Property ( STRING , Double . to String ( natural Origin Lat ) ) ; } if ( ! Double . is Na N ( false Origin Lon ) ) { properties . set Property ( STRING , Double . to String ( false Origin Lon ) ) ; } if ( ! Double . is Na N ( false Origin Lat ) ) { properties . set Property ( STRING , Double . to String ( false Origin Lat ) ) ; } if ( ! Double . is Na N ( false Easting ) ) { properties . set Property ( STRING , Double . to String ( false Easting ) ) ; } if ( ! Double . is Na N ( false Northing ) ) { properties . set Property ( STRING , Double . to String ( false Northing ) ) ; } if ( ! Double . is Na N ( center Easting ) ) { properties . set Property ( STRING , Double . to String ( center Easting ) ) ; } if ( ! Double . is Na N ( center Northing ) ) { properties . set Property ( STRING , Double . to String ( center Northing ) ) ; } if ( ! Double . is Na N ( center Lon ) ) { properties . set Property ( STRING , Double . to String ( center Lon ) ) ; } if ( ! Double . is Na N ( center Lat ) ) { properties . set Property ( STRING , Double . to String ( center Lat ) ) ; } if ( ! Double . is Na N ( scale At Natural Origin ) ) { properties . set Property ( STRING , Double . to String ( scale At Natural Origin ) ) ; } if ( ! Double . is Na N ( scale At Center ) ) { properties . set Property ( STRING , Double . to String ( scale At Center ) ) ; } if ( ! Double . is Na N ( azimuth ) ) { properties . set Property ( STRING , Double . to String ( azimuth ) ) ; } if ( ! Double . is Na N ( straight Vert Pole Lon ) ) { properties . set Property ( STRING , Double . to String ( straight Vert Pole Lon ) ) ; } if ( gcs Citation != null ) { properties . set Property ( STRING , gcs Citation ) ; } if ( pcs Citation != null ) { properties . set Property ( STRING , pcs Citation ) ; } }
static public double gamma ( double x ) throws Arithmetic Exception { double P [ ] = { NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; double Q [ ] = { - NUM , NUM , - NUM , NUM , NUM , - NUM , NUM , NUM } ; double p , z ; int i ; double q = Math . abs ( x ) ; if ( q > NUM ) { if ( x < NUM ) { p = Math . floor ( q ) ; if ( p == q ) throw new Arithmetic Exception ( STRING ) ; i = ( int ) p ; z = q - p ; if ( z > NUM ) { p += NUM ; z = q - p ; } z = q * Math . sin ( Math . PI * z ) ; if ( z == NUM ) throw new Arithmetic Exception ( STRING ) ; z = Math . abs ( z ) ; z = Math . PI / ( z * stirling Formula ( q ) ) ; return - z ; } else { return stirling Formula ( x ) ; } } z = NUM ; while ( x >= NUM ) { x -= NUM ; z *= x ; } while ( x < NUM ) { if ( x == NUM ) { throw new Arithmetic Exception ( STRING ) ; } else if ( x > - NUM ) { return ( z / ( ( NUM + NUM * x ) * x ) ) ; } z /= x ; x += NUM ; } while ( x < NUM ) { if ( x == NUM ) { throw new Arithmetic Exception ( STRING ) ; } else if ( x < NUM ) { return ( z / ( ( NUM + NUM * x ) * x ) ) ; } z /= x ; x += NUM ; } if ( ( x == NUM ) || ( x == NUM ) ) return z ; x -= NUM ; p = Polynomial . polevl ( x , P , NUM ) ; q = Polynomial . polevl ( x , Q , NUM ) ; return z * p / q ; }
public void start ( int total Seeds , int max NFE ) { this . total Seeds = total Seeds ; this . max NFE = max NFE ; last Seed = NUM ; last NFE = NUM ; current Seed = NUM ; current NFE = NUM ; statistics . clear ( ) ; start Time = System . current Time Millis ( ) ; last Time = start Time ; }
public static Parse Result parse ( String expression , String epl Statement Error Msg , boolean add Please Check , Parse Rule Selector parse Rule Selector , boolean rewrite Script ) throws EP Exception { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + expression ) ; } Char Stream input ; try { input = new No Case Sensitive Stream ( new String Reader ( expression ) ) ; } catch ( IO Exception ex ) { throw new EP Exception ( STRING + expression + STRING , ex ) ; } Esper EPL 2 Grammar Lexer lex = new Lexer ( input ) ; Common Token Stream tokens = new Common Token Stream ( lex ) ; Esper EPL 2 Grammar Parser parser = Parse Helper . new Parser ( tokens ) ; Tree tree ; try { tree = parse Rule Selector . invoke Parse Rule ( parser ) ; } catch ( Recognition Exception ex ) { tokens . fill ( ) ; if ( rewrite Script && is Contains Script Expression ( tokens ) ) { return handle Script Rewrite ( tokens , epl Statement Error Msg , add Please Check , parse Rule Selector ) ; } log . debug ( STRING + expression + STRING , ex ) ; throw Exception Convertor . convert Statement ( ex , epl Statement Error Msg , add Please Check , parser ) ; } catch ( Runtime Exception e ) { try { tokens . fill ( ) ; } catch ( Runtime Exception ex ) { log . debug ( STRING + e . get Message ( ) , e ) ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + epl Statement Error Msg + STRING , e ) ; } if ( e . get Cause ( ) instanceof Recognition Exception ) { if ( rewrite Script && is Contains Script Expression ( tokens ) ) { return handle Script Rewrite ( tokens , epl Statement Error Msg , add Please Check , parse Rule Selector ) ; } throw Exception Convertor . convert Statement ( ( Recognition Exception ) e . get Cause ( ) , epl Statement Error Msg , add Please Check , parser ) ; } else { throw e ; } } if ( rewrite Script && is Contains Script Expression ( tokens ) ) { return handle Script Rewrite ( tokens , epl Statement Error Msg , add Please Check , parse Rule Selector ) ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING ) ; AST Util . dump AST ( tree ) ; } String expression Without Annotation = expression ; if ( tree instanceof Esper EPL 2 Grammar Parser . Start EPL Expression Rule Context ) { Esper EPL 2 Grammar Parser . Start EPL Expression Rule Context epl = ( Esper EPL 2 Grammar Parser . Start EPL Expression Rule Context ) tree ; expression Without Annotation = get No Annotation ( expression , epl . annotation Enum ( ) , tokens ) ; } else if ( tree instanceof Esper EPL 2 Grammar Parser . Start Pattern Expression Rule Context ) { Esper EPL 2 Grammar Parser . Start Pattern Expression Rule Context pattern = ( Esper EPL 2 Grammar Parser . Start Pattern Expression Rule Context ) tree ; expression Without Annotation = get No Annotation ( expression , pattern . annotation Enum ( ) , tokens ) ; } return new Parse Result ( tree , expression Without Annotation , tokens , Collections . < String > empty List ( ) ) ; }
@ Override public synchronized void close ( ) throws IO Exception { buffer = null ; is Closed = BOOL ; notify All ( ) ; }
protected final void add Section Internal ( int position , Section section ) { sections . add ( position , section ) ; }
public static Genome Relationships load ( Buffered Reader reader ) throws IO Exception { final Genome Relationships ped = new Genome Relationships ( ) ; String line ; while ( ( line = reader . read Line ( ) ) != null ) { line = line . trim ( ) ; if ( line . starts With ( STRING ) || line . matches ( STRING ) ) { continue ; } parse Ped Line ( ped , line ) ; } return ped ; }
public Message ( int number Of Parts , Version dest Version ) { this . version = dest Version ; Assert . assert True ( dest Version != null , STRING ) ; parts List = new Part [ number Of Parts ] ; this . number Of Parts = number Of Parts ; for ( int i = NUM ; i < parts List . length ; i ++ ) { parts List [ i ] = new Part ( ) ; } }
public static boolean assert Equals ( final double a , final double b ) { if ( Double . is Na N ( a ) && Double . is Na N ( b ) ) { return BOOL ; } if ( a == b ) { return BOOL ; } throw new Exam Exception ( a + STRING + b ) ; }
public static Map < String , Object > read Json Model ( File js File ) throws IO Exception { try ( Buffered Reader reader = new Buffered Reader ( new File Reader ( js File ) ) ) { String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { if ( ( line . starts With ( STRING ) || line . starts With ( STRING ) || line . starts With ( STRING ) || line . starts With ( STRING ) ) && line . ends With ( STRING ) ) { line = line . substring ( line . index Of ( STRING ) , line . length ( ) - NUM ) ; @ Suppress Warnings ( STRING ) Map < String , Object > rv = ( Map < String , Object > ) JSON Value . parse ( line ) ; return rv ; } } return null ; } }
private static String find First Matching Line ( String data , String prefix ) { if ( data == null ) { return STRING ; } int ix = data . index Of ( prefix ) ; if ( ix >= NUM ) { int iy = data . index Of ( STRING , ix ) ; if ( iy > NUM ) { return data . substring ( ix , iy ) ; } } return STRING ; }
private List < Volume > create Block Volumes ( String volume Name , int num Volumes , URI storage System ) { List < Volume > volumes = new Array List < Volume > ( ) ; for ( int i = NUM ; i <= num Volumes ; i ++ ) { Volume volume = new Volume ( ) ; URI volume URI = URI Util . create Id ( Volume . class ) ; block Volume UR Is . add ( volume URI ) ; volume . set Id ( volume URI ) ; volume . set Label ( volume Name + i ) ; volume . set Storage Controller ( storage System ) ; db Client . create Object ( volume ) ; volumes . add ( volume ) ; } return volumes ; }
@ Suppress Warnings ( STRING ) public < T > Json String Map < T > create Map Dto From Json ( Reader json , Class < T > dto Interface ) throws IO Exception { final Dto Provider < T > dto Provider = get Dto Provider ( dto Interface ) ; final Map < String , Json Element > map ; try { map = gson . from Json ( json , map Type Cache . get ( Json Element . class ) ) ; } catch ( Json Syntax Exception e ) { final Throwable cause = e . get Cause ( ) ; if ( cause instanceof IO Exception ) { throw ( IO Exception ) cause ; } throw e ; } final Map < String , T > result = new Linked Hash Map < > ( map . size ( ) ) ; for ( Map . Entry < String , Json Element > e : map . entry Set ( ) ) { result . put ( e . get Key ( ) , dto Provider . from Json ( e . get Value ( ) ) ) ; } return new Json String Map Impl < > ( result ) ; }
private void search SMS ( String message , String contact Name ) { Array List < Contact > contacts ; send ( R . string . chat sms search start ) ; contacts = Contacts Manager . get Matching Contacts ( s Context , contact Name ) ; if ( contacts . size ( ) > NUM ) { send ( R . string . chat sms search , message , contacts . size ( ) ) ; for ( Contact contact : contacts ) { Array List < Sms > sms List = m Sms Manager . get Sms ( Contacts Manager . get Phones ( s Context , contact . ids ) , message ) ; Collections . sort ( sms List ) ; if ( sms List . size ( ) > NUM ) { send Sms List On Xmpp ( sms List , contact . name , null ) ; } } send ( STRING ) ; } else { send ( R . string . chat no match for , message ) ; } }
public void merge Pre Condition ( ) { if ( pre Condition != null && condition Block != null ) { List < Insn Node > cond Insns = condition Block . get Instructions ( ) ; List < Insn Node > pre Cond Insns = pre Condition . get Instructions ( ) ; pre Cond Insns . add All ( cond Insns ) ; cond Insns . clear ( ) ; cond Insns . add All ( pre Cond Insns ) ; pre Cond Insns . clear ( ) ; pre Condition = null ; } }
public boolean check Error ( ) { Writer delegate = out ; if ( delegate == null ) { return io Error ; } flush ( ) ; return io Error || delegate . check Error ( ) ; }
public List < Pdf Document > extract Page Ranges ( List < Page Range > page Ranges ) { List < Pdf Document > split Documents = new Array List < > ( ) ; for ( Page Range current Page Range : page Ranges ) { Pdf Document current Pdf Document = create Pdf Document ( current Page Range ) ; split Documents . add ( current Pdf Document ) ; pdf Document . copy Pages To ( current Page Range . get All Pages ( ) , current Pdf Document ) ; } return split Documents ; }
private boolean validate End Ip ( Set ip Set ) throws Policy Exception { if ( start Ip == Long . MAX VALUE ) { String args [ ] = { END IP , START IP } ; throw new Policy Exception ( Res Bundle Utils . rb Name , STRING , args , null ) ; } if ( ip Set . size ( ) != NUM ) { String args [ ] = { END IP } ; throw new Policy Exception ( Res Bundle Utils . rb Name , STRING , args , null ) ; } Iterator end Ip Iter = ip Set . iterator ( ) ; try { String end Ip String = ( String ) end Ip Iter . next ( ) ; end Ip = string To Ip ( end Ip String ) ; } catch ( Class Cast Exception ce ) { String args [ ] = { END IP } ; throw new Policy Exception ( Res Bundle Utils . rb Name , STRING , args , ce ) ; } if ( end Ip < start Ip ) { throw new Policy Exception ( Res Bundle Utils . rb Name , STRING , null , null ) ; } return BOOL ; }
public static void check Operational Pattern 1 A Compliance ( List < Partition Pack > partition Packs ) { IMF Error Logger imf Error Logger = new IMF Error Logger Impl ( ) ; for ( Partition Pack partition Pack : partition Packs ) { byte [ ] bytes = partition Pack . get Operational Pattern ( ) ; for ( int i = NUM ; i < bytes . length ; i ++ ) { if ( ( MXF Operational Pattern 1 A . OPERATIONAL PATTERN 1 A KEY MASK [ i ] != NUM ) && ( MXF Operational Pattern 1 A . OPERATIONAL PATTERN 1 A KEY [ i ] != bytes [ i ] ) ) { imf Error Logger . add Error ( IMF Error Logger . IMF Errors . Error Codes . IMF ESSENCE COMPONENT ERROR , IMF Error Logger . IMF Errors . Error Levels . FATAL , MXF Operational Pattern 1 A . OP 1 A EXCEPTION PREFIX + String . format ( STRING , bytes [ i ] , i , MXF Operational Pattern 1 A . OPERATIONAL PATTERN 1 A KEY [ i ] ) ) ; } } if ( partition Pack . get Number Of Essence Container U Ls ( ) < NUM ) { imf Error Logger . add Error ( IMF Error Logger . IMF Errors . Error Codes . IMF ESSENCE COMPONENT ERROR , IMF Error Logger . IMF Errors . Error Levels . FATAL , MXF Operational Pattern 1 A . OP 1 A EXCEPTION PREFIX + String . format ( STRING , partition Pack . get Number Of Essence Container U Ls ( ) ) ) ; } } if ( imf Error Logger . has Fatal Errors ( ) ) { throw new MXF Exception ( String . format ( STRING ) , imf Error Logger ) ; } }
public static String read Line ( ) { String line ; try { line = scanner . next Line ( ) ; } catch ( No Such Element Exception e ) { line = null ; } return line ; }
public static Byte String value Of Base 64 ( final String s ) { if ( s . length ( ) == NUM ) { return EMPTY ; } return Base 64 . decode ( s ) ; }
private void draw Spectrum ( Graphics 2 D graphics ) { Dimension size = get Size ( ) ; Rectangle background = new Rectangle ( NUM , NUM , size . width , size . height ) ; graphics . set Color ( m Color Spectrum Background ) ; graphics . draw ( background ) ; graphics . fill ( background ) ; Gradient Paint gradient = new Gradient Paint ( NUM , ( get Size ( ) . height - m Spectrum Inset ) / NUM , m Color Spectrum Gradient Top , NUM , get Size ( ) . height , m Color Spectrum Gradient Bottom ) ; graphics . set Background ( m Color Spectrum Background ) ; General Path spectrum Shape = new General Path ( ) ; spectrum Shape . move To ( size . get Width ( ) , size . get Height ( ) - m Spectrum Inset ) ; spectrum Shape . line To ( NUM , size . get Height ( ) - m Spectrum Inset ) ; float [ ] bins = get Bins ( ) ; if ( bins != null ) { float inside Height = size . height - m Spectrum Inset ; float scalor = inside Height / - mDB Scale ; float bin Size = ( float ) size . width / ( ( float ) ( bins . length ) ) ; for ( int x = NUM ; x < bins . length ; x ++ ) { float height ; height = bins [ x ] * scalor ; if ( height > inside Height ) { height = inside Height ; } if ( height < NUM ) { height = NUM ; } float x Axis = ( float ) x * bin Size ; spectrum Shape . line To ( x Axis , height ) ; } } else { graphics . set Paint ( gradient ) ; spectrum Shape . line To ( NUM , size . get Height ( ) - m Spectrum Inset ) ; spectrum Shape . line To ( size . get Width ( ) , size . get Height ( ) - m Spectrum Inset ) ; } spectrum Shape . line To ( size . get Width ( ) , size . get Height ( ) - m Spectrum Inset ) ; graphics . set Paint ( gradient ) ; graphics . draw ( spectrum Shape ) ; graphics . fill ( spectrum Shape ) ; graphics . set Paint ( m Color Spectrum Line ) ; graphics . draw ( new Line 2 D . Float ( NUM , size . height - m Spectrum Inset , size . width , size . height - m Spectrum Inset ) ) ; }
public static List < String > match Description Classes ( String desc ) { String pattern = STRING ; Pattern pat = Pattern . compile ( pattern ) ; Matcher m = pat . matcher ( desc ) ; List < String > matches = new Array List < String > ( ) ; while ( m . find ( ) ) { matches . add ( m . group ( ) ) ; } return matches ; }
public Struct Storage Stat [ ] list Storages ( Tracker Server tracker Server , String group Name , String storage Ip Addr ) throws IO Exception { byte [ ] header ; byte [ ] b Group Name ; byte [ ] bs ; int len ; boolean b New Connection ; Socket tracker Socket ; if ( tracker Server == null ) { tracker Server = get Connection ( ) ; if ( tracker Server == null ) { return null ; } b New Connection = BOOL ; } else { b New Connection = BOOL ; } tracker Socket = tracker Server . get Socket ( ) ; Output Stream out = tracker Socket . get Output Stream ( ) ; try { bs = group Name . get Bytes ( Client Global . g charset ) ; b Group Name = new byte [ Proto Common . FDFS GROUP NAME MAX LEN ] ; if ( bs . length <= Proto Common . FDFS GROUP NAME MAX LEN ) { len = bs . length ; } else { len = Proto Common . FDFS GROUP NAME MAX LEN ; } Arrays . fill ( b Group Name , ( byte ) NUM ) ; System . arraycopy ( bs , NUM , b Group Name , NUM , len ) ; int ip Addr Len ; byte [ ] b Ip Addr ; if ( storage Ip Addr != null && storage Ip Addr . length ( ) > NUM ) { b Ip Addr = storage Ip Addr . get Bytes ( Client Global . g charset ) ; if ( b Ip Addr . length < Proto Common . FDFS IPADDR SIZE ) { ip Addr Len = b Ip Addr . length ; } else { ip Addr Len = Proto Common . FDFS IPADDR SIZE - NUM ; } } else { b Ip Addr = null ; ip Addr Len = NUM ; } header = Proto Common . pack Header ( Proto Common . TRACKER PROTO CMD SERVER LIST STORAGE , Proto Common . FDFS GROUP NAME MAX LEN + ip Addr Len , ( byte ) NUM ) ; byte [ ] whole Pkg = new byte [ header . length + b Group Name . length + ip Addr Len ] ; System . arraycopy ( header , NUM , whole Pkg , NUM , header . length ) ; System . arraycopy ( b Group Name , NUM , whole Pkg , header . length , b Group Name . length ) ; if ( ip Addr Len > NUM ) { System . arraycopy ( b Ip Addr , NUM , whole Pkg , header . length + b Group Name . length , ip Addr Len ) ; } out . write ( whole Pkg ) ; Proto Common . Recv Package Info pkg Info = Proto Common . recv Package ( tracker Socket . get Input Stream ( ) , Proto Common . TRACKER PROTO CMD RESP , - NUM ) ; this . errno = pkg Info . errno ; if ( pkg Info . errno != NUM ) { return null ; } Proto Struct Decoder < Struct Storage Stat > decoder = new Proto Struct Decoder < Struct Storage Stat > ( ) ; return decoder . decode ( pkg Info . body , Struct Storage Stat . class , Struct Storage Stat . get Fields Total Size ( ) ) ; } catch ( IO Exception ex ) { if ( ! b New Connection ) { try { tracker Server . close ( ) ; } catch ( IO Exception ex 1 ) { ex 1 . print Stack Trace ( ) ; } } throw ex ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; this . errno = Proto Common . ERR NO EINVAL ; return null ; } finally { if ( b New Connection ) { try { tracker Server . close ( ) ; } catch ( IO Exception ex 1 ) { ex 1 . print Stack Trace ( ) ; } } } }
@ Override public UUID create Exit Node ( UUID parent Node ) { UUID uuid = UUID . random UUID ( ) ; graph Server . add Vertex ( uuid ) ; graph Server . add Edge ( parent Node , uuid ) ; exit Node Map . put ( uuid , parent Node ) ; return uuid ; }
public void delivery Complete ( final I Mqtt Delivery Token token ) { logger . trace ( STRING , token . get Message Id ( ) ) ; }
public static List < ? extends Import Module > perform Import ( @ Non Null Gradle Import importer , @ Non Null Collection < Eclipse Project > projects ) { List < Eclipse Import Module > modules = Lists . new Array List ( ) ; List < Eclipse Import Module > replaced By Dependencies = Lists . new Array List ( ) ; for ( Eclipse Project project : projects ) { Eclipse Import Module module = new Eclipse Import Module ( importer , project ) ; module . initialize ( ) ; if ( module . is Replaced With Dependency ( ) ) { replaced By Dependencies . add ( module ) ; } else { modules . add ( module ) ; } } for ( Eclipse Import Module replaced : replaced By Dependencies ) { assert replaced . get Replace With Dependencies ( ) != null ; Eclipse Project project = replaced . get Project ( ) ; for ( Eclipse Import Module module : modules ) { if ( module . get Project ( ) . get All Libraries ( ) . contains ( project ) ) { module . add Dependencies ( replaced . get Replace With Dependencies ( ) ) ; } } } for ( Eclipse Import Module module : modules ) { module . remove Jar Dependencies ( ) ; } Collections . sort ( modules ) ; return modules ; }
public static void save Photo To SD Card ( Bitmap photo Bitmap , String path , String photo Name ) { if ( check SD Card Available ( ) ) { File dir = new File ( path ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } File photo File = new File ( path , photo Name + STRING ) ; File Output Stream file Output Stream = null ; try { file Output Stream = new File Output Stream ( photo File ) ; if ( photo Bitmap != null ) { if ( photo Bitmap . compress ( Bitmap . Compress Format . PNG , NUM , file Output Stream ) ) { file Output Stream . flush ( ) ; } } } catch ( File Not Found Exception e ) { photo File . delete ( ) ; e . print Stack Trace ( ) ; } catch ( IO Exception e ) { photo File . delete ( ) ; e . print Stack Trace ( ) ; } finally { try { file Output Stream . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } } }
protected Conversation Parser ( final Sentence Implementation sentence ) { String text = sentence . get Original Text ( ) ; if ( text == null ) { text = STRING ; } else if ( text . starts With ( STRING ) ) { text = STRING ; } final String text Without Punctation = detect Sentence Type ( text , sentence ) ; tokenizer = new String Tokenizer ( text Without Punctation ) ; }
protected int hash ( Object key 1 , Object key 2 , Object key 3 , Object key 4 , Object key 5 ) { int h = NUM ; if ( key 1 != null ) { h ^= key 1 . hash Code ( ) ; } if ( key 2 != null ) { h ^= key 2 . hash Code ( ) ; } if ( key 3 != null ) { h ^= key 3 . hash Code ( ) ; } if ( key 4 != null ) { h ^= key 4 . hash Code ( ) ; } if ( key 5 != null ) { h ^= key 5 . hash Code ( ) ; } h += ~ ( h << NUM ) ; h ^= ( h > > > NUM ) ; h += ( h << NUM ) ; h ^= ( h > > > NUM ) ; return h ; }
public void flush ( ) throws IO Exception { output Stream . flush ( ) ; }
private void add Json For Entry ( final String Builder result , Entry entry , boolean include Just Text Fields , boolean include User Was Sign In , boolean user Was Signed In , boolean force Quotation To Note ) throws IO Exception { result . append ( STRING + Json Builder . quote ( entry . get Note Or Title ( STRING ) ) + STRING ) ; result . append ( STRING + Json Builder . quote ( entry . get Quotation ( STRING ) ) + STRING ) ; result . append ( STRING + entry . get Is Public ( ) + STRING ) ; String type To Add = entry . get Type ( ) ; if ( type To Add . equals ( Db Logic . Constants . quotation ) ) { type To Add = Db Logic . Constants . note ; } result . append ( STRING + type To Add + STRING ) ; if ( include User Was Sign In ) { result . append ( STRING + user Was Signed In + STRING ) ; } if ( include Just Text Fields ) { result . append ( STRING + Json Builder . quote ( get Note Html ( entry , BOOL , entry . has Quotation ( ) , BOOL ) ) + STRING ) ; result . append ( STRING + Json Builder . quote ( get Quotation Html ( entry , BOOL ) ) + STRING ) ; } else { final String Builder inner Result = new String Builder ( ) ; add Entry Html To Tree Simple ( entry , inner Result , null , NUM , ! entry . is Notebook ( ) ) ; result . append ( STRING + Json Builder . quote ( inner Result . to String ( ) ) + STRING ) ; } }
private boolean handle Before Slide Changed ( ) { Fragment current Fragment = m Pager Adapter . get Item ( pager . get Current Item ( ) ) ; Log Helper . d ( TAG , String . format ( STRING , current Fragment ) ) ; if ( current Fragment instanceof I Slide Policy ) { I Slide Policy slide = ( I Slide Policy ) current Fragment ; Log Helper . d ( TAG , STRING ) ; if ( ! slide . is Policy Respected ( ) ) { Log Helper . d ( TAG , STRING ) ; return BOOL ; } } Log Helper . d ( TAG , STRING ) ; return BOOL ; }
public Vcf Record next ( ) throws IO Exception { if ( m Current . size ( ) == NUM ) { throw new Illegal State Exception ( STRING ) ; } final Vcf Record rec = m Current . poll ( ) ; set Next ( ) ; return rec ; }
public static boolean substring Match ( Char Sequence str , int index , Char Sequence substring ) { for ( int j = NUM ; j < substring . length ( ) ; j ++ ) { int i = index + j ; if ( i >= str . length ( ) || str . char At ( i ) != substring . char At ( j ) ) { return BOOL ; } } return BOOL ; }
protected void end ( ) { stream . println ( STRING ) ; flush ( ) ; }
protected static DNS Task Starter new DNS Task Starter ( Jm DNS Impl jm DNS Impl ) { DNS Task Starter instance = null ; Class Delegate delegate = database Class Delegate . get ( ) ; if ( delegate != null ) { instance = delegate . new DNS Task Starter ( jm DNS Impl ) ; } return ( instance != null ? instance : new DNS Task Starter Impl ( jm DNS Impl ) ) ; }
@ Suppress Warnings ( STRING ) public Data Response paginate List ( Map < String , String > request Params , Query query , String default Sort , Map < String , Query Property > properties ) { return paginate List ( request Params , null , query , default Sort , properties ) ; }
public void deregister Service Provider ( Object provider ) { if ( provider == null ) { throw new Illegal Argument Exception ( STRING ) ; } Iterator regs = get Sub Registries ( provider ) ; while ( regs . has Next ( ) ) { Sub Registry reg = ( Sub Registry ) regs . next ( ) ; reg . deregister Service Provider ( provider ) ; } }
public static int calc Diff ( Calendar c1 , long now Ms , int id ) { int presumed Diff ; int step = NUM ; switch ( id ) { case Calendar . YEAR : presumed Diff = ( int ) ( ( now Ms - c1 . get Time In Millis ( ) ) / ( Util . MILLIS IN YEAR - Util . MILLIS IN DAY * NUM ) ) ; break ; case Calendar . MONTH : presumed Diff = ( int ) ( ( now Ms - c1 . get Time In Millis ( ) ) / ( Util . MILLIS IN MONTH - Util . MILLIS IN DAY * NUM ) ) ; break ; case Calendar . WEEK OF MONTH : case Calendar . WEEK OF YEAR : presumed Diff = ( int ) ( ( now Ms - c1 . get Time In Millis ( ) ) / ( Util . MILLIS IN DAY * NUM - Util . MILLIS IN HOUR * NUM ) ) ; step = NUM ; id = Calendar . DATE ; break ; case Calendar . DATE : presumed Diff = ( int ) ( ( now Ms - c1 . get Time In Millis ( ) ) / ( Util . MILLIS IN HOUR * NUM - Util . MILLIS IN MINUTE * NUM ) ) ; break ; case Calendar . HOUR : case Calendar . HOUR OF DAY : return ( int ) ( ( now Ms - c1 . get Time In Millis ( ) ) / Util . MILLIS IN HOUR ) ; case Calendar . MINUTE : return ( int ) ( ( now Ms - c1 . get Time In Millis ( ) ) / Util . MILLIS IN MINUTE ) ; default : throw new Illegal State Exception ( STRING + id + STRING ) ; } return calc Diff 2 ( c1 , now Ms , presumed Diff , id , step ) ; }
public static Range iterate To Find Range Bounds ( XY Dataset dataset , List visible Series Keys , Range x Range , boolean include Interval ) { Param Checks . null Not Permitted ( dataset , STRING ) ; Param Checks . null Not Permitted ( visible Series Keys , STRING ) ; Param Checks . null Not Permitted ( x Range , STRING ) ; double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; if ( include Interval && dataset instanceof OHLC Dataset ) { OHLC Dataset ohlc = ( OHLC Dataset ) dataset ; Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double x = ohlc . get X Value ( series , item ) ; if ( x Range . contains ( x ) ) { double lvalue = ohlc . get Low Value ( series , item ) ; double uvalue = ohlc . get High Value ( series , item ) ; if ( ! Double . is Na N ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . is Na N ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } } } } else if ( include Interval && dataset instanceof Box And Whisker XY Dataset ) { Box And Whisker XY Dataset bx = ( Box And Whisker XY Dataset ) dataset ; Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double x = bx . get X Value ( series , item ) ; if ( x Range . contains ( x ) ) { Number lvalue = bx . get Min Regular Value ( series , item ) ; Number uvalue = bx . get Max Regular Value ( series , item ) ; if ( lvalue != null ) { minimum = Math . min ( minimum , lvalue . double Value ( ) ) ; } if ( uvalue != null ) { maximum = Math . max ( maximum , uvalue . double Value ( ) ) ; } } } } } else if ( include Interval && dataset instanceof Interval XY Dataset ) { Interval XY Dataset ixyd = ( Interval XY Dataset ) dataset ; Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double x = ixyd . get X Value ( series , item ) ; if ( x Range . contains ( x ) ) { double yvalue = ixyd . get Y Value ( series , item ) ; double lvalue = ixyd . get Start Y Value ( series , item ) ; double uvalue = ixyd . get End Y Value ( series , item ) ; if ( ! Double . is Na N ( yvalue ) ) { minimum = Math . min ( minimum , yvalue ) ; maximum = Math . max ( maximum , yvalue ) ; } if ( ! Double . is Na N ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . is Na N ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } } } } else { Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM ; item < item Count ; item ++ ) { double x = dataset . get X Value ( series , item ) ; double y = dataset . get Y Value ( series , item ) ; if ( x Range . contains ( x ) ) { if ( ! Double . is Na N ( y ) ) { minimum = Math . min ( minimum , y ) ; maximum = Math . max ( maximum , y ) ; } } } } } if ( minimum == Double . POSITIVE INFINITY ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
public void write Field ( String name , int value ) throws java . io . IO Exception { write Field ( name , Integer . to String ( value ) ) ; }
public byte [ ] encode Data ( byte [ ] data , int num Error Correction Bytes ) throws Data Too Large Exception { if ( data == null || data . length == NUM ) { return null ; } if ( ( data . length + num Error Correction Bytes ) > NUM ) { throw new Data Too Large Exception ( STRING ) ; } int total Bytes = num Error Correction Bytes + data . length ; int [ ] data Ints = new int [ total Bytes ] ; for ( int i = NUM ; i < data . length ; i ++ ) { data Ints [ i ] = data [ i ] & NUM ; } encoder . encode ( data Ints , num Error Correction Bytes ) ; Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; for ( int i : data Ints ) { bos . write ( i ) ; } return bos . to Byte Array ( ) ; }
public static Array List < String > convert String Array To Array List ( String [ ] string Array ) { if ( string Array != null && string Array . length > NUM ) { return new Array List < > ( Arrays . as List ( string Array ) ) ; } else { return null ; } }
private void prune Scrap Views ( ) { final int max Views = m Active Views . length ; final int view Type Count = m View Type Count ; final Array List < View > [ ] scrap Views = m Scrap Views ; for ( int i = NUM ; i < view Type Count ; ++ i ) { final Array List < View > scrap Pile = scrap Views [ i ] ; int size = scrap Pile . size ( ) ; final int extras = size - max Views ; size -- ; for ( int j = NUM ; j < extras ; j ++ ) { remove Detached View ( scrap Pile . remove ( size -- ) , BOOL ) ; } } if ( m Transient State Views != null ) { for ( int i = NUM ; i < m Transient State Views . size ( ) ; i ++ ) { final View v = m Transient State Views . value At ( i ) ; if ( ! View Compat . has Transient State ( v ) ) { m Transient State Views . remove At ( i ) ; i -- ; } } } }
private boolean check Catalog Existence ( File catalog Parent Folder , boolean check Catalog Folder Only ) { if ( ! catalog Parent Folder . exists ( ) ) { if ( logger . is Trace Enabled ( ) ) logger . trace ( STRING ) ; return BOOL ; } switch ( current Profile . get Device Mode ( ) ) { case Nook : File trook File = new File ( catalog Parent Folder , Constants . TROOK SEARCH DATABASE FILENAME ) ; if ( ! trook File . exists ( ) ) { if ( logger . is Trace Enabled ( ) ) logger . trace ( STRING ) ; return BOOL ; } break ; default : File catalog Folder ; if ( current Profile . get Only Catalog At Target ( ) ) { catalog Folder = catalog Parent Folder ; } else { catalog Folder = new File ( catalog Parent Folder , Catalog Manager . get Catalog Folder Name ( ) ) ; } if ( ( BOOL == catalog Folder . exists ( ) ) && ( BOOL == check Catalog Folder Only ) ) { if ( logger . is Trace Enabled ( ) ) logger . trace ( STRING ) ; return BOOL ; } if ( logger . is Trace Enabled ( ) ) logger . trace ( STRING + catalog Folder . get Path ( ) ) ; if ( ! catalog Folder . exists ( ) ) { if ( logger . is Trace Enabled ( ) ) logger . trace ( STRING ) ; return BOOL ; } File desktop File = new File ( catalog Folder , STRING ) ; if ( ! desktop File . exists ( ) ) { if ( logger . is Trace Enabled ( ) ) logger . trace ( STRING ) ; return BOOL ; } File mobile File = new File ( catalog Folder , STRING ) ; if ( ! mobile File . exists ( ) ) { if ( logger . is Trace Enabled ( ) ) logger . trace ( STRING ) ; return BOOL ; } break ; } if ( logger . is Trace Enabled ( ) ) logger . trace ( STRING ) ; return BOOL ; }
boolean add ( String src Filename , int src Line , int dst Line , boolean is Prefer Last ) { if ( src Filename != null && ( ! src Filename . equals ( src Filename ) || src Filename == null ) ) return BOOL ; if ( dst Line <= dst Line ) { if ( ! is Prefer Last ) return BOOL ; else if ( dst Increment == NUM && repeat == NUM ) { src Line = src Line ; return BOOL ; } else if ( repeat > NUM ) { repeat -- ; return BOOL ; } else if ( dst Increment > NUM ) { dst Increment -- ; return BOOL ; } else return BOOL ; } if ( src Line == src Line ) { dst Increment = dst Line - dst Line + NUM ; return BOOL ; } else if ( dst Line - dst Line == ( src Line - src Line ) * dst Increment ) { repeat = src Line - src Line + NUM ; return BOOL ; } else if ( src Line == src Line + NUM && repeat == NUM ) { dst Increment = dst Line - dst Line ; return BOOL ; } return BOOL ; }
public void add Notification ( @ Not Null Notification notification ) { notifications . add ( notification ) ; Notification Container Item item = new Notification Container Item ( notification , resources ) ; item . set Delegate ( this ) ; int index = n Grid . get Row Count ( ) ; n Grid . resize Rows ( index + NUM ) ; n Grid . set Widget ( index , NUM , item ) ; }
public boolean has Attributes ( ) { return attributes != null && ! attributes . is Empty ( ) ; }
static Optimized Class Descriptor class Descriptor ( Concurrent Map < Class , Optimized Class Descriptor > cls Map , int id , Class Loader ldr , Marshaller Context ctx , Optimized Marshaller Id Mapper mapper ) throws IO Exception , Class Not Found Exception { Class cls ; try { cls = ctx . get Class ( id , ldr ) ; } catch ( Ignite Checked Exception e ) { throw new IO Exception ( STRING + id , e ) ; } Optimized Class Descriptor desc = cls Map . get ( cls ) ; if ( desc == null ) { Optimized Class Descriptor old = cls Map . put If Absent ( cls , desc = new Optimized Class Descriptor ( cls , resolve Type Id ( cls . get Name ( ) , mapper ) , cls Map , ctx , mapper ) ) ; if ( old != null ) desc = old ; } return desc ; }
private void fetch File List ( long gen ) throws IO Exception { Modifiable Solr Params params = new Modifiable Solr Params ( ) ; params . set ( COMMAND , CMD GET FILE LIST ) ; params . set ( GENERATION , String . value Of ( gen ) ) ; params . set ( Common Params . WT , STRING ) ; params . set ( Common Params . QT , STRING ) ; Query Request req = new Query Request ( params ) ; Http Solr Server server = new Http Solr Server ( master Url , my Http Client ) ; try { server . set So Timeout ( NUM ) ; server . set Connection Timeout ( NUM ) ; Named List response = server . request ( req ) ; List < Map < String , Object > > files = ( List < Map < String , Object > > ) response . get ( CMD GET FILE LIST ) ; if ( files != null ) files To Download = Collections . synchronized List ( files ) ; else { files To Download = Collections . empty List ( ) ; LOG . error ( STRING + gen ) ; } files = ( List < Map < String , Object > > ) response . get ( CONF FILES ) ; if ( files != null ) conf Files To Download = Collections . synchronized List ( files ) ; } catch ( Solr Server Exception e ) { throw new IO Exception ( e ) ; } finally { server . shutdown ( ) ; } }
public static DBID Var random Sample ( DBI Ds ids , Random random ) { Array DBI Ds aids = DBID Util . ensure Array ( ids ) ; DBID Var v = DBID Util . new Var ( ) ; aids . assign Var ( random . next Int ( aids . size ( ) ) , v ) ; return v ; }
protected int draw Host Address ( int host Range [ ] ) { if ( host Range [ NUM ] == host Range [ NUM ] ) { return host Range [ NUM ] ; } return host Range [ NUM ] + rng . next Int ( host Range [ NUM ] - host Range [ NUM ] ) ; }
public static String grab Name ( String signature ) { Matcher matcher = sig RE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . group Count ( ) != NUM ) logger . error ( STRING , signature ) ; return matcher . group ( NUM ) ; }
public static Uniform Pair < Event Bean [ ] > flatten List ( Array Deque < Uniform Pair < Event Bean [ ] > > event Vector ) { if ( event Vector . is Empty ( ) ) { return null ; } if ( event Vector . size ( ) == NUM ) { return event Vector . get First ( ) ; } int total New = NUM ; int total Old = NUM ; for ( Uniform Pair < Event Bean [ ] > pair : event Vector ) { if ( pair != null ) { if ( pair . get First ( ) != null ) { total New += pair . get First ( ) . length ; } if ( pair . get Second ( ) != null ) { total Old += pair . get Second ( ) . length ; } } } if ( ( total New + total Old ) == NUM ) { return null ; } Event Bean [ ] result New = null ; if ( total New > NUM ) { result New = new Event Bean [ total New ] ; } Event Bean [ ] result Old = null ; if ( total Old > NUM ) { result Old = new Event Bean [ total Old ] ; } int dest Pos New = NUM ; int dest Pos Old = NUM ; for ( Uniform Pair < Event Bean [ ] > pair : event Vector ) { if ( pair != null ) { if ( pair . get First ( ) != null ) { System . arraycopy ( pair . get First ( ) , NUM , result New , dest Pos New , pair . get First ( ) . length ) ; dest Pos New += pair . get First ( ) . length ; } if ( pair . get Second ( ) != null ) { System . arraycopy ( pair . get Second ( ) , NUM , result Old , dest Pos Old , pair . get Second ( ) . length ) ; dest Pos Old += pair . get Second ( ) . length ; } } } return new Uniform Pair < Event Bean [ ] > ( result New , result Old ) ; }
public V put ( K key , V value ) { final int hash ; int index ; if ( key == null ) { hash = NUM ; index = index Of Null ( ) ; } else { hash = key . hash Code ( ) ; index = index Of ( key , hash ) ; } if ( index >= NUM ) { index = ( index << NUM ) + NUM ; final V old = ( V ) m Array [ index ] ; m Array [ index ] = value ; return old ; } index = ~ index ; if ( m Size >= m Hashes . length ) { final int n = m Size >= ( BASE SIZE * NUM ) ? ( m Size + ( m Size > > NUM ) ) : ( m Size >= BASE SIZE ? ( BASE SIZE * NUM ) : BASE SIZE ) ; if ( DEBUG ) Log . d ( TAG , STRING + m Hashes . length + STRING + n ) ; final int [ ] ohashes = m Hashes ; final Object [ ] oarray = m Array ; alloc Arrays ( n ) ; if ( m Hashes . length > NUM ) { if ( DEBUG ) Log . d ( TAG , STRING + m Size + STRING ) ; System . arraycopy ( ohashes , NUM , m Hashes , NUM , ohashes . length ) ; System . arraycopy ( oarray , NUM , m Array , NUM , oarray . length ) ; } free Arrays ( ohashes , oarray , m Size ) ; } if ( index < m Size ) { if ( DEBUG ) Log . d ( TAG , STRING + index + STRING + ( m Size - index ) + STRING + ( index + NUM ) ) ; System . arraycopy ( m Hashes , index , m Hashes , index + NUM , m Size - index ) ; System . arraycopy ( m Array , index << NUM , m Array , ( index + NUM ) << NUM , ( m Size - index ) << NUM ) ; } m Hashes [ index ] = hash ; m Array [ index << NUM ] = key ; m Array [ ( index << NUM ) + NUM ] = value ; m Size ++ ; return null ; }
protected void put Long Volatile ( long pos , long val ) { unsafe . put Long Volatile ( null , pos + addr , val ) ; }
public boolean recreate R Set Step ( URI rp System Id , List < URI > volume Ids , Map < String , Recreate Replication Set Request Params > rset Params , String token ) throws Internal Exception { List < String > replication Set Names = new Array List < String > ( ) ; try { Protection System rp System = db Client . query Object ( Protection System . class , rp System Id ) ; for ( URI volume Id : volume Ids ) { Volume volume = db Client . query Object ( Volume . class , volume Id ) ; replication Set Names . add ( volume . get R Set Name ( ) ) ; } Recover Point Client rp = RP Helper . get Recover Point Client ( rp System ) ; log . info ( STRING ) ; try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { log . warn ( STRING ) ; } rp . recreate Replication Sets ( rset Params ) ; Workflow Step Completer . step Succeded ( token ) ; } catch ( Exception e ) { log . error ( String . format ( STRING , replication Set Names . to String ( ) ) ) ; return step Failed ( token , e , STRING ) ; } return BOOL ; }
public Bitmap pop ( long timeout , Time Unit unit ) throws Interrupted Exception { check Not Main Thread ( ) ; ensure Scheduled ( ) ; return finished . poll ( timeout , unit ) ; }
public String order ( Properties ctx , int Window No , Grid Tab m Tab , Grid Field m Field , Object value ) { Integer C Order ID = ( Integer ) value ; if ( C Order ID == null || C Order ID . int Value ( ) == NUM ) return STRING ; if ( is Callout Active ( ) ) return STRING ; M Order order = new M Order ( ctx , C Order ID . int Value ( ) , null ) ; if ( order . get ID ( ) != NUM ) { m Tab . set Value ( STRING , order . get Date Ordered ( ) ) ; m Tab . set Value ( STRING , order . get PO Reference ( ) ) ; m Tab . set Value ( STRING , new Integer ( order . get AD Org ID ( ) ) ) ; m Tab . set Value ( STRING , new Integer ( order . get AD Org Trx ID ( ) ) ) ; m Tab . set Value ( STRING , new Integer ( order . get C Activity ID ( ) ) ) ; m Tab . set Value ( STRING , new Integer ( order . get C Campaign ID ( ) ) ) ; m Tab . set Value ( STRING , new Integer ( order . get C Project ID ( ) ) ) ; m Tab . set Value ( STRING , new Integer ( order . get User 1 ID ( ) ) ) ; m Tab . set Value ( STRING , new Integer ( order . get User 2 ID ( ) ) ) ; m Tab . set Value ( STRING , new Integer ( order . get M Warehouse ID ( ) ) ) ; m Tab . set Value ( STRING , order . get Delivery Rule ( ) ) ; m Tab . set Value ( STRING , order . get Delivery Via Rule ( ) ) ; m Tab . set Value ( STRING , new Integer ( order . get M Shipper ID ( ) ) ) ; m Tab . set Value ( STRING , order . get Freight Cost Rule ( ) ) ; m Tab . set Value ( STRING , order . get Freight Amt ( ) ) ; m Tab . set Value ( STRING , new Integer ( order . get C B Partner ID ( ) ) ) ; m Tab . set Value ( STRING , new Integer ( order . get C B Partner Location ID ( ) ) ) ; if ( order . get AD User ID ( ) > NUM ) m Tab . set Value ( STRING , new Integer ( order . get AD User ID ( ) ) ) ; else m Tab . set Value ( STRING , null ) ; } return STRING ; }
public final int read Int ( ) throws java . io . IO Exception { read Fully ( scratch , NUM , NUM ) ; return ( ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) | ( ( scratch [ NUM ] & NUM ) << NUM ) ) ; }
public void test Table Meta Data ( ) throws Exception { Statement stmt = con . create Statement ( Result Set . TYPE SCROLL INSENSITIVE , Result Set . CONCUR READ ONLY ) ; Result Set rs = stmt . execute Query ( STRING ) ; assert Not Null ( rs ) ; Result Set Meta Data rsmd = rs . get Meta Data ( ) ; Assert . assert Equals ( STRING , rsmd . get Catalog Name ( NUM ) ) ; Assert . assert Equals ( STRING , rsmd . get Schema Name ( NUM ) ) ; Assert . assert Equals ( STRING , rsmd . get Table Name ( NUM ) ) ; stmt . close ( ) ; rs . close ( ) ; }
boolean clear Addr Map ( final long addr , final int latched Addr ) throws Illegal State Exception , Interrupted Exception { final Byte Buffer tmp = acquire ( ) ; try { if ( m closed For Writes ) { return BOOL ; } final Record Metadata removed = record Map . remove ( addr ) ; if ( removed == null ) { throw new Assertion Error ( ) ; } removed . deleted = BOOL ; if ( ! prefix Writes ) { m removed += removed . record Length ; return BOOL ; } final int addr offset = removed . buffer Offset - SIZEOF PREFIX WRITE METADATA ; tmp . put Long ( addr offset , - removed . file Offset ) ; if ( m written && record Map . is Empty ( ) ) { m written = BOOL ; } m removed += removed . record Length ; return BOOL ; } finally { release ( ) ; } }
private void handle Json Create Quotation ( Request And Response request And Response ) throws IO Exception , Servlet Exception { request And Response . set Response Content Type Json ( ) ; String url ; String title ; String quotation ; String note ; String session Id ; try { final Json Node Helper json = get Json Node ( request And Response ) ; url = json . get String ( Db Logic . Constants . url ) ; title = json . get String ( Db Logic . Constants . title ) ; quotation = json . get String ( Db Logic . Constants . quotation ) ; note = json . get String ( Db Logic . Constants . note ) ; session Id = json . get String ( STRING ) ; } catch ( final IO Exception e ) { return Json 400 ( request And Response , servlet Text . error Json ( ) ) ; return ; } if ( ! Entry Attribute Validator . is Note Valid ( note ) ) { return Json 400 ( request And Response , servlet Text . error Note Is Invalid ( ) ) ; return ; } if ( ! Entry Attribute Validator . is Quotation Valid ( quotation ) ) { return Json 400 ( request And Response , servlet Text . error Quotation Is Invalid ( ) ) ; return ; } if ( ! Entry Attribute Validator . is Url Valid ( url ) ) { return Json 400 ( request And Response , servlet Text . error Url Is Invalid ( ) ) ; return ; } if ( ! Entry Attribute Validator . is Source Title Valid ( title ) ) { return Json 400 ( request And Response , servlet Text . error Title Is Invalid ( ) ) ; return ; } final Errors errors = new Errors ( ) ; try { final Long time = new Long ( System . current Time Millis ( ) ) ; String user Id = null ; if ( session Manager != null ) { final Http Session session = session Manager . get Session ( session Id ) ; if ( session != null && session . get Attribute ( session User Id Attribute ) != null ) { user Id = ( String ) session . get Attribute ( session User Id Attribute ) ; } } final User user = db Logic . get User By Id ( user Id ) ; if ( user == null ) { return Json 400 ( request And Response , servlet Text . error No Account Found ( ) ) ; return ; } if ( user . get Is Account Closed ( ) ) { return Json 400 ( request And Response , servlet Text . error Account Is Closed ( ) ) ; return ; } final Entry source = db Logic . update Or Create Source ( user , null , url , title , time , time , is User An Admin ( request And Response ) , errors ) ; if ( source == null ) { return Json 400 ( request And Response , errors ) ; return ; } final Entry entry = db Logic . create Entry Quotation ( user , source , quotation , note , time , is User An Admin ( request And Response ) , errors ) ; if ( entry == null ) { return Json 400 ( request And Response , errors ) ; return ; } request And Response . print ( STRING + STRING + entry . get Id ( ) + STRING + STRING + source . get Id ( ) + STRING ) ; db Logic . commit ( ) ; } catch ( final Persistence Exception e ) { logger . log ( Level . INFO , STRING , e ) ; return Json 500 ( request And Response , servlet Text . error Internal Database ( ) ) ; } }
public Object [ ] build Parameters ( Object [ ] first Parameters , Method method , Class < ? extends Annotation > annotation Type ) { int parameters Length = method . get Parameter Types ( ) . length ; if ( first Parameters . length > NUM && parameters Length < NUM ) { throw new Repository Method Exception ( String . format ( STRING , annotation Type ) ) ; } int parameters To Resolve = parameters Length - first Parameters . length ; Object [ ] additional Parameters = new Object [ parameters To Resolve ] ; for ( int i = first Parameters . length ; i < parameters Length ; i ++ ) { additional Parameters [ i - first Parameters . length ] = parameter Provider . provide ( method , i ) ; } return concatenate ( first Parameters , additional Parameters ) ; }
boolean is Valid Jimple Name ( String prospective Name ) { if ( prospective Name == null ) return BOOL ; for ( int i = NUM ; i < prospective Name . length ( ) ; i ++ ) { char c = prospective Name . char At ( i ) ; if ( i == NUM && c >= STRING && c <= STRING ) return BOOL ; if ( ! ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c == STRING || c == STRING ) ) ) return BOOL ; } return BOOL ; }
private void enable Stronger Defaults ( Socket socket ) { if ( is Secure ( socket ) ) { SSL Socket ssl Socket = ( SSL Socket ) socket ; read SSL Parameters ( ssl Socket ) ; if ( m Enable Stonger Default Protocal Version && m Protocols != null ) { ssl Socket . set Enabled Protocols ( m Protocols ) ; } if ( m Enable Stonger Default SSL Cipher Suite && m Cipher Suites != null ) { ssl Socket . set Enabled Cipher Suites ( m Cipher Suites ) ; } } }
static String scan Identifier ( IXML Reader reader ) throws IO Exception , XML Parse Exception { String Buffer result = new String Buffer ( ) ; for ( ; ; ) { char ch = reader . read ( ) ; if ( ( ch == STRING ) || ( ch == STRING ) || ( ch == STRING ) || ( ch == STRING ) || ( ( ch >= STRING ) && ( ch <= STRING ) ) || ( ( ch >= STRING ) && ( ch <= STRING ) ) || ( ( ch >= STRING ) && ( ch <= STRING ) ) || ( ch > STRING ) ) { result . append ( ch ) ; } else { reader . unread ( ch ) ; break ; } } return result . to String ( ) ; }
private void update Font ( String family , int style , int size ) { console . set Font ( new Font ( family , style , size ) ) ; }
public Command checkout Command ( ) throws Interrupted Exception { Command command = pool . poll ( ) ; if ( command == null ) { command = new Command ( gondola , this , cmember ) ; } return command ; }
public static boolean is Double ( String desc ) { return desc . ends With ( STRING ) ; }
public static void move End ( J Scroll Pane pane ) { J Scroll Bar bar = pane . get Vertical Scroll Bar ( ) ; bar . set Value ( bar . get Maximum ( ) ) ; }
public void add ( String arg Name , String desc , int expected Number Of Arguments , boolean expect Dashed Arguments ) { Arg new Arg = new Arg ( arg Name , desc , expected Number Of Arguments , expect Dashed Arguments ) ; args . add ( new Arg ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + arg Name ) ; } }
private boolean add If Absent ( E e , Object [ ] snapshot ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] current = get Array ( ) ; int len = current . length ; if ( snapshot != current ) { int common = Math . min ( snapshot . length , len ) ; for ( int i = NUM ; i < common ; i ++ ) if ( current [ i ] != snapshot [ i ] && eq ( e , current [ i ] ) ) return BOOL ; if ( index Of ( e , current , common , len ) >= NUM ) return BOOL ; } Object [ ] new Elements = Arrays . copy Of ( current , len + NUM ) ; new Elements [ len ] = e ; set Array ( new Elements ) ; return BOOL ; } finally { lock . unlock ( ) ; } }
public void add Model ( Model model ) { models . add ( model ) ; }
public void save Fingerprint As File ( byte [ ] fingerprint , String filename ) { File Output Stream file Output Stream ; try { file Output Stream = new File Output Stream ( filename ) ; file Output Stream . write ( fingerprint ) ; file Output Stream . close ( ) ; } catch ( File Not Found Exception e1 ) { e1 . print Stack Trace ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public int create Binomial ( final int n , final double p ) { double value = p ; final String Builder bits = new String Builder ( NUM ) ; double bit Value = NUM ; while ( value > NUM ) { if ( value >= bit Value ) { bits . append ( STRING ) ; value -= bit Value ; } else { bits . append ( STRING ) ; } bit Value /= NUM ; } final Bit String p Bits = new Bit String ( bits . to String ( ) ) ; int trials = n ; int total Successes = NUM ; int p Index = p Bits . get Length ( ) - NUM ; while ( trials > NUM && p Index >= NUM ) { final Bit String bs = new Bit String ( trials , generator ) ; final int successes = bs . count Set Bits ( ) ; trials -= successes ; if ( p Bits . get Bit ( p Index ) ) { total Successes += successes ; } -- p Index ; } return total Successes ; }
public Matsim Xml Parser ( ) { String local Dtd = System . get Property ( STRING ) ; if ( local Dtd != null ) { this . prefer Local Dtds = Boolean . parse Boolean ( local Dtd ) ; } }
@ Event Handler ( priority = Event Priority . HIGH , ignore Cancelled = BOOL ) public void on Bucket Fill ( Player Bucket Fill Event event ) { Match match = Cardinal . get Match ( event . get Player ( ) ) ; if ( match == null || ! match . has Player ( event . get Player ( ) ) ) { return ; } for ( Applied Region reg : get ( match , Apply Type . BLOCK , Apply Type . BLOCK BREAK ) ) { Block evaluating = event . get Block Clicked ( ) ; if ( apply ( reg , evaluating . get Location ( ) , event . get Player ( ) , event , event , evaluating , event . get Player ( ) ) ) { break ; } } }
public void expand ( Tree Path [ ] paths ) { for ( Tree Path path : paths ) { expand J Tree Node ( data Tree , data Tree . get Model ( ) , path . get Last Path Component ( ) , data Tree . get Row For Path ( path ) , NUM ) ; } }
public static void assert Throws ( Class < ? > throwable , Checked Runnable runnable , Consumer < Throwable > exception Consumer ) { boolean fail = BOOL ; try { runnable . run ( ) ; fail = BOOL ; } catch ( Throwable t ) { if ( ! throwable . is Instance ( t ) ) throw new Assertion Error ( STRING , t ) ; exception Consumer . accept ( t ) ; } if ( fail ) Assert . fail ( STRING ) ; }
public boolean is Empty ( ) { return nodes . is Empty ( ) ; }
public static boolean assert Equals ( final String msg , final Object a , final Object b ) { if ( a == b ) { return BOOL ; } if ( a == null || ! a . equals ( b ) ) { throw new Exam Exception ( msg + STRING + a + STRING + b ) ; } return BOOL ; }
public Future < Job > save ( ) { Objects . require Non Null ( this . type , STRING ) ; if ( this . id > NUM ) return update ( ) ; Future < Job > future = Future . future ( ) ; client . incr ( Redis Helper . get Key ( STRING ) , null ) ; return future . compose ( null ) ; }
public static boolean debugging ( String token ) { return Debug . On && ( debug All || dbg Table . contains Key ( token ) ) ; }
public static List < File > sort In Batch ( File file , Comparator < String > cmp , int maxtmpfiles ) throws IO Exception { List < File > files = new Array List < File > ( ) ; Buffered Reader fbr = new Buffered Reader ( new File Reader ( file ) ) ; long blocksize = estimate Best Size Of Blocks ( file , maxtmpfiles ) ; try { List < String > tmplist = new Array List < String > ( ) ; String line = STRING ; try { while ( line != null ) { long currentblocksize = NUM ; while ( ( currentblocksize < blocksize ) && ( ( line = fbr . read Line ( ) ) != null ) ) { tmplist . add ( line ) ; currentblocksize += line . length ( ) * NUM ; } files . add ( sort And Save ( tmplist , cmp ) ) ; tmplist . clear ( ) ; } } catch ( EOF Exception oef ) { if ( tmplist . size ( ) > NUM ) { files . add ( sort And Save ( tmplist , cmp ) ) ; tmplist . clear ( ) ; } } } finally { fbr . close ( ) ; } return files ; }
public void remove Directory Set ( Context context , String path ) { Tiny DB tinydb = new Tiny DB ( context ) ; Array List < String > file = tinydb . get List String ( STRING ) ; file . remove ( path ) ; tinydb . put List String ( STRING , file ) ; }
private Concurrent Skip List Map . Node < K , V > lo Node ( ) { if ( lo == null ) return m . find First ( ) ; else if ( lo Inclusive ) return m . find Near ( lo , GT | EQ ) ; else return m . find Near ( lo , GT ) ; }
public void run ( ) { Buffered Reader tdin = null ; Print Writer tdout = null ; if ( view Name == null ) { Debug . error ( STRING ) ; return ; } while ( ! this . shutdown ) { if ( DEBUG ) Debug . output ( STRING ) ; try { tdin = new Buffered Reader ( new Input Stream Reader ( s . get Input Stream ( ) ) ) ; tdout = new Print Writer ( s . get Output Stream ( ) , BOOL ) ; if ( DEBUG ) Debug . output ( STRING + view Name ) ; tdout . println ( STRING + view Name + STRING ) ; s . set So Timeout ( NUM ) ; } catch ( Interrupted IO Exception e Connect Interrupted ) { continue ; } catch ( IO Exception e Connect ) { Debug . error ( STRING + e Connect . get Message ( ) + STRING ) ; try { Thread . sleep ( NUM ) ; } catch ( Exception e Sleep ) { } continue ; } if ( netmap Conn == null ) { continue ; } netmap Conn . connection Up ( ) ; while ( ! this . shutdown ) { try { String line = null ; if ( ( line = tdin . read Line ( ) ) == null ) break ; if ( DEBUG VERBOSE ) Debug . output ( STRING + line ) ; Properties event Props = procline ( line ) ; if ( DEBUG VERBOSE ) Debug . output ( STRING ) ; if ( ! event Props . is Empty ( ) ) { netmap Conn . distribute Event ( event Props ) ; if ( DEBUG VERBOSE ) Debug . output ( STRING ) ; } else { if ( DEBUG VERBOSE ) Debug . output ( STRING ) ; } } catch ( Interrupted IO Exception e Read Interrupted ) { continue ; } catch ( Exception e ) { Debug . error ( STRING + e . get Message ( ) + STRING ) ; continue ; } } try { s . close ( ) ; netmap Conn . connection Down ( ) ; } catch ( Exception e Shutdown ) { } } }
private static void update Embedded Id Repo ( String org Name , String config Name , String entry ) throws SMS Exception , SSO Exception { SSO Token token = Access Controller . do Privileged ( Admin Token Action . get Instance ( ) ) ; Service Config Manager scm = new Service Config Manager ( token , Id Constants . REPO SERVICE , STRING ) ; Service Config sc = scm . get Organization Config ( org Name , null ) ; if ( sc != null ) { Service Config sub Config = sc . get Sub Config ( config Name ) ; if ( sub Config != null ) { Map < String , Set < String > > config Map = sub Config . get Attributes ( ) ; Set < String > vals = config Map . get ( STRING ) ; vals . add ( entry ) ; Hash Map < String , Set < String > > mp = new Hash Map < String , Set < String > > ( NUM ) ; mp . put ( STRING , vals ) ; sub Config . set Attributes ( mp ) ; } } }
private boolean via try snap smd center ( int p layer ) { Item Selection Filter selection filter = new Item Selection Filter ( Item Selection Choice . PINS ) ; Collection < Brd Item > picked items = r board . pick items ( prev corner , p layer , selection filter ) ; Brd Abit Pin found smd pin = null ; for ( Brd Item curr item : picked items ) { if ( ! ( curr item instanceof Brd Abit Pin ) ) continue ; Brd Abit Pin a pin = ( Brd Abit Pin ) curr item ; if ( ! a pin . shares net no ( net nos ) ) continue ; if ( a pin . first layer ( ) == p layer && a pin . last layer ( ) == p layer ) { found smd pin = a pin ; break ; } } if ( found smd pin == null ) return BOOL ; Pla Point Int pin center = found smd pin . center get ( ) ; if ( itera connect ( prev corner , pin center ) ) { prev corner = pin center ; } return BOOL ; }
private boolean is Hardcoded Filename String ( String string ) { if ( string == null ) { return BOOL ; } if ( string . index Of ( ( int ) STRING ) == - NUM && string . index Of ( ( int ) STRING ) == - NUM ) { return BOOL ; } final char start Char = string . char At ( NUM ) ; if ( Character . is Letter ( start Char ) && string . char At ( NUM ) == STRING ) { return BOOL ; } if ( is XML String ( string ) ) { return BOOL ; } if ( is Date Format String ( string ) ) { return BOOL ; } if ( is URL String ( string ) ) { return BOOL ; } if ( is Media Type String ( string ) ) { return BOOL ; } return ! is Time Zone Id String ( string ) ; }
public Shape paint Layer ( Graphics g , int offs 0 , int offs 1 , Shape bounds , J Text Component c , View view ) { g . set Color ( get Color ( ) ) ; if ( offs 0 == view . get Start Offset ( ) && offs 1 == view . get End Offset ( ) ) { Rectangle alloc ; if ( bounds instanceof Rectangle ) alloc = ( Rectangle ) bounds ; else alloc = bounds . get Bounds ( ) ; paint Squiggle ( g , alloc ) ; return alloc ; } try { Shape shape = view . model To View ( offs 0 , Position . Bias . Forward , offs 1 , Position . Bias . Backward , bounds ) ; Rectangle r = ( shape instanceof Rectangle ) ? ( Rectangle ) shape : shape . get Bounds ( ) ; paint Squiggle ( g , r ) ; return r ; } catch ( Bad Location Exception e ) { e . print Stack Trace ( ) ; } return null ; }
synchronized void receive ( char one Char ) throws IO Exception { if ( buffer == null ) { throw new IO Exception ( STRING ) ; } if ( last Reader != null && ! last Reader . is Alive ( ) ) { throw new IO Exception ( STRING ) ; } last Writer = Thread . current Thread ( ) ; try { while ( buffer != null && out == in ) { notify All ( ) ; wait ( NUM ) ; if ( last Reader != null && ! last Reader . is Alive ( ) ) { throw new IO Exception ( STRING ) ; } } } catch ( Interrupted Exception e ) { Io Utils . throw Interrupted Io Exception ( ) ; } if ( buffer == null ) { throw new IO Exception ( STRING ) ; } if ( in == - NUM ) { in = NUM ; } buffer [ in ++ ] = one Char ; if ( in == buffer . length ) { in = NUM ; } }
static final Byte Buffer Buffer To Byte Buffer ( final byte [ ] buffer , final Byte Order order , final int start , final int len ) { final Byte Buffer ret Buff = Byte Buffer . wrap ( buffer , start , len ) ; ret Buff . order ( order ) ; return ret Buff ; }
static protected String host From Uri Str ( String uri Str ) { debug Out ( STRING + uri Str + STRING ) ; String host = null ; URI uri ; try { uri = new URI ( uri Str ) ; host = uri . get Host ( ) ; } catch ( URI Syntax Exception e ) { debug Out ( e . get Message ( ) ) ; } return host ; }
public void reset ( ) { current Time = NUM ; stored Time = NUM ; start Time = System . current Time Millis ( ) ; }
public int read Word ( ) throws IO Exception { length += NUM ; int k1 = in . read ( ) ; if ( k1 < NUM ) return NUM ; return ( k1 + ( in . read ( ) << NUM ) ) & NUM ; }
private void tag End ( ) throws IO Exception { save Current ( NUM ) ; go ( NUM ) ; col += NUM ; if ( is All Read ( ) ) { return ; } String tag Name = identifier ( ) ; if ( transformations != null && transformations . has Transformation For Tag ( tag Name ) ) { Tag Transformation tag Transformation = transformations . get Transformation ( tag Name ) ; if ( tag Transformation != null ) { tag Name = tag Transformation . get Dest Tag ( ) ; } } if ( tag Name != null ) { I Tag Info Provider tag Info Provider = cleaner . get Tag Info Provider ( ) ; Tag Info tag Info = tag Info Provider . get Tag Info ( tag Name ) ; if ( ( tag Info == null && ! props . is Omit Unknown Tags ( ) && props . is Treat Unknown Tags As Content ( ) && ! is Reserved Tag ( tag Name ) && ! props . is Namespaces Aware ( ) ) || ( tag Info != null && tag Info . is Deprecated ( ) && ! props . is Omit Deprecated Tags ( ) && props . is Treat Deprecated Tags As Content ( ) ) ) { content ( ) ; return ; } } current Tag Token = new End Tag Token ( tag Name ) ; if ( as Expected ) { skip Whitespaces ( ) ; tag Attributes ( ) ; if ( tag Name != null ) { add Token ( current Tag Token ) ; } if ( is Char ( STRING ) ) { go ( ) ; } if ( props . is Use Cdata For ( tag Name ) ) { is Special Context = BOOL ; is Special Context Name = tag Name ; } if ( tag Name != null && tag Name . equals Ignore Case ( STRING ) ) { skip Whitespaces ( ) ; } current Tag Token = null ; } else { add Saved As Content ( ) ; } }
public String next String ( char quote ) throws JSON Exception { char c ; String Buffer sb = new String Buffer ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case NUM : case STRING : case STRING : throw syntax Error ( STRING ) ; case STRING : c = next ( ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( ( char ) Integer . parse Int ( next ( NUM ) , NUM ) ) ; break ; case STRING : case STRING : case STRING : case STRING : sb . append ( c ) ; break ; default : throw syntax Error ( STRING ) ; } break ; default : if ( c == quote ) { return sb . to String ( ) ; } sb . append ( c ) ; } } }
public ID 3 v 11 Tag ( Random Access File file , String logging Filename ) throws Tag Not Found Exception , IO Exception { set Logging Filename ( logging Filename ) ; File Channel fc ; Byte Buffer byte Buffer = Byte Buffer . allocate ( TAG LENGTH ) ; fc = file . get Channel ( ) ; fc . position ( file . length ( ) - TAG LENGTH ) ; fc . read ( byte Buffer ) ; byte Buffer . flip ( ) ; read ( byte Buffer ) ; }
public double evaluate ( Vector Instance x , double [ ] y ) throws Exception { double dot Prod = x . dot Product ( y ) ; return Math . pow ( m gamma * dot Prod + m coef 0 , m degree ) ; }
private void validate Vcenter Credentials ( Vcenter Param param , Vcenter vcenter ) { if ( String Utils . is Blank ( param . get Password ( ) ) && vcenter != null ) { param . set Password ( String Utils . trim To Null ( vcenter . get Password ( ) ) ) ; } if ( String Utils . is Blank ( param . get User Name ( ) ) && vcenter != null ) { param . set User Name ( String Utils . trim To Null ( vcenter . get Username ( ) ) ) ; } Arg Validator . check Field Not Null ( param . get User Name ( ) , STRING ) ; Arg Validator . check Field Not Null ( param . get Password ( ) , STRING ) ; }
@ Not Null private static Text Range process Tabs ( @ Not Null Helper helper , @ Not Null Text Range range , int tab Width ) { Char Sequence indent = helper . get Current Line Indent ( ) ; int start = Math . max ( NUM , range . get Start Offset ( ) - helper . get Current Line Start Offset ( ) ) ; int end = Math . min ( indent . length ( ) , range . get End Offset ( ) - helper . get Current Line Start Offset ( ) ) ; int replacements Number = NUM ; int consecutive Spaces = NUM ; for ( int i = start ; i < end ; i ++ ) { char c = indent . char At ( i ) ; if ( c == STRING ) { ++ consecutive Spaces ; } else { int tabs Number = consecutive Spaces / tab Width ; if ( tabs Number > NUM ) { helper . replace ( i - consecutive Spaces , i - consecutive Spaces + tabs Number * tab Width , String Util . repeat ( STRING , tabs Number ) ) ; replacements Number ++ ; consecutive Spaces = NUM ; } if ( c != STRING ) { break ; } } } int tabs Number = consecutive Spaces / tab Width ; if ( tabs Number > NUM ) { helper . replace ( end - consecutive Spaces , end - consecutive Spaces + tabs Number * tab Width , String Util . repeat ( STRING , tabs Number ) ) ; } if ( replacements Number > NUM ) { return Text Range . create ( range . get Start Offset ( ) , range . get End Offset ( ) - replacements Number * ( tab Width - NUM ) ) ; } else { return range ; } }
public static void generate Java Script Log Session Expired Relation ( Writer writer , String idioma , Long num Idioma , String message , int enabled ) throws IO Exception { writer . write ( STRING + message + STRING ) ; if ( enabled == NUM ) { writer . write ( STRING + idioma + STRING + num Idioma + STRING ) ; writer . write ( STRING ) ; } else { writer . write ( STRING + idioma + STRING + num Idioma + STRING ) ; } writer . write ( STRING ) ; }
public Tree < String > extract Best Max Rule Parse 1 ( int start , int end , int state , List < String > sentence ) { int c State = maxc Child [ start ] [ end ] [ state ] ; if ( c State == - NUM ) { return extract Best Max Rule Parse 2 ( start , end , state , sentence ) ; } else { List < Tree < String > > child = new Array List < Tree < String > > ( ) ; child . add ( extract Best Max Rule Parse 2 ( start , end , c State , sentence ) ) ; String state Str = ( String ) tag Numberer . object ( state ) ; if ( state Str . ends With ( STRING ) ) state Str = state Str . substring ( NUM , state Str . length ( ) - NUM ) ; total Used Unaries ++ ; int intermediate Node = grammar . get Unary Intermediate ( ( short ) state , ( short ) c State ) ; if ( intermediate Node > NUM ) { List < Tree < String > > restored Child = new Array List < Tree < String > > ( ) ; n Times Restored Unaries ++ ; String state Str 2 = ( String ) tag Numberer . object ( intermediate Node ) ; if ( state Str 2 . ends With ( STRING ) ) state Str 2 = state Str 2 . substring ( NUM , state Str 2 . length ( ) - NUM ) ; restored Child . add ( new Tree < String > ( state Str 2 , child ) ) ; return new Tree < String > ( state Str , restored Child ) ; } return new Tree < String > ( state Str , child ) ; } }
@ Override protected void on Draw ( Canvas canvas ) { super . on Draw ( canvas ) ; if ( m Shader == null ) return ; float radius = m Center X <= m Center Y ? m Center X - NUM : m Center Y - NUM ; canvas . rotate ( m Rotate Degrees , m Center X , m Center Y ) ; canvas . draw Circle ( m Center X , m Center Y , radius , m Paint Cover ) ; canvas . rotate ( - m Rotate Degrees , m Center X , m Center Y ) ; canvas . draw Circle ( m Center X , m Center Y , m Button Radius , m Paint Button ) ; if ( m Progress Visibility ) { canvas . draw Arc ( rect F , NUM , NUM , BOOL , m Paint Progress Empty ) ; canvas . draw Arc ( rect F , NUM , calculate Past Progress Degree ( ) , BOOL , m Paint Progress Loaded ) ; String left Time = seconds To Time ( calculate Left Seconds ( ) ) ; m Paint Time . get Text Bounds ( left Time , NUM , left Time . length ( ) , m Rect Text ) ; canvas . draw Text ( left Time , ( float ) ( m Center X * Math . cos ( Math . to Radians ( NUM ) ) ) + m Width / NUM - m Rect Text . width ( ) / NUM , ( float ) ( m Center X * Math . sin ( Math . to Radians ( NUM ) ) ) + m Height / NUM + m Rect Text . height ( ) + NUM , m Paint Time ) ; String passed Time = seconds To Time ( calculate Passed Seconds ( ) ) ; m Paint Time . get Text Bounds ( passed Time , NUM , passed Time . length ( ) , m Rect Text ) ; canvas . draw Text ( passed Time , ( float ) ( m Center X * - Math . cos ( Math . to Radians ( NUM ) ) ) + m Width / NUM - m Rect Text . width ( ) / NUM , ( float ) ( m Center X * Math . sin ( Math . to Radians ( NUM ) ) ) + m Height / NUM + m Rect Text . height ( ) + NUM , m Paint Time ) ; } if ( m First Draw ) { toggle ( ) ; m First Draw = BOOL ; } m Play Pause Drawable . draw ( canvas ) ; }
public void start ( int conditions ) throws IO Exception { super . start ( conditions ) ; int ptr = ( int ) tagout . get Bytes Written ( ) ; int offset = ptr - last Ptr ; offsets . add ( new int [ ] { last Ptr , offset } ) ; last Ptr = ptr ; tagout . write UI 16 ( NUM ) ; tagout . write UI 16 ( conditions ) ; }
private static Result Code register Success Result Code ( final int int Value , final Localizable Message name , final Enum result Code Enum ) { final Result Code t = new Result Code ( int Value , name , BOOL , result Code Enum ) ; ELEMENTS . put ( int Value , t ) ; return t ; }
public void clear ( ) { exception Set . clear ( ) ; explicit Set . clear ( ) ; universal Handler = BOOL ; common Supertype = null ; size = NUM ; }
@ HLE Unimplemented @ HLE Function ( nid = NUM , version = NUM ) public int sce Usb Cam Setup Video ( psp Usb Cam Setup Video Param usb Cam Setup Video Param , T Pointer work Area , int work Area Size ) { this . work Area = work Area . get Address ( ) ; this . work Area Size = work Area Size ; resolution = usb Cam Setup Video Param . resolution ; frame Rate = usb Cam Setup Video Param . framerate ; white Balance = usb Cam Setup Video Param . wb ; saturation = usb Cam Setup Video Param . saturation ; brightness = usb Cam Setup Video Param . brightness ; contrast = usb Cam Setup Video Param . contrast ; sharpness = usb Cam Setup Video Param . sharpness ; image Effect Mode = usb Cam Setup Video Param . effectmode ; frame Size = usb Cam Setup Video Param . framesize ; ev Level = usb Cam Setup Video Param . evlevel ; if ( ! setup Video ( ) ) { log . warn ( String . format ( STRING ) ) ; return Sce Kernel Errors . ERROR USBCAM NOT READY ; } return NUM ; }
@ Nullable public Codenvy License load ( ) throws License Exception { String license Text ; try { license Text = new String ( Files . read All Bytes ( license File ) , UTF 8 ) ; } catch ( No Such File Exception e ) { throw new License Not Found Exception ( STRING ) ; } catch ( IO Exception e ) { throw new License Exception ( e . get Message ( ) , e ) ; } if ( is Null Or Empty ( license Text ) ) { throw new License Not Found Exception ( STRING ) ; } return license Factory . create ( license Text ) ; }
public List < Project Type Resolution > resolve Sources ( String path , boolean transient Only ) throws Server Exception , Not Found Exception { final List < Project Type Resolution > resolutions = new Array List < > ( ) ; for ( Project Type type : project Type Registry . get Project Types ( Project Type Registry . CHILD TO PARENT COMPARATOR ) ) { if ( transient Only && type . is Persisted ( ) ) { continue ; } try { final Project Type Resolution resolution = estimate Project ( path , type . get Id ( ) ) ; if ( resolution . matched ( ) ) { resolutions . add ( resolution ) ; } } catch ( Value Storage Exception e ) { LOG . warn ( e . get Localized Message ( ) , e ) ; } } return resolutions ; }
static public void remove Notification Listener ( JMX Connector jmx Connector , Class < ? > mbean Interface , String mbean Name , Notification Listener notification Listener , boolean ignored ) throws Exception { M Bean Server Connection mbsc = jmx Connector . get M Bean Server Connection ( ) ; Object Name object Name = generate M Bean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; mbsc . remove Notification Listener ( object Name , notification Listener ) ; }
private void send Message ( Consumer Record < String , String > record ) { try { bus . send ( bus Address , Kafka Event . create Event For Bus ( record ) ) ; } catch ( Exception ex ) { String error = String . format ( STRING , record . to String ( ) ) ; logger . error ( error , ex ) ; bus . send ( Config Constants . CONSUMER ERROR TOPIC , get Error String ( error , ex . get Message ( ) ) ) ; } }
public byte [ ] read Raw Bytes ( final int size ) throws IO Exception { if ( size < NUM ) { throw Invalid Protocol Buffer Exception . negative Size ( ) ; } if ( total Bytes Retired + buffer Pos + size > current Limit ) { skip Raw Bytes ( current Limit - total Bytes Retired - buffer Pos ) ; throw Invalid Protocol Buffer Exception . truncated Message ( ) ; } if ( size <= buffer Size - buffer Pos ) { final byte [ ] bytes = new byte [ size ] ; System . arraycopy ( buffer , buffer Pos , bytes , NUM , size ) ; buffer Pos += size ; return bytes ; } else if ( size < BUFFER SIZE ) { final byte [ ] bytes = new byte [ size ] ; int pos = buffer Size - buffer Pos ; System . arraycopy ( buffer , buffer Pos , bytes , NUM , pos ) ; buffer Pos = buffer Size ; refill Buffer ( BOOL ) ; while ( size - pos > buffer Size ) { System . arraycopy ( buffer , NUM , bytes , pos , buffer Size ) ; pos += buffer Size ; buffer Pos = buffer Size ; refill Buffer ( BOOL ) ; } System . arraycopy ( buffer , NUM , bytes , pos , size - pos ) ; buffer Pos = size - pos ; return bytes ; } else { final int original Buffer Pos = buffer Pos ; final int original Buffer Size = buffer Size ; total Bytes Retired += buffer Size ; buffer Pos = NUM ; buffer Size = NUM ; int size Left = size - ( original Buffer Size - original Buffer Pos ) ; final List < byte [ ] > chunks = new Array List < byte [ ] > ( ) ; while ( size Left > NUM ) { final byte [ ] chunk = new byte [ Math . min ( size Left , BUFFER SIZE ) ] ; int pos = NUM ; while ( pos < chunk . length ) { final int n = ( input == null ) ? - NUM : input . read ( chunk , pos , chunk . length - pos ) ; if ( n == - NUM ) { throw Invalid Protocol Buffer Exception . truncated Message ( ) ; } total Bytes Retired += n ; pos += n ; } size Left -= chunk . length ; chunks . add ( chunk ) ; } final byte [ ] bytes = new byte [ size ] ; int pos = original Buffer Size - original Buffer Pos ; System . arraycopy ( buffer , original Buffer Pos , bytes , NUM , pos ) ; for ( final byte [ ] chunk : chunks ) { System . arraycopy ( chunk , NUM , bytes , pos , chunk . length ) ; pos += chunk . length ; } return bytes ; } }
private void delete Attrs ( Svc Reg reg , Entry Rep entry , boolean check Dups ) { Entry Class eclass = entry . eclass ; delete Instance ( eclass ) ; Object [ ] fields = entry . fields ; if ( fields . length == NUM ) { Array List regs = ( Array List ) service By Empty Attr . get ( eclass ) ; if ( regs == null || ( check Dups && has Empty Attr ( reg , eclass ) ) ) return ; int idx = regs . index Of ( reg ) ; if ( idx >= NUM ) { regs . remove ( idx ) ; if ( regs . is Empty ( ) ) service By Empty Attr . remove ( eclass ) ; } return ; } for ( int fldidx = fields . length ; -- fldidx >= NUM ; ) { eclass = get Defining Class ( eclass , fldidx ) ; Hash Map [ ] attr Maps = ( Hash Map [ ] ) service By Attr . get ( eclass ) ; if ( attr Maps == null || attr Maps [ fldidx ] == null || ( check Dups && has Attr ( reg , eclass , fldidx , fields [ fldidx ] ) ) ) continue ; Hash Map map = attr Maps [ fldidx ] ; Object value = fields [ fldidx ] ; Array List regs = ( Array List ) map . get ( value ) ; if ( regs == null ) continue ; int idx = regs . index Of ( reg ) ; if ( idx < NUM ) continue ; regs . remove ( idx ) ; if ( ! regs . is Empty ( ) ) continue ; map . remove ( value ) ; if ( ! map . is Empty ( ) ) continue ; attr Maps [ fldidx ] = null ; if ( all Null ( attr Maps ) ) service By Attr . remove ( eclass ) ; } }
public boolean is Public ( ) { return Modifier . is Public ( class . get Modifiers ( ) ) ; }
private void save Log File ( License license , Properties props ) { File log File = get Log File ( license ) ; logger . fine ( STRING + props ) ; try { final Output Stream out = new File Output Stream ( log File ) ; try { props . store ( out , String . format ( LOG HEADER , new Date ( ) ) ) ; } finally { out . close ( ) ; } } catch ( IO Exception ex ) { logger . log ( Level . SEVERE , STRING + log File . get Absolute Path ( ) , ex ) ; } }
public Serbian Normalization Filter Factory ( Map < String , String > args ) { super ( args ) ; this . haircut = get ( args , STRING , Arrays . as List ( STRING , STRING ) , STRING ) ; if ( ! args . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING + args ) ; } }
public static int update ( W q , V v ) { String passwd = ( String ) v . value ( STRING ) ; if ( ! X . is Empty ( passwd ) ) { passwd = encrypt ( passwd ) ; v . set ( STRING , passwd , BOOL ) ; } else { v . remove ( STRING ) ; } return Helper . update ( q , v . set ( STRING , System . current Time Millis ( ) ) , User . class ) ; }
@ Override public String to String ( ) { String Buffer text = new String Buffer ( ) ; if ( m train Instances == null ) { text . append ( STRING ) ; } else { text . append ( STRING ) ; if ( ! m missing merge ) { text . append ( STRING ) ; } } text . append ( STRING ) ; return text . to String ( ) ; }
public boolean is Safe Class ( Soot Class clz ) { return safe Classes . contains ( clz . get Name ( ) ) ; }
public void test get Put Byte Array With Offset And Length ( ) { final int capacity = NUM ; final Byte Array Buffer buf = new Byte Array Buffer ( capacity ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( NUM ) ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( capacity - NUM ) ) ; final int pos = NUM ; for ( int i = NUM ; i < LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . next Int ( capacity - NUM ) ] ; final int off = ( expected . length / NUM == NUM ? NUM : r . next Int ( expected . length / NUM ) ) ; final int len = ( expected . length == NUM ? NUM : r . next Int ( expected . length - off ) ) ; r . next Bytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assert Equals ( NUM , Bytes Util . compare Bytes With Len And Offset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . next Int ( NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assert Equals ( NUM , Bytes Util . compare Bytes With Len And Offset ( off , len , expected , dstoff , len , actual ) ) ; } assert Equals ( ( byte ) NUM , buf . get Byte ( NUM ) ) ; assert Equals ( ( byte ) NUM , buf . get Byte ( pos + capacity - NUM ) ) ; }
public void add Item ( int position , M model ) { m Datas . add ( position , model ) ; notify Data Set Changed ( ) ; }
public Search Action ( Search Information info , String message Key ) { this . info = info ; put Value ( Action . NAME , Message Format . format ( I18 n . tr ( message Key ) , new Object [ ] { info . get Title ( ) } ) ) ; if ( Search Mediator . validate Info ( info ) != Search Mediator . QUERY VALID ) { throw new Illegal Argument Exception ( STRING + info ) ; } }
private void process Line ( List < byte [ ] > parts , Channel channel , Channel Handler Context channel Handler Context ) throws Unknown Command Exception , Malformed Command Exception { final int num Parts = parts . size ( ) ; Op op ; try { op = Op . find Op ( parts . get ( NUM ) ) ; } catch ( Illegal Argument Exception e ) { throw new Unknown Command Exception ( STRING + new String ( parts . get ( NUM ) ) ) ; } Command Message cmd = Command Message . command ( op ) ; switch ( op ) { case DELETE : if ( num Parts < NUM || num Parts > NUM ) throw new Malformed Command Exception ( STRING ) ; cmd . set Key ( parts . get ( NUM ) ) ; if ( num Parts > NUM ) { if ( Arrays . equals ( parts . get ( num Parts - NUM ) , NOREPLY ) ) { cmd . noreply = BOOL ; if ( num Parts == NUM ) cmd . time = Buffer Utils . atoi ( ( parts . get ( NUM ) ) ) ; } else if ( num Parts == NUM ) { cmd . time = Buffer Utils . atoi ( ( parts . get ( NUM ) ) ) ; } else { throw new Malformed Command Exception ( STRING ) ; } } Channels . fire Message Received ( channel Handler Context , cmd , channel . get Remote Address ( ) ) ; break ; case DECR : case INCR : if ( num Parts < NUM || num Parts > NUM ) throw new Malformed Command Exception ( STRING ) ; cmd . set Key ( parts . get ( NUM ) ) ; cmd . incr Amount = Buffer Utils . atoi ( parts . get ( NUM ) ) ; if ( num Parts == NUM && Arrays . equals ( parts . get ( NUM ) , NOREPLY ) ) { cmd . noreply = BOOL ; } Channels . fire Message Received ( channel Handler Context , cmd , channel . get Remote Address ( ) ) ; break ; case FLUSH ALL : if ( num Parts >= NUM ) { if ( Arrays . equals ( parts . get ( num Parts - NUM ) , NOREPLY ) ) { cmd . noreply = BOOL ; if ( num Parts == NUM ) cmd . time = Buffer Utils . atoi ( ( parts . get ( NUM ) ) ) ; } else if ( num Parts == NUM ) cmd . time = Buffer Utils . atoi ( ( parts . get ( NUM ) ) ) ; } Channels . fire Message Received ( channel Handler Context , cmd , channel . get Remote Address ( ) ) ; break ; case VERBOSITY : if ( num Parts < NUM || num Parts > NUM ) throw new Malformed Command Exception ( STRING ) ; cmd . time = Buffer Utils . atoi ( ( parts . get ( NUM ) ) ) ; if ( num Parts > NUM && Arrays . equals ( parts . get ( NUM ) , NOREPLY ) ) cmd . noreply = BOOL ; Channels . fire Message Received ( channel Handler Context , cmd , channel . get Remote Address ( ) ) ; break ; case APPEND : case PREPEND : case REPLACE : case ADD : case SET : case CAS : if ( num Parts < NUM ) { throw new Malformed Command Exception ( STRING ) ; } int size = Buffer Utils . atoi ( parts . get ( NUM ) ) ; int expire = Buffer Utils . atoi ( parts . get ( NUM ) ) ; int flags = Buffer Utils . atoi ( parts . get ( NUM ) ) ; if ( expire == NUM ) { expire = Integer . MAX VALUE ; } else if ( expire > Space Cache . THIRTY DAYS ) { expire = Local Cache Element . Now ( ) - expire ; } cmd . element = new Local Cache Element ( new Key ( parts . get ( NUM ) ) , flags , expire , NUM ) ; if ( num Parts > NUM ) { int noreply = op == Op . CAS ? NUM : NUM ; if ( op == Op . CAS ) { cmd . cas key = Buffer Utils . atol ( parts . get ( NUM ) ) ; } if ( num Parts == noreply + NUM && Arrays . equals ( parts . get ( noreply ) , NOREPLY ) ) cmd . noreply = BOOL ; } status . need More ( size , cmd ) ; break ; case GET : case GETS : case STATS : cmd . set Keys ( parts . sub List ( NUM , num Parts ) ) ; Channels . fire Message Received ( channel Handler Context , cmd , channel . get Remote Address ( ) ) ; break ; case VERSION : case QUIT : if ( num Parts > NUM ) { throw new Malformed Command Exception ( STRING ) ; } Channels . fire Message Received ( channel Handler Context , cmd , channel . get Remote Address ( ) ) ; break ; default : throw new Unknown Command Exception ( STRING + op ) ; } }
public synchronized void unlisten ( final Set < Notification Channel > channel Names ) { m channels . remove All ( channel Names ) ; }
private static < T > void display Property Values ( Console Application app , Property Definition < T > pd , Collection < T > values ) { Table Builder builder = new Table Builder ( ) ; Property Value Printer value Printer = new Property Value Printer ( null , null , BOOL ) ; int sz = values . size ( ) ; boolean use Multiple Columns = ( sz >= MULTI COLUMN THRESHOLD ) ; int rows = sz ; if ( use Multiple Columns ) { rows /= NUM ; rows += sz % NUM ; } List < T > vl = new Array List < > ( values ) ; for ( int i = NUM , j = rows ; i < rows ; i ++ , j ++ ) { builder . start Row ( ) ; builder . append Cell ( STRING ) ; builder . append Cell ( value Printer . print ( pd , vl . get ( i ) ) ) ; if ( use Multiple Columns && j < sz ) { builder . append Cell ( ) ; builder . append Cell ( STRING ) ; builder . append Cell ( value Printer . print ( pd , vl . get ( j ) ) ) ; } } Text Table Printer printer = new Text Table Printer ( app . get Error Stream ( ) ) ; printer . set Display Headings ( BOOL ) ; printer . set Indent Width ( NUM ) ; printer . set Column Width ( NUM , NUM ) ; if ( use Multiple Columns ) { printer . set Column Width ( NUM , NUM ) ; printer . set Column Width ( NUM , NUM ) ; } builder . print ( printer ) ; }
@ Override default Completable Future < Optional Int > min Int ( final To Int Function < ? super T > fn ) { return Completable Future . supply Async ( null , get Exec ( ) ) ; }
public void test Write 1 ( ) throws Exception { byte [ ] data = new byte [ ] { - NUM , - NUM , - NUM , - NUM , - NUM , NUM , NUM , NUM , NUM , NUM } ; Test Output Stream tos = new Test Output Stream ( ) ; Cipher Output Stream cos = new Cipher Output Stream ( tos , new Null Cipher ( ) ) ; for ( int i = NUM ; i < data . length ; i ++ ) { cos . write ( data [ i ] ) ; } cos . flush ( ) ; byte [ ] result = tos . to Byte Array ( ) ; if ( ! Arrays . equals ( result , data ) ) { fail ( STRING ) ; } }
public static Document read Document ( Input Stream in , String encoding ) throws IO Exception , XML Exception { try { Input Stream Reader reader = new Input Stream Reader ( in , encoding ) ; Input Source source = new Input Source ( new Buffered Reader ( reader ) ) ; Document document ; try { document = document Builder . parse ( source ) ; } catch ( SAX Exception e ) { throw new XML Exception ( STRING , e ) ; } return document ; } finally { in . close ( ) ; } }
private Create Volume Params populate Volume Params ( URI volume Id , URI storage System Id , URI neighborhood Id , String internal Site Name , boolean production , String rp Copy Name , String wwn , int max Number Of Snap Shots ) { Create Volume Params volume Params = new Create Volume Params ( ) ; volume Params . set Virtual Array ( neighborhood Id ) ; volume Params . set Production ( production ) ; volume Params . set Internal Site Name ( internal Site Name ) ; volume Params . set Storage System ( storage System Id ) ; volume Params . set Volume URI ( volume Id ) ; volume Params . set Rp Copy Name ( rp Copy Name ) ; volume Params . set Wwn ( wwn ) ; volume Params . set Max Number Of Snap Shots ( max Number Of Snap Shots ) ; return volume Params ; }
protected static void remove All Triggers ( Connection conn , String prefix ) throws SQL Exception { Statement stat = conn . create Statement ( ) ; Result Set rs = stat . execute Query ( STRING ) ; Statement stat 2 = conn . create Statement ( ) ; while ( rs . next ( ) ) { String schema = rs . get String ( STRING ) ; String name = rs . get String ( STRING ) ; if ( name . starts With ( prefix ) ) { name = String Utils . quote Identifier ( schema ) + STRING + String Utils . quote Identifier ( name ) ; stat 2 . execute ( STRING + name ) ; } } }
@ Override public String from URI ( final URI uri ) { if ( uri == null ) { throw new Illegal Argument Exception ( ) ; } try { return URL Decoder . decode ( uri . get Local Name ( ) , STRING ) ; } catch ( Unsupported Encoding Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Deprecated public static void wait For Criterion ( final Wait Criterion wait Criterion , final long timeout Millis , final long polling Interval , final boolean throw On Timeout ) { long wait This Time = jitter Interval ( polling Interval ) ; final long tilt = System . current Time Millis ( ) + timeout Millis ; for ( ; ; ) { if ( wait Criterion . done ( ) ) { return ; } if ( wait Criterion instanceof Stoppable Wait Criterion ) { Stoppable Wait Criterion ev 2 = ( Stoppable Wait Criterion ) wait Criterion ; if ( ev 2 . stop Waiting ( ) ) { if ( throw On Timeout ) { fail ( STRING + wait Criterion . description ( ) ) ; } return ; } } long time Left = tilt - System . current Time Millis ( ) ; if ( time Left <= NUM ) { if ( ! throw On Timeout ) { return ; } fail ( STRING + timeout Millis + STRING + wait Criterion . description ( ) ) ; } if ( wait This Time > time Left ) { wait This Time = time Left ; } Thread . yield ( ) ; try { Thread . sleep ( wait This Time ) ; } catch ( Interrupted Exception e ) { fail ( STRING ) ; } } }
public static void shift Mapping Vector ( Vector mvec , int shift ) { for ( int i = NUM ; i < mvec . size ( ) ; i ++ ) { Vector line = ( Vector ) mvec . element At ( i ) ; for ( int j = NUM ; j < line . size ( ) ; j ++ ) { Mapping Object mobj = ( Mapping Object ) line . element At ( j ) ; if ( mobj . type == BEGIN TLATOKEN ) { Begin TLA Token obj = ( Begin TLA Token ) mobj ; obj . set Column ( obj . get Column ( ) + shift ) ; } else if ( mobj . type == END TLATOKEN ) { End TLA Token obj = ( End TLA Token ) mobj ; obj . set Column ( obj . get Column ( ) + shift ) ; } else if ( mobj . type == SOURCE TOKEN ) { Source Token obj = ( Source Token ) mobj ; obj . set Begin Column ( obj . get Begin Column ( ) + shift ) ; obj . set End Column ( obj . get End Column ( ) + shift ) ; } } } }
private static List < String > wrap ( String text , int width ) { List < String > lines = Collections . singleton List ( text ) ; if ( text . length ( ) > width ) { String [ ] chunks = text . split ( STRING ) ; lines = new Array List < > ( ) ; String Builder line = new String Builder ( ) ; for ( String chunk : chunks ) { if ( line . length ( ) + chunk . length ( ) > width ) { lines . add ( line . to String ( ) ) ; line . set Length ( NUM ) ; } if ( line . length ( ) != NUM ) { line . append ( STRING ) ; } String [ ] embedded Lines = chunk . split ( STRING , - NUM ) ; if ( embedded Lines . length == NUM ) { line . append ( chunk ) ; } else { for ( int i = NUM ; i < embedded Lines . length ; i ++ ) { line . append ( embedded Lines [ i ] ) ; if ( i < embedded Lines . length - NUM ) { lines . add ( line . to String ( ) ) ; line . set Length ( NUM ) ; } } } } if ( line . length ( ) != NUM ) { lines . add ( line . to String ( ) ) ; } } return lines ; }
public Repeated Field Builder < M Type , B Type , I Type > add Message ( M Type message ) { if ( message == null ) { throw new Null Pointer Exception ( ) ; } ensure Mutable Message List ( ) ; messages . add ( message ) ; if ( builders != null ) { builders . add ( null ) ; } on Changed ( ) ; increment Mod Counts ( ) ; return this ; }
public boolean append ( String p button name , String p window title , Printable Info p object ) { Collection < Printable Info > object list = new Linked List < Printable Info > ( ) ; object list . add ( p object ) ; return append objects ( p button name , p window title , object list ) ; }
public < E extends T > E max ( Iterable < E > iterable ) { Iterator < E > iterator = iterable . iterator ( ) ; E max So Far = iterator . next ( ) ; while ( iterator . has Next ( ) ) { max So Far = max ( max So Far , iterator . next ( ) ) ; } return max So Far ; }
public void write ( byte [ ] b , int off , int len , long pos ) throws IO Exception { if ( b == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( ( off < NUM ) || ( len < NUM ) || ( pos < NUM ) || ( off + len > b . length ) || ( off + len < NUM ) ) { throw new Index Out Of Bounds Exception ( ) ; } long last Pos = pos + len - NUM ; if ( last Pos >= length ) { pad ( last Pos ) ; length = last Pos + NUM ; } int offset = ( int ) ( pos % BUFFER LENGTH ) ; while ( len > NUM ) { byte [ ] buf = get Cache Block ( pos / BUFFER LENGTH ) ; int nbytes = Math . min ( len , BUFFER LENGTH - offset ) ; System . arraycopy ( b , off , buf , offset , nbytes ) ; pos += nbytes ; off += nbytes ; len -= nbytes ; offset = NUM ; } }
public static void merge Stacks ( I Storage source Storage , I Storage dest Storage , Item source Item , Item target Item , long count ) { if ( source Item . get Item Count ( ) >= count ) { long free Count = target Item . get Free Count ( ) ; count = count > free Count ? free Count : count ; long left Count = dest Storage . increase Item Count ( target Item , count , source Storage . get Storage Type ( ) == dest Storage . get Storage Type ( ) ? Item Update Type . INC ITEM MERGE : Item Update Type . INC ITEM COLLECT ) ; source Storage . decrease Item Count ( source Item , count - left Count , source Storage . get Storage Type ( ) == dest Storage . get Storage Type ( ) ? Item Update Type . DEC ITEM SPLIT : Item Update Type . DEC ITEM SPLIT MOVE ) ; } }
public static int how Many Hours Old ( long time ) { return ( int ) ( ( System . current Time Millis ( ) - time ) / Date Utils . HOUR IN MILLIS ) ; }
protected boolean is WFXML Char ( String chardata , Character ref Invalid Char ) { if ( chardata == null || ( chardata . length ( ) == NUM ) ) { return BOOL ; } char [ ] dataarray = chardata . to Char Array ( ) ; int datalength = dataarray . length ; if ( f Is XML Version 11 ) { int i = NUM ; while ( i < datalength ) { if ( XML 11 Char . is XML 11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM ] ; if ( XML Char . is High Surrogate ( ch ) && i < datalength ) { char ch 2 = dataarray [ i ++ ] ; if ( XML Char . is Low Surrogate ( ch 2 ) && XML Char . is Supplemental ( XML Char . supplemental ( ch , ch 2 ) ) ) { continue ; } } ref Invalid Char = new Character ( ch ) ; return BOOL ; } } } else { int i = NUM ; while ( i < datalength ) { if ( XML Char . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM ] ; if ( XML Char . is High Surrogate ( ch ) && i < datalength ) { char ch 2 = dataarray [ i ++ ] ; if ( XML Char . is Low Surrogate ( ch 2 ) && XML Char . is Supplemental ( XML Char . supplemental ( ch , ch 2 ) ) ) { continue ; } } ref Invalid Char = new Character ( ch ) ; return BOOL ; } } } return BOOL ; }
public void test Pos Zero ( ) { String num A = STRING ; String num B = STRING ; String res = STRING ; Big Integer a Number = new Big Integer ( num A ) ; Big Integer b Number = new Big Integer ( num B ) ; Big Integer result = a Number . xor ( b Number ) ; assert True ( res . equals ( result . to String ( ) ) ) ; }
public final Parallel Flux < T > do On Subscribe ( Consumer < ? super Subscription > on Subscribe ) { Objects . require Non Null ( on Subscribe , STRING ) ; return do On Signal ( this , null , null , null , null , null , on Subscribe , null , null ) ; }
protected void add Missing ( Instances data , int level , boolean attribute Missing , boolean class Missing , int attr Index ) { int class Index = data . class Index ( ) ; Random random = new Random ( NUM ) ; for ( int i = NUM ; i < data . num Instances ( ) ; i ++ ) { Instance current = data . instance ( i ) ; for ( int j = NUM ; j < data . num Attributes ( ) ; j ++ ) { if ( ( ( j == class Index ) && class Missing ) || ( ( j == attr Index ) && attribute Missing ) ) { if ( Math . abs ( random . next Int ( ) ) % NUM < level ) { current . set Missing ( j ) ; } } } } }
public < T extends Data Object > void update In Batches ( List < T > records , int partition Size , Db Client db Client , String type ) { List < List < T > > volume partitions = Lists . partition ( records , partition Size ) ; for ( List < T > partition : volume partitions ) { try { db Client . update Object ( partition ) ; log . info ( STRING , partition . size ( ) , type ) ; } catch ( Database Exception e ) { log . error ( STRING , type , e ) ; } } }
public void create ( SSO Token token , String obj Name , Map attrs ) throws SMS Exception , SSO Exception { if ( ( obj Name == null ) || ( obj Name . length ( ) == NUM ) || ( attrs == null ) ) { throw new Illegal Argument Exception ( STRING + STRING ) ; } String attribute File Name = null ; mRW Lock . read Request ( ) ; try { if ( root . is Exists ( m Root Dir , obj Name ) ) { String errmsg = STRING + obj Name ; m Debug . error ( errmsg ) ; throw new Service Already Exists Exception ( errmsg ) ; } } finally { mRW Lock . read Done ( ) ; } mRW Lock . write Request ( ) ; if ( root . is Exists ( m Root Dir , obj Name ) ) { String errmsg = STRING + obj Name ; m Debug . error ( errmsg ) ; throw new Service Already Exists Exception ( errmsg ) ; } SMS Flat File Tree Node node = new SMS Flat File Tree Node ( obj Name ) ; String filepath = node . get Attribute Filename ( m Root Dir ) ; try { Set sunserviceids = null ; Set sunxmlkeyvals = null ; Properties props = new Properties ( ) ; Set keys = attrs . key Set ( ) ; if ( keys != null ) { for ( Iterator i = keys . iterator ( ) ; i . has Next ( ) ; ) { String key = ( String ) i . next ( ) ; Set vals = ( Set ) attrs . get ( key ) ; if ( key . equals Ignore Case ( SMS Entry . ATTR SERVICE ID ) ) { sunserviceids = vals ; } else if ( key . equals Ignore Case ( SMS Entry . ATTR XML KEYVAL ) ) { sunxmlkeyvals = vals ; } props . put ( key , to Val String ( vals ) ) ; } } try { File attr File = new File ( filepath ) ; try { if ( ! attr File . create New File ( ) ) { String errmsg = STRING + obj Name + STRING + filepath ; m Debug . error ( errmsg ) ; throw new SMS Exception ( errmsg ) ; } } catch ( IO Exception e ) { String errmsg = STRING + obj Name + STRING + filepath + STRING + e . get Message ( ) ; m Debug . error ( STRING , e ) ; throw new SMS Exception ( errmsg ) ; } save Properties ( props , attr File , obj Name ) ; create Sun Service Id Files ( node , sunserviceids ) ; create Sun Xml Key Val Files ( node , sunxmlkeyvals ) ; if ( ! root . add Child ( node ) ) { throw new SMS Exception ( STRING + obj Name ) ; } save Directory Tree ( ) ; } catch ( SMS Exception e ) { File attr File = new File ( filepath ) ; try { attr File . delete ( ) ; } catch ( Security Exception se ) { } throw e ; } } finally { mRW Lock . write Done ( ) ; } }
public void add On Tab Selected Listener ( On Tab Selected Listener listener ) { if ( listener != null ) { m Listeners . add ( listener ) ; } }
public Social Share image ( Uri image Uri ) { if ( image Uri == null ) throw new Illegal Argument Exception ( STRING ) ; if ( this . uri != null ) throw new Illegal State Exception ( STRING ) ; this . uri = image Uri ; this . mime Type = Mime . ANY IMAGE ; return this ; }
public void move Volumes From One Storage Group To Another ( Storage System storage , CIM Object Path source Masking Group , CIM Object Path target Masking Group , List < URI > volume UR Is , Smis Job job ) throws Exception { Set < String > volume Device Ids = new Hash Set < String > ( ) ; for ( URI vol URI : volume UR Is ) { Volume volume = db Client . query Object ( Volume . class , vol URI ) ; volume Device Ids . add ( volume . get Native Id ( ) ) ; } CIM Argument [ ] in Args = get Move Volumes Between Masking Group Input Arguments ( storage , source Masking Group , target Masking Group , volume Device Ids ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM ] ; invoke Method Synchronously ( storage , cim Path . get Controller Config Svc Path ( storage ) , STRING , in Args , out Args , job ) ; }
public boolean import Pkcs 12 ( ) { return jrb Pkcs 12 . is Selected ( ) ; }
public Cycle Bound Tick ( boolean map To Last Cycle , Number number , String label , Text Anchor text Anchor , Text Anchor rotation Anchor , double angle ) { super ( number , label , text Anchor , rotation Anchor , angle ) ; this . map To Last Cycle = map To Last Cycle ; }
private int draw Label String Valign ( Android Graphics underlying , Codename One Text Paint native Font , String str , int x , int y , int text Space W , boolean is Ticker Running , int ticker Shift Text , int text Decoration , boolean rtl , boolean ends With 3 Points , int text Width , int icon String H Gap , int icon Height , int font Height , int valign , Bitmap text Cache ) { if ( str . length ( ) == NUM ) { return NUM ; } switch ( valign ) { case Component . TOP : return draw Label String ( underlying , native Font , str , x , y , text Space W , is Ticker Running , ticker Shift Text , text Decoration , rtl , ends With 3 Points , text Width , font Height , text Cache ) ; case Component . CENTER : return draw Label String ( underlying , native Font , str , x , y + icon Height / NUM - font Height / NUM , text Space W , is Ticker Running , ticker Shift Text , text Decoration , rtl , ends With 3 Points , text Width , font Height , text Cache ) ; default : return draw Label String ( underlying , native Font , str , x , y + icon String H Gap , text Space W , is Ticker Running , ticker Shift Text , text Decoration , rtl , ends With 3 Points , text Width , font Height , text Cache ) ; } }
public void error ( Level level , String message Id , String data [ ] , Object session , Map props ) throws Log Exception { if ( is Error Loggable ( level ) ) { Log Record lr = new Log Record ( level , format Message ( message Id , data , session ) ) ; error Logger . log ( lr ) ; } }
public Gossip Service ( String cluster , String ip Address , int port , String id , List < Gossip Member > gossip Members , Gossip Settings settings , Gossip Listener listener ) throws Interrupted Exception , Unknown Host Exception { gossip Manager = new Random Gossip Manager ( cluster , ip Address , port , id , settings , gossip Members , listener ) ; }
public boolean visible From ( Ct Class clazz ) { int mod = get Modifiers ( ) ; if ( Modifier . is Public ( mod ) ) return BOOL ; else if ( Modifier . is Private ( mod ) ) return clazz == declaring Class ; else { String decl Name = declaring Class . get Package Name ( ) ; String from Name = clazz . get Package Name ( ) ; boolean visible ; if ( decl Name == null ) visible = from Name == null ; else visible = decl Name . equals ( from Name ) ; if ( ! visible && Modifier . is Protected ( mod ) ) return clazz . subclass Of ( declaring Class ) ; return visible ; } }
public JSON Buffer append Key Array ( Object key ) { if ( stack . empty ( ) || stack . peek ( ) != Operand . HASH ) { throw new JSON Exception ( STRING ) ; } add Quoted String ( key ) ; buffer . append ( STRING ) ; buffer . append ( STRING ) ; stack . push ( Operand . ARRAY ) ; return this ; }
public static Tungsten Properties load Passwords From Authentication Info ( Authentication Info authentication Info ) throws Server Runtime Exception { try { String password File Location = authentication Info . get Password File Location ( ) ; Tungsten Properties new Props = new Tungsten Properties ( ) ; new Props . load ( new File Input Stream ( password File Location ) , BOOL ) ; new Props . trim ( ) ; logger . debug ( Message Format . format ( STRING , password File Location ) ) ; return new Props ; } catch ( File Not Found Exception e ) { throw new Server Runtime Exception ( STRING + authentication Info . get Password File Location ( ) , e ) ; } catch ( IO Exception e ) { throw new Server Runtime Exception ( STRING + authentication Info . get Password File Location ( ) , e ) ; } }
public void error ( Level level , String message Id , String data [ ] , Object session , Map props ) throws Log Exception { if ( is Error Loggable ( level ) ) { Log Record lr = new Log Record ( level , format Message ( message Id , data , session ) ) ; error Logger . log ( lr ) ; } }
public synchronized int index Of ( I Audio Processor processor ) { return processors . index Of ( processor ) ; }
private int end Recover Animation ( Recycler View . View Holder view Holder , boolean override ) { final int recover Anim Size = m Recover Animations . size ( ) ; for ( int i = recover Anim Size - NUM ; i >= NUM ; i -- ) { final Recover Animation anim = m Recover Animations . get ( i ) ; if ( anim . m View Holder == view Holder ) { anim . m Overridden |= override ; if ( ! anim . m Ended ) { anim . cancel ( ) ; } m Recover Animations . remove ( i ) ; return anim . m Animation Type ; } } return NUM ; }
private void add Proxy Method ( Method m , Class < ? > from Class ) { String name = m . get Name ( ) ; Class < ? > [ ] parameter Types = m . get Parameter Types ( ) ; Class < ? > return Type = m . get Return Type ( ) ; Class < ? > [ ] exception Types = m . get Exception Types ( ) ; String sig = name + get Parameter Descriptors ( parameter Types ) ; List < Proxy Method > sigmethods = proxy Methods . get ( sig ) ; if ( sigmethods != null ) { for ( Proxy Method pm : sigmethods ) { if ( return Type == pm . return Type ) { List < Class < ? > > legal Exceptions = new Array List < > ( ) ; collect Compatible Types ( exception Types , pm . exception Types , legal Exceptions ) ; collect Compatible Types ( pm . exception Types , exception Types , legal Exceptions ) ; pm . exception Types = new Class < ? > [ legal Exceptions . size ( ) ] ; pm . exception Types = legal Exceptions . to Array ( pm . exception Types ) ; return ; } } } else { sigmethods = new Array List < > ( NUM ) ; proxy Methods . put ( sig , sigmethods ) ; } sigmethods . add ( new Proxy Method ( name , parameter Types , return Type , exception Types , from Class ) ) ; }
void update Pressed ( Action Event e , boolean new Signal Group , boolean close ) { if ( cur Signal Group == null ) { if ( ! check New Names OK ( ) ) { return ; } } if ( ! check Valid Signal Mast ( ) ) { return ; } String u Name = user Name . get Text ( ) ; Signal Group g = check Names OK ( ) ; if ( g == null ) { return ; } cur Signal Group = g ; g . set User Name ( u Name ) ; initialize Included List ( ) ; set Signal Information ( g ) ; set Mast Appearance Information ( g ) ; g . set Signal Mast ( ( Signal Mast ) main Signal . get Selected Bean ( ) , main Signal . get Selected Display Name ( ) ) ; Signal Group Dirty = BOOL ; if ( close ) { finish Update ( ) ; } }
protected String attribute Values String ( Instance instance ) { String Buffer text = new String Buffer ( ) ; if ( m Attributes != null ) { m Attributes . set Upper ( instance . num Attributes ( ) - NUM ) ; boolean first = BOOL ; for ( int i = NUM ; i < instance . num Attributes ( ) ; i ++ ) { if ( m Attributes . is In Range ( i ) && i != instance . class Index ( ) ) { if ( ! first ) { text . append ( m Delimiter ) ; } text . append ( instance . to String ( i ) ) ; first = BOOL ; } } } return text . to String ( ) ; }
private static void check For KOML ( ) { try { Class . for Name ( STRING ) ; m Present = BOOL ; } catch ( Exception e ) { m Present = BOOL ; } }
@ Target Api ( Build . VERSION CODES . GINGERBREAD MR 1 ) private Response < Bitmap > do Parse ( Network Response response ) { byte [ ] data = response . data ; Bitmap Factory . Options decode Options = new Bitmap Factory . Options ( ) ; decode Options . in Input Shareable = BOOL ; decode Options . in Purgeable = BOOL ; decode Options . in Preferred Config = m Decode Config ; Bitmap bitmap ; if ( m Max Width == NUM && m Max Height == NUM ) { bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; } else { decode Options . in Just Decode Bounds = BOOL ; Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; int actual Width = decode Options . out Width ; int actual Height = decode Options . out Height ; int desired Width = get Resized Dimension ( m Max Width , m Max Height , actual Width , actual Height , m Scale Type ) ; int desired Height = get Resized Dimension ( m Max Height , m Max Width , actual Height , actual Width , m Scale Type ) ; decode Options . in Just Decode Bounds = BOOL ; if ( Utils . has Gingerbread MR 1 ( ) ) { decode Options . in Prefer Quality Over Speed = PREFER QUALITY OVER SPEED ; } decode Options . in Sample Size = Image Utils . find Best Sample Size ( actual Width , actual Height , desired Width , desired Height ) ; Bitmap temp Bitmap = Bitmap Factory . decode Byte Array ( data , NUM , data . length , decode Options ) ; if ( temp Bitmap != null && ( temp Bitmap . get Width ( ) > desired Width || temp Bitmap . get Height ( ) > desired Height ) ) { bitmap = Bitmap . create Scaled Bitmap ( temp Bitmap , desired Width , desired Height , BOOL ) ; temp Bitmap . recycle ( ) ; } else { bitmap = temp Bitmap ; } } if ( bitmap == null ) { return Response . error ( new Parse Error ( response ) ) ; } else { return Response . success ( bitmap , Http Header Parser . parse Cache Headers ( response ) ) ; } }
public double evaluate ( Vector Instance x , Vector Instance y ) throws Exception { double dot Prod = x . dot Product ( y ) ; double z = m gamma * dot Prod + m coef 0 ; double a = Math . exp ( z ) ; double b = Math . exp ( - z ) ; return ( ( a - b ) / ( a + b ) ) ; }
@ Override public void batch Size ( int size ) { A . ensure ( size > NUM , STRING + size ) ; lock . lock ( ) ; try { batch Size = size ; } finally { lock . unlock ( ) ; } }
public void clear ( ) { if ( m View Type Count == NUM ) { final Array List < View > scrap = m Current Scrap ; final int scrap Count = scrap . size ( ) ; for ( int i = NUM ; i < scrap Count ; i ++ ) { remove Detached View ( scrap . remove ( scrap Count - NUM - i ) , BOOL ) ; } } else { final int type Count = m View Type Count ; for ( int i = NUM ; i < type Count ; i ++ ) { final Array List < View > scrap = m Scrap Views [ i ] ; final int scrap Count = scrap . size ( ) ; for ( int j = NUM ; j < scrap Count ; j ++ ) { remove Detached View ( scrap . remove ( scrap Count - NUM - j ) , BOOL ) ; } } } if ( m Transient State Views != null ) { m Transient State Views . clear ( ) ; } }
public FPS Surface View add Child At ( int location , @ Non Null Display Base Display Base ) { Display Base . set Up ( m Fps ) ; m Display List . add ( location , Display Base ) ; return this ; }
private double [ ] prune ( Tree tree , Node Ref node , Colour Change Matrix mm ) { double [ ] p = new double [ colour Count ] ; if ( tree . is External ( node ) ) { p [ get Colour ( node ) ] = NUM ; } else { Node Ref left Child = tree . get Child ( node , NUM ) ; Node Ref right Child = tree . get Child ( node , NUM ) ; double [ ] left = prune ( tree , left Child , mm ) ; double [ ] right = prune ( tree , right Child , mm ) ; double node Height = tree . get Node Height ( node ) ; double left Time = node Height - tree . get Node Height ( tree . get Child ( node , NUM ) ) ; double right Time = node Height - tree . get Node Height ( tree . get Child ( node , NUM ) ) ; double maxp = NUM ; for ( int i = NUM ; i < colour Count ; i ++ ) { double left Sum = NUM ; double right Sum = NUM ; for ( int j = NUM ; j < colour Count ; j ++ ) { left Sum += mm . forward Time Evolution ( i , j , left Time ) * left [ j ] ; right Sum += mm . forward Time Evolution ( i , j , right Time ) * right [ j ] ; } p [ i ] = left Sum * right Sum ; if ( p [ i ] > maxp ) { maxp = p [ i ] ; } } if ( maxp < NUM ) { for ( int i = NUM ; i < colour Count ; i ++ ) { p [ i ] *= NUM ; } log Node Partials Rescaling -= Math . log ( NUM ) ; } } node Partials [ node . get Number ( ) ] = p ; if ( debug Node Partials ) { pretty Print ( STRING + node . get Number ( ) + STRING , p ) ; } return p ; }
private void bfs ( char [ ] [ ] grid , int i , int j ) { Queue < Point > queue = new Array Deque < > ( ) ; grid [ i ] [ j ] = STRING ; queue . add ( new Point ( i , j ) ) ; while ( ! queue . is Empty ( ) ) { Point p = queue . poll ( ) ; for ( int [ ] dir : dirs ) { int row = p . row + dir [ NUM ] ; int col = p . col + dir [ NUM ] ; if ( row >= NUM && row < grid . length && col >= NUM && col < grid [ row ] . length && grid [ row ] [ col ] == STRING ) { grid [ row ] [ col ] = STRING ; queue . add ( new Point ( row , col ) ) ; } } } }
public Time ( Date date ) { Simple Time Zone tz = new Simple Time Zone ( NUM , STRING ) ; Simple Date Format date F = new Simple Date Format ( STRING ) ; date F . set Time Zone ( tz ) ; String d = date F . format ( date ) + STRING ; int year = Integer . parse Int ( d . substring ( NUM , NUM ) ) ; if ( year < NUM || year > NUM ) { time = new DER Generalized Time ( d ) ; } else { time = new DERUTC Time ( d . substring ( NUM ) ) ; } }
public D Import Key Pair Pvk ( J Frame parent ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; init Components ( ) ; }
public static Automaton determinize Simple ( Automaton a ) { Set < Integer > initialset = new Hash Set < > ( ) ; initialset . add ( NUM ) ; return determinize Simple ( a , initialset ) ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) return BOOL ; if ( o == null || get Class ( ) != o . get Class ( ) ) return BOOL ; Abstract Drawer Item < ? , ? > that = ( Abstract Drawer Item < ? , ? > ) o ; return m Identifier == that . m Identifier ; }
public void add Column ( Column previous Column , Column column ) { if ( column != null ) { if ( previous Column == null ) { columns . add ( NUM , column ) ; } else { columns . add ( columns . index Of ( previous Column ) , column ) ; } } }
public static void render Orthogonal ( Complex Vector vec 1 , Complex Vector vec 2 ) { Incompatible Vectors Exception . check Vectors Compatible ( vec 1 , vec 2 ) ; if ( vec 1 . get Op Mode ( ) != Complex Vector . Mode . CARTESIAN ) vec 1 . to Cartesian ( ) ; if ( vec 2 . get Op Mode ( ) != Complex Vector . Mode . CARTESIAN ) vec 2 . to Cartesian ( ) ; float [ ] coordinates 1 = vec 1 . get Coordinates ( ) ; float [ ] coordinates 2 = vec 2 . get Coordinates ( ) ; double cosine = vec 1 . measure Hermitian Overlap ( vec 2 ) ; for ( int i = NUM ; i < coordinates 1 . length ; i ++ ) coordinates 1 [ i ] = ( float ) ( coordinates 1 [ i ] - cosine * coordinates 2 [ i ] ) ; }
public static String build Selector From Elements And Attribute Value ( String element Name , String attribute Name , String attribute Value ) { String Builder strb = new String Builder ( ) ; strb . append ( element Name ) ; strb . append ( OPEN BRACKET ) ; strb . append ( attribute Name ) ; strb . append ( EQUAL ) ; strb . append ( attribute Value ) ; strb . append ( CLOSE BRACKET ) ; return strb . to String ( ) ; }
public void dump PAG For Method ( String f Name , String c Name , String m Name ) throws File Not Found Exception { File Output Stream fos = new File Output Stream ( new File ( f Name ) ) ; Print Stream ps = new Print Stream ( fos ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; dump Local PAG ( c Name , m Name , ps ) ; ps . print ( STRING ) ; try { fos . close ( ) ; } catch ( IO Exception e ) { } ps . close ( ) ; }
@ Override public double calculate K ( int [ ] x index , double [ ] x att , int [ ] y index , double [ ] y att ) { return Math . sqrt ( ( norm 2 ( x index , x att , y index , y att ) / sigma ) + ( shift * shift ) ) ; }
@ Override public void close ( ) throws IO Exception { synchronized ( lock ) { if ( is Closed ( ) ) { return ; } Throwable thrown = null ; try { flush Internal ( ) ; } catch ( Throwable e ) { thrown = e ; } buf = null ; try { out . close ( ) ; } catch ( Throwable e ) { if ( thrown == null ) { thrown = e ; } } out = null ; if ( thrown != null ) { Sneaky Throw . sneaky Throw ( thrown ) ; } } }
public static double cos ( double radians ) { return Math . cos ( radians ) ; }
public static double ss Reg ( double [ ] residuals , double [ ] target Attribute ) { double mean = sum ( target Attribute ) / target Attribute . length ; double ret = NUM ; for ( int i = NUM ; i < residuals . length ; i ++ ) { ret += Math . pow ( residuals [ i ] - mean , NUM ) ; } return ret ; }
public void test Find Prefixes ( ) { Vector < String > prefixes = m Trie . get With Prefix ( STRING ) ; assert Equals ( STRING , NUM , prefixes . size ( ) ) ; prefixes = m Trie . get With Prefix ( STRING ) ; assert Equals ( STRING , NUM , prefixes . size ( ) ) ; }
static Jpa Target update Target Info ( @ Not Null final Jpa Target target , @ Not Null final Target Update Status status , final boolean set Installed Date , final Target Info Repository target Info Repository , final Entity Manager entity Manager ) { final Jpa Target Info ts = ( Jpa Target Info ) target . get Target Info ( ) ; ts . set Update Status ( status ) ; if ( set Installed Date ) { ts . set Installation Date ( System . current Time Millis ( ) ) ; } target Info Repository . save ( ts ) ; return entity Manager . merge ( target ) ; }
public < T extends Enum < T > > T consume Enum ( String name , boolean required , Class < T > enum Class , T default Value ) throws Parse Exception { String value = consume ( name , required ) ; if ( value == null ) { return default Value ; } try { return Enum . value Of ( enum Class , value . to Upper Case ( ) ) ; } catch ( Illegal Argument Exception e ) { Parse Exception pe = new Parse Exception ( Core Error Domain . ERR . invalid Attribute Value , e ) ; pe . set Internal Reason ( STRING + name + STRING ) ; throw pe ; } }
public final void copy ( byte [ ] bytes , int offset , int length ) { if ( this . bytes == null || this . bytes . length < length ) { this . bytes = new byte [ length ] ; } System . arraycopy ( bytes , offset , this . bytes , NUM , length ) ; this . count = length ; }
public void decrypt ( Key Parameter aes Key ) { lock . lock ( ) ; try { check State ( get Encryption Type ( ) != Encryption Type . UNENCRYPTED , STRING ) ; check Not Null ( key Crypter ) ; Array List < EC Key > decrypted Key Chain = new Array List < EC Key > ( ) ; for ( EC Key key : keychain ) { if ( ! key . is Encrypted ( ) ) { decrypted Key Chain . add ( key ) ; } else { EC Key decrypted EC Key = key . decrypt ( key Crypter , aes Key ) ; decrypted Key Chain . add ( decrypted EC Key ) ; } } keychain = decrypted Key Chain ; key Crypter = null ; extensions . remove ( Multi Bit Wallet Protobuf Serializer . ORG MULTIBIT WALLET PROTECT 2 ) ; } finally { lock . unlock ( ) ; } }
public void init ( Authenticated User user , LDAP Connection ldap Connection ) throws Guacamole Exception { user Directory = new Simple Directory < User > ( user Service . get Users ( ldap Connection ) ) ; connection Directory = new Simple Directory < Connection > ( connection Service . get Connections ( user , ldap Connection ) ) ; root Group = new Simple Connection Group ( LDAP Authentication Provider . ROOT CONNECTION GROUP , LDAP Authentication Provider . ROOT CONNECTION GROUP , connection Directory . get Identifiers ( ) , Collections . < String > empty List ( ) ) ; connection Group Directory = new Simple Connection Group Directory ( Collections . singleton ( root Group ) ) ; self = new Simple User ( user . get Identifier ( ) , user Directory . get Identifiers ( ) , connection Directory . get Identifiers ( ) , connection Group Directory . get Identifiers ( ) ) ; }
public int skip Whitespace ( ) { try { int read Char = NUM ; char c = SPACE ; while ( Character . is Whitespace ( c ) ) { reader . mark ( NUM ) ; read Char = reader . read ( ) ; c = ( char ) read Char ; } reader . reset ( ) ; return read Char ; } catch ( IO Exception ioe ) { throw new Json Exception ( STRING , ioe ) ; } }
public static boolean is Button Pressed ( Input Event e , int button ) { return ( e . get Modifiers ( ) & button ) == button ; }
private synchronized void init ( String instance RDN ) throws Exception { String srvc Name = get Service Name ( ) ; if ( admin Token == null ) { admin Token = ( SSO Token ) Access Controller . do Privileged ( Admin Token Action . get Instance ( ) ) ; s Manager = new Service Manager ( admin Token ) ; Service Schema Manager schema Manager = s Manager . get Schema Manager ( srvc Name , SERVICE VERSION ) ; client Service Schema = schema Manager . get Global Schema ( ) ; client Schema = client Service Schema . get Sub Schema ( DBSTORE SUBSCHEMA ID ) ; client Schema = client Schema . get Sub Schema ( CLIENT SUBSCHEMA ID ) ; am Connection = new AM Store Connection ( admin Token ) ; top Level DN = am Connection . get Organization DN ( null , null ) ; init Client Schema ( ) ; init Configuration Info ( client Service Schema ) ; client Data DN = CLIENT DATA DN PREFIX + COMMA + top Level DN ; } database DN = instance RDN + COMMA + client Data DN ; am Client Org = am Connection . get Organizational Unit ( database DN ) ; }
public static boolean is Auto Scan Enabled ( Context context ) { final Shared Preferences prefs = Preference Manager . get Default Shared Preferences ( context ) ; return prefs . get Boolean ( context . get String ( R . string . pref key auto scan enabled ) , Boolean . parse Boolean ( context . get String ( R . string . pref auto scan default value ) ) ) ; }
Type Simplifier ( Types type Utils , String package Name , Set < Type Mirror > types , Type Mirror base ) { this . type Utils = type Utils ; Set < Type Mirror > types Plus Base = new Type Mirror Set ( types ) ; if ( base != null ) { types Plus Base . add ( base ) ; } Set < Type Mirror > referenced = referenced Class Types ( type Utils , types Plus Base ) ; Set < Type Mirror > defined = non Private Declared Types ( type Utils , base ) ; this . imports = find Imports ( type Utils , package Name , referenced , defined ) ; }
public static Histogram subtract ( Histogram x , double y ) { return x . modify Event Counters ( null ) ; }
private Point add Point ( Polygon arrow , Rectangle rect , int pos , boolean from ) { int x = rect . x ; int y = rect . y ; Point point = null ; if ( pos == Swing Constants . TOP ) { x += rect . width / NUM ; if ( from ) { arrow . add Point ( x - NUM , y ) ; arrow . add Point ( x + NUM , y ) ; } else arrow . add Point ( x , y ) ; point = new Point ( x , y - NUM ) ; } else if ( pos == Swing Constants . RIGHT ) { x += rect . width ; y += rect . height / NUM ; if ( from ) { arrow . add Point ( x , y - NUM ) ; arrow . add Point ( x , y + NUM ) ; } else arrow . add Point ( x , y ) ; point = new Point ( x + NUM , y ) ; } else if ( pos == Swing Constants . LEFT ) { y += rect . height / NUM ; if ( from ) { arrow . add Point ( x , y - NUM ) ; arrow . add Point ( x , y + NUM ) ; } else arrow . add Point ( x , y ) ; point = new Point ( x - NUM , y ) ; } else { x += rect . width / NUM ; y += rect . height ; if ( from ) { arrow . add Point ( x - NUM , y ) ; arrow . add Point ( x + NUM , y ) ; } else arrow . add Point ( x , y ) ; point = new Point ( x , y + NUM ) ; } return point ; }
void refresh ( String filter , Set < Identity > selected Participants ) { Set < Identity > filtered Identities = filter ( filter ) ; for ( Identity selected Participant : selected Participants ) { filtered Identities . remove ( selected Participant ) ; } m Participants . clear ( ) ; m Participants . add All ( filtered Identities ) ; Collections . sort ( m Participants , new Identity Display Name Comparator ( ) ) ; notify Data Set Changed ( ) ; if ( m Show Conversations ) { query Conversations ( selected Participants ) ; } }
private void savehttp Red Mni ( String mnihttp Location , String mnihttp Resp Location , List manage Name Id List , com . sun . identity . saml 2 . jaxb . metadata . Object Factory obj Fact ) throws JAXB Exception { if ( mnihttp Location != null && mnihttp Location . length ( ) > NUM ) { Manage Name ID Service Element sls Elem Red = obj Fact . create Manage Name ID Service Element ( ) ; sls Elem Red . set Binding ( http Redirect Binding ) ; sls Elem Red . set Location ( mnihttp Location ) ; sls Elem Red . set Response Location ( mnihttp Resp Location ) ; manage Name Id List . add ( sls Elem Red ) ; } }
public static Intent create Take Video Intent ( Activity ctx , Uri saving Uri , int duration In Seconds ) { if ( saving Uri == null ) { throw new Null Pointer Exception ( STRING ) ; } final List < Intent > camera Intents = new Array List < Intent > ( ) ; final Intent capture Intent = new Intent ( Media Store . ACTION VIDEO CAPTURE ) ; final Package Manager package Manager = ctx . get Package Manager ( ) ; final List < Resolve Info > list Cam = package Manager . query Intent Activities ( capture Intent , NUM ) ; for ( Resolve Info res : list Cam ) { final String package Name = res . activity Info . package Name ; final Intent intent = new Intent ( capture Intent ) ; intent . set Component ( new Component Name ( res . activity Info . package Name , res . activity Info . name ) ) ; intent . set Package ( package Name ) ; intent . put Extra ( Media Store . EXTRA OUTPUT , saving Uri ) ; intent . put Extra ( Media Store . EXTRA DURATION LIMIT , duration In Seconds ) ; camera Intents . add ( intent ) ; } final Intent gallery Intent = new Intent ( ) ; gallery Intent . set Type ( STRING ) ; gallery Intent . set Action ( Intent . ACTION GET CONTENT ) ; final Intent chooser Intent = Intent . create Chooser ( gallery Intent , STRING ) ; chooser Intent . put Extra ( Intent . EXTRA INITIAL INTENTS , camera Intents . to Array ( new Parcelable [ ] { } ) ) ; return chooser Intent ; }
public static List < Virtual File > find Files Closest To Target ( @ Not Null final List < String > target Parent Folders , final List < File Info > candidates , final int min Proximity Threshold ) { if ( candidates . is Empty ( ) ) { return Collections . empty List ( ) ; } for ( String folder Name : target Parent Folders ) { for ( File Info info : candidates ) { info . process Relative Path Component ( folder Name ) ; } } int max Proximity = NUM ; for ( File Info file Info : candidates ) { final int proximity = file Info . get Proximity ( ) ; if ( proximity > max Proximity ) { max Proximity = proximity ; } } if ( max Proximity >= min Proximity Threshold ) { final List < Virtual File > files = new Array List < Virtual File > ( ) ; for ( File Info info : candidates ) { if ( info . get Proximity ( ) == max Proximity ) { files . add ( info . get File ( ) ) ; } } return files ; } return Collections . empty List ( ) ; }
private static void install Security Mgr ( ) { try { System . set Security Manager ( new RMI Security Manager ( ) ) ; } catch ( Exception e ) { } }
public static Big Decimal convert ( Big Decimal p Amount , int p C Currency From ID , int p C Currency To ID , Timestamp p Conversion Date , int p C Conversion Type ID , int p AD Client ID , int p AD Org ID ) throws SQL Exception { if ( p Amount == null || p C Currency From ID == NUM || p C Currency To ID == NUM ) return null ; if ( p Amount . signum ( ) == NUM || p C Currency From ID == p C Currency To ID ) return p Amount ; Big Decimal rate = rate ( p C Currency From ID , p C Currency To ID , p Conversion Date , p C Conversion Type ID , p AD Client ID , p AD Org ID ) ; if ( rate == null ) return null ; return round ( p Amount . multiply ( rate ) , p C Currency To ID , null ) ; }
public static Snmp Engine Id create Engine Id ( int port , int iana ) throws Unknown Host Exception { Inet Address address = null ; address = Inet Address . get Local Host ( ) ; return create Engine Id ( address , port , iana ) ; }
public static List < Active Rule > import Configuration ( String configuration , List < Rule > rules Repository ) { Ruleset ruleset = Delphi Rules Utils . build Rule Set From Xml ( configuration ) ; List < Active Rule > active Rules = new Array List < Active Rule > ( ) ; for ( Delphi Rule f Rule : ruleset . get Rules ( ) ) { Active Rule active Rule = create Active Rule ( f Rule , rules Repository ) ; if ( active Rule != null ) { active Rules . add ( active Rule ) ; } } return active Rules ; }
public org . w3 c . dom . Element sign XML ( org . w3 c . dom . Document doc , java . lang . String cert Alias , java . lang . String algorithm , java . util . List ids ) throws XML Signature Exception { return sign XML ( doc , cert Alias , algorithm , null , ids ) ; }
public void insert Child ( Node [ ] nodes , int index ) { for ( Node node : nodes ) { node . detach From Parent ( ) ; node . parent Node = this ; try { init Child Nodes ( node ) ; child Nodes . add ( index , node ) ; index ++ ; } catch ( Index Out Of Bounds Exception ignore ) { throw new Lagarto DOM Exception ( STRING + index ) ; } } reindex Children ( ) ; }
private static byte [ ] ntlm Hash ( String password ) throws Exception { byte [ ] unicode Password = password . get Bytes ( STRING ) ; Message Digest md 4 = Message Digest . get Instance ( STRING ) ; return md 4 . digest ( unicode Password ) ; }
protected boolean add New Icon ( String name ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + icon Map . size ( ) ) ; } if ( name == null || name . length ( ) == NUM ) { J Option Pane . show Message Dialog ( parent . palette Frame , Bundle . get Message ( STRING ) , Bundle . get Message ( STRING ) , J Option Pane . WARNING MESSAGE ) ; return BOOL ; } else if ( icon Map . get ( name ) != null ) { J Option Pane . show Message Dialog ( parent . palette Frame , Bundle . get Message ( STRING , name ) , Bundle . get Message ( STRING ) , J Option Pane . WARNING MESSAGE ) ; return BOOL ; } String file Name = STRING ; Named Icon icon = new jmri . jmrit . catalog . Named Icon ( file Name , file Name ) ; icon Map . put ( name , icon ) ; return BOOL ; }
public static Parameter Type make File Parameter Type ( Parameter Handler parameter Handler , String parameter Name , String description , Port Provider port Provider , String ... file Extensions ) { return make File Parameter Type ( parameter Handler , parameter Name , description , port Provider , BOOL , file Extensions ) ; }
public Matrix pow ( double exp ) { Matrix X = new Matrix ( m , n ) ; double [ ] [ ] C = X . get Array ( ) ; for ( int i = NUM ; i < m ; i ++ ) for ( int j = NUM ; j < n ; j ++ ) C [ i ] [ j ] = Math . pow ( A [ i ] [ j ] , exp ) ; return X ; }
public static String format Duration ( long duration ) { String Builder result = new String Builder ( ) ; long remaining Duration = duration ; if ( remaining Duration == NUM ) { result . append ( STRING ) ; } else { remaining Duration = process Duration ( remaining Duration , MILLIS PER DAY , STRING , result , BOOL ) ; remaining Duration = process Duration ( remaining Duration , MILLIS PER HOUR , STRING , result , BOOL ) ; remaining Duration = process Duration ( remaining Duration , MILLIS PER MINUTE , STRING , result , BOOL ) ; remaining Duration = process Duration ( remaining Duration , MILLIS PER SECOND , STRING , result , BOOL ) ; long milli Seconds = remaining Duration ; if ( milli Seconds > NUM ) { process Duration ( remaining Duration , NUM , STRING , result , BOOL ) ; } } return result . to String ( ) ; }
public Node List select Node List ( Node context Node , Node xpathnode , String str , Node namespace Node ) throws Transformer Exception { if ( ! str . equals ( xpath Str ) || xpath Expression == null ) { if ( xpf == null ) { xpf = X Path Factory . new Instance ( ) ; try { xpf . set Feature ( XML Constants . FEATURE SECURE PROCESSING , Boolean . TRUE ) ; } catch ( X Path Factory Configuration Exception ex ) { throw new Transformer Exception ( STRING , ex ) ; } } X Path xpath = xpf . new X Path ( ) ; xpath . set Namespace Context ( new DOM Namespace Context ( namespace Node ) ) ; xpath Str = str ; try { xpath Expression = xpath . compile ( xpath Str ) ; } catch ( X Path Expression Exception ex ) { throw new Transformer Exception ( STRING , ex ) ; } } try { return ( Node List ) xpath Expression . evaluate ( context Node , X Path Constants . NODESET ) ; } catch ( X Path Expression Exception ex ) { throw new Transformer Exception ( STRING , ex ) ; } }
private void generate ( Region . Entry entry ) throws SAX Exception { if ( ( entry == null ) ) { return ; } handler . start Element ( STRING , ENTRY , ENTRY , EMPTY ) ; handler . start Element ( STRING , KEY , KEY , EMPTY ) ; generate ( entry . get Key ( ) ) ; handler . end Element ( STRING , KEY , KEY ) ; handler . start Element ( STRING , VALUE , VALUE , EMPTY ) ; generate ( entry . get Value ( ) ) ; handler . end Element ( STRING , VALUE , VALUE ) ; handler . end Element ( STRING , ENTRY , ENTRY ) ; }
public void test Ordered By Type Mapping ( ) throws Exception { List type Names = get Type Names In Order ( ) ; int sql Variant Index = type Names . index Of ( STRING ) ; if ( sql Variant Index != - NUM ) { check Order ( type Names , STRING , STRING ) ; } check Order ( type Names , STRING , STRING ) ; check Order ( type Names , STRING , STRING ) ; check Order ( type Names , STRING , STRING ) ; }
@ Override public void action Performed ( Action Event e ) { if ( e . get Source ( ) == ok ) { close Action = ACTION OK ; } set Visible ( BOOL ) ; }
private void parameter Type ( Method method ) { Type Variable < Method > type Parameter = get Type Parameter ( method ) ; assert Lenght One ( method . get Generic Parameter Types ( ) ) ; Type generic Parameter Type = method . get Generic Parameter Types ( ) [ NUM ] ; assert Equals ( type Parameter , generic Parameter Type ) ; assert True ( generic Parameter Type instanceof Type Variable ) ; Type Variable < ? > type Variable = ( Type Variable < ? > ) generic Parameter Type ; assert Equals ( method , type Variable . get Generic Declaration ( ) ) ; Type [ ] param Bounds = type Variable . get Bounds ( ) ; assert Lenght One ( param Bounds ) ; Type param Bound = param Bounds [ NUM ] ; assert Equals ( Bounded Generic Methods . class , param Bound ) ; }
public static List < ? extends Node > child Node List ( Node node ) { if ( node == null ) return null ; List < Node > nodes = new Linked List < Node > ( ) ; do { if ( node . get Node Type ( ) == Node . ELEMENT NODE || node . get Node Type ( ) == Node . COMMENT NODE ) { nodes . add ( node ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; return nodes ; }
synchronized void load Mapper ( ) throws SMS Exception { String file Name = m Root Dir + File . separator + DIR TREE FILENAME ; File file Handle = new File ( file Name ) ; if ( file Handle . is File ( ) ) { if ( ! file Handle . can Read ( ) ) { String errmsg = STRING + file Name ; m Debug . error ( errmsg ) ; throw new SMS Exception ( errmsg ) ; } parse Directory Tree XML ( file Name ) ; } else { try { file Handle . create New File ( ) ; } catch ( IO Exception e ) { String errmsg = STRING + STRING + file Name + STRING + e . get Message ( ) ; m Debug . error ( STRING , e ) ; throw new SMS Exception ( errmsg ) ; } catch ( Security Exception e ) { String errmsg = STRING + STRING + file Name + STRING + e . get Message ( ) ; m Debug . error ( STRING , e ) ; throw new SMS Exception ( errmsg ) ; } root = new SMS Flat File Tree Node ( m Root DN ) ; try { Map map = new Hash Map ( NUM ) ; Set set = new Hash Set ( NUM ) ; set . add ( STRING ) ; set . add ( STRING ) ; map . put ( STRING , set ) ; create ( null , STRING + m Root DN , map ) ; save Directory Tree ( ) ; } catch ( SSO Exception e ) { } catch ( Service Already Exists Exception e ) { m Debug . message ( STRING , e ) ; } } }
private static void add To TT ( String tt S Name , boolean start BR , Object ... tt O ) { if ( start BR == BR ) tooltip String . append ( STRING ) ; if ( tt O != null ) { tooltip String . append ( Messages . get String ( STRING + tt S Name , tt O ) ) ; } else { tooltip String . append ( Messages . get String ( STRING + tt S Name ) ) ; } }
public void write String No Compression ( String str ) throws IO Exception { if ( str == null ) { write Int ( NUM ) ; } else { write Int ( str . length ( ) ) ; for ( int i = NUM ; i < str . length ( ) ; i ++ ) outs . write ( ( byte ) str . char At ( i ) ) ; position += str . length ( ) ; } }
private boolean read GZIP File ( final File fl ) throws IO Exception , File Not Found Exception { boolean success = BOOL ; Buffered Reader reader = null ; try { reader = new Buffered Reader ( new Input Stream Reader ( new GZIP Input Stream ( new File Input Stream ( fl ) ) ) ) ; int line = NUM ; String read Line = null ; while ( reader . ready ( ) && ( read Line = reader . read Line ( ) ) != null ) { parse Value ( read Line , line ) ; line ++ ; } reader . close ( ) ; success = BOOL ; } finally { if ( reader != null ) { reader . close ( ) ; } } return success ; }
public Single Timed Scheduler ( Thread Factory thread Factory ) { Scheduled Thread Pool Executor e = ( Scheduled Thread Pool Executor ) Executors . new Scheduled Thread Pool ( NUM , thread Factory ) ; e . set Remove On Cancel Policy ( BOOL ) ; executor = e ; }
@ Override public Point 2 D . Double constrain Point ( Point 2 D . Double p ) { p . x = Math . round ( p . x / width ) * width ; p . y = Math . round ( p . y / height ) * height ; return p ; }
@ On Open public void on Connect ( final Session session ) { SESSIONS . add ( session ) ; }
public static List < Volume Descriptor > filter By Type ( List < Volume Descriptor > descriptors , Type [ ] inclusive , Type [ ] exclusive ) { List < Volume Descriptor > result = new Array List < Volume Descriptor > ( ) ; if ( descriptors == null ) { return result ; } Hash Set < Type > included = new Hash Set < Type > ( ) ; if ( inclusive != null ) { included . add All ( Arrays . as List ( inclusive ) ) ; } Hash Set < Type > excluded = new Hash Set < Type > ( ) ; if ( exclusive != null ) { excluded . add All ( Arrays . as List ( exclusive ) ) ; } for ( Volume Descriptor desc : descriptors ) { if ( excluded . contains ( desc . get Type ( ) ) ) { continue ; } if ( included . is Empty ( ) || included . contains ( desc . get Type ( ) ) ) { result . add ( desc ) ; } } return result ; }
public static boolean is In Range ( String ip , String ip Range ) { if ( ip == null || ip Range == null ) return BOOL ; String [ ] cidr String = ip Range . split ( STRING ) ; if ( cidr String . length == NUM ) return BOOL ; String network = cidr String [ NUM ] ; String cidr Mask = STRING ; if ( cidr String . length > NUM ) { cidr Mask = cidr String [ NUM ] ; } String net Mask = cidr Mask To Net Mask ( cidr Mask ) ; Inet Address masked IP = apply Mask ( ip , net Mask ) ; Inet Address masked Network = apply Mask ( network , net Mask ) ; if ( masked IP == null || masked Network == null ) return BOOL ; return masked IP . equals ( masked Network ) ; }
public static void globals Put All ( Template Hash Model hash Model , Set < String > in Ex Keys , Boolean include , Environment env ) throws Template Model Exception { vars Put All ( hash Model , in Ex Keys , include , new Global Ftl Var Handler ( env ) , env ) ; }
public static String join ( String separator , double ... elements ) { if ( elements == null || elements . length == NUM ) { return STRING ; } List < Number > list = new Array List < Number > ( elements . length ) ; for ( Double elem : elements ) { list . add ( elem ) ; } return join ( separator , list ) ; }
public static void put Unsigned Byte ( Byte Buffer bb , short v , int offset ) { bb . put ( offset , ( byte ) ( v & NUM ) ) ; }
@ Override public Trie optimize ( Trie orig ) { List < Char Sequence > cmds = orig . cmds ; List < Row > rows = new Array List < > ( ) ; List < Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; Arrays . fill ( remap , NUM ) ; for ( int j = orows . size ( ) - NUM ; j >= NUM ; j -- ) { if ( eat ( orows . get ( j ) , remap ) ) { remap [ j ] = NUM ; } } Arrays . fill ( remap , - NUM ) ; rows = remove Gaps ( orig . root , orows , new Array List < Row > ( ) , remap ) ; return new Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
public boolean has Denied Permission ( ) { for ( int i = NUM ; i < m Perms . size ( ) ; i ++ ) { if ( m Perms . get ( m User Permission . get ( i ) ) == Package Manager . PERMISSION DENIED ) return BOOL ; } return BOOL ; }
@ Override public String to String Key ( ) { String result ; int i ; result = STRING ; for ( i = NUM ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) { continue ; } result += LEFT PARENTHESES + ( i + NUM ) + RIGHT PARENTHESES + STRING + remove Filter Name ( m Col Names [ i ] ) + STRING ; } return result ; }
Date Time Formatter to Formatter ( Resolver Style resolver Style , Chronology chrono ) { return to Formatter ( Locale . get Default ( Locale . Category . FORMAT ) , resolver Style , chrono ) ; }
protected void wait For File To Grow ( File file ) throws Exception { int current Wait Time = NUM ; while ( ! file . exists ( ) ) { Log . i ( LOG TAG , STRING ) ; current Wait Time = timeout Wait ( current Wait Time , WAIT FOR DOWNLOAD POLL TIME , MAX WAIT FOR DOWNLOAD TIME , STRING ) ; } long original Size = file . length ( ) ; while ( file . length ( ) <= original Size ) { Log . i ( LOG TAG , STRING ) ; current Wait Time = timeout Wait ( current Wait Time , WAIT FOR DOWNLOAD POLL TIME , MAX WAIT FOR DOWNLOAD TIME , STRING ) ; } }
private boolean install Vm Prereqs ( I Test Device device , Cts Build Helper cts Build ) throws Device Not Available Exception { cleanup Device Files ( device ) ; C Log . d ( STRING ) ; create Remote Dir ( device , VM TEST TEMP DIR + STRING ) ; try { File local Tmp Dir = File Util . create Temp Dir ( STRING , new File ( STRING ) ) ; C Log . d ( STRING , local Tmp Dir . get Path ( ) ) ; File jar File = new File ( cts Build . get Test Cases Dir ( ) , get Jar File Name ( ) ) ; if ( ! jar File . exists ( ) ) { C Log . e ( STRING , jar File . get Path ( ) ) ; return BOOL ; } C Log . d ( STRING , jar File . get Path ( ) , local Tmp Dir . get Path ( ) ) ; Zip File zip File = new Zip File ( jar File ) ; File Util . extract Zip ( zip File , local Tmp Dir ) ; File local Test Tmp Dir = new File ( local Tmp Dir , STRING ) ; C Log . d ( STRING , local Test Tmp Dir . get Path ( ) , VM TEST TEMP DIR ) ; if ( ! device . push Dir ( local Test Tmp Dir , VM TEST TEMP DIR ) ) { C Log . e ( STRING ) ; return BOOL ; } C Log . d ( STRING , local Tmp Dir . get Path ( ) ) ; File Util . recursive Delete ( local Tmp Dir ) ; } catch ( IO Exception e ) { C Log . e ( STRING , get Jar File Name ( ) , device . get Serial Number ( ) ) ; return BOOL ; } return BOOL ; }
public void prev ( ) { if ( D ) LOG . info ( STRING ) ; synchronized ( this ) { if ( m Shuffle Mode == SHUFFLE NORMAL ) { final int histsize = m History . size ( ) ; if ( histsize == NUM ) { return ; } final Integer pos = m History . remove ( histsize - NUM ) ; m Play Pos = pos . int Value ( ) ; } else { if ( m Play Pos > NUM ) { m Play Pos -- ; } else { m Play Pos = m Play List Len - NUM ; } } stop ( BOOL ) ; open Current ( ) ; play ( ) ; notify Change ( META CHANGED ) ; } }
public void test Reverse Step By One With Closure ( ) { final List call Log = new Array List ( ) ; final Closure closure = new Recording Closure ( call Log ) ; final Range range = create Range ( NUM , NUM ) ; range . step ( NUM , closure ) ; assert Equals ( STRING , NUM , call Log . size ( ) ) ; final Iterator iter = call Log . iterator ( ) ; for ( int i = NUM ; i >= NUM ; i -- ) { assert Equals ( STRING , create Value ( i ) , iter . next ( ) ) ; } }
private static Big Decimal normalize Decimal Value ( Big Decimal big Decimal , int allowed Precision ) { if ( big Decimal . precision ( ) > allowed Precision ) { return null ; } return big Decimal ; }
protected static String serialize DOM Source ( DOM Source dom Source ) { try { String Writer writer = new String Writer ( ) ; Stream Result result = new Stream Result ( writer ) ; Transformer Factory tf = Transformer Factory . new Instance ( ) ; Transformer transformer = tf . new Transformer ( ) ; transformer . set Output Property ( Output Keys . ENCODING , DEFAULT ENCODING ) ; transformer . set Output Property ( Output Keys . INDENT , DEFAULT INDENT ) ; transformer . transform ( dom Source , result ) ; writer . flush ( ) ; return writer . to String ( ) ; } catch ( Throwable e ) { log . log ( Level . SEVERE , STRING , e ) ; } return null ; }
private void load Events ( ) throws XML Stream Exception { if ( ! xml Event Reader . has Next ( ) ) { done = BOOL ; return ; } XML Event event = xml Event Reader . next Event ( ) ; event = event Transformer . transform ( event ) ; xml Write Stream . reset ( ) ; xml Event Writer . add ( event ) ; xml Event Writer . flush ( ) ; xml In Stream = new Byte Array Input Stream ( xml Write Stream . to Byte Array ( ) ) ; }
public static void debug ( Throwable t ) { String Writer writer = new String Writer ( ) ; t . print Stack Trace ( new Print Writer ( writer ) ) ; String str = writer . to String ( ) ; if ( str . ends With ( STRING ) ) str = str . substring ( NUM , str . length ( ) - NUM ) ; debug ( str ) ; }
public Revision next ( ) { try { Revision revision = new Revision ( result . get Int ( NUM ) ) ; this . primary Key = result . get Int ( NUM ) ; revision . set Primary Key ( this . primary Key ) ; revision . set Revision ID ( result . get Int ( NUM ) ) ; revision . set Article ID ( result . get Int ( NUM ) ) ; revision . set Time Stamp ( new Timestamp ( result . get Long ( NUM ) ) ) ; revision . set Full Revision ID ( result . get Int ( NUM ) ) ; return revision ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( e ) ; } }
private void add Line ( Grid Field field , W Editor editor , boolean mandatory ) { log . fine ( STRING + field ) ; Label label = editor . get Label ( ) ; editor . set Read Write ( BOOL ) ; editor . set Mandatory ( mandatory ) ; field . add Property Change Listener ( editor ) ; if ( m new Row ) { m row = new Row ( ) ; m row . set Style ( STRING ) ; m rows . append Child ( m row ) ; } Div div = new Div ( ) ; div . set Style ( STRING ) ; div . append Child ( label ) ; m row . append Child ( div ) ; m row . append Child ( editor . get Component ( ) ) ; editor . dynamic Display ( ) ; m new Row = ! m new Row ; }
public static void close EL ( Output Stream os ) { try { if ( os != null ) os . close ( ) ; } catch ( Throwable e ) { } }
public void remove Search Listener ( Search Listener l ) { m Search Listeners . remove ( l ) ; }
final boolean is Recursively Visible Up To Heavyweight Container ( ) { if ( ! is Lightweight ( ) ) { return BOOL ; } for ( Container cont = this ; cont != null && cont . is Lightweight ( ) ; cont = cont . get Container ( ) ) { if ( ! cont . is Visible ( ) ) { return BOOL ; } } return BOOL ; }
public void edit ( File file ) throws IO Exception { check AWT Permission ( ) ; check Exec ( ) ; check Action Support ( Action . EDIT ) ; file . can Write ( ) ; check File Validation ( file ) ; peer . edit ( file ) ; }
public Date to Date ( String iso 8601 string ) throws Parse Exception { if ( iso 8601 string == null ) { return null ; } Date Format df = new Simple Date Format ( ISO 8601 ) ; df . set Time Zone ( Time Zone . get Time Zone ( STRING ) ) ; int z = iso 8601 string . index Of ( STRING ) ; if ( z > NUM ) { iso 8601 string = iso 8601 string . substring ( NUM , z ) + STRING ; } try { Date date = df . parse ( iso 8601 string ) ; return date ; } catch ( Parse Exception e ) { Date Format dfshort = new Simple Date Format ( ISO 8601 short ) ; dfshort . set Time Zone ( Time Zone . get Time Zone ( STRING ) ) ; try { return dfshort . parse ( iso 8601 string ) ; } catch ( Parse Exception ee ) { Date Format last Chance = new Simple Date Format ( Java Date To String Format ) ; last Chance . set Time Zone ( Time Zone . get Time Zone ( STRING ) ) ; return last Chance . parse ( iso 8601 string ) ; } } }
@ Override public void toggle Selection ( Photo photo ) { if ( selected Photos . contains ( photo ) ) { selected Photos . remove ( photo ) ; } else { selected Photos . add ( photo ) ; } }
protected void pre Collection ( ) { }
public final static byte [ ] to Ascii Byte Array ( Char Sequence char Sequence ) { byte [ ] barr = new byte [ char Sequence . length ( ) ] ; for ( int i = NUM ; i < barr . length ; i ++ ) { char c = char Sequence . char At ( i ) ; barr [ i ] = ( byte ) ( ( int ) ( c <= NUM ? c : NUM ) ) ; } return barr ; }
public static boolean is Config File Keyword ( String name ) { return CONFIG KEYWORDS . contains ( name ) ; }
public List < String > explain Mismatch ( Issue issue ) { Objects . require Non Null ( issue ) ; List < String > result = new Linked List < > ( ) ; for ( Issue Property Matcher property Matcher : property Matchers ) { if ( ! property Matcher . matches ( issue ) ) result . add ( property Matcher . get Message ( issue ) ) ; } return result ; }
public Key ( Type type , Annotation [ ] anns ) { Objects . require Non Null ( type ) ; type = type ; anns = anns ; if ( anns == null || anns . length == NUM ) { ann Types = DEFAULT ANN TYPES ; return ; } Array List < Class < ? extends Annotation > > ann Type List = new Array List < > ( ) ; for ( Annotation ann : anns ) { if ( is Qualifier ( ann . annotation Type ( ) ) ) { ann Type List . add ( ann . annotation Type ( ) ) ; } } if ( ann Type List . size ( ) == NUM ) { ann Types = DEFAULT ANN TYPES ; return ; } Class < ? extends Annotation > [ ] ann Types = new Class [ ann Type List . size ( ) ] ; ann Type List . to Array ( ann Types ) ; ann Types = ann Types ; }
private static native int Windows Reg Close Key ( int h Key ) ;
public void remove Property Change Listener ( Scene Property Change Listener listener ) { if ( listener != null ) { logger . log ( Level . FINE , STRING , listener ) ; listeners . remove ( listener ) ; } }
@ Override public int following ( int offset ) { Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; text . set Index ( offset ) ; if ( offset == text . get Begin Index ( ) ) { cached Last Known Break = handle Next ( ) ; return cached Last Known Break ; } int result = cached Last Known Break ; if ( result >= offset || result <= Break Iterator . DONE ) { result = handle Previous ( ) ; } else { text . set Index ( result ) ; } while ( result != Break Iterator . DONE && result <= offset ) { result = handle Next ( ) ; } cached Last Known Break = result ; return result ; }
@ Override public Volatile Image create Back Buffer ( W Component Peer peer ) { Component target = ( Component ) peer . get Target ( ) ; int w = Math . max ( NUM , target . get Width ( ) ) ; int h = Math . max ( NUM , target . get Height ( ) ) ; return new Sun Volatile Image ( target , w , h , Boolean . TRUE ) ; }
public boolean starts With ( Name n ) { if ( n instanceof Composite Name ) { return ( impl . starts With ( n . size ( ) , n . get All ( ) ) ) ; } else { return BOOL ; } }
public void check Is Allocated ( ) { int original Bits = Addressable Memory Manager . read Int Volatile ( this . memory Address + REF COUNT OFFSET ) ; if ( ( original Bits & MAGIC MASK ) != MAGIC NUMBER ) { throw new Illegal State Exception ( STRING + Integer . to Hex String ( original Bits ) ) ; } }
public void test Invoke Any 6 ( ) throws Throwable { Executor Service e = new Fork Join Pool ( NUM ) ; Pool Cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new Array List < Callable < String > > ( ) ; l . add ( new String Task ( ) ) ; l . add ( new String Task ( ) ) ; String result = e . invoke Any ( l ) ; assert Same ( TEST STRING , result ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public Glow Server ( Server Config config ) { material Value Manager = new Builtin Material Value Manager ( ) ; this . config = config ; ops List = new Uuid List File ( config . get File ( STRING ) ) ; whitelist = new Uuid List File ( config . get File ( STRING ) ) ; name Bans = new Glow Ban List ( this , Type . NAME ) ; ip Bans = new Glow Ban List ( this , Type . IP ) ; Bukkit . set Server ( this ) ; load Config ( ) ; }
public byte [ ] to ASN 1 ( ) { try { byte [ ] priv Key Bytes = get Priv Key Bytes ( ) ; Byte Array Output Stream baos = new Byte Array Output Stream ( NUM ) ; DER Sequence Generator seq = new DER Sequence Generator ( baos ) ; seq . add Object ( new ASN 1 Integer ( NUM ) ) ; seq . add Object ( new DER Octet String ( priv Key Bytes ) ) ; seq . add Object ( new DER Tagged Object ( NUM , CURVE PARAMS . to ASN 1 Primitive ( ) ) ) ; seq . add Object ( new DER Tagged Object ( NUM , new DER Bit String ( get Pub Key ( ) ) ) ) ; seq . close ( ) ; return baos . to Byte Array ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
public void start ( Calendar start Time , Calendar end Time ) { if ( start Time == null || end Time == null || start Time . after ( end Time ) ) { throw new Illegal Argument Exception ( STRING ) ; } m Start Time = start Time ; start ( end Time ) ; }
public J Popup Menu create Network Context Menu ( ) { context Menu = new J Popup Menu ( ) ; context Menu . add ( action Manager . get New Neuron Action ( ) ) ; context Menu . add ( new Add Neurons Action ( this ) ) ; context Menu . add ( action Manager . get New Group Menu ( ) ) ; context Menu . add ( action Manager . get New Network Menu ( ) ) ; context Menu . add Separator ( ) ; for ( Action action : action Manager . get Clipboard Actions ( ) ) { context Menu . add ( action ) ; } context Menu . add Separator ( ) ; context Menu . add ( action Manager . get Clear Source Neurons Action ( ) ) ; context Menu . add ( action Manager . get Set Source Neurons Action ( ) ) ; context Menu . add Separator ( ) ; context Menu . add ( action Manager . get Show Network Preferences Action ( ) ) ; return context Menu ; }
public static void print State ( TLC State current State , TLC State last State , int num ) { String state String ; if ( last State != null && TLC Globals . print Diffs Only ) { state String = current State . to String ( last State ) ; } else { state String = current State . to String ( ) ; } MP . print State ( EC . TLC STATE PRINT 1 , new String [ ] { String . value Of ( num ) , state String } , current State , num ) ; }
private void import Records ( ) { for ( X I Product BOM import BOM : get Records ( BOOL , m Is Import Only No Errors ) ) { is Imported = BOOL ; MPP Product BOM bom = get MPP Product BOM ( import BOM ) ; MPP Product BOM Line bom Line = null ; if ( bom != null ) bom Line = import BOM Line ( bom , import BOM ) ; if ( bom Line != null ) { import BOM . set PP Product BOM Line ID ( bom Line . get PP Product BOM Line ID ( ) ) ; import BOM . set PP Product BOM ID ( bom . get ID ( ) ) ; imported ++ ; is Imported = BOOL ; } import BOM . set I Is Imported ( is Imported ) ; import BOM . set Processed ( is Imported ) ; import BOM . save Ex ( ) ; } }
public void add Collect ( int regency , Signed Object signed Collect ) { Hash Set < Signed Object > c = collects . get ( regency ) ; if ( c == null ) c = new Hash Set < Signed Object > ( ) ; c . add ( signed Collect ) ; collects . put ( regency , c ) ; }
@ Suppress Warnings ( { STRING , STRING , STRING } ) public Object parse Text ( String text ) { if ( text == null || text . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } return parse ( new Line Column Reader ( new String Reader ( text ) ) ) ; }
@ Suppress Warnings ( STRING ) private static Outlier Result run Online LOF ( Updatable Database db ) { Relation < Double Vector > rep = db . get Relation ( Type Util . DOUBLE VECTOR FIELD ) ; Online LOF < Double Vector > lof = new Online LOF < > ( k , k , neighborhood Distance Function , reachability Distance Function ) ; Outlier Result result = lof . run ( db ) ; Array List < Double Vector > insertions = new Array List < > ( ) ; Number Vector . Factory < Double Vector > o = Relation Util . get Number Vector Factory ( rep ) ; int dim = Relation Util . dimensionality ( rep ) ; Random random = new Random ( seed ) ; for ( int i = NUM ; i < size ; i ++ ) { Double Vector obj = Vector Util . random Vector ( o , dim , random ) ; insertions . add ( obj ) ; } DBI Ds deletions = db . insert ( Multiple Objects Bundle . make Simple ( rep . get Data Type Information ( ) , insertions ) ) ; db . delete ( deletions ) ; return result ; }
private Design File open dialog ( Stat stat , String p design dir name ) { J File Chooser file chooser = new J File Chooser ( p design dir name ) ; File Filter file filter = new File Filter ( Design File . all file extensions ) ; file chooser . set File Filter ( file filter ) ; file chooser . show Open Dialog ( null ) ; File curr design file = file chooser . get Selected File ( ) ; if ( curr design file == null ) return null ; return new Design File ( stat , curr design file , file chooser ) ; }
public void destroy ( ) { m Destroyed = BOOL ; m Handler . remove Callbacks And Messages ( null ) ; if ( m Service != null ) { try { m Service . listen To ( null , m Callback ) ; m Context . unbind Service ( m Connection ) ; } catch ( Remote Exception e ) { } } }
public String next Token ( ) { String result = null ; synchronized ( this ) { if ( is Empty ( ) ) { return null ; } else { if ( is Eating Blocks Of Delimiters ) { trim Starting Delimiters ( ) ; } int nearest Delimeter = - NUM ; for ( int i = NUM ; i < delimiters . length ( ) ; i ++ ) { int delimiter = source . index Of ( delimiters . char At ( i ) , current Index ) ; if ( nearest Delimeter == - NUM || delimiter != - NUM && delimiter < nearest Delimeter ) { nearest Delimeter = delimiter ; } } if ( nearest Delimeter == - NUM ) { result = source . substring ( current Index ) ; current Index = source . length ( ) ; } else { result = source . substring ( current Index , nearest Delimeter ) ; current Index = nearest Delimeter + NUM ; if ( is Eating Blocks Of Delimiters ) { trim Starting Delimiters ( ) ; } } } } return result ; }
public Collection asignar Fondo ( Collection detallesprestamos ) { Gestion Fondos BI fondos Service = get Gestion Fondos BI ( ) ; Array List detallesprestamos Final = new Array List ( ) ; if ( detallesprestamos != null ) { Iterator it = detallesprestamos . iterator ( ) ; while ( it . has Next ( ) ) { Busqueda Detalle VO bdp = ( Busqueda Detalle VO ) it . next ( ) ; Fondo VO fondoauxiliar = fondos Service . get Fondo X Id ( bdp . get Idfondo ( ) ) ; bdp . set Fondo ( fondoauxiliar . get Titulo ( ) ) ; detallesprestamos Final . add ( bdp ) ; } } return detallesprestamos Final ; }
private void build Network ( final Network network , int [ ] nodes Per Layer , Point 2 D initial Position , final Neuron input Neuron Template ) { set Label ( STRING ) ; List < Neuron > input Layer Neurons = new Array List < Neuron > ( ) ; for ( int i = NUM ; i < nodes Per Layer [ NUM ] ; i ++ ) { input Layer Neurons . add ( new Neuron ( network , input Neuron Template ) ) ; } Neuron Group input Layer = new Neuron Group ( network , input Layer Neurons ) ; input Layer . set Clamped ( BOOL ) ; add Neuron Group ( input Layer ) ; input Layer . set Layout Based On Size ( initial Position ) ; Synapse synapse = Synapse . get Template Synapse ( new Static Synapse Rule ( ) ) ; synapse . set Lower Bound ( - NUM ) ; synapse . set Upper Bound ( NUM ) ; Neuron Group last Layer = input Layer ; for ( int i = NUM ; i < nodes Per Layer . length ; i ++ ) { List < Neuron > hidden Layer Neurons = new Array List < Neuron > ( ) ; for ( int j = NUM ; j < nodes Per Layer [ i ] ; j ++ ) { Sigmoidal Rule rule = new Sigmoidal Rule ( ) ; Neuron neuron = new Neuron ( network , rule ) ; rule . set Lower Bound ( NUM ) ; neuron . set Update Priority ( i ) ; hidden Layer Neurons . add ( neuron ) ; } Neuron Group hidden Layer = new Neuron Group ( network , hidden Layer Neurons ) ; hidden Layer . set Layout Based On Size ( ) ; add Neuron Group ( hidden Layer ) ; Network Layout Manager . offset Neuron Group ( last Layer , hidden Layer , Direction . NORTH , between Layer Interval ) ; All To All connection = new All To All ( ) ; Synapse Group lh = connect Neuron Groups ( last Layer , hidden Layer , connection ) ; lh . randomize Connection Weights ( ) ; last Layer = hidden Layer ; } }
public static int interp ( int c1 , int c2 , double frac ) { double ifrac = NUM - frac ; return rgba ( ( int ) Math . round ( frac * red ( c2 ) + ifrac * red ( c1 ) ) , ( int ) Math . round ( frac * green ( c2 ) + ifrac * green ( c1 ) ) , ( int ) Math . round ( frac * blue ( c2 ) + ifrac * blue ( c1 ) ) , ( int ) Math . round ( frac * alpha ( c2 ) + ifrac * alpha ( c1 ) ) ) ; }
public static String ltrim ( String s ) { if ( s == null ) { return null ; } int index = NUM ; int len = s . length ( ) ; while ( index < len && Character . is Whitespace ( s . char At ( index ) ) ) { index ++ ; } return ( index >= len ) ? STRING : s . substring ( index ) ; }
public Named Map Converter ( @ Suppress Warnings ( STRING ) final Class < ? extends Map > type , final Mapper mapper , final String entry Name , final String key Name , final Class < ? > key Type , final String value Name , final Class < ? > value Type , final boolean key As Attribute , final boolean value As Attribute , final Converter Lookup lookup ) { super ( mapper , type ) ; this . entry Name = entry Name != null && entry Name . length ( ) == NUM ? null : entry Name ; this . key Name = key Name != null && key Name . length ( ) == NUM ? null : key Name ; this . key Type = key Type ; this . value Name = value Name != null && value Name . length ( ) == NUM ? null : value Name ; this . value Type = value Type ; this . key As Attribute = key As Attribute ; this . value As Attribute = value As Attribute ; this . lookup = lookup ; enum Mapper = Use Attribute For Enum Mapper . create Enum Mapper ( mapper ) ; if ( key Type == null || value Type == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( entry Name == null ) { if ( key As Attribute || value As Attribute ) { throw new Illegal Argument Exception ( STRING ) ; } if ( value Name == null ) { throw new Illegal Argument Exception ( STRING ) ; } } if ( key Name == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( value Name == null ) { if ( value As Attribute ) { throw new Illegal Argument Exception ( STRING ) ; } else if ( ! key As Attribute ) { throw new Illegal Argument Exception ( STRING ) ; } } if ( key As Attribute && value As Attribute && key Name . equals ( value Name ) ) { throw new Illegal Argument Exception ( STRING ) ; } }
public void create Accrual Based Journal Entries And Reversals For Loan ( final Office office , final String currency Code , final Integer account Type To Be Debited , final Integer account Type To Be Credited , final Long loan Product Id , final Long payment Type Id , final Long loan Id , final String transaction Id , final Date transaction Date , final Big Decimal amount , final Boolean is Reversal ) { int account Type To Debit Id = account Type To Be Debited ; int account Type To Credit Id = account Type To Be Credited ; if ( is Reversal ) { account Type To Debit Id = account Type To Be Credited ; account Type To Credit Id = account Type To Be Debited ; } create Journal Entries For Loan ( office , currency Code , account Type To Debit Id , account Type To Credit Id , loan Product Id , payment Type Id , loan Id , transaction Id , transaction Date , amount ) ; }
public int read ( Byte Buffer dst , int dst Start , int dst Length ) throws IO Exception { final int remaining = ( int ) Math . min ( this . length - this . position , Integer . MAX VALUE ) ; final int read = Math . min ( remaining , dst Length ) ; final int buffer Position = check Offset ( position , read ) ; final long src Address = Platform Dependent . direct Buffer Address ( last Mapped ) + buffer Position ; if ( dst . is Direct ( ) ) { final long dst Address = Platform Dependent . direct Buffer Address ( dst ) + dst Start ; Platform Dependent . copy Memory ( src Address , dst Address , read ) ; } else { final byte [ ] dst Array = dst . array ( ) ; Platform Dependent . copy Memory ( src Address , dst Array , dst Start , read ) ; } position += read ; return read ; }
public static Calendar to Calendar ( Date self ) { Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( self ) ; return cal ; }
public double pdf ( int k ) { if ( k < NUM ) throw new Illegal Argument Exception ( ) ; int r = this . n - k ; return Math . exp ( this . log n - Arithmetic . log Factorial ( k ) - Arithmetic . log Factorial ( r ) + this . log p * k + this . log q * r ) ; }
public static void append Unpadded Integer ( String Buffer buf , int value ) { if ( value < NUM ) { buf . append ( STRING ) ; if ( value != Integer . MIN VALUE ) { value = - value ; } else { buf . append ( STRING + - ( long ) Integer . MIN VALUE ) ; return ; } } if ( value < NUM ) { buf . append ( ( char ) ( value + STRING ) ) ; } else if ( value < NUM ) { int d = ( ( value + NUM ) * NUM ) > > NUM ; buf . append ( ( char ) ( d + STRING ) ) ; buf . append ( ( char ) ( value - ( d << NUM ) - ( d << NUM ) + STRING ) ) ; } else { buf . append ( Integer . to String ( value ) ) ; } }
private void draw Text Elements ( Canvas canvas , float text Size , Typeface typeface , Color State List text Color , String [ ] texts , float [ ] text X , float [ ] text Y , Paint paint , int alpha , boolean show Activated , int activated Degrees , boolean activated Only ) { paint . set Text Size ( text Size ) ; paint . set Typeface ( typeface ) ; final float activated Index = activated Degrees / ( NUM / NUM POSITIONS ) ; final int activated Floor = ( int ) activated Index ; final int activated Ceil = ( ( int ) Math . ceil ( activated Index ) ) % NUM POSITIONS ; for ( int i = NUM ; i < NUM ; i ++ ) { final boolean activated = ( activated Floor == i || activated Ceil == i ) ; if ( activated Only && ! activated ) { continue ; } final int state Mask = S Utils . STATE ENABLED | ( show Activated && activated ? S Utils . STATE ACTIVATED : NUM ) ; final int color = text Color . get Color For State ( S Utils . resolve State Set ( state Mask ) , NUM ) ; paint . set Color ( color ) ; paint . set Alpha ( get Multiplied Alpha ( color , alpha ) ) ; canvas . draw Text ( texts [ i ] , text X [ i ] , text Y [ i ] , paint ) ; } }
public void test Find Spring Active Directory ( ) { Ldap Proxy proxy = get Ldap AD ( ) ; List result = null ; try { result = proxy . find ( get Ldap Search VO ( STRING , Ldap Constants . NO SEARCH LIMIT , null , null , null , Ldap Scope Constants . SCOPE SUBTREE ) ) ; } catch ( Exception e ) { } assert Not Null ( result ) ; assert Equals ( NUM , result . size ( ) ) ; }
public boolean on Key Event ( Key Event event , Action Processor action Processor , Keyboard Action Listener keyboard Action Listener ) { long extended Key Code = Key Combo Preference . key Event To Extended Key Code ( event ) ; if ( ! m Trigger Keys . contains ( extended Key Code ) ) { return BOOL ; } if ( event . get Action ( ) == Key Event . ACTION DOWN ) { if ( m Pressed Keys . is Empty ( ) ) { action Processor . process ( m Action ) ; if ( keyboard Action Listener != null ) { keyboard Action Listener . on Keyboard Action ( m Assigned Keys Res Id ) ; } } m Pressed Keys . add ( extended Key Code ) ; } else if ( event . get Action ( ) == Key Event . ACTION UP ) { m Pressed Keys . remove ( extended Key Code ) ; } return BOOL ; }
@ Override public int hash Code ( ) { int my Position = position ; int hash = NUM ; while ( my Position < limit ) { hash = hash + get ( my Position ++ ) ; } return hash ; }
private static String descriptor To Class Name ( String s ) { if ( s . starts With ( STRING ) || ! s . starts With ( STRING ) ) return s ; return s . substring ( NUM , s . length ( ) - NUM ) ; }

private void process Skip Entries ( ) { for ( Iterator < Skip Entry > i = skip Records . iterator ( ) ; i . has Next ( ) ; ) { Skip Entry skip Record = i . next ( ) ; int label Offset = action Offsets [ skip Record . skip Target - start Count ] ; skip Record . action . skip Target = get Label ( label Offset ) ; } }
public static long date Value From Date ( long ms ) { Calendar cal = get Calendar ( ) ; cal . set Time In Millis ( ms ) ; return date Value From Calendar ( cal ) ; }
@ Override default Completable Future < Optional Long > min Long ( final To Long Function < ? super T > fn ) { return Completable Future . supply Async ( null , get Exec ( ) ) ; }
public Tomcat Manager ( URL url , String username , String password , String charset ) { this . url = url ; this . username = username ; this . password = password ; this . charset = charset ; try { md 5 = Message Digest . get Instance ( STRING ) ; } catch ( No Such Algorithm Exception e ) { throw new Cargo Exception ( STRING , e ) ; } }
public final static char [ ] [ ] split Type Levels Signature ( String type Signature ) { char [ ] source = Signature . remove Capture ( type Signature . to Char Array ( ) ) ; Char Operation . replace ( source , STRING , STRING ) ; char [ ] [ ] signatures = new char [ NUM ] [ ] ; int signatures Count = NUM ; int param Opening = NUM ; for ( int idx = NUM , ln = source . length ; idx < ln ; idx ++ ) { switch ( source [ idx ] ) { case STRING : param Opening -- ; if ( param Opening == NUM ) { if ( signatures Count == signatures . length ) { System . arraycopy ( signatures , NUM , signatures = new char [ signatures Count + NUM ] [ ] , NUM , signatures Count ) ; } } break ; case STRING : param Opening ++ ; break ; case STRING : if ( param Opening == NUM ) { if ( signatures Count == signatures . length ) { System . arraycopy ( signatures , NUM , signatures = new char [ signatures Count + NUM ] [ ] , NUM , signatures Count ) ; } signatures [ signatures Count ] = new char [ idx + NUM ] ; System . arraycopy ( source , NUM , signatures [ signatures Count ] , NUM , idx ) ; signatures [ signatures Count ] [ idx ] = Signature . C SEMICOLON ; signatures Count ++ ; } break ; case STRING : source [ idx ] = STRING ; break ; } } char [ ] [ ] type Signatures = new char [ signatures Count + NUM ] [ ] ; type Signatures [ NUM ] = source ; for ( int i = NUM , j = signatures Count - NUM ; i <= signatures Count ; i ++ , j -- ) { type Signatures [ i ] = signatures [ j ] ; } return type Signatures ; }
private void write ( Coordinate [ ] coords , Writer writer , int level ) throws IO Exception { start Line ( level , writer ) ; start Geom Tag ( GML Constants . GML COORDINATES , null , writer ) ; int dim = NUM ; if ( coords . length > NUM ) { if ( ! ( Double . is Na N ( coords [ NUM ] . z ) ) ) dim = NUM ; } boolean is New Line = BOOL ; for ( int i = NUM ; i < coords . length ; i ++ ) { if ( is New Line ) { start Line ( level + NUM , writer ) ; is New Line = BOOL ; } if ( dim == NUM ) { writer . write ( STRING + coords [ i ] . x ) ; writer . write ( coordinate Separator ) ; writer . write ( STRING + coords [ i ] . y ) ; } else if ( dim == NUM ) { writer . write ( STRING + coords [ i ] . x ) ; writer . write ( coordinate Separator ) ; writer . write ( STRING + coords [ i ] . y ) ; writer . write ( coordinate Separator ) ; writer . write ( STRING + coords [ i ] . z ) ; } writer . write ( tuple Separator ) ; if ( ( i + NUM ) % max Coordinates Per Line == NUM && i < coords . length - NUM ) { writer . write ( STRING ) ; is New Line = BOOL ; } } if ( ! is New Line ) writer . write ( STRING ) ; start Line ( level , writer ) ; end Geom Tag ( GML Constants . GML COORDINATES , writer ) ; }
protected void index Nulls ( Input Stream is , long ptr , Output Stream os ) { boolean more Records = BOOL ; byte r Hdr [ ] = new byte [ SHAPE RECORD HEADER LENGTH ] ; byte out Buf [ ] = new byte [ SPATIAL INDEX RECORD LENGTH ] ; int result ; int n Records = NUM ; int rec Length Words , rec Length Bytes ; long rec Offset ; int rec Buf Size = NUM ; byte rec Buf [ ] = new byte [ rec Buf Size ] ; double x ; double y ; try { while ( more Records ) { result = is . read ( r Hdr , NUM , SHAPE RECORD HEADER LENGTH ) ; if ( result < NUM ) { more Records = BOOL ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + n Records + STRING ) ; logger . fine ( STRING + rec Buf Size ) ; } } else { n Records ++ ; rec Offset = ptr ; read BE Int ( r Hdr , NUM ) ; rec Length Words = read BE Int ( r Hdr , NUM ) ; rec Length Bytes = rec Length Words * NUM ; if ( rec Length Bytes > rec Buf Size ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STRING + rec Length Bytes ) ; } rec Buf Size = rec Length Bytes ; rec Buf = new byte [ rec Buf Size ] ; } result = is . read ( rec Buf , NUM , rec Length Bytes ) ; x = NUM ; y = NUM ; ptr += rec Length Bytes + NUM ; write BE Int ( out Buf , NUM , ( int ) ( rec Offset / NUM ) ) ; write BE Int ( out Buf , NUM , rec Length Words ) ; write LE Double ( out Buf , NUM , x ) ; write LE Double ( out Buf , NUM , y ) ; write LE Double ( out Buf , NUM , x ) ; write LE Double ( out Buf , NUM , y ) ; os . write ( out Buf , NUM , SPATIAL INDEX RECORD LENGTH ) ; } } } catch ( java . io . IO Exception e ) { e . print Stack Trace ( ) ; } finally { try { is . close ( ) ; } catch ( java . io . IO Exception e ) { } } }
public double [ ] distribution For Instance ( Instance instance ) throws Exception { double trans Prob = NUM , temp = NUM ; double [ ] class Probability = new double [ m Num Classes ] ; double [ ] predicted Value = new double [ NUM ] ; for ( int i = NUM ; i < class Probability . length ; i ++ ) { class Probability [ i ] = NUM ; } predicted Value [ NUM ] = NUM ; if ( m Init Flag == ON ) { if ( m Blend Method == B ENTROPY ) { generate Random Class Colomns ( ) ; } m Cache = new K Star Cache [ m Num Attributes ] ; for ( int i = NUM ; i < m Num Attributes ; i ++ ) { m Cache [ i ] = new K Star Cache ( ) ; } m Init Flag = OFF ; } Instance train Instance ; Enumeration < Instance > enu = m Train . enumerate Instances ( ) ; while ( enu . has More Elements ( ) ) { train Instance = ( Instance ) enu . next Element ( ) ; trans Prob = instance Transformation Probability ( instance , train Instance ) ; switch ( m Class Type ) { case Attribute . NOMINAL : class Probability [ ( int ) train Instance . class Value ( ) ] += trans Prob ; break ; case Attribute . NUMERIC : predicted Value [ NUM ] += trans Prob * train Instance . class Value ( ) ; temp += trans Prob ; break ; } } if ( m Class Type == Attribute . NOMINAL ) { double sum = Utils . sum ( class Probability ) ; if ( sum <= NUM ) for ( int i = NUM ; i < class Probability . length ; i ++ ) class Probability [ i ] = ( double ) NUM / ( double ) m Num Classes ; else Utils . normalize ( class Probability , sum ) ; return class Probability ; } else { predicted Value [ NUM ] = ( temp != NUM ) ? predicted Value [ NUM ] / temp : NUM ; return predicted Value ; } }
@ Override protected Node remove From Frontier ( ) { Node result = frontier . remove ( ) ; explored . add ( result . get State ( ) ) ; frontier States . remove ( result . get State ( ) ) ; update Metrics ( frontier . size ( ) ) ; return result ; }
public String to String ( ) { String Buffer buf = new String Buffer ( ) ; if ( is Boot || ( data Chars [ NUM ] == Sprog Message . STX ) ) { for ( int i = NUM ; i < n Data Chars ; i ++ ) { buf . append ( STRING ) ; buf . append ( data Chars [ i ] ) ; buf . append ( STRING ) ; } } else { for ( int i = NUM ; i < n Data Chars ; i ++ ) { buf . append ( ( char ) data Chars [ i ] ) ; } } return buf . to String ( ) ; }
private Bitmap process Bitmap ( String key , int type ) { Log . d ( TAG , STRING + key ) ; if ( type == Image Data . IMAGE TYPE NORMAL ) { final File f = download Bitmap To File ( m Context , key , m Fetcher Params . m Http Cache Dir ) ; if ( f != null ) { final Bitmap bitmap = decode Sampled Bitmap From File ( f . to String ( ) , m Fetcher Params . m Image Width , m Fetcher Params . m Image Height ) ; f . delete ( ) ; return bitmap ; } } else if ( type == Image Data . IMAGE TYPE THUMBNAIL ) { final byte [ ] bitmap Bytes = download Bitmap To Memory ( m Context , key , m Fetcher Params . m Max Thumbnail Bytes ) ; if ( bitmap Bytes != null ) { return Bitmap Factory . decode Byte Array ( bitmap Bytes , NUM , bitmap Bytes . length ) ; } } else if ( type == Image Data . IMAGE TYPE LOCAL ) { final Bitmap bitmap = decode Sampled Bitmap From File ( key , m Fetcher Params . m Image Thumbnail Width , m Fetcher Params . m Image Thumbnail Height ) ; return bitmap ; } return null ; }
private static Map < String , Snmp Oid > build Pool Index Map ( Snmp Table Handler handler ) { if ( handler instanceof Snmp Cached Data ) return build Pool Index Map ( ( Snmp Cached Data ) handler ) ; final Map < String , Snmp Oid > m = new Hash Map < > ( ) ; Snmp Oid index = null ; while ( ( index = handler . get Next ( index ) ) != null ) { final Memory Pool MX Bean mpm = ( Memory Pool MX Bean ) handler . get Data ( index ) ; if ( mpm == null ) continue ; final String name = mpm . get Name ( ) ; if ( name == null ) continue ; m . put ( name , index ) ; } return m ; }
public String to Simple String ( ) { String Buffer buffer = new String Buffer ( ) ; buffer . append ( STRING + m Label + STRING + mY Vals . size ( ) + STRING ) ; return buffer . to String ( ) ; }
public static < T > T unchecked ( Callable < T > callable ) { try { return callable . call ( ) ; } catch ( Exception e ) { return sneaky Throw ( e ) ; } }
private void install Selector For Protocol ( Dict proxy Settings , Protocol Dispatch Selector ps , String protocol ) { String prefix = protocol . trim ( ) ; if ( is Active ( proxy Settings . get ( prefix + STRING ) ) ) { String proxy Host = ( String ) proxy Settings . get ( prefix + STRING ) ; int proxy Port = ( Integer ) proxy Settings . get ( prefix + STRING ) ; Fixed Proxy Selector fp = new Fixed Proxy Selector ( proxy Host , proxy Port ) ; ps . set Selector ( protocol . to Lower Case ( ) , fp ) ; Logger . log ( get Class ( ) , Log Level . TRACE , STRING , protocol , proxy Host , proxy Port ) ; } }
private List < String > read Lines ( final Buffered Reader reader ) throws IO Exception { final List < String > lines = new Array List < > ( ) ; String line ; for ( int line Number = NUM ; ( line = reader . read Line ( ) ) != null ; line Number ++ ) { if ( line . starts With ( STRING ) ) { final int last Line Index = lines . size ( ) - NUM ; final String previous Line = lines . get ( last Line Index ) ; if ( lines . is Empty ( ) || previous Line . is Empty ( ) ) { throw Decode Exception . fatal Error ( ERR TEMPLATE FILE INVALID LEADING SPACE . get ( line Number , line ) ) ; } lines . set ( last Line Index , previous Line + line . substring ( NUM ) ) ; } else { lines . add ( line ) ; } } return lines ; }
public static boolean is Monogamous ( Collection < Family > families ) { final Hash Set < String > parents = new Hash Set < > ( ) ; for ( Family f : families ) { if ( ! parents . add ( f . get Father ( ) ) ) { return BOOL ; } if ( ! parents . add ( f . get Mother ( ) ) ) { return BOOL ; } } return BOOL ; }
public void write Jar From Content ( final String class Name , final String content , final File output File ) throws IO Exception { File Output Stream file Output Stream = new File Output Stream ( output File ) ; write Jar From Content ( class Name , content , file Output Stream ) ; file Output Stream . close ( ) ; }
public static char [ ] [ ] load Image ( File file , char off Char ) throws File Not Found Exception , Runtime Exception { Array List < String > rows = Boolean Image Load . load Image Pad ( file , off Char ) ; String s = rows . get ( NUM ) ; char [ ] [ ] img = new char [ rows . size ( ) ] [ s . length ( ) ] ; for ( int i = NUM ; i < rows . size ( ) ; i ++ ) { s = rows . get ( i ) ; for ( int j = NUM ; j < s . length ( ) ; j ++ ) { img [ i ] [ j ] = s . char At ( j ) ; } } return img ; }
@ Action ( value = STRING ) @ Skip Validation public String cancel Receipt ( ) { if ( get Selected Receipts ( ) != null && get Selected Receipts ( ) . length > NUM ) { receipt Header = receipt Header Service . find By Id ( Long . value Of ( selected Receipts [ NUM ] ) , BOOL ) ; load Receipt Details ( ) ; } return Collection Constants . CANCELRECEIPT ; }
void present Animations ( View parent , float offset , float offset In Pixel ) { int anim Map Size = m Animations . size ( ) ; for ( int i = NUM ; i < anim Map Size ; i ++ ) { int key = m Animations . key At ( i ) ; Array List < Animation > animations = m Animations . get ( key ) ; int anim List Size = animations . size ( ) ; for ( int j = NUM ; j < anim List Size ; j ++ ) { Animation animation = animations . get ( j ) ; final View view To Animate ; if ( key == parent . get Id ( ) || key == Animation . FULL PAGE ) { view To Animate = parent ; } else { view To Animate = parent . find View By Id ( key ) ; } if ( animation == null || view To Animate == null ) { continue ; } animation . animate ( view To Animate , offset , offset In Pixel , - NUM ) ; } } }
@ Suppress Warnings ( STRING ) @ Override protected Object apply Updates To Managed Data ( Object updates ) { boolean made Changes = BOOL ; List < String > words = ( List < String > ) updates ; log . info ( STRING + words ) ; boolean ignore Case = get Ignore Case ( ) ; for ( String word : words ) { if ( ignore Case ) word = word . to Lower Case ( Locale . ROOT ) ; if ( managed Words . add ( word ) ) { made Changes = BOOL ; log . info ( STRING , word ) ; } } return made Changes ? managed Words : null ; }
public void read ( Data Input dis ) throws IO Exception { Debug . message ( STRING , STRING ) ; int poly Length = dis . read Int ( ) ; points = new float [ poly Length ] ; float x , y ; for ( int i = NUM ; i < points . length ; i += NUM ) { y = dis . read Float ( ) ; x = dis . read Float ( ) ; if ( i == NUM ) { min X = x ; min Y = y ; max X = x ; max Y = y ; } points [ i ] = y ; points [ i + NUM ] = x ; if ( x < min X ) min X = x ; if ( x > max X ) max X = x ; if ( y < min Y ) min Y = y ; if ( y > max Y ) max Y = y ; } }
public double [ ] read TS ( String data File Name , int load Limit ) throws SAX Exception , IO Exception { Path path = Paths . get ( data File Name ) ; if ( ! ( Files . exists ( path ) ) ) { throw new SAX Exception ( STRING ) ; } Buffered Reader reader = Files . new Buffered Reader ( path , DEFAULT CHARSET ) ; return read TS ( reader , NUM , load Limit ) ; }
public String register Name ( final String name , final Operator operator ) { if ( operator Name Map . get ( name ) != null ) { String base Name = name ; int index = base Name . index Of ( STRING ) ; if ( index >= NUM ) { base Name = base Name . substring ( NUM , index ) ; } int i = NUM ; while ( operator Name Map . get ( base Name + STRING + i + STRING ) != null ) { i ++ ; } String new Name = base Name + STRING + i + STRING ; operator Name Map . put ( new Name , operator ) ; return new Name ; } else { operator Name Map . put ( name , operator ) ; return name ; } }
public void remove Column ( final int col Index ) { final CSV Info info = get Info ( ) ; if ( info . header ) { final Array List < String > cols = new Array List < > ( Arrays . as List ( info . headers ) ) ; cols . remove ( col Index ) ; info . headers = cols . to Array ( new String [ cols . size ( ) ] ) ; } info . cols -- ; for ( final CSV Row row : rows ) { if ( ! row . is Comment Line ( ) ) { row . remove Element At ( col Index ) ; } } save Meta Data ( ) ; }
public static Protection Set check Protection Set Exists In DB ( Db Client db Client , String native Guid ) throws IO Exception { List < Protection Set > cgs = Custom Query Utility . get Active Protection Set By Native Guid ( db Client , native Guid ) ; Iterator < Protection Set > cgs Itr = cgs . iterator ( ) ; if ( cgs Itr . has Next ( ) ) { return cgs Itr . next ( ) ; } return null ; }
public static void assert Equal Streams ( Input Stream exp In , Input Stream act In , @ Nullable Long exp Size ) throws IO Exception { int buf Size = NUM ; byte buf 1 [ ] = new byte [ buf Size ] ; byte buf 2 [ ] = new byte [ buf Size ] ; long pos = NUM ; while ( BOOL ) { int i1 = act In . read ( buf 1 , NUM , buf Size ) ; int i2 ; if ( i1 == - NUM ) i2 = exp In . read ( buf 2 , NUM , NUM ) ; else IO Utils . read Fully ( exp In , buf 2 , NUM , i2 = i1 ) ; if ( i1 != i2 ) fail ( STRING + pos + STRING + i1 + STRING + i2 + STRING ) ; if ( i1 == - NUM ) break ; assert True ( STRING + pos + STRING + i1 + STRING + i2 + STRING , Arrays . equals ( buf 1 , buf 2 ) ) ; pos += i1 ; } if ( exp Size != null ) assert Equals ( exp Size . long Value ( ) , pos ) ; }
public final V update And Get ( T obj , Unary Operator < V > update Function ) { V prev , next ; do { prev = get ( obj ) ; next = update Function . apply ( prev ) ; } while ( ! compare And Set ( obj , prev , next ) ) ; return next ; }
public void populate Combos ( Activity activity , final Listener listener ) { List < String > services = get Services ( activity . get Package Manager ( ) ) ; populate Combos ( activity , services , listener ) ; }
public void test lbs host policy ( ) { final String H1 = STRING ; final Host Score host Score 1 = new Host Score ( STRING , NUM ) ; assert Equals ( NUM , host Score 1 . get Availability ( ) ) ; final Host Score [ ] host Scores = new Host Score [ ] { host Score 1 } ; { final Host Score actual Host = Abstract Host LBS Policy . get Host ( NUM , host Scores ) ; assert Same Ref ( host Score 1 , actual Host ) ; } { final Host Score actual Host = Abstract Host LBS Policy . get Host ( NUM , host Scores ) ; assert Same Ref ( host Score 1 , actual Host ) ; } { final Host Score actual Host = Abstract Host LBS Policy . get Host ( NUM , host Scores ) ; assert Same Ref ( host Score 1 , actual Host ) ; } { final Host Score actual Host = Abstract Host LBS Policy . get Host ( NUM , host Scores ) ; assert Same Ref ( host Score 1 , actual Host ) ; } { try { Abstract Host LBS Policy . get Host ( NUM , host Scores ) ; } catch ( Illegal Argument Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( ex ) ; } } { try { Abstract Host LBS Policy . get Host ( - NUM , host Scores ) ; } catch ( Illegal Argument Exception ex ) { if ( log . is Info Enabled ( ) ) log . info ( ex ) ; } } final UUID A = UUID . random UUID ( ) ; final UUID B = UUID . random UUID ( ) ; final UUID C = UUID . random UUID ( ) ; final Service Score service A = new Service Score ( A , H1 , to Request URI ( H1 ) ) ; final Service Score service B = new Service Score ( B , H1 , to Request URI ( H1 ) ) ; final Service Score service C = new Service Score ( C , H1 , to Request URI ( H1 ) ) ; { { final Random rand = new Random ( NUM ) ; final Service Score [ ] service Scores = new Service Score [ ] { service A } ; final Service Score actual Service = Abstract Host LBS Policy . get Service ( rand , host Score 1 , service Scores ) ; assert True ( actual Service == service A ) ; } { final Random rand = new Random ( NUM ) ; final Service Score [ ] service Scores = new Service Score [ ] { service A , service B , service C } ; final Service Score actual Service = Abstract Host LBS Policy . get Service ( rand , host Score 1 , service Scores ) ; assert True ( actual Service == service A ) ; } } }
private void format And Log Arguments ( Logging Level level , Color color , String msg , Object [ ] args ) { if ( ! USE COLORS ) { format And Log Arguments ( level , msg , args ) ; return ; } if ( Photon Logger . level . id < level . id ) { return ; } Local Date Time date Time = Local Date Time . now ( ) ; Formatting Tuple ft = Message Formatter . array Format ( msg , args ) ; String formatted = format Log Line ( level , date Time , ft . get Message ( ) ) ; Throwable t = ft . get Throwable ( ) ; if ( t == null ) { Logging Service . log Line ( date Time , formatted , color ) ; } else { Logging Service . log Throwable ( date Time , t , formatted , color ) ; } }
@ Override public int compare To ( Scout Widget scout Widget ) { if ( m Parent == null ) { return - NUM ; } if ( m Root Distance != scout Widget . m Root Distance ) { return Float . compare ( m Root Distance , scout Widget . m Root Distance ) ; } if ( mY != scout Widget . mY ) { return Float . compare ( mY , scout Widget . mY ) ; } if ( mX != scout Widget . mX ) { return Float . compare ( mX , scout Widget . mX ) ; } return NUM ; }
public Windows Directory ( Path path , Lock Factory lock Factory ) throws IO Exception { super ( path , lock Factory ) ; }
public static int find Minutes In Reminder List ( Array List < Integer > values , int minutes ) { int index = values . index Of ( minutes ) ; if ( index == - NUM ) { Log . e ( TAG , STRING + minutes + STRING ) ; return NUM ; } return index ; }
public void property Change ( Property Change Event e ) { String property Name = e . get Property Name ( ) ; if ( property Name == STRING || property Name == STRING ) { if ( e . get New Value ( ) instanceof J Scroll Bar ) { set Scroll Bar Relations ( ( J Scroll Bar ) e . get New Value ( ) ) ; } } }
public static double [ ] quantiles ( int n , double [ ] values ) { values = ( double [ ] ) values . clone ( ) ; Arrays . sort ( values ) ; double [ ] qtls = new double [ n + NUM ] ; for ( int i = NUM ; i <= n ; ++ i ) { qtls [ i ] = values [ ( ( values . length - NUM ) * i ) / n ] ; } return qtls ; }
private static Bitmap transform ( @ Non Null final Matrix scaler , @ Non Null final Bitmap source , final int target Width , final int target Height , final int options ) { final boolean scale Up = ( options & OPTIONS SCALE UP ) != NUM ; final boolean recycle = ( options & OPTIONS RECYCLE INPUT ) != NUM ; int delta X = source . get Width ( ) - target Width ; int delta Y = source . get Height ( ) - target Height ; if ( ! scale Up && ( delta X < NUM || delta Y < NUM ) ) { Bitmap b2 = Bitmap . create Bitmap ( target Width , target Height , Bitmap . Config . ARGB 8888 ) ; Canvas c = new Canvas ( b2 ) ; int delta X Half = Math . max ( NUM , delta X / NUM ) ; int delta Y Half = Math . max ( NUM , delta Y / NUM ) ; final Rect src = new Rect ( delta X Half , delta Y Half , delta X Half + Math . min ( target Width , source . get Width ( ) ) , delta Y Half + Math . min ( target Height , source . get Height ( ) ) ) ; int dst X = ( target Width - src . width ( ) ) / NUM ; int dst Y = ( target Height - src . height ( ) ) / NUM ; final Rect dst = new Rect ( dst X , dst Y , target Width - dst X , target Height - dst Y ) ; c . draw Bitmap ( source , src , dst , null ) ; if ( recycle ) { source . recycle ( ) ; } c . set Bitmap ( null ) ; return b2 ; } float bitmap Width F = source . get Width ( ) ; float bitmap Height F = source . get Height ( ) ; float bitmap Aspect = bitmap Width F / bitmap Height F ; float view Aspect = ( float ) target Width / target Height ; Matrix scaler Matrix = scaler ; if ( bitmap Aspect > view Aspect ) { float scale = target Height / bitmap Height F ; if ( scale < NUM || scale > NUM ) { scaler . set Scale ( scale , scale ) ; } else { scaler Matrix = null ; } } else { float scale = target Width / bitmap Width F ; if ( scale < NUM || scale > NUM ) { scaler . set Scale ( scale , scale ) ; } else { scaler Matrix = null ; } } final Bitmap b1 ; if ( scaler Matrix != null ) { b1 = Bitmap . create Bitmap ( source , NUM , NUM , source . get Width ( ) , source . get Height ( ) , scaler Matrix , BOOL ) ; } else { b1 = source ; } if ( recycle && b1 != source ) { source . recycle ( ) ; } final int dx 1 = Math . max ( NUM , b1 . get Width ( ) - target Width ) ; final int dy 1 = Math . max ( NUM , b1 . get Height ( ) - target Height ) ; final Bitmap b2 = Bitmap . create Bitmap ( b1 , dx 1 / NUM , dy 1 / NUM , target Width , target Height ) ; if ( b2 != b1 ) { if ( recycle || b1 != source ) { b1 . recycle ( ) ; } } return b2 ; }
private void test Data Source ( Hikari Data Source data Source Pool ) throws SQL Exception { try { Connection conn = null ; try { conn = data Source Pool . get Connection ( ) ; test Connection ( conn ) ; } finally { if ( conn != null ) { conn . close ( ) ; } } } catch ( SQL Exception e ) { log Connection Failure ( ) ; throw e ; } }
private void recalculate Table Indices ( ) { List < Integer > indices = new Linked List < Integer > ( ) ; for ( int i = NUM ; i < elements . length ; i ++ ) { if ( mask [ elements [ i ] ] ) { indices . add ( i ) ; } } table Index Map = new int [ indices . size ( ) ] ; Iterator < Integer > i = indices . iterator ( ) ; int counter = NUM ; while ( i . has Next ( ) ) { table Index Map [ counter ++ ] = i . next ( ) ; } }
public static Cookie new Cookie ( String name , String value , int max Age , String path , String domain ) { Cookie cookie = null ; if ( cookie Encoding ) { cookie = new Cookie ( name , URL Enc Dec . encode ( value ) ) ; } else { cookie = new Cookie ( name , value ) ; } cookie . set Max Age ( max Age ) ; if ( ( path != null ) && ( path . length ( ) > NUM ) ) { cookie . set Path ( path ) ; } else { cookie . set Path ( STRING ) ; } if ( ( domain != null ) && ( domain . length ( ) > NUM ) ) { cookie . set Domain ( domain ) ; } cookie . set Secure ( is Cookie Secure ( ) ) ; return cookie ; }
@ Override public List < Alarm Model Descriptor > alarm Models ( ) { List < Alarm Model Descriptor > descriptors = new Array List < Alarm Model Descriptor > ( ) ; for ( Service Reference < Alarm Model > model : models ) { descriptors . add ( model . meta Info ( Alarm Model Descriptor . class ) ) ; } return descriptors ; }
private int decode Channel Wordlen ( int ch Num ) { int ret ; Channel chan = ctx . channels [ ch Num ] ; Channel ref Chan = ctx . channels [ NUM ] ; int weight Idx = NUM ; chan . fill Mode = NUM ; switch ( br . read ( NUM ) ) { case NUM : for ( int i = NUM ; i < ctx . num Quant Units ; i ++ ) { chan . qu Wordlen [ i ] = br . read ( NUM ) ; } break ; case NUM : if ( ch Num > NUM ) { ret = num Coded Units ( chan ) ; if ( ret < NUM ) { return ret ; } if ( chan . num Coded Vals > NUM ) { VLC vlc Tab = wl vlc tabs [ br . read ( NUM ) ] ; for ( int i = NUM ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Wordlen [ i ] = ( ref Chan . qu Wordlen [ i ] + delta ) & NUM ; } } } else { weight Idx = br . read ( NUM ) ; ret = num Coded Units ( chan ) ; if ( ret < NUM ) { return ret ; } if ( chan . num Coded Vals > NUM ) { int pos = br . read ( NUM ) ; if ( pos > chan . num Coded Vals ) { log . error ( String . format ( STRING , pos ) ) ; return AT 3 P ERROR ; } int delta Bits = br . read ( NUM ) ; int min Val = br . read ( NUM ) ; for ( int i = NUM ; i < pos ; i ++ ) { chan . qu Wordlen [ i ] = br . read ( NUM ) ; } for ( int i = pos ; i < chan . num Coded Vals ; i ++ ) { chan . qu Wordlen [ i ] = ( min Val + get Delta ( delta Bits ) ) & NUM ; } } } break ; case NUM : ret = num Coded Units ( chan ) ; if ( ret < NUM ) { return ret ; } if ( ch Num > NUM && chan . num Coded Vals > NUM ) { VLC vlc Tab = wl vlc tabs [ br . read ( NUM ) ] ; int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Wordlen [ NUM ] = ( ref Chan . qu Wordlen [ NUM ] + delta ) & NUM ; for ( int i = NUM ; i < chan . num Coded Vals ; i ++ ) { int diff = ref Chan . qu Wordlen [ i ] - ref Chan . qu Wordlen [ i - NUM ] ; delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i - NUM ] + diff + delta ) & NUM ; } } else if ( chan . num Coded Vals > NUM ) { boolean flag = br . read Bool ( ) ; VLC vlc Tab = wl vlc tabs [ br . read ( NUM ) ] ; int start Val = br . read ( NUM ) ; unpack Vq Shape ( start Val , atrac 3 p wl shapes [ start Val ] [ br . read ( NUM ) ] , chan . qu Wordlen , chan . num Coded Vals ) ; if ( ! flag ) { for ( int i = NUM ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + delta ) & NUM ; } } else { int i ; for ( i = NUM ; i < ( chan . num Coded Vals & - NUM ) ; i += NUM ) { if ( ! br . read Bool ( ) ) { chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + vlc Tab . get VLC 2 ( br ) ) & NUM ; chan . qu Wordlen [ i + NUM ] = ( chan . qu Wordlen [ i + NUM ] + vlc Tab . get VLC 2 ( br ) ) & NUM ; } } if ( ( chan . num Coded Vals & NUM ) != NUM ) { chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + vlc Tab . get VLC 2 ( br ) ) & NUM ; } } } break ; case NUM : weight Idx = br . read ( NUM ) ; ret = num Coded Units ( chan ) ; if ( ret < NUM ) { return ret ; } if ( chan . num Coded Vals > NUM ) { VLC vlc Tab = wl vlc tabs [ br . read ( NUM ) ] ; chan . qu Wordlen [ NUM ] = br . read ( NUM ) ; for ( int i = NUM ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i - NUM ] + delta ) & NUM ; } } break ; } if ( chan . fill Mode == NUM ) { for ( int i = chan . num Coded Vals ; i < ctx . num Quant Units ; i ++ ) { chan . qu Wordlen [ i ] = ( ch Num > NUM ? br . read 1 ( ) : NUM ) ; } } else if ( chan . fill Mode == NUM ) { int pos = ( ch Num > NUM ? chan . num Coded Vals + chan . split Point : ctx . num Quant Units - chan . split Point ) ; for ( int i = chan . num Coded Vals ; i < pos ; i ++ ) { chan . qu Wordlen [ i ] = NUM ; } } if ( weight Idx != NUM ) { return add Wordlen Weights ( chan , weight Idx ) ; } return NUM ; }
final void unfactor ( IR ir ) { for ( Enumeration < Instruction > e = forward Real Instr Enumerator ( ) ; e . has More Elements ( ) ; ) { Instruction s = e . next Element ( ) ; Enumeration < Basic Block > exp Outs = get Applicable Exceptional Out ( s ) ; if ( exp Outs . has More Elements ( ) && e . has More Elements ( ) ) { Basic Block next = split Node With Links At ( s , ir ) ; next . unfactor ( ir ) ; prune Exceptional Out ( ir ) ; return ; } } }
protected void estimate Densities ( Relation < O > rel , KNN Query < O > knnq , final DBI Ds ids , Writable Data Store < double [ ] > densities ) { final int dim = dimensionality ( rel ) ; final int knum = kmax + NUM - kmin ; for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { densities . put ( iter , new double [ knum ] ) ; } Finite Progress prog = LOG . is Verbose ( ) ? new Finite Progress ( STRING , ids . size ( ) , LOG ) : null ; double iminbw = ( min Bandwidth > NUM ) ? NUM / ( min Bandwidth * scale ) : Double . POSITIVE INFINITY ; for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { KNN List neighbors = knnq . get KNN For DBID ( iter , kmax + NUM ) ; int k = NUM , idx = NUM ; double sum = NUM ; for ( Double DBID List Iter kneighbor = neighbors . iter ( ) ; k <= kmax && kneighbor . valid ( ) ; kneighbor . advance ( ) , k ++ ) { sum += kneighbor . double Value ( ) ; if ( k < kmin ) { continue ; } final double ibw = Math . min ( k / ( sum * scale ) , iminbw ) ; final double sca = Math Util . powi ( ibw , dim ) ; for ( Double DBID List Iter neighbor = neighbors . iter ( ) ; neighbor . valid ( ) ; neighbor . advance ( ) ) { final double dens ; if ( sca < Double . POSITIVE INFINITY ) { dens = sca * kernel . density ( neighbor . double Value ( ) * ibw ) ; } else { dens = neighbor . double Value ( ) == NUM ? NUM : NUM ; } densities . get ( neighbor ) [ idx ] += dens ; if ( dens < CUTOFF ) { break ; } } ++ idx ; } LOG . increment Processed ( prog ) ; } LOG . ensure Completed ( prog ) ; }
private Boolean handle Execution Response ( Http URL Connection connection ) throws IO Exception { int response Code = connection . get Response Code ( ) ; if ( is Successful ( response Code ) ) { String response Content = get Response Content As String ( connection ) ; String id = response Content != null ? response Content : STRING ; Log . i ( TAG , STRING + m File To Upload . get Name ( ) + STRING + id ) ; cleanup Minidump File ( ) ; try { append Uploaded Entry To Log ( id ) ; } catch ( IO Exception ioe ) { Log . e ( TAG , STRING ) ; } return BOOL ; } else { String msg = String . format ( Locale . US , STRING , m File To Upload . get Name ( ) , response Code , connection . get Response Message ( ) ) ; Log . i ( TAG , msg ) ; return BOOL ; } }
protected static String escape Dot ( String identifier To Escape ) { int indexof = identifier To Escape . index Of ( STRING ) ; if ( indexof == - NUM ) { return identifier To Escape ; } String Builder builder = new String Builder ( ) ; for ( int i = NUM ; i < identifier To Escape . length ( ) ; i ++ ) { char c = identifier To Escape . char At ( i ) ; if ( c != STRING ) { builder . append ( c ) ; continue ; } if ( i > NUM ) { if ( identifier To Escape . char At ( i - NUM ) == STRING ) { builder . append ( STRING ) ; continue ; } } builder . append ( STRING ) ; builder . append ( STRING ) ; } return builder . to String ( ) ; }
private int parse Header Tag ( final byte [ ] b , final int off ) throws Parse Exception { final int len = b . length - off ; final Crypto Algorithm crypto Algo = Crypto Algorithm . deserialize ( crypto Algo Val ) ; final int tag Len = crypto Algo . get Tag Len ( ) ; if ( len >= tag Len ) { header Tag = Arrays . copy Of Range ( b , off , off + tag Len ) ; return tag Len ; } else { throw new Parse Exception ( STRING ) ; } }
@ Benchmark public void no Coding ( ) { run ( ) ; }
private void r Cubic To ( float dx 1 , float dy 1 , float dx 2 , float dy 2 , float dx 3 , float dy 3 ) { if ( is Empty ( ) ) { m Path . move To ( m Last X = NUM , m Last Y = NUM ) ; } dx 1 += m Last X ; dy 1 += m Last Y ; dx 2 += m Last X ; dy 2 += m Last Y ; dx 3 += m Last X ; dy 3 += m Last Y ; m Path . curve To ( dx 1 , dy 1 , dx 2 , dy 2 , m Last X = dx 3 , m Last Y = dy 3 ) ; }
private List < String > read Lines ( final Buffered Reader reader ) throws IO Exception { final List < String > lines = new Array List < > ( ) ; String line ; for ( int line Number = NUM ; ( line = reader . read Line ( ) ) != null ; line Number ++ ) { if ( line . starts With ( STRING ) ) { final int last Line Index = lines . size ( ) - NUM ; final String previous Line = lines . get ( last Line Index ) ; if ( lines . is Empty ( ) || previous Line . is Empty ( ) ) { throw Decode Exception . fatal Error ( ERR TEMPLATE FILE INVALID LEADING SPACE . get ( line Number , line ) ) ; } lines . set ( last Line Index , previous Line + line . substring ( NUM ) ) ; } else { lines . add ( line ) ; } } return lines ; }
protected void send End Of Header ( final Output Stream out ) throws IO Exception { LOG . trace ( STRING ) ; out . write ( CRLF BYTES ) ; out . write ( CRLF BYTES ) ; }
public void update Quantity ( Item Bean original , Item Bean item To Add , boolean add ) { Big Decimal original Quantity = original . get Qty ( ) ; Big Decimal quantity To Add = item To Add . get Qty ( ) ; Big Decimal final Quantity = null ; if ( ! add ) final Quantity = original Quantity . subtract ( quantity To Add ) ; else final Quantity = original Quantity . add ( quantity To Add ) ; original . set Qty ( final Quantity ) ; }
final public boolean starts With Ignore Case ( final String prefix ) { final int l = prefix . length ( ) ; if ( l > length ( ) ) return BOOL ; int i = l ; final char [ ] a = array ; char c , d ; while ( i -- != NUM ) { c = Character . to Lower Case ( Character . to Upper Case ( a [ i ] ) ) ; d = Character . to Lower Case ( Character . to Upper Case ( prefix . char At ( i ) ) ) ; if ( c != d ) return BOOL ; } return BOOL ; }
public static void print Warnings ( Connection conn , Print Writer pw ) { if ( conn != null ) { try { print Stack Trace ( conn . get Warnings ( ) , pw ) ; } catch ( SQL Exception e ) { print Stack Trace ( e , pw ) ; } } }

public void read Data ( Data Input din ) throws IO Exception { int byte Count = din . read Unsigned Byte ( ) ; int record Count = byte Count / NUM ; records = new Record Request [ record Count ] ; for ( int i = NUM ; i < record Count ; i ++ ) { if ( din . read Byte ( ) != NUM ) { throw new IO Exception ( ) ; } int file = din . read Unsigned Short ( ) ; int record = din . read Unsigned Short ( ) ; if ( record < NUM || record >= NUM ) { throw new IO Exception ( ) ; } int count = din . read Unsigned Short ( ) ; records [ i ] = new Record Request ( file , record , count ) ; } }
public void add ( int index , E element ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] elements = get Array ( ) ; int len = elements . length ; if ( index > len || index < NUM ) throw new Index Out Of Bounds Exception ( STRING + index + STRING + len ) ; Object [ ] new Elements ; int num Moved = len - index ; if ( num Moved == NUM ) new Elements = Arrays . copy Of ( elements , len + NUM ) ; else { new Elements = new Object [ len + NUM ] ; System . arraycopy ( elements , NUM , new Elements , NUM , index ) ; System . arraycopy ( elements , index , new Elements , index + NUM , num Moved ) ; } new Elements [ index ] = element ; set Array ( new Elements ) ; } finally { lock . unlock ( ) ; } }
void create Edges ( String [ ] v ) { graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM ] , v [ NUM ] , Edge Type . DIRECTED ) ; }
@ Suppress Warnings ( STRING ) public Data Response paginate List ( Map < String , String > request Params , Query query , String default Sort , Map < String , Query Property > properties ) { return paginate List ( request Params , null , query , default Sort , properties ) ; }
private < T extends Component > T build Row ( final J Panel panel , final I Type Description description , final String hint , final T component , final boolean is Last ) { component . set Preferred Size ( new Dimension ( COLORPANEL WIDTH , COLORPANEL HEIGHT ) ) ; final J Panel row Panel = new J Panel ( new Border Layout ( ) ) ; row Panel . set Border ( new Empty Border ( NUM , NUM , is Last ? NUM : NUM , NUM ) ) ; final J Panel inner Panel = new J Panel ( new Grid Layout ( NUM , NUM ) ) ; inner Panel . add ( new J Check Box ( new Checkbox Action ( description , description . get Description ( ) + STRING ) ) , Border Layout . CENTER ) ; inner Panel . add ( C Hint Creator . create Hint Panel ( component , hint ) , Border Layout . EAST ) ; row Panel . add ( inner Panel , Border Layout . WEST ) ; panel . add ( row Panel ) ; return component ; }
private static void add Curve To ( Point 2 D . Double [ ] bez Curve , Bezier Path bezier Path , double error Squared , boolean connects Corners ) { Bezier Path . Node last Node = bezier Path . get ( bezier Path . size ( ) - NUM ) ; double error = Math . sqrt ( error Squared ) ; if ( connects Corners && Geom . line Contains Point ( last Node . x [ NUM ] , last Node . y [ NUM ] , bez Curve [ NUM ] . x , bez Curve [ NUM ] . y , bez Curve [ NUM ] . x , bez Curve [ NUM ] . y , error ) && Geom . line Contains Point ( last Node . x [ NUM ] , last Node . y [ NUM ] , bez Curve [ NUM ] . x , bez Curve [ NUM ] . y , bez Curve [ NUM ] . x , bez Curve [ NUM ] . y , error ) ) { bezier Path . line To ( bez Curve [ NUM ] . x , bez Curve [ NUM ] . y ) ; } else { bezier Path . curve To ( bez Curve [ NUM ] . x , bez Curve [ NUM ] . y , bez Curve [ NUM ] . x , bez Curve [ NUM ] . y , bez Curve [ NUM ] . x , bez Curve [ NUM ] . y ) ; } }
private void initfrom Root Block ( final I Root Block View rb ) throws IO Exception { assert ( rb != null ) ; m store UUID = rb . get UUID ( ) ; if ( rb . get Next Offset ( ) == NUM ) { default Init ( ) ; } else { final long nxt Offset = rb . get Next Offset ( ) ; m next Allocation = - ( int ) ( nxt Offset > > NUM ) ; if ( m next Allocation == NUM ) { m next Allocation = - ( NUM + META ALLOCATION ) ; } m committed Next Allocation = m next Allocation ; m meta Bits Addr = - ( int ) nxt Offset ; if ( log . is Info Enabled ( ) ) { log . info ( STRING + m meta Bits Addr ) ; } { final long meta Addr = rb . get Meta Start Addr ( ) ; m file Size = ( int ) - ( meta Addr & NUM ) ; if ( log . is Info Enabled ( ) ) log . info ( STRING + convert Addr ( m file Size ) ) ; } long rawmbaddr = rb . get Meta Bits Addr ( ) ; final int meta Bits Store = ( int ) ( rawmbaddr & NUM ) ; if ( meta Bits Store > NUM ) { rawmbaddr >>= NUM ; final byte [ ] buf = new byte [ meta Bits Store * NUM ] ; File Channel Utility . read All ( m reopener , Byte Buffer . wrap ( buf ) , rawmbaddr ) ; final Data Input Stream str Buf = new Data Input Stream ( new Byte Array Input Stream ( buf ) ) ; final int store Version = str Buf . read Int ( ) ; switch ( ( store Version & NUM ) ) { case ( c Version & NUM ) : case ( c Version Demispace & NUM ) : break ; default : throw new Illegal State Exception ( STRING + store Version + STRING + c Version + STRING + is Using Demi Space ( ) ) ; } m last Deferred Release Time = str Buf . read Long ( ) ; if ( str Buf . read Int ( ) != c Default Meta Bits Size ) { throw new Illegal State Exception ( STRING ) ; } final int alloc Blocks = str Buf . read Int ( ) ; m storage Stats Addr = str Buf . read Long ( ) ; for ( int i = NUM ; i < c Reserved Meta Bits ; i ++ ) { str Buf . read Int ( ) ; } m alloc Sizes = new int [ alloc Blocks ] ; for ( int i = NUM ; i < alloc Blocks ; i ++ ) { m alloc Sizes [ i ] = str Buf . read Int ( ) ; } m meta Bits Size = meta Bits Store - alloc Blocks - c Meta Hdr Fields ; m meta Bits = new int [ m meta Bits Size ] ; if ( log . is Info Enabled ( ) ) { log . info ( STRING + rawmbaddr ) ; } for ( int i = NUM ; i < m meta Bits Size ; i ++ ) { m meta Bits [ i ] = str Buf . read Int ( ) ; } sync Meta Transients ( ) ; final int num Fixed = m alloc Sizes . length ; m free Fixed = new Array List [ num Fixed ] ; for ( int i = NUM ; i < num Fixed ; i ++ ) { m free Fixed [ i ] = new Array List < Fixed Allocator > ( ) ; } check Core Allocations ( ) ; read Allocation Blocks ( ) ; } if ( log . is Info Enabled ( ) ) log . info ( STRING + m next Allocation + STRING + m meta Bits Addr ) ; } }
private void open Counter Data Output Stream ( ) throws Data Fallback Exception { if ( d Output == null ) { if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STRING + counter File . get Name ( ) + STRING ) ; try { d Output = new Buffered Writer ( new File Writer ( counter File ) ) ; } catch ( IO Exception e ) { throw new Data Fallback Exception ( e . get Message ( ) ) ; } } }
private static String parse Version Number ( String line ) { String Tokenizer tokenizer = new String Tokenizer ( line , STRING ) ; if ( ! expect ( tokenizer , STRING ) || ! expect ( tokenizer , STRING ) || ! tokenizer . has More Tokens ( ) ) { return null ; } return tokenizer . next Token ( ) ; }
public void write ( String str , int off , int len ) throws IO Exception { if ( output == null ) throw new IO Exception ( STRING ) ; output . append ( str , off , off + len ) ; }
@ Override public Array List < Object > [ ] mine CA Rs ( Instances data ) throws Exception { m car = BOOL ; build Associations ( data ) ; return m all The Rules ; }
public void test Float Value Neg Infinity ( ) { String a = STRING ; Big Decimal a Number = new Big Decimal ( a ) ; float result = Float . NEGATIVE INFINITY ; assert True ( STRING , a Number . float Value ( ) == result ) ; }
public static String replace Last ( String s , String sub , String with ) { int i = s . last Index Of ( sub ) ; if ( i == - NUM ) { return s ; } return s . substring ( NUM , i ) + with + s . substring ( i + sub . length ( ) ) ; }
public static void copy Geo ( Geo Time Serie from , Geo Time Serie to ) { GTS Helper . sort ( from , BOOL ) ; GTS Helper . sort ( to , BOOL ) ; int fromidx = NUM ; int toidx = NUM ; while ( toidx < to . values && fromidx < from . values ) { long fromtick = GTS Helper . tick At Index ( from , fromidx ) ; long totick = GTS Helper . tick At Index ( to , toidx ) ; while ( fromidx < from . values && fromtick < totick ) { fromidx ++ ; fromtick = GTS Helper . tick At Index ( from , fromidx ) ; } if ( fromidx >= from . values ) { break ; } while ( toidx < to . values && totick < fromtick ) { toidx ++ ; totick = GTS Helper . tick At Index ( to , toidx ) ; } if ( toidx >= to . values ) { break ; } if ( totick == fromtick ) { long location = GTS Helper . location At Index ( from , fromidx ) ; long elevation = GTS Helper . elevation At Index ( from , fromidx ) ; GTS Helper . set Location At Index ( to , toidx , location ) ; GTS Helper . set Elevation At Index ( to , toidx , elevation ) ; fromidx ++ ; } } }
public void add Object ( Object o ) throws Exception { inspect ( o . get Class ( ) ) ; }
public static void main ( String [ ] args ) { System . set Property ( STRING , STRING ) ; J Frame frame = new J Frame ( ) ; frame . set Content Pane ( new Bowler Studio 3 d Engine ( ) ) ; frame . set Size ( NUM , NUM ) ; frame . set Visible ( BOOL ) ; frame . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; }
@ Override public int hash Code ( ) { int hash = raw URI . hash Code ( ) ; if ( raw Host != null ) { hash = hash * NUM + raw Host . hash Code ( ) ; } hash = hash * NUM + port ; return hash ; }
public final void test Add All Helper Text Colors From Collection ( ) { int helper Text Color 1 = Color . BLACK ; int helper Text Color 2 = Color . GRAY ; Collection < Integer > helper Text Colors 1 = new Linked List < > ( ) ; helper Text Colors 1 . add ( helper Text Color 1 ) ; helper Text Colors 1 . add ( helper Text Color 2 ) ; Password Edit Text password Edit Text = new Password Edit Text ( get Context ( ) ) ; password Edit Text . add All Helper Text Colors ( helper Text Colors 1 ) ; password Edit Text . add All Helper Text Colors ( helper Text Colors 1 ) ; Collection < Integer > helper Text Colors 2 = password Edit Text . get Helper Text Colors ( ) ; assert Equals ( helper Text Colors 1 . size ( ) , helper Text Colors 2 . size ( ) ) ; Iterator < Integer > iterator = helper Text Colors 2 . iterator ( ) ; assert Equals ( helper Text Color 1 , ( int ) iterator . next ( ) ) ; assert Equals ( helper Text Color 2 , ( int ) iterator . next ( ) ) ; }
public boolean save As Geo JSON ( File file ) { try { File Writer fw = new File Writer ( file ) ; Buffered Writer writer = new Buffered Writer ( fw , NUM ) ; boolean result = save As Geo JSON ( writer ) ; writer . close ( ) ; return result ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return BOOL ; } }
public void test Hash Code ( ) { Set < Model > set = new Hash Set < Model > ( ) ; Model m1 = new Mock Model ( ) ; Model m2 = new Mock Model ( ) ; Model m3 = new Another Mock Model ( ) ; assert False ( m1 . hash Code ( ) == m2 . hash Code ( ) ) ; set . add ( m1 ) ; set . add ( m2 ) ; assert Equals ( NUM , set . size ( ) ) ; assert False ( m1 . hash Code ( ) == m3 . hash Code ( ) ) ; set . add ( m3 ) ; assert Equals ( NUM , set . size ( ) ) ; }
public void write File ( String name , String mime Type , String file Name , Input Stream is ) throws IO Exception { if ( is == null ) { throw new Illegal Argument Exception ( STRING ) ; } if ( file Name == null || file Name . is Empty ( ) ) { throw new Illegal Argument Exception ( STRING ) ; } out . write Bytes ( PREFIX ) ; out . write Bytes ( boundary ) ; out . write Bytes ( NEWLINE ) ; out . write Bytes ( STRING + name + STRING + file Name + STRING ) ; out . write Bytes ( NEWLINE ) ; if ( mime Type != null ) { out . write Bytes ( STRING + mime Type ) ; out . write Bytes ( NEWLINE ) ; } out . write Bytes ( NEWLINE ) ; byte [ ] data = new byte [ NUM ] ; int r = NUM ; while ( ( r = is . read ( data , NUM , data . length ) ) != - NUM ) { out . write ( data , NUM , r ) ; } is . close ( ) ; out . write Bytes ( NEWLINE ) ; out . flush ( ) ; }
@ Target Api ( Build . VERSION CODES . ICE CREAM SANDWICH MR 1 ) private boolean needs Fallback Locale ( ) { if ( ! PACKAGE GOOGLE TTS . equals ( m Tts Engine ) || ( m Default Locale != null ) ) { return BOOL ; } if ( m Tts == null ) { return BOOL ; } final Set < String > features = m Tts . get Features ( m System Locale ) ; return ! ( ( ( features != null ) && features . contains ( Engine . KEY FEATURE EMBEDDED SYNTHESIS ) ) || ! is Not Available Status ( m Tts . is Language Available ( m System Locale ) ) ) ; }

protected String parse Quoted String ( ) throws IO Exception , RDF Parse Exception { String result = null ; int c1 = read Code Point ( ) ; verify Character Or Fail ( c1 , STRING ) ; int c2 = read Code Point ( ) ; int c3 = read Code Point ( ) ; if ( ( c1 == STRING && c2 == STRING && c3 == STRING ) || ( c1 == STRING && c2 == STRING && c3 == STRING ) ) { result = parse Long String ( c2 ) ; } else { unread ( c3 ) ; unread ( c2 ) ; result = parse String ( c1 ) ; } try { result = Turtle Util . decode String ( result ) ; } catch ( Illegal Argument Exception e ) { report Error ( e . get Message ( ) , Basic Parser Settings . VERIFY DATATYPE VALUES ) ; } return result ; }
protected void add Non Match ( String Builder sb , String text ) { sb . append ( text ) ; }
public static boolean check File ( String track Name , boolean should Exist , Drive drive ) throws IO Exception { long start Time = System . current Time Millis ( ) ; while ( System . current Time Millis ( ) - start Time < MAX TIME TO WAIT SYNC ) { boolean exist = get File ( track Name , drive ) != null ; if ( exist == should Exist ) { return BOOL ; } } Assert . fail ( ) ; return BOOL ; }
@ Override public void delete Columns ( int start , int len ) throws Fits Exception { ensure Data ( ) ; Object [ ] new Data = new Object [ this . n Fields - len ] ; int [ ] new Offsets = new int [ this . n Fields - len ] ; int [ ] new Lengths = new int [ this . n Fields - len ] ; Class < ? > [ ] new Types = new Class [ this . n Fields - len ] ; String [ ] new Nulls = new String [ this . n Fields - len ] ; System . arraycopy ( this . data , NUM , new Data , NUM , start ) ; System . arraycopy ( this . lengths , NUM , new Lengths , NUM , start ) ; System . arraycopy ( this . types , NUM , new Types , NUM , start ) ; System . arraycopy ( this . nulls , NUM , new Nulls , NUM , start ) ; System . arraycopy ( this . data , start + len , new Data , start , this . n Fields - start - len ) ; System . arraycopy ( this . lengths , start + len , new Lengths , start , this . n Fields - start - len ) ; System . arraycopy ( this . types , start + len , new Types , start , this . n Fields - start - len ) ; System . arraycopy ( this . nulls , start + len , new Nulls , start , this . n Fields - start - len ) ; for ( int i = start ; i < start + len ; i += NUM ) { this . row Len -= this . lengths [ i ] + NUM ; } this . data = new Data ; this . offsets = new Offsets ; this . lengths = new Lengths ; this . types = new Types ; this . nulls = new Nulls ; if ( this . is Null != null ) { boolean found = BOOL ; boolean [ ] new Is Null = new boolean [ this . n Rows * ( this . n Fields - len ) ] ; for ( int i = NUM ; i < this . n Rows ; i += NUM ) { int old Off = this . n Fields * i ; int new Off = ( this . n Fields - len ) * i ; for ( int col = NUM ; col < start ; col += NUM ) { new Is Null [ new Off + col ] = this . is Null [ old Off + col ] ; found = found || this . is Null [ old Off + col ] ; } for ( int col = start + len ; col < this . n Fields ; col += NUM ) { new Is Null [ new Off + col - len ] = this . is Null [ old Off + col ] ; found = found || this . is Null [ old Off + col ] ; } } if ( found ) { this . is Null = new Is Null ; } else { this . is Null = null ; } } this . buffer = null ; this . n Fields -= len ; }
public static String remove Chars ( String src , char ... chars ) { int i = src . length ( ) ; String Builder sb = new String Builder ( i ) ; mainloop : for ( int j = NUM ; j < i ; j ++ ) { char c = src . char At ( j ) ; for ( char a Char : chars ) { if ( c == a Char ) { continue mainloop ; } } sb . append ( c ) ; } return sb . to String ( ) ; }
private void add Indexed Columns ( ) throws SQL Exception { Database Meta Data meta Data = get Database Meta Data ( ) ; Arrays . sort ( column Indexes ) ; List < String > columns = new Array List < > ( ) ; try ( Result Set rs = meta Data . get Columns ( null , null , normalize Object Name ( statement Model . get Table Name ( ) ) , null ) ) { while ( rs . next ( ) ) { if ( Arrays . binary Search ( column Indexes , rs . get Int ( IDX ORDINAL POSITION ) ) >= NUM ) { columns . add ( quote Object Name ( rs . get String ( IDX COLUMN NAME ) ) ) ; } } } column Names = columns . to Array ( new String [ NUM ] ) ; add Returning Clause ( ) ; }
public void load Ham N Spam ( Connection conn ) throws java . sql . SQL Exception { Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = conn . prepare Statement ( sql Queries . get Sql String ( STRING , BOOL ) ) ; rs = pstmt . execute Query ( ) ; Map < String , Integer > ham = get Ham Token Counts ( ) ; while ( rs . next ( ) ) { String token = rs . get String ( NUM ) ; int count = rs . get Int ( NUM ) ; if ( count > NUM ) { ham . put ( token , count ) ; } } delegated Log ( STRING + ham . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepare Statement ( sql Queries . get Sql String ( STRING , BOOL ) ) ; rs = pstmt . execute Query ( ) ; Map < String , Integer > spam = get Spam Token Counts ( ) ; while ( rs . next ( ) ) { String token = rs . get String ( NUM ) ; int count = rs . get Int ( NUM ) ; if ( count > NUM ) { spam . put ( token , count ) ; } } delegated Log ( STRING + spam . size ( ) ) ; rs . close ( ) ; pstmt . close ( ) ; pstmt = conn . prepare Statement ( sql Queries . get Sql String ( STRING , BOOL ) ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { set Ham Message Count ( rs . get Int ( NUM ) ) ; set Spam Message Count ( rs . get Int ( NUM ) ) ; } rs . close ( ) ; pstmt . close ( ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( java . sql . SQL Exception se ) { } rs = null ; } if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( java . sql . SQL Exception se ) { } pstmt = null ; } } }
private static long copy ( Input Stream from , Output Stream to ) throws IO Exception { byte [ ] buf = new byte [ Settings . BUFFER SIZE ] ; long total = NUM ; while ( BOOL ) { int r = from . read ( buf ) ; if ( r == - NUM ) { break ; } to . write ( buf , NUM , r ) ; total += r ; } return total ; }
public void on Drawer Closed ( View view ) { super . on Drawer Closed ( view ) ; update Action Bar Title And Home Button ( null ) ; invalidate Options Menu ( ) ; }
public void test List Sub Class ( ) throws Exception { Object Mapper mapper = new Object Mapper ( ) ; List Sub Class result = mapper . read Value ( STRING , List Sub Class . class ) ; assert Equals ( NUM , result . size ( ) ) ; Object value = result . get ( NUM ) ; assert Equals ( String Wrapper . class , value . get Class ( ) ) ; String Wrapper bw = ( String Wrapper ) value ; assert Equals ( STRING , bw . str ) ; }
public Command Editor ( Action Command cmd , Editable Resources res , String ui Name , List < com . codename 1 . ui . Command > commands , Properties project Generator Settings , boolean java 5 ) { this . java 5 = java 5 ; this . project Generator Settings = project Generator Settings ; this . ui Name = ui Name ; init Components ( ) ; go To Source . set Enabled ( project Generator Settings != null ) ; com . codename 1 . ui . Command [ ] existing = new com . codename 1 . ui . Command [ commands . size ( ) + NUM ] ; existing [ NUM ] = null ; for ( int iter = NUM ; iter < existing . length ; iter ++ ) { existing [ iter ] = commands . get ( iter - NUM ) ; } Vector post Actions = new Vector ( ) ; post Actions . add Element ( STRING ) ; Vector actions = new Vector ( ) ; actions . add Element ( STRING ) ; actions . add Element ( STRING ) ; actions . add Element ( STRING ) ; actions . add Element ( STRING ) ; actions . add Element ( STRING ) ; back Command . set Selected ( cmd . is Back Command ( ) ) ; String [ ] ui Entries = new String [ res . get UI Resource Names ( ) . length ] ; System . arraycopy ( res . get UI Resource Names ( ) , NUM , ui Entries , NUM , ui Entries . length ) ; Arrays . sort ( ui Entries ) ; for ( String uis : ui Entries ) { if ( ! ui Name . equals ( uis ) ) { actions . add Element ( uis ) ; post Actions . add Element ( uis ) ; } } action . set Model ( new Default Combo Box Model ( actions ) ) ; post Action . set Model ( new Default Combo Box Model ( post Actions ) ) ; String a = cmd . get Action ( ) ; if ( a != null ) { if ( a . starts With ( STRING ) ) { a = a . substring ( NUM ) ; asynchronous . set Selected ( BOOL ) ; } else { if ( a . starts With ( STRING ) ) { a = a . substring ( NUM ) ; String [ ] arr = a . split ( STRING ) ; action . set Selected Item ( arr [ NUM ] ) ; post Action . set Selected Item ( arr [ NUM ] ) ; } else { if ( a . starts With ( STRING ) ) { a = a . substring ( NUM ) ; } } } } action . set Selected Item ( a ) ; name . set Text ( cmd . get Command Name ( ) ) ; id . set Model ( new Spinner Number Model ( cmd . get Id ( ) , - NUM , Integer . MAX VALUE , NUM ) ) ; Resource Editor View . init Images Combo Box ( icon , res , BOOL , BOOL ) ; icon . set Selected Item ( cmd . get Icon ( ) ) ; Resource Editor View . init Images Combo Box ( rollover , res , BOOL , BOOL ) ; rollover . set Selected Item ( cmd . get Rollover Icon ( ) ) ; Resource Editor View . init Images Combo Box ( pressed , res , BOOL , BOOL ) ; pressed . set Selected Item ( cmd . get Pressed Icon ( ) ) ; Resource Editor View . init Images Combo Box ( disabled , res , BOOL , BOOL ) ; disabled . set Selected Item ( cmd . get Disabled Icon ( ) ) ; }
public Eg Demand Details insert Advance Collection ( final String demand Reason , final Big Decimal advance Collection Amount , final Installment installment ) { Eg Demand Details demand Detail = null ; if ( advance Collection Amount != null && advance Collection Amount . compare To ( Big Decimal . ZERO ) > NUM ) { final Eg Demand Reason Master eg Demand Reason Master = demand Generic DAO . get Demand Reason Master By Code ( demand Reason , module ( ) ) ; if ( eg Demand Reason Master == null ) throw new Application Runtime Exception ( STRING ) ; final Eg Demand Reason eg Demand Reason = demand Generic DAO . get Dmd Reason By Dmd Reason Mster Install And Mod ( eg Demand Reason Master , installment , module ( ) ) ; if ( eg Demand Reason == null ) throw new Application Runtime Exception ( STRING ) ; demand Detail = create Demand Details ( eg Demand Reason , advance Collection Amount , Big Decimal . ZERO ) ; } return demand Detail ; }
public void remove ( final int index ) { check Widget ( ) ; if ( index < NUM || index >= items . size ( ) ) { SWT . error ( SWT . ERROR INVALID ARGUMENT ) ; } items . remove ( index ) ; redraw Tables ( ) ; }
public static Symbol Variant symbol Variant ( Char Sequence symbol ) { int length = symbol . length ( ) ; if ( length == NUM ) { throw new Empty Symbol Exception ( ) ; } if ( is Identifier Keyword ( symbol ) ) { return Symbol Variant . QUOTED ; } char c = symbol . char At ( NUM ) ; if ( is Identifier Start ( c ) ) { for ( int ii = NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ( c == STRING || c < NUM || c > NUM ) || ! is Identifier Part ( c ) ) { return Symbol Variant . QUOTED ; } } return Symbol Variant . IDENTIFIER ; } if ( is Operator Part ( c ) ) { for ( int ii = NUM ; ii < length ; ii ++ ) { c = symbol . char At ( ii ) ; if ( ! is Operator Part ( c ) ) { return Symbol Variant . QUOTED ; } } return Symbol Variant . OPERATOR ; } return Symbol Variant . QUOTED ; }
public Workload File Reader ( final String file Name , final int rating ) throws File Not Found Exception { if ( file Name == null || file Name . length ( ) == NUM ) { throw new Illegal Argument Exception ( STRING ) ; } else if ( rating <= NUM ) { throw new Illegal Argument Exception ( STRING ) ; } file = new File ( file Name ) ; if ( ! file . exists ( ) ) { throw new File Not Found Exception ( STRING + file Name + STRING ) ; } this . rating = rating ; }
public static Document load Document ( Input Stream stream ) throws Exception { Document Builder Factory factory = Document Builder Factory . new Instance ( ) ; Document Builder builder = factory . new Document Builder ( ) ; return builder . parse ( stream ) ; }
public static Comment [ ] to Comment Array ( Document doc , Object o ) throws Page Exception { if ( o instanceof Node [ ] ) { Node [ ] nodes = ( Node [ ] ) o ; if ( is All Of Same Type ( nodes , Node . COMMENT NODE ) ) return ( Comment [ ] ) nodes ; Comment [ ] comments = new Comment [ nodes . length ] ; for ( int i = NUM ; i < nodes . length ; i ++ ) { comments [ i ] = to Comment ( doc , nodes [ i ] ) ; } return comments ; } else if ( o instanceof Collection ) { Collection coll = ( Collection ) o ; Iterator < Object > it = coll . value Iterator ( ) ; List < Comment > comments = new Array List < Comment > ( ) ; while ( it . has Next ( ) ) { comments . add ( to Comment ( doc , it . next ( ) ) ) ; } return comments . to Array ( new Comment [ comments . size ( ) ] ) ; } Node [ ] nodes = to Node Array ( doc , o ) ; if ( nodes != null ) return to Comment Array ( doc , nodes ) ; try { return new Comment [ ] { to Comment ( doc , o ) } ; } catch ( Expression Exception e ) { throw new XML Exception ( STRING + Caster . to Class Name ( o ) + STRING ) ; } }
@ Deprecated public Boolean is Hod ( final Long assign Id ) { final List < Head Of Departments > hod List = employee Department Repository . get All Hod Departments ( assign Id ) ; return ! hod List . is Empty ( ) ; }
public Munger limit Label Languages ( String ... languages ) { return limit Label Languages ( Arrays . as List ( languages ) ) ; }
Combo Value ( List value List ) { this ( ( Stat Value [ ] ) value List . to Array ( new Stat Value [ value List . size ( ) ] ) ) ; }
protected void graph Tree ( String Buffer text ) throws Exception { text . append ( STRING + m cluster Num + STRING + ( ( m children == null ) ? STRING : STRING ) + m cluster Num + STRING + STRING + m cluster Instances . num Instances ( ) + STRING + ( ( m children == null ) ? STRING : STRING ) + ( m save Instances ? STRING + dump Data ( ) + STRING : STRING ) + STRING ) ; if ( m children != null ) { for ( int i = NUM ; i < m children . size ( ) ; i ++ ) { C Node temp = m children . get ( i ) ; text . append ( STRING + m cluster Num + STRING + STRING + temp . m cluster Num + STRING ) ; } for ( int i = NUM ; i < m children . size ( ) ; i ++ ) { C Node temp = m children . get ( i ) ; temp . graph Tree ( text ) ; } } }
protected void bezier To ( float control 1 x , float control 1 y , float control 2 x , float control 2 y , float end X , float end Y ) { mPS Stream . println ( trunc ( control 1 x ) + STRING + trunc ( control 1 y ) + STRING + trunc ( control 2 x ) + STRING + trunc ( control 2 y ) + STRING + trunc ( end X ) + STRING + trunc ( end Y ) + CURVETO STR ) ; m Pen X = end X ; m Pen Y = end Y ; }
public Tv Show Episode Scrape Task ( List < Tv Show Episode > episodes , Media Scraper media Scraper , boolean scrape Thumb ) { super ( BUNDLE . get String ( STRING ) , episodes . size ( ) , Task Type . BACKGROUND TASK ) ; this . episodes = episodes ; this . media Scraper = media Scraper ; this . scrape Thumb = scrape Thumb ; }
public Model M Bean Info Support ( String class Name , String description , Model M Bean Attribute Info [ ] attributes , Model M Bean Constructor Info [ ] constructors , Model M Bean Operation Info [ ] operations , Model M Bean Notification Info [ ] notifications ) { this ( class Name , description , attributes , constructors , operations , notifications , null ) ; }
protected void execute Tasks ( final Access Path Task [ ] tasks ) throws Exception { if ( executor == null ) { for ( Access Path Task task : tasks ) { task . call ( ) ; } return ; } final List < Future Task < Void > > future Tasks = new Linked List < Future Task < Void > > ( ) ; for ( Access Path Task task : tasks ) { final Future Task < Void > ft = new Future Task < Void > ( task ) ; future Tasks . add ( ft ) ; } try { for ( Future Task < Void > ft : future Tasks ) { if ( halt ) throw new Runtime Exception ( first Cause . get ( ) ) ; executor . execute ( ft ) ; } for ( Future Task < Void > ft : future Tasks ) { if ( ! halt ) ft . get ( ) ; } } finally { for ( Future Task < Void > ft : future Tasks ) { ft . cancel ( BOOL ) ; } } }
public void rotate Way ( final Way way , final float angle , final int direction , final float pivot X , final float pivot Y , int w , int h , Bounding Box v ) { if ( way . get Nodes ( ) == null ) { Log . d ( STRING , STRING + way . get Osm Id ( ) + STRING ) ; return ; } dirty = BOOL ; try { Hash Set < Node > nodes = new Hash Set < Node > ( way . get Nodes ( ) ) ; for ( Node nd : nodes ) { undo . save ( nd ) ; api Storage . insert Element Safe ( nd ) ; float node X = Geo Math . lon E 7 To X ( w , v , nd . get Lon ( ) ) ; float node Y = Geo Math . lat E 7 To Y ( h , w , v , nd . get Lat ( ) ) ; float new X = pivot X + ( node X - pivot X ) * ( float ) Math . cos ( angle ) - direction * ( node Y - pivot Y ) * ( float ) Math . sin ( angle ) ; float new Y = pivot Y + direction * ( node X - pivot X ) * ( float ) Math . sin ( angle ) + ( node Y - pivot Y ) * ( float ) Math . cos ( angle ) ; int lat = Geo Math . y To Lat E 7 ( h , w , v , new Y ) ; int lon = Geo Math . x To Lon E 7 ( w , v , new X ) ; nd . set Lat ( lat ) ; nd . set Lon ( lon ) ; nd . update State ( Osm Element . STATE MODIFIED ) ; } record Imagery ( ) ; } catch ( Storage Exception e ) { e . print Stack Trace ( ) ; } }
public void send Exception ( final Exception exception , final Map < String , String > properties ) { final Property Map Builder builder = new Property Map Builder ( properties ) ; logger . debug ( String . format ( STRING , exception . get Message ( ) , builder . to String ( ) ) ) ; if ( telemetry Client != null ) { telemetry Client . track Exception ( exception , builder . build ( ) , null ) ; } }
public void handle Header Column Left Click ( Point p ) { J Table Header th = TABLE . get Table Header ( ) ; int col = th . column At Point ( p ) ; int c = TABLE . convert Column Index To Model ( col ) ; int old C = DATA MODEL . get Sort Column ( ) ; if ( c != - NUM ) { sort And Maintain Selection ( c ) ; th . repaint ( th . get Header Rect ( col ) ) ; if ( old C != - NUM && old C != c ) { int old Col = TABLE . convert Column Index To View ( old C ) ; th . repaint ( th . get Header Rect ( old Col ) ) ; } } }
Vcf Record [ ] merge Records ( Vcf Record [ ] records , Vcf Header [ ] headers , Vcf Header dest Header , Set < String > unmergeable Format Fields , boolean preserve Formats ) { assert records . length == headers . length ; final Multi Map < Integer , Vcf Record > record Sets = new Multi Map < > ( BOOL ) ; final Multi Map < Integer , Vcf Header > header Sets = new Multi Map < > ( BOOL ) ; for ( int i = NUM ; i < records . length ; i ++ ) { record Sets . put ( records [ i ] . get Length ( ) , records [ i ] ) ; header Sets . put ( records [ i ] . get Length ( ) , headers [ i ] ) ; } final Array List < Vcf Record > ret = new Array List < > ( ) ; for ( Integer key : record Sets . key Set ( ) ) { final Collection < Vcf Record > recs = record Sets . get ( key ) ; final Collection < Vcf Header > heads = header Sets . get ( key ) ; final Vcf Record [ ] recs Array = recs . to Array ( new Vcf Record [ recs . size ( ) ] ) ; final Vcf Header [ ] heads Array = heads . to Array ( new Vcf Header [ heads . size ( ) ] ) ; final Vcf Record merged = merge Records With Same Ref ( recs Array , heads Array , dest Header , unmergeable Format Fields , ! preserve Formats ) ; if ( merged != null ) { ret . add ( merged ) ; } else { final Vcf Record [ ] rec Holder = new Vcf Record [ NUM ] ; final Vcf Header [ ] head Holder = new Vcf Header [ NUM ] ; for ( int i = NUM ; i < recs Array . length ; i ++ ) { rec Holder [ NUM ] = recs Array [ i ] ; head Holder [ NUM ] = heads Array [ i ] ; ret . add ( merge Records With Same Ref ( rec Holder , head Holder , dest Header , unmergeable Format Fields , ! preserve Formats ) ) ; } } } return ret . to Array ( new Vcf Record [ ret . size ( ) ] ) ; }
public Tracked Entity Instance Query Params add Filters If Not Exist ( List < Query Item > filtrs ) { for ( Query Item filter : filtrs ) { if ( filters != null && ! filters . contains ( filter ) ) { filters . add ( filter ) ; } } return this ; }
public static void clean Dir ( File dir To Remove ) throws IO Exception { if ( dir To Remove . is File ( ) ) { File Misc . force Delete ( dir To Remove ) ; } else if ( dir To Remove . is Directory ( ) ) { try { File Utils . delete Directory ( dir To Remove ) ; } catch ( IO Exception e ) { for ( File file : File Misc . list ( dir To Remove ) ) { File Misc . force Delete ( file ) ; } } } mkdirs ( dir To Remove ) ; }
public static int hash ( Object object ) { return object == null ? NUM : object . hash Code ( ) ; }
public String documentation Admin Guide Url ( ) { return properties . get Property ( STRING ) ; }
public static double sum ( final List < ? extends Number > list ) { double sum = NUM ; for ( Number number : list ) { sum += number . double Value ( ) ; } return sum ; }
public String encrypt ( String raw ) { try { Message Digest local Message Digest = clone Message Digest ( ) ; byte [ ] digest = local Message Digest . digest ( raw . get Bytes ( STRING ) ) ; return new String ( Hex . encode Hex ( digest ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Encoding Exception ( STRING , e ) ; } }
@ Visible For Testing public void disable Browser Override For Test ( ) { m Disable Browser Override = BOOL ; m Persistent Control Tokens . clear ( ) ; m Handler . remove Messages ( MSG ID HIDE CONTROLS ) ; if ( m Control Animation != null ) { m Control Animation . cancel ( ) ; m Control Animation = null ; } m Browser Control Offset = Float . Na N ; update Visuals ( ) ; }
public static String htmlentities ( final String str ) { if ( str == null ) { return STRING ; } if ( htmlentities map . is Empty ( ) ) { initialize Entities Tables ( ) ; } final String Builder buf = new String Builder ( ) ; for ( int i = NUM ; i < str . length ( ) ; ++ i ) { final char ch = str . char At ( i ) ; final String entity = htmlentities map . get ( new Integer ( ch ) ) ; if ( entity == null ) { if ( ch > NUM ) { buf . append ( STRING + ( int ) ch + STRING ) ; } else { buf . append ( ch ) ; } } else { buf . append ( entity ) ; } } return buf . to String ( ) ; }
private void unlock ( ) { try { MP Instance mpi = new MP Instance ( get Ctx ( ) , m pi . get AD P Instance ID ( ) , null ) ; if ( mpi . get ID ( ) == NUM ) { log . log ( Level . SEVERE , STRING + m pi . get AD P Instance ID ( ) ) ; return ; } mpi . set Is Processing ( BOOL ) ; mpi . set Result ( ! m pi . is Error ( ) ) ; mpi . set Error Msg ( m pi . get Summary ( ) ) ; mpi . save Ex ( ) ; log . fine ( mpi . to String ( ) ) ; Process Info Util . save Log To DB ( m pi ) ; } catch ( Exception e ) { log . severe ( STRING + e . get Localized Message ( ) ) ; } }
private Map < URI , Storage System > build Array Map ( List < Volume Descriptor > descriptors , Volume Descriptor . Type type ) { Map < URI , Storage System > array Map = new Hash Map < URI , Storage System > ( ) ; if ( type != null ) { descriptors = Volume Descriptor . filter By Type ( descriptors , new Volume Descriptor . Type [ ] { type } , new Volume Descriptor . Type [ ] { } ) ; } for ( Volume Descriptor desc : descriptors ) { if ( array Map . contains Key ( desc . get Device URI ( ) ) == BOOL ) { Storage System array = get Data Object ( Storage System . class , desc . get Device URI ( ) , db Client ) ; array Map . put ( desc . get Device URI ( ) , array ) ; } } return array Map ; }
public byte [ ] decrypt ( byte [ ] bytes To Decode , Char Sequence password ) throws Key Crypter Exception { try { byte [ ] salt = new byte [ SALT LENGTH ] ; System . arraycopy ( bytes To Decode , NUM , salt , NUM , SALT LENGTH ) ; byte [ ] cipher Bytes = new byte [ bytes To Decode . length - SALT LENGTH ] ; System . arraycopy ( bytes To Decode , SALT LENGTH , cipher Bytes , NUM , bytes To Decode . length - SALT LENGTH ) ; Parameters With IV key = ( Parameters With IV ) get AES Password Key ( password , salt ) ; Buffered Block Cipher cipher = new Padded Buffered Block Cipher ( new CBC Block Cipher ( new AES Fast Engine ( ) ) ) ; cipher . init ( BOOL , key ) ; byte [ ] decrypted Bytes = new byte [ cipher . get Output Size ( cipher Bytes . length ) ] ; final int process Length = cipher . process Bytes ( cipher Bytes , NUM , cipher Bytes . length , decrypted Bytes , NUM ) ; final int do Final Length = cipher . do Final ( decrypted Bytes , process Length ) ; return Arrays . copy Of ( decrypted Bytes , process Length + do Final Length ) ; } catch ( Exception e ) { throw new Key Crypter Exception ( STRING , e ) ; } }
public final Array List < Wifi Record > load Wifis Overview Within ( final int session , final Double min Lon , final Double max Lon , final Double min Lat , final Double max Lat ) { final Array List < Wifi Record > wifis = new Array List < > ( ) ; String selection = null ; String [ ] selection Args = null ; if ( min Lon != null && max Lon != null && min Lat != null && max Lat != null ) { selection = STRING + Schema . COL LONGITUDE + STRING + STRING + Schema . COL LONGITUDE + STRING + STRING + Schema . COL LATITUDE + STRING + STRING + Schema . COL LATITUDE + STRING ; selection Args = new String [ ] { String . value Of ( min Lon ) , String . value Of ( max Lon ) , String . value Of ( min Lat ) , String . value Of ( max Lat ) } ; } final Cursor cursor = content Resolver . query ( Content Uris . with Appended Id ( Uri . with Appended Path ( Content Provider . CONTENT URI WIFI , Content Provider . CONTENT URI OVERVIEW SUFFIX ) , session ) , null , selection , selection Args , null ) ; final int column Index = cursor . get Column Index ( Schema . COL BSSID ) ; final int column Index 2 = cursor . get Column Index ( Schema . COL SSID ) ; final int column Index 3 = cursor . get Column Index ( Schema . COL CAPABILITIES ) ; final int column Index 4 = cursor . get Column Index ( Schema . COL FREQUENCY ) ; final int column Index 5 = cursor . get Column Index ( Schema . COL MAX LEVEL ) ; final int column Index 6 = cursor . get Column Index ( Schema . COL TIMESTAMP ) ; final int column Index 7 = cursor . get Column Index ( Schema . COL BEGIN POSITION ID ) ; final int column Index 8 = cursor . get Column Index ( Schema . COL END POSITION ID ) ; final int column Index 9 = cursor . get Column Index ( Schema . COL KNOWN WIFI ) ; while ( cursor . move To Next ( ) ) { final Wifi Record wifi = new Wifi Record ( ) ; wifi . set Bssid ( cursor . get String ( column Index ) ) ; wifi . set Ssid ( cursor . get String ( column Index 2 ) ) ; wifi . set Capabilities ( cursor . get String ( column Index 3 ) ) ; wifi . set Frequency ( cursor . get Int ( column Index 4 ) ) ; wifi . set Level ( cursor . get Int ( column Index 5 ) ) ; wifi . set Open Bmap Timestamp ( cursor . get Long ( column Index 6 ) ) ; wifi . set Begin Position ( load Position By Id ( cursor . get String ( column Index 7 ) ) ) ; wifi . set End Position ( load Position By Id ( cursor . get String ( column Index 8 ) ) ) ; wifi . set Catalog Status ( Catalog Status . values ( ) [ cursor . get Int ( column Index 9 ) ] ) ; wifis . add ( wifi ) ; } cursor . close ( ) ; return wifis ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return NOTE ID ; case NUM : return PARAGRAPH ID ; case NUM : return RESOURCE NAME ; default : return null ; } }
@ Override public void install ( J Editor Pane editor ) { super . install ( editor ) ; editor . add Key Listener ( this ) ; }
private void enable Stronger Defaults ( Socket socket ) { if ( is Secure ( socket ) ) { SSL Socket ssl Socket = ( SSL Socket ) socket ; read SSL Parameters ( ssl Socket ) ; if ( m Enable Stonger Default Protocal Version && m Protocols != null ) { ssl Socket . set Enabled Protocols ( m Protocols ) ; } if ( m Enable Stonger Default SSL Cipher Suite && m Cipher Suites != null ) { ssl Socket . set Enabled Cipher Suites ( m Cipher Suites ) ; } } }
public void add Sample ( int weight , float value ) { ensure Sorted By Index ( ) ; Sample new Sample = recycled Sample Count > NUM ? recycled Samples [ -- recycled Sample Count ] : new Sample ( ) ; new Sample . index = next Sample Index ++ ; new Sample . weight = weight ; new Sample . value = value ; samples . add ( new Sample ) ; total Weight += weight ; while ( total Weight > max Weight ) { int excess Weight = total Weight - max Weight ; Sample oldest Sample = samples . get ( NUM ) ; if ( oldest Sample . weight <= excess Weight ) { total Weight -= oldest Sample . weight ; samples . remove ( NUM ) ; if ( recycled Sample Count < MAX RECYCLED SAMPLES ) { recycled Samples [ recycled Sample Count ++ ] = oldest Sample ; } } else { oldest Sample . weight -= excess Weight ; total Weight -= excess Weight ; } } }
public URI create Tenant ( Keystone Tenant tenant ) { Tenant Org Rest Rep tenant Resp = internal Tenant Service Client . create Tenant ( keystone Utils Service . prepare Tenant Param ( tenant ) ) ; return tenant Resp . get Id ( ) ; }
static private void throw Failure ( ) throws Internal Gem Fire Error , Error { if ( failure != null ) throw failure ; }
@ Override public void draw Node ( Graphics g , int w , int h ) { if ( ( m type & PURE INPUT ) == PURE INPUT ) { g . set Color ( Color . green ) ; } else { g . set Color ( Color . orange ) ; } Font Metrics fm = g . get Font Metrics ( ) ; int l = ( int ) ( m x * w ) - fm . string Width ( m id ) / NUM ; int t = ( int ) ( m y * h ) - fm . get Height ( ) / NUM ; g . fill 3 D Rect ( l , t , fm . string Width ( m id ) + NUM , fm . get Height ( ) + fm . get Descent ( ) + NUM , BOOL ) ; g . set Color ( Color . black ) ; g . draw String ( m id , l + NUM , t + fm . get Height ( ) + NUM ) ; }
public static byte [ ] encode Gif ( Buffered Image image ) throws IO Exception { Byte Array Output Stream out = new Byte Array Output Stream ( ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + out ) ; } Acme . JPM . Encoders . Gif Encoder enc = new Acme . JPM . Encoders . Gif Encoder ( image , out ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING ) ; } enc . encode ( ) ; if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING ) ; } return out . to Byte Array ( ) ; }
public double empirical HSI Cincomplete Cholesky ( Tetrad Matrix Gy , Tetrad Matrix Gx , int m ) { int ky = Gy . columns ( ) ; int kx = Gx . columns ( ) ; Tetrad Matrix H = Kernel Utils . construct H ( m ) ; Tetrad Matrix Gcy = H . times ( Gy ) ; Tetrad Matrix Gcx = H . times ( Gx ) ; Tetrad Matrix Gcyt = Gcy . transpose ( ) ; Tetrad Matrix A = Gcyt . times ( Gcx ) ; Tetrad Matrix B = Gcy . times ( A ) ; Tetrad Matrix Gcxt = Gcx . transpose ( ) ; double emp HSIC = NUM ; for ( int i = NUM ; i < m ; i ++ ) { emp HSIC += matrix Product Entry ( B , Gcxt , i , i ) ; } emp HSIC /= Math . pow ( m - NUM , NUM ) ; return emp HSIC ; }
public static String parse ( String [ ] options , String option , String def Value ) throws Exception { String value = Utils . get Option ( option , options ) ; if ( value . is Empty ( ) ) return def Value ; else return value ; }
public boolean is Source Balanced ( ) { if ( m lines . size ( ) == NUM || m doc . is Multi Currency ( ) ) return BOOL ; Big Decimal balance = get Source Balance ( ) ; boolean ret Value = balance . signum ( ) == NUM ; if ( ret Value ) log . finer ( to String ( ) ) ; else log . warning ( STRING + balance + STRING + to String ( ) ) ; return ret Value ; }
private void ensure Capacity Helper ( int min Capacity ) { int old Capacity = element Data . length ; if ( min Capacity > old Capacity ) { Object [ ] old Data = element Data ; int new Capacity = ( capacity Increment > NUM ) ? ( old Capacity + capacity Increment ) : ( old Capacity * NUM ) ; if ( new Capacity < min Capacity ) { new Capacity = min Capacity ; } element Data = new Object [ new Capacity ] ; System . arraycopy ( old Data , NUM , element Data , NUM , element Count ) ; } }
private void methods ( Class type ) { Method [ ] list = type . get Declared Methods ( ) ; for ( Method method : list ) { Method Detail detail = new Method Detail ( method ) ; methods . add ( detail ) ; } }
public static byte [ ] compress ( byte [ ] data ) throws IO Exception { Deflater deflater = new Deflater ( NUM , Boolean . TRUE ) ; deflater . set Input ( data ) ; Byte Array Output Stream output Stream = new Byte Array Output Stream ( data . length ) ; deflater . finish ( ) ; byte [ ] buffer = new byte [ NUM ] ; while ( ! deflater . finished ( ) ) { int count = deflater . deflate ( buffer ) ; output Stream . write ( buffer , NUM , count ) ; } output Stream . close ( ) ; byte [ ] output = output Stream . to Byte Array ( ) ; deflater . end ( ) ; return output ; }
protected final void drag Exit ( final int x , final int y ) { Drag Source Event event = new Drag Source Event ( get Drag Source Context ( ) , x , y ) ; Event Dispatcher dispatcher = new Event Dispatcher ( DISPATCH EXIT , event ) ; Sun Toolkit . invoke Later On App Context ( Sun Toolkit . target To App Context ( get Component ( ) ) , dispatcher ) ; start Secondary Event Loop ( ) ; }
@ Override public Object create Statement ( Object proxy , Method method , Object [ ] args , Object statement , long time ) { try { String name = method . get Name ( ) ; Constructor < ? > constructor = null ; String sql = null ; if ( compare ( CREATE STATEMENT , name ) ) { constructor = get Constructor ( CREATE STATEMENT IDX , Statement . class ) ; } else if ( compare ( PREPARE STATEMENT , name ) ) { constructor = get Constructor ( PREPARE STATEMENT IDX , Prepared Statement . class ) ; sql = ( String ) args [ NUM ] ; } else if ( compare ( PREPARE CALL , name ) ) { constructor = get Constructor ( PREPARE CALL IDX , Callable Statement . class ) ; sql = ( String ) args [ NUM ] ; } else { return statement ; } return create Decorator ( proxy , method , args , statement , constructor , sql ) ; } catch ( Exception x ) { if ( x instanceof Invocation Target Exception ) { Throwable cause = x . get Cause ( ) ; if ( cause instanceof Thread Death ) { throw ( Thread Death ) cause ; } if ( cause instanceof Virtual Machine Error ) { throw ( Virtual Machine Error ) cause ; } } logger . warn ( STRING , x ) ; } return statement ; }
@ Deprecated public Concurrent Update Solr Client ( String solr Server Url , int queue Size , int thread Count ) { this ( solr Server Url , null , queue Size , thread Count ) ; shutdown Executor = BOOL ; internal Http Client = BOOL ; }
public void action Performed ( Action Event e ) { boolean ok ; int ret Val ; if ( ! check Modified ( ) ) return ; ret Val = m File Chooser . show Open Dialog ( File Scripting Panel . this ) ; if ( ret Val != J File Chooser . APPROVE OPTION ) return ; ok = m Script . open ( m File Chooser . get Selected File ( ) ) ; m Text Code . set Caret Position ( NUM ) ; if ( ! ok ) J Option Pane . show Message Dialog ( File Scripting Panel . this , STRING + m File Chooser . get Selected File ( ) + STRING ) ; notify Title Updated Listeners ( new Title Updated Event ( File Scripting Panel . this ) ) ; }
public Implicit Client register Implicit Client ( URI login Redirect URI , URI logout Redirect URI ) throws Auth Exception { try { OIDC Tokens tokens = token Handler . get Admin Server Access Token ( user , password ) ; OIDC Client DTO oidc Client DTO = register Client ( login Redirect URI , login Redirect URI , logout Redirect URI ) ; Client ID client ID = new Client ID ( oidc Client DTO . get Client Id ( ) ) ; URI login URI = build Authentication Request URI ( client ID , login Redirect URI ) ; URI logout URI = build Logout Request URI ( client ID , tokens . get Client ID Token ( ) , logout Redirect URI ) ; return new Implicit Client ( oidc Client DTO . get Client Id ( ) , login URI . to String ( ) , logout URI . to String ( ) ) ; } catch ( Exception e ) { throw new Auth Exception ( String . format ( STRING + STRING , login Redirect URI , logout Redirect URI ) , e ) ; } }
public void add Method Property ( String name , String accessor Method ) { method Properties . add ( new Legacy Method Prop Desc ( name , accessor Method ) ) ; }
private void parse Wild Cards ( ) { if ( f Pattern . starts With ( STRING ) ) f Has Leading Star = BOOL ; if ( f Pattern . ends With ( STRING ) ) { if ( f Length > NUM && f Pattern . char At ( f Length - NUM ) != STRING ) { f Has Trailing Star = BOOL ; } } Vector < String > temp = new Vector < String > ( ) ; int pos = NUM ; String Buffer buf = new String Buffer ( ) ; while ( pos < f Length ) { char c = f Pattern . char At ( pos ++ ) ; switch ( c ) { case STRING : if ( pos >= f Length ) { buf . append ( c ) ; } else { char next = f Pattern . char At ( pos ++ ) ; if ( next == STRING || next == STRING || next == STRING ) { buf . append ( next ) ; } else { buf . append ( c ) ; buf . append ( next ) ; } } break ; case STRING : if ( buf . length ( ) > NUM ) { temp . add Element ( buf . to String ( ) ) ; f Bound += buf . length ( ) ; buf . set Length ( NUM ) ; } break ; case STRING : buf . append ( f Single Wild Card ) ; break ; default : buf . append ( c ) ; } } if ( buf . length ( ) > NUM ) { temp . add Element ( buf . to String ( ) ) ; f Bound += buf . length ( ) ; } f Segments = new String [ temp . size ( ) ] ; temp . copy Into ( f Segments ) ; }
public static List < Byte Buffer > base 64 String To Byte Buffer ( String ... base 64 Encoded Keys ) { List < Byte Buffer > byte Buffers = new Array List < > ( base 64 Encoded Keys . length ) ; for ( String base 64 Encoded Key : base 64 Encoded Keys ) { byte Buffers . add ( base 64 String To Byte Buffer ( base 64 Encoded Key ) ) ; } return byte Buffers ; }
@ Override public void draw Series ( Canvas canvas , Paint paint , List < Float > points , XY Series Renderer series Renderer , float y Axis Value , int series Index , int start Index ) { int series Nr = m Dataset . get Series Count ( ) ; int length = points . size ( ) ; paint . set Color ( series Renderer . get Color ( ) ) ; paint . set Style ( Style . FILL ) ; float half Diff X = get Half Diff X ( points , length , series Nr ) ; for ( int i = NUM ; i < length ; i += NUM ) { float x = points . get ( i ) ; float y = points . get ( i + NUM ) ; draw Bar ( canvas , x , y Axis Value , x , y , half Diff X , series Nr , series Index , paint ) ; } paint . set Color ( series Renderer . get Color ( ) ) ; }
public boolean authenticate User ( String username , String password , String uri ) throws Data Access Exception { if ( null == username || null == password ) { return BOOL ; } User Info user = get User Info ( username ) ; if ( user == null ) { return BOOL ; } String hashed Salted Password = Utilities . get Salted Password ( username , uri , password ) ; return hashed Salted Password . equals ( user . get Hashed Password ( ) ) ; }
public static boolean is Byte Code Class Name ( String class Name ) { return ( ( class Name . starts With ( STRING ) || class Name . starts With ( STRING ) ) && class Name . ends With ( STRING ) && ( ( class Name . index Of ( STRING ) != - NUM || class Name . index Of ( STRING ) == - NUM ) ) ) ; }
@ Suppress Warnings ( STRING ) public void notify Changed Slot ( Loco Net Slot s ) { if ( s . get Slot ( ) != Ln Constants . FC SLOT ) { return ; } if ( ! correct Fast Clock && ! synchronize With Internal Clock && ! set Internal ) { return ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STRING + s ) ; } cur Days = s . get Fc Days ( ) ; cur Hours = s . get Fc Hours ( ) ; cur Minutes = s . get Fc Minutes ( ) ; int tem Rate = s . get Fc Rate ( ) ; if ( ( tem Rate != cur Rate ) && ! set Internal ) { set Rate ( cur Rate ) ; } else if ( ( tem Rate != cur Rate ) && set Internal ) { try { clock . user Set Rate ( tem Rate ) ; } catch ( jmri . Timebase Rate Exception e ) { if ( ! timebase Error Reported ) { timebase Error Reported = BOOL ; log . warn ( STRING ) ; } } } cur Fractional Minutes = s . get Fc Frac Mins ( ) ; Date tem = clock . get Time ( ) ; int c Hours = tem . get Hours ( ) ; long c Num M Sec = tem . get Time ( ) ; long n Num M Sec = ( ( c Num M Sec / MSECPERHOUR ) * MSECPERHOUR ) - ( c Hours * MSECPERHOUR ) + ( cur Hours * MSECPERHOUR ) + ( cur Minutes * MSECPERMINUTE ) ; if ( read In Progress && ! in Sync With Internal Fast Clock ) { n Num M Sec += ( long ) ( ( ( CORRECTION - cur Fractional Minutes ) / CORRECTION * MSECPERMINUTE ) ) ; clock . set Time ( new Date ( n Num M Sec ) ) ; } else if ( set Internal ) { clock . set Time ( new Date ( n Num M Sec ) ) ; } in Sync With Internal Fast Clock = BOOL ; }
private boolean is Job Scheduling Needed ( URI id , String type , boolean in Progress , boolean is Error , boolean scheduler , long last Time , long next Time ) { long system Time = System . current Time Millis ( ) ; long tolerance = Long . parse Long ( config Info . get ( TOLERANCE ) ) * NUM ; logger . info ( STRING , next Time , last Time ) ; long refresh Interval = get Refresh Interval ( type ) ; if ( ! in Progress ) { if ( scheduler ) { if ( system Time < next Time - tolerance ) { logger . info ( STRING , id + STRING + type , new Date ( next Time ) ) ; logger . info ( STRING , new Date ( system Time ) , tolerance ) ; return BOOL ; } } if ( ! scheduler && is Error && last Time > NUM ) { logger . info ( STRING , type , id ) ; return BOOL ; } if ( system Time - last Time < refresh Interval * NUM ) { logger . info ( STRING , id , type ) ; return BOOL ; } } else if ( ! scheduler && ( system Time - last Time > refresh Interval * NUM ) && last Time > NUM ) { logger . info ( STRING , type , id ) ; } else if ( scheduler && ( system Time - last Time > refresh Interval * NUM ) && next Time > NUM && System . current Time Millis ( ) - next Time >= Job Intervals . get Max Idle Interval ( ) * NUM ) { logger . info ( STRING , type , id ) ; } else { logger . info ( STRING , type , id ) ; return BOOL ; } return BOOL ; }
private void add Breakpoints ( final Set < Breakpoint Address > addresses , final Breakpoint Status status , final Breakpoint Storage storage , final Breakpoint Type type ) { Preconditions . check Not Null ( addresses , STRING ) ; Preconditions . check Not Null ( status , STRING ) ; Preconditions . check Not Null ( storage , STRING ) ; Preconditions . check Not Null ( type , STRING ) ; if ( addresses . size ( ) == NUM ) { return ; } final List < Breakpoint > breakpoints = new Array List < > ( ) ; for ( final Breakpoint Address address : addresses ) { final Breakpoint breakpoint = new Breakpoint ( type , address ) ; storage . add ( breakpoint , status ) ; breakpoints . add ( breakpoint ) ; } for ( final Breakpoint Manager Listener listener : listeners ) { try { listener . breakpoints Added ( breakpoints ) ; } catch ( final Exception e ) { C Utility Functions . log Exception ( e ) ; } } }
public void replace Creation Template ( Creation Template template , Guid org Guid ) throws UMS Exception { if ( template == null ) { return ; } String template Name = template . get Name ( ) ; if ( template Name == null ) { String msg = i18 n . get String ( IUMS Constants . MISSING TEMPL NAME ) ; throw new Illegal Argument Exception ( msg ) ; } Attr Set attr Set = to Attr Set ( template ) ; try { m config Manager . replace Creation Template ( org Guid , template Name , attr Set ) ; } catch ( Config Manager Exception e ) { throw new UMS Exception ( e . get Message ( ) ) ; } }
private static Entry [ ] unmarshal Attributes ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { Array List attributes = new Array List ( ) ; Marshalled Instance mi = null ; while ( ( mi = ( Marshalled Instance ) in . read Object ( ) ) != null ) { try { attributes . add ( ( Entry ) mi . get ( BOOL ) ) ; } catch ( Throwable e ) { if ( e instanceof Error && Throwable Constants . retryable ( e ) == Throwable Constants . BAD OBJECT ) { throw ( Error ) e ; } logger . log ( Level . WARNING , STRING , e ) ; } } Entry [ ] attrs = new Entry [ attributes . size ( ) ] ; return ( Entry [ ] ) attributes . to Array ( attrs ) ; }
public Sc Physical Server create Server ( String ssn , String host Name , boolean is Iscsi , String os Id ) throws Storage Center API Exception { Parameters params = new Parameters ( ) ; params . add ( STRING , host Name ) ; params . add ( STRING , ssn ) ; params . add ( STRING , NOTES STRING ) ; params . add ( STRING , os Id ) ; Rest Result rr = rest Client . post ( STRING , params . to Json ( ) ) ; if ( ! check Results ( rr ) ) { String error = String . format ( STRING , host Name , rr . get Error Msg ( ) ) ; throw new Storage Center API Exception ( error ) ; } return gson . from Json ( rr . get Result ( ) , Sc Physical Server . class ) ; }
public void test Completed Stage ( ) { Atomic Integer x = new Atomic Integer ( NUM ) ; Atomic Reference < Throwable > r = new Atomic Reference < Throwable > ( ) ; Completion Stage < Integer > f = Completable Future . completed Stage ( NUM ) ; f . when Complete ( null ) ; assert Equals ( x . get ( ) , NUM ) ; assert Null ( r . get ( ) ) ; }
private void write Directory Post Resource ( String Builder sb , String path ) { sb . append ( STRING + DIR RESOURCE SET + STRING ) ; sb . append ( path . replace ( STRING , STRING ) ) ; }
private Potion Data data From String ( String string ) { Potion Type type ; boolean extended = BOOL , upgraded = BOOL ; if ( string . starts With ( STRING ) ) string = string . replace ( STRING , STRING ) ; if ( string . starts With ( STRING ) ) { string = string . replace ( STRING , STRING ) ; extended = BOOL ; } else if ( string . starts With ( STRING ) ) { string = string . replace ( STRING , STRING ) ; upgraded = BOOL ; } type = Potion Type Table . from Name ( string ) ; return new Potion Data ( type , extended , upgraded ) ; }
public synchronized void add Curl Mesh ( Curl Mesh mesh ) { remove Curl Mesh ( mesh ) ; m Curl Meshes . add ( mesh ) ; }
private void update Pseudo References ( int epoch ) { if ( nbest List Writer != null ) { nbest List Writer . close ( ) ; Evaluation Metric < I String , String > metric = new BLEU Metric < I String , String > ( references ) ; Multi Translation Metric Max < I String , String > search Algorithm = new Hill Climbing Multi Translation Metric Max < I String , String > ( metric ) ; N Best List Container < I String , String > nbest Lists = null ; try { nbest Lists = new Flat N Best List ( nbest Filename , references . size ( ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; logger . error ( STRING , nbest Filename ) ; throw new Runtime Exception ( STRING + nbest Filename ) ; } List < Scored Featurized Translation < I String , String > > max Featurized Translations = search Algorithm . maximize ( nbest Lists ) ; assert max Featurized Translations . size ( ) == tune Source . size ( ) : STRING ; int num Translations = max Featurized Translations . size ( ) ; for ( int i = NUM ; i < num Translations ; ++ i ) { Sequence < I String > translation = max Featurized Translations . get ( i ) . translation ; if ( pseudo References . get ( i ) . size ( ) >= num Pseudo References ) pseudo References . get ( i ) . remove ( NUM ) ; pseudo References . get ( i ) . add ( translation ) ; } logger . info ( STRING , pseudo References . get ( NUM ) . size ( ) ) ; File file = new File ( nbest Filename ) ; file . delete ( ) ; reference Weights = new double [ num References + pseudo References . get ( NUM ) . size ( ) ] ; Arrays . fill ( reference Weights , NUM ) ; } if ( epoch >= pseudo Reference Burn In ) { nbest Filename = String . format ( STRING , temp Directory , epoch ) ; logger . info ( STRING , nbest Filename ) ; nbest List Writer = IO Tools . get Writer From File ( nbest Filename ) ; } }
public boolean is Closed ( ) throws SQL Exception { return this . is Closed ; }
public void insert Sleep Time ( ) { Script Step sleep Time Script Step = Script Step Factory . create Sleep Time ( get Sleep Time ( ) ) ; steps . add ( get Insert Index ( ) , sleep Time Script Step ) ; sleep Time = STRING ; reindex Script Steps ( ) ; }
private static void step In Code Node ( final I Navi Code Node node , final Unrelocated Address address , final Set < Breakpoint Address > instructions ) { final int instruction Index = C Code Node Helpers . get Instruction ( node , address . get Address ( ) ) ; if ( instruction Index != - NUM ) { if ( instruction Index < node . instruction Count ( ) - NUM ) { final I Navi Instruction instruction = Iterables . get ( node . get Instructions ( ) , instruction Index + NUM ) ; instructions . add ( new Breakpoint Address ( instruction . get Module ( ) , new Unrelocated Address ( instruction . get Address ( ) ) ) ) ; } else { instructions . add All ( C Stepping Helper . get Successors ( node ) ) ; } } }
public synchronized void ensure Capacity ( int minimum Capacity ) { if ( element Data . length < minimum Capacity ) { int next = ( capacity Increment <= NUM ? element Data . length : capacity Increment ) + element Data . length ; grow ( minimum Capacity > next ? minimum Capacity : next ) ; } }
private < T > T read Object ( Json Node source , Class < T > clazz , boolean handle Relationships ) throws IO Exception , Illegal Access Exception , Instantiation Exception { String identifier = create Identifier ( source ) ; T result = ( T ) resource Cache . get ( identifier ) ; if ( result == null ) { Class < ? > type = get Actual Type ( source , clazz ) ; if ( source . has ( ATTRIBUTES ) ) { result = ( T ) object Mapper . tree To Value ( source . get ( ATTRIBUTES ) , type ) ; } else { if ( type . is Interface ( ) ) { result = null ; } else { result = ( T ) object Mapper . tree To Value ( object Mapper . create Object Node ( ) , type ) ; } } if ( source . has ( META ) ) { Field field = configuration . get Meta Field ( type ) ; if ( field != null ) { Class < ? > meta Type = configuration . get Meta Type ( type ) ; Object meta Object = object Mapper . tree To Value ( source . get ( META ) , meta Type ) ; field . set ( result , meta Object ) ; } } if ( source . has ( LINKS ) ) { Field link Field = configuration . get Links Field ( type ) ; if ( link Field != null ) { link Field . set ( result , new Links ( map Links ( source . get ( LINKS ) ) ) ) ; } } if ( result != null ) { resource Cache . cache ( identifier , result ) ; set Id Value ( result , source . get ( ID ) ) ; if ( handle Relationships ) { handle Relationships ( source , result ) ; } } } return result ; }
public void remove Actions For ( int entity Id ) { Vector < Entity Action > to Keep = new Vector < Entity Action > ( actions . size ( ) ) ; for ( Entity Action ea : actions ) { if ( ea . get Entity Id ( ) != entity Id ) { to Keep . add Element ( ea ) ; } } actions = to Keep ; }
private int remove Expired Checkpoints ( Connection conn ) throws SQL Exception { int del Cnt = NUM ; Prepared Statement sel St = null ; Prepared Statement del St = null ; Result Set rs = null ; Time time = new Time ( U . current Time Millis ( ) ) ; Checkpoint Listener tmp = lsnr ; try { if ( tmp != null ) { sel St = conn . prepare Statement ( sel Exp Sql ) ; sel St . set Time ( NUM , time ) ; rs = sel St . execute Query ( ) ; while ( rs . next ( ) ) tmp . on Checkpoint Removed ( rs . get String ( NUM ) ) ; } del St = conn . prepare Statement ( del Exp Sql ) ; del St . set Time ( NUM , time ) ; del Cnt = del St . execute Update ( ) ; } finally { U . close ( rs , log ) ; U . close ( sel St , log ) ; U . close ( del St , log ) ; } if ( log . is Debug Enabled ( ) ) log . debug ( STRING + tbl Name ) ; return del Cnt ; }
public OM Scaling Icon ( double center Lat , double center Lon , Image Icon ii ) { this ( center Lat , center Lon , ii . get Image ( ) ) ; }
@ Override protected Void do In Background ( Void ... voids ) { Https URL Connection con = null ; Input Stream input Stream = null ; File Output Stream output Stream = null ; try { con = Net Cipher . get Https URL Connection ( file URL ) ; int response Code = con . get Response Code ( ) ; if ( response Code == Http URL Connection . HTTP OK ) { file Size = con . get Content Length ( ) ; input Stream = new Buffered Input Stream ( con . get Input Stream ( ) ) ; output Stream = new File Output Stream ( save File Path ) ; int buffer Size = NUM ; int downloaded = NUM ; int bytes Read = - NUM ; byte [ ] buffer = new byte [ buffer Size ] ; while ( ( bytes Read = input Stream . read ( buffer ) ) != - NUM ) { output Stream . write ( buffer , NUM , bytes Read ) ; downloaded += bytes Read ; if ( downloaded % NUM < buffer Size ) { publish Progress ( downloaded ) ; } } publish Progress ( buffer Size ) ; } else { Log . i ( TAG , STRING + response Code ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STRING , e ) ; e . print Stack Trace ( ) ; } finally { try { if ( output Stream != null ) { output Stream . close ( ) ; } if ( input Stream != null ) { input Stream . close ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } if ( con != null ) { con . disconnect ( ) ; } } return null ; }
protected void write Call ( String method Name , Object [ ] args ) throws Exception { huc = u . open Connection ( ) ; huc . set Do Output ( BOOL ) ; huc . set Do Input ( BOOL ) ; huc . set Use Caches ( BOOL ) ; huc . set Request Property ( STRING , STRING ) ; huc . set Read Timeout ( NUM ) ; Output Stream os = huc . get Output Stream ( ) ; Linked List temp = new Linked List ( ) ; temp . add ( method Name ) ; for ( Object o : args ) temp . add ( o ) ; packer . write ( os , temp ) ; os . close ( ) ; }
protected String parse Long String ( int closing Character ) throws IO Exception , RDF Parse Exception { String Builder sb = get Builder ( ) ; int double Quote Count = NUM ; int c ; while ( double Quote Count < NUM ) { c = read Code Point ( ) ; if ( c == - NUM ) { throw EOF Exception ( ) ; } else if ( c == closing Character ) { double Quote Count ++ ; } else { double Quote Count = NUM ; } append Codepoint ( sb , c ) ; if ( c == STRING ) { c = read Code Point ( ) ; if ( c == - NUM ) { throw EOF Exception ( ) ; } append Codepoint ( sb , c ) ; } } return sb . substring ( NUM , sb . length ( ) - NUM ) ; }
private void code Wrap Argument ( Class < ? > type , int slot , Data Output Stream out ) throws IO Exception { if ( type . is Primitive ( ) ) { Primitive Type Info prim = Primitive Type Info . get ( type ) ; if ( type == int . class || type == boolean . class || type == byte . class || type == char . class || type == short . class ) { code iload ( slot , out ) ; } else if ( type == long . class ) { code lload ( slot , out ) ; } else if ( type == float . class ) { code fload ( slot , out ) ; } else if ( type == double . class ) { code dload ( slot , out ) ; } else { throw new Assertion Error ( ) ; } out . write Byte ( opc invokestatic ) ; out . write Short ( cp . get Method Ref ( prim . wrapper Class Name , STRING , prim . wrapper Value Of Desc ) ) ; } else { code aload ( slot , out ) ; } }
public static Rectangle 2 D calc Aligned String Bounds ( String text , Graphics 2 D g2 , float x , float y , Text Anchor anchor ) { Rectangle 2 D text Bounds = new Rectangle 2 D . Double ( ) ; float [ ] adjust = derive Text Bounds Anchor Offsets ( g2 , text , anchor , text Bounds ) ; text Bounds . set Rect ( x + adjust [ NUM ] , y + adjust [ NUM ] + adjust [ NUM ] , text Bounds . get Width ( ) , text Bounds . get Height ( ) ) ; return text Bounds ; }
public static String clear Event ( Http Servlet Request request , Http Servlet Response response ) { String err Msg = STRING ; Locale locale = Util Http . get Locale ( request ) ; Security security = ( Security ) request . get Attribute ( STRING ) ; if ( ! security . has Permission ( STRING , request . get Session ( ) ) ) { err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; return STRING ; } String name = request . get Parameter ( STRING ) ; if ( name == null ) { err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; return STRING ; } Util Cache < ? , ? > util Cache = Util Cache . find Cache ( name ) ; if ( util Cache != null ) { util Cache . clear ( ) ; err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , Util Misc . to Map ( STRING , name ) , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; } else { err Msg = Util Properties . get Message ( Util Cache Events . err resource , STRING , Util Misc . to Map ( STRING , name ) , locale ) + STRING ; request . set Attribute ( STRING , err Msg ) ; return STRING ; } return STRING ; }
public Object parse XML Object ( XML Object xo ) throws XML Parse Exception { Pattern List pattern List = ( Pattern List ) xo . get Child ( NUM ) ; Patterns patterns = new Patterns ( pattern List ) ; for ( int i = NUM ; i < xo . get Child Count ( ) ; i ++ ) { patterns . add Patterns ( ( Pattern List ) xo . get Child ( i ) ) ; } if ( xo . has Attribute ( XML Parser . ID ) ) { final Logger logger = Logger . get Logger ( STRING ) ; logger . info ( STRING + xo . get Id ( ) + STRING + xo . get Child Count ( ) + STRING ) ; logger . info ( STRING + patterns . get Pattern Count ( ) ) ; } return patterns ; }
public static String [ ] ls Files Recursive ( String directory , Filename Filter filter ) throws IO Exception { File dir = new File ( directory ) ; Array List < String > files = new Array List < > ( ) ; for ( File filepath : dir . list Files ( filter ) ) { if ( is File ( filepath . get Absolute Path ( ) ) ) files . add ( filepath . get Absolute Path ( ) ) ; else if ( is Directory ( filepath . get Absolute Path ( ) ) ) files . add All ( Arrays . as List ( ls Files Recursive ( filepath . get Absolute Path ( ) , filter ) ) ) ; } return files . to Array ( new String [ files . size ( ) ] ) ; }
private static int parse Int ( String value , int begin Index , int end Index ) throws Number Format Exception { if ( begin Index < NUM || end Index > value . length ( ) || begin Index > end Index ) { throw new Number Format Exception ( value ) ; } int i = begin Index ; int result = NUM ; int digit ; if ( i < end Index ) { digit = Character . digit ( value . char At ( i ++ ) , NUM ) ; if ( digit < NUM ) { throw new Number Format Exception ( STRING + value ) ; } result = - digit ; } while ( i < end Index ) { digit = Character . digit ( value . char At ( i ++ ) , NUM ) ; if ( digit < NUM ) { throw new Number Format Exception ( STRING + value ) ; } result *= NUM ; result -= digit ; } return - result ; }
protected void merge Children Impl ( mx I Cell from , mx I Cell to , boolean clone All Edges , Hashtable < Object , Object > mapping ) throws Clone Not Supported Exception { begin Update ( ) ; try { int child Count = from . get Child Count ( ) ; for ( int i = NUM ; i < child Count ; i ++ ) { Object child = from . get Child At ( i ) ; if ( child instanceof mx I Cell ) { mx I Cell cell = ( mx I Cell ) child ; String id = cell . get Id ( ) ; mx I Cell target = ( mx I Cell ) ( ( id != null && ( ! is Edge ( cell ) || ! clone All Edges ) ) ? get Cell ( id ) : null ) ; if ( target == null ) { mx Cell clone = ( mx Cell ) cell . clone ( ) ; clone . set Id ( id ) ; target = ( mx I Cell ) to . insert ( clone ) ; cell Added ( target ) ; } mapping . put ( cell , target ) ; merge Children Impl ( cell , target , clone All Edges , mapping ) ; } } } finally { end Update ( ) ; } }
public void add Foreign Key ( int idx , Foreign Key foreign Key ) { if ( foreign Key != null ) { foreign Keys . add ( idx , foreign Key ) ; } }
public java . lang . String Buffer insert ( int offset , java . lang . Object obj ) { internal . insert ( offset , obj ) ; return this ; }
public void add Gefaehrdungs Baum Child ( I Gefaehrdungs Baum Element new Child ) { if ( new Child instanceof Cn A Tree Element ) { add Child ( ( Cn A Tree Element ) new Child ) ; } }
@ Override public Path Impl scheme Walk ( String user Path , Map < String , Object > attributes , String file Path , int offset ) { int length = file Path . length ( ) ; if ( length <= offset || file Path . char At ( offset ) != STRING ) return super . scheme Walk ( user Path , attributes , file Path , offset ) ; Merge Path merge Path = create Merge Path ( ) ; merge Path . set User Path ( user Path ) ; int head = ++ offset ; int tail = head ; while ( tail < length ) { int ch = file Path . char At ( tail ) ; if ( ch == STRING ) { if ( head + NUM != tail ) { String sub Path = file Path . substring ( head , tail ) ; if ( sub Path . starts With ( STRING ) && sub Path . ends With ( STRING ) ) sub Path = sub Path . substring ( NUM , sub Path . length ( ) - NUM ) ; merge Path . add Merge Path ( Vfs Old . lookup ( sub Path ) ) ; } if ( tail + NUM == length ) return merge Path ; else return merge Path . fs Walk ( user Path , attributes , file Path . substring ( tail + NUM ) ) ; } else if ( ch == STRING ) { String sub Path = file Path . substring ( head , tail ) ; if ( sub Path . starts With ( STRING ) && sub Path . ends With ( STRING ) ) sub Path = sub Path . substring ( NUM , sub Path . length ( ) - NUM ) ; merge Path . add Merge Path ( Vfs Old . lookup ( sub Path ) ) ; head = ++ tail ; } else if ( ch == STRING ) { int depth = NUM ; for ( tail ++ ; tail < length ; tail ++ ) { if ( file Path . char At ( tail ) == STRING ) depth ++ ; else if ( file Path . char At ( tail ) == STRING ) { tail ++ ; depth -- ; if ( depth == NUM ) break ; } } if ( depth != NUM ) return new Not Found Path ( get Scheme Map ( ) , file Path ) ; } else tail ++ ; } return new Not Found Path ( get Scheme Map ( ) , file Path ) ; }
public static long round ( double x ) { final long bits = Double . double To Raw Long Bits ( x ) ; final int biased Exp = ( ( int ) ( bits > > NUM ) ) & NUM ; final int shift = ( NUM - NUM + Double . MAX EXPONENT ) - biased Exp ; if ( ( shift & - NUM ) == NUM ) { long extended Mantissa = NUM | ( bits & NUM ) ; if ( bits < NUM ) { extended Mantissa = - extended Mantissa ; } return ( ( extended Mantissa > > shift ) + NUM ) > > NUM ; } else { return ( long ) x ; } }
protected Node binary Numeric Promotion ( Node node , Type Mirror expr Type ) { node = unbox ( node ) ; if ( ! types . is Same Type ( node . get Type ( ) , expr Type ) ) { Node widened = new Widening Conversion Node ( node . get Tree ( ) , node , expr Type ) ; add To Converted Lookup Map ( widened ) ; insert Node After ( widened , node ) ; return widened ; } else { return node ; } }
public Vm Identifier ( String uri String ) throws URI Syntax Exception { URI u ; try { u = canonicalize ( uri String ) ; } catch ( URI Syntax Exception e ) { if ( uri String . starts With ( STRING ) ) { throw e ; } u = canonicalize ( STRING + uri String ) ; } uri = u ; validate ( ) ; }
@ Override public void write Expression ( Expression old Exp ) { if ( null == old Exp ) { throw new Null Pointer Exception ( ) ; } boolean old Writing Object = writing Object ; writing Object = BOOL ; Object old Value = expression Value ( old Exp ) ; if ( old Value == null || get ( old Value ) != null && ( old Writing Object || old Value . get Class ( ) != String . class ) ) { return ; } if ( ! is Basic Type ( old Value ) || ( ! old Writing Object && old Value . get Class ( ) == String . class ) ) { record Expression ( old Value , old Exp ) ; } if ( check Dead Loop ( old Value ) ) { return ; } super . write Expression ( old Exp ) ; writing Object = old Writing Object ; }
final private long physical Address ( final int addr , final boolean nocheck ) { final Lock lock = m allocation Read Lock ; lock . lock ( ) ; try { if ( addr >= NUM ) { return addr & NUM ; } else { final Fixed Allocator allocator = get Block ( addr ) ; final int offset = get Offset ( addr ) ; final long laddr = allocator . get Physical Address ( offset , nocheck ) ; return laddr ; } } finally { lock . unlock ( ) ; } }
public void internal Entity Decl ( String name , XML String text , XML String non Normalized Text , Augmentations augs ) throws XNI Exception { try { if ( f Decl Handler != null ) { f Decl Handler . internal Entity Decl ( name , text . to String ( ) ) ; } } catch ( SAX Exception e ) { throw new XNI Exception ( e ) ; } }
private Having Operation extract Operation ( Matcher query ) throws Bad Having Exception { String operation Name = query . group ( NUM ) ; try { return Having Operation . from String ( operation Name ) ; } catch ( Illegal Argument Exception ignored ) { LOG . debug ( HAVING OPERATOR INVALID . log Format ( operation Name ) ) ; throw new Bad Having Exception ( HAVING OPERATOR INVALID . format ( operation Name ) ) ; } }
public String next Token ( ) throws No Such Element Exception { if ( pos < len && delim . index Of ( str . char At ( pos ) ) >= NUM ) { if ( ret Delims ) return str . substring ( pos , ++ pos ) ; while ( ++ pos < len && delim . index Of ( str . char At ( pos ) ) >= NUM ) ; } if ( pos < len ) { int start = pos ; while ( ++ pos < len && delim . index Of ( str . char At ( pos ) ) < NUM ) ; return str . substring ( start , pos ) ; } throw new No Such Element Exception ( ) ; }
public Permission Request Object ask ( int req Code ) { m Request Code = req Code ; int length = m Permission Names . length ; m Permissions We Dont Have = new Array List < > ( length ) ; for ( String m Permission Name : m Permission Names ) { m Permissions We Dont Have . add ( new Single Permission ( m Permission Name ) ) ; } if ( need To Ask ( ) ) { Log . i ( TAG , STRING ) ; if ( m Activity != null ) { Activity Compat . request Permissions ( m Activity , m Permission Names , req Code ) ; } else { m Fragment . request Permissions ( m Permission Names , req Code ) ; } } else { Log . i ( TAG , STRING ) ; if ( m Grant Func != null ) { m Grant Func . call ( ) ; } } return this ; }
protected static List < String > parse Roles ( String roles As String ) { List < String > roles = new Array List < String > ( ) ; String Tokenizer role Tokens = new String Tokenizer ( roles As String , STRING ) ; while ( role Tokens . has More Tokens ( ) ) { String role Token = role Tokens . next Token ( ) ; roles . add ( role Token ) ; } return roles ; }
public static int roll 1 D 20 ( ) { return rand . next Int ( NUM ) + NUM ; }
public static byte [ ] string To Gsm 7 Bit Packed ( String data , int starting Septet Offset , boolean throw Exception , int language Table , int language Shift Table ) throws Encode Exception { int data Len = data . length ( ) ; int septet Count = count Gsm Septets Using Tables ( data , ! throw Exception , language Table , language Shift Table ) ; if ( septet Count == - NUM ) { throw new Encode Exception ( STRING ) ; } septet Count += starting Septet Offset ; if ( septet Count > NUM ) { throw new Encode Exception ( STRING ) ; } int byte Count = ( ( septet Count * NUM ) + NUM ) / NUM ; byte [ ] ret = new byte [ byte Count + NUM ] ; Sparse Int Array char To Language Table = s Chars To Gsm Tables [ language Table ] ; Sparse Int Array char To Shift Table = s Chars To Shift Tables [ language Shift Table ] ; for ( int i = NUM , septets = starting Septet Offset , bit Offset = starting Septet Offset * NUM ; i < data Len && septets < septet Count ; i ++ , bit Offset += NUM ) { char c = data . char At ( i ) ; int v = char To Language Table . get ( c , - NUM ) ; if ( v == - NUM ) { v = char To Shift Table . get ( c , - NUM ) ; if ( v == - NUM ) { if ( throw Exception ) { throw new Encode Exception ( STRING ) ; } else { v = char To Language Table . get ( STRING , STRING ) ; } } else { pack Sms Char ( ret , bit Offset , GSM EXTENDED ESCAPE ) ; bit Offset += NUM ; septets ++ ; } } pack Sms Char ( ret , bit Offset , v ) ; septets ++ ; } ret [ NUM ] = ( byte ) ( septet Count ) ; return ret ; }
private J Panel create Project Tree Panel ( ) { final J Panel project Tree Panel = new J Panel ( new Border Layout ( ) ) ; project Tree Panel . set Border ( null ) ; project Tree Panel . set Background ( Color . WHITE ) ; m project Tree . set Border ( new Empty Border ( NUM , NUM , NUM , NUM ) ) ; m project Tree . add Tree Selection Listener ( new Internal Tree Selection Listener ( ) ) ; final J Scroll Pane pane = new J Scroll Pane ( m project Tree ) ; pane . set Vertical Scroll Bar Policy ( Scroll Pane Constants . VERTICAL SCROLLBAR AS NEEDED ) ; pane . set Horizontal Scroll Bar Policy ( Scroll Pane Constants . HORIZONTAL SCROLLBAR AS NEEDED ) ; pane . set Border ( null ) ; project Tree Panel . add ( pane , Border Layout . CENTER ) ; return project Tree Panel ; }
public static boolean move To Marker ( Input Stream is , int marker To Find ) throws IO Exception { Preconditions . check Not Null ( is ) ; while ( Stream Processor . read Packed Int ( is , NUM , BOOL ) == MARKER FIRST BYTE ) { int marker = MARKER FIRST BYTE ; while ( marker == MARKER FIRST BYTE ) { marker = Stream Processor . read Packed Int ( is , NUM , BOOL ) ; } if ( marker To Find == MARKER SO Fn && is SO Fn ( marker ) ) { return BOOL ; } if ( marker == marker To Find ) { return BOOL ; } if ( marker == MARKER SOI || marker == MARKER TEM ) { continue ; } if ( marker == MARKER EOI || marker == MARKER SOS ) { return BOOL ; } int length = Stream Processor . read Packed Int ( is , NUM , BOOL ) - NUM ; is . skip ( length ) ; } return BOOL ; }
public < K , V > void produce ( String producer Name , int message Count , Serializer < K > key Serializer , Serializer < V > value Serializer , Runnable completion Callback , Supplier < Producer Record < K , V > > message Supplier ) { Properties props = get Producer Properties ( producer Name ) ; Thread t = new Thread ( null ) ; t . set Name ( producer Name + STRING ) ; t . start ( ) ; }
@ Override public double distance ( Instance first , Instance second , Performance Stats stats ) { return Math . pow ( distance ( first , second , Double . POSITIVE INFINITY , stats ) , NUM / m Order ) ; }
public Set < Resource > find Same As ( Resource value , Resource ... contxts ) throws Inference Engine Exception { Set < Resource > same As = new Hash Set < Resource > ( ) ; same As . add ( value ) ; find Same As Chaining ( value , same As , contxts ) ; return same As ; }
protected static void remove All Triggers ( Connection conn , String prefix ) throws SQL Exception { Statement stat = conn . create Statement ( ) ; Result Set rs = stat . execute Query ( STRING ) ; Statement stat 2 = conn . create Statement ( ) ; while ( rs . next ( ) ) { String schema = rs . get String ( STRING ) ; String name = rs . get String ( STRING ) ; if ( name . starts With ( prefix ) ) { name = String Utils . quote Identifier ( schema ) + STRING + String Utils . quote Identifier ( name ) ; stat 2 . execute ( STRING + name ) ; } } }
public void reset ( ) { m Object Count = NUM ; m Object Data Used = NUM ; Arrays . fill ( m Objects , null ) ; }
public double gaussian Potential Upside ( double percentile ) { QL . require ( percentile < NUM && percentile >= NUM , STRING ) ; double result = gaussian Percentile ( percentile ) ; return Math . max ( result , NUM ) ; }
public static String shard Name From DB Name ( String db Name ) { String [ ] tokens = db Name . split ( STRING ) ; return tokens [ NUM ] ; }
public String Use This Var ( String id , String context ) { Sym Tab Entry se = null ; int i = Find Sym ( id , context ) ; if ( i == symtab . size ( ) ) return id ; se = ( Sym Tab Entry ) symtab . element At ( i ) ; if ( se . type == GLOBAL || se . type == PROCESSVAR || se . type == PROCEDUREVAR || se . type == PARAMETER ) return se . use This ; i = Find Sym ( id , STRING ) ; if ( se . type == GLOBAL ) return se . use This ; return id ; }
public void to Axis Angle ( Vector 4 f output ) { if ( get W ( ) > NUM ) { normalise ( ) ; } float angle = NUM * ( float ) Math . to Degrees ( Math . acos ( get W ( ) ) ) ; float x ; float y ; float z ; float s = ( float ) Math . sqrt ( NUM - get W ( ) * get W ( ) ) ; if ( s < NUM ) { x = points [ NUM ] ; y = points [ NUM ] ; z = points [ NUM ] ; } else { x = points [ NUM ] / s ; y = points [ NUM ] / s ; z = points [ NUM ] / s ; } output . points [ NUM ] = x ; output . points [ NUM ] = y ; output . points [ NUM ] = z ; output . points [ NUM ] = angle ; }
private byte [ ] uint 8 4 From Data ( int offset ) { return Arrays . copy Of Range ( data ( ) , offset , offset + NUM ) ; }

public static String join Options ( String [ ] option Array ) { String option String = STRING ; for ( String element : option Array ) { if ( element . equals ( STRING ) ) { continue ; } boolean escape = BOOL ; for ( int n = NUM ; n < element . length ( ) ; n ++ ) { if ( Character . is Whitespace ( element . char At ( n ) ) ) { escape = BOOL ; break ; } } if ( escape ) { option String += STRING + back Quote Chars ( element ) + STRING ; } else { option String += element ; } option String += STRING ; } return option String . trim ( ) ; }
@ Override public String generate Label ( Category Dataset dataset , int series ) { Param Checks . null Not Permitted ( dataset , STRING ) ; String label = Message Format . format ( this . format Pattern , create Item Array ( dataset , series ) ) ; return label ; }
@ Override public Match Result match ( String str ) { String input = str . trim ( ) ; Matcher matcher = pattern . matcher ( input ) ; if ( ( matcher . matches ( ) ) ) { Match Result result = new Match Result ( matcher . start ( ) , matcher . end ( ) ) ; for ( String slot : slots . key Set ( ) ) { String filled Value = matcher . group ( slots . get ( slot ) ) ; if ( ! String Utils . check Form ( filled Value ) && permutate Pattern ( ) ) { return match ( str ) ; } result . add Pair ( slot , filled Value ) ; } return result ; } return new Match Result ( BOOL ) ; }
private void align Labels ( ) { final int height = m selector Label . get Preferred Size ( ) . height ; int width = m selector Label . get Preferred Size ( ) . width ; if ( m editor != null ) { final int label Width = m editor . get Label Width ( ) ; if ( width < label Width ) { width = label Width ; } else { m editor . set Label Width ( width ) ; } } final Dimension dimension = new Dimension ( width , height ) ; m selector Label . set Preferred Size ( dimension ) ; m selector Label . set Size ( dimension ) ; }
private static Field find Accessible Field ( Class clas , String field Name ) throws Util Eval Error , No Such Field Exception { Field field ; try { field = clas . get Field ( field Name ) ; Reflect Manager . RM Set Accessible ( field ) ; return field ; } catch ( No Such Field Exception e ) { } while ( clas != null ) { try { field = clas . get Declared Field ( field Name ) ; Reflect Manager . RM Set Accessible ( field ) ; return field ; } catch ( No Such Field Exception e ) { } clas = clas . get Superclass ( ) ; } throw new No Such Field Exception ( field Name ) ; }
public Year ( Date time , Time Zone zone ) { this ( time , zone , Locale . get Default ( ) ) ; }
private Collection < Unit > fire AA ( final Route route , final Collection < Unit > units ) { if ( m aa In Move Util == null ) { m aa In Move Util = new AA In Move Util ( ) ; } m aa In Move Util . initialize ( m bridge ) ; final Collection < Unit > r Val = m aa In Move Util . fire AA ( route , units , Unit Comparator . get Lowest To Highest Movement Comparator ( ) , m current Move ) ; m aa In Move Util = null ; return r Val ; }
default B with Default ( String key , long value ) { return with Default ( key , Long . to String ( value ) ) ; }
public static String read String ( final JSON Array json Array , final int index , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Array . get String ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT ARRAY , index ) ) ; } String value = null ; if ( ! json Array . is Null ( index ) ) { value = json Array . get String ( index ) ; } return value ; }
private void throw Ex Int Param ( Method Visitor mv , Class < ? > ex Cls ) { String ex Sig = Type . get Internal Name ( ex Cls ) ; mv . visit Type Insn ( NEW , ex Sig ) ; mv . visit Insn ( DUP ) ; mv . visit Ldc Insn ( STRING + this . class Name + STRING ) ; mv . visit Var Insn ( ILOAD , NUM ) ; mv . visit Method Insn ( INVOKESTATIC , STRING , STRING , STRING ) ; mv . visit Method Insn ( INVOKEVIRTUAL , STRING , STRING , STRING ) ; mv . visit Method Insn ( INVOKESPECIAL , ex Sig , STRING , STRING ) ; mv . visit Insn ( ATHROW ) ; }
public final Pdf Object read Reference Table ( final Pdf Object linear Obj , final Pdf File Reader current Pdf File , final Object Reader object Reader ) throws Pdf Exception { int pointer = - NUM ; final int eof = ( int ) this . eof ; boolean islinearized Compressed = BOOL ; if ( linear Obj == null ) { pointer = read First Start Ref ( ) ; } else { final byte [ ] data = pdf datafile . get Pdf Buffer ( ) ; final int count = data . length ; int ptr = NUM ; for ( int i = NUM ; i < count ; i ++ ) { if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { ptr = i + NUM ; } if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { pointer = i ; i = count ; } else if ( data [ i ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING && data [ i + NUM ] == STRING ) { islinearized Compressed = BOOL ; pointer = ptr ; while ( data [ pointer ] == NUM || data [ pointer ] == NUM || data [ pointer ] == NUM ) { pointer ++ ; } i = count ; } } } offset . add Xref ( pointer ) ; Pdf Object root Obj = null ; if ( pointer >= eof || pointer == NUM ) { Log Writer . write Log ( STRING ) ; offset . set Ref Table Invalid ( BOOL ) ; try { root Obj = new Page Object ( Broken Ref Table . find Offsets ( pdf datafile , offset ) ) ; } catch ( Error err ) { throw new Pdf Exception ( err . get Message ( ) + STRING ) ; } current Pdf File . read Object ( root Obj ) ; return root Obj ; } else if ( islinearized Compressed || is Compressed Stream ( pointer , eof ) ) { return read Compressed Stream ( root Obj , pointer , current Pdf File , object Reader , linear Obj ) ; } else { return read Legacy Reference Table ( root Obj , pointer , eof , current Pdf File ) ; } }
public static void main ( String [ ] args ) { try { Set < String > files = new Tree Set < String > ( ) ; for ( int i = NUM ; i < args . length ; i ++ ) { get XML Files ( args [ i ] , files ) ; } new Log Messages Formatter ( files ) ; } catch ( Parser Configuration Exception e ) { e . print Stack Trace ( ) ; } catch ( SAX Exception e ) { e . print Stack Trace ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
boolean await Exchange ( E e , int start ) { for ( int step = NUM , total Spins = NUM ; ( step < ARENA LENGTH ) && ( total Spins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA MASK ; Atomic Reference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( ( found == WAITER ) && slot . compare And Set ( WAITER , e ) ) { return BOOL ; } else if ( ( found == FREE ) && slot . compare And Set ( FREE , e ) ) { int slot Spins = NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( found != e ) { return BOOL ; } else if ( ( slot Spins >= SPINS PER STEP ) && ( slot . compare And Set ( e , FREE ) ) ) { total Spins += slot Spins ; break ; } slot Spins ++ ; } } } return BOOL ; }
protected Array List < Array List < DBI Ds > > build Ranges ( Relation < V > relation ) { final int dim = Relation Util . dimensionality ( relation ) ; final int size = relation . size ( ) ; final Array List < Array List < DBI Ds > > ranges = new Array List < > ( ) ; Array Modifiable DBI Ds ids = DBID Util . new Array ( relation . get DBI Ds ( ) ) ; Sort DBI Ds By Single Dimension sorter = new Sort DBI Ds By Single Dimension ( relation ) ; final double part = size * NUM / phi ; for ( int d = NUM ; d < dim ; d ++ ) { sorter . set Dimension ( d ) ; ids . sort ( sorter ) ; Array List < DBI Ds > dimranges = new Array List < > ( phi + NUM ) ; int start = NUM ; DBID Array Iter iter = ids . iter ( ) ; for ( int r = NUM ; r <= phi ; r ++ ) { int end = ( r < phi ) ? ( int ) ( part * r ) : size ; Array Modifiable DBI Ds currange = DBID Util . new Array ( end - start ) ; for ( iter . seek ( start ) ; iter . get Offset ( ) < end ; iter . advance ( ) ) { currange . add ( iter ) ; } start = end ; dimranges . add ( currange ) ; } ranges . add ( dimranges ) ; } return ranges ; }
static int find Start Trim Blanks ( Char Sequence s ) { final int len = s . length ( ) ; for ( int i = NUM ; i < len ; i ++ ) { final char ch = s . char At ( i ) ; if ( ch != STRING && ch != STRING ) { return i ; } } return len ; }
protected void assert Func Equals ( final String ... inputs ) throws Exception { Solr Query Request req = req ( ) ; try { assert Func Equals ( req , inputs ) ; } finally { req . close ( ) ; } }
private void create Matrices ( ) { final int w = ( int ) ( current image . get Width ( ) / scaling ) ; final int h = ( int ) ( current image . get Height ( ) / scaling ) ; Trm = new float [ NUM ] [ NUM ] ; Trm [ NUM ] [ NUM ] = ( CTM [ NUM ] [ NUM ] / w ) ; Trm [ NUM ] [ NUM ] = ( CTM [ NUM ] [ NUM ] / w ) ; Trm [ NUM ] [ NUM ] = NUM ; Trm [ NUM ] [ NUM ] = ( CTM [ NUM ] [ NUM ] / h ) ; Trm [ NUM ] [ NUM ] = ( CTM [ NUM ] [ NUM ] / h ) ; Trm [ NUM ] [ NUM ] = NUM ; Trm [ NUM ] [ NUM ] = CTM [ NUM ] [ NUM ] ; Trm [ NUM ] [ NUM ] = CTM [ NUM ] [ NUM ] ; Trm [ NUM ] [ NUM ] = NUM ; for ( int y = NUM ; y < NUM ; y ++ ) { for ( int x = NUM ; x < NUM ; x ++ ) { if ( ( Trm [ x ] [ y ] > NUM ) & ( Trm [ x ] [ y ] < NUM ) ) { Trm [ x ] [ y ] = NUM ; } } } Trm 1 = new float [ NUM ] [ NUM ] ; Trm 2 = new float [ NUM ] [ NUM ] ; float x1 , x2 , y1 , y2 ; x1 = CTM [ NUM ] [ NUM ] ; if ( x1 < NUM ) { x1 = - x1 ; } x2 = CTM [ NUM ] [ NUM ] ; if ( x2 < NUM ) { x2 = - x2 ; } y1 = CTM [ NUM ] [ NUM ] ; if ( y1 < NUM ) { y1 = - y1 ; } y2 = CTM [ NUM ] [ NUM ] ; if ( y2 < NUM ) { y2 = - y2 ; } if ( CTM [ NUM ] [ NUM ] == NUM || CTM [ NUM ] [ NUM ] == NUM ) { Trm 1 = Trm ; } else if ( ( CTM [ NUM ] [ NUM ] == NUM ) && ( CTM [ NUM ] [ NUM ] == NUM ) ) { Trm 1 [ NUM ] [ NUM ] = w / ( CTM [ NUM ] [ NUM ] ) ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = h / ( CTM [ NUM ] [ NUM ] ) ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 = Matrix . multiply ( Trm , Trm 1 ) ; for ( int y = NUM ; y < NUM ; y ++ ) { for ( int x = NUM ; x < NUM ; x ++ ) { if ( ( Trm 1 [ x ] [ y ] > NUM ) & ( Trm 1 [ x ] [ y ] < NUM ) ) { Trm 1 [ x ] [ y ] = NUM ; } } } if ( Trm 1 [ NUM ] [ NUM ] < NUM && Trm 1 [ NUM ] [ NUM ] > NUM && CTM [ NUM ] [ NUM ] < NUM ) { Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = - NUM ; } if ( Trm 1 [ NUM ] [ NUM ] < NUM && Trm 1 [ NUM ] [ NUM ] > NUM && CTM [ NUM ] [ NUM ] < NUM && CTM [ NUM ] [ NUM ] < NUM ) { Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = - NUM ; } } else { if ( x1 > x2 ) { Trm 1 [ NUM ] [ NUM ] = w / ( CTM [ NUM ] [ NUM ] ) ; } else { Trm 1 [ NUM ] [ NUM ] = w / ( CTM [ NUM ] [ NUM ] ) ; } if ( Trm 1 [ NUM ] [ NUM ] < NUM ) { Trm 1 [ NUM ] [ NUM ] = - Trm 1 [ NUM ] [ NUM ] ; } Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = NUM ; if ( y1 > y2 ) { Trm 1 [ NUM ] [ NUM ] = h / ( CTM [ NUM ] [ NUM ] ) ; } else { Trm 1 [ NUM ] [ NUM ] = h / ( CTM [ NUM ] [ NUM ] ) ; } if ( Trm 1 [ NUM ] [ NUM ] < NUM ) { Trm 1 [ NUM ] [ NUM ] = - Trm 1 [ NUM ] [ NUM ] ; } Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 [ NUM ] [ NUM ] = NUM ; Trm 1 = Matrix . multiply ( Trm , Trm 1 ) ; for ( int y = NUM ; y < NUM ; y ++ ) { for ( int x = NUM ; x < NUM ; x ++ ) { if ( ( Trm 1 [ x ] [ y ] > NUM ) & ( Trm 1 [ x ] [ y ] < NUM ) ) { Trm 1 [ x ] [ y ] = NUM ; } } } } if ( x1 > x2 ) { Trm 2 [ NUM ] [ NUM ] = ( CTM [ NUM ] [ NUM ] / w ) ; } else { Trm 2 [ NUM ] [ NUM ] = ( CTM [ NUM ] [ NUM ] / w ) ; } if ( Trm 2 [ NUM ] [ NUM ] < NUM ) { Trm 2 [ NUM ] [ NUM ] = - Trm 2 [ NUM ] [ NUM ] ; } Trm 2 [ NUM ] [ NUM ] = NUM ; Trm 2 [ NUM ] [ NUM ] = NUM ; Trm 2 [ NUM ] [ NUM ] = NUM ; if ( y1 > y2 ) { Trm 2 [ NUM ] [ NUM ] = ( CTM [ NUM ] [ NUM ] / h ) ; } else { Trm 2 [ NUM ] [ NUM ] = ( CTM [ NUM ] [ NUM ] / h ) ; } if ( Trm 2 [ NUM ] [ NUM ] < NUM ) { Trm 2 [ NUM ] [ NUM ] = - Trm 2 [ NUM ] [ NUM ] ; } Trm 2 [ NUM ] [ NUM ] = NUM ; Trm 2 [ NUM ] [ NUM ] = NUM ; Trm 2 [ NUM ] [ NUM ] = NUM ; Trm 2 [ NUM ] [ NUM ] = NUM ; for ( int y = NUM ; y < NUM ; y ++ ) { for ( int x = NUM ; x < NUM ; x ++ ) { if ( ( Trm 2 [ x ] [ y ] > NUM ) & ( Trm 2 [ x ] [ y ] < NUM ) ) { Trm 2 [ x ] [ y ] = NUM ; } } } }
public boolean check Entry ( int i , String road Name , String road Number , String consist Number , String loco 1 Address , String loco 2 Address , String loco 3 Address , String loco 4 Address , String loco 5 Address , String loco 6 Address , String id ) { Nce Consist Roster Entry r = list . get ( i ) ; if ( id != null && ! id . equals ( r . get Id ( ) ) ) { return BOOL ; } if ( road Name != null && ! road Name . equals ( r . get Road Name ( ) ) ) { return BOOL ; } if ( road Number != null && ! road Number . equals ( r . get Road Number ( ) ) ) { return BOOL ; } if ( consist Number != null && ! consist Number . equals ( r . get Consist Number ( ) ) ) { return BOOL ; } if ( loco 1 Address != null && ! loco 1 Address . equals ( r . get Loco 1 Dcc Address ( ) ) ) { return BOOL ; } if ( loco 2 Address != null && ! loco 2 Address . equals ( r . get Loco 2 Dcc Address ( ) ) ) { return BOOL ; } if ( loco 3 Address != null && ! loco 3 Address . equals ( r . get Loco 3 Dcc Address ( ) ) ) { return BOOL ; } if ( loco 4 Address != null && ! loco 4 Address . equals ( r . get Loco 4 Dcc Address ( ) ) ) { return BOOL ; } if ( loco 5 Address != null && ! loco 5 Address . equals ( r . get Loco 5 Dcc Address ( ) ) ) { return BOOL ; } if ( loco 6 Address != null && ! loco 6 Address . equals ( r . get Loco 6 Dcc Address ( ) ) ) { return BOOL ; } return BOOL ; }
protected int to Julian ( java . util . Date date ) { YMD ymd = null ; synchronized ( gc ) { gc . set Time ( date ) ; ymd = new YMD ( gc . get ( Gregorian Calendar . YEAR ) , gc . get ( Gregorian Calendar . MONTH ) + NUM , gc . get ( Gregorian Calendar . DAY OF MONTH ) ) ; } return ymd . julian ( ) ; }
public synchronized boolean remove First ( K obj ) { if ( peek First ( ) != obj ) { return BOOL ; } int len = array . length ; @ Suppress Warnings ( STRING ) K [ ] a = ( K [ ] ) new Object [ len - NUM ] ; System . arraycopy ( array , NUM , a , NUM , len - NUM ) ; array = a ; return BOOL ; }
private boolean serialize Compact RDF Attr Props ( XMP Node parent Node , int indent ) throws IO Exception { boolean all Are Attrs = BOOL ; for ( Iterator it = parent Node . iterate Children ( ) ; it . has Next ( ) ; ) { XMP Node prop = ( XMP Node ) it . next ( ) ; if ( can Be RDF Attr Prop ( prop ) ) { write Newline ( ) ; write Indent ( indent ) ; write ( prop . get Name ( ) ) ; write ( STRING ) ; append Node Value ( prop . get Value ( ) , BOOL ) ; write ( STRING ) ; } else { all Are Attrs = BOOL ; } } return all Are Attrs ; }
public default Utility Table query Util ( B Network network , String query Var ) { return query Util ( new Query . Util Query ( network , Arrays . as List ( query Var ) , new Assignment ( ) ) ) ; }
public double local Score ( int i ) { double sum = NUM ; for ( B Deu Score score : scores ) { sum += score . local Score ( i ) ; } return sum / scores . size ( ) ; }
@ Override public void previous ( ) { current Image = Optional . of ( add Index And Get Image By Offset ( - NUM ) ) ; event Bus . post ( new Source Has Pending Update Event ( this ) ) ; }
public static NBT Tag make ( Input Stream is ) throws Exception { NBT Tag ret = null ; Data Input Stream stream = new Data Input Stream ( is ) ; byte t = stream . read Byte ( ) ; int type = ( int ) t ; String name = STRING ; if ( type > NUM ) name = stream . read UTF ( ) ; switch ( type ) { case NUM : ret = new TAG End ( name ) ; break ; case NUM : ret = new TAG Byte ( name ) ; break ; case NUM : ret = new TAG Short ( name ) ; break ; case NUM : ret = new TAG Int ( name ) ; break ; case NUM : ret = new TAG Long ( name ) ; break ; case NUM : ret = new TAG Float ( name ) ; break ; case NUM : ret = new TAG Double ( name ) ; break ; case NUM : ret = new TAG Byte Array ( name ) ; break ; case NUM : ret = new TAG String ( name ) ; break ; case NUM : ret = new TAG List ( name ) ; break ; case NUM : ret = new TAG Compound ( name ) ; break ; case NUM : ret = new TAG Int Array ( name ) ; break ; default : throw ( new Exception ( STRING + type ) ) ; } ret . parse ( stream ) ; return ret ; }
public void run ( ) { set Running ( BOOL ) ; while ( keep Running ( ) ) { if ( activity Count ( ) > NUM ) { long current Time = System . current Time Millis ( ) ; long t = - NUM ; synchronized ( this ) { for ( int i = NUM ; i < m activities . size ( ) ; i ++ ) { Activity a = ( Activity ) m activities . get ( i ) ; m tmp . add ( a ) ; if ( current Time >= a . get Stop Time ( ) ) { m activities . remove ( i -- ) ; a . set Scheduled ( BOOL ) ; } } if ( m activities . size ( ) == NUM ) { m next Time = Long . MAX VALUE ; } } for ( int i = NUM ; i < m tmp . size ( ) ; i ++ ) { Activity a = ( Activity ) m tmp . get ( i ) ; long s = a . run Activity ( current Time ) ; t = ( s < NUM ? t : t < NUM ? s : Math . min ( t , s ) ) ; } m tmp . clear ( ) ; if ( t == - NUM ) continue ; try { synchronized ( this ) { wait ( t ) ; } } catch ( Interrupted Exception e ) { } } else { try { synchronized ( this ) { wait ( ) ; } } catch ( Interrupted Exception e ) { } } } }
public void write Int ( int value ) throws IO Exception { check Write Primitive Types ( ) ; primitive Types . write Int ( value ) ; }
public Storage Pool select Pool ( List < Storage Pool > pool List ) { if ( pool List == null || pool List . is Empty ( ) ) { return null ; } port Metrics Processor . compute Storage Pools Avg Port Metrics ( pool List ) ; Collections . sort ( pool List , storage Pool Comparator ) ; return pool List . get ( NUM ) ; }
public void on Register Click ( View view ) { if ( view != null ) { Intent register = new Intent ( Intent . ACTION VIEW , Uri . parse ( get String ( R . string . welcome link url ) ) ) ; set Result ( RESULT CANCELED ) ; start Activity ( register ) ; } }
private void index Certificate ( X509 Certificate cert ) { X500 Principal subject = cert . get Subject X 500 Principal ( ) ; Object old Entry = cert Subjects . put ( subject , cert ) ; if ( old Entry != null ) { if ( old Entry instanceof X509 Certificate ) { if ( cert . equals ( old Entry ) ) { return ; } List < X509 Certificate > list = new Array List < > ( NUM ) ; list . add ( cert ) ; list . add ( ( X509 Certificate ) old Entry ) ; cert Subjects . put ( subject , list ) ; } else { @ Suppress Warnings ( STRING ) List < X509 Certificate > list = ( List < X509 Certificate > ) old Entry ; if ( list . contains ( cert ) == BOOL ) { list . add ( cert ) ; } cert Subjects . put ( subject , list ) ; } } }
public static String trim Name ( String line ) { int idx = line . index Of ( STRING ) ; if ( idx != - NUM ) { line = line . substring ( NUM , idx ) ; } line = trim Line ( line ) ; idx = line . index Of ( STRING ) ; if ( idx == - NUM ) { idx = line . index Of ( STRING ) ; } if ( idx != - NUM ) { line = line . substring ( NUM , idx ) ; } return line . trim ( ) ; }
public double distance ( double p1 , double p2 ) { double d = ( p1 - p2 ) * ( p1 - p2 ) ; return Math . sqrt ( d ) ; }
public static < T > String path ( Tree Def . Parented < T > tree Def , T node , Function < ? super T , String > to String , String delimiter ) { List < T > to Root = to Root ( tree Def , node ) ; List Iterator < T > iterator = to Root . list Iterator ( to Root . size ( ) ) ; String Builder builder = new String Builder ( ) ; while ( iterator . has Previous ( ) ) { T segment = iterator . previous ( ) ; builder . append ( to String . apply ( segment ) ) ; if ( iterator . has Previous ( ) ) { builder . append ( delimiter ) ; } } return builder . to String ( ) ; }
private void remove Cookies For Redirects ( final Http Servlet Request request , final Http Servlet Response response ) { final Set < String > domains = Auth Client Utils . get Cookie Domains For Request ( request ) ; for ( String domain : domains ) { Cookie Utils . add Cookie To Response ( response , Cookie Utils . new Cookie ( Constants . AM LOCATION COOKIE , STRING , NUM , STRING , domain ) ) ; } }
public static int identify Regions ( char [ ] [ ] img , char off Char ) { for ( int i = NUM ; i < img . length ; i ++ ) { for ( int j = NUM ; j < img [ NUM ] . length ; j ++ ) { if ( img [ i ] [ j ] != off Char ) { img [ i ] [ j ] = ON ; } } } char next = First Region ; I Convex Hull alg = new Convex Hull Scan ( ) ; while ( BOOL ) { I Point p = locate ( img ) ; if ( p == null ) return ( next - First Region ) ; Collection < I Point > points = new Linked List < I Point > ( ) ; points . add ( p ) ; spread ( img , ( int ) p . get X ( ) , ( int ) p . get Y ( ) , points , next ) ; I Point [ ] raw = points . to Array ( new Two D Point [ ] { } ) ; I Point [ ] hull = alg . compute ( raw ) ; for ( I Point h : hull ) { img [ ( int ) h . get X ( ) ] [ ( int ) h . get Y ( ) ] = HULL ; } next ++ ; } }
private void parse Test Class ( String test Class Name , Test Suite Builder test Suite Builder ) { int method Separator Index = test Class Name . index Of ( STRING ) ; String test Method Name = null ; if ( method Separator Index > NUM ) { test Method Name = test Class Name . substring ( method Separator Index + NUM ) ; test Class Name = test Class Name . substring ( NUM , method Separator Index ) ; } test Suite Builder . add Test Class By Name ( test Class Name , test Method Name , get Target Context ( ) ) ; }
public long nswap ( ) { return Long . parse Long ( fields [ NUM ] ) ; }
public final Json Serializer < ? > find Serializer By Lookup ( Java Type type , Serialization Config config , Basic Bean Description bean Desc , Bean Property property , boolean static Typing ) { Class < ? > raw = type . get Raw Class ( ) ; String cls Name = raw . get Name ( ) ; Json Serializer < ? > ser = concrete . get ( cls Name ) ; if ( ser != null ) { return ser ; } Class < ? extends Json Serializer < ? > > ser Class = concrete Lazy . get ( cls Name ) ; if ( ser Class != null ) { try { return ser Class . new Instance ( ) ; } catch ( Exception e ) { throw new Illegal State Exception ( STRING + ser Class . get Name ( ) + STRING + e . get Message ( ) , e ) ; } } return null ; }
private void save Impl ( File Location loc ) throws IO Exception { Output Stream out = loc . get Output Stream ( ) ; Print Writer w = new Print Writer ( new Buffered Writer ( new Unicode Writer ( out , get Encoding ( ) ) ) ) ; try { write ( w ) ; } finally { w . close ( ) ; } }
public boolean bound Scroll Raw ( ) { float cur Scroll = get Stack Scroll ( ) ; float new Scroll = get Bounded Stack Scroll ( cur Scroll ) ; if ( Float . compare ( new Scroll , cur Scroll ) != NUM ) { set Stack Scroll Raw ( new Scroll ) ; return BOOL ; } return BOOL ; }
public Vector < MBROLA Phoneme > convert Sampa ( MBROLA Phoneme mary Phoneme ) { Vector < MBROLA Phoneme > phones = new Vector < MBROLA Phoneme > ( ) ; String mary Sampa = mary Phoneme . get Symbol ( ) ; if ( sampa 2 voice Map != null && sampa 2 voice Map . contains Key ( mary Sampa ) ) { String new Sampa = sampa 2 voice Map . get ( mary Sampa ) ; Vector < String > new Sampas = new Vector < String > ( ) ; String Tokenizer st = new String Tokenizer ( new Sampa ) ; while ( st . has More Tokens ( ) ) { new Sampas . add ( st . next Token ( ) ) ; } int n = new Sampas . size ( ) ; int total Dur = mary Phoneme . get Duration ( ) ; Vector < int [ ] > all Targets = mary Phoneme . get Targets ( ) ; for ( int i = NUM ; i < new Sampas . size ( ) ; i ++ ) { String sampa = new Sampas . get ( i ) ; int dur = total Dur / n ; Vector < int [ ] > new Targets = null ; int max P = NUM * ( i + NUM ) / n ; boolean ok = BOOL ; while ( all Targets != null && all Targets . size ( ) > NUM && ok ) { int [ ] old Target = all Targets . get ( NUM ) ; if ( old Target [ NUM ] <= max P ) { int [ ] new Target = new int [ NUM ] ; new Target [ NUM ] = old Target [ NUM ] * n ; new Target [ NUM ] = old Target [ NUM ] ; if ( new Targets == null ) new Targets = new Vector < int [ ] > ( ) ; new Targets . add ( new Target ) ; all Targets . remove ( NUM ) ; } else { ok = BOOL ; } } MBROLA Phoneme mp = new MBROLA Phoneme ( sampa , dur , new Targets , mary Phoneme . get Voice Quality ( ) ) ; phones . add ( mp ) ; } } else { phones . add ( mary Phoneme ) ; } return phones ; }
public void append ( int key , float value ) { if ( m Size != NUM && key <= m Keys [ m Size - NUM ] ) { put ( key , value ) ; return ; } int pos = m Size ; if ( pos >= m Keys . length ) { int n = Array Utils . ideal Int Array Size ( pos + NUM ) ; int [ ] nkeys = new int [ n ] ; float [ ] nvalues = new float [ n ] ; System . arraycopy ( m Keys , NUM , nkeys , NUM , m Keys . length ) ; System . arraycopy ( m Values , NUM , nvalues , NUM , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } m Keys [ pos ] = key ; m Values [ pos ] = value ; m Size = pos + NUM ; }
public synchronized void remove Batch Classifier Listener ( Batch Classifier Listener cl ) { m batch Classifier Listeners . remove ( cl ) ; }
public final float read Float ( ) throws java . io . IO Exception { return Float . int Bits To Float ( read Int ( ) ) ; }
public static void sync Modification Times ( Configuration conf , Path src , Path dest , Optional < Path Filter > filter ) throws IO Exception { Set < File Status > src File Statuses = get File Statuses Recursive ( conf , src , filter ) ; Map < String , Long > src File Modification Times = null ; try { src File Modification Times = get Relative Path To Modification Time ( src , src File Statuses ) ; } catch ( Argument Exception e ) { throw new IO Exception ( STRING , e ) ; } File System dest Fs = dest . get File System ( conf ) ; for ( String file : src File Modification Times . key Set ( ) ) { dest Fs . set Times ( new Path ( dest , file ) , src File Modification Times . get ( file ) , - NUM ) ; } }
private void convert Values Impl ( Blackboard bb , Sql Call values , Rel Data Type target Row Type ) { Rel Node values Rel = convert Row Values ( bb , values , values . get Operand List ( ) , BOOL , target Row Type ) ; if ( values Rel != null ) { bb . set Root ( values Rel , BOOL ) ; return ; } final List < Rel Node > union Rels = new Array List < > ( ) ; for ( Sql Node row Constructor 1 : values . get Operand List ( ) ) { Sql Call row Constructor = ( Sql Call ) row Constructor 1 ; Blackboard tmp Bb = create Blackboard ( bb . scope , null , BOOL ) ; replace Subqueries ( tmp Bb , row Constructor , Rel Opt Util . Logic . TRUE FALSE UNKNOWN ) ; final List < Pair < Rex Node , String > > exps = new Array List < > ( ) ; for ( Ord < Sql Node > operand : Ord . zip ( row Constructor . get Operand List ( ) ) ) { exps . add ( Pair . of ( tmp Bb . convert Expression ( operand . e ) , validator . derive Alias ( operand . e , operand . i ) ) ) ; } Rel Node in = ( null == tmp Bb . root ) ? Logical Values . create One Row ( cluster ) : tmp Bb . root ; union Rels . add ( Rel Opt Util . create Project ( in , Pair . left ( exps ) , Pair . right ( exps ) , BOOL ) ) ; } if ( union Rels . size ( ) == NUM ) { throw Util . new Internal ( STRING ) ; } else if ( union Rels . size ( ) == NUM ) { bb . set Root ( union Rels . get ( NUM ) , BOOL ) ; } else { bb . set Root ( Logical Union . create ( union Rels , BOOL ) , BOOL ) ; } }
static public Item Stack chisel Block ( final I Continuous Inventory selected , final Acting Player player , final Voxel Blob vb , final World world , final Block Pos pos , final Enum Facing side , final int x , final int y , final int z , Item Stack output , final List < Entity Item > spawnlist ) { final boolean is Creative = player . is Creative ( ) ; final int blk = vb . get ( x , y , z ) ; if ( blk == NUM ) { return output ; } if ( ! can Mine ( selected , Block . get State By Id ( blk ) , player . get Player ( ) , world , pos ) ) { return output ; } selected . use Item ( blk ) ; final boolean spawn Bit = Chisels And Bits . get Items ( ) . item Block Bit != null ; if ( ! world . is Remote && ! is Creative ) { double hit X = x * one 16 th ; double hit Y = y * one 16 th ; double hit Z = z * one 16 th ; final double offset = NUM ; hit X += side . get Front Offset X ( ) * offset ; hit Y += side . get Front Offset Y ( ) * offset ; hit Z += side . get Front Offset Z ( ) * offset ; if ( output == null || ! Item Chiseled Bit . same Bit ( output , blk ) || output . stack Size == NUM ) { output = Item Chiseled Bit . create Stack ( blk , NUM , BOOL ) ; if ( spawn Bit ) { spawnlist . add ( new Entity Item ( world , pos . get X ( ) + hit X , pos . get Y ( ) + hit Y , pos . get Z ( ) + hit Z , output ) ) ; } } else { output . stack Size ++ ; } } else { output = Item Chiseled Bit . create Stack ( blk , NUM , BOOL ) ; } vb . clear ( x , y , z ) ; return output ; }
private void configure Button ( J Button button ) { Font button Font = ( Font ) Default Lookup . get ( option Pane , this , STRING ) ; if ( button Font != null ) { button . set Font ( button Font ) ; } }
default Filterable < T > retain All ( final Stream < ? extends T > stream ) { final Set < T > set = stream . collect ( Collectors . to Set ( ) ) ; return filter ( null ) ; }
public void draw Shape ( int x , int y , int w , int h , Map < String , Object > style ) { Color pen Color = mx Utils . get Color ( style , mx Constants . STYLE STROKECOLOR ) ; float pen Width = mx Utils . get Float ( style , mx Constants . STYLE STROKEWIDTH , NUM ) ; int pw = ( int ) Math . ceil ( pen Width * scale ) ; if ( g . hit Clip ( x - pw , y - pw , w + NUM * pw , h + NUM * pw ) ) { boolean shadow = mx Utils . is True ( style , mx Constants . STYLE SHADOW , BOOL ) ; Color fill Color = mx Utils . get Style Fill Color ( style ) ; Paint fill Paint = get Fill Paint ( new Rectangle ( x , y , w , h ) , fill Color , style ) ; if ( pen Width > NUM ) { set Stroke ( pen Width , style ) ; } String shape = mx Utils . get String ( style , mx Constants . STYLE SHAPE , STRING ) ; if ( shape . equals ( mx Constants . SHAPE IMAGE ) ) { String img = get Image For Style ( style ) ; if ( img != null ) { draw Image ( x , y , w , h , img ) ; } } else if ( shape . equals ( mx Constants . SHAPE LINE ) ) { if ( pen Color != null ) { g . set Color ( pen Color ) ; String direction = mx Utils . get String ( style , mx Constants . STYLE DIRECTION , mx Constants . DIRECTION EAST ) ; if ( direction . equals ( mx Constants . DIRECTION EAST ) || direction . equals ( mx Constants . DIRECTION WEST ) ) { int mid = ( int ) ( y + h / NUM ) ; draw Line ( x , mid , x + w , mid ) ; } else { int mid = ( int ) ( x + w / NUM ) ; draw Line ( mid , y , mid , y + h ) ; } } } else if ( shape . equals ( mx Constants . SHAPE ELLIPSE ) ) { draw Oval ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants . SHAPE DOUBLE ELLIPSE ) ) { draw Oval ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; int inset = ( int ) ( ( NUM + pen Width ) * scale ) ; x += inset ; y += inset ; w -= NUM * inset ; h -= NUM * inset ; draw Oval ( x , y , w , h , null , null , pen Color , BOOL ) ; } else if ( shape . equals ( mx Constants . SHAPE RHOMBUS ) ) { draw Rhombus ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants . SHAPE CYLINDER ) ) { draw Cylinder ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants . SHAPE ACTOR ) ) { draw Actor ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants . SHAPE CLOUD ) ) { draw Cloud ( x , y , w , h , fill Color , fill Paint , pen Color , shadow ) ; } else if ( shape . equals ( mx Constants . SHAPE TRIANGLE ) ) { String direction = mx Utils . get String ( style , mx Constants . STYLE DIRECTION , STRING ) ; draw Triangle ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , direction ) ; } else if ( shape . equals ( mx Constants . SHAPE HEXAGON ) ) { String direction = mx Utils . get String ( style , mx Constants . STYLE DIRECTION , STRING ) ; draw Hexagon ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , direction ) ; } else { draw Rect ( x , y , w , h , fill Color , fill Paint , pen Color , shadow , mx Utils . is True ( style , mx Constants . STYLE ROUNDED ) ) ; if ( shape . equals ( mx Constants . SHAPE LABEL ) ) { String img = get Image For Style ( style ) ; if ( img != null ) { String img Align = mx Utils . get String ( style , mx Constants . STYLE IMAGE ALIGN , mx Constants . ALIGN CENTER ) ; String img Valign = mx Utils . get String ( style , mx Constants . STYLE IMAGE VERTICAL ALIGN , mx Constants . ALIGN MIDDLE ) ; int img Width = ( int ) ( mx Utils . get Int ( style , mx Constants . STYLE IMAGE WIDTH , mx Constants . DEFAULT IMAGESIZE ) * scale ) ; int img Height = ( int ) ( mx Utils . get Int ( style , mx Constants . STYLE IMAGE HEIGHT , mx Constants . DEFAULT IMAGESIZE ) * scale ) ; int spacing = ( int ) ( mx Utils . get Int ( style , mx Constants . STYLE SPACING , NUM ) * scale ) ; int img X = x ; if ( img Align . equals ( mx Constants . ALIGN LEFT ) ) { img X += spacing ; } else if ( img Align . equals ( mx Constants . ALIGN RIGHT ) ) { img X += w - img Width - spacing ; } else { img X += ( w - img Width ) / NUM ; } int img Y = y ; if ( img Valign . equals ( mx Constants . ALIGN TOP ) ) { img Y += spacing ; } else if ( img Valign . equals ( mx Constants . ALIGN BOTTOM ) ) { img Y += h - img Height - spacing ; } else { img Y += ( h - img Height ) / NUM ; } draw Image ( img X , img Y , img Width , img Height , img ) ; } } } } }
public Rect guaranteed Safe Crop ( int width , int height , @ Nullable Rect crop ) { if ( crop == null ) { return new Rect ( NUM , NUM , width , height ) ; } Rect safe Crop = new Rect ( crop ) ; if ( crop . top > crop . bottom || crop . left > crop . right || crop . width ( ) <= NUM || crop . height ( ) <= NUM ) { return new Rect ( NUM , NUM , NUM , NUM ) ; } safe Crop . left = Math . max ( safe Crop . left , NUM ) ; safe Crop . top = Math . max ( safe Crop . top , NUM ) ; safe Crop . right = Math . max ( Math . min ( safe Crop . right , width ) , safe Crop . left ) ; safe Crop . bottom = Math . max ( Math . min ( safe Crop . bottom , height ) , safe Crop . top ) ; if ( safe Crop . width ( ) <= NUM || safe Crop . height ( ) <= NUM ) { return new Rect ( NUM , NUM , NUM , NUM ) ; } return safe Crop ; }
@ Override public void flush ( ) throws IO Exception { Output Stream output = m streams . get ( ) ; if ( null != output ) { output . flush ( ) ; } }
private static void quick Sort 1 ( double x [ ] , int off , int len , Double Comparator comp ) { if ( len < SMALL ) { for ( int i = off ; i < len + off ; i ++ ) for ( int j = i ; j > off && comp . compare ( x [ j - NUM ] , x [ j ] ) > NUM ; j -- ) swap ( x , j , j - NUM ) ; return ; } int m = off + len / NUM ; if ( len > SMALL ) { int l = off ; int n = off + len - NUM ; if ( len > MEDIUM ) { int s = len / NUM ; l = med 3 ( x , l , l + s , l + NUM * s , comp ) ; m = med 3 ( x , m - s , m , m + s , comp ) ; n = med 3 ( x , n - NUM * s , n - s , n , comp ) ; } m = med 3 ( x , l , m , n , comp ) ; } double v = x [ m ] ; int a = off , b = a , c = off + len - NUM , d = c ; while ( BOOL ) { int comparison ; while ( b <= c && ( comparison = comp . compare ( x [ b ] , v ) ) <= NUM ) { if ( comparison == NUM ) swap ( x , a ++ , b ) ; b ++ ; } while ( c >= b && ( comparison = comp . compare ( x [ c ] , v ) ) >= NUM ) { if ( comparison == NUM ) swap ( x , c , d -- ) ; c -- ; } if ( b > c ) break ; swap ( x , b ++ , c -- ) ; } int s , n = off + len ; s = Math . min ( a - off , b - a ) ; vecswap ( x , off , b - s , s ) ; s = Math . min ( d - c , n - d - NUM ) ; vecswap ( x , b , n - s , s ) ; if ( ( s = b - a ) > NUM ) quick Sort 1 ( x , off , s , comp ) ; if ( ( s = d - c ) > NUM ) quick Sort 1 ( x , n - s , s , comp ) ; }
public static double distance ( double lat 1 , double lat 2 , double lon 1 , double lon 2 , double el 1 , double el 2 ) { final int R = NUM ; Double lat Distance = deg 2 rad ( lat 2 - lat 1 ) ; Double lon Distance = deg 2 rad ( lon 2 - lon 1 ) ; Double a = Math . sin ( lat Distance / NUM ) * Math . sin ( lat Distance / NUM ) + Math . cos ( deg 2 rad ( lat 1 ) ) * Math . cos ( deg 2 rad ( lat 2 ) ) * Math . sin ( lon Distance / NUM ) * Math . sin ( lon Distance / NUM ) ; Double c = NUM * Math . atan 2 ( Math . sqrt ( a ) , Math . sqrt ( NUM - a ) ) ; double distance = R * c * NUM ; double height = el 1 - el 2 ; distance = Math . pow ( distance , NUM ) + Math . pow ( height , NUM ) ; return Math . sqrt ( distance ) ; }
public static final boolean sq Attacked ( Position pos , int sq ) { int x = Position . get X ( sq ) ; int y = Position . get Y ( sq ) ; boolean is White Move = pos . white Move ; final int o Queen = is White Move ? Piece . BQUEEN : Piece . WQUEEN ; final int o Rook = is White Move ? Piece . BROOK : Piece . WROOK ; final int o Bish = is White Move ? Piece . BBISHOP : Piece . WBISHOP ; final int o Knight = is White Move ? Piece . BKNIGHT : Piece . WKNIGHT ; int p ; if ( y > NUM ) { p = check Direction ( pos , sq , y , - NUM ) ; if ( ( p == o Queen ) || ( p == o Rook ) ) return BOOL ; p = check Direction ( pos , sq , Math . min ( x , y ) , - NUM ) ; if ( ( p == o Queen ) || ( p == o Bish ) ) return BOOL ; p = check Direction ( pos , sq , Math . min ( NUM - x , y ) , - NUM ) ; if ( ( p == o Queen ) || ( p == o Bish ) ) return BOOL ; if ( x > NUM ) { p = check Direction ( pos , sq , NUM , - NUM ) ; if ( p == o Knight ) return BOOL ; } if ( x > NUM && y > NUM ) { p = check Direction ( pos , sq , NUM , - NUM ) ; if ( p == o Knight ) return BOOL ; } if ( x < NUM && y > NUM ) { p = check Direction ( pos , sq , NUM , - NUM ) ; if ( p == o Knight ) return BOOL ; } if ( x < NUM ) { p = check Direction ( pos , sq , NUM , - NUM ) ; if ( p == o Knight ) return BOOL ; } if ( ! is White Move ) { if ( x < NUM && y > NUM ) { p = check Direction ( pos , sq , NUM , - NUM ) ; if ( p == Piece . WPAWN ) return BOOL ; } if ( x > NUM && y > NUM ) { p = check Direction ( pos , sq , NUM , - NUM ) ; if ( p == Piece . WPAWN ) return BOOL ; } } } if ( y < NUM ) { p = check Direction ( pos , sq , NUM - y , NUM ) ; if ( ( p == o Queen ) || ( p == o Rook ) ) return BOOL ; p = check Direction ( pos , sq , Math . min ( NUM - x , NUM - y ) , NUM ) ; if ( ( p == o Queen ) || ( p == o Bish ) ) return BOOL ; p = check Direction ( pos , sq , Math . min ( x , NUM - y ) , NUM ) ; if ( ( p == o Queen ) || ( p == o Bish ) ) return BOOL ; if ( x < NUM ) { p = check Direction ( pos , sq , NUM , NUM ) ; if ( p == o Knight ) return BOOL ; } if ( x < NUM && y < NUM ) { p = check Direction ( pos , sq , NUM , NUM ) ; if ( p == o Knight ) return BOOL ; } if ( x > NUM && y < NUM ) { p = check Direction ( pos , sq , NUM , NUM ) ; if ( p == o Knight ) return BOOL ; } if ( x > NUM ) { p = check Direction ( pos , sq , NUM , NUM ) ; if ( p == o Knight ) return BOOL ; } if ( is White Move ) { if ( x < NUM && y < NUM ) { p = check Direction ( pos , sq , NUM , NUM ) ; if ( p == Piece . BPAWN ) return BOOL ; } if ( x > NUM && y < NUM ) { p = check Direction ( pos , sq , NUM , NUM ) ; if ( p == Piece . BPAWN ) return BOOL ; } } } p = check Direction ( pos , sq , NUM - x , NUM ) ; if ( ( p == o Queen ) || ( p == o Rook ) ) return BOOL ; p = check Direction ( pos , sq , x , - NUM ) ; if ( ( p == o Queen ) || ( p == o Rook ) ) return BOOL ; int o King Sq = pos . get King Sq ( ! is White Move ) ; if ( o King Sq >= NUM ) { int ox = Position . get X ( o King Sq ) ; int oy = Position . get Y ( o King Sq ) ; if ( ( Math . abs ( x - ox ) <= NUM ) && ( Math . abs ( y - oy ) <= NUM ) ) return BOOL ; } return BOOL ; }
public boolean put Register Content ( int register Number , String content ) { try { registers [ register Number ] = Double . parse Double ( content ) ; } catch ( Number Format Exception nfe ) { return BOOL ; } return BOOL ; }
private void add ( Session ID session ID ) { remote Session Set . add ( session ID ) ; }
final protected void fire Dirty Event ( ) { assert Not Read Only ( ) ; final I Dirty Listener l = this . listener ; if ( l == null ) return ; if ( Thread . interrupted ( ) ) { throw new Runtime Exception ( new Interrupted Exception ( ) ) ; } l . dirty Event ( this ) ; }
final static String HMAC MD 5 ( byte [ ] key , byte [ ] text ) throws No Such Algorithm Exception { Message Digest md 5 = Message Digest . get Instance ( STRING ) ; if ( key . length > MD 5 BLOCKSIZE ) { key = md 5 . digest ( key ) ; } byte [ ] ipad = new byte [ MD 5 BLOCKSIZE ] ; byte [ ] opad = new byte [ MD 5 BLOCKSIZE ] ; byte [ ] digest ; int i ; for ( i = NUM ; i < key . length ; i ++ ) { ipad [ i ] = key [ i ] ; opad [ i ] = key [ i ] ; } for ( i = NUM ; i < MD 5 BLOCKSIZE ; i ++ ) { ipad [ i ] ^= NUM ; opad [ i ] ^= NUM ; } md 5 . update ( ipad ) ; md 5 . update ( text ) ; digest = md 5 . digest ( ) ; md 5 . update ( opad ) ; md 5 . update ( digest ) ; digest = md 5 . digest ( ) ; String Buffer digest String = new String Buffer ( ) ; for ( i = NUM ; i < digest . length ; i ++ ) { if ( ( digest [ i ] & NUM ) < NUM ) { digest String . append ( STRING + Integer . to Hex String ( digest [ i ] & NUM ) ) ; } else { digest String . append ( Integer . to Hex String ( digest [ i ] & NUM ) ) ; } } Arrays . fill ( ipad , ( byte ) NUM ) ; Arrays . fill ( opad , ( byte ) NUM ) ; ipad = null ; opad = null ; return ( digest String . to String ( ) ) ; }
public boolean ends With ( String string ) { if ( string == null ) return BOOL ; int strlen = string . length ( ) ; if ( length < strlen ) return BOOL ; char [ ] buffer = buffer ; int offset = offset + length - strlen ; while ( -- strlen >= NUM ) { if ( buffer [ offset + strlen ] != string . char At ( strlen ) ) return BOOL ; } return BOOL ; }
public void write Raw Bytes ( final byte [ ] value , int offset , int length ) throws IO Exception { if ( limit - position >= length ) { System . arraycopy ( value , offset , buffer , position , length ) ; position += length ; total Bytes Written += length ; } else { final int bytes Written = limit - position ; System . arraycopy ( value , offset , buffer , position , bytes Written ) ; offset += bytes Written ; length -= bytes Written ; position = limit ; total Bytes Written += bytes Written ; refresh Buffer ( ) ; if ( length <= limit ) { System . arraycopy ( value , offset , buffer , NUM , length ) ; position = length ; } else { output . write ( value , offset , length ) ; } total Bytes Written += length ; } }
public void add Src Class ( Soot Class clz ) { src Classes . add ( clz . get Name ( ) ) ; }
public static Change Record value Of LDIF Change Record ( final String ... ldif Lines ) { try ( final LDIF Change Record Reader reader = new LDIF Change Record Reader ( ldif Lines ) ) { if ( ! reader . has Next ( ) ) { final Localizable Message message = WARN READ LDIF RECORD NO CHANGE RECORD FOUND . get ( ) ; throw new Localized Illegal Argument Exception ( message ) ; } final Change Record record = reader . read Change Record ( ) ; if ( reader . has Next ( ) ) { final Localizable Message message = WARN READ LDIF RECORD MULTIPLE CHANGE RECORDS FOUND . get ( ) ; throw new Localized Illegal Argument Exception ( message ) ; } return record ; } catch ( final Decode Exception e ) { throw new Localized Illegal Argument Exception ( e . get Message Object ( ) ) ; } catch ( final IO Exception e ) { final Localizable Message message = WARN READ LDIF RECORD UNEXPECTED IO ERROR . get ( e . get Message ( ) ) ; throw new Localized Illegal Argument Exception ( message ) ; } }
public static void add Col Times ( Matrix matrix , long diag , long from Row , long col , double factor ) { long rows = matrix . get Row Count ( ) ; for ( long row = from Row ; row < rows ; row ++ ) { matrix . set As Double ( matrix . get As Double ( row , col ) - factor * matrix . get As Double ( row , diag ) , row , col ) ; } }
void release If Locked ( Object name , Internal Distributed Member owner , int lock Id ) throws Interrupted Exception { wait While Initializing ( ) ; if ( ! acquire Destroy Read Lock ( NUM ) ) { wait Until Destroyed ( ) ; check Destroyed ( ) ; } try { check Destroyed ( ) ; get And Release Grant If Locked By ( name , owner , lock Id ) ; } finally { release Destroy Read Lock ( ) ; } }
public final Array List < Wifi Record > load Wifis Overview Within ( final int session , final Double min Lon , final Double max Lon , final Double min Lat , final Double max Lat ) { final Array List < Wifi Record > wifis = new Array List < > ( ) ; String selection = null ; String [ ] selection Args = null ; if ( min Lon != null && max Lon != null && min Lat != null && max Lat != null ) { selection = STRING + Schema . COL LONGITUDE + STRING + STRING + Schema . COL LONGITUDE + STRING + STRING + Schema . COL LATITUDE + STRING + STRING + Schema . COL LATITUDE + STRING ; selection Args = new String [ ] { String . value Of ( min Lon ) , String . value Of ( max Lon ) , String . value Of ( min Lat ) , String . value Of ( max Lat ) } ; } final Cursor cursor = content Resolver . query ( Content Uris . with Appended Id ( Uri . with Appended Path ( Content Provider . CONTENT URI WIFI , Content Provider . CONTENT URI OVERVIEW SUFFIX ) , session ) , null , selection , selection Args , null ) ; final int column Index = cursor . get Column Index ( Schema . COL BSSID ) ; final int column Index 2 = cursor . get Column Index ( Schema . COL SSID ) ; final int column Index 3 = cursor . get Column Index ( Schema . COL CAPABILITIES ) ; final int column Index 4 = cursor . get Column Index ( Schema . COL FREQUENCY ) ; final int column Index 5 = cursor . get Column Index ( Schema . COL MAX LEVEL ) ; final int column Index 6 = cursor . get Column Index ( Schema . COL TIMESTAMP ) ; final int column Index 7 = cursor . get Column Index ( Schema . COL BEGIN POSITION ID ) ; final int column Index 8 = cursor . get Column Index ( Schema . COL END POSITION ID ) ; final int column Index 9 = cursor . get Column Index ( Schema . COL KNOWN WIFI ) ; while ( cursor . move To Next ( ) ) { final Wifi Record wifi = new Wifi Record ( ) ; wifi . set Bssid ( cursor . get String ( column Index ) ) ; wifi . set Ssid ( cursor . get String ( column Index 2 ) ) ; wifi . set Capabilities ( cursor . get String ( column Index 3 ) ) ; wifi . set Frequency ( cursor . get Int ( column Index 4 ) ) ; wifi . set Level ( cursor . get Int ( column Index 5 ) ) ; wifi . set Open Bmap Timestamp ( cursor . get Long ( column Index 6 ) ) ; wifi . set Begin Position ( load Position By Id ( cursor . get String ( column Index 7 ) ) ) ; wifi . set End Position ( load Position By Id ( cursor . get String ( column Index 8 ) ) ) ; wifi . set Catalog Status ( Catalog Status . values ( ) [ cursor . get Int ( column Index 9 ) ] ) ; wifis . add ( wifi ) ; } cursor . close ( ) ; return wifis ; }
private void update Locations ( ) { log . debug ( STRING ) ; remove Property Change Locations ( ) ; track Check Box List . clear ( ) ; int x = NUM ; p Locations . remove All ( ) ; String type = ( String ) type Combo Box . get Selected Item ( ) ; String load = ( String ) load Combo Box . get Selected Item ( ) ; log . debug ( STRING , type , load ) ; if ( location != null && location Manager . get Location By Name ( location . get Name ( ) ) == null ) { location = null ; } List < Location > locations = location Manager . get Locations By Name List ( ) ; for ( Location location : locations ) { if ( location != null && location != location ) { continue ; } location . add Property Change Listener ( this ) ; J Label location Name = new J Label ( location . get Name ( ) ) ; add Item Left ( p Locations , location Name , NUM , x ++ ) ; List < Track > tracks = location . get Track By Name List ( null ) ; for ( Track track : tracks ) { track . add Property Change Listener ( this ) ; J Check Box cb = new J Check Box ( track . get Name ( ) ) ; cb . set Name ( track . get Id ( ) + STRING + STRING ) ; add Check Box Action ( cb ) ; track Check Box List . add ( cb ) ; cb . set Enabled ( track . accepts Type Name ( type ) ) ; cb . set Selected ( track . accepts Load ( load , type ) ) ; add Item Left ( p Locations , cb , NUM , x ++ ) ; if ( cb . is Enabled ( ) ) { cb . set Tool Tip Text ( Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { load } ) ) ; } else { cb . set Tool Tip Text ( Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { type } ) ) ; } } if ( location . is Staging ( ) ) { J Label ships = new J Label ( location . get Name ( ) + STRING + Bundle . get Message ( STRING ) + STRING ) ; add Item Left ( p Locations , ships , NUM , x ++ ) ; for ( Track track : tracks ) { J Check Box cb = new J Check Box ( track . get Name ( ) ) ; cb . set Name ( track . get Id ( ) + STRING + STRING ) ; add Check Box Action ( cb ) ; track Check Box List . add ( cb ) ; cb . set Enabled ( track . accepts Type Name ( type ) ) ; cb . set Selected ( track . ships Load ( load , type ) ) ; add Item Left ( p Locations , cb , NUM , x ++ ) ; if ( cb . is Enabled ( ) ) { cb . set Tool Tip Text ( Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { load } ) ) ; } else { cb . set Tool Tip Text ( Message Format . format ( Bundle . get Message ( STRING ) , new Object [ ] { type } ) ) ; } } } } p Locations . revalidate ( ) ; repaint ( ) ; }
private boolean update Locked ( ) { boolean is Active = BOOL ; long next Retry Time Millis = Long . MAX VALUE ; long now = system Facade . current Time Millis ( ) ; Collection < File Download Info > all Downloads = downloads Repository . get All Downloads ( ) ; update Total Bytes For ( all Downloads ) ; List < Download Batch > download Batches = batch Repository . retrieve Batches For ( all Downloads ) ; for ( Download Batch download Batch : download Batches ) { if ( download Batch . is Active ( ) ) { is Active = BOOL ; break ; } } for ( Download Batch download Batch : download Batches ) { if ( download Batch . is Deleted ( ) || download Batch . prune ( download Deleter ) ) { continue ; } if ( ! is Active && download Ready Checker . can Download ( download Batch ) ) { boolean is Batch Starting For The First Time = batch Repository . is Batch Starting For The First Time ( download Batch . get Batch Id ( ) ) ; if ( is Batch Starting For The First Time ) { handle Batch Starting For The First Time ( download Batch ) ; } download Or Continue Batch ( download Batch . get Downloads ( ) ) ; is Active = BOOL ; } else if ( download Batch . scan Completed Media If Ready ( download Scanner ) ) { is Active = BOOL ; } next Retry Time Millis = download Batch . next Action Millis ( now , next Retry Time Millis ) ; } batch Repository . delete Marked Batches For ( all Downloads ) ; update User Visible Notification ( download Batches ) ; if ( next Retry Time Millis > NUM && next Retry Time Millis < Long . MAX VALUE ) { L Log . v ( STRING + next Retry Time Millis + STRING ) ; Intent intent = new Intent ( Constants . ACTION RETRY ) ; intent . set Class ( this , Download Receiver . class ) ; alarm Manager . set ( Alarm Manager . RTC WAKEUP , now + next Retry Time Millis , Pending Intent . get Broadcast ( this , NUM , intent , Pending Intent . FLAG ONE SHOT ) ) ; } if ( ! is Active ) { move Submitted Tasks To Batch Status If Necessary ( ) ; } return is Active ; }
public static Job Definition retryable Cron Job Definition ( final String job Type , final String job Name , final String description , final String cron , final int restarts , final int retries , final Duration retry Delay , final Optional < Duration > max Age ) { return new Default Job Definition ( job Type , job Name , description , max Age , Optional . empty ( ) , Optional . of ( cron ) , restarts , retries , Optional . of ( retry Delay ) ) ; }
public static Fields find By Thrift Id ( int field Id ) { switch ( field Id ) { case NUM : return MESSAGE ; case NUM : return TYPE ; default : return null ; } }
public static void put Double ( long addr , double val ) { if ( UNALIGNED ) UNSAFE . put Double ( addr , val ) ; else put Long By Byte ( addr , Double . double To Long Bits ( val ) , BIG ENDIAN ) ; }
public static J Cas run Test ( String a Document Id , Analysis Engine a Engine , String a Language , String a Document ) throws UIMA Exception { if ( offline ) { System . set Property ( Resource Object Provider Base . PROP REPO OFFLINE , STRING ) ; } offline = BOOL ; J Cas jcas = a Engine . new J Cas ( ) ; if ( a Document Id != null ) { Document Meta Data meta = Document Meta Data . create ( jcas ) ; meta . set Document Id ( a Document Id ) ; } jcas . set Document Language ( a Language ) ; Token Builder < Token , Sentence > tb = new Token Builder < Token , Sentence > ( Token . class , Sentence . class ) ; tb . build Tokens ( jcas , a Document ) ; a Engine . process ( jcas ) ; Assert Annotations . assert Valid ( jcas ) ; return jcas ; }
public org . w3 c . dom . Element sign XML ( org . w3 c . dom . Document doc , java . lang . String cert Alias , java . lang . String algorithm , java . util . List ids ) throws XML Signature Exception { return sign XML ( doc , cert Alias , algorithm , null , ids ) ; }
private Scrollable J Popup Menu create Content Assist Popup ( final J Formatted Text Field field , final List < String > possible Values , final boolean multiple Values Allowed , final Class < ? extends Cell Type > cell Class ) { final Scrollable J Popup Menu popup Menu = new Scrollable J Popup Menu ( Scrollable J Popup Menu . SIZE SMALL ) ; popup Menu . set Background ( Color . WHITE ) ; popup Menu . set Custom Width ( field . get Width ( ) ) ; if ( possible Values == null || possible Values . size ( ) <= NUM ) { J Menu Item empty Item = new J Menu Item ( I18 N . get Message ( I18 N . get GUI Bundle ( ) , STRING ) ) ; empty Item . set Tool Tip Text ( I18 N . get Message ( I18 N . get GUI Bundle ( ) , STRING ) ) ; empty Item . set Opaque ( BOOL ) ; popup Menu . add ( empty Item ) ; return popup Menu ; } if ( multiple Values Allowed ) { fill Multiple Values Selection Popup ( field , possible Values , popup Menu , cell Class ) ; } else { fill Single Value Selection Popup ( field , possible Values , popup Menu , cell Class ) ; } return popup Menu ; }
public Index File ( final File dir ) throws IO Exception { m Preread Arm = Preread Arm . UNKNOWN ; m Preread Type = Preread Type . UNKNOWN ; m Sdf Id = new Sdf Id ( NUM ) ; final File index = new File ( dir , Sdf File Utils . INDEX FILENAME ) ; try ( Data Input Stream index Stream = new Data Input Stream ( new Buffered Input Stream ( new File Input Stream ( index ) , File Utils . BUFFERED STREAM SIZE ) ) ) { final Preread Hash Function header Hash = new Preread Hash Function ( ) ; version 1 Load ( index Stream , header Hash , dir ) ; if ( m Version > VERSION ) { throw new No Talkback Slim Exception ( STRING + dir . to String ( ) + STRING ) ; } load Version 3 Fields ( index Stream , header Hash ) ; load Version 4 Fields ( index Stream , header Hash , dir ) ; load Version 6 Fields ( index Stream , header Hash ) ; load Version 8 Fields ( index Stream , header Hash ) ; load Version 9 Fields ( ) ; load Version 10 Fields ( index Stream , header Hash ) ; load Version 12 Fields ( index Stream , header Hash ) ; load Version 13 Fields ( index Stream , header Hash ) ; checksum Load ( index Stream , header Hash , dir ) ; } catch ( final EOF Exception e ) { throw new Corrupt Sdf Exception ( dir ) ; } }
public boolean correct Heat Sinks ( String Buffer buff ) { if ( ( aero . get Heat Type ( ) != Aero . HEAT SINGLE ) && ( aero . get Heat Type ( ) != Aero . HEAT DOUBLE ) ) { buff . append ( STRING + Aero . HEAT SINGLE + STRING + Aero . HEAT DOUBLE + STRING + aero . get Heat Type ( ) + STRING ) ; } if ( aero . get Entity Type ( ) == Entity . ETYPE CONV FIGHTER ) { int max Weap Heat = count Heat Energy Weapons ( ) ; int heat Dissipation = NUM ; if ( aero . get Heat Type ( ) == Aero . HEAT DOUBLE ) { buff . append ( STRING + STRING ) ; return BOOL ; } heat Dissipation = aero . get Heat Sinks ( ) ; if ( max Weap Heat > heat Dissipation ) { buff . append ( STRING + STRING + STRING + max Weap Heat + STRING + heat Dissipation ) ; return BOOL ; } else { return BOOL ; } } else { return BOOL ; } }
private void filter By Context Tenant ( List < Virtual Array Rest Rep > input Arrays , List < Virtual Array Rest Rep > virtual Arrays By Tenant ) { Iterator < Virtual Array Rest Rep > iterator = input Arrays . iterator ( ) ; while ( iterator . has Next ( ) ) { Virtual Array Rest Rep rep = iterator . next ( ) ; if ( ! contains ( rep . get Id ( ) , virtual Arrays By Tenant ) ) { iterator . remove ( ) ; } } }
public void add Action Listener ( Action Listener al ) { if ( back Button != null && forward Button != null ) { back Button . add Action Listener ( al ) ; forward Button . add Action Listener ( al ) ; } else { if ( listeners == null ) { listeners = new Vector ( ) ; } listeners . add ( al ) ; } }
@ Deprecated public Shapeless Recipe remove Ingredient ( int count , Material ingredient , int rawdata ) { Iterator < Item Stack > iterator = ingredients . iterator ( ) ; while ( count > NUM && iterator . has Next ( ) ) { Item Stack stack = iterator . next ( ) ; if ( stack . get Type ( ) == ingredient && stack . get Durability ( ) == rawdata ) { iterator . remove ( ) ; count -- ; } } return this ; }
private Order apply Order By ( ) { final String order By = sord == null ? ord : sord ; final String order By Field = sidx == null ? search Field : sidx ; if ( order By . equals ( STRING ) ) return Order . asc ( order By Field ) ; else return Order . desc ( order By Field ) ; }
public void add String ( String s , String encoding ) { if ( encoding == null || encoding . equals ( STRING ) ) { add String ( s ) ; return ; } byte [ ] bytes = null ; try { bytes = s . get Bytes ( encoding ) ; } catch ( Unsupported Encoding Exception e ) { add String ( s ) ; return ; } int len = bytes . length ; if ( len + length > capacity ) ensure Capacity ( length + len ) ; for ( int i = NUM ; i < len ; i ++ ) buffer [ length ++ ] = bytes [ i ] ; }
public static boolean looks Like ABG Position ( String val ) { return BACKGROUND POSITIONS IDENTS . contains ( val ) || looks Like A Length ( val ) ; }
public int execute Process ( ) { final List < String > process Strings = tokenize String ( exec Command ) ; process Strings . add All ( tokenize String ( script ) ) ; logger . info ( Message Format . format ( STRING , process Strings ) ) ; final Process Builder process Builder = new Process Builder ( process Strings ) ; if ( working Directory != null ) { final Path dir = Paths . get ( working Directory ) ; if ( Files . not Exists ( dir ) ) { try { Files . create Directories ( dir ) ; } catch ( IO Exception e ) { logger . warning ( STRING + working Directory ) ; return - NUM ; } } else if ( ! Files . is Directory ( dir ) ) { logger . warning ( working Directory + STRING ) ; return - NUM ; } final File directory = dir . to File ( ) ; process Builder . directory ( directory ) ; } process Builder . redirect Error Stream ( BOOL ) ; Integer exit Value ; try { logger . info ( STRING ) ; final Process process = process Builder . start ( ) ; send Input String To Process ( process ) ; handle Process Output ( process ) ; try { exit Value = process . wait For ( ) ; } catch ( Interrupted Exception e ) { logger . warning ( STRING ) ; process . destroy ( ) ; exit Value = - NUM ; } logger . info ( STRING + exit Value + STRING ) ; } catch ( IO Exception e ) { logger . log ( SEVERE , STRING , e . get Cause ( ) ) ; exit Value = - NUM ; } return exit Value ; }
private void handle SAML 2 Metadata ( String file Name ) { String meta File = fedlet Home Dir + File . separator + file Name + STRING ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + meta File ) ; } String meta XML = open File ( meta File ) ; if ( meta XML == null ) { return ; } meta XML = workaround Abstract Role Descriptor ( meta XML ) ; String entity Id = get Entity ID ( meta XML ) ; if ( entity Id == null ) { return ; } Map map = new Hash Map ( ) ; Set set = new Hash Set ( ) ; set . add ( meta XML ) ; map . put ( STRING , set ) ; String ext File = fedlet Home Dir + File . separator + file Name + EXTENDED XML SUFFIX ; String ext XML = open File ( ext File ) ; if ( ext XML == null ) { return ; } set = new Hash Set ( ) ; set . add ( ext XML ) ; map . put ( STRING , set ) ; entity Map . put ( entity Id , map ) ; if ( debug . message Enabled ( ) ) { debug . message ( STRING + STRING + entity Id ) ; } }
private Matches lookup Do ( Template tmpl , int max Matches ) { if ( max Matches < NUM ) throw new Illegal Argument Exception ( STRING ) ; int total Matches = NUM ; Array List < Item > matches = null ; Item Iter iter = matching Items ( tmpl ) ; if ( max Matches > NUM || iter . dups Possible ) { int suggested Size = iter . suggested Size ( ) ; suggested Size = max Matches < suggested Size ? max Matches : suggested Size ; matches = new Array List < Item > ( suggested Size ) ; } if ( iter . dups Possible ) { while ( iter . has Next ( ) ) { Item item = iter . next ( ) ; if ( ! matches . contains ( item ) ) matches . add ( item ) ; } total Matches = matches . size ( ) ; if ( max Matches > NUM ) { for ( int i = matches . size ( ) ; -- i >= max Matches ; ) matches . remove ( i ) ; for ( int i = matches . size ( ) ; -- i >= NUM ; ) { matches . set ( i , copy Item ( matches . get ( i ) ) ) ; } } else { matches = null ; } } else { while ( iter . has Next ( ) ) { Item item = iter . next ( ) ; total Matches ++ ; if ( -- max Matches >= NUM ) matches . add ( copy Item ( item ) ) ; } } return new Matches ( matches , total Matches ) ; }
public static List < History > find History By Job And Status ( Entity Manager em , JPA Entity job , Big Integer limit , Job Status job Status ) { require Argument ( em != null , STRING ) ; require Argument ( job != null , STRING ) ; Typed Query < History > query = em . create Named Query ( STRING , History . class ) ; if ( limit != null ) { query . set Max Results ( limit . int Value ( ) ) ; } try { query . set Parameter ( STRING , job ) ; query . set Parameter ( STRING , job Status ) ; return query . get Result List ( ) ; } catch ( No Result Exception ex ) { return new Array List < History > ( NUM ) ; } }
protected boolean is WFXML Char ( String chardata , Character ref Invalid Char ) { if ( chardata == null || ( chardata . length ( ) == NUM ) ) { return BOOL ; } char [ ] dataarray = chardata . to Char Array ( ) ; int datalength = dataarray . length ; if ( f Is XML Version 11 ) { int i = NUM ; while ( i < datalength ) { if ( XML 11 Char . is XML 11 Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM ] ; if ( XML Char . is High Surrogate ( ch ) && i < datalength ) { char ch 2 = dataarray [ i ++ ] ; if ( XML Char . is Low Surrogate ( ch 2 ) && XML Char . is Supplemental ( XML Char . supplemental ( ch , ch 2 ) ) ) { continue ; } } ref Invalid Char = new Character ( ch ) ; return BOOL ; } } } else { int i = NUM ; while ( i < datalength ) { if ( XML Char . is Invalid ( dataarray [ i ++ ] ) ) { char ch = dataarray [ i - NUM ] ; if ( XML Char . is High Surrogate ( ch ) && i < datalength ) { char ch 2 = dataarray [ i ++ ] ; if ( XML Char . is Low Surrogate ( ch 2 ) && XML Char . is Supplemental ( XML Char . supplemental ( ch , ch 2 ) ) ) { continue ; } } ref Invalid Char = new Character ( ch ) ; return BOOL ; } } } return BOOL ; }
void update Pending Nodes ( final int new Landmark Index , final Node to Node , final Router Priority Queue < Node > pending Nodes ) { Iterator < Node > it = pending Nodes . iterator ( ) ; Pre Process Landmarks . Landmarks Data to Role = get Pre Process Data ( to Node ) ; Array List < Double > new Est Rem Trav Costs = new Array List < Double > ( ) ; Array List < Node > nodes To Be Updated = new Array List < Node > ( ) ; while ( it . has Next ( ) ) { Node node = it . next ( ) ; A Star Node Data role = get Data ( node ) ; Pre Process Landmarks . Landmarks Data pp Role = get Pre Process Data ( node ) ; double est Rem Trav Cost = role . get Expected Remaining Cost ( ) ; double new Est Rem Trav Cost = estimate Remaining Travel Cost ( pp Role , to Role , new Landmark Index ) ; if ( new Est Rem Trav Cost > est Rem Trav Cost ) { nodes To Be Updated . add ( node ) ; new Est Rem Trav Costs . add ( new Est Rem Trav Cost ) ; } } for ( Node node : nodes To Be Updated ) { pending Nodes . remove ( node ) ; } for ( int i = NUM ; i < nodes To Be Updated . size ( ) ; i ++ ) { Node node = nodes To Be Updated . get ( i ) ; A Star Node Data data = get Data ( node ) ; data . set Expected Remaining Cost ( new Est Rem Trav Costs . get ( i ) ) ; pending Nodes . add ( node , get Priority ( data ) ) ; } }
public static String convert String To Html ( String s ) { if ( s == null ) { return null ; } if ( s . length ( ) == NUM ) { return s ; } String Builder buff = new String Builder ( ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char ch = s . char At ( i ) ; String token = CODE MAP . get ( ch ) ; if ( token == null ) { if ( ch < NUM ) { buff . append ( ch ) ; } else { buff . append ( STRING ) ; buff . append ( STRING ) ; buff . append ( ( int ) ch ) ; buff . append ( STRING ) ; } } else { buff . append ( STRING ) ; buff . append ( token ) ; buff . append ( STRING ) ; } } return buff . to String ( ) ; }
private void draw Overflow Indicator ( final Workflow Annotation anno , final Graphics 2 D g , final Rectangle 2 D loc , final boolean printing ) { if ( printing ) { return ; } Graphics 2 D g2 = ( Graphics 2 D ) g . create ( ) ; int size = NUM ; int x Offset = NUM ; int y Offset = NUM ; int step Size = size / NUM ; int dot Size = NUM ; int x = ( int ) loc . get Max X ( ) - size - x Offset ; int y = ( int ) loc . get Max Y ( ) - size - y Offset ; Gradient Paint gp = new Gradient Paint ( x , y , Color . WHITE , x , y + size * NUM , Color . LIGHT GRAY ) ; g2 . set Paint ( gp ) ; g2 . fill Rect ( x , y , size , size ) ; g2 . set Color ( Color . BLACK ) ; g2 . draw Rect ( x , y , size , size ) ; g2 . fill Oval ( x + step Size , y + step Size * NUM , dot Size , dot Size ) ; g2 . fill Oval ( x + step Size * NUM , y + step Size * NUM , dot Size , dot Size ) ; g2 . fill Oval ( x + step Size * NUM , y + step Size * NUM , dot Size , dot Size ) ; g2 . dispose ( ) ; }
public void write Line ( long time , double [ ] column ) { String str = Long . to String ( time ) ; for ( int i = NUM ; i < column . length ; ++ i ) { str += STRING + column [ i ] ; } writer . println ( str ) ; }
public static boolean is PEM ( byte [ ] byte Array ) { try { String start PEM = STRING ; int header Length = NUM ; byte [ ] preamble = new byte [ header Length ] ; System . arraycopy ( byte Array , NUM , preamble , NUM , header Length ) ; String start Array = new String ( preamble ) ; return start Array . starts With ( start PEM ) ; } catch ( Exception e ) { throw new DSS Exception ( STRING ) ; } }
public Weak Close Listener ( Object resource ) { resource Ref = new Weak Reference < Object > ( resource ) ; }
@ Override public Delete Request routing ( String routing ) { if ( routing != null && routing . length ( ) == NUM ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
public byte [ ] receive ( ) throws IO Exception { if ( connection != null ) { packet . set Length ( Datagram Connection . DEFAULT DATAGRAM SIZE ) ; connection . receive ( packet ) ; int packet Length = packet . get Length ( ) ; byte [ ] data = new byte [ packet Length ] ; System . arraycopy ( packet . get Data ( ) , NUM , data , NUM , packet Length ) ; return data ; } else { throw new IO Exception ( STRING ) ; } }
@ Override protected void force Insert Attribute At ( int position ) { double [ ] new Values = new double [ m Att Values . length + NUM ] ; System . arraycopy ( m Att Values , NUM , new Values , NUM , position ) ; new Values [ position ] = Utils . missing Value ( ) ; System . arraycopy ( m Att Values , position , new Values , position + NUM , m Att Values . length - position ) ; m Att Values = new Values ; }
public static Priv Key load ( File file , final String password ) throws IO Exception , No Such Algorithm Exception , Invalid Key Spec Exception , No Such Padding Exception , Invalid Key Exception , Invalid Algorithm Parameter Exception , Illegal Block Size Exception , Bad Padding Exception , Invalid Parameter Spec Exception { if ( file . length ( ) < NUM ) throw new Illegal Argument Exception ( STRING ) ; byte [ ] key Data = File Util . read File ( file ) ; return load ( key Data , password ) ; }
public static boolean create Server Instance ( SSO Token sso Token , String instance Name , String instance Id , Set values , String server Config XML ) throws SMS Exception , SSO Exception , Configuration Exception , Unknown Property Name Exception { boolean created = BOOL ; if ( ! instance Name . equals ( DEFAULT SERVER CONFIG ) ) { validate Property ( sso Token , values ) ; } Service Config sc = get Root Server Config With Retry ( sso Token ) ; if ( sc != null ) { if ( ! instance Name . equals ( DEFAULT SERVER CONFIG ) ) { try { new URL ( instance Name ) ; } catch ( Malformed URL Exception ex ) { String [ ] param = { instance Name } ; throw new Configuration Exception ( STRING , param ) ; } } Map server Values = new Hash Map ( NUM ) ; Set set Server Id = new Hash Set ( NUM ) ; set Server Id . add ( instance Id ) ; server Values . put ( ATTR SERVER ID , set Server Id ) ; if ( values . is Empty ( ) ) { values = new Hash Set ( NUM ) ; } values . add ( Constants . PROPERTY NAME LB COOKIE VALUE + STRING + instance Id ) ; Set set Server Config XML = new Hash Set ( NUM ) ; set Server Config XML . add ( server Config XML ) ; server Values . put ( ATTR SERVER CONFIG XML , set Server Config XML ) ; server Values . put ( ATTR SERVER CONFIG , values ) ; if ( ! instance Name . equals ( DEFAULT SERVER CONFIG ) ) { set Protocol Host Port URI ( server Values , instance Name ) ; } sc . add Sub Config ( instance Name , SUBSCHEMA SERVER , NUM , server Values ) ; created = BOOL ; } if ( created && ! instance Name . equals ( DEFAULT SERVER CONFIG ) ) { update Organization Alias ( sso Token , instance Name , BOOL ) ; } return created ; }
void start Scrolling Instance ( ) { if ( log . is Loggable ( Platform Logger . Level . FINER ) ) { log . finer ( STRING + this ) ; } scroll ( ) ; i scroller . set Scrollbar ( this ) ; i scroller . start ( ) ; }
public static Class < ? > load Proxy Class ( String codebase , String [ ] interfaces , Class Loader default Loader ) throws Malformed URL Exception , Class Not Found Exception { if ( loader Log . is Loggable ( Log . BRIEF ) ) { loader Log . log ( Log . BRIEF , STRING + Arrays . as List ( interfaces ) + STRING + STRING + ( codebase != null ? codebase : STRING ) + STRING + ( default Loader != null ? STRING + default Loader : STRING ) ) ; } Class Loader parent = get RMI Context Class Loader ( ) ; if ( loader Log . is Loggable ( Log . VERBOSE ) ) { loader Log . log ( Log . VERBOSE , STRING + parent + STRING ) ; } URL [ ] urls ; if ( codebase != null ) { urls = path To UR Ls ( codebase ) ; } else { urls = get Default Codebase UR Ls ( ) ; } Security Manager sm = System . get Security Manager ( ) ; if ( sm == null ) { try { Class < ? > c = load Proxy Class ( interfaces , default Loader , parent , BOOL ) ; if ( loader Log . is Loggable ( Log . VERBOSE ) ) { loader Log . log ( Log . VERBOSE , STRING + STRING + c . get Class Loader ( ) ) ; } return c ; } catch ( Class Not Found Exception e ) { if ( loader Log . is Loggable ( Log . BRIEF ) ) { loader Log . log ( Log . BRIEF , STRING + STRING , e ) ; } throw new Class Not Found Exception ( e . get Message ( ) + STRING , e . get Exception ( ) ) ; } } Loader loader = lookup Loader ( urls , parent ) ; try { if ( loader != null ) { loader . check Permissions ( ) ; } } catch ( Security Exception e ) { try { Class < ? > c = load Proxy Class ( interfaces , default Loader , parent , BOOL ) ; if ( loader Log . is Loggable ( Log . VERBOSE ) ) { loader Log . log ( Log . VERBOSE , STRING + STRING + c . get Class Loader ( ) ) ; } return c ; } catch ( Class Not Found Exception unimportant ) { if ( loader Log . is Loggable ( Log . BRIEF ) ) { loader Log . log ( Log . BRIEF , STRING + STRING , e ) ; } throw new Class Not Found Exception ( STRING , e ) ; } } try { Class < ? > c = load Proxy Class ( interfaces , default Loader , loader , BOOL ) ; if ( loader Log . is Loggable ( Log . VERBOSE ) ) { loader Log . log ( Log . VERBOSE , STRING + c . get Class Loader ( ) ) ; } return c ; } catch ( Class Not Found Exception e ) { if ( loader Log . is Loggable ( Log . BRIEF ) ) { loader Log . log ( Log . BRIEF , STRING , e ) ; } throw e ; } }
public static List < I Navi Module > load Modules ( final Abstract SQL Provider provider , final List < I Navi Raw Module > raw Modules , final Debugger Template Manager debugger Manager ) throws Couldnt Load Data Exception { Preconditions . check Not Null ( raw Modules , STRING ) ; Postgre SQL Database Functions . check Arguments ( provider , debugger Manager ) ; final List < C Module > modules = new Array List < > ( ) ; final C Connection connection = provider . get Connection ( ) ; if ( ! Postgre SQL Helpers . has Table ( connection , C Table Names . MODULES TABLE ) ) { return new Array List < I Navi Module > ( modules ) ; } final String query = STRING + C Table Names . MODULES TABLE + STRING + STRING + STRING + STRING + C Table Names . FUNCTIONS TABLE + STRING + STRING + C Table Names . FUNCTIONS TABLE + STRING + STRING + STRING + C Table Names . MODULE VIEWS TABLE + STRING + C Table Names . VIEWS TABLE + STRING + STRING + C Table Names . MODULES TABLE + STRING + STRING + C Table Names . MODULES TABLE + STRING + STRING ; try ( Result Set result Set = connection . execute Query ( query , BOOL ) ) { while ( result Set . next ( ) ) { final int module Id = result Set . get Int ( STRING ) ; final String name = Postgre SQL Helpers . read String ( result Set , STRING ) ; final String md 5 = Postgre SQL Helpers . read String ( result Set , STRING ) ; final String sha 1 = Postgre SQL Helpers . read String ( result Set , STRING ) ; final String comment = Postgre SQL Helpers . read String ( result Set , STRING ) ; final Timestamp timestamp = result Set . get Timestamp ( STRING ) ; final Timestamp modification Date = result Set . get Timestamp ( STRING ) ; int function Count = result Set . get Int ( STRING ) ; final int view Count = result Set . get Int ( STRING ) ; final I Address image Base = Postgre SQL Helpers . load Address ( result Set , STRING ) ; final I Address file Base = Postgre SQL Helpers . load Address ( result Set , STRING ) ; final int debugger Id = result Set . get Int ( STRING ) ; final boolean is Stared = result Set . get Boolean ( STRING ) ; final int initialization State = result Set . get Int ( STRING ) ; final Debugger Template description = debugger Manager . find Debugger ( debugger Id ) ; final int raw Module Id = result Set . get Int ( STRING ) ; final I Navi Raw Module raw Module = Postgre SQL Database Functions . find Raw Module ( raw Module Id , raw Modules ) ; if ( ( function Count == NUM ) && ( raw Module != null ) ) { function Count = raw Module . get Function Count ( ) ; } modules . add ( new C Module ( module Id , name , comment , timestamp , modification Date , md 5 , sha 1 , function Count , view Count , file Base , image Base , description , raw Module , initialization State , is Stared , provider ) ) ; } } catch ( final SQL Exception e ) { throw new Couldnt Load Data Exception ( e ) ; } return new Array List < I Navi Module > ( modules ) ; }
void write ( Image Output Stream ios ) throws IO Exception { length = NUM + ( ( data != null ) ? data . length : NUM ) ; write Tag ( ios ) ; if ( data != null ) { ios . write ( data ) ; } }
private static List < List < Trace Register > > load Trace Event Values ( final C Connection connection , final Trace List trace List ) throws SQL Exception { final List < List < Trace Register > > values = new Array List < > ( ) ; final String query = STRING + C Table Names . TRACE EVENT VALUES TABLE + STRING + trace List . get Id ( ) + STRING ; final Result Set result Set = connection . execute Query ( query , BOOL ) ; int current Position = - NUM ; try { List < Trace Register > registers = new Array List < Trace Register > ( ) ; while ( result Set . next ( ) ) { final int position = result Set . get Int ( STRING ) ; if ( position != current Position ) { if ( ! registers . is Empty ( ) ) { values . add ( Lists . new Array List ( registers ) ) ; registers = new Filled List < Trace Register > ( ) ; } current Position = position ; } final String name = Postgre SQL Helpers . read String ( result Set , STRING ) ; final long value = result Set . get Long ( STRING ) ; final byte [ ] memory = result Set . get Bytes ( STRING ) ; registers . add ( new Trace Register ( name , new C Address ( value ) , memory ) ) ; } if ( ! registers . is Empty ( ) ) { values . add ( Lists . new Array List ( registers ) ) ; } } finally { result Set . close ( ) ; } return values ; }
public Named Thread Factory ( String name Prefix ) { this . name Prefix = name Prefix ; delegate = Executors . default Thread Factory ( ) ; }
public void test metric heartbeat uint 32 ( ) { final I Ganglia Metadata Message decl = new Ganglia Metadata Message ( STRING , STRING , BOOL , Ganglia Message Type Enum . UINT 32 , STRING , STRING , Ganglia Slope Enum . unspecified , NUM , NUM , Abstract Metrics . get Map ( I Ganglia Attributes . GROUP CORE , STRING , STRING ) ) ; assert Encode Decode ( null , decl ) ; final I Ganglia Metric Message expected = new Ganglia Metric Message ( Ganglia Message Type Enum . UINT 32 , STRING , STRING , BOOL , STRING , Long . value Of ( NUM ) ) ; final byte [ ] actual Data = assert Encode Decode ( decl , expected ) ; final byte [ ] expected Data = new byte [ ] { NUM , NUM , NUM , - NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , - NUM } ; if ( ! Arrays . equals ( expected Data , actual Data ) ) { fail ( STRING + Arrays . to String ( expected Data ) + STRING + Arrays . to String ( actual Data ) ) ; } }
@ Override public void delete Columns ( int start , int len ) throws Fits Exception { ensure Data ( ) ; Object [ ] new Data = new Object [ this . n Fields - len ] ; int [ ] new Offsets = new int [ this . n Fields - len ] ; int [ ] new Lengths = new int [ this . n Fields - len ] ; Class < ? > [ ] new Types = new Class [ this . n Fields - len ] ; String [ ] new Nulls = new String [ this . n Fields - len ] ; System . arraycopy ( this . data , NUM , new Data , NUM , start ) ; System . arraycopy ( this . lengths , NUM , new Lengths , NUM , start ) ; System . arraycopy ( this . types , NUM , new Types , NUM , start ) ; System . arraycopy ( this . nulls , NUM , new Nulls , NUM , start ) ; System . arraycopy ( this . data , start + len , new Data , start , this . n Fields - start - len ) ; System . arraycopy ( this . lengths , start + len , new Lengths , start , this . n Fields - start - len ) ; System . arraycopy ( this . types , start + len , new Types , start , this . n Fields - start - len ) ; System . arraycopy ( this . nulls , start + len , new Nulls , start , this . n Fields - start - len ) ; for ( int i = start ; i < start + len ; i += NUM ) { this . row Len -= this . lengths [ i ] + NUM ; } this . data = new Data ; this . offsets = new Offsets ; this . lengths = new Lengths ; this . types = new Types ; this . nulls = new Nulls ; if ( this . is Null != null ) { boolean found = BOOL ; boolean [ ] new Is Null = new boolean [ this . n Rows * ( this . n Fields - len ) ] ; for ( int i = NUM ; i < this . n Rows ; i += NUM ) { int old Off = this . n Fields * i ; int new Off = ( this . n Fields - len ) * i ; for ( int col = NUM ; col < start ; col += NUM ) { new Is Null [ new Off + col ] = this . is Null [ old Off + col ] ; found = found || this . is Null [ old Off + col ] ; } for ( int col = start + len ; col < this . n Fields ; col += NUM ) { new Is Null [ new Off + col - len ] = this . is Null [ old Off + col ] ; found = found || this . is Null [ old Off + col ] ; } } if ( found ) { this . is Null = new Is Null ; } else { this . is Null = null ; } } this . buffer = null ; this . n Fields -= len ; }
void sccp ( Method m ) { add Trace Attr ( STRING , m ) ; Deque < Block > code = dfs ( m . entry . to ) ; Edge Map < Expr > uses = find Uses ( code ) ; Map < Expr , Object > values = new Tree Map < Expr , Object > ( ) ; Map < Expr , Typeref > types = new Tree Map < Expr , Typeref > ( ) ; Set < Edge > reached = new Tree Set < Edge > ( ) ; sccp analyze ( m , uses , values , types , reached ) ; verbose Status ( STRING + reached ) ; verbose Status ( STRING + types ) ; sccp cfgopt ( values , types , reached ) ; dce ( m ) ; code = dfs ( m . entry . to ) ; uses = find Uses ( code ) ; Tree Set < Expr > work = new Tree Set < Expr > ( ) ; for ( Block b : code ) for ( Expr e : b ) work . add ( e ) ; while ( ! work . is Empty ( ) ) { Expr e = get Expr ( work ) ; sccp modify ( m , uses , values , types , e , work ) ; } dce ( m ) ; }
public SIP Server Transaction create Server Transaction ( Message Channel encapsulated Message Channel ) { if ( unlimited Server Transaction Table Size ) { return new SIP Server Transaction Impl ( this , encapsulated Message Channel ) ; } else { float threshold = ( ( float ) ( server Transaction Table . size ( ) - server Transaction Table Lowater Mark ) ) / ( ( float ) ( server Transaction Table Highwater Mark - server Transaction Table Lowater Mark ) ) ; boolean decision = Math . random ( ) > NUM - threshold ; if ( decision ) { return null ; } else { return new SIP Server Transaction Impl ( this , encapsulated Message Channel ) ; } } }
protected void delay ( long delay Ms , String desc ) { try { Thread . sleep ( delay Ms ) ; } catch ( Interrupted Exception int Exc ) { LOG . warn ( STRING + desc , int Exc ) ; } }
public void test Split And Join Multiple Properties On Pipe ( ) { Properties inner = Property Utils . split Properties On Pipe ( ONE PIPE TWO ) ; assert Equals ( STRING , inner . get Property ( STRING ) ) ; assert Equals ( STRING , inner . get Property ( STRING ) ) ; assert Equals ( NUM , inner . size ( ) ) ; try { assert Equals ( ONE PIPE TWO , Property Utils . join On Pipe ( Property Utils . to Map ( inner ) ) ) ; } catch ( Comparison Failure e ) { assert Equals ( TWO PIPE ONE , Property Utils . join On Pipe ( Property Utils . to Map ( inner ) ) ) ; } }
public void test Generic Wrapper ( ) throws Exception { Object Mapper mapper = new Object Mapper ( ) ; Wrapper < Simple Bean > result = mapper . read Value ( STRING , new Type Reference < Wrapper < Simple Bean > > ( ) { } ) ; assert Not Null ( result ) ; assert Equals ( Wrapper . class , result . get Class ( ) ) ; Object contents = result . value ; assert Not Null ( contents ) ; assert Equals ( Simple Bean . class , contents . get Class ( ) ) ; Simple Bean bean = ( Simple Bean ) contents ; assert Equals ( NUM , bean . x ) ; }
public static final void decode ( Input Stream is , Output Stream os ) throws Base 64 Decoding Exception , IO Exception { byte b1 = NUM , b2 = NUM , b3 = NUM , b4 = NUM ; int index = NUM ; byte [ ] data = new byte [ NUM ] ; int read ; while ( ( read = is . read ( ) ) > NUM ) { byte readed = ( byte ) read ; if ( is White Space ( readed ) ) { continue ; } if ( is Pad ( readed ) ) { data [ index ++ ] = readed ; if ( index == NUM ) { data [ index ++ ] = ( byte ) is . read ( ) ; } break ; } if ( ( data [ index ++ ] = readed ) == - NUM ) { throw new Base 64 Decoding Exception ( STRING ) ; } if ( index != NUM ) { continue ; } index = NUM ; b1 = base 64 Alphabet [ data [ NUM ] ] ; b2 = base 64 Alphabet [ data [ NUM ] ] ; b3 = base 64 Alphabet [ data [ NUM ] ] ; b4 = base 64 Alphabet [ data [ NUM ] ] ; os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ) ; os . write ( ( byte ) ( b3 << NUM | b4 ) ) ; } byte d1 = data [ NUM ] , d2 = data [ NUM ] , d3 = data [ NUM ] , d4 = data [ NUM ] ; b1 = base 64 Alphabet [ d1 ] ; b2 = base 64 Alphabet [ d2 ] ; b3 = base 64 Alphabet [ d3 ] ; b4 = base 64 Alphabet [ d4 ] ; if ( ( b3 == - NUM ) || ( b4 == - NUM ) ) { if ( is Pad ( d3 ) && is Pad ( d4 ) ) { if ( ( b2 & NUM ) != NUM ) { throw new Base 64 Decoding Exception ( STRING ) ; } os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; } else if ( ! is Pad ( d3 ) && is Pad ( d4 ) ) { b3 = base 64 Alphabet [ d3 ] ; if ( ( b3 & NUM ) != NUM ) { throw new Base 64 Decoding Exception ( STRING ) ; } os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ) ; } else { throw new Base 64 Decoding Exception ( STRING ) ; } } else { os . write ( ( byte ) ( b1 << NUM | b2 > > NUM ) ) ; os . write ( ( byte ) ( ( ( b2 & NUM ) << NUM ) | ( ( b3 > > NUM ) & NUM ) ) ) ; os . write ( ( byte ) ( b3 << NUM | b4 ) ) ; } }
public Connection Quality register ( Connection Class State Change Listener listener ) { if ( listener != null ) { m Listener List . add ( listener ) ; } return m Current Bandwidth Connection Quality . get ( ) ; }
public void test Merge Multiple Filters Into Empty Document ( ) throws Exception { String src Xml = STRING ; Web Xml src Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( src Xml . get Bytes ( STRING ) ) , null ) ; String merge Xml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; Web Xml merge Web Xml = Web Xml Io . parse Web Xml ( new Byte Array Input Stream ( merge Xml . get Bytes ( STRING ) ) , null ) ; Web Xml Merger merger = new Web Xml Merger ( src Web Xml ) ; merger . merge Filters ( merge Web Xml ) ; List < String > filter Names = Web Xml Utils . get Filter Names ( src Web Xml ) ; assert Equals ( NUM , filter Names . size ( ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; assert Equals ( STRING , filter Names . get ( NUM ) ) ; }
private Diff Part decode Replace ( final int block Size S , final int block Size E , final int block Size L ) throws Unsupported Encoding Exception , Decoding Exception { if ( block Size S < NUM || block Size E < NUM || block Size L < NUM ) { throw new Decoding Exception ( STRING + block Size S + STRING + block Size E + STRING + block Size L ) ; } int s = r . read ( block Size S ) ; int e = r . read ( block Size E ) ; int l = r . read ( block Size L ) ; Byte Array Output Stream output = new Byte Array Output Stream ( ) ; for ( int i = NUM ; i < l ; i ++ ) { output . write ( r . read Byte ( ) ) ; } Diff Part part = new Diff Part ( Diff Action . REPLACE ) ; part . set Start ( s ) ; part . set Length ( e ) ; part . set Text ( output . to String ( WIKIPEDIA ENCODING ) ) ; return part ; }
Node clone Or Import Node ( short operation , Node node , boolean deep ) { Node Impl copy = shallow Copy ( operation , node ) ; if ( deep ) { Node List list = node . get Child Nodes ( ) ; for ( int i = NUM ; i < list . get Length ( ) ; i ++ ) { copy . append Child ( clone Or Import Node ( operation , list . item ( i ) , deep ) ) ; } } notify User Data Handlers ( operation , node , copy ) ; return copy ; }
private void load Corpus ( Parallel Corpus corpus ) { logger . info ( STRING ) ; Time Keeper timer = Timing Utils . start ( ) ; num Sentences = corpus . size ( ) ; int num Source Positions = corpus . num Source Positions ( ) ; int num Target Positions = corpus . num Target Positions ( ) ; int src Length = num Source Positions + num Sentences ; src Bitext = new int [ src Length ] ; f2 e = new int [ src Length ] ; int tgt Length = num Target Positions + num Sentences ; tgt Bitext = new int [ tgt Length ] ; e2 f = new int [ tgt Length ] ; int src Offset = NUM ; int tgt Offset = NUM ; for ( Aligned Sentence sentence : corpus ) { System . arraycopy ( sentence . source , NUM , src Bitext , src Offset , sentence . source Length ( ) ) ; System . arraycopy ( sentence . f2 e , NUM , f2 e , src Offset , sentence . f2 e . length ) ; System . arraycopy ( sentence . target , NUM , tgt Bitext , tgt Offset , sentence . target Length ( ) ) ; System . arraycopy ( sentence . e2 f , NUM , e2 f , tgt Offset , sentence . e2 f . length ) ; src Offset += sentence . source Length ( ) ; tgt Offset += sentence . target Length ( ) ; src Bitext [ src Offset ] = to Sentence Offset ( tgt Offset ) ; tgt Bitext [ tgt Offset ] = to Sentence Offset ( src Offset ) ; ++ src Offset ; ++ tgt Offset ; } vocabulary = corpus . get Vocabulary ( ) ; timer . mark ( STRING ) ; logger . info ( STRING , timer ) ; }
private void update Seek Bars For Spring Config ( Spring Config spring Config ) { float tension = ( float ) Origami Value Converter . origami Value From Tension ( spring Config . tension ) ; float tension Range = MAX TENSION - MIN TENSION ; int scaled Tension = Math . round ( ( ( tension - MIN TENSION ) * MAX SEEKBAR VAL ) / tension Range ) ; float friction = ( float ) Origami Value Converter . origami Value From Friction ( spring Config . friction ) ; float friction Range = MAX FRICTION - MIN FRICTION ; int scaled Friction = Math . round ( ( ( friction - MIN FRICTION ) * MAX SEEKBAR VAL ) / friction Range ) ; m Tension Seek Bar . set Progress ( scaled Tension ) ; m Friction Seek Bar . set Progress ( scaled Friction ) ; }
@ Override public FS Data Output Stream create Object ( String obj Name , String content Type , Map < String , String > metadata , Statistics statistics ) throws IO Exception { URL url = new URL ( m Joss Account . get Access URL ( ) + STRING + obj Name ) ; LOG . debug ( STRING , url . to String ( ) , content Type ) ; try { return new FS Data Output Stream ( new Swift Output Stream ( m Joss Account , url , content Type , metadata , swift Connection Manager ) , statistics ) ; } catch ( IO Exception e ) { LOG . error ( e . get Message ( ) ) ; throw e ; } }
private int [ ] read Type Annotations ( final Method Visitor mv , final Context context , int u , boolean visible ) { char [ ] c = context . buffer ; int [ ] offsets = new int [ read Unsigned Short ( u ) ] ; u += NUM ; for ( int i = NUM ; i < offsets . length ; ++ i ) { offsets [ i ] = u ; int target = read Int ( u ) ; switch ( target > > > NUM ) { case NUM : case NUM : case NUM : u += NUM ; break ; case NUM : case NUM : case NUM : u += NUM ; break ; case NUM : case NUM : for ( int j = read Unsigned Short ( u + NUM ) ; j > NUM ; -- j ) { int start = read Unsigned Short ( u + NUM ) ; int length = read Unsigned Short ( u + NUM ) ; read Label ( start , context . labels ) ; read Label ( start + length , context . labels ) ; u += NUM ; } u += NUM ; break ; case NUM : case NUM : case NUM : case NUM : case NUM : u += NUM ; break ; default : u += NUM ; break ; } int path Length = read Byte ( u ) ; if ( ( target > > > NUM ) == NUM ) { Type Path path = path Length == NUM ? null : new Type Path ( b , u ) ; u += NUM + NUM * path Length ; u = read Annotation Values ( u + NUM , c , BOOL , mv . visit Try Catch Annotation ( target , path , read UTF 8 ( u , c ) , visible ) ) ; } else { u = read Annotation Values ( u + NUM + NUM * path Length , c , BOOL , null ) ; } } return offsets ; }
private String post RP Change Vpool Steps ( Workflow workflow , String wait For , List < Volume Descriptor > volume Descriptors , String task Id ) { List < Volume Descriptor > rp Volume Descriptors = Volume Descriptor . filter By Type ( volume Descriptors , new Volume Descriptor . Type [ ] { Volume Descriptor . Type . RP EXISTING SOURCE } , null ) ; if ( rp Volume Descriptors . is Empty ( ) ) { return wait For ; } List < Volume Descriptor > migrated Block Data Descriptors = new Array List < Volume Descriptor > ( ) ; List < URI > volumes With Migration = new Array List < URI > ( ) ; if ( volume Descriptors != null ) { List < Volume Descriptor > migrate Descriptors = Volume Descriptor . filter By Type ( volume Descriptors , new Volume Descriptor . Type [ ] { Volume Descriptor . Type . VPLEX MIGRATE VOLUME } , null ) ; if ( migrate Descriptors != null && ! migrate Descriptors . is Empty ( ) ) { s logger . info ( STRING ) ; Iterator < Volume Descriptor > migration Iter = migrate Descriptors . iterator ( ) ; while ( migration Iter . has Next ( ) ) { Volume Descriptor migration Desc = migration Iter . next ( ) ; Migration migration = s db Client . query Object ( Migration . class , migration Desc . get Migration Id ( ) ) ; volumes With Migration . add ( migration . get Source ( ) ) ; Volume migrated Volume = s db Client . query Object ( Volume . class , migration . get Volume ( ) ) ; Volume Descriptor migrated Block Data Desc = new Volume Descriptor ( Volume Descriptor . Type . BLOCK DATA , migrated Volume . get Storage Controller ( ) , migrated Volume . get Id ( ) , null , migrated Volume . get Consistency Group ( ) , migration Desc . get Capabilities Values ( ) ) ; migrated Block Data Descriptors . add ( migrated Block Data Desc ) ; } } } List < Volume Descriptor > block Data Descriptors = new Array List < Volume Descriptor > ( ) ; for ( Volume Descriptor descr : rp Volume Descriptors ) { Volume rp Existing Source = s db Client . query Object ( Volume . class , descr . get Volume URI ( ) ) ; if ( RP Helper . is V Plex Volume ( rp Existing Source , s db Client ) ) { s logger . info ( String . format ( STRING , rp Existing Source . get Label ( ) ) ) ; if ( null != rp Existing Source . get Associated Volumes ( ) ) { for ( String assoc Volume Id : rp Existing Source . get Associated Volumes ( ) ) { Volume assoc Volume = s db Client . query Object ( Volume . class , URI . create ( assoc Volume Id ) ) ; if ( volumes With Migration . contains ( assoc Volume . get Id ( ) ) ) { s logger . info ( String . format ( STRING , assoc Volume . get Label ( ) ) ) ; continue ; } if ( Null Column Value Getter . is Not Null Value ( assoc Volume . get Replication Group Instance ( ) ) ) { Volume Descriptor block Data Desc = new Volume Descriptor ( Volume Descriptor . Type . BLOCK DATA , assoc Volume . get Storage Controller ( ) , assoc Volume . get Id ( ) , null , rp Existing Source . get Consistency Group ( ) , descr . get Capabilities Values ( ) ) ; block Data Descriptors . add ( block Data Desc ) ; assoc Volume . set Consistency Group ( rp Existing Source . get Consistency Group ( ) ) ; s db Client . update Object ( assoc Volume ) ; s logger . info ( String . format ( STRING , assoc Volume . get Label ( ) , rp Existing Source . get Consistency Group ( ) , assoc Volume . get Storage Controller ( ) ) ) ; } } } } } if ( ! block Data Descriptors . is Empty ( ) ) { wait For = block Device Controller . add Steps For Create Consistency Group ( workflow , wait For , block Data Descriptors , STRING ) ; wait For = block Device Controller . add Steps For Update Consistency Group ( workflow , wait For , block Data Descriptors , null ) ; } block Data Descriptors . add All ( migrated Block Data Descriptors ) ; s logger . info ( STRING ) ; wait For = replica Device Controller . add Steps For Create Volumes ( workflow , wait For , block Data Descriptors , task Id ) ; return wait For ; }
public boolean check Entry ( List < Roster Entry > list , int i , String road Name , String road Number , String dcc Address , String mfg , String decoder Model , String decoder Family , String id , String group ) { Roster Entry r = list . get ( i ) ; return check Entry ( r , road Name , road Number , dcc Address , mfg , decoder Model , decoder Family , id , group ) ; }
public static Double zing ( Number value ) { if ( value == null ) { return null ; } return Math . max ( NUM , value . double Value ( ) ) ; }
public Rich Text with Size ( int size ) { this . size = size ; return this ; }
private boolean is Included ( final Http Servlet Request request ) { final String uri = ( String ) request . get Attribute ( STRING ) ; final boolean include Request = ! ( uri == null ) ; if ( include Request && LOG . is Debug Enabled ( ) ) { LOG . debug ( request . get Request URL ( ) + STRING + STRING ) ; } return include Request ; }
protected Abstract Data Line ( Data Line . Info info , Abstract Mixer mixer , Control [ ] controls , Audio Format format , int buffer Size ) { super ( info , mixer , controls ) ; if ( format != null ) { default Format = format ; } else { default Format = new Audio Format ( NUM , NUM , NUM , BOOL , Platform . is Big Endian ( ) ) ; } if ( buffer Size > NUM ) { default Buffer Size = buffer Size ; } else { default Buffer Size = ( ( int ) ( default Format . get Frame Rate ( ) / NUM ) ) * default Format . get Frame Size ( ) ; } this . format = default Format ; this . buffer Size = default Buffer Size ; }
private void fill Conversations ( ) { conversations . add ( STRING ) ; conversations . add ( STRING ) ; conversations . add ( STRING ) ; conversations . add ( STRING ) ; conversations . add ( STRING ) ; conversations . add ( STRING ) ; conversations . add ( STRING ) ; conversations . add ( STRING ) ; conversations . add ( STRING ) ; conversations . add ( STRING ) ; conversations . add ( STRING ) ; conversations . add ( STRING ) ; }
public String modify Replication Job ( Isilon Sync Job job ) throws Isilon Exception { return create ( base Url . resolve ( URI REPLICATION JOBS ) , STRING , job ) ; }
public void end Element ( String uri , String local Name , String q Name ) throws SAX Exception { if ( q Name . equals ( Print Data . XML TAG ) ) { pop ( ) ; } else if ( q Name . equals ( Print Data Element . XML TAG ) ) { m cur PD . add Node ( new Print Data Element ( m cur PD Ename , m cur PD Evalue . to String ( ) , NUM , null ) ) ; } }
private void draw String ( Object native Graphics , Object native Font , String str , int x , int y , int text Decoration , int font Height ) { if ( str . length ( ) == NUM ) { return ; } if ( text Decoration != NUM ) { boolean raised = ( text Decoration & Style . TEXT DECORATION 3D ) != NUM ; boolean lowerd = ( text Decoration & Style . TEXT DECORATION 3D LOWERED ) != NUM ; boolean north = ( text Decoration & Style . TEXT DECORATION 3D SHADOW NORTH ) != NUM ; if ( raised || lowerd || north ) { text Decoration = text Decoration & ( ~ Style . TEXT DECORATION 3D ) & ( ~ Style . TEXT DECORATION 3D LOWERED ) & ( ~ Style . TEXT DECORATION 3D SHADOW NORTH ) ; int c = get Color ( native Graphics ) ; int a = get Alpha ( native Graphics ) ; int new Color = NUM ; int offset = - NUM ; if ( lowerd ) { offset = NUM ; new Color = NUM ; } else if ( north ) { offset = NUM ; } set Color ( native Graphics , new Color ) ; if ( a == NUM ) { set Alpha ( native Graphics , NUM ) ; } draw String ( native Graphics , native Font , str , x , y + offset , text Decoration , font Height ) ; set Alpha ( native Graphics , a ) ; set Color ( native Graphics , c ) ; draw String ( native Graphics , native Font , str , x , y , text Decoration , font Height ) ; return ; } draw String ( native Graphics , str , x , y ) ; if ( ( text Decoration & Style . TEXT DECORATION UNDERLINE ) != NUM ) { draw Line ( native Graphics , x , y + font Height - NUM , x + string Width ( native Font , str ) , y + font Height - NUM ) ; } if ( ( text Decoration & Style . TEXT DECORATION STRIKETHRU ) != NUM ) { draw Line ( native Graphics , x , y + font Height / NUM , x + string Width ( native Font , str ) , y + font Height / NUM ) ; } if ( ( text Decoration & Style . TEXT DECORATION OVERLINE ) != NUM ) { draw Line ( native Graphics , x , y , x + string Width ( native Font , str ) , y ) ; } } else { draw String ( native Graphics , str , x , y ) ; } }
public String build Nonce Counter ( ) { String result = Integer . to Hex String ( m Cnonce Counter ) ; while ( result . length ( ) != NUM ) { result = STRING + result ; } return result ; }
@ Override public synchronized void accept Instance ( Instance Event e ) { m busy = BOOL ; if ( m completed == null ) { m completed = new Hash Map < Object , Instances > ( ) ; m incremental Savers = new Hash Map < Object , Arff Saver > ( ) ; m finished Count = NUM ; m incremental Counter = NUM ; } if ( e . get Status ( ) == Instance Event . FORMAT AVAILABLE ) { if ( m completed . contains Key ( e . get Source ( ) ) ) { if ( m log != null ) { String msg = status Message Prefix ( ) + STRING ; m log . status Message ( msg ) ; m log . log Message ( STRING + msg + STRING + STRING ) ; } m completed = new Hash Map < Object , Instances > ( ) ; m incremental Savers = new Hash Map < Object , Arff Saver > ( ) ; m incremental Counter = NUM ; m complete Header = null ; m finished Count = NUM ; } m completed . put ( e . get Source ( ) , e . get Structure ( ) ) ; if ( m completed . size ( ) == m listenees . size ( ) ) { try { if ( m log != null ) { String msg = status Message Prefix ( ) + STRING ; m log . status Message ( msg ) ; m log . log Message ( STRING + msg ) ; } m complete Header = make Output Header ( ) ; m ie . set Structure ( m complete Header ) ; notify Instance Listeners ( m ie ) ; if ( m incremental Savers . size ( ) > NUM ) { for ( Arff Saver s : m incremental Savers . values ( ) ) { s . write Incremental ( null ) ; File tmp File = s . retrieve File ( ) ; Arff Loader loader = new Arff Loader ( ) ; loader . set File ( tmp File ) ; Instances temp Structure = loader . get Structure ( ) ; Instance temp Loaded = loader . get Next Instance ( temp Structure ) ; while ( temp Loaded != null ) { Instance converted = make Output Instance ( m complete Header , temp Loaded ) ; m ie . set Status ( Instance Event . INSTANCE AVAILABLE ) ; m ie . set Instance ( converted ) ; notify Instance Listeners ( m ie ) ; m incremental Counter ++ ; if ( m incremental Counter % NUM == NUM ) { if ( m log != null ) { m log . status Message ( status Message Prefix ( ) + STRING + m incremental Counter + STRING ) ; } } temp Loaded = loader . get Next Instance ( temp Structure ) ; } } m incremental Savers . clear ( ) ; } } catch ( Exception e1 ) { String msg = status Message Prefix ( ) + STRING ; if ( m log != null ) { m log . status Message ( msg ) ; m log . log Message ( STRING + e1 . get Message ( ) ) ; } stop ( ) ; e1 . print Stack Trace ( ) ; m busy = BOOL ; return ; } } m busy = BOOL ; return ; } if ( e . get Status ( ) == Instance Event . BATCH FINISHED || e . get Status ( ) == Instance Event . INSTANCE AVAILABLE ) { Instance current I = e . get Instance ( ) ; if ( m complete Header == null ) { if ( current I != null ) { Arff Saver saver = m incremental Savers . get ( e . get Source ( ) ) ; if ( saver == null ) { saver = new Arff Saver ( ) ; try { File tmp File = File . create Temp File ( STRING , STRING ) ; saver . set File ( tmp File ) ; saver . set Retrieval ( weka . core . converters . Saver . INCREMENTAL ) ; saver . set Instances ( new Instances ( current I . dataset ( ) , NUM ) ) ; m incremental Savers . put ( e . get Source ( ) , saver ) ; } catch ( IO Exception e1 ) { stop ( ) ; e1 . print Stack Trace ( ) ; String msg = status Message Prefix ( ) + STRING ; if ( m log != null ) { m log . status Message ( msg ) ; m log . log Message ( STRING + e1 . get Message ( ) ) ; } m busy = BOOL ; return ; } } try { saver . write Incremental ( current I ) ; if ( e . get Status ( ) == Instance Event . BATCH FINISHED ) { m finished Count ++ ; } } catch ( IO Exception e1 ) { stop ( ) ; e1 . print Stack Trace ( ) ; String msg = status Message Prefix ( ) + STRING ; if ( m log != null ) { m log . status Message ( msg ) ; m log . log Message ( STRING + e1 . get Message ( ) ) ; } m busy = BOOL ; return ; } } } else { if ( current I != null ) { int code = Instance Event . INSTANCE AVAILABLE ; if ( e . get Status ( ) == Instance Event . BATCH FINISHED ) { m finished Count ++ ; if ( m finished Count == m listenees . size ( ) ) { code = Instance Event . BATCH FINISHED ; } } Instance new I = make Output Instance ( m complete Header , current I ) ; m ie . set Status ( code ) ; m ie . set Instance ( new I ) ; notify Instance Listeners ( m ie ) ; m incremental Counter ++ ; if ( m incremental Counter % NUM == NUM ) { if ( m log != null ) { m log . status Message ( status Message Prefix ( ) + STRING + m incremental Counter + STRING ) ; } } if ( code == Instance Event . BATCH FINISHED ) { if ( m log != null ) { m log . status Message ( status Message Prefix ( ) + STRING ) ; } m completed = null ; m incremental Savers = null ; m incremental Counter = NUM ; m complete Header = null ; m finished Count = NUM ; } } } } m busy = BOOL ; }
public static void match Virtual Pool With All Storage Pools ( Virtual Pool vpool , Db Client db Client , Coordinator Client coordinator , String Buffer error Message ) { List < URI > storage Pool UR Is = db Client . query By Type ( Storage Pool . class , BOOL ) ; Iterator < Storage Pool > storage Pool List = db Client . query Iterative Objects ( Storage Pool . class , storage Pool UR Is ) ; List < Storage Pool > all Pools To Process = new Array List < Storage Pool > ( ) ; while ( storage Pool List . has Next ( ) ) { all Pools To Process . add ( storage Pool List . next ( ) ) ; } if ( ! all Pools To Process . is Empty ( ) ) { matchv Pool With Storage Pools ( vpool , all Pools To Process , db Client , coordinator , null , error Message ) ; } }
public static boolean can Player Afford Trading Fee ( Player player , int price ) { Big Decimal fee = calculate Fee ( player , price ) ; List < Item > all Equipped = player . get All Equipped ( STRING ) ; int owned Money = NUM ; for ( Item item : all Equipped ) { Money m = ( Money ) item ; owned Money += m . get Quantity ( ) ; } return fee . int Value ( ) <= owned Money ; }
private void add Replace History ( ) { add Replace History ( tf Replace Editor . get Text ( ) ) ; }
void load Cache ( ) { boolean worked = BOOL ; Array List < Source File > files = new Array List < Source File > ( ) ; Swf Info [ ] swfs = get All Swfs ( ) ; for ( int i = NUM ; i < swfs . length ; i ++ ) { if ( swfs [ i ] != null ) worked = load Swf Files ( files , swfs [ i ] ) ? worked : BOOL ; } Array List < Source File > fa = trim File List ( files ) ; m files = fa . to Array ( new Source File [ fa . size ( ) ] ) ; Arrays . sort ( m files , this ) ; if ( worked ) m swfs Loaded = swfs . length ; }
public static String join ( boolean [ ] self , String separator ) { String Builder buffer = new String Builder ( ) ; boolean first = BOOL ; if ( separator == null ) separator = STRING ; for ( boolean next : self ) { if ( first ) { first = BOOL ; } else { buffer . append ( separator ) ; } buffer . append ( next ) ; } return buffer . to String ( ) ; }
public Query include ( Contact . Field ... fields ) { include . clear ( ) ; include . add All ( Arrays . as List ( fields ) ) ; return this ; }
public Stemmed String ( String orig , Char Sequence stemmed ) { str Orig = orig ; str Stemmed = stemmed . to String ( ) ; }
public Log Stream Merger ( Log Request req , Log Svc Properties Loader properties Loader ) { logger . trace ( STRING ) ; this . request = req ; Log File Finder file Finder = new Log File Finder ( properties Loader . get Log File Paths ( ) , properties Loader . get Excluded Log File Paths ( ) ) ; Map < String , List < File > > grouped Log Files = file Finder . find Files Grouped By Base Name ( ) ; List < String > groups = req . get Base Names ( ) ; if ( groups == null || groups . is Empty ( ) ) { groups = new Array List < > ( grouped Log Files . key Set ( ) ) ; } logger . debug ( STRING , groups ) ; if ( groups . retain All ( grouped Log Files . key Set ( ) ) ) { logger . info ( STRING , groups ) ; } int size = groups . size ( ) ; log Stream List = new Log File Stream [ size ] ; log Heads = new Log Message [ size ] ; for ( int i = NUM ; i < size ; i ++ ) { String service = groups . get ( i ) ; log Stream List [ i ] = new Log File Stream ( service , grouped Log Files . get ( service ) , req , status ) ; log Heads [ i ] = null ; } }
public static String [ ] unpack Cipher Suites ( String ciphers ) { if ( ciphers == null ) return null ; Vector c = new Vector ( ) ; int i = ciphers . index Of ( STRING ) ; int j = NUM ; while ( i > - NUM ) { c . add ( ciphers . substring ( j , i ) ) ; j = i + NUM ; i = ciphers . index Of ( STRING , j ) ; } c . add ( ciphers . substring ( j ) ) ; String [ ] s = new String [ c . size ( ) ] ; c . to Array ( s ) ; return s ; }
public Default File Filter ( String extension , String description ) { ext = extension . to Lower Case ( ) ; desc = description ; }
private boolean is Named Param ( String arg ) { return arg . starts With ( STRING ) && ( arg . index Of ( STRING ) > NUM && valid First Char ( arg . char At ( NUM ) ) ) ; }
Node clone Or Import Node ( short operation , Node node , boolean deep ) { Node Impl copy = shallow Copy ( operation , node ) ; if ( deep ) { Node List list = node . get Child Nodes ( ) ; for ( int i = NUM ; i < list . get Length ( ) ; i ++ ) { copy . append Child ( clone Or Import Node ( operation , list . item ( i ) , deep ) ) ; } } notify User Data Handlers ( operation , node , copy ) ; return copy ; }
private boolean does Match ( String pattern , int pp , String result , int rp ) { for ( ; ; ) { if ( pp == pattern . length ( ) && rp == result . length ( ) ) return BOOL ; if ( pp == pattern . length ( ) ) return BOOL ; char pc = pattern . char At ( pp ) ; if ( pc == STRING ) { if ( rp == result . length ( ) ) return BOOL ; pp ++ ; rp ++ ; } else if ( pc == STRING ) { if ( pp == pattern . length ( ) - NUM ) { return BOOL ; } for ( int sp = rp ; sp < result . length ( ) ; sp ++ ) { if ( does Match ( pattern , pp + NUM , result , sp ) ) { return BOOL ; } } return BOOL ; } else { if ( rp == result . length ( ) ) return BOOL ; if ( pc != result . char At ( rp ) ) { return BOOL ; } pp ++ ; rp ++ ; } } }
protected Function < Object [ ] , Object > create Key Generator ( Schema schema , Table Id column Set Name , List < Column > columns ) { if ( schema != null ) { int [ ] record Indexes = indexes For Columns ( columns ) ; Field [ ] fields = fields For Columns ( schema , columns ) ; int num Fields = record Indexes . length ; Value Converter [ ] converters = converters For Columns ( schema , column Set Name , columns , null , null ) ; return null ; } return null ; }
private static void copy File ( File src , File dst , Integer port , boolean internal Compression ) throws IO Exception { Buffered Reader in = new Buffered Reader ( new Input Stream Reader ( new File Input Stream ( src ) , Standard Charsets . UTF 8 ) ) ; Writer out = new Output Stream Writer ( new File Output Stream ( dst ) , Standard Charsets . UTF 8 ) ; for ( String line = in . read Line ( ) ; null != line ; line = in . read Line ( ) ) { if ( null != port ) line = line . replace ( STRING , port . to String ( ) ) ; line = line . replace ( STRING , internal Compression ? STRING : STRING ) ; out . write ( line ) ; } in . close ( ) ; out . close ( ) ; }
private boolean is Capability Refresh Authorized ( long timestamp Of Last Request ) { long current Time = System . current Time Millis ( ) ; if ( current Time < timestamp Of Last Request ) { return BOOL ; } return ( current Time > ( timestamp Of Last Request + m Rcs Settings . get Capability Refresh Timeout ( ) ) ) ; }

private void handle Static Stop Trees ( Static Metadata . Stop Tree Request request , Transport Network transport Network , Task Statistics ts ) { Static Metadata static Metadata = new Static Metadata ( request . request , transport Network ) ; if ( request . request . bucket != null ) { try { Output Stream os = Static Data Store . get Output Stream ( request . request , STRING , STRING ) ; static Metadata . write Stop Trees ( os ) ; os . close ( ) ; } catch ( IO Exception e ) { LOG . error ( STRING , e ) ; } delete Request ( request ) ; } else { try { Piped Input Stream pis = new Piped Input Stream ( ) ; Piped Output Stream pos = new Piped Output Stream ( pis ) ; finish Priority Task ( request , pis ) ; static Metadata . write Stop Trees ( pos ) ; pos . close ( ) ; } catch ( IO Exception e ) { LOG . error ( STRING , e ) ; } } }
public synchronized void add Room ( String room ) { if ( ! Helper . validate Stream ( room ) ) { return ; } connect ( ) ; room = room . to Lower Case ( ) ; if ( rooms . add ( room ) ) { sub Room ( room ) ; } }
public void remove All ( final Collection elements ) { adjusting = BOOL ; Set old Selection = new Hash Set ( selection ) ; boolean rv = selection . remove All ( elements ) ; adjusting = BOOL ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
@ Override public boolean e Is Set ( int feature ID ) { switch ( feature ID ) { case S Gen Package . FEATURE PARAMETER DEPRECATED : return deprecated != DEPRECATED EDEFAULT ; case S Gen Package . FEATURE PARAMETER COMMENT : return COMMENT EDEFAULT == null ? comment != null : ! COMMENT EDEFAULT . equals ( comment ) ; case S Gen Package . FEATURE PARAMETER FEATURE TYPE : return get Feature Type ( ) != null ; case S Gen Package . FEATURE PARAMETER OPTIONAL : return optional != OPTIONAL EDEFAULT ; case S Gen Package . FEATURE PARAMETER PARAMETER TYPE : return parameter Type != PARAMETER TYPE EDEFAULT ; } return super . e Is Set ( feature ID ) ; }
public Set < Integer > primary Partitions ( UUID node Id ) { Set < Integer > set = primary . get ( node Id ) ; return set == null ? Collections . < Integer > empty Set ( ) : set ; }
public java . lang . String Buffer insert ( int offset , java . lang . Object obj ) { internal . insert ( offset , obj ) ; return this ; }
@ Override protected final String replace Image Url ( final String css Uri , final String image Url ) { if ( ! image Urls . contains ( image Url ) ) { image Urls . add ( image Url ) ; return super . replace Image Url ( css Uri , image Url ) ; } LOG . debug ( STRING , image Url ) ; return image Url ; }
public void drag Over ( Drop Target Drag Event e ) { Point pt = e . get Location ( ) ; if ( pt . equals ( pt Last ) ) { return ; } int n Delta Left Right = pt . x - pt Last . x ; if ( ( ( n Left Right > NUM ) && ( n Delta Left Right < NUM ) ) || ( ( n Left Right < NUM ) && ( n Delta Left Right > NUM ) ) ) { n Left Right = NUM ; } n Left Right += n Delta Left Right ; pt Last = pt ; Graphics 2 D g2 = ( Graphics 2 D ) get Graphics ( ) ; if ( ! Drag Source . is Drag Image Supported ( ) ) { paint Immediately ( ra Ghost . get Bounds ( ) ) ; ra Ghost . set Rect ( pt . x - m pt Offset . x , pt . y - m pt Offset . y , m img Ghost . get Width ( ) , m img Ghost . get Height ( ) ) ; g2 . draw Image ( m img Ghost , Affine Transform . get Translate Instance ( ra Ghost . get X ( ) , ra Ghost . get Y ( ) ) , null ) ; } else { paint Immediately ( ra Cue Line . get Bounds ( ) ) ; } Tree Path path = get Closest Path For Location ( pt . x , pt . y ) ; if ( ! ( path == path Last ) ) { n Left Right = NUM ; path Last = path ; timer Hover . restart ( ) ; } Rectangle ra Path = get Path Bounds ( path ) ; ra Cue Line . set Rect ( NUM , ra Path . y + ( int ) ra Path . get Height ( ) , get Width ( ) , NUM ) ; g2 . set Color ( color Cue Line ) ; g2 . fill ( ra Cue Line ) ; if ( n Left Right > NUM ) { g2 . draw Image ( img Right , Affine Transform . get Translate Instance ( pt . x - m pt Offset . x , pt . y - m pt Offset . y ) , null ) ; n Shift = + NUM ; } else if ( n Left Right < - NUM ) { g2 . draw Image ( img Left , Affine Transform . get Translate Instance ( pt . x - m pt Offset . x , pt . y - m pt Offset . y ) , null ) ; n Shift = - NUM ; } else { n Shift = NUM ; } ra Ghost = ra Ghost . create Union ( ra Cue Line ) ; if ( path . equals ( m selected Tree Path ) ) { e . reject Drag ( ) ; } else { e . accept Drag ( e . get Drop Action ( ) ) ; } }
public Bidi ( Attributed Character Iterator paragraph ) { if ( paragraph == null ) { throw new Illegal Argument Exception ( STRING ) ; } bidi Base = new Bidi Base ( NUM , NUM ) ; bidi Base . set Para ( paragraph ) ; }
public String patch to Text ( List < Patch > patches ) { String Builder text = new String Builder ( ) ; for ( Patch a Patch : patches ) { text . append ( a Patch ) ; } return text . to String ( ) ; }
public void add Result ( double pred [ ] , Instance real ) { predictions . add ( pred ) ; actuals . add ( ML Utils . to Int Array ( real , pred . length ) ) ; }
public static void migrate Downloads ( Properties ctx ) { String sql = STRING ; int no = DB . get SQL Value ( null , sql ) ; if ( no > NUM ) return ; int count = NUM ; sql = STRING + STRING + STRING ; Prepared Statement pstmt = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int AD Client ID = rs . get Int ( NUM ) ; int AD Org ID = rs . get Int ( NUM ) ; int M Product ID = rs . get Int ( NUM ) ; String Name = rs . get String ( NUM ) ; String Download URL = rs . get String ( NUM ) ; M Product Download pdl = new M Product Download ( ctx , NUM , null ) ; pdl . set Client Org ( AD Client ID , AD Org ID ) ; pdl . set M Product ID ( M Product ID ) ; pdl . set Name ( Name ) ; pdl . set Download URL ( Download URL ) ; if ( pdl . save ( ) ) { count ++ ; String sql Update = STRING + M Product ID ; int updated = DB . execute Update ( sql Update , null ) ; if ( updated != NUM ) s log . warning ( STRING ) ; } else s log . warning ( STRING + M Product ID ) ; } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { s log . log ( Level . SEVERE , sql , e ) ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { pstmt = null ; } s log . info ( STRING + count ) ; }
public All Stats Table Single ( Dataset Generator dataset Generator , Locker locker ) { Argument Checking . not Null ( dataset Generator , STRING ) ; init Components ( ) ; table . set Default Renderer ( J Label . class , new Renderer ( ) ) ; table . set Column Selection Allowed ( BOOL ) ; table . set Row Selection Allowed ( BOOL ) ; J Table Header header = table . get Table Header ( ) ; header . set Reordering Allowed ( BOOL ) ; GUI Utilities . set Table Header ( header ) ; model = new Model ( dataset Generator ) ; table . set Model ( model ) ; this . locker = locker ; }
public void download ( String remote File Name , File local File , long restart At , FTP Data Transfer Listener listener ) throws Illegal State Exception , File Not Found Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception , FTP Data Transfer Exception , FTP Aborted Exception { Output Stream output Stream = null ; try { output Stream = new File Output Stream ( local File , restart At > NUM ) ; } catch ( IO Exception e ) { throw new FTP Data Transfer Exception ( e ) ; } try { download ( remote File Name , output Stream , restart At , listener ) ; } catch ( Illegal State Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( FTP Illegal Reply Exception e ) { throw e ; } catch ( FTP Exception e ) { throw e ; } catch ( FTP Data Transfer Exception e ) { throw e ; } catch ( FTP Aborted Exception e ) { throw e ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public final static boolean is Java Like File Name ( String name ) { if ( name == null ) return BOOL ; return index Of Java Like Extension ( name ) != - NUM ; }
private static List < C Reference > parse References ( final int expression Id , final I Code Node Provider dataset ) throws Parser Exception { final List < C Reference > references = new Array List < C Reference > ( ) ; boolean has References = BOOL ; do { final C Reference reference = dataset . get Reference ( ) ; if ( reference == null ) { if ( has References ) { dataset . prev ( ) ; } break ; } has References = BOOL ; final int current Expression Id = dataset . get Expression Tree Id ( ) ; if ( expression Id != current Expression Id ) { dataset . prev ( ) ; break ; } references . add ( reference ) ; } while ( dataset . next ( ) ) ; return references ; }
private Properties load Properties From External File ( String file Path , Properties fallback ) { Properties properties = new Properties ( fallback ) ; try { File Input Stream property File Stream = new File Input Stream ( file Path ) ; properties . load ( property File Stream ) ; return properties ; } catch ( Null Pointer Exception e ) { return fallback ; } catch ( File Not Found Exception e ) { return fallback ; } catch ( IO Exception e ) { return fallback ; } }
public void to EPL ( String Writer writer ) { writer . write ( STRING ) ; writer . write ( window Name ) ; Projected Stream . to EPL Views ( writer , views ) ; }
public void remove Listeners ( ) { if ( click Listeners != null ) { click Listeners . clear ( ) ; } if ( select Listeners != null ) { select Listeners . clear ( ) ; } }
public void add Generic Attr ( Generic Attr g ) { generic . add Element ( g ) ; g . resolve ( this ) ; }
protected void compare To DEQ Sim Events ( final String deqsim Events File ) { Linked List < Event > copy Event List = new Linked List < Event > ( ) ; for ( int i = NUM ; i < all Events . size ( ) ; i ++ ) { if ( ! ( all Events . get ( i ) instanceof Activity Start Event || all Events . get ( i ) instanceof Activity End Event ) ) { copy Event List . add ( all Events . get ( i ) ) ; } } Array List < Event Log > deq Sim Log = Cpp Event File Parser . parse File ( deqsim Events File ) ; for ( int i = NUM ; i < copy Event List . size ( ) ; i ++ ) { assert True ( STRING , Cpp Event File Parser . equals ( copy Event List . get ( i ) , deq Sim Log . get ( i ) ) ) ; } }
@ Override public UUID create Exit Node ( UUID parent Node ) { UUID uuid = UUID . random UUID ( ) ; graph Server . add Vertex ( uuid ) ; graph Server . add Edge ( parent Node , uuid ) ; exit Node Map . put ( uuid , parent Node ) ; return uuid ; }
Output Stream write Channel ( int channel ) throws IO Exception { while ( os != null ) { boolean can Write = BOOL ; synchronized ( WRITE LOCK ) { if ( ! is Write Locked ) { is Write Locked = BOOL ; can Write = BOOL ; } else { try { WRITE LOCK . wait ( NUM ) ; } catch ( Exception e ) { } } } if ( can Write ) { os . write ( STRING ) ; os . write ( channel > > NUM ) ; os . write ( channel ) ; return os ; } } return null ; }
boolean check Server Up ( String server Id ) { if ( ( server Id == null ) || ( server Id . is Empty ( ) ) ) { return BOOL ; } if ( server Id . equals Ignore Case ( local Server Id ) ) { return BOOL ; } if ( ( servers == null ) || servers . is Empty ( ) ) { return BOOL ; } State Info info = servers . get ( server Id ) ; info . is Up = check Server Up ( info ) ; return info . is Up ; }
private void write Object ( Object Output Stream p stream ) throws IO Exception { p stream . default Write Object ( ) ; item color table . write object ( p stream ) ; other color table . write object ( p stream ) ; }
public Mock Response add Header ( String name , Object value ) { return add Header ( name + STRING + String . value Of ( value ) ) ; }
public static double standard Normal Cdf ( double x ) { double a = ( x ) / ( Math . sqrt ( NUM ) ) ; return NUM * ( NUM + Error Function . erf ( a ) ) ; }
public void update Result ( String name ) { String Buffer buff = m Results . get ( name ) ; if ( buff == null ) { return ; } if ( m Single Name == name ) { m Single Text . set Text ( buff . to String ( ) ) ; } J Text Component current Text = m Framed Output . get ( name ) ; if ( current Text != null ) { current Text . set Text ( buff . to String ( ) ) ; } }
public Path Controller ( J List l , J Label label , Default List Model model , J Button add , J File Chooser chooser , J Button remove , J Button up , J Button down , List Data Listener lstnr ) { this . l = l ; this . label = label ; this . model = model ; this . add = add ; this . remove = remove ; this . up = up ; this . down = down ; this . chooser = chooser ; this . lstnr = lstnr ; l . set Model ( model ) ; if ( model != null ) { model . add List Data Listener ( this ) ; } add . set Action Command ( STRING ) ; remove . set Action Command ( STRING ) ; up . set Action Command ( STRING ) ; down . set Action Command ( STRING ) ; add . add Action Listener ( this ) ; remove . add Action Listener ( this ) ; up . add Action Listener ( this ) ; down . add Action Listener ( this ) ; l . add List Selection Listener ( this ) ; remove . set Enabled ( BOOL ) ; up . set Enabled ( BOOL ) ; down . set Enabled ( BOOL ) ; }
public List < Interval > insert ( List < Interval > intervals , Interval new Interval ) { List < Interval > res = new Array List < > ( ) ; res . add ( new Interval ) ; if ( intervals == null || intervals . size ( ) == NUM ) { return res ; } for ( Interval i : intervals ) { int start = res . get ( res . size ( ) - NUM ) . start ; int end = res . get ( res . size ( ) - NUM ) . end ; if ( i . end < start ) { res . add ( res . size ( ) - NUM , i ) ; } else if ( end < i . start ) { res . add ( i ) ; } else { start = Math . min ( start , i . start ) ; end = Math . max ( end , i . end ) ; res . set ( res . size ( ) - NUM , new Interval ( start , end ) ) ; } } return res ; }
public D Export Private Key Pkcs 8 ( J Frame parent , String entry Alias , Password Quality Config password Quality Config ) { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; this . entry Alias = entry Alias ; this . password Quality Config = password Quality Config ; init Components ( ) ; }
public SQL Query ( Class < T > type , String sql Expression ) { this ( sql Expression , type . get Name ( ) , null , DEFAULT QUERY RESULT TYPE , null ) ; }
private void update Adapter Items ( ) { Section Info last Section Info = null ; String last Section Name = null ; Fast Scroll Section Info last Fast Scroller Section Info = null ; int position = NUM ; int app Index = NUM ; m Filtered Apps . clear ( ) ; m Fast Scroller Sections . clear ( ) ; m Adapter Items . clear ( ) ; m Sections . clear ( ) ; if ( DEBUG PREDICTIONS ) { if ( m Predicted App Components . is Empty ( ) && ! m Apps . is Empty ( ) ) { m Predicted App Components . add ( new Component Key ( m Apps . get ( NUM ) . component Name , User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new Component Key ( m Apps . get ( NUM ) . component Name , User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new Component Key ( m Apps . get ( NUM ) . component Name , User Handle Compat . my User Handle ( ) ) ) ; m Predicted App Components . add ( new Component Key ( m Apps . get ( NUM ) . component Name , User Handle Compat . my User Handle ( ) ) ) ; } } m Predicted Apps . clear ( ) ; if ( m Predicted App Components != null && ! m Predicted App Components . is Empty ( ) && ! has Filter ( ) ) { for ( Component Key ck : m Predicted App Components ) { App Info info = m Component To App Map . get ( ck ) ; if ( info != null ) { m Predicted Apps . add ( info ) ; } else { if ( Launcher App State . is Dogfood Build ( ) ) { Log . e ( TAG , STRING + ck . flatten To String ( m Launcher ) ) ; } } if ( m Predicted Apps . size ( ) == m Num Predicted Apps Per Row ) { break ; } } if ( ! m Predicted Apps . is Empty ( ) ) { last Section Info = new Section Info ( ) ; last Fast Scroller Section Info = new Fast Scroll Section Info ( STRING ) ; Adapter Item section Item = Adapter Item . as Section Break ( position ++ , last Section Info ) ; m Sections . add ( last Section Info ) ; m Fast Scroller Sections . add ( last Fast Scroller Section Info ) ; m Adapter Items . add ( section Item ) ; for ( App Info info : m Predicted Apps ) { Adapter Item app Item = Adapter Item . as Predicted App ( position ++ , last Section Info , STRING , last Section Info . num Apps ++ , info , app Index ++ ) ; if ( last Section Info . first App Item == null ) { last Section Info . first App Item = app Item ; last Fast Scroller Section Info . fast Scroll To Item = app Item ; } m Adapter Items . add ( app Item ) ; m Filtered Apps . add ( info ) ; } } } for ( App Info info : get Filters App Infos ( ) ) { String section Name = get And Update Cached Section Name ( info . title ) ; if ( last Section Info == null || ! section Name . equals ( last Section Name ) ) { last Section Name = section Name ; last Section Info = new Section Info ( ) ; last Fast Scroller Section Info = new Fast Scroll Section Info ( section Name ) ; m Sections . add ( last Section Info ) ; m Fast Scroller Sections . add ( last Fast Scroller Section Info ) ; if ( ! has Filter ( ) ) { Adapter Item section Item = Adapter Item . as Section Break ( position ++ , last Section Info ) ; m Adapter Items . add ( section Item ) ; } } Adapter Item app Item = Adapter Item . as App ( position ++ , last Section Info , section Name , last Section Info . num Apps ++ , info , app Index ++ ) ; if ( last Section Info . first App Item == null ) { last Section Info . first App Item = app Item ; last Fast Scroller Section Info . fast Scroll To Item = app Item ; } m Adapter Items . add ( app Item ) ; m Filtered Apps . add ( info ) ; } if ( has Filter ( ) ) { if ( has No Filtered Results ( ) ) { m Adapter Items . add ( Adapter Item . as Empty Search ( position ++ ) ) ; } else { m Adapter Items . add ( Adapter Item . as Divider ( position ++ ) ) ; } m Adapter Items . add ( Adapter Item . as Market Search ( position ++ ) ) ; } merge Sections ( ) ; if ( m Num Apps Per Row != NUM ) { int num Apps In Section = NUM ; int num Apps In Row = NUM ; int row Index = - NUM ; for ( Adapter Item item : m Adapter Items ) { item . row Index = NUM ; if ( item . view Type == All Apps Grid Adapter . SECTION BREAK VIEW TYPE ) { num Apps In Section = NUM ; } else if ( item . view Type == All Apps Grid Adapter . ICON VIEW TYPE || item . view Type == All Apps Grid Adapter . PREDICTION ICON VIEW TYPE ) { if ( num Apps In Section % m Num Apps Per Row == NUM ) { num Apps In Row = NUM ; row Index ++ ; } item . row Index = row Index ; item . row App Index = num Apps In Row ; num Apps In Section ++ ; num Apps In Row ++ ; } } m Num App Rows In Adapter = row Index + NUM ; switch ( m Fast Scroll Distribution Mode ) { case FAST SCROLL FRACTION DISTRIBUTE BY ROWS FRACTION : float row Fraction = NUM / m Num App Rows In Adapter ; for ( Fast Scroll Section Info info : m Fast Scroller Sections ) { Adapter Item item = info . fast Scroll To Item ; if ( item . view Type != All Apps Grid Adapter . ICON VIEW TYPE && item . view Type != All Apps Grid Adapter . PREDICTION ICON VIEW TYPE ) { info . touch Fraction = NUM ; continue ; } float sub Row Fraction = item . row App Index * ( row Fraction / m Num Apps Per Row ) ; info . touch Fraction = item . row Index * row Fraction + sub Row Fraction ; } break ; case FAST SCROLL FRACTION DISTRIBUTE BY NUM SECTIONS : float per Section Touch Fraction = NUM / m Fast Scroller Sections . size ( ) ; float cumulative Touch Fraction = NUM ; for ( Fast Scroll Section Info info : m Fast Scroller Sections ) { Adapter Item item = info . fast Scroll To Item ; if ( item . view Type != All Apps Grid Adapter . ICON VIEW TYPE && item . view Type != All Apps Grid Adapter . PREDICTION ICON VIEW TYPE ) { info . touch Fraction = NUM ; continue ; } info . touch Fraction = cumulative Touch Fraction ; cumulative Touch Fraction += per Section Touch Fraction ; } break ; } } if ( m Adapter != null ) { m Adapter . notify Data Set Changed ( ) ; } }
public Math Vector rotate ( double angle ) { double rad = angle * TO RADIANS ; double cos = Math . cos ( rad ) ; double sin = Math . sin ( rad ) ; double new X = this . x * cos - this . y * sin ; double new Y = this . x * sin + this . y * cos ; this . x = new X ; this . y = new Y ; return this ; }
private void write Document ( File output Dir , Document xml Doc , Transformer transformer , String name , String current Date String ) throws Transformer Exception , IO Exception { DOM Source source = new DOM Source ( xml Doc ) ; File output File = new File ( output Dir , STRING ) ; Stream Result result = new Stream Result ( output File ) ; transformer . transform ( source , result ) ; Buffered Reader reader = new Buffered Reader ( new File Reader ( output File ) ) ; List < String > lines = new Array List < > ( ) ; String line ; while ( ( line = reader . read Line ( ) ) != null ) { lines . add ( line ) ; } reader . close ( ) ; Buffered Writer writer = new Buffered Writer ( new File Writer ( output File ) ) ; for ( int i = NUM ; i < lines . size ( ) ; i ++ ) { line = lines . get ( i ) ; if ( i == NUM ) { writer . write ( String . format ( STRING , name , current Date String ) ) ; } writer . write ( line + STRING ) ; } writer . close ( ) ; }
public static boolean is Yesterday ( Date date ) { Calendar calendar = Calendar . get Instance ( ) ; calendar . add ( Calendar . DAY OF MONTH , - NUM ) ; int now Year = calendar . get ( Calendar . YEAR ) ; int now Month = calendar . get ( Calendar . MONTH ) ; int now Month Day = calendar . get ( Calendar . DAY OF MONTH ) ; calendar . set Time In Millis ( date . get Time ( ) ) ; int then Year = calendar . get ( Calendar . YEAR ) ; int then Month = calendar . get ( Calendar . MONTH ) ; int then Month Day = calendar . get ( Calendar . DAY OF MONTH ) ; return ( then Year == now Year ) && ( then Month == now Month ) && ( then Month Day == now Month Day ) ; }
private static File create Reserve Disk Cache Dir ( Context context ) { File cache Dir = Storage Utils . get Cache Directory ( context , BOOL ) ; File individual Dir = new File ( cache Dir , STRING ) ; if ( individual Dir . exists ( ) || individual Dir . mkdir ( ) ) { cache Dir = individual Dir ; } return cache Dir ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; new Vector . add Element ( new Option ( STRING , STRING , NUM , STRING ) ) ; return new Vector . elements ( ) ; }
public boolean remove Entry ( int x Index , int data Set Index ) { if ( data Set Index >= m Data Sets . size ( ) ) return BOOL ; T data Set = m Data Sets . get ( data Set Index ) ; Entry e = data Set . get Entry For X Index ( x Index ) ; if ( e == null || e . get X Index ( ) != x Index ) return BOOL ; return remove Entry ( e , data Set Index ) ; }
private void write File ( File file , byte [ ] input , Compression Mode mode ) throws IO Exception { try ( Output Stream os = get Output Stream For Mode ( mode , new File Output Stream ( file ) ) ) { os . write ( input ) ; } }
public static void close ( @ Nullable Auto Closeable rsrc , @ Nullable Ignite Logger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( Exception e ) { warn ( log , STRING + e . get Message ( ) ) ; } }
public Writable Raster create Compatible Writable Raster ( int w , int h ) { if ( w <= NUM || h <= NUM ) { throw new Raster Format Exception ( STRING + ( ( w <= NUM ) ? STRING : STRING ) ) ; } Sample Model sm = sample Model . create Compatible Sample Model ( w , h ) ; return new Short Interleaved Raster ( sm , new Point ( NUM , NUM ) ) ; }
public static String [ ] executor Command ( Config config , Config runtime , int container Index , List < Integer > free Ports ) { if ( free Ports . size ( ) < PORTS REQUIRED FOR EXECUTOR ) { throw new Runtime Exception ( STRING ) ; } for ( int port : free Ports ) { if ( port == - NUM ) { throw new Runtime Exception ( STRING ) ; } } List < String > ports = new Linked List < > ( ) ; for ( int port : free Ports ) { ports . add ( Integer . to String ( port ) ) ; } return get Executor Command ( config , runtime , container Index , ports ) ; }
public Update Request add ( final Collection < Solr Input Document > docs ) { if ( documents == null ) { documents = new Linked Hash Map < > ( ) ; } for ( Solr Input Document doc : docs ) { Objects . require Non Null ( doc , STRING ) ; documents . put ( doc , null ) ; } return this ; }
private void load Or Execute Query Phase ( final Shard Search Request request , final Search Context context , final Query Phase query Phase ) throws Exception { final boolean can Cache = indices Query Cache . can Cache ( request , context ) ; if ( can Cache ) { indices Query Cache . load Into Context ( request , context , query Phase ) ; } else { query Phase . execute ( context ) ; } }
public Simple Object Permission Set ( ) { }
@ Override public final void add Bezier Curve C ( final float x , final float y , final float x2 , final float y2 , final float x3 , final float y3 ) { elements . add ( new Cubic Curve To ( x , y , x2 , y2 , x3 , y3 ) ) ; current Pos [ NUM ] = x3 ; current Pos [ NUM ] = y3 ; }
private void save Bucket ( Auto Mix Bucket bucket ) { if ( ! bucket . is Playlist Session Error ( ) ) { Shared Preferences prefs = get Prefs ( ) ; Shared Preferences . Editor editor = prefs . edit ( ) ; final String id = bucket . get Session Id ( ) ; if ( id != null ) { editor . put String ( PREF PREFIX NAME + id , bucket . m Name ) ; editor . put Float ( PREF PREFIX ADVENTUROUS + id , bucket . m Adventurousness ) ; editor . put Float ( PREF PREFIX ENERGY + id , bucket . m Energy ) ; editor . put Float ( PREF PREFIX FAMILIAR + id , bucket . m Familiar ) ; editor . put String ( PREF PREFIX MOODS + id , Utils . implode ( bucket . m Moods , STRING ) ) ; editor . put String ( PREF PREFIX SONG TYPES + id , Utils . implode ( bucket . m Song Types , STRING ) ) ; editor . put Float ( PREF PREFIX SPEECHINESS + id , bucket . m Speechiness ) ; editor . put String ( PREF PREFIX STYLES + id , Utils . implode ( bucket . m Styles , STRING ) ) ; editor . put Boolean ( PREF PREFIX TASTE + id , bucket . m Use Taste ) ; Set < String > set = new Tree Set < > ( prefs . get String Set ( PREF BUCKETS IDS , new Tree Set < String > ( ) ) ) ; set . add ( id ) ; editor . put String Set ( PREF BUCKETS IDS , set ) ; editor . apply ( ) ; } } else { Log . e ( TAG , STRING ) ; } }
@ Override public void accept Offer ( Offer offer ) { future Accepted Offers . on Next ( offer ) ; offers . remove ( offer ) ; accepted Offers . add ( offer ) ; }
private void inject Dependencies ( ) { Sample Application easy MVP Application = ( Sample Application ) get Application ( ) ; List < Object > activity Scope Modules = ( get Modules ( ) != null ) ? get Modules ( ) : new Array List < > ( ) ; activity Scope Modules . add ( new Activity Module ( this ) ) ; activity Scope Modules . add ( new Presenter Module ( ) ) ; activity Scope Graph = easy MVP Application . build Graph With Aditional Modules ( activity Scope Modules ) ; inject ( this ) ; }
public synchronized void read Request ( ) { if ( current Writers == NUM && writer Locks . size ( ) == NUM ) { ++ current Readers ; } else { ++ queued Readers ; try { wait ( ) ; } catch ( Interrupted Exception e ) { } } }
public long read UTC Date ( ) throws IO Exception { expect Start Tag ( STRING ) ; if ( utc Calendar == null ) utc Calendar = Calendar . get Instance ( Time Zone . get Time Zone ( STRING ) ) ; long value = parse Date ( utc Calendar ) ; expect End Tag ( STRING ) ; return value ; }
public void remove Selection Listener ( final Selection Listener listener ) { check Widget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR NULL ARGUMENT ) ; } selection Listeners . remove ( listener ) ; }
private String read Fully ( Input Stream input ) throws IO Exception { if ( input == null ) { throw new File Not Found Exception ( ) ; } final Buffered Reader in = new Buffered Reader ( new Input Stream Reader ( input , charset ) ) ; try { String Builder sb = new String Builder ( ) ; String line ; while ( ( line = in . read Line ( ) ) != null ) { if ( sb . length ( ) > NUM ) { sb . append ( STRING ) ; } sb . append ( line ) ; } return sb . to String ( ) ; } finally { in . close ( ) ; } }
public boolean revision Contains Template Names ( int rev Id , List < String > template Names ) throws Wiki Api Exception { List < String > tpl List = get Template Names From Revision ( rev Id ) ; for ( String tpl : tpl List ) { for ( String template Name : template Names ) { if ( tpl . equals Ignore Case ( template Name ) ) { return BOOL ; } } } return BOOL ; }
private static boolean within Three ( I Node n , I Node goal ) { Double Linked List < I Move > moves = n . valid Moves ( ) ; for ( Iterator < I Move > it = moves . iterator ( ) ; it . has Next ( ) ; ) { I Move move = it . next ( ) ; I Node successor = n . copy ( ) ; move . execute ( successor ) ; if ( within Two ( successor , goal ) ) { return BOOL ; } } return BOOL ; }
public static boolean write XMP Meta ( Input Stream input Stream , Output Stream output Stream , XMP Meta meta ) { List < Section > sections = parse ( input Stream , BOOL ) ; sections = insert XMP Section ( sections , meta ) ; if ( sections == null ) { return BOOL ; } try { write Jpeg File ( output Stream , sections ) ; } catch ( IO Exception e ) { Log . d ( TAG , STRING , e ) ; return BOOL ; } finally { if ( output Stream != null ) { try { output Stream . close ( ) ; } catch ( IO Exception e ) { } } } return BOOL ; }
@ Override public void close Write ( ) throws IO Exception { if ( is Close Write ) { return ; } is Close Write = BOOL ; boolean is Shutdown Output = BOOL ; if ( s != null ) { try { s . shutdown Output ( ) ; is Shutdown Output = BOOL ; } catch ( Unsupported Operation Exception e ) { log . log ( Level . FINEST , e . to String ( ) , e ) ; } catch ( Exception e ) { log . finer ( e . to String ( ) ) ; log . log ( Level . FINEST , e . to String ( ) , e ) ; } } }
private void prefetch Statement Data ( Statement Data data ) throws Replicator Exception { statements ++ ; String sql Query = null ; try { if ( data . get Query ( ) != null ) sql Query = data . get Query ( ) ; else { try { sql Query = new String ( data . get Query As Bytes ( ) , data . get Charset ( ) ) ; } catch ( Unsupported Encoding Exception e ) { sql Query = new String ( data . get Query As Bytes ( ) ) ; } } statement . clear Batch ( ) ; boolean has Transform = BOOL ; boolean fetch Secondary Indexes = BOOL ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING + sql Query ) ; } Sql Operation parsing = ( Sql Operation ) data . get Parsing Metadata ( ) ; if ( parsing . get Operation ( ) == Sql Operation . INSERT ) { Matcher m = insert . matcher ( sql Query ) ; if ( m . matches ( ) ) { if ( m . group ( NUM ) != null ) sql Query = m . group ( NUM ) ; else sql Query = m . group ( NUM ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; transformed ++ ; has Transform = BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; } } else if ( parsing . get Operation ( ) == Sql Operation . DELETE ) { Matcher m = delete . matcher ( sql Query ) ; if ( m . matches ( ) ) { sql Query = STRING + m . group ( NUM ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; transformed ++ ; has Transform = BOOL ; fetch Secondary Indexes = BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; } } else if ( parsing . get Operation ( ) == Sql Operation . UPDATE ) { Matcher m = update . matcher ( sql Query ) ; if ( m . matches ( ) ) { sql Query = STRING + m . group ( NUM ) + STRING + m . group ( NUM ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; transformed ++ ; has Transform = BOOL ; fetch Secondary Indexes = BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; } } else if ( parsing . get Operation ( ) == Sql Operation . SET ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; has Transform = BOOL ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; } String schema = data . get Default Schema ( ) ; Long timestamp = data . get Timestamp ( ) ; List < Repl Option > options = data . get Options ( ) ; apply Use Schema ( schema ) ; apply Set Timestamp ( timestamp ) ; apply Session Variables ( options ) ; try { statement . execute Batch ( ) ; } catch ( SQL Warning e ) { String msg = STRING + data . to String ( ) + STRING + e . get Message ( ) ; logger . warn ( msg ) ; } catch ( SQL Exception e ) { if ( data . get Error Code ( ) == NUM ) { String msg = STRING + data . to String ( ) ; SQL Exception sql Exception = new SQL Exception ( msg ) ; sql Exception . init Cause ( e ) ; throw sql Exception ; } } finally { statement . clear Batch ( ) ; } Result Set rs = null ; if ( has Transform ) { if ( prefetch Row Limit > NUM ) sql Query = prefetch Transformer . add Limit To Query ( sql Query , prefetch Row Limit ) ; try { if ( logger . is Debug Enabled ( ) ) logger . debug ( STRING + sql Query ) ; rs = statement . execute Query ( sql Query ) ; prefetched Queries ++ ; if ( fetch Secondary Indexes ) { prefetch Indexes For Statement ( data , parsing , rs ) ; } } finally { close Result Set ( rs ) ; } } } catch ( SQL Exception e ) { log Failed Statement SQL ( data . get Query ( ) , e ) ; throw new Applier Exception ( e ) ; } }
private boolean ensure Data In Buffer ( ) throws IO Exception { if ( m Buffer Offset < m Buffered Size ) { return BOOL ; } final int read Data = m Input Stream . read ( m Byte Array ) ; if ( read Data <= NUM ) { return BOOL ; } m Buffered Size = read Data ; m Buffer Offset = NUM ; return BOOL ; }
public static Object invoke ( Invocation State invocation State , Class < ? > target Class , Object o , Object functional Object , Class < ? > invoker , String method , boolean [ ] primitives , Object [ ] args ) throws Throwable { if ( primitives . length != args . length ) throw new Lt Bug ( STRING ) ; List < Method > method List = new Array List < > ( ) ; Queue < Class < ? > > interfaces = new Array Deque < > ( ) ; Class < ? > c = o == null ? target Class : o . get Class ( ) ; while ( c != null ) { Collections . add All ( interfaces , c . get Interfaces ( ) ) ; fill Method Candidates ( c , invoker , method , args , method List , o == null ) ; c = c . get Superclass ( ) ; } c = o == null ? target Class : o . get Class ( ) ; Collections . add All ( interfaces , c . get Interfaces ( ) ) ; while ( ! interfaces . is Empty ( ) ) { Class < ? > i = interfaces . remove ( ) ; fill Method Candidates ( i , invoker , method , args , method List , o == null ) ; Collections . add All ( interfaces , i . get Interfaces ( ) ) ; } if ( method List . is Empty ( ) ) { if ( c . is Array ( ) ) { if ( method . equals ( STRING ) && args . length >= NUM && args [ NUM ] instanceof Integer ) { Object res = Array . get ( o , ( Integer ) args [ NUM ] ) ; if ( args . length == NUM ) return res ; boolean [ ] bs = new boolean [ primitives . length - NUM ] ; Object [ ] as = new Object [ args . length - NUM ] ; for ( int i = NUM ; i < args . length ; ++ i ) { bs [ i - NUM ] = primitives [ i ] ; as [ i - NUM ] = args [ i ] ; } return invoke ( invocation State , target Class , res , null , invoker , STRING , bs , as ) ; } else if ( method . equals ( STRING ) && args . length >= NUM && args [ NUM ] instanceof Integer ) { if ( args . length == NUM ) { Array . set ( o , ( Integer ) args [ NUM ] , args [ NUM ] ) ; return args [ NUM ] ; } else { Object elem = Array . get ( o , ( Integer ) args [ NUM ] ) ; boolean [ ] bs = new boolean [ primitives . length - NUM ] ; Object [ ] as = new Object [ args . length - NUM ] ; for ( int i = NUM ; i < args . length ; ++ i ) { bs [ i - NUM ] = primitives [ i ] ; as [ i - NUM ] = args [ i ] ; } return invoke ( invocation State , target Class , elem , null , invoker , STRING , bs , as ) ; } } } else { if ( args . length == NUM && is Box Type ( c ) && is Box Type ( args [ NUM ] . get Class ( ) ) ) { return invoke Primitive ( o , method , args [ NUM ] ) ; } else if ( args . length == NUM && is Box Type ( c ) ) { return invoke Primitive ( o , method ) ; } else if ( method . equals ( STRING ) && args . length == NUM && ( args [ NUM ] instanceof String || o instanceof String ) ) { return String . value Of ( o ) + String . value Of ( args [ NUM ] ) ; } else if ( method . equals ( STRING ) ) { return invoke ( invocation State , target Class , o , functional Object , invoker , STRING , primitives , args ) ; } else if ( method . equals ( STRING ) && args . length == NUM ) { return ! Lt Runtime . cast To Bool ( o ) ; } } if ( ! invocation State . is Calling Reverse ) { if ( o != null && args . length == NUM && args [ NUM ] != null ) { String method Name = STRING + method ; Object 2 = args [ NUM ] ; Invocation State reverse Invocation State = new Invocation State ( ) ; reverse Invocation State . is Calling Reverse = BOOL ; try { return invoke ( reverse Invocation State , 2 . get Class ( ) , 2 , null , invoker , method Name , new boolean [ ] { BOOL } , new Object [ ] { o } ) ; } catch ( Throwable t ) { if ( reverse Invocation State . method Found ) { throw t ; } } } if ( functional Object != null ) { Invocation State call Functional State = new Invocation State ( ) ; try { return call Functional Object ( call Functional State , functional Object , invoker , args ) ; } catch ( Throwable t ) { if ( call Functional State . method Found ) throw t ; } } invocation State . method Found = BOOL ; Method call = null ; try { Class < ? > cc = target Class ; if ( o != null ) { cc = o . get Class ( ) ; } call = cc . get Method ( STRING , Object . class , String . class , boolean [ ] . class , Object [ ] . class ) ; if ( Modifier . is Static ( call . get Modifiers ( ) ) && ! call . get Return Type ( ) . equals ( void . class ) ) { invocation State . method Found = BOOL ; } } catch ( No Such Method Exception ignore ) { } if ( invocation State . method Found ) { assert call != null ; try { return call . invoke ( null , o , method , primitives , args ) ; } catch ( Invocation Target Exception e ) { throw e . get Target Exception ( ) ; } } } if ( ! invocation State . from Field && ! invocation State . is Calling Reverse ) { Object result = Lt Runtime . get Field ( o , method , invoker ) ; if ( result != null && ! result . equals ( Unit . get ( ) ) ) { invocation State . method Found = BOOL ; return call Functional Object ( result , invoker , args ) ; } } String Builder sb = new String Builder ( ) . append ( o == null ? target Class . get Name ( ) : o . get Class ( ) . get Name ( ) ) . append ( STRING ) . append ( method ) . append ( STRING ) ; boolean is First = BOOL ; for ( Object arg : args ) { if ( is First ) is First = BOOL ; else sb . append ( STRING ) ; sb . append ( arg == null ? STRING : arg . get Class ( ) . get Name ( ) ) ; } sb . append ( STRING ) ; throw new Lt Runtime Exception ( STRING + sb . to String ( ) ) ; } Method method To Invoke = find Best Match ( method List , args , primitives ) ; invocation State . method Found = BOOL ; trans To Required Type ( args , method To Invoke . get Parameter Types ( ) ) ; method To Invoke . set Accessible ( BOOL ) ; try { Object res = method To Invoke . invoke ( o , args ) ; if ( method To Invoke . get Return Type ( ) == void . class ) return Unit . get ( ) ; else return res ; } catch ( Invocation Target Exception e ) { throw e . get Target Exception ( ) ; } }
public final boolean is Valid ( ) { return ! Float . is Na N ( x ) && ! Float . is Infinite ( x ) && ! Float . is Na N ( y ) && ! Float . is Infinite ( y ) ; }
private void visualize R Tree Entry ( SVG Plot svgp , Element layer , Projection Parallel proj , Abstract R Star Tree < ? extends N , E , ? > rtree , E entry , int depth , int step ) { final int dim = proj . get Visible Dimensions ( ) ; double [ ] min = proj . fast Project Data To Render Space ( Spatial Util . get Min ( entry ) ) ; double [ ] max = proj . fast Project Data To Render Space ( Spatial Util . get Max ( entry ) ) ; assert ( min . length == dim && max . length == dim ) ; SVG Path path = new SVG Path ( ) ; for ( int i = NUM ; i < dim ; i ++ ) { path . draw To ( get Visible Axis X ( i ) , Math . max ( min [ i ] , max [ i ] ) ) ; } for ( int i = dim - NUM ; i >= NUM ; i -- ) { path . draw To ( get Visible Axis X ( i ) , Math . min ( min [ i ] , max [ i ] ) ) ; } path . close ( ) ; Element intervals = path . make Element ( svgp ) ; SVG Util . add CSS Class ( intervals , INDEX + depth ) ; layer . append Child ( intervals ) ; if ( ! entry . is Leaf Entry ( ) ) { N node = rtree . get Node ( entry ) ; for ( int i = NUM ; i < node . get Num Entries ( ) ; i ++ ) { E child = node . get Entry ( i ) ; if ( ! child . is Leaf Entry ( ) ) { visualize R Tree Entry ( svgp , layer , proj , rtree , child , depth + NUM , ++ step ) ; } } } }
public static URL [ ] path To UR Ls ( String path ) { String Tokenizer st = new String Tokenizer ( path , File . path Separator ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; int count = NUM ; while ( st . has More Tokens ( ) ) { URL url = file To URL ( new File ( st . next Token ( ) ) ) ; if ( url != null ) { urls [ count ++ ] = url ; } } urls = Arrays . copy Of ( urls , count ) ; return urls ; }
@ Override public long add File ( String file Name , Input Stream input Stream , long file Size ) throws IO Exception , Name Taken Exception , Internal Exception { try { String image Path = get Image File Path ( file Name ) ; logger . info ( STRING , image Path ) ; try ( Nfc File Output Stream output Stream = nfc Client . put File ( image Path , file Size ) ) { for ( int i = NUM ; i < file Size ; i ++ ) { output Stream . write ( input Stream . read ( ) ) ; } } return file Size ; } finally { if ( input Stream != null ) { input Stream . close ( ) ; } } }
protected void fire Fatal Connection Error ( SQL Exception ex ) { Connection Event evt = new Connection Event ( this , ex ) ; for ( Connection Event Listener listener : connection Event Listeners ) { listener . connection Error Occurred ( evt ) ; } }
public static void put Object Volatile ( Object obj , long off , Object val ) { UNSAFE . put Object Volatile ( obj , off , val ) ; }
public void bind ( ) throws Exception { if ( is Bind . get And Set ( BOOL ) ) { return ; } if ( protocol == null ) { throw new Illegal State Exception ( L . l ( STRING , this ) ) ; } if ( port < NUM && unix Path == null ) { return ; } Socket System system = Socket System . current ( ) ; if ( throttle == null ) { throttle = new Throttle Socket ( ) ; } String ssl = ssl Factory != null ? STRING : STRING ; if ( server Socket != null ) { Inet Address address = server Socket . get Local Address ( ) ; if ( address != null ) log . info ( STRING + address . get Host Name ( ) + STRING + server Socket . get Local Port ( ) ) ; else log . info ( STRING + server Socket . get Local Port ( ) ) ; } else if ( socket Address != null ) { server Socket = system . open Server Socket ( socket Address , port , accept Listen Backlog , is Enable Jni ) ; log . info ( protocol . name ( ) + ssl + STRING + socket Address . get Host Name ( ) + STRING + server Socket . get Local Port ( ) ) ; } else { server Socket = system . open Server Socket ( null , port , accept Listen Backlog , is Enable Jni ) ; log . info ( protocol . name ( ) + ssl + STRING + server Socket . get Local Port ( ) ) ; } assert ( server Socket != null ) ; post Bind ( ) ; }
private void add Datasets To Plot States ( ) { if ( dataset List . is Empty ( ) ) { throw new Parser Exception ( STRING ) ; } int actual Auto Dataset Nr = NUM ; for ( Plot State plot State : parser Result . get Plot State List ( ) ) { actual Auto Dataset Nr = add Dataset ( plot State , actual Auto Dataset Nr ) ; for ( Plot State sub Plot State : plot State . get Subplots ( ) ) { log . info ( STRING ) ; actual Auto Dataset Nr = add Dataset ( sub Plot State , actual Auto Dataset Nr ) ; } } }
public void render List Head ( List Head head ) { Component header ; W Table Column column ; for ( int column Index = NUM ; column Index < m table Columns . size ( ) ; column Index ++ ) { column = m table Columns . get ( column Index ) ; header = get List Header Component ( column . get Header Value ( ) , column Index , column . get Column Class ( ) ) ; head . append Child ( header ) ; } head . set Sizable ( BOOL ) ; return ; }
protected void replace Worst Point ( Point Value Pair point Value Pair , final Comparator < Point Value Pair > comparator ) { for ( int i = NUM ; i < dimension ; i ++ ) { if ( comparator . compare ( simplex [ i ] , point Value Pair ) > NUM ) { Point Value Pair tmp = simplex [ i ] ; simplex [ i ] = point Value Pair ; point Value Pair = tmp ; } } simplex [ dimension ] = point Value Pair ; }
@ Override public void encode XML ( Document doc , Element root , String element Name ) { if ( ( doc == null ) || ( root == null ) || ( element Name == null ) ) { return ; } Element data Source Element = doc . create Element ( element Name ) ; for ( String key : property Map . key Set ( ) ) { Element element = doc . create Element ( key ) ; element . append Child ( doc . create Text Node ( property Map . get ( key ) ) ) ; data Source Element . append Child ( element ) ; } root . append Child ( data Source Element ) ; }
public void add ( String field Name , String value ) { if ( field Name == null ) throw new Illegal Argument Exception ( STRING ) ; if ( value == null ) throw new Illegal Argument Exception ( STRING ) ; if ( field Name . length ( ) == NUM || field Name . index Of ( STRING ) != - NUM || value . index Of ( STRING ) != - NUM ) { throw new Illegal Argument Exception ( STRING + field Name + STRING + value ) ; } add Lenient ( field Name , value ) ; }
public static boolean is Right Click ( Mouse Event e ) { boolean result ; result = BOOL ; if ( ( e . get Button ( ) == Mouse Event . BUTTON 3 ) && ( e . get Click Count ( ) == NUM ) ) result = BOOL ; else if ( ( e . get Button ( ) == Mouse Event . BUTTON 1 ) && e . is Alt Down ( ) && ! e . is Shift Down ( ) && ! e . is Control Down ( ) ) result = BOOL ; return result ; }
private void process Run Completed Tag ( String identifier ) { Pattern time Pattern = Pattern . compile ( STRING ) ; Matcher time = time Pattern . matcher ( identifier ) ; if ( time . find ( ) ) { try { m Total Run Time = Long . parse Long ( time . group ( NUM ) ) ; } catch ( Number Format Exception e ) { Log . e ( LOG TAG , STRING + time . group ( NUM ) ) ; } } report Test Run Ended ( ) ; m Test Run In Progress = BOOL ; }
public Str Builder insert ( int index , char chars [ ] , int offset , int length ) { validate Index ( index ) ; if ( chars == null ) { return insert ( index , null Text ) ; } if ( offset < NUM || offset > chars . length ) { throw new String Index Out Of Bounds Exception ( STRING + offset ) ; } if ( length < NUM || offset + length > chars . length ) { throw new String Index Out Of Bounds Exception ( STRING + length ) ; } if ( length > NUM ) { ensure Capacity ( size + length ) ; System . arraycopy ( buffer , index , buffer , index + length , size - index ) ; System . arraycopy ( chars , offset , buffer , index , length ) ; size += length ; } return this ; }
public Element parse ( Reader is ) { buff Offset = NUM ; buff Size = - NUM ; event Parser = BOOL ; Element root Element = create New Element ( STRING ) ; try { parse Tag Content ( root Element , is ) ; } catch ( IO Exception ioe ) { ioe . print Stack Trace ( ) ; } if ( root Element . get Num Children ( ) == NUM ) { notify Error ( Parser Callback . ERROR NO ROOTS , null , null , null , STRING ) ; return null ; } else if ( root Element . get Num Children ( ) > NUM ) { String roots = STRING ; for ( int i = NUM ; i < root Element . get Num Children ( ) ; i ++ ) { Element elem = root Element . get Child At ( i ) ; if ( elem . is Text Element ( ) ) { roots += STRING + elem . get Text ( ) + STRING ; } else { roots += elem . get Tag Name ( ) + STRING ; } } if ( roots . ends With ( STRING ) ) { roots = roots . substring ( NUM , roots . length ( ) - NUM ) ; } Element first Root = root Element . get Child At ( NUM ) ; String str = null ; if ( first Root . is Text Element ( ) ) { str = STRING + first Root . get Text ( ) ; } else { str = first Root . get Tag Name ( ) ; } notify Error ( Parser Callback . ERROR MULTIPLE ROOTS , null , null , null , STRING + str + STRING + roots ) ; } root Element = root Element . get Child At ( NUM ) ; return root Element ; }
public void expand Object ( Object element Or Tree Path , int level ) { if ( check Busy ( ) ) { return ; } Object parent = get Parent Element ( element Or Tree Path ) ; if ( ! ( ( ( parent != null ) && get Expanded State ( parent ) ) || is Root Element ( element Or Tree Path ) ) ) { List < Object > objects To Expand = create Object List ( parent , new Array List < > ( ) ) ; if ( ! objects To Expand . is Empty ( ) ) { objects To Be Expanded . add All ( objects To Expand ) ; } } objects To Be Expanded . add ( element Or Tree Path ) ; Widget w = internal Expand ( element Or Tree Path , BOOL ) ; if ( w != null ) { internal Expand To Level ( w , level ) ; } }
public void append Cell ( byte value ) { append Cell ( String . value Of ( value ) ) ; }
@ Override public void init Params ( Http Servlet Request request , I Configuration configuration , Object ... params ) throws Connector Exception { super . init Params ( request , configuration ) ; this . files = new Array List < > ( ) ; get Files List From Request ( request ) ; }
@ Override protected void on Measure ( int width Measure Spec , int height Measure Spec ) { int width Spec Mode = Measure Spec . get Mode ( width Measure Spec ) ; int height Spec Mode = Measure Spec . get Mode ( height Measure Spec ) ; int parent Width = Measure Spec . get Size ( width Measure Spec ) ; int parent Height = Measure Spec . get Size ( height Measure Spec ) ; boolean resize Width = width Spec Mode != Measure Spec . EXACTLY ; boolean resize Height = height Spec Mode != Measure Spec . EXACTLY ; int width = parent Width ; int height = parent Height ; if ( s Width > NUM && s Height > NUM ) { if ( resize Width && resize Height ) { width = s Width ( ) ; height = s Height ( ) ; } else if ( resize Height ) { height = ( int ) ( ( ( ( double ) s Height ( ) / ( double ) s Width ( ) ) * width ) ) ; } else if ( resize Width ) { width = ( int ) ( ( ( ( double ) s Width ( ) / ( double ) s Height ( ) ) * height ) ) ; } } width = Math . max ( width , get Suggested Minimum Width ( ) ) ; height = Math . max ( height , get Suggested Minimum Height ( ) ) ; set Measured Dimension ( width , height ) ; }
public static String normalize ( Char Sequence src , java . text . Normalizer . Form form , int option ) { return Normalizer Base . normalize ( src . to String ( ) , form , option ) ; }
private String escapify ( String s ) { String Buffer result = new String Buffer ( s . length ( ) * NUM ) ; for ( int i = NUM ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case STRING : result . append ( STRING ) ; break ; case STRING : result . append ( STRING ) ; break ; case STRING : result . append ( STRING ) ; break ; case STRING : result . append ( STRING ) ; break ; case STRING : if ( i + NUM == s . length ( ) || s . char At ( i + NUM ) != STRING ) result . append ( STRING ) ; break ; case STRING : result . append ( STRING ) ; break ; default : result . append ( c ) ; } } return result . to String ( ) ; }
public static String escape Som ( String s ) { if ( s == null ) return STRING ; int idx = s . index Of ( STRING ) ; if ( idx < NUM ) return s ; String Builder sb = new String Builder ( ) ; int last = NUM ; while ( idx >= NUM ) { sb . append ( s . substring ( last , idx ) ) ; sb . append ( STRING ) ; last = idx ; idx = s . index Of ( STRING , idx + NUM ) ; } sb . append ( s . substring ( last ) ) ; return sb . to String ( ) ; }
public static void queue Column Load ( I Cubic World world , Cube IO loader , int x , int z , Consumer < Column > runnable ) { Queued Column key = new Queued Column ( x , z , world ) ; Async Column IO Provider task = column Tasks . get ( key ) ; if ( task == null ) { task = new Async Column IO Provider ( key , loader ) ; task . add Callback ( runnable ) ; column Tasks . put ( key , task ) ; pool . execute ( task ) ; } else { task . add Callback ( runnable ) ; } }
synchronized boolean visit ( ) throws IO Exception { if ( exc != null ) { return BOOL ; } if ( current == null ) { if ( iter . has Next ( ) == BOOL ) { c . close ( ) ; return BOOL ; } Map . Entry < String , File Meta Data > next = iter . next ( ) ; File Meta Data meta Data = next . get Value ( ) ; String file Name = next . get Key ( ) ; long len = c . in . read V Long ( ) ; if ( len != meta Data . length ) { throw new Illegal State Exception ( STRING + file Name + STRING + meta Data . length + STRING + len ) ; } current = new Copy One File ( c . in , dest , file Name , meta Data , copy Buffer ) ; } if ( current . visit ( ) ) { copied Files . put ( current . name , current . tmp Name ) ; tot Bytes Copied += current . get Bytes Copied ( ) ; assert tot Bytes Copied <= tot Bytes : STRING + tot Bytes Copied + STRING + tot Bytes ; current = null ; return BOOL ; } return BOOL ; }
private void before Key ( ) throws JSON Exception { Scope context = peek ( ) ; if ( context == Scope . NONEMPTY OBJECT ) { out . append ( STRING ) ; } else if ( context != Scope . EMPTY OBJECT ) { throw new JSON Exception ( STRING ) ; } newline ( ) ; replace Top ( Scope . DANGLING KEY ) ; }
public Integer add Token Annotation ( String token String , String file Id , Integer sent Id , Integer tok Id , Integer position Counter , J Cas jcas ) { Token token = new Token ( jcas ) ; if ( ! ( ( sent Id == new Tok Sent Number ) && ( tok Id == new Tok Sent Number ) ) ) { if ( USE SPACES ) position Counter = position Counter + NUM ; } token . set Begin ( position Counter ) ; position Counter = position Counter + token String . length ( ) ; token . set End ( position Counter ) ; token . set Token Id ( tok Id ) ; token . set Sent Id ( sent Id ) ; token . set Filename ( file Id ) ; token . add To Indexes ( ) ; String id = file Id + STRING + sent Id + STRING + tok Id ; hm Token . put ( id , token ) ; return position Counter ; }
public static int calculate Lighter Color ( final int color , final float factor ) { final int a = Color . alpha ( color ) ; final int r = Color . red ( color ) ; final int g = Color . green ( color ) ; final int b = Color . blue ( color ) ; final int lightness Level = Math . round ( RGB TOTAL COLORS * factor ) ; return Color . argb ( a , Math . min ( r + lightness Level , NUM ) , Math . min ( g + lightness Level , NUM ) , Math . min ( b + lightness Level , NUM ) ) ; }
static final int from Type ( String type , Constant Pool pool ) { if ( type . length ( ) == NUM ) { switch ( type . char At ( NUM ) ) { case STRING : case STRING : case STRING : case STRING : case STRING : return INTEGER ; case STRING : return DOUBLE ; case STRING : return FLOAT ; case STRING : return LONG ; default : throw new Illegal Argument Exception ( STRING ) ; } } return Type Info . OBJECT ( type , pool ) ; }
public Beans Access Builder ( Class < ? > type , Accessor [ ] accs , Dynamic Class Loader loader ) { this . type = type ; this . accs = accs ; this . loader = loader ; this . class Name = type . get Name ( ) ; if ( class Name . starts With ( STRING ) ) this . access Class Name = STRING + class Name + STRING ; else this . access Class Name = class Name . concat ( STRING ) ; this . access Class Name Internal = access Class Name . replace ( STRING , STRING ) ; this . class Name Internal = class Name . replace ( STRING , STRING ) ; }
protected synchronized void add All Data Series ( ) { for ( Indexed Process Var pv : ( Iterable < Indexed Process Var > ) pvs . values ( ) ) { XY Series series = ( XY Series ) pv . get ( FID DATA SERIES ) ; if ( series == null ) { series = new XY Series ( String . value Of ( pv . get ( Ecu Data Pv . FID DESCRIPT ) ) ) ; pv . put ( FID DATA SERIES , series ) ; pv . add Pv Change Listener ( this , Pv Change Event . PV MODIFIED ) ; } } }
private static void assert Qual Name ( String qual Name ) throws XMP Exception { if ( qual Name == null || qual Name . length ( ) == NUM ) { throw new XMP Exception ( STRING , XMP Error . BADXPATH ) ; } }
public static String Builder format To ( String Builder buf , double [ ] d , String sep , Number Format nf ) { if ( d == null ) { return buf . append ( STRING ) ; } if ( d . length == NUM ) { return buf ; } buf . append ( nf . format ( d [ NUM ] ) ) ; for ( int i = NUM ; i < d . length ; i ++ ) { buf . append ( sep ) ; buf . append ( nf . format ( d [ i ] ) ) ; } return buf ; }
public void next Viewpoint ( ) { if ( viewpoint List . size ( ) == NUM ) { return ; } viewpoint Index ++ ; if ( viewpoint Index >= viewpoint List . size ( ) ) { viewpoint Index = NUM ; } viewpoint Node . set Viewpoint ( viewpoint List . get ( viewpoint Index ) , BOOL , BOOL ) ; }
private boolean verify Width Input ( J Component input ) { J Text Field text Field = ( J Text Field ) input ; String input String = text Field . get Text ( ) ; try { float width = Float . parse Float ( input String ) ; if ( width <= NUM ) { text Field . set Foreground ( Color . RED ) ; return BOOL ; } } catch ( Number Format Exception e ) { text Field . set Foreground ( Color . RED ) ; return BOOL ; } text Field . set Foreground ( Color . BLACK ) ; return BOOL ; }
public void add Ignored View ( View v ) { ignored Views . add ( v ) ; }
public boolean write Header ( Output Stream os ) { try { write Int ( os , CACHE MAGIC ) ; write String ( os , key ) ; write String ( os , etag == null ? STRING : etag ) ; write Long ( os , server Date ) ; write Long ( os , last Modified ) ; write Long ( os , ttl ) ; write Long ( os , soft Ttl ) ; write String String Map ( response Headers , os ) ; os . flush ( ) ; return BOOL ; } catch ( IO Exception e ) { Volley Log . d ( STRING , e . to String ( ) ) ; return BOOL ; } }
private synchronized boolean still Leased ( ) throws Interrupted Exception { if ( cancelled ) return BOOL ; expiration Time = System Time . time Millis ( ) + duration ; wait ( duration ) ; if ( renewed ) { renewed = BOOL ; return BOOL ; } expired = BOOL ; return BOOL ; }
View create Section Header If Needed ( Recycler View . Recycler recycler , int section Index ) { if ( adapter . does Section Have Header ( section Index ) ) { for ( int i = NUM , n = get Child Count ( ) ; i < n ; i ++ ) { View view = get Child At ( i ) ; if ( get View Base Type ( view ) == Sectioning Adapter . TYPE HEADER && get View Section Index ( view ) == section Index ) { return view ; } } int header Adapter Position = adapter . get Adapter Position For Section Header ( section Index ) ; View header View = recycler . get View For Position ( header Adapter Position ) ; header Views . add ( header View ) ; add View ( header View ) ; measure Child With Margins ( header View , NUM , NUM ) ; return header View ; } return null ; }
public String trim Audio ( String path , double start , double length ) throws Exception { Array List < String > cmd = new Array List < String > ( ) ; File file = new File ( path ) ; String out File = file . get Canonical Path ( ) + STRING ; cmd . add ( sox Bin ) ; cmd . add ( path ) ; cmd . add ( STRING ) ; cmd . add ( STRING ) ; cmd . add ( STRING ) ; cmd . add ( STRING ) ; cmd . add ( out File ) ; cmd . add ( STRING ) ; cmd . add ( start + STRING ) ; if ( length != - NUM ) cmd . add ( length + STRING ) ; int rc = exec Sox ( cmd , callback ) ; if ( rc != NUM ) { out File = null ; } if ( file . exists ( ) ) return out File ; else return null ; }
void start Scrolling Instance ( ) { if ( log . is Loggable ( Platform Logger . Level . FINER ) ) { log . finer ( STRING + this ) ; } scroll ( ) ; i scroller . set Scrollbar ( this ) ; i scroller . start ( ) ; }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STRING , justification = STRING ) protected void notify Target Intensity Change ( double intensity ) { double old Value = m Current Intensity ; m Current Intensity = intensity ; if ( old Value != intensity ) { fire Property Change ( STRING , Double . value Of ( old Value ) , Double . value Of ( intensity ) ) ; } }
private static boolean contents Equals ( Input Stream in 1 , Input Stream in 2 ) throws IO Exception { if ( ! ( in 1 instanceof Buffered Input Stream ) ) { in 1 = new Buffered Input Stream ( in 1 ) ; } if ( ! ( in 2 instanceof Buffered Input Stream ) ) { in 2 = new Buffered Input Stream ( in 2 ) ; } int ch = in 1 . read ( ) ; while ( ch != - NUM ) { int ch 2 = in 2 . read ( ) ; if ( ch != ch 2 ) { return BOOL ; } ch = in 1 . read ( ) ; } int ch 2 = in 2 . read ( ) ; return ch 2 == - NUM ; }
public Response new Fixed Length Response ( String msg ) { return new Fixed Length Response ( Response . Status . OK , Nano HTTPD . MIME HTML , msg ) ; }
@ Override public XML Event next Event ( ) throws XML Stream Exception { log . log ( Level . FINE , STRING ) ; current Event = next Event ; if ( current Event . get Event Type ( ) != XML Stream Constants . END DOCUMENT ) { next Event = construct Event ( stream . next ( ) , stream ) ; } else { next Event = null ; } log . log ( Level . FINE , STRING , current Event ) ; return current Event ; }
public boolean unregister Client ( Unregister Profile profile , Server Config utils , Context context ) throws App Catalog Exception { String Builder end Point = new String Builder ( ) ; end Point . append ( utils . get API Server URL ( context ) ) ; end Point . append ( Constants . DYNAMIC CLIENT REGISTER ENDPOINT ) ; end Point . append ( STRING + USER ID + STRING + profile . get User Id ( ) ) ; end Point . append ( STRING + CONSUMER KEY + STRING + profile . get Consumer Key ( ) ) ; end Point . append ( STRING + APPLICATION NAME + STRING + profile . get Application Name ( ) ) ; End Point Info end Point Info = new End Point Info ( ) ; end Point Info . set Http Method ( org . wso 2 . emm . agent . proxy . utils . Constants . HTTP METHODS . DELETE ) ; end Point Info . set End Point ( end Point . to String ( ) ) ; send Request ( end Point Info , null , Constants . DYNAMIC CLIENT UNREGISTER REQUEST CODE ) ; return BOOL ; }
public static double magnitude ( final double x , final double y , final double z ) { return Math . sqrt ( x * x + y * y + z * z ) ; }
private void update Arrow ( ) { path 1 . reset ( ) ; path 2 . reset ( ) ; path 3 . reset ( ) ; path 1 . move To ( m Real Left + radius , m Arrow Start ) ; path 1 . line To ( m Real Left + radius , m Arrow Start + radius ) ; path 2 . move To ( m Real Left + radius , m Arrow Start + radius ) ; path 2 . line To ( ( float ) ( m Real Left + radius - Math . tan ( Math . to Radians ( NUM ) ) * radius * NUM ) , m Arrow Start + radius - radius * NUM ) ; path 3 . move To ( m Real Left + radius , m Arrow Start + radius ) ; path 3 . line To ( ( float ) ( m Real Left + radius + Math . tan ( Math . to Radians ( NUM ) ) * radius * NUM ) , m Arrow Start + radius - radius * NUM ) ; path Measure 1 . set Path ( path 1 , BOOL ) ; path Measure 2 . set Path ( path 2 , BOOL ) ; path Measure 3 . set Path ( path 3 , BOOL ) ; m Arrow center length = path Measure 1 . get Length ( ) ; m Arrow left length = path Measure 2 . get Length ( ) ; m Arrow right length = path Measure 3 . get Length ( ) ; }
private static SSL Context create Easy SSL Context ( ) { SSL Context context ; try { context = SSL Context . get Instance ( STRING ) ; context . init ( null , trust Managers , new Secure Random ( ) ) ; Https URL Connection . set Default SSL Socket Factory ( context . get Socket Factory ( ) ) ; } catch ( final General Security Exception gse ) { throw new Illegal State Exception ( gse . get Message ( ) ) ; } return context ; }
protected List < String > convert List To Lower Case ( List < String > list ) { List < String > lower Case List = new Array List < > ( ) ; for ( String value : list ) { lower Case List . add ( value . to Lower Case ( ) ) ; } return lower Case List ; }
public static I Type resolve Element To Java Type ( IDOM Element element , I Java Project java Project ) { String qualified Type Name = compute Qualified Widget Type Name ( element ) ; if ( qualified Type Name == null ) { Node type Attr = get Type Attribute ( element ) ; if ( type Attr != null ) { qualified Type Name = type Attr . get Node Value ( ) ; } } if ( qualified Type Name == null ) { if ( is Image Element ( element ) ) { qualified Type Name = Ui Binder Constants . UI BINDER IMAGE RESOURCE NAME ; } else if ( is Data Element ( element ) ) { qualified Type Name = Ui Binder Constants . UI BINDER DATA RESOURCE NAME ; } else if ( is Import Element ( element ) ) { Node node = get Field Attribute ( element ) ; if ( node == null ) { return null ; } String qualified Constant = node . get Node Value ( ) ; int index = qualified Constant . last Index Of ( STRING ) ; if ( index != - NUM ) { qualified Type Name = qualified Constant . substring ( NUM , index ) ; } } } if ( qualified Type Name == null ) { return null ; } try { return java Project . find Type ( qualified Type Name ) ; } catch ( Java Model Exception e ) { GWT Plugin Log . log Warning ( e , STRING ) ; return null ; } }
public static Gapless Info parse Udta ( Atom . Leaf Atom udta Atom , boolean is Quick Time ) { if ( is Quick Time ) { return null ; } Parsable Byte Array udta Data = udta Atom . data ; udta Data . set Position ( Atom . HEADER SIZE ) ; while ( udta Data . bytes Left ( ) >= Atom . HEADER SIZE ) { int atom Size = udta Data . read Int ( ) ; int atom Type = udta Data . read Int ( ) ; if ( atom Type == Atom . TYPE meta ) { udta Data . set Position ( udta Data . get Position ( ) - Atom . HEADER SIZE ) ; udta Data . set Limit ( udta Data . get Position ( ) + atom Size ) ; return parse Meta Atom ( udta Data ) ; } else { udta Data . skip Bytes ( atom Size - Atom . HEADER SIZE ) ; } } return null ; }
public String post ( String url , String json , final int expected Status Code ) { return post ( url , json , Collections . < String , String > empty Map ( ) , expected Status Code ) ; }
protected double log Of Sum ( double log Of X , double log Of Y ) { if ( Double . is Na N ( log Of X ) ) { return log Of Y ; } if ( Double . is Na N ( log Of Y ) ) { return log Of X ; } if ( log Of X > log Of Y ) { return log Of X + Math . log ( NUM + Math . exp ( log Of Y - log Of X ) ) ; } else { return log Of Y + Math . log ( NUM + Math . exp ( log Of X - log Of Y ) ) ; } }
public Multivariate Table ( Categorical Table head Table ) { this . head Vars = new Hash Set < String > ( Arrays . as List ( head Table . get Variable ( ) ) ) ; this . table = new Hash Map < Assignment , Double > ( ) ; String variable = head Table . get Variable ( ) ; for ( Value a : head Table . get Values ( ) ) { double prob = head Table . get Prob ( a ) ; table . put ( new Assignment ( variable , a ) , prob ) ; } }
public static void update Property ( Configuration conf , String prefix , String alternative Prefix , String key , Properties props , String props Key , boolean required ) throws Configuration Parse Exception { String val = conf . get ( prefix + key ) ; if ( val == null ) { val = conf . get ( alternative Prefix + key ) ; LOG . trace ( STRING , alternative Prefix , key ) ; } if ( required && val == null ) { throw new Configuration Parse Exception ( STRING + key ) ; } if ( val != null ) { props . set Property ( props Key , val . trim ( ) ) ; } }
public Property XML Builder ( String service Name , AM Model model , Set attribute Schemas , Schema Type schema Type ) throws SMS Exception , SSO Exception { this . model = model ; this . service Name = service Name ; svc Schema Manager = new Service Schema Manager ( service Name , model . get User SSO Token ( ) ) ; if ( schema Type != null ) { if ( load Section Order ( ) ) { schema Types = new Hash Set < Schema Type > ( ) ; schema Types . add ( schema Type ) ; get Sections For Type ( ) ; } } get Service Resource Bundle ( ) ; if ( service Bundle != null ) { map Type To Attribute Schema = new Hash Map ( attribute Schemas . size ( ) * NUM ) ; map Type To Attribute Schema . put ( NULL TYPE , attribute Schemas ) ; } }
@ Override public String to String ( ) { return String . format ( STRING , get Thread Id ( ) ) ; }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( BOOL ) ; } else { return BOOL ; } } return BOOL ; }
public void put ( final Resources res , final String key , Recycling Bitmap Drawable bmp , final boolean as PNG ) { boolean is Default Art = BOOL ; final String clean Key = sanitize Key ( key ) ; if ( bmp == null ) { bmp = new Recycling Bitmap Drawable ( res , m Default Art . copy ( m Default Art . get Config ( ) , BOOL ) ) ; is Default Art = BOOL ; } if ( USE MEMORY CACHE ) { m Memory Cache . put ( clean Key , bmp ) ; } if ( ! is Default Art ) { try { File Output Stream out = new File Output Stream ( m Cache Dir . get Absolute Path ( ) + STRING + clean Key ) ; Bitmap bitmap = bmp . get Bitmap ( ) ; boolean should Recycle = BOOL ; final float max Size = NUM ; if ( bitmap . get Width ( ) > max Size && bitmap . get Height ( ) > max Size ) { float ratio = ( bitmap . get Width ( ) < bitmap . get Height ( ) ) ? bitmap . get Width ( ) / max Size : bitmap . get Height ( ) / max Size ; final int s Width = ( int ) ( bitmap . get Width ( ) / ratio ) ; final int s Height = ( int ) ( bitmap . get Height ( ) / ratio ) ; bitmap = Bitmap . create Scaled Bitmap ( bitmap , s Width , s Height , BOOL ) ; should Recycle = BOOL ; Log . d ( TAG , STRING + s Width + STRING + s Height ) ; } bitmap . compress ( as PNG ? Bitmap . Compress Format . PNG : Bitmap . Compress Format . JPEG , NUM , out ) ; out . close ( ) ; if ( should Recycle ) { bitmap . recycle ( ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STRING , e ) ; } synchronized ( m Entries ) { m Entries . add ( clean Key ) ; } } }
protected synchronized void after Space Mode Change ( Space Mode new Mode ) { if ( logger . is Loggable ( Level . FINER ) ) logger . finer ( STRING + new Mode ) ; Queue < I Space Mode Listener > remote Listeners = new Linked List < I Space Mode Listener > ( ) ; for ( Iterator < I Space Mode Listener > iter = primary Space Mode Listeners . iterator ( ) ; iter . has Next ( ) ; ) { I Space Mode Listener listener = iter . next ( ) ; try { if ( LRMI Utilities . is Remote Proxy ( listener ) ) { if ( logger . is Loggable ( Level . FINEST ) ) logger . finest ( STRING + listener . to String ( ) + STRING ) ; remote Listeners . add ( listener ) ; continue ; } listener . after Space Mode Change ( new Mode ) ; } catch ( Exception rex ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STRING + listener + STRING , rex ) ; } primary Space Mode Listeners . remove Listener ( listener ) ; } } if ( remote Listeners . size ( ) > NUM ) dispatch After Event To Remote Listeners ( remote Listeners , new Mode ) ; if ( logger . is Loggable ( Level . FINEST ) ) logger . finest ( STRING + new Mode ) ; }
private int make Available ( ) throws IO Exception { if ( pos != - NUM ) { return NUM ; } total += tail - head - pad ; System . arraycopy ( buffer , tail - pad , buffer , NUM , pad ) ; head = NUM ; tail = pad ; for ( ; ; ) { int bytes Read = input . read ( buffer , tail , buf Size - tail ) ; if ( bytes Read == - NUM ) { final String msg = STRING ; throw new Malformed Stream Exception ( msg ) ; } tail += bytes Read ; find Separator ( ) ; int av = available ( ) ; if ( av > NUM || pos != - NUM ) { return av ; } } }
public void handle Client Membership ( String client Id , int event Type ) { String notif Type = null ; List < Managed Resource > cleaned Up = null ; if ( event Type == Client Membership Message . LEFT ) { notif Type = NOTIF CLIENT LEFT ; cleaned Up = cleanup Bridge Client Resources ( client Id ) ; } else if ( event Type == Client Membership Message . CRASHED ) { notif Type = NOTIF CLIENT CRASHED ; cleaned Up = cleanup Bridge Client Resources ( client Id ) ; } else if ( event Type == Client Membership Message . JOINED ) { notif Type = NOTIF CLIENT JOINED ; } if ( cleaned Up != null ) { for ( Managed Resource resource : cleaned Up ) { M Bean Util . unregister M Bean ( resource ) ; } } Helper . send Notification ( this , new Notification ( notif Type , this . model M Bean , Helper . get Next Notification Sequence Number ( ) , client Id ) ) ; }
@ Override public boolean domain Match ( final String host , final String domain ) { final boolean match = host . equals ( domain ) || ( domain . starts With ( STRING ) && host . ends With ( domain ) ) ; return match ; }
protected double find Split Numeric Nominal ( int index ) throws Exception { double best Val = Double . MAX VALUE , curr Val , curr Cut Point ; int num Missing = NUM ; double [ ] sum = new double [ m Instances . num Classes ( ) ] ; double [ ] [ ] best Dist = new double [ NUM ] [ m Instances . num Classes ( ) ] ; for ( int i = NUM ; i < m Instances . num Instances ( ) ; i ++ ) { Instance inst = m Instances . instance ( i ) ; if ( ! inst . is Missing ( index ) ) { m Distribution [ NUM ] [ ( int ) inst . class Value ( ) ] += inst . weight ( ) ; } else { m Distribution [ NUM ] [ ( int ) inst . class Value ( ) ] += inst . weight ( ) ; num Missing ++ ; } } System . arraycopy ( m Distribution [ NUM ] , NUM , sum , NUM , m Instances . num Classes ( ) ) ; for ( int j = NUM ; j < NUM ; j ++ ) { System . arraycopy ( m Distribution [ j ] , NUM , best Dist [ j ] , NUM , m Instances . num Classes ( ) ) ; } m Instances . sort ( index ) ; for ( int i = NUM ; i < m Instances . num Instances ( ) - ( num Missing + NUM ) ; i ++ ) { Instance inst = m Instances . instance ( i ) ; Instance inst Plus One = m Instances . instance ( i + NUM ) ; m Distribution [ NUM ] [ ( int ) inst . class Value ( ) ] += inst . weight ( ) ; m Distribution [ NUM ] [ ( int ) inst . class Value ( ) ] -= inst . weight ( ) ; if ( inst . value ( index ) < inst Plus One . value ( index ) ) { curr Cut Point = ( inst . value ( index ) + inst Plus One . value ( index ) ) / NUM ; curr Val = Contingency Tables . entropy Conditioned On Rows ( m Distribution ) ; if ( curr Val < best Val ) { m Split Point = curr Cut Point ; best Val = curr Val ; for ( int j = NUM ; j < NUM ; j ++ ) { System . arraycopy ( m Distribution [ j ] , NUM , best Dist [ j ] , NUM , m Instances . num Classes ( ) ) ; } } } } if ( num Missing == NUM ) { System . arraycopy ( sum , NUM , best Dist [ NUM ] , NUM , m Instances . num Classes ( ) ) ; } m Distribution = best Dist ; return best Val ; }
public void write Tree Likelihood ( Partition Pattern partition , XML Writer writer ) { Partition Substitution Model subst Model = partition . get Partition Substitution Model ( ) ; Partition Clock Model clock Model = partition . get Partition Clock Model ( ) ; writer . write Comment ( STRING ) ; writer . write Open Tag ( Microsatellite Sampler Tree Likelihood Parser . TREE LIKELIHOOD , new Attribute [ ] { new Attribute . Default < String > ( XML Parser . ID , partition . get Prefix ( ) + Microsatellite Sampler Tree Likelihood Parser . TREE LIKELIHOOD ) } ) ; write Microsat Subst Model Ref ( subst Model , writer ) ; writer . write I Dref ( Microsatellite Sampler Tree Model Parser . TREE MICROSATELLITE SAMPLER MODEL , partition . get Name ( ) + STRING + Microsatellite Sampler Tree Model Parser . TREE MICROSATELLITE SAMPLER MODEL ) ; switch ( clock Model . get Clock Type ( ) ) { case STRICT CLOCK : writer . write I Dref ( Strict Clock Branch Rates Parser . STRICT CLOCK BRANCH RATES , clock Model . get Prefix ( ) + Branch Rate Model . BRANCH RATES ) ; break ; case UNCORRELATED : case RANDOM LOCAL CLOCK : case AUTOCORRELATED : throw new Unsupported Operation Exception ( STRING ) ; default : throw new Illegal Argument Exception ( STRING ) ; } writer . write Close Tag ( Microsatellite Sampler Tree Likelihood Parser . TREE LIKELIHOOD ) ; }
protected void save Transformed Data ( Instances ti ) { J File Chooser fc ; int ret Val ; Buffered Writer writer ; Extension File Filter filter ; fc = new J File Chooser ( ) ; filter = new Extension File Filter ( STRING , STRING ) ; fc . set File Filter ( filter ) ; ret Val = fc . show Save Dialog ( this ) ; if ( ret Val == J File Chooser . APPROVE OPTION ) { try { writer = new Buffered Writer ( new File Writer ( fc . get Selected File ( ) ) ) ; writer . write ( ti . to String ( ) ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; m Log . log Message ( STRING + e . get Message ( ) ) ; J Option Pane . show Message Dialog ( this , STRING + e . get Message ( ) , STRING , J Option Pane . ERROR MESSAGE ) ; } } }
public int read ( char cbuf [ ] , int off , int len ) throws IO Exception { synchronized ( lock ) { ensure Open ( ) ; if ( ( off < NUM ) || ( off > cbuf . length ) || ( len < NUM ) || ( ( off + len ) > cbuf . length ) || ( ( off + len ) < NUM ) ) { throw new Index Out Of Bounds Exception ( ) ; } else if ( len == NUM ) { return NUM ; } if ( next >= length ) return - NUM ; int n = Math . min ( length - next , len ) ; str . get Chars ( next , next + n , cbuf , off ) ; next += n ; return n ; } }
private Alignment read Characters Block ( Taxon List taxon List ) throws Import Exception , IO Exception { site Count = NUM ; data Type = null ; read Data Block Header ( STRING , CHARACTERS BLOCK ) ; Simple Alignment alignment = new Simple Alignment ( ) ; read Sequence Data ( alignment , taxon List ) ; alignment . update Site Count ( ) ; find End Block ( ) ; return alignment ; }
@ Override public String to Parsable String ( Type declaring Type , Type Tuple input Types , Type output Type ) { return declaring Type . get Name ( ) + STRING + field . get Name ( ) + STRING ; }
public Dialogue Importer ( Dialogue System system , List < Dialogue State > turns ) { this . system = system ; this . turns = turns ; }
private J Radio Button add Radio Button ( String text , Container container , int left Indent ) { J Radio Button radio Button = new J Radio Button ( text ) ; radio Button . set Alignment X ( Component . LEFT ALIGNMENT ) ; radio Button . set Border ( Border Factory . create Empty Border ( NUM , left Indent , NUM , NUM ) ) ; container . add ( radio Button ) ; return radio Button ; }
protected void close Out Unwanted Embedded Tags ( Attribute Set attr ) throws IO Exception { tags To Remove . remove All Elements ( ) ; attr = convert To HTML ( attr , null ) ; HTML . Tag t ; Object t Value ; int first Index = - NUM ; int size = tags . size ( ) ; for ( int i = size - NUM ; i >= NUM ; i -- ) { t = tags . element At ( i ) ; t Value = tag Values . element At ( i ) ; if ( ( attr == null ) || no Match For Tag In Attributes ( attr , t , t Value ) ) { first Index = i ; tags To Remove . add Element ( t ) ; } } if ( first Index != - NUM ) { boolean remove All = ( ( size - first Index ) == tags To Remove . size ( ) ) ; for ( int i = size - NUM ; i >= first Index ; i -- ) { t = tags . element At ( i ) ; if ( remove All || tags To Remove . contains ( t ) ) { tags . remove Element At ( i ) ; tag Values . remove Element At ( i ) ; } write ( STRING ) ; write ( STRING ) ; write ( t . to String ( ) ) ; write ( STRING ) ; } size = tags . size ( ) ; for ( int i = first Index ; i < size ; i ++ ) { t = tags . element At ( i ) ; write ( STRING ) ; write ( t . to String ( ) ) ; Object o = tag Values . element At ( i ) ; if ( o != null && o instanceof Attribute Set ) { write Attributes ( ( Attribute Set ) o ) ; } write ( STRING ) ; } } }
public Business Object Data Key create Business Object Data Key ( Business Object Data business Object Data ) { Business Object Data Key business Object Data Key = new Business Object Data Key ( ) ; business Object Data Key . set Namespace ( business Object Data . get Namespace ( ) ) ; business Object Data Key . set Business Object Definition Name ( business Object Data . get Business Object Definition Name ( ) ) ; business Object Data Key . set Business Object Format Usage ( business Object Data . get Business Object Format Usage ( ) ) ; business Object Data Key . set Business Object Format File Type ( business Object Data . get Business Object Format File Type ( ) ) ; business Object Data Key . set Business Object Format Version ( business Object Data . get Business Object Format Version ( ) ) ; business Object Data Key . set Partition Value ( business Object Data . get Partition Value ( ) ) ; business Object Data Key . set Sub Partition Values ( business Object Data . get Sub Partition Values ( ) ) ; business Object Data Key . set Business Object Data Version ( business Object Data . get Version ( ) ) ; return business Object Data Key ; }
private void populate Recycler List ( ) { talk Adapter . set Cycle ( cycle ) ; talk Adapter . set Incoming Outgoing ( data Usage ) ; talk Adapter . set Divider Header ( new Recycler Divider ( resources . get String ( R . string . add to plan header ) , NUM ) ) ; List < Offer > talk Offers = new Array List < > ( ) ; for ( Offer offer : accepted Offers ) { if ( ( offer . get Type ( ) ) == Plan Constants . TALK ) { talk Offers . add ( offer ) ; } } talk Adapter . set Card Offers ( talk Offers ) ; }
@ Nullable public Gr Literal find Module Reference ( @ Not Null Module module ) { check Initialized ( ) ; String module Gradle Path = get Module Gradle Path ( module ) ; if ( module Gradle Path != null ) { commit Document Changes ( ) ; for ( Gr Method Call include Statement : get Method Calls ( my Groovy File , INCLUDE METHOD ) ) { for ( Gr Literal lit : get Literal Arguments ( include Statement ) ) { if ( module Gradle Path . equals ( lit . get Value ( ) ) ) { return lit ; } } } } return null ; }
public static Process Result execute LLVM Binary ( File bitcode File , Object [ ] args ) { try { File object File = File . create Temp File ( absolute Path To File Name ( bitcode File ) , STRING ) ; object File . delete On Exit ( ) ; File executable = File . create Temp File ( absolute Path To File Name ( bitcode File ) , STRING ) ; executable . delete On Exit ( ) ; LLC . compile Bit Code To Object File ( bitcode File , object File ) ; GCC . compile Object To Machine Code ( object File , executable ) ; String Builder command Builder = new String Builder ( executable . get Absolute Path ( ) ) ; if ( args != null ) { for ( int i = NUM ; i < args . length ; i ++ ) { command Builder . append ( STRING ) ; command Builder . append ( args [ i ] ) ; } } return Process Util . execute Native Command ( command Builder . to String ( ) ) ; } catch ( Exception e ) { throw new Assertion Error ( e ) ; } }
protected < T extends Data Object > void check For Pending Tasks ( T object , URI tenant URI ) { Block Service Utils . check For Pending Tasks ( tenant URI , Arrays . as List ( object ) , db Client ) ; }
Index Entry ( Byte Provider byte Provider ) throws IO Exception { MXF Property Populator . populate Field ( byte Provider , this , STRING ) ; MXF Property Populator . populate Field ( byte Provider , this , STRING ) ; MXF Property Populator . populate Field ( byte Provider , this , STRING ) ; MXF Property Populator . populate Field ( byte Provider , this , STRING ) ; }
public void clean Up Listeners ( ) { synchronized ( listener Object Map ) { for ( Object Name object Name : listener Object Map . key Set ( ) ) { Notification Hub Listener listener = listener Object Map . get ( object Name ) ; if ( listener != null ) { try { mbean Server . remove Notification Listener ( object Name , listener ) ; } catch ( Listener Not Found Exception e ) { } catch ( Instance Not Found Exception e ) { } } } } listener Object Map . clear ( ) ; }
private static int find Esds Position ( Parsable Byte Array parent , int position , int size ) { int child Atom Position = parent . get Position ( ) ; while ( child Atom Position - position < size ) { parent . set Position ( child Atom Position ) ; int child Atom Size = parent . read Int ( ) ; Assertions . check Argument ( child Atom Size > NUM , STRING ) ; int child Type = parent . read Int ( ) ; if ( child Type == Atom . TYPE esds ) { return child Atom Position ; } child Atom Position += child Atom Size ; } return - NUM ; }
public static void write Uuid ( Byte Buf buf , UUID uuid ) { buf . write Long ( uuid . get Most Significant Bits ( ) ) ; buf . write Long ( uuid . get Least Significant Bits ( ) ) ; }
public Flux Concat Array < T > concat Additional Source Last ( Publisher < ? extends T > source ) { int n = array . length ; @ Suppress Warnings ( STRING ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM ] ; System . arraycopy ( array , NUM , new Array , NUM , n ) ; new Array [ n ] = source ; return new Flux Concat Array < > ( delay Error , new Array ) ; }
@ Override public void shutdown ( ) { m Thread Pool Slow . shutdown ( ) ; m Thread Pool Fast . shutdown ( ) ; }
private static void check Name ( String zone Id ) { int n = zone Id . length ( ) ; if ( n < NUM ) { throw new Date Time Exception ( STRING + zone Id ) ; } for ( int i = NUM ; i < n ; i ++ ) { char c = zone Id . char At ( i ) ; if ( c >= STRING && c <= STRING ) continue ; if ( c >= STRING && c <= STRING ) continue ; if ( c == STRING && i != NUM ) continue ; if ( c >= STRING && c <= STRING && i != NUM ) continue ; if ( c == STRING && i != NUM ) continue ; if ( c == STRING && i != NUM ) continue ; if ( c == STRING && i != NUM ) continue ; if ( c == STRING && i != NUM ) continue ; if ( c == STRING && i != NUM ) continue ; throw new Date Time Exception ( STRING + zone Id ) ; } }
public void bind ( Server Socket Bar ss ) throws IO Exception { Objects . require Non Null ( ss ) ; is Bind . set ( BOOL ) ; if ( protocol == null ) throw new Illegal State Exception ( L . l ( STRING , this ) ) ; if ( throttle == null ) throttle = new Throttle Socket ( ) ; server Socket = ss ; String scheme = protocol . name ( ) ; if ( address != null ) log . info ( scheme + STRING + address + STRING + port ) ; else log . info ( scheme + STRING + port ) ; if ( ssl Factory != null ) { try { server Socket = ssl Factory . bind ( server Socket ) ; } catch ( Runtime Exception e ) { throw e ; } catch ( IO Exception e ) { throw e ; } catch ( Exception e ) { throw new IO Exception ( e ) ; } } }
private synchronized void make Composite Builder ( ) throws Invalid Object Exception { if ( composite Builder != null ) return ; Class target Class = ( Class < ? > ) get Target Type ( ) ; Composite Builder [ ] [ ] builders = { { new Composite Builder Via From ( target Class , item Names ) } , { new Composite Builder Via Constructor ( target Class , item Names ) } , { new Composite Builder Check Getters ( target Class , item Names , getter Converters ) , new Composite Builder Via Setters ( target Class , item Names ) , new Composite Builder Via Proxy ( target Class , item Names ) } } ; Composite Builder found Builder = null ; String Builder why Nots = new String Builder ( ) ; Throwable possible Cause = null ; find : for ( Composite Builder [ ] related Builders : builders ) { for ( int i = NUM ; i < related Builders . length ; i ++ ) { Composite Builder builder = related Builders [ i ] ; String why Not = builder . applicable ( getters ) ; if ( why Not == null ) { found Builder = builder ; break find ; } Throwable cause = builder . possible Cause ( ) ; if ( cause != null ) possible Cause = cause ; if ( why Not . length ( ) > NUM ) { if ( why Nots . length ( ) > NUM ) why Nots . append ( STRING ) ; why Nots . append ( why Not ) ; if ( i == NUM ) break ; } } } if ( found Builder == null ) { String msg = STRING + target Class . get Name ( ) + STRING + why Nots ; if ( possible Cause != null ) msg += STRING ; throw invalid Object Exception ( msg , possible Cause ) ; } composite Builder = found Builder ; }
public void generate All Dot Desc For Wagon ( Print Writer out , Set < String > features To Ignore ) { out . println ( STRING ) ; out . println ( STRING ) ; for ( int i = NUM , n = get Number Of Features ( ) ; i < n ; i ++ ) { out . print ( STRING ) ; String feature Name = get Feature Name ( i ) ; out . print ( feature Name ) ; if ( features To Ignore != null && features To Ignore . contains ( feature Name ) ) { out . print ( STRING ) ; } if ( i < num Byte Features + num Short Features ) { for ( int v = NUM , vmax = get Number Of Values ( i ) ; v < vmax ; v ++ ) { out . print ( STRING ) ; String val = get Feature Value As String ( i , v ) ; if ( val . index Of ( STRING ) != - NUM ) { String Builder buf = new String Builder ( ) ; for ( int c = NUM ; c < val . length ( ) ; c ++ ) { char ch = val . char At ( c ) ; if ( ch == STRING ) buf . append ( STRING ) ; else buf . append ( ch ) ; } val = buf . to String ( ) ; } out . print ( STRING + val + STRING ) ; } out . println ( STRING ) ; } else { out . println ( STRING ) ; } } out . println ( STRING ) ; }
public void write ( String filename ) { logger . info ( STRING ) ; try { open File ( filename ) ; write Xml Head ( ) ; start Carriers ( this . writer ) ; for ( Carrier carrier : carriers ) { start Carrier ( carrier , this . writer ) ; write Vehicles And Their Types ( carrier , this . writer ) ; write Shipments ( carrier , this . writer ) ; write Services ( carrier , this . writer ) ; write Plans ( carrier , this . writer ) ; end Carrier ( this . writer ) ; } end Carriers ( this . writer ) ; close ( ) ; logger . info ( STRING ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; logger . error ( e ) ; System . exit ( NUM ) ; } }
public void add Resource Listener ( Resource Events Listener listener ) { resource Listeners . add ( listener ) ; }
public void test Missing Main Activity ( ) throws Exception { m Enabled . add ( Launcher Activity Detector . ISSUE MORE THAN ONE LAUNCHER ) ; m Enabled . add ( Launcher Activity Detector . ISSUE MISSING LAUNCHER ) ; m Enabled . add ( Launcher Activity Detector . ISSUE LAUNCHER ACTIVITY IN LIBRARY ) ; String expected = STRING + STRING + STRING + STRING + STRING ; String result = lint Project ( xml ( FN ANDROID MANIFEST XML , STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ) ) ; assert Equals ( expected , result ) ; }
public void print String ( String v , int str Offset , int length ) throws IO Exception { int offset = offset ; byte [ ] buffer = buffer ; for ( int i = NUM ; i < length ; i ++ ) { if ( SIZE <= offset + NUM ) { offset = offset ; flush Buffer ( ) ; offset = offset ; } char ch = v . char At ( i + str Offset ) ; if ( ch < NUM ) buffer [ offset ++ ] = ( byte ) ( ch ) ; else if ( ch < NUM ) { buffer [ offset ++ ] = ( byte ) ( NUM + ( ( ch > > NUM ) & NUM ) ) ; buffer [ offset ++ ] = ( byte ) ( NUM + ( ch & NUM ) ) ; } else { buffer [ offset ++ ] = ( byte ) ( NUM + ( ( ch > > NUM ) & NUM ) ) ; buffer [ offset ++ ] = ( byte ) ( NUM + ( ( ch > > NUM ) & NUM ) ) ; buffer [ offset ++ ] = ( byte ) ( NUM + ( ch & NUM ) ) ; } } offset = offset ; }
public String build Jvm Vendor ( ) { return properties . get Property ( STRING ) ; }
Tree Bin ( Tree Node < K , V > b ) { super ( TREEBIN , null , null , null ) ; this . first = b ; Tree Node < K , V > r = null ; for ( Tree Node < K , V > x = b , next ; x != null ; x = next ) { next = ( Tree Node < K , V > ) x . next ; x . left = x . right = null ; if ( r == null ) { x . parent = null ; x . red = BOOL ; r = x ; } else { K k = x . key ; int h = x . hash ; Class < ? > kc = null ; for ( Tree Node < K , V > p = r ; ; ) { int dir , ph ; K pk = p . key ; if ( ( ph = p . hash ) > h ) dir = - NUM ; else if ( ph < h ) dir = NUM ; else if ( ( kc == null && ( kc = comparable Class For ( k ) ) == null ) || ( dir = compare Comparables ( kc , k , pk ) ) == NUM ) dir = tie Break Order ( k , pk ) ; Tree Node < K , V > xp = p ; if ( ( p = ( dir <= NUM ) ? p . left : p . right ) == null ) { x . parent = xp ; if ( dir <= NUM ) xp . left = x ; else xp . right = x ; r = balance Insertion ( r , x ) ; break ; } } } } this . root = r ; assert check Invariants ( root ) ; }
public void select Map Element ( Map Element map Element ) { if ( map Element == null ) { tree . set Selection Path ( null ) ; return ; } Default Mutable Tree Node tree Node = null ; if ( map Element instanceof Landmark ) { int n = landmarks Node . get Child Count ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Default Mutable Tree Node dmtn = ( Default Mutable Tree Node ) landmarks Node . get Child At ( i ) ; if ( ( Map Element ) dmtn . get User Object ( ) == map Element ) { tree Node = dmtn ; break ; } } if ( tree Node != null ) { tree . set Selection Path ( new Tree Path ( new Object [ ] { root Node , landmarks Node , tree Node } ) ) ; } } else if ( map Element instanceof Tool ) { int n = tools Node . get Child Count ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Default Mutable Tree Node dmtn = ( Default Mutable Tree Node ) tools Node . get Child At ( i ) ; if ( ( Map Element ) dmtn . get User Object ( ) == map Element ) { tree Node = dmtn ; break ; } } if ( tree Node != null ) { tree . set Selection Path ( new Tree Path ( new Object [ ] { root Node , tools Node , tree Node } ) ) ; } } else if ( map Element instanceof Line Set ) { int n = line Sets Node . get Child Count ( ) ; for ( int i = NUM ; i < n ; ++ i ) { Default Mutable Tree Node dmtn = ( Default Mutable Tree Node ) line Sets Node . get Child At ( i ) ; if ( ( Map Element ) dmtn . get User Object ( ) == map Element ) { tree Node = dmtn ; break ; } } if ( tree Node != null ) { tree . set Selection Path ( new Tree Path ( new Object [ ] { root Node , line Sets Node , tree Node } ) ) ; } } }
protected static void launch ( Class < ? extends Activity > activity ) { final Intent intent = new Intent ( application , activity ) ; intent . put Extra ( CONTENT , content Layout View ) ; intent . put Extra ( BG COLOR , background Color ) ; intent . put Extra ( INIT ACTIVITY , init Activity Name ) ; intent . set Flags ( Intent . FLAG ACTIVITY CLEAR TASK | Intent . FLAG ACTIVITY NEW TASK ) ; application . start Activity ( intent ) ; }
private void record ( ) { for ( Keep Free Area keep Free Area : keep Free Areas ) { for ( Player player : keep Free Area . get Players ( ) ) { Player Position Entry entry = new Player Position Entry ( player , keep Free Area ) ; if ( ! player Positions . contains ( entry ) ) { player Positions . add ( entry ) ; } } } }
private void on Main Content Scrolled ( int current Y , int delta Y ) { if ( delta Y > m Action Bar Auto Hide Sensivity ) { delta Y = m Action Bar Auto Hide Sensivity ; } else if ( delta Y < - m Action Bar Auto Hide Sensivity ) { delta Y = - m Action Bar Auto Hide Sensivity ; } if ( Math . signum ( delta Y ) * Math . signum ( m Action Bar Auto Hide Signal ) < NUM ) { m Action Bar Auto Hide Signal = delta Y ; } else { m Action Bar Auto Hide Signal += delta Y ; } boolean should Show = current Y < m Action Bar Auto Hide Min Y || ( m Action Bar Auto Hide Signal <= - m Action Bar Auto Hide Sensivity ) ; auto Show Or Hide Action Bar ( should Show ) ; }
public String generate Name ( final Int Unary Operator random In Range , final int length , final char starting Symbol ) { if ( length == NUM ) { return STRING ; } final String Builder sb = new String Builder ( ) ; sb . append ( starting Symbol ) ; while ( sb . length ( ) < length ) { for ( int i = NUM ; i < sb . length ( ) ; i ++ ) { final char current Char = sb . char At ( i ) ; final boolean is Current Char Upper Case = Character . is Upper Case ( current Char ) ; if ( is Current Char Upper Case ) { final String substitution = choose Random Rule Option ( random In Range , current Char ) ; if ( substitution != null ) { String temp = sb . to String ( ) ; temp = temp . replace ( String . value Of ( current Char ) , substitution ) ; sb . set Length ( NUM ) ; sb . append ( temp ) ; i -- ; } } } if ( sb . length ( ) < length ) { sb . set Length ( NUM ) ; sb . append ( starting Symbol ) ; } } if ( length >= NUM ) { return sb . substring ( NUM , length ) ; } else { return sb . to String ( ) ; } }
public static void play Sound Buffer ( byte [ ] wav Data ) { float sample Rate = NUM ; int sample Size In Bits = NUM ; int channels = NUM ; boolean signed = ( sample Size In Bits > NUM ) ; boolean big Endian = BOOL ; Audio Format format = new Audio Format ( sample Rate , sample Size In Bits , channels , signed , big Endian ) ; Source Data Line line ; Data Line . Info info = new Data Line . Info ( Source Data Line . class , format ) ; if ( ! Audio System . is Line Supported ( info ) ) { log . warn ( STRING + info ) ; return ; } try { line = ( Source Data Line ) Audio System . get Line ( info ) ; line . open ( format ) ; } catch ( Line Unavailable Exception ex ) { log . error ( STRING + ex ) ; return ; } line . start ( ) ; line . write ( wav Data , NUM , wav Data . length ) ; }
private void tql 2 ( ) { for ( int i = NUM ; i < n ; i ++ ) { e [ i - NUM ] = e [ i ] ; } e [ n - NUM ] = NUM ; double f = NUM ; double tst 1 = NUM ; double eps = Math . pow ( NUM , - NUM ) ; for ( int l = NUM ; l < n ; l ++ ) { tst 1 = Math . max ( tst 1 , Math . abs ( d [ l ] ) + Math . abs ( e [ l ] ) ) ; int m = l ; while ( m < n ) { if ( Math . abs ( e [ m ] ) <= eps * tst 1 ) { break ; } m ++ ; } if ( m > l ) { int iter = NUM ; do { iter = iter + NUM ; double g = d [ l ] ; double p = ( d [ l + NUM ] - g ) / ( NUM * e [ l ] ) ; double r = Algebra . hypot ( p , NUM ) ; if ( p < NUM ) { r = - r ; } d [ l ] = e [ l ] / ( p + r ) ; d [ l + NUM ] = e [ l ] * ( p + r ) ; double dl 1 = d [ l + NUM ] ; double h = g - d [ l ] ; for ( int i = l + NUM ; i < n ; i ++ ) { d [ i ] -= h ; } f = f + h ; p = d [ m ] ; double c = NUM ; double c2 = c ; double c3 = c ; double el 1 = e [ l + NUM ] ; double s = NUM ; double s2 = NUM ; for ( int i = m - NUM ; i >= l ; i -- ) { c3 = c2 ; c2 = c ; s2 = s ; g = c * e [ i ] ; h = c * p ; r = Algebra . hypot ( p , e [ i ] ) ; e [ i + NUM ] = s * r ; s = e [ i ] / r ; c = p / r ; p = c * d [ i ] - s * g ; d [ i + NUM ] = h + s * ( c * g + s * d [ i ] ) ; for ( int k = NUM ; k < n ; k ++ ) { h = V [ k ] [ i + NUM ] ; V [ k ] [ i + NUM ] = s * V [ k ] [ i ] + c * h ; V [ k ] [ i ] = c * V [ k ] [ i ] - s * h ; } } p = - s * s2 * c3 * el 1 * e [ l ] / dl 1 ; e [ l ] = s * p ; d [ l ] = c * p ; } while ( Math . abs ( e [ l ] ) > eps * tst 1 ) ; } d [ l ] = d [ l ] + f ; e [ l ] = NUM ; } for ( int i = NUM ; i < n - NUM ; i ++ ) { int k = i ; double p = d [ i ] ; for ( int j = i + NUM ; j < n ; j ++ ) { if ( d [ j ] < p ) { k = j ; p = d [ j ] ; } } if ( k != i ) { d [ k ] = d [ i ] ; d [ i ] = p ; for ( int j = NUM ; j < n ; j ++ ) { p = V [ j ] [ i ] ; V [ j ] [ i ] = V [ j ] [ k ] ; V [ j ] [ k ] = p ; } } } }
public static double calculate Row Total ( Values 2 D data , int row , int [ ] valid Cols ) { Param Checks . null Not Permitted ( data , STRING ) ; double total = NUM ; int col Count = data . get Column Count ( ) ; for ( int v = NUM ; v < valid Cols . length ; v ++ ) { int col = valid Cols [ v ] ; if ( col < col Count ) { Number n = data . get Value ( row , col ) ; if ( n != null ) { total += n . double Value ( ) ; } } } return total ; }
void open ( ) { if ( ! main Frame . can Navigate Away ( ) ) { return ; } if ( ask To Save ( ) ) { return ; } boolean loading = BOOL ; Save Type file Type ; try Again : while ( loading ) { int value = save Open File Chooser . show Open Dialog ( main Frame ) ; if ( value != J File Chooser . APPROVE OPTION ) { return ; } loading = BOOL ; file Type = convert Filter To Type ( save Open File Chooser . get File Filter ( ) ) ; final File f = save Open File Chooser . get Selected File ( ) ; if ( ! file Type . is Valid ( f ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STRING , STRING , J Option Pane . WARNING MESSAGE ) ; loading = BOOL ; continue ; } switch ( file Type ) { case XML ANALYSIS : if ( ! f . get Name ( ) . ends With ( STRING ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , L10 N . get Local String ( STRING , STRING ) ) ; loading = BOOL ; continue try Again ; } if ( ! main Frame . open Analysis ( f , file Type ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STRING ) ; loading = BOOL ; continue try Again ; } break ; case FBP FILE : if ( ! open FBP File ( f ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STRING ) ; loading = BOOL ; continue try Again ; } break ; case FBA FILE : if ( ! open FBA File ( f ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STRING ) ; loading = BOOL ; continue try Again ; } break ; default : assert BOOL ; } } }
public void children Removed ( Bean Context Membership Event bcme ) { Iterator it = bcme . iterator ( ) ; while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public String process ( Item item ) throws Process Exception { int count = NUM ; Item ss = item . get Item As ( Relation . SYLLABLE ) ; Item first Syllable = FIRST SYLLABLE PATH . find Item ( item ) ; for ( Item p = ss ; p != null ; p = p . get Previous ( ) , count ++ ) { if ( p . equals Shared ( first Syllable ) ) { break ; } } return Integer . to String ( rail ( count ) ) ; }
private void remove Instances From Containers ( Array List < Container > containers , Map < Integer , List < Instance Id > > allocation , Map < String , Integer > components To Scale Down ) { Array List < Ram Requirement > ram Requirements = get Sorted RAM Instances ( components To Scale Down ) ; for ( Ram Requirement ram Requirement : ram Requirements ) { String component = ram Requirement . get Component Name ( ) ; int num Instances To Remove = - components To Scale Down . get ( component ) ; for ( int j = NUM ; j < num Instances To Remove ; j ++ ) { Pair < Integer , Instance Id > id Pair = remove FFD Instance ( containers , component ) ; List < Instance Id > instances = allocation . get ( id Pair . first ) ; instances . remove ( id Pair . second ) ; allocation . put ( id Pair . first , instances ) ; } } }
private void draw Lifeline Part ( Draw Handler draw Handler , final double center X , final double start Y , boolean active Count Inc Start , final double end Y , boolean active Count Inc End , int active Count , List Iterator < Line 1 D > interrupted Areas ) { double next Start Y = start Y ; boolean draw Head = BOOL ; if ( interrupted Areas . has Next ( ) ) { Line 1 D area = interrupted Areas . next ( ) ; if ( area . contains ( next Start Y ) ) { draw Head = BOOL ; next Start Y = area . get High ( ) ; } else { interrupted Areas . previous ( ) ; } } boolean drawing Finished = BOOL ; boolean draw End = BOOL ; double current End Y ; double current Start Y ; while ( ! drawing Finished ) { current Start Y = next Start Y ; if ( interrupted Areas . has Next ( ) ) { Line 1 D area = interrupted Areas . next ( ) ; if ( area . get Low ( ) < end Y ) { current End Y = area . get Low ( ) ; next Start Y = area . get High ( ) ; if ( area . get High ( ) > end Y ) { drawing Finished = BOOL ; interrupted Areas . previous ( ) ; } } else { interrupted Areas . previous ( ) ; drawing Finished = BOOL ; draw End = BOOL ; current End Y = end Y ; } } else { drawing Finished = BOOL ; draw End = BOOL ; current End Y = end Y ; } if ( active Count == NUM ) { draw Handler . set Line Type ( Line Type . DASHED ) ; draw Handler . draw Line ( center X , current Start Y , center X , current End Y ) ; } else { draw Handler . set Line Type ( Line Type . SOLID ) ; double line X = center X - EXECUTIONSPECIFICATION WIDTH / NUM ; draw Handler . draw Line ( line X , current Start Y , line X , current End Y ) ; for ( int i = NUM ; i < active Count - NUM ; i ++ ) { line X += EXECUTIONSPECIFICATION WIDTH - EXECUTIONSPECIFICATION OVERLAPP ; draw Handler . draw Line ( line X , current Start Y , line X , current End Y ) ; } line X += EXECUTIONSPECIFICATION WIDTH ; draw Handler . draw Line ( line X , current Start Y , line X , current End Y ) ; if ( draw Head && active Count Inc Start ) { draw Handler . draw Line ( line X - EXECUTIONSPECIFICATION WIDTH , current Start Y , line X , current Start Y ) ; } if ( draw End && ! active Count Inc End ) { draw Handler . draw Line ( line X - EXECUTIONSPECIFICATION WIDTH , current End Y , line X , current End Y ) ; } } draw Head = BOOL ; } }
public boolean check Entry ( int i , String road Name , String road Number , String consist Number , String loco 1 Address , String loco 2 Address , String loco 3 Address , String loco 4 Address , String loco 5 Address , String loco 6 Address , String id ) { Nce Consist Roster Entry r = list . get ( i ) ; if ( id != null && ! id . equals ( r . get Id ( ) ) ) { return BOOL ; } if ( road Name != null && ! road Name . equals ( r . get Road Name ( ) ) ) { return BOOL ; } if ( road Number != null && ! road Number . equals ( r . get Road Number ( ) ) ) { return BOOL ; } if ( consist Number != null && ! consist Number . equals ( r . get Consist Number ( ) ) ) { return BOOL ; } if ( loco 1 Address != null && ! loco 1 Address . equals ( r . get Loco 1 Dcc Address ( ) ) ) { return BOOL ; } if ( loco 2 Address != null && ! loco 2 Address . equals ( r . get Loco 2 Dcc Address ( ) ) ) { return BOOL ; } if ( loco 3 Address != null && ! loco 3 Address . equals ( r . get Loco 3 Dcc Address ( ) ) ) { return BOOL ; } if ( loco 4 Address != null && ! loco 4 Address . equals ( r . get Loco 4 Dcc Address ( ) ) ) { return BOOL ; } if ( loco 5 Address != null && ! loco 5 Address . equals ( r . get Loco 5 Dcc Address ( ) ) ) { return BOOL ; } if ( loco 6 Address != null && ! loco 6 Address . equals ( r . get Loco 6 Dcc Address ( ) ) ) { return BOOL ; } return BOOL ; }
private static void start Listening ( final Ignite ignite , Ignite Messaging imsg ) throws Ignite Exception { imsg . remote Listen ( TOPIC . ORDERED , null ) ; imsg . remote Listen ( TOPIC . UNORDERED , null ) ; }
public static void register Experimental Flags ( C Flags flags ) { reset Accessed Status ( ) ; final String [ ] cat = flags . get Categories ( ) ; if ( cat != null ) { final String [ ] copy = Arrays . copy Of ( cat , cat . length + NUM ) ; copy [ copy . length - NUM ] = CATEGORY ; flags . set Categories ( flags . get Help Category ( ) , copy ) ; } for ( final Flag flag : FLAGS ) { flags . register ( flag ) ; } s Flags = flags ; }
@ Suppress Warnings ( STRING ) private String ent ( char flag ) throws Exception { char ch ; int idx = m Buff Idx + NUM ; Input inp = null ; String str = null ; mE St = NUM ; bappend ( STRING ) ; for ( short st = NUM ; st >= NUM ; ) { ch = ( m Ch Idx < m Ch Len ) ? m Chars [ m Ch Idx ++ ] : getch ( ) ; switch ( st ) { case NUM : case NUM : switch ( chtyp ( ch ) ) { case STRING : case STRING : case STRING : if ( st != NUM ) { panic ( FAULT ) ; } case STRING : case STRING : case STRING : case STRING : bappend ( ch ) ; eappend ( ch ) ; st = NUM ; break ; case STRING : if ( m Is NS Aware != BOOL ) { panic ( FAULT ) ; } bappend ( ch ) ; eappend ( ch ) ; st = NUM ; break ; case STRING : if ( mE St < NUM ) { m Buff Idx = idx - NUM ; bappend ( mE St ) ; st = - NUM ; break ; } else if ( m Ph == PH DTD ) { bappend ( STRING ) ; st = - NUM ; break ; } str = new String ( m Buff , idx + NUM , m Buff Idx - idx ) ; inp = m Ent . get ( str ) ; m Buff Idx = idx - NUM ; if ( inp != null ) { if ( inp . chars == null ) { Input Source is = resolve Ent ( str , inp . pubid , inp . sysid ) ; if ( is != null ) { push ( new Input ( BUFFSIZE READER ) ) ; setinp ( is ) ; m Inp . pubid = inp . pubid ; m Inp . sysid = inp . sysid ; str = null ; } else { if ( flag != STRING ) { panic ( FAULT ) ; } } } else { push ( inp ) ; str = null ; } } else { if ( flag != STRING ) { panic ( FAULT ) ; } } st = - NUM ; break ; case STRING : if ( st != NUM ) { panic ( FAULT ) ; } st = NUM ; break ; default : panic ( FAULT ) ; } break ; case NUM : switch ( chtyp ( ch ) ) { case STRING : bappend ( ch ) ; break ; case STRING : try { int i = Integer . parse Int ( new String ( m Buff , idx + NUM , m Buff Idx - idx ) , NUM ) ; if ( i >= NUM ) { panic ( FAULT ) ; } ch = ( char ) i ; } catch ( Number Format Exception nfe ) { panic ( FAULT ) ; } m Buff Idx = idx - NUM ; if ( ch == STRING || m Inp . next != null ) { bappend ( ch , flag ) ; } else { bappend ( ch ) ; } st = - NUM ; break ; case STRING : if ( ( m Buff Idx == idx ) && ( ch == STRING ) ) { st = NUM ; break ; } default : panic ( FAULT ) ; } break ; case NUM : switch ( chtyp ( ch ) ) { case STRING : case STRING : case STRING : bappend ( ch ) ; break ; case STRING : try { int i = Integer . parse Int ( new String ( m Buff , idx + NUM , m Buff Idx - idx ) , NUM ) ; if ( i >= NUM ) { panic ( FAULT ) ; } ch = ( char ) i ; } catch ( Number Format Exception nfe ) { panic ( FAULT ) ; } m Buff Idx = idx - NUM ; if ( ch == STRING || m Inp . next != null ) { bappend ( ch , flag ) ; } else { bappend ( ch ) ; } st = - NUM ; break ; default : panic ( FAULT ) ; } break ; default : panic ( FAULT ) ; } } return str ; }
@ Override public void add Match ( final String match , final T value , final boolean immutable Match ) { add Match ( match , value , immutable Match , BOOL ) ; }
Restaurant Holder visit ( long millis ) { if ( millis > NUM ) { long now = System . current Time Millis ( ) ; detail . set Text ( now - millis > MINUTE IN MILLIS ? Date Utils . get Relative Time Span String ( millis , now , NUM , FORMAT ABBREV ALL ) : m Context . get String ( R . string . recent time ) ) ; } else { detail . set Text ( R . string . never ) ; } detail . set Compound Drawables With Intrinsic Bounds ( R . drawable . ic action time small , NUM , NUM , NUM ) ; detail Is Address = BOOL ; return this ; }
public static byte [ ] decode ( String input ) throws Parse Exception { if ( input . length ( ) == NUM ) { return new byte [ NUM ] ; } byte [ ] input 58 = new byte [ input . length ( ) ] ; for ( int i = NUM ; i < input . length ( ) ; ++ i ) { char c = input . char At ( i ) ; int digit = c < NUM ? INDEXES [ c ] : - NUM ; if ( digit < NUM ) { throw new Parse Exception ( STRING + c + STRING + i , i ) ; } input 58 [ i ] = ( byte ) digit ; } int zeros = NUM ; while ( zeros < input 58 . length && input 58 [ zeros ] == NUM ) { ++ zeros ; } byte [ ] decoded = new byte [ input . length ( ) ] ; int output Start = decoded . length ; for ( int input Start = zeros ; input Start < input 58 . length ; ) { decoded [ -- output Start ] = divmod ( input 58 , input Start , NUM , NUM ) ; if ( input 58 [ input Start ] == NUM ) { ++ input Start ; } } while ( output Start < decoded . length && decoded [ output Start ] == NUM ) { ++ output Start ; } return Arrays . copy Of Range ( decoded , output Start - zeros , decoded . length ) ; }
private void queue Ready Jobs For Execution Locked H ( ) { Array Set < Job Status > jobs = m Jobs . get Jobs ( ) ; if ( DEBUG ) { } for ( int i = NUM ; i < jobs . size ( ) ; i ++ ) { Job Status job = jobs . value At ( i ) ; if ( is Ready To Be Executed Locked ( job ) ) { if ( DEBUG ) { } m Pending Jobs . add ( job ) ; } else if ( is Ready To Be Cancelled Locked ( job ) ) { stop Job On Service Context Locked ( job ) ; } } if ( DEBUG ) { final int queued Jobs = m Pending Jobs . size ( ) ; if ( queued Jobs == NUM ) { } else { } } }
public void update Width ( ) { if ( m Sum Of Weights > NUM ) { double mean = m Weighted Sum / m Sum Of Weights ; double variance = m Weighted Sum Squared / m Sum Of Weights - mean * mean ; if ( variance < NUM ) { variance = NUM ; } m Width = Math . sqrt ( variance ) * Math . pow ( m Sum Of Weights , m Exponent ) ; if ( m Width <= m Min Width ) { m Width = m Min Width ; } } else { m Width = Double . MAX VALUE ; } }
public String to String ( ) { String Builder buf = new String Builder ( ) ; for ( Node node 1 : nodes To Variables . key Set ( ) ) { buf . append ( STRING ) ; buf . append ( ( node 1 ) ) ; buf . append ( STRING ) ; Discrete Variable variable = nodes To Variables . get ( ( node 1 ) ) ; for ( int j = NUM ; j < variable . get Num Categories ( ) ; j ++ ) { buf . append ( variable . get Category ( j ) ) ; if ( j < variable . get Num Categories ( ) - NUM ) { buf . append ( STRING ) ; } } } return buf . to String ( ) ; }
public void add Default Version ( Version new Default , boolean include Implied ) { Array List < Version > new Defaults = new Array List < Version > ( default Versions ) ; if ( include Implied ) { merge Versions ( new Defaults , new Default . get Implied Versions ( ) ) ; } else { merge Versions ( new Defaults , new Default ) ; } default Versions = Collections . unmodifiable List ( new Defaults ) ; }
private Attribute Schema Impl check And Update Choice Values ( Attribute Schema Impl existing Attr , Attribute Schema Impl new Attr , List < String > new Choices ) throws Upgrade Exception { List < String > choices = new Array List < > ( Arrays . as List ( existing Attr . get Choice Values ( ) ) ) ; if ( choices . contains All ( new Choices ) ) { return null ; } else { choices . add All ( new Choices ) ; update Choice Values ( new Attr , choices ) ; } return new Attr ; }
public final boolean is Registered ( ) { return ! canonical Name . starts With ( STRING ) && ! canonical Name . starts With ( STRING ) ; }
public void unregister Client Interest ( String region Name , List keys Of Interest , boolean is Closing , Client Proxy Membership ID membership ID , boolean keepalive ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING , membership ID , region Name , keys Of Interest ) ; } Cache Client Proxy proxy = get Client Proxy ( membership ID ) ; if ( proxy != null ) { proxy . set Keep Alive ( keepalive ) ; proxy . unregister Client Interest ( region Name , keys Of Interest , is Closing ) ; } }
public static String replace All ( String str , String original Token , String replacement Token ) { return str . replace All ( Pattern . quote ( original Token ) , Matcher . quote Replacement ( replacement Token ) ) ; }
public static List < Container > create Container List ( int broker Id , int containers Number ) { Array List < Container > containers = new Array List < Container > ( ) ; for ( int i = NUM ; i < containers Number ; ++ i ) { int container Type = i / ( int ) Math . ceil ( ( double ) containers Number / NUM ) ; containers . add ( new Power Container ( I Ds . poll Id ( Container . class ) , broker Id , ( double ) Constants Examples . CONTAINER MIPS [ container Type ] , Constants Examples . CONTAINER PES [ container Type ] , Constants Examples . CONTAINER RAM [ container Type ] , Constants Examples . CONTAINER BW , NUM , STRING , new Container Cloudlet Scheduler Dynamic Workload ( Constants Examples . CONTAINER MIPS [ container Type ] , Constants Examples . CONTAINER PES [ container Type ] ) , Constants Examples . SCHEDULING INTERVAL ) ) ; } return containers ; }
public static boolean is Local Resource Uri ( @ Nullable Uri uri ) { final String scheme = get Scheme Or Null ( uri ) ; return LOCAL RESOURCE SCHEME . equals ( scheme ) ; }
protected Data Input Stream open File On Mounted Obb ( String obb Path , String file Name ) { assert True ( STRING , m Sm . is Obb Mounted ( obb Path ) ) ; String path = m Sm . get Mounted Obb Path ( obb Path ) ; assert True ( STRING , path != null ) ; File in File = new File ( path , file Name ) ; Data Input Stream in Stream = null ; try { in Stream = new Data Input Stream ( new File Input Stream ( in File ) ) ; Log . i ( LOG TAG , STRING + file Name + STRING + path ) ; } catch ( File Not Found Exception e ) { Log . e ( LOG TAG , e . to String ( ) ) ; return null ; } catch ( Security Exception e ) { Log . e ( LOG TAG , e . to String ( ) ) ; return null ; } return in Stream ; }
private void start Replication Service ( Tungsten Properties repl Props ) throws Replicator Exception { String service Name = repl Props . get String ( Replicator Conf . SERVICE NAME ) ; String service Type = repl Props . get String ( Replicator Conf . SERVICE TYPE ) ; boolean is Detached = repl Props . get Boolean ( Replicator Conf . DETACHED ) ; Open Replicator Manager M Bean orm = null ; try { if ( is Detached ) { throw new Replicator Exception ( STRING ) ; } else { orm = create Internal Service ( service Name ) ; } replicators . put ( service Name , orm ) ; orm . start ( repl Props . get Boolean ( Replicator Conf . FORCE OFFLINE ) ) ; int listen Port = orm . get Master Listen Port ( ) ; if ( listen Port > master Listen Port Max ) master Listen Port Max = listen Port ; logger . info ( String . format ( STRING , ( is Detached ? STRING : STRING ) , service Type , service Name ) ) ; } catch ( Exception e ) { logger . error ( String . format ( STRING , service Name ) , e ) ; } }
private void log Drop Detail ( int counter , String annotation ) { if ( annotation == null ) annotation = STRING ; if ( counter > NUM ) { String detail Type = m detail Types ; if ( counter == NUM ) detail Type = m detail Type ; s logger . log ( Level . FINE , STRING , new Object [ ] { Integer . to String ( counter ) , detail Type , annotation } ) ; } if ( m detail Counter Drp == null ) m detail Counter Drp = new Integer ( NUM ) ; m detail Counter Drp = new Integer ( m detail Counter Drp . int Value ( ) + counter ) ; }
public static byte [ ] SHA 1 ( final byte [ ] message , final int offset , final int length ) { Message Digest digest ; try { digest = Message Digest . get Instance ( STRING ) ; digest . update ( message , offset , length ) ; final byte [ ] sha 1 = digest . digest ( ) ; return sha 1 ; } catch ( final No Such Algorithm Exception e ) { if ( Cfg . EXCEPTION ) { Check . log ( e ) ; } } return null ; }
private void run Analysis ( Path node Db , Path inverted , Path output , int iteration , int num Iterations , float rank One ) throws IO Exception { Job Conf analyzer = new Nutch Job ( get Conf ( ) ) ; analyzer . set ( STRING , String . value Of ( iteration + NUM ) ) ; analyzer . set Job Name ( STRING + ( iteration + NUM ) + STRING + num Iterations ) ; File Input Format . add Input Path ( analyzer , node Db ) ; File Input Format . add Input Path ( analyzer , inverted ) ; File Output Format . set Output Path ( analyzer , output ) ; analyzer . set ( STRING , String . value Of ( rank One ) ) ; analyzer . set Map Output Key Class ( Text . class ) ; analyzer . set Map Output Value Class ( Object Writable . class ) ; analyzer . set Input Format ( Sequence File Input Format . class ) ; analyzer . set Mapper Class ( Analyzer . class ) ; analyzer . set Reducer Class ( Analyzer . class ) ; analyzer . set Output Key Class ( Text . class ) ; analyzer . set Output Value Class ( Node . class ) ; analyzer . set Output Format ( Map File Output Format . class ) ; analyzer . set Boolean ( STRING , BOOL ) ; LOG . info ( STRING ) ; try { Job Client . run Job ( analyzer ) ; } catch ( IO Exception e ) { LOG . error ( String Utils . stringify Exception ( e ) ) ; throw e ; } LOG . info ( STRING ) ; }
public Set create Sub Group Containers ( Set group Container Names ) throws AM Exception , SSO Exception { Iterator iter = group Container Names . iterator ( ) ; Set group Containers = new Hash Set ( ) ; while ( iter . has Next ( ) ) { String group Container DN = AM Naming Attr Manager . get Naming Attr ( GROUP CONTAINER ) + STRING + ( ( String ) iter . next ( ) ) + STRING + entry DN ; AM Group Container Impl group Container Impl = new AM Group Container Impl ( token , group Container DN ) ; group Container Impl . create ( ) ; group Containers . add ( group Container Impl ) ; } return group Containers ; }
private void test Count Messages In Mailbox ( ) throws Exception { LOG . info ( STRING ) ; long message Count = message Mapper . count Messages In Mailbox ( MBOXES . get ( NUM ) ) ; assert Equals ( MESSAGE NO . size ( ) , message Count ) ; }
private String pop And Encode As Js ( ) { synchronized ( this ) { int length = queue . size ( ) ; if ( length == NUM ) { return null ; } int total Payload Len = NUM ; int num Messages To Send = NUM ; for ( Js Message message : queue ) { int message Size = message . calculate Encoded Length ( ) + NUM ; if ( num Messages To Send > NUM && total Payload Len + message Size > MAX PAYLOAD SIZE && MAX PAYLOAD SIZE > NUM ) { break ; } total Payload Len += message Size ; num Messages To Send += NUM ; } boolean will Send All Messages = num Messages To Send == queue . size ( ) ; String Builder sb = new String Builder ( total Payload Len + ( will Send All Messages ? NUM : NUM ) ) ; for ( int i = NUM ; i < num Messages To Send ; ++ i ) { Js Message message = queue . remove First ( ) ; if ( will Send All Messages && ( i + NUM == num Messages To Send ) ) { message . encode As Js Message ( sb ) ; } else { sb . append ( STRING ) ; message . encode As Js Message ( sb ) ; sb . append ( STRING ) ; } } if ( ! will Send All Messages ) { sb . append ( STRING ) ; } for ( int i = will Send All Messages ? NUM : NUM ; i < num Messages To Send ; ++ i ) { sb . append ( STRING ) ; } String ret = sb . to String ( ) ; return ret ; } }
public static < V > Map < String , V > remove Multi Form Parameters ( Map < String , V > parameters ) { Map < String , V > filtered Parameters = new Hash Map < String , V > ( ) ; for ( Map . Entry < String , V > entry : parameters . entry Set ( ) ) { String key = entry . get Key ( ) ; if ( key != null && ( key . index Of ( MULTI ROW DELIMITER ) != - NUM || key . index Of ( STRING ) != - NUM || key . index Of ( STRING ) != - NUM ) ) { continue ; } filtered Parameters . put ( key , entry . get Value ( ) ) ; } return filtered Parameters ; }
public String query ( String handler , Solr Query Request req ) throws Exception { try { Solr Core core = req . get Core ( ) ; Solr Query Response rsp = new Solr Query Response ( ) ; Solr Request Info . set Request Info ( new Solr Request Info ( req , rsp ) ) ; core . execute ( core . get Request Handler ( handler ) , req , rsp ) ; if ( rsp . get Exception ( ) != null ) { throw rsp . get Exception ( ) ; } String Writer sw = new String Writer ( NUM ) ; Query Response Writer response Writer = core . get Query Response Writer ( req ) ; response Writer . write ( sw , req , rsp ) ; return sw . to String ( ) ; } finally { req . close ( ) ; Solr Request Info . clear Request Info ( ) ; } }
public static void add Link ( Pagination Link link , int page Number , Uri Builder uri Builder , Map < String , URI > body Links ) { Uri Builder page Link = uri Builder . replace Query Param ( STRING , page Number ) ; body Links . put ( link . get Body Name ( ) , page Link . build ( ) ) ; }
public static String join Punctuation Marks ( String line ) { String result = line ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; result = result . replace ( STRING , STRING ) ; return result ; }
public static Copy Object Result parse Copy Object Result ( Input Stream response Body ) throws Response Parse Exception { try { Element root = get Xml Root Element ( response Body ) ; Copy Object Result result = new Copy Object Result ( ) ; result . set Last Modified ( Date Util . parse Iso 8601 Date ( root . get Child Text ( STRING ) ) ) ; result . set Etag ( trim Quotes ( root . get Child Text ( STRING ) ) ) ; return result ; } catch ( Exception e ) { throw new Response Parse Exception ( e . get Message ( ) , e ) ; } }
public static String format Spelled Out Amount ( Double amount , Locale locale ) { return format Spelled Out Amount ( amount . double Value ( ) , locale ) ; }
private void delete Instance ( Entry Class eclass ) { int idx = entry Classes . index Of ( eclass ) ; if ( idx < NUM ) { return ; } eclass = entry Classes . get ( idx ) ; int num = eclass . get Num Instances ( ) - NUM ; if ( num == NUM ) entry Classes . remove ( idx ) ; eclass . set Num Instances ( num ) ; }
public Warning create ( int limit , String message , boolean log All ) { final Warning warning = new Warning ( limit , message , log All ) ; m Warnings . add ( warning ) ; return warning ; }
public static Byte Array List read As Bytes ( Input Stream is ) throws IO Exception { Byte Array List buf = new Byte Array List ( ) ; byte [ ] b = new byte [ NUM ] ; int nread = - NUM ; while ( ( nread = is . read ( b ) ) >= NUM ) { buf . add ( b , NUM , nread ) ; } return buf ; }
public Array Real Vector ( int size , double preset ) { data = new double [ size ] ; Arrays . fill ( data , preset ) ; }
public static synchronized void register Transaction Service Plugin ( Transaction Service Plugin l ) { if ( service != null ) { service . add TS Listener ( l ) ; } ts Listeners List . add ( l ) ; }
private void priority Layout 2 ( int level [ ] , int priorities [ ] , int b Centers [ ] , int hor Positions [ ] ) { int desc Order [ ] = new int [ priorities . length ] ; desc Order [ NUM ] = NUM ; for ( int i = NUM ; i < priorities . length - NUM ; i ++ ) { int j = i ; int temp = i + NUM ; while ( j > - NUM && priorities [ desc Order [ j ] ] < priorities [ temp ] ) { desc Order [ j + NUM ] = desc Order [ j ] ; j -- ; } j ++ ; desc Order [ j ] = temp ; } for ( int k = NUM ; k < desc Order . length ; k ++ ) { for ( int i = NUM ; i < desc Order . length ; i ++ ) { int left Count = NUM , right Count = NUM , left Nodes [ ] , right Nodes [ ] ; for ( int j = NUM ; j < priorities . length ; j ++ ) { if ( hor Positions [ level [ desc Order [ i ] ] ] > hor Positions [ level [ j ] ] ) { left Count ++ ; } else if ( hor Positions [ level [ desc Order [ i ] ] ] < hor Positions [ level [ j ] ] ) { right Count ++ ; } } left Nodes = new int [ left Count ] ; right Nodes = new int [ right Count ] ; for ( int j = NUM , l = NUM , r = NUM ; j < priorities . length ; j ++ ) { if ( hor Positions [ level [ desc Order [ i ] ] ] > hor Positions [ level [ j ] ] ) { left Nodes [ l ++ ] = j ; } else if ( hor Positions [ level [ desc Order [ i ] ] ] < hor Positions [ level [ j ] ] ) { right Nodes [ r ++ ] = j ; } } while ( Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] - NUM - b Centers [ desc Order [ i ] ] ) < Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] - b Centers [ desc Order [ i ] ] ) ) { int temp = hor Positions [ level [ desc Order [ i ] ] ] ; boolean cant Move = BOOL ; for ( int j = left Nodes . length - NUM ; j >= NUM ; j -- ) { if ( temp - hor Positions [ level [ left Nodes [ j ] ] ] > NUM ) { break ; } else if ( priorities [ desc Order [ i ] ] <= priorities [ left Nodes [ j ] ] ) { cant Move = BOOL ; break ; } else { temp = hor Positions [ level [ left Nodes [ j ] ] ] ; } } if ( cant Move ) { break ; } temp = hor Positions [ level [ desc Order [ i ] ] ] - NUM ; for ( int j = left Nodes . length - NUM ; j >= NUM ; j -- ) { if ( temp == hor Positions [ level [ left Nodes [ j ] ] ] ) { hor Positions [ level [ left Nodes [ j ] ] ] = temp = hor Positions [ level [ left Nodes [ j ] ] ] - NUM ; } } hor Positions [ level [ desc Order [ i ] ] ] = hor Positions [ level [ desc Order [ i ] ] ] - NUM ; } while ( Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] + NUM - b Centers [ desc Order [ i ] ] ) < Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] - b Centers [ desc Order [ i ] ] ) ) { int temp = hor Positions [ level [ desc Order [ i ] ] ] ; boolean cant Move = BOOL ; for ( int right Node : right Nodes ) { if ( hor Positions [ level [ right Node ] ] - temp > NUM ) { break ; } else if ( priorities [ desc Order [ i ] ] <= priorities [ right Node ] ) { cant Move = BOOL ; break ; } else { temp = hor Positions [ level [ right Node ] ] ; } } if ( cant Move ) { break ; } temp = hor Positions [ level [ desc Order [ i ] ] ] + NUM ; for ( int j = NUM ; j < right Nodes . length ; j ++ ) { if ( temp == hor Positions [ level [ right Nodes [ j ] ] ] ) { hor Positions [ level [ right Nodes [ j ] ] ] = temp = hor Positions [ level [ right Nodes [ j ] ] ] + NUM ; } } hor Positions [ level [ desc Order [ i ] ] ] = hor Positions [ level [ desc Order [ i ] ] ] + NUM ; } } } }
private void reassess Model ( ) { if ( this . model Param Types == null ) { return ; } for ( Class clazz : this . model Param Types ) { if ( clazz == null ) { return ; } } List < Class < ? extends Object > > list 1 = new Array List < > ( ) ; for ( Session Node node : this . parents ) { Object model = node . get Model ( ) ; if ( model != null ) { list 1 . add ( model . get Class ( ) ) ; } } List < Class > list 2 = Arrays . as List ( this . model Param Types ) ; if ( ! list 1 . contains ( list 2 ) || ! list 2 . contains ( list 1 ) ) { destroy Model ( ) ; } }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof Map Bean ) { set Map ( ( Map Bean ) some Obj ) ; } }
public void remove Layer ( Layer layer ) { int length = layers . size ( ) ; int no ; for ( no = NUM ; no < length ; no ++ ) { if ( ( ( Layer With Zoom Levels ) layers . element At ( no ) ) . layer == layer ) { break ; } } layers . remove Element At ( no ) ; refresh Layers = BOOL ; super . repaint ( ) ; }
private void read Object ( Object Input Stream ois ) throws Class Not Found Exception , IO Exception { ois . default Read Object ( ) ; stroke = read Stroke ( ois , OM Graphic Adapter . BASIC STROKE ) ; texture Mask = read Texture Mask ( ois ) ; }
public int compare ( Object o1 , Object o2 ) { if ( o1 == null ) throw new Illegal Argument Exception ( STRING ) ; if ( o2 == null ) throw new Illegal Argument Exception ( STRING ) ; M Rf Q Response Line Qty q1 = null ; M Rf Q Response Line Qty q2 = null ; if ( o1 instanceof M Rf Q Response Line Qty ) q1 = ( M Rf Q Response Line Qty ) o1 ; else throw new Class Cast Exception ( STRING ) ; if ( o2 instanceof M Rf Q Response Line Qty ) q2 = ( M Rf Q Response Line Qty ) o2 ; else throw new Class Cast Exception ( STRING ) ; if ( ! q1 . is Valid Amt ( ) ) return - NUM ; if ( ! q2 . is Valid Amt ( ) ) return + NUM ; Big Decimal net 1 = q1 . get Net Amt ( ) ; if ( net 1 == null ) return - NUM ; Big Decimal net 2 = q2 . get Net Amt ( ) ; if ( net 2 == null ) return + NUM ; return net 1 . compare To ( net 2 ) ; }
private void bind Entity Id ( Class < ? > cls , String type , Accessible Object field Or Method ) { String field Name = get Field Name ( field Or Method ) ; Class < ? > field Type = get Field Type ( field Or Method ) ; fields To Types . put ( field Name , field Type ) ; id Field = field Or Method ; id Type = field Type ; id Field Name = field Name ; fields To Values . put ( field Name , field Or Method ) ; if ( id Field != null && ! field Or Method . equals ( id Field ) ) { throw new Duplicate Mapping Exception ( type + STRING + cls . get Name ( ) + STRING + field Name ) ; } }
public static boolean addresses Are Equal ( String host 1 , String host 2 ) { try { Host Address host 1 Address = get By Name ( host 1 ) ; Host Address host 2 Address = get By Name ( host 2 ) ; byte [ ] host 1 Raw = host 1 Address . get Address ( ) ; byte [ ] host 2 Raw = host 2 Address . get Address ( ) ; for ( int octet = NUM ; octet < NUM ; octet ++ ) { if ( host 1 Raw [ octet ] != host 2 Raw [ octet ] ) return BOOL ; } return BOOL ; } catch ( Exception e ) { CL Utils . println ( String . format ( STRING , host 1 , host 2 , e ) ) ; return BOOL ; } }
public void remove Membership Listener ( Membership Listener listener ) { membership Listeners . remove ( listener ) ; }
public static Uri add Message To Uri ( Content Resolver resolver , Uri uri , String address , String body , String subject , Long date , boolean read , boolean delivery Report ) { return add Message To Uri ( resolver , uri , address , body , subject , date , read , delivery Report , - NUM ) ; }
private void present ( ) { gl Use Program ( quad Program ) ; gl Bind Vertex Array ( vao ) ; gl Bind Texture ( GL TEXTURE 2D , tex ) ; gl Bind Sampler ( NUM , this . sampler ) ; gl Draw Arrays ( GL TRIANGLES , NUM , NUM ) ; gl Bind Sampler ( NUM , NUM ) ; gl Bind Texture ( GL TEXTURE 2D , NUM ) ; gl Bind Vertex Array ( NUM ) ; gl Use Program ( NUM ) ; }
public static Calendar previous ( Calendar self ) { Calendar result = ( Calendar ) self . clone ( ) ; result . add ( Calendar . DAY OF YEAR , - NUM ) ; return result ; }
public static Map < String , Object > create Order Note ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . get Delegator ( ) ; Local Dispatcher dispatcher = dctx . get Dispatcher ( ) ; Generic Value user Login = ( Generic Value ) context . get ( STRING ) ; String note String = ( String ) context . get ( STRING ) ; String note Name = ( String ) context . get ( STRING ) ; String order Id = ( String ) context . get ( STRING ) ; String internal Note = ( String ) context . get ( STRING ) ; Map < String , Object > note Ctx = Util Misc . < String , Object > to Map ( STRING , note String , STRING , user Login , STRING , note Name ) ; Locale locale = ( Locale ) context . get ( STRING ) ; try { Map < String , Object > note Res = dispatcher . run Sync ( STRING , note Ctx ) ; if ( Service Util . is Error ( note Res ) ) return note Res ; String note Id = ( String ) note Res . get ( STRING ) ; if ( Util Validate . is Empty ( note Id ) ) { return Service Util . return Error ( Util Properties . get Message ( resource error , STRING , locale ) ) ; } Map < String , String > fields = Util Misc . < String , String > to Map ( STRING , order Id , STRING , note Id , STRING , internal Note ) ; Generic Value v = delegator . make Value ( STRING , fields ) ; delegator . create ( v ) ; } catch ( Generic Entity Exception ee ) { Debug . log Error ( ee , module ) ; return Service Util . return Error ( Util Properties . get Message ( resource , STRING , Util Misc . to Map ( STRING , ee . get Message ( ) ) , locale ) ) ; } catch ( Generic Service Exception se ) { Debug . log Error ( se , module ) ; return Service Util . return Error ( Util Properties . get Message ( resource , STRING , Util Misc . to Map ( STRING , se . get Message ( ) ) , locale ) ) ; } return Service Util . return Success ( ) ; }
public void compress My Own Way ( int [ ] indexes ) { List < Integer > list = new Array List < Integer > ( Carbon Common Constants . CONSTANT SIZE TEN ) ; List < Integer > map = new Array List < Integer > ( Carbon Common Constants . CONSTANT SIZE TEN ) ; int k = NUM ; int i = NUM ; for ( ; i < indexes . length ; i ++ ) { if ( indexes [ i ] - indexes [ i - NUM ] == NUM ) { k ++ ; } else { if ( k > NUM ) { map . add ( ( list . size ( ) ) ) ; list . add ( indexes [ i - k - NUM ] ) ; list . add ( indexes [ i - NUM ] ) ; } else { list . add ( indexes [ i - NUM ] ) ; } k = NUM ; } } if ( k > NUM ) { map . add ( ( list . size ( ) ) ) ; list . add ( indexes [ i - k - NUM ] ) ; list . add ( indexes [ i - NUM ] ) ; } else { list . add ( indexes [ i - NUM ] ) ; } data After Comp = convert To Array ( list ) ; if ( indexes . length == data After Comp . length ) { index Map = new int [ NUM ] ; } else { index Map = convert To Array ( map ) ; } if ( data After Comp . length == NUM && index Map . length == NUM ) { already Sorted = BOOL ; } }
public C Function Selection Tree ( final I Database database , final I Action Provider action Provider ) { Preconditions . check Not Null ( database , STRING ) ; Preconditions . check Not Null ( action Provider , STRING ) ; final Default Tree Model model = new Default Tree Model ( null ) ; set Model ( model ) ; set Root Visible ( BOOL ) ; model . set Root ( new C Root Node ( database , model , action Provider ) ) ; set Cell Renderer ( new Icon Node Renderer ( ) ) ; add Mouse Listener ( new Internal Mouse Listener ( ) ) ; }
public static boolean is Proxy Type ( Class < ? > type ) { String name = type . get Name ( ) ; if ( name . starts With ( STRING ) || name . starts With ( STRING ) ) { return BOOL ; } return BOOL ; }
public void clear Mods Already Requested ( String channel ) { if ( channel == null ) { mods Already Requested . clear ( ) ; } else { mods Already Requested . remove ( channel ) ; } }
public Big Decimal invoke ( M Depreciation Workfile assetwk , M Asset Acct asset Acct , int A Current Period , Big Decimal Accum Dep ) { String depreciation Type = get Depreciation Type ( ) ; Big Decimal ret Value = null ; if ( C Log Mgt . is Level Finest ( ) ) { log . fine ( STRING + depreciation Type + STRING + assetwk + STRING + asset Acct + STRING + A Current Period + STRING + Accum Dep ) ; } if ( ! can Invoke ( assetwk , asset Acct , A Current Period , Accum Dep ) ) { return Big Decimal . ZERO ; } if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply SL ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH VAR ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH AD 1 ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH AD 2 ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else if ( depreciation Type . equals Ignore Case ( STRING ) ) { ret Value = apply ARH ZERO ( assetwk , asset Acct , A Current Period , Accum Dep ) ; } else { throw new Asset Not Supported Exception ( COLUMNNAME Depreciation Type , depreciation Type ) ; } if ( ret Value == null ) { ret Value = Big Decimal . ZERO ; } ret Value = ret Value . set Scale ( get Precision ( ) , Rounding Mode . HALF UP ) ; if ( C Log Mgt . is Level Finest ( ) ) log . fine ( STRING + ret Value ) ; return ret Value ; }
@ Override public boolean contains ( Object value ) { if ( value == null ) { return BOOL ; } final Iterator it = new Step Iterator ( this , step Size ) ; while ( it . has Next ( ) ) { if ( compare Equal ( value , it . next ( ) ) ) { return BOOL ; } } return BOOL ; }
public synchronized void delete File ( JDBC Sequential File file ) throws SQL Exception { try { connection . set Auto Commit ( BOOL ) ; delete File . set Int ( NUM , file . get Id ( ) ) ; delete File . execute Update ( ) ; connection . commit ( ) ; } catch ( SQL Exception e ) { connection . rollback ( ) ; throw e ; } }
byte [ ] unzip ( final byte [ ] data ) throws IO Exception { final Input Stream input = new Byte Array Input Stream ( data ) ; final byte [ ] buffer = new byte [ NUM ] ; final Zip Input Stream zip = new Zip Input Stream ( input ) ; final Byte Array Output Stream out = new Byte Array Output Stream ( data . length ) ; int count = NUM ; if ( zip . get Next Entry ( ) != null ) { while ( ( count = zip . read ( buffer ) ) != - NUM ) { out . write ( buffer , NUM , count ) ; } } out . flush ( ) ; zip . close ( ) ; out . close ( ) ; return out . to Byte Array ( ) ; }
private static void Display Help And Exit ( EXIT CODE exit Code ) { Help Formatter formatter = new Help Formatter ( ) ; formatter . set Width ( NUM ) ; formatter . print Help ( STRING , keystore Manager . options ) ; Exit ( exit Code ) ; }
public void add ( final Sensor sensor ) { Set < Sensor > old Selection = new Hash Set < Sensor > ( selection ) ; boolean rv = selection . add ( sensor ) ; if ( rv ) { fire Selection Changed ( old Selection , selection ) ; } }
@ Override public void visit Map Way ( Map Way way ) { Default Entity View Info p Info = ( Default Entity View Info ) way . get View Info ( ) ; List < Map Node > nodes = get Way Nodes ( way ) ; if ( ! nodes . is Empty ( ) && p Info . way Color != null ) { if ( p Info . way Fill Color != null && nodes . get ( NUM ) == nodes . get ( nodes . size ( ) - NUM ) && ( way . is Area ( ) || ! p Info . fill Areas Only ) ) area Buffer . add ( way ) ; else way Buffer . add ( way ) ; } if ( p Info . is Way Icon && p Info . icon != null ) node Buffer . add ( way ) ; }
private Environment Logger build Parent Tree ( String child Name ) { if ( child Name == null || child Name . equals ( STRING ) ) return null ; int p = child Name . last Index Of ( STRING ) ; String parent Name ; if ( p > NUM ) parent Name = child Name . substring ( NUM , p ) ; else parent Name = STRING ; Environment Logger parent = null ; Soft Reference < Environment Logger > parent Ref = env Loggers . get ( parent Name ) ; if ( parent Ref != null ) parent = parent Ref . get ( ) ; if ( parent != null ) return parent ; else { parent = new Environment Logger ( parent Name , null ) ; env Loggers . put ( parent Name , new Soft Reference < Environment Logger > ( parent ) ) ; Environment Logger grandparent = build Parent Tree ( parent Name ) ; if ( grandparent != null ) parent . set Parent ( grandparent ) ; return parent ; } }
protected void pick Contained Vertices ( Visualization Viewer < V , E > vv , Point 2 D down , Point 2 D out , boolean clear ) { Layout < V , E > layout = vv . get Graph Layout ( ) ; Picked State < V > picked Vertex State = vv . get Picked Vertex State ( ) ; Rectangle 2 D pick Rectangle = new Rectangle 2 D . Double ( ) ; pick Rectangle . set Frame From Diagonal ( down , out ) ; if ( picked Vertex State != null ) { if ( clear ) { picked Vertex State . clear ( ) ; } Graph Element Accessor < V , E > pick Support = vv . get Pick Support ( ) ; Collection < V > picked = pick Support . get Vertices ( layout , pick Rectangle ) ; for ( V v : picked ) { picked Vertex State . pick ( v , BOOL ) ; } } }
public int hash Code ( ) { throw new Unsupported Operation Exception ( STRING ) ; }
@ Suppress Warnings ( STRING ) public Create Index Request source ( Map < String , ? > source ) { boolean found = BOOL ; for ( Map . Entry < String , ? > entry : source . entry Set ( ) ) { String name = entry . get Key ( ) ; if ( name . equals ( STRING ) ) { found = BOOL ; settings ( ( Map < String , Object > ) entry . get Value ( ) ) ; } else if ( name . equals ( STRING ) ) { found = BOOL ; Map < String , Object > mappings = ( Map < String , Object > ) entry . get Value ( ) ; for ( Map . Entry < String , Object > entry 1 : mappings . entry Set ( ) ) { mapping ( entry 1 . get Key ( ) , ( Map < String , Object > ) entry 1 . get Value ( ) ) ; } } else if ( name . equals ( STRING ) ) { found = BOOL ; aliases ( ( Map < String , Object > ) entry . get Value ( ) ) ; } else { Index Meta Data . Custom proto = Index Meta Data . lookup Prototype ( name ) ; if ( proto != null ) { found = BOOL ; try { customs . put ( name , proto . from Map ( ( Map < String , Object > ) entry . get Value ( ) ) ) ; } catch ( IO Exception e ) { throw new Elasticsearch Parse Exception ( STRING , name ) ; } } } } if ( ! found ) { settings ( source ) ; } return this ; }
public static String validate Credit Card Number ( String credit Card Number ) { if ( credit Card Number == null || credit Card Number . length ( ) == NUM ) return STRING ; String cc Number 1 = check Numeric ( credit Card Number ) ; int cc Length = cc Number 1 . length ( ) ; String Buffer buf = new String Buffer ( ) ; for ( int i = cc Length ; i != NUM ; i -- ) buf . append ( cc Number 1 . char At ( i - NUM ) ) ; String cc Number = buf . to String ( ) ; int sum = NUM ; for ( int i = NUM ; i < cc Length ; i ++ ) { int digit = Character . get Numeric Value ( cc Number . char At ( i ) ) ; if ( i % NUM == NUM ) { digit *= NUM ; if ( digit > NUM ) digit -= NUM ; } sum += digit ; } if ( sum % NUM == NUM ) return STRING ; s log . fine ( STRING + credit Card Number + STRING + cc Number + STRING + sum ) ; return STRING ; }
public static void unpack ( File source Zip , final File target Dir ) throws IO Exception { Zip File zip File = null ; try { zip File = new Zip File ( source Zip ) ; Enumeration < ? extends Zip Entry > entries Enum = zip File . entries ( ) ; while ( entries Enum . has More Elements ( ) ) { unpack Entry ( zip File , entries Enum . next Element ( ) , target Dir ) ; } } finally { try { if ( zip File != null ) { zip File . close ( ) ; } } catch ( IO Exception e ) { } } }
static public Input Stream find JMS Config ( String custom Config File Name ) throws Exception { URL config URL = null ; String file Path = Constants . Jms . JMS CONFIG DIRECTORY ; boolean is Full URL Path = BOOL ; try { config URL = new URL ( custom Config File Name ) ; } catch ( Malformed URL Exception e ) { } if ( config URL != null ) { if ( ! J Space Utilities . is Empty ( config URL . get Protocol ( ) ) ) { file Path = config URL . get File ( ) ; is Full URL Path = BOOL ; } } if ( ! is Full URL Path ) { if ( custom Config File Name != null ) { file Path = Constants . Jms . JMS CONFIG DIRECTORY + custom Config File Name ; } else { file Path = Constants . Jms . JMS CONFIG DIRECTORY + Constants . Jms . JMS CONFIG FILE NAME ; } } Input Stream input Stream = get Resource Stream ( file Path ) ; if ( input Stream == null ) { String missing JMS Config File Msg = STRING + file Path + STRING ; throw new Exception ( missing JMS Config File Msg ) ; } else { if ( logger . is Loggable ( Level . INFO ) ) { logger . info ( STRING + get Resource URL ( file Path ) + STRING ) ; } } return input Stream ; }
public static void device Report Pressed ( String dev Name , Frame parent ) { J Text Area text = null ; J Scroll Pane scroll Pane = null ; text = new javax . swing . J Text Area ( NUM , NUM ) ; text . set Editable ( BOOL ) ; text . set Tab Size ( NUM ) ; search ( dev Name , text ) ; scroll Pane = new J Scroll Pane ( text ) ; make Dialog ( scroll Pane , null , parent , rbm . get String ( STRING ) ) ; }
private void send Request Teardown ( ) throws IO Exception { String request = STRING + m Parameters . host + STRING + m Parameters . port + m Parameters . path + STRING + add Headers ( ) ; Log . i ( TAG , request . substring ( NUM , request . index Of ( STRING ) ) ) ; m Output Stream . write ( request . get Bytes ( STRING ) ) ; }
public static Geo Time Serie fillticks ( Geo Time Serie gts , long location , long elevation , Object value , long [ ] ticks ) { Geo Time Serie filled = gts . clone ( ) ; if ( null == value || GTS Helper . is Bucketized ( filled ) ) { return filled ; } long [ ] gticks = filled . values > NUM ? Arrays . copy Of ( filled . ticks , filled . values ) : new long [ NUM ] ; Arrays . sort ( gticks ) ; Arrays . sort ( ticks ) ; int gtsidx = NUM ; int tickidx = NUM ; int nvalues = filled . values ; while ( gtsidx < nvalues ) { long tick = gticks [ gtsidx ] ; while ( tickidx < ticks . length && ticks [ tickidx ] < tick ) { GTS Helper . set Value ( filled , ticks [ tickidx ] , location , elevation , value , BOOL ) ; tickidx ++ ; } gtsidx ++ ; } while ( tickidx < ticks . length ) { GTS Helper . set Value ( filled , ticks [ tickidx ] , location , elevation , value , BOOL ) ; tickidx ++ ; } return filled ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) return BOOL ; if ( o == this ) return BOOL ; if ( ! ( o instanceof Attribute ) ) return BOOL ; final Attribute attribute = ( Attribute ) o ; if ( name != null ? ! name . equals ( attribute . name ) : attribute . name != null ) return BOOL ; if ( compare Value ) if ( value != null ? ! value . equals ( attribute . value ) : attribute . value != null ) return BOOL ; return BOOL ; }
public boolean wait For Wifi State ( int expected State , long timeout ) { long start Time = System . current Time Millis ( ) ; while ( BOOL ) { if ( ( System . current Time Millis ( ) - start Time ) > timeout ) { if ( m Wifi State != expected State ) { return BOOL ; } else { return BOOL ; } } Log . v ( LOG TAG , STRING + expected State ) ; synchronized ( m Wifi Monitor ) { try { m Wifi Monitor . wait ( SHORT TIMEOUT ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } if ( m Wifi State != expected State ) { Log . v ( LOG TAG , STRING + m Wifi State ) ; continue ; } return BOOL ; } } }
@ Nullable private static Boolean find Path ( Instruction cur , int destination , Linked Hash Set < Integer > fragment Insns , boolean was Outside , Hash Map < Instruction , Boolean > visited ) { was Outside = was Outside || ! fragment Insns . contains ( cur . num ( ) ) ; visited . put ( cur , null ) ; Iterable < ? extends Instruction > instructions = cur . all Successors ( ) ; boolean path Exists = BOOL ; for ( Instruction i : instructions ) { if ( i . num ( ) == destination ) return was Outside ; Boolean result ; if ( visited . contains Key ( i ) ) { result = visited . get ( i ) ; } else { result = find Path ( i , destination , fragment Insns , was Outside , visited ) ; visited . put ( i , result ) ; } if ( result != null ) { if ( result . boolean Value ( ) ) { visited . put ( cur , BOOL ) ; return BOOL ; } path Exists = BOOL ; } } if ( path Exists ) { visited . put ( cur , BOOL ) ; return BOOL ; } else { visited . put ( cur , null ) ; return null ; } }
public void add Diagram Change Listener ( mx Diagram Change Listener listener ) { if ( diagram Change Listeners == null ) { diagram Change Listeners = new Array List < mx Diagram Change Listener > ( ) ; } diagram Change Listeners . add ( listener ) ; }
private Button create Push Button ( Composite parent , String key , String key Override ) { Button button = new Button ( parent , SWT . PUSH ) ; button . set Text ( key != null ? J Face Resources . get String ( key ) : key Override ) ; button . set Font ( parent . get Font ( ) ) ; Grid Data data = new Grid Data ( Grid Data . FILL HORIZONTAL ) ; int width Hint = convert Horizontal DL Us To Pixels ( button , I Dialog Constants . BUTTON WIDTH ) ; data . width Hint = Math . max ( width Hint , button . compute Size ( SWT . DEFAULT , SWT . DEFAULT , BOOL ) . x ) ; button . set Layout Data ( data ) ; button . add Selection Listener ( get Selection Listener ( ) ) ; return button ; }
public static boolean is UU Id ( Object obj ) { String str = Caster . to String ( obj , null ) ; if ( str == null ) return BOOL ; if ( str . length ( ) == NUM ) { return Decision . is Hex ( str . substring ( NUM , NUM ) ) && str . char At ( NUM ) == STRING && Decision . is Hex ( str . substring ( NUM , NUM ) ) && str . char At ( NUM ) == STRING && Decision . is Hex ( str . substring ( NUM , NUM ) ) && str . char At ( NUM ) == STRING && Decision . is Hex ( str . substring ( NUM ) ) ; } else if ( str . length ( ) == NUM ) return Decision . is Hex ( str ) ; return BOOL ; }
public static double F1 ( int s1 [ ] , int s2 [ ] ) { double p = P Precision ( s1 , s2 ) ; double r = P Recall ( s1 , s2 ) ; if ( Double . is Na N ( r ) || Double . is Na N ( p ) ) { return Double . Na N ; } if ( p == NUM && r == NUM ) return NUM ; return NUM * p * r / ( p + r ) ; }
void start Scrolling Instance ( ) { if ( log . is Loggable ( Platform Logger . Level . FINER ) ) { log . finer ( STRING + this ) ; } scroll ( ) ; i scroller . set Scrollbar ( this ) ; i scroller . start ( ) ; }
public void start ( Stage stage ) throws Exception { stage . set Scene ( new Scene ( new My Demo Pane ( ) ) ) ; stage . set Title ( STRING ) ; stage . set Width ( NUM ) ; stage . set Height ( NUM ) ; stage . show ( ) ; }
public void accept Data Point ( double [ ] data Point ) { if ( m output Frame != null && ( m x Count % m refresh Frequency == NUM ) ) { double [ ] dp = new double [ data Point . length + NUM ] ; dp [ dp . length - NUM ] = m x Count ; System . arraycopy ( data Point , NUM , dp , NUM , data Point . length ) ; for ( double element : data Point ) { if ( element < m min ) { m old Min = m min ; m min = element ; m y Scale Update = BOOL ; } if ( element > m max ) { m old Max = m max ; m max = element ; m y Scale Update = BOOL ; } } if ( m y Scale Update ) { m scale Panel . repaint ( ) ; m y Scale Update = BOOL ; } synchronized ( m data List ) { m data List . add ( m data List . size ( ) , dp ) ; m data List . notify All ( ) ; } } }
List < Named Range > remove Surrogates ( int start Code Point , int end Code Point ) { assert start Code Point <= end Code Point ; if ( start Code Point >= NUM && end Code Point <= NUM ) { return Collections . empty List ( ) ; } List < Named Range > ranges = new Array List < Named Range > ( ) ; if ( end Code Point < NUM || start Code Point > NUM ) { ranges . add ( new Named Range ( start Code Point , end Code Point ) ) ; return ranges ; } if ( start Code Point < NUM ) { ranges . add ( new Named Range ( start Code Point , NUM ) ) ; } if ( end Code Point > NUM ) { ranges . add ( new Named Range ( NUM , end Code Point ) ) ; } return ranges ; }
public static boolean is Os 2 ( ) { return os Name . index Of ( STRING ) > - NUM ; }
public D View Asn 1 Dump ( J Dialog parent , X509 Ext extension ) throws Asn 1 Exception , IO Exception { super ( res . get String ( STRING ) ) ; this . extension = extension ; init Components ( ) ; }
public static String remove Spaces ( final String value ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; return value . replace All ( STRING , STRING ) ; }
public synchronized void add Object ( Object obj ) { fifo . add Element ( obj ) ; nb Objects ++ ; notify All ( ) ; }
public void close Popout ( Channel channel ) { if ( channel == null ) { return ; } if ( ! dialogs . contains Key ( channel ) ) { return ; } J Dialog dialog = dialogs . remove ( channel ) ; dialog . dispose ( ) ; popout Disposed ( channel ) ; }
public double distance signed ( Pla Point Float p point ) { double dx = point b . v x - point a . v x ; double dy = point b . v y - point a . v y ; double det = dy * ( p point . v x - point a . v x ) - dx * ( p point . v y - point a . v y ) ; double length = Math . sqrt ( dx * dx + dy * dy ) ; return det / length ; }
public static void expand Real ( String number String , Word Relation word Relation ) { int string Length = number String . length ( ) ; int position ; if ( number String . char At ( NUM ) == STRING ) { word Relation . add Word ( STRING ) ; expand Real ( number String . substring ( NUM , string Length ) , word Relation ) ; } else if ( number String . char At ( NUM ) == STRING ) { word Relation . add Word ( STRING ) ; expand Real ( number String . substring ( NUM , string Length ) , word Relation ) ; } else if ( ( position = number String . index Of ( STRING ) ) != - NUM || ( position = number String . index Of ( STRING ) ) != - NUM ) { expand Real ( number String . substring ( NUM , position ) , word Relation ) ; word Relation . add Word ( STRING ) ; expand Real ( number String . substring ( position + NUM ) , word Relation ) ; } else if ( ( position = number String . index Of ( STRING ) ) != - NUM ) { String before Dot = number String . substring ( NUM , position ) ; if ( before Dot . length ( ) > NUM ) { expand Real ( before Dot , word Relation ) ; } word Relation . add Word ( STRING ) ; String after Dot = number String . substring ( position + NUM ) ; if ( after Dot . length ( ) > NUM ) { expand Digits ( after Dot , word Relation ) ; } } else { expand Number ( number String , word Relation ) ; } }
public Distribution ( Distribution to Merge ) { tota L = to Merge . tota L ; m per Class = new double [ to Merge . num Classes ( ) ] ; System . arraycopy ( to Merge . m per Class , NUM , m per Class , NUM , to Merge . num Classes ( ) ) ; m per Class Per Bag = new double [ NUM ] [ NUM ] ; m per Class Per Bag [ NUM ] = new double [ to Merge . num Classes ( ) ] ; System . arraycopy ( to Merge . m per Class , NUM , m per Class Per Bag [ NUM ] , NUM , to Merge . num Classes ( ) ) ; m per Bag = new double [ NUM ] ; m per Bag [ NUM ] = tota L ; }
public void test Compute Location When Ejb Packaging ( ) throws Exception { Deployable deployable Element = new Deployable ( ) ; deployable Element . set Group Id ( STRING ) ; deployable Element . set Artifact Id ( STRING ) ; deployable Element . set Type ( STRING ) ; String location = deployable Element . compute Location ( create Default Project ( STRING , null ) ) ; assert True ( location . ends With ( STRING ) ) ; }
private static < T > void execute Script ( final File file , final T plugin Interface ) { final List < Pair < String , Object > > bindings = new Array List < > ( ) ; final Console Writer console Writer = new Console Writer ( new String Writer ( ) ) ; bindings . add ( new Pair < String , Object > ( STRING , plugin Interface ) ) ; bindings . add ( new Pair < String , Object > ( STRING , console Writer ) ) ; try { Script Runner . run Script ( file , bindings ) ; if ( console Writer . get Output ( ) != null ) { Navi Logger . info ( console Writer . get Output ( ) ) ; } } catch ( final Exception exception ) { final String message = STRING + STRING ; final String description = C Utility Functions . create Description ( String . format ( STRING + STRING + STRING , file . get Absolute File ( ) ) , new String [ ] { STRING } , new String [ ] { STRING + STRING } ) ; Navi Logger . severe ( message ) ; C Utility Functions . log Exception ( exception ) ; Navi Logger . severe ( console Writer . get Output ( ) ) ; Navi Error Dialog . show ( null , message , description , exception ) ; } }
public static Delete Sub Command Handler create ( Sub Command Argument Parser parser , Managed Object Path < ? , ? > p , Instantiable Relation Definition < ? , ? > r ) throws Argument Exception { return new Delete Sub Command Handler ( parser , p , r , p . child ( r , STRING ) ) ; }
private void trace ( Var Node node , Print Stream ps , Hash Set < Node > visited Nodes , int level ) { if ( level < NUM ) return ; ps . println ( STRING + translate Label ( node ) ) ; Node [ ] succs = pag . simple Inv Lookup ( node ) ; for ( int i = NUM ; i < succs . length ; i ++ ) { if ( visited Nodes . contains ( succs [ i ] ) ) continue ; ps . println ( STRING + translate Label ( succs [ i ] ) ) ; ps . println ( STRING + translate Edge ( node , succs [ i ] , STRING ) ) ; visited Nodes . add ( succs [ i ] ) ; trace ( ( Var Node ) succs [ i ] , ps , visited Nodes , level - NUM ) ; } succs = pag . alloc Inv Lookup ( node ) ; for ( int i = NUM ; i < succs . length ; i ++ ) { if ( visited Nodes . contains ( succs [ i ] ) ) continue ; ps . println ( STRING + translate Label ( succs [ i ] ) ) ; ps . println ( STRING + translate Edge ( node , succs [ i ] , STRING ) ) ; } succs = vmatches . get ( node ) ; if ( succs != null ) { for ( int i = NUM ; i < succs . length ; i ++ ) { if ( visited Nodes . contains ( succs [ i ] ) ) continue ; ps . println ( STRING + translate Label ( succs [ i ] ) ) ; ps . println ( STRING + translate Edge ( node , succs [ i ] , STRING ) ) ; trace ( ( Var Node ) succs [ i ] , ps , visited Nodes , level - NUM ) ; } } }
public String to String ( Double Matrix 3 D matrix ) { String Buffer buf = new String Buffer ( ) ; boolean old Print Shape = this . print Shape ; this . print Shape = BOOL ; for ( int slice = NUM ; slice < matrix . slices ( ) ; slice ++ ) { if ( slice != NUM ) buf . append ( slice Separator ) ; buf . append ( to String ( matrix . view Slice ( slice ) ) ) ; } this . print Shape = old Print Shape ; if ( print Shape ) buf . insert ( NUM , shape ( matrix ) + STRING ) ; return buf . to String ( ) ; }
@ Override public synchronized void start Manager ( ) { try { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STRING ) ; } Runtime rt = Runtime . get Runtime ( ) ; this . pooled Membership Executor = Executors . new Fixed Thread Pool ( rt . available Processors ( ) ) ; running = BOOL ; start Managing Activity ( ) ; messenger . broadcast Manager Info ( ) ; } catch ( Interrupted Exception e ) { running = BOOL ; throw new Management Exception ( e ) ; } catch ( Exception e ) { running = BOOL ; throw new Management Exception ( e ) ; } }
public Core Admin Handler ( final Core Container core Container ) { this . core Container = core Container ; Hash Map < String , Map < String , Task Object > > map = new Hash Map < > ( NUM , NUM ) ; map . put ( RUNNING , Collections . synchronized Map ( new Linked Hash Map < String , Task Object > ( ) ) ) ; map . put ( COMPLETED , Collections . synchronized Map ( new Linked Hash Map < String , Task Object > ( ) ) ) ; map . put ( FAILED , Collections . synchronized Map ( new Linked Hash Map < String , Task Object > ( ) ) ) ; request Status Map = Collections . unmodifiable Map ( map ) ; }
protected Class < ? > resolve Proxy Class ( String [ ] interfaces ) throws IO Exception , Class Not Found Exception { Stream Checker checker = stream Checker ; if ( checker != null ) { checker . check Proxy Interface Names ( interfaces ) ; } Object annotation = read Location ( ) ; Class Loader default Loader = skip Default Resolve Class ? null : latest User Defined Loader ( ) ; String codebase = null ; if ( ! use Codebase Only && annotation instanceof String ) { codebase = ( String ) annotation ; } return RMI Class Loader . load Proxy Class ( codebase , interfaces , default Loader ) ; }
public void create And Send Move To Action ( final Point 2 D point , boolean double Click ) { final RP Action action = new RP Action ( ) ; action . put ( STRING , STRING ) ; action . put ( STRING , ( int ) point . get X ( ) ) ; action . put ( STRING , ( int ) point . get Y ( ) ) ; if ( double Click ) { action . put ( STRING , STRING ) ; } Direction dir = calculate Zone Change Direction ( point ) ; if ( dir != null ) { action . put ( STRING , dir . ordinal ( ) ) ; } client . send ( action ) ; }
public void append ( byte [ ] buffer , int offset , int length ) { if ( length + length >= capacity ) ensure Capacity ( length + length ) ; System . arraycopy ( buffer , offset , buffer , length , length ) ; length += length ; }
protected void create Triple Buffer ( int width , int height ) { try { triple Buffer = mx Utils . create Buffered Image ( width , height , null ) ; triple Buffer Graphics = triple Buffer . create Graphics ( ) ; mx Utils . set Anti Alias ( triple Buffer Graphics , anti Alias , text Anti Alias ) ; repaint Triple Buffer ( null ) ; } catch ( Out Of Memory Error error ) { } }
public static void rename Cube For Deletion ( int partition Count , String store Path , String schema Name , String cube Name ) { String cube Name With Partition = STRING ; String schema Name With Partition = STRING ; String full Path = STRING ; String new File Path = STRING ; String new File Name = STRING ; Callable < Void > c = null ; long time = System . current Time Millis ( ) ; File Factory . File Type file Type = null ; Executor Service executor Service = Executors . new Fixed Thread Pool ( NUM ) ; for ( int i = NUM ; i < partition Count ; i ++ ) { schema Name With Partition = schema Name + STRING + i ; cube Name With Partition = cube Name + STRING + i ; new File Name = cube Name With Partition + STRING + time ; full Path = store Path + File . separator + schema Name With Partition + File . separator + cube Name With Partition ; new File Path = store Path + File . separator + schema Name With Partition + File . separator + new File Name ; file Type = File Factory . get File Type ( full Path ) ; try { if ( File Factory . is File Exist ( full Path , file Type ) ) { Carbon File file = File Factory . get Carbon File ( full Path , file Type ) ; boolean is Rename Successfull = file . rename To ( new File Path ) ; if ( ! is Rename Successfull ) { LOGGER . error ( STRING + full Path ) ; c = new Delete Cube ( file ) ; executor Service . submit ( c ) ; } else { c = new Delete Cube ( File Factory . get Carbon File ( new File Path , file Type ) ) ; executor Service . submit ( c ) ; } } } catch ( IO Exception e ) { LOGGER . error ( STRING + full Path ) ; } } executor Service . shutdown ( ) ; }
protected void do Validate Int Contents ( String path , String filename , int start , int end ) { File in File = new File ( path , filename ) ; Data Input Stream in Stream = null ; Log . i ( LOG TAG , STRING + filename + STRING + path ) ; try { in Stream = new Data Input Stream ( new File Input Stream ( in File ) ) ; for ( int i = start ; i < end ; ++ i ) { if ( in Stream . read Int ( ) != i ) { fail ( STRING ) ; } } if ( in Stream != null ) { in Stream . close ( ) ; } Log . i ( LOG TAG , STRING + filename ) ; } catch ( File Not Found Exception e ) { fail ( STRING + in File + STRING + e . to String ( ) ) ; } catch ( IO Exception e ) { fail ( STRING + in File + STRING + e . to String ( ) ) ; } }
public static NBT Tag make ( Input Stream is ) throws Exception { NBT Tag ret = null ; Data Input Stream stream = new Data Input Stream ( is ) ; byte t = stream . read Byte ( ) ; int type = ( int ) t ; String name = STRING ; if ( type > NUM ) name = stream . read UTF ( ) ; switch ( type ) { case NUM : ret = new TAG End ( name ) ; break ; case NUM : ret = new TAG Byte ( name ) ; break ; case NUM : ret = new TAG Short ( name ) ; break ; case NUM : ret = new TAG Int ( name ) ; break ; case NUM : ret = new TAG Long ( name ) ; break ; case NUM : ret = new TAG Float ( name ) ; break ; case NUM : ret = new TAG Double ( name ) ; break ; case NUM : ret = new TAG Byte Array ( name ) ; break ; case NUM : ret = new TAG String ( name ) ; break ; case NUM : ret = new TAG List ( name ) ; break ; case NUM : ret = new TAG Compound ( name ) ; break ; case NUM : ret = new TAG Int Array ( name ) ; break ; default : throw ( new Exception ( STRING + type ) ) ; } ret . parse ( stream ) ; return ret ; }
public Format Result apply Mask ( String mask , String value , String old Value , Integer cursor Index ) { if ( mask == null || value == null ) { return null ; } if ( old Value . length ( ) > value . length ( ) ) { return new Format Result ( value , null ) ; } value = ( String ) get Mask Or Get Cursor Index ( mask , value , cursor Index , BOOL ) ; cursor Index = ( Integer ) get Mask Or Get Cursor Index ( mask , value , cursor Index , BOOL ) ; return new Format Result ( value , cursor Index ) ; }
private void test Zen Mode With Duration ( int mode , long duration Millis ) { final long start Time Millis = System . current Time Millis ( ) ; m Partner Interface . set Zen Mode With Duration ( mode , duration Millis ) ; final int actual Zen Mode = get Zen Mode ( ) ; if ( duration Millis == NUM ) { assert True ( actual Zen Mode == mode || actual Zen Mode == Partner Interface . ZEN MODE OFF ) ; } else { assert Equals ( mode , actual Zen Mode ) ; } if ( actual Zen Mode == Partner Interface . ZEN MODE OFF || duration Millis < NUM || duration Millis == Long . MAX VALUE ) { return ; } final long zen Duration = get Zen Mode Duration ( start Time Millis ) ; assert True ( Math . abs ( zen Duration - duration Millis ) <= DURATION TOLERANCE MS ) ; }
protected boolean read Data Record ( int lon index ) { try { if ( bin File == null ) { if ( ! reopen ( ) ) { return BOOL ; } } bin File . seek ( UHL SIZE + DSI SIZE + ACC SIZE + ( lon index * ( NUM + ( NUM * uhl . num lat points ) ) ) ) ; bin File . read ( ) ; bin File . skip Bytes ( NUM ) ; bin File . read Short ( ) ; bin File . read Short ( ) ; elevations [ lon index ] = new short [ uhl . num lat points ] ; for ( int j = NUM ; j < uhl . num lat points ; j ++ ) { elevations [ lon index ] [ j ] = bin File . read Short Data ( ) ; } } catch ( IO Exception e3 ) { Debug . error ( STRING ) ; e3 . print Stack Trace ( ) ; elevations [ lon index ] = null ; return BOOL ; } catch ( Format Exception f ) { Debug . error ( STRING ) ; elevations [ lon index ] = null ; return BOOL ; } return BOOL ; }
private void save Memory Block JPG ( Image Data image Data , File file , float quality ) throws Exception { Buffered Image buffered Image = get Buffered Image From Data ( image Data ) ; Iterator iter = Image IO . get Image Writers By Format Name ( STRING ) ; Image Writer writer = ( Image Writer ) iter . next ( ) ; Image Write Param iwp = writer . get Default Write Param ( ) ; iwp . set Compression Mode ( Image Write Param . MODE EXPLICIT ) ; iwp . set Compression Quality ( quality ) ; File Image Output Stream output = null ; try { output = new File Image Output Stream ( file ) ; writer . set Output ( output ) ; IIO Image image = new IIO Image ( buffered Image , null , null ) ; writer . write ( null , image , iwp ) ; add Scan File ( file ) ; } catch ( Exception e ) { throw e ; } finally { if ( output != null ) { output . close ( ) ; } } }
@ Override public int compare To ( Scout Widget scout Widget ) { if ( m Parent == null ) { return - NUM ; } if ( m Root Distance != scout Widget . m Root Distance ) { return Float . compare ( m Root Distance , scout Widget . m Root Distance ) ; } if ( mY != scout Widget . mY ) { return Float . compare ( mY , scout Widget . mY ) ; } if ( mX != scout Widget . mX ) { return Float . compare ( mX , scout Widget . mX ) ; } return NUM ; }
